!> \file
!> \author Chris Bradley
!> \brief The top level OpenCMISS Iron module.
!>
!> \mainpage OpenCMISS Iron Documentation
!>
!> An open source interactive computer program for Continuum Mechanics, Image analysis, Signal processing and System
!> Identification. Target usage: Bioengineering application of finite element analysis, boundary element and collocation
!> techniques.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s): Chris Bradley
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>
!>

! Eclipse regular expressions to add the DLLEXPORT macro:
! Find: ^( *)(SUBROUTINE *)([^\(]*)(\([^\)]*\))
! Replace: $1$2$3$4\R$1  !DLLEXPORT($3)

!> \defgroup OpenCMISS_Iron OpenCMISS::Iron
!> The top level OpenCMISS Iron module. This module is the buffer Fortran module between the OpenCMISS Iron library and user code.
MODULE OpenCMISS_Iron

 USE AnalyticAnalysisRoutines
 USE BaseRoutines
 USE BasisRoutines
 USE BasisAccessRoutines
 USE BioelectricFiniteElasticityRoutines
 USE BoundaryConditionsRoutines
 USE BoundaryConditionAccessRoutines
 USE CellMLAccessRoutines
 USE Cmiss
 USE CmissPetsc
 USE CmissCellML
 USE ComputationRoutines
 USE ComputationAccessRoutines
 USE Constants
 USE ContextRoutines
 USE ContextAccessRoutines
 USE ControlLoopRoutines
 USE ControlLoopAccessRoutines
 USE CoordinateSystemRoutines
 USE CoordinateSystemAccessRoutines
 USE DataPointRoutines
 USE DataPointAccessRoutines
 USE DataProjectionRoutines
 USE DataProjectionAccessRoutines
 USE DecompositionRoutines
 USE DecompositionAccessRoutines
 USE DistributedMatrixVector
 USE DistributedMatrixVectorAccessRoutines
 USE EquationsRoutines
 USE EquationsMappingAccessRoutines
 USE EquationsMatricesAccessRoutines
 USE EquationsSetRoutines
 USE EquationsSetAccessRoutines
 USE FieldRoutines
 USE FieldAccessRoutines
#ifdef WITH_FIELDML
 USE FIELDML_TYPES
 USE FIELDML_INPUT_ROUTINES
 USE FIELDML_OUTPUT_ROUTINES
 USE FIELDML_UTIL_ROUTINES
#endif
 USE FIELD_IO_ROUTINES
 USE FiniteElasticityRoutines
 USE GeneratedMeshRoutines
 USE GeneratedMeshAccessRoutines
 USE HamiltonJacobiRoutines
 USE HISTORY_ROUTINES
 USE InputOutput
 USE InterfaceRoutines
 USE InterfaceAccessRoutines
 USE InterfaceConditionRoutines
 USE InterfaceConditionAccessRoutines
 USE InterfaceEquationsRoutines
 USE InterfaceMatricesRoutines
 USE InterfaceMatricesAccessRoutines
 USE ISO_C_BINDING
 USE ISO_VARYING_STRING
 USE Kinds
 USE MeshRoutines
 USE MeshAccessRoutines
 USE NodeRoutines
 USE ProblemRoutines
 USE ProblemAccessRoutines
 USE RegionRoutines
 USE RegionAccessRoutines
 USE SolverRoutines
 USE SolverAccessRoutines
 USE SolverMatricesAccessRoutines
 USE Strings
 USE Types

#include "macros.h"
#include "dllexport.h"

 IMPLICIT NONE

 PRIVATE

 !Module parameters

 !Module types

 !>Contains information about a basis function.
 TYPE cmfe_BasisType
   PRIVATE
   TYPE(BasisType), POINTER :: basis
 END TYPE cmfe_BasisType

 !>Contains information on the boundary conditions for the equations set.
 TYPE cmfe_BoundaryConditionsType
   PRIVATE
   TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
 END TYPE cmfe_BoundaryConditionsType

 !>Contains information on a CellML environment.
 TYPE cmfe_CellMLType
   PRIVATE
   TYPE(CellMLType), POINTER :: cellml
 END TYPE cmfe_CellMLType

 !>Contains information about the CellML equations for a solver.
 TYPE cmfe_CellMLEquationsType
   PRIVATE
   TYPE(CellMLEquationsType), POINTER :: cellmlEquations
 END TYPE cmfe_CellMLEquationsType

 !>Contains information on a computation environment
 TYPE cmfe_ComputationEnvironmentType
   PRIVATE
   TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
 END TYPE cmfe_ComputationEnvironmentType

 !>Contains information on a context.
 TYPE cmfe_ContextType
   PRIVATE
   TYPE(ContextType), POINTER :: context
 END TYPE cmfe_ContextType

 !>Contains information on a control loop.
 TYPE cmfe_ControlLoopType
   PRIVATE
   TYPE(ControlLoopType), POINTER :: controlLoop
 END TYPE cmfe_ControlLoopType

 !>Contains information on a coordinate system.
 TYPE cmfe_CoordinateSystemType
   PRIVATE
   TYPE(CoordinateSystemType), POINTER :: coordinateSystem
 END TYPE cmfe_CoordinateSystemType

 !>Contains information on the data points defined on a region.
 TYPE cmfe_DataPointsType
   PRIVATE
   TYPE(DataPointsType), POINTER :: dataPoints
 END TYPE cmfe_DataPointsType

 !>Contains information about a data projection.
 TYPE cmfe_DataProjectionType
   PRIVATE
   TYPE(DataProjectionType), POINTER :: dataProjection
 END TYPE cmfe_DataProjectionType

 !>Contains information on the mesh decomposition.
 TYPE cmfe_DecompositionType
   PRIVATE
   TYPE(DecompositionType), POINTER :: decomposition
 END TYPE cmfe_DecompositionType

 !>Contains information on the decomposer.
 TYPE cmfe_DecomposerType
   PRIVATE
   TYPE(DecomposerType), POINTER :: decomposer
 END TYPE cmfe_DecomposerType

 !>Contains information about the equations in an equations set.
 TYPE cmfe_EquationsType
   PRIVATE
   TYPE(EquationsType), POINTER :: equations
 END TYPE cmfe_EquationsType

 !>Contains information on an equations set defined on a region.
 TYPE cmfe_EquationsSetType
   PRIVATE
   TYPE(EquationsSetType), POINTER :: equationsSet
 END TYPE cmfe_EquationsSetType

 !>Contains information for a field defined on a region.
 TYPE cmfe_FieldType
   PRIVATE
   TYPE(FieldType), POINTER :: field
 END TYPE cmfe_FieldType

 !>Contains information for a fields defined on a region.
 TYPE cmfe_FieldsType
   !PRIVATE
   TYPE(FieldsType), POINTER :: fields
 END TYPE cmfe_FieldsType

 !>Contains information on a generated mesh.
 TYPE cmfe_GeneratedMeshType
   PRIVATE
   TYPE(GeneratedMeshType), POINTER :: generatedMesh
 END TYPE cmfe_GeneratedMeshType

 !>Contains information about a history file for a control loop.
 TYPE cmfe_HistoryType
   PRIVATE
   TYPE(HISTORY_TYPE), POINTER :: history
 END TYPE cmfe_HistoryType

 !>Contains information about an interface.
 TYPE cmfe_InterfaceType
   PRIVATE
   TYPE(InterfaceType), POINTER :: interface
 END TYPE cmfe_InterfaceType

 !>Contains information about an interface condition.
 TYPE cmfe_InterfaceConditionType
   PRIVATE
   TYPE(InterfaceConditionType), POINTER :: interfaceCondition
 END TYPE cmfe_InterfaceConditionType

 !>Contains information about an interface condition.
 TYPE cmfe_InterfaceEquationsType
   PRIVATE
   TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
 END TYPE cmfe_InterfaceEquationsType

  !>Contains information on an interfaces meshes connectivity.
 TYPE cmfe_InterfaceMeshConnectivityType
   PRIVATE
   TYPE(InterfaceMeshConnectivityType), POINTER :: meshConnectivity
 END TYPE cmfe_InterfaceMeshConnectivityType

 !>Contains information on an interfaces points connectivity.
 TYPE cmfe_InterfacePointsConnectivityType
   PRIVATE
   TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
 END TYPE cmfe_InterfacePointsConnectivityType

 !>A matrix that may be distributed across multiple computation nodes
 !>and may use sparse or full storage.
 TYPE cmfe_DistributedMatrixType
   PRIVATE
   TYPE(DistributedMatrixType), POINTER :: distributedMatrix
 END TYPE cmfe_DistributedMatrixType

 !>A vector that may be distributed across multiple computation nodes
 TYPE cmfe_DistributedVectorType
   PRIVATE
   TYPE(DistributedVectorType), POINTER :: distributedVector
 END TYPE cmfe_DistributedVectorType

 !>Contains information on a mesh defined on a region.
 TYPE cmfe_MeshType
   PRIVATE
   TYPE(MeshType), POINTER :: mesh
 END TYPE cmfe_MeshType

 !>Contains information on a mesh elements defined in a mesh
 TYPE cmfe_MeshElementsType
   PRIVATE
   TYPE(MeshElementsType), POINTER :: meshElements
 END TYPE cmfe_MeshElementsType

 !>Contains information on an embedded mesh
 TYPE cmfe_MeshEmbeddingType
   PRIVATE
   TYPE(MESH_EMBEDDING_TYPE), POINTER :: meshEmbedding
 END TYPE cmfe_MeshEmbeddingType

 !>Contains information on a mesh nodes defined in a mesh
 TYPE cmfe_MeshNodesType
   PRIVATE
   TYPE(MeshNodesType), POINTER :: meshNodes
 END TYPE cmfe_MeshNodesType

 !>Contains information on the nodes defined on a region.
 TYPE cmfe_NodesType
   PRIVATE
   TYPE(NodesType), POINTER :: nodes
 END TYPE cmfe_NodesType

 !>Contains information for a problem.
 TYPE cmfe_ProblemType
   PRIVATE
   TYPE(ProblemType), POINTER :: problem
 END TYPE cmfe_ProblemType

 !>Contains information for a particular quadrature scheme for a basis.
 TYPE cmfe_QuadratureType
   PRIVATE
   TYPE(QuadratureType), POINTER :: quadrature
 END TYPE cmfe_QuadratureType

 !>Contains information for a region.
 TYPE cmfe_RegionType
   PRIVATE
   TYPE(RegionType), POINTER :: region
 END TYPE cmfe_RegionType

 !>Contains information about a solver.
 TYPE cmfe_SolverType
   PRIVATE
   TYPE(SolverType), POINTER :: solver
 END TYPE cmfe_SolverType

 !>Contains information about the solver equations for a solver.
 TYPE cmfe_SolverEquationsType
   PRIVATE
   TYPE(SolverEquationsType), POINTER :: solverEquations
 END TYPE cmfe_SolverEquationsType

 !>Contains information on a work group
 TYPE cmfe_WorkGroupType
   PRIVATE
   TYPE(WorkGroupType), POINTER :: workGroup
 END TYPE cmfe_WorkGroupType

 !Module variables

 TYPE(VARYING_STRING) :: error

 INTERFACE cmfe_Initialise
   MODULE PROCEDURE cmfe_InitialiseNumber
   MODULE PROCEDURE cmfe_InitialiseObj
 END INTERFACE cmfe_Initialise

 INTERFACE cmfe_Finalise
   MODULE PROCEDURE cmfe_FinaliseNumber
   MODULE PROCEDURE cmfe_FinaliseObj
 END INTERFACE cmfe_Finalise
 
 INTERFACE cmfe_Fields_Create
   MODULE PROCEDURE cmfe_Fields_CreateInterface
   MODULE PROCEDURE cmfe_Fields_CreateRegion
 END INTERFACE cmfe_Fields_Create

 PUBLIC cmfe_Finalise,cmfe_Initialise

 PUBLIC cmfe_WorkingRealPrecisionGet

 PUBLIC cmfe_PetscOptionsSetValue

 PUBLIC cmfe_BasisType,cmfe_BasisTypesCopy,cmfe_Basis_Finalise,cmfe_Basis_Initialise

 PUBLIC cmfe_BoundaryConditionsType,cmfe_BoundaryConditions_Finalise,cmfe_BoundaryConditions_Initialise

 PUBLIC cmfe_CellMLType,cmfe_CellML_Finalise,cmfe_CellML_Initialise

 PUBLIC cmfe_CellMLEquationsType,cmfe_CellMLEquations_Finalise,cmfe_CellMLEquations_Initialise

 PUBLIC cmfe_ComputationEnvironmentType,cmfe_ComputationEnvironment_Initialise,cmfe_ComputationEnvironment_Finalise

 PUBLIC cmfe_ContextType,cmfe_Context_Finalise,cmfe_Context_Initialise

 PUBLIC cmfe_ControlLoopType,cmfe_ControlLoop_Finalise,cmfe_ControlLoop_Initialise

 PUBLIC cmfe_CoordinateSystemType,cmfe_CoordinateSystem_Finalise,cmfe_CoordinateSystem_Initialise

 PUBLIC cmfe_DataPointsType,cmfe_DataPoints_Finalise,cmfe_DataPoints_Initialise

 PUBLIC cmfe_DataProjectionType,cmfe_DataProjection_Finalise,cmfe_DataProjection_Initialise

 PUBLIC cmfe_DecompositionType,cmfe_Decomposition_Finalise,cmfe_Decomposition_Initialise

 PUBLIC cmfe_DecomposerType,cmfe_Decomposer_Finalise,cmfe_Decomposer_Initialise

 PUBLIC cmfe_DistributedMatrixType,cmfe_DistributedVectorType

 PUBLIC cmfe_DistributedMatrix_Initialise,cmfe_DistributedVector_Initialise

 PUBLIC cmfe_EquationsType,cmfe_Equations_Finalise,cmfe_Equations_Initialise

 PUBLIC cmfe_EquationsSetType,cmfe_EquationsSet_Finalise,cmfe_EquationsSet_Initialise

 PUBLIC cmfe_FieldType,cmfe_Field_Finalise,cmfe_Field_Initialise

 PUBLIC cmfe_FieldsType,cmfe_Fields_Create,cmfe_Fields_Finalise,cmfe_Fields_Initialise

 PUBLIC cmfe_GeneratedMeshType,cmfe_GeneratedMesh_Finalise,cmfe_GeneratedMesh_Initialise

 PUBLIC cmfe_HistoryType,cmfe_History_Finalise,cmfe_History_Initialise

 PUBLIC cmfe_InterfaceType,cmfe_Interface_Finalise,cmfe_Interface_Initialise

 PUBLIC cmfe_InterfaceConditionType,cmfe_InterfaceCondition_Finalise,cmfe_InterfaceCondition_Initialise

 PUBLIC cmfe_InterfaceEquationsType,cmfe_InterfaceEquations_Finalise,cmfe_InterfaceEquations_Initialise

 PUBLIC cmfe_InterfaceMeshConnectivityType,cmfe_InterfaceMeshConnectivity_Finalise,cmfe_InterfaceMeshConnectivity_Initialise

 PUBLIC cmfe_InterfacePointsConnectivityType,cmfe_InterfacePointsConnectivity_Initialise,cmfe_InterfacePointsConnectivity_Finalise

 PUBLIC cmfe_MeshType,cmfe_Mesh_Finalise,cmfe_Mesh_Initialise

 PUBLIC cmfe_MeshElementsType,cmfe_MeshElements_Finalise,cmfe_MeshElements_Initialise

 PUBLIC cmfe_MeshNodesType,cmfe_MeshNodes_Finalise,cmfe_MeshNodes_Initialise

 PUBLIC cmfe_NodesType,cmfe_Nodes_Finalise,cmfe_Nodes_Initialise

 PUBLIC cmfe_ProblemType,cmfe_Problem_Finalise,cmfe_Problem_Initialise

 PUBLIC cmfe_QuadratureType,cmfe_Quadrature_Finalise,cmfe_Quadrature_Initialise

 PUBLIC cmfe_RegionType,cmfe_Region_Finalise,cmfe_Region_Initialise

 PUBLIC cmfe_SolverType,cmfe_Solver_Finalise,cmfe_Solver_Initialise

 PUBLIC cmfe_SolverEquationsType,cmfe_SolverEquations_Finalise,cmfe_SolverEquations_Initialise

 PUBLIC cmfe_WorkGroupType,cmfe_WorkGroup_Initialise,cmfe_WorkGroup_Finalise

!==================================================================================================================================
!
! AnalyticAnalysisRoutines
!
!==================================================================================================================================

 !Module parameters

 !Module types

 !Module variables

 !Interfaces

 !>Output the analytic error analysis for a field compared to the analytic values parameter set.
 INTERFACE cmfe_AnalyticAnalysis_Output
   MODULE PROCEDURE cmfe_AnalyticAnalysis_OutputNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_OutputObj
 END INTERFACE

 !>Get the absolute error of the node.
 INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetNode
   MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj
 END INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetNode

 !>Get the percentage error of the node.
 INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetNode
   MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj
 END INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetNode

 !>Get the relative error of the node.
 INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetNode
   MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj
 END INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetNode

 !>Get the absolute error of the element.
 INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetElement
   MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj
 END INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetElement

 !>Get the percentage error of the element.
 INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetElement
   MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetElementObj
 END INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetElement

 !>Get the relative error of the element.
 INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetElement
   MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetElementObj
 END INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetElement

 !>Get the absolute error of the constant.
 INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstant
   MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj
 END INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstant

 !>Get the percentage error of the constant.
 INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetConstant
   MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj
 END INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetConstant

 !>Get the relative error of the constant.
 INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetConstant
   MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj
 END INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetConstant

 !>Get the RMS error of nodes.
 INTERFACE cmfe_AnalyticAnalysis_RMSErrorGetNode
   MODULE PROCEDURE cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_RMSErrorGetNodeObj
 END INTERFACE cmfe_AnalyticAnalysis_RMSErrorGetNode

 !>Get the RMS error of elements.
 INTERFACE cmfe_AnalyticAnalysis_RMSErrorGetElement
   MODULE PROCEDURE cmfe_AnalyticAnalysis_RMSErrorGetElementNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_RMSErrorGetElementObj
 END INTERFACE cmfe_AnalyticAnalysis_RMSErrorGetElement

 !>Get integral of numerical values.
 INTERFACE cmfe_AnalyticAnalysis_IntegralNumericalValueGet
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj
 END INTERFACE cmfe_AnalyticAnalysis_IntegralNumericalValueGet

 !>Get integral of analytical values.
 INTERFACE cmfe_AnalyticAnalysis_IntegralAnalyticValueGet
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj
 END INTERFACE cmfe_AnalyticAnalysis_IntegralAnalyticValueGet

 !>Get integral of percentage errors.
 INTERFACE cmfe_AnalyticAnalysis_IntegralPercentageErrorGet
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj
 END INTERFACE cmfe_AnalyticAnalysis_IntegralPercentageErrorGet

 !>Get integral of absolute errors.
 INTERFACE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGet
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj
 END INTERFACE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGet

 !>Get integral of relative errors.
 INTERFACE cmfe_AnalyticAnalysis_IntegralRelativeErrorGet
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj
 END INTERFACE cmfe_AnalyticAnalysis_IntegralRelativeErrorGet

 !>Get integral of NID numerical errors.
 INTERFACE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGet
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetObj
 END INTERFACE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGet

 !>Get integral of NID errors.
 INTERFACE cmfe_AnalyticAnalysis_IntegralNIDErrorGet
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNIDErrorGetNumber
   MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj
 END INTERFACE cmfe_AnalyticAnalysis_IntegralNIDErrorGet

 PUBLIC cmfe_AnalyticAnalysis_Output

 PUBLIC cmfe_AnalyticAnalysis_AbsoluteErrorGetNode,cmfe_AnalyticAnalysis_PercentageErrorGetNode, &
   & cmfe_AnalyticAnalysis_RelativeErrorGetNode

 PUBLIC cmfe_AnalyticAnalysis_AbsoluteErrorGetElement,cmfe_AnalyticAnalysis_PercentageErrorGetElement, &
   & cmfe_AnalyticAnalysis_RelativeErrorGetElement

 PUBLIC cmfe_AnalyticAnalysis_AbsoluteErrorGetConstant,cmfe_AnalyticAnalysis_PercentageErrorGetConstant, &
   & cmfe_AnalyticAnalysis_RelativeErrorGetConstant

 PUBLIC cmfe_AnalyticAnalysis_RMSErrorGetNode,cmfe_AnalyticAnalysis_RMSErrorGetElement

 PUBLIC cmfe_AnalyticAnalysis_IntegralNumericalValueGet,cmfe_AnalyticAnalysis_IntegralAnalyticValueGet, &
   & cmfe_AnalyticAnalysis_IntegralPercentageErrorGet,cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGet, &
   & cmfe_AnalyticAnalysis_IntegralRelativeErrorGet,cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGet, &
   & cmfe_AnalyticAnalysis_IntegralNIDErrorGet

!==================================================================================================================================
!
! BaseRoutines
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_DiagnosticAndTimingConstants OpenCMISS::Iron::DiagnosticAndTiming::Constants
 !> \brief Diagnostic and Timing constants.
 !>@{
 !> \addtogroup OpenCMISS_DiagnosticTypes OpenCMISS::Iron::DiagnosticAndTiming::DiagnosticTypes
 !> \brief Diganostic constants.
 !> \see OpenCMISS::Iron::DiagnosticTypes,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_ALL_DIAG_TYPE = ALL_DIAG_TYPE !<Type for setting diagnostic output in all routines \see OpenCMISS_DiagnosticTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_IN_DIAG_TYPE = IN_DIAG_TYPE !<Type for setting diagnostic output in one routine \see OpenCMISS_DiagnosticTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FROM_DIAG_TYPE = FROM_DIAG_TYPE !<Type for setting diagnostic output in one routine downwards \see OpenCMISS_DiagnosticTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_TimingTypes OpenCMISS::Iron::DiagnosticAndTiming::TimingTypes
 !> \brief Timing constants.
 !> \see OpenCMISS::Iron::TimingTypes,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_ALL_TIMING_TYPE = ALL_TIMING_TYPE !<Type for setting timing output in all routines \see OpenCMISS_TimingTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_IN_TIMING_TYPE = IN_TIMING_TYPE !<Type for setting timing output in one routine \see OpenCMISS_TimingTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FROM_TIMING_TYPE = FROM_TIMING_TYPE !<Type for setting timing output from one routine downwards \see OpenCMISS_TimingTypes,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 PUBLIC CMFE_ALL_DIAG_TYPE,CMFE_IN_DIAG_TYPE,CMFE_FROM_DIAG_TYPE

 PUBLIC CMFE_ALL_TIMING_TYPE,CMFE_IN_TIMING_TYPE,CMFE_FROM_TIMING_TYPE

 PUBLIC cmfe_DiagnosticsSetOff,cmfe_DiagnosticsSetOn

 PUBLIC cmfe_OutputSetOff,cmfe_OutputSetOn

 PUBLIC cmfe_TimingSetOff,cmfe_TimingSetOn,cmfe_TimingSummaryOutput

!==================================================================================================================================
!
! BasisRoutines
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_BasisConstants OpenCMISS::Iron::Basis::Constants
 !> \brief Basis function constants.
 !>@{
 !> \addtogroup OpenCMISS_BasisTypes OpenCMISS::Iron::Basis::BasisTypes
 !> \brief Basis definition type parameters.
 !> \see OpenCMISS::Iron::BasisConstants,OpenCMISS
 !>@{ 
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_LAGRANGE_HERMITE_TP_TYPE = BASIS_LAGRANGE_HERMITE_TP_TYPE !<Lagrange-Hermite tensor product basis type \see OpenCMISS_BasisTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_SIMPLEX_TYPE = BASIS_SIMPLEX_TYPE !<Simplex basis type \see OpenCMISS_BasisTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_SERENDIPITY_TYPE = BASIS_SERENDIPITY_TYPE !<Serendipity basis type \see OpenCMISS_BasisTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_AUXILLIARY_TYPE = BASIS_AUXILLIARY_TYPE !<Auxillary basis type \see OpenCMISS_BasisTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_B_SPLINE_TP_TYPE = BASIS_B_SPLINE_TP_TYPE !<B-spline basis type \see OpenCMISS_BasisTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE = BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE !<Fourier-Lagrange tensor product basis type \see OpenCMISS_BasisTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_EXTENDED_LAGRANGE_TP_TYPE = BASIS_EXTENDED_LAGRANGE_TP_TYPE !< Extendend Lagrange tensor product basis type \see OpenCMISS_BasisTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_BasisInterpolationSpecifications OpenCMISS::Iron::Basis::InterpolationSpecifications
 !> \brief Interpolation specification parameters
 !> \see OpenCMISS::Iron::BasisConstants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_LINEAR_LAGRANGE_INTERPOLATION = BASIS_LINEAR_LAGRANGE_INTERPOLATION !<Linear Lagrange interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_QUADRATIC_LAGRANGE_INTERPOLATION = BASIS_QUADRATIC_LAGRANGE_INTERPOLATION !<Quadratic Lagrange interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_CUBIC_LAGRANGE_INTERPOLATION = BASIS_CUBIC_LAGRANGE_INTERPOLATION !<Cubic Lagrange interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_CUBIC_HERMITE_INTERPOLATION = BASIS_CUBIC_HERMITE_INTERPOLATION !<Cubic Hermite interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_QUADRATIC1_HERMITE_INTERPOLATION = BASIS_QUADRATIC1_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=0) interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_QUADRATIC2_HERMITE_INTERPOLATION = BASIS_QUADRATIC2_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=1) interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_LINEAR_SIMPLEX_INTERPOLATION = BASIS_LINEAR_SIMPLEX_INTERPOLATION !<Linear Simplex interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_QUADRATIC_SIMPLEX_INTERPOLATION = BASIS_QUADRATIC_SIMPLEX_INTERPOLATION !<Quadratic Simplex interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_CUBIC_SIMPLEX_INTERPOLATION = BASIS_CUBIC_SIMPLEX_INTERPOLATION !<Cubic Simplex interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_BasisQuadratureSchemes OpenCMISS::Iron::Basis::QuadratureSchemes
 !> \brief Quadrature scheme parameters
 !> \see OpenCMISS::Iron::BasisConstants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_DEFAULT_QUADRATURE_SCHEME = BASIS_DEFAULT_QUADRATURE_SCHEME !<Identifier for the default quadrature scheme \see OpenCMISS_BasisQuadratureSchemes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_LOW_QUADRATURE_SCHEME = BASIS_LOW_QUADRATURE_SCHEME !<Identifier for a low order quadrature scheme \see OpenCMISS_BasisQuadratureSchemes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_MID_QUADRATURE_SCHEME = BASIS_MID_QUADRATURE_SCHEME !<Identifier for a mid order quadrature scheme \see OpenCMISS_BasisQuadratureSchemes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_HIGH_QUADRATURE_SCHEME = BASIS_HIGH_QUADRATURE_SCHEME !<Identifier for a high order quadrature scheme \see OpenCMISS_BasisQuadratureSchemes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_BasisQuadratureTypes OpenCMISS::Iron::Basis::QuadratureTypes
 !> \brief Basis quadrature type parameters.
 !> \see OpenCMISS::Iron::BasisConstants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_GAUSS_LEGENDRE_QUADRATURE = BASIS_GAUSS_LEGENDRE_QUADRATURE !<Gauss-Legendre quadrature \see OpenCMISS_BasisQuadratureTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_GAUSS_LAGUERRE_QUADRATURE = BASIS_GAUSS_LAGUERRE_QUADRATURE !<Gauss-Laguerre quadrature \see OpenCMISS_BasisQuadratureTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_GUASS_HERMITE_QUADRATURE = BASIS_GUASS_HERMITE_QUADRATURE !<Gauss-Hermite quadrature \see OpenCMISS_BasisQuadratureTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE = BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE !<Adaptive Gauss-Legendre quadrature \see OpenCMISS_BasisQuadratureTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_GAUSS_SIMPLEX_QUADRATURE = BASIS_GAUSS_SIMPLEX_QUADRATURE !<Gauss-Legendre for Simplex elements quadrature \see OpenCMISS_BasisQuadratureTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_BasisXiCollapse OpenCMISS::Iron::Basis::XiCollapse
 !> \brief Basis Xi collapse parameters.
 !> \see OpenCMISS::Iron::Basis,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_XI_COLLAPSED = BASIS_XI_COLLAPSED !<The Xi direction is collapsed \see OpenCMISS_BasisXiCollapse,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_COLLAPSED_AT_XI0 = BASIS_COLLAPSED_AT_XI0 !<The Xi direction at the xi=0 end of this Xi direction is collapsed \see OpenCMISS_BasisXiCollapse,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_COLLAPSED_AT_XI1 = BASIS_COLLAPSED_AT_XI1 !<The Xi direction at the xi=1 end of this Xi direction is collapsed \see OpenCMISS_BasisXiCollapse,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_BASIS_NOT_COLLAPSED = BASIS_NOT_COLLAPSED !<The Xi direction is not collapsed \see OpenCMISS_BasisXiCollapse,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Returns the collapsed Xi flags for a basis.
 INTERFACE cmfe_Basis_CollapsedXiGet
   MODULE PROCEDURE cmfe_Basis_CollapsedXiGetNumber
   MODULE PROCEDURE cmfe_Basis_CollapsedXiGetObj
 END INTERFACE cmfe_Basis_CollapsedXiGet

 !>Sets/changes the collapsed Xi flags for a basis.
 INTERFACE cmfe_Basis_CollapsedXiSet
   MODULE PROCEDURE cmfe_Basis_CollapsedXiSetNumber
   MODULE PROCEDURE cmfe_Basis_CollapsedXiSetObj
 END INTERFACE cmfe_Basis_CollapsedXiSet

 !>Finishes the creation of a new basis. \see OpenCMISS::Iron::cmfe_Basis_CreateStart
 INTERFACE cmfe_Basis_CreateFinish
   MODULE PROCEDURE cmfe_Basis_CreateFinishNumber
   MODULE PROCEDURE cmfe_Basis_CreateFinishObj
 END INTERFACE cmfe_Basis_CreateFinish

 !>Starts the creation of a new basis. \see OpenCMISS::Iron::cmfe_Basis_CreateFinish
 INTERFACE cmfe_Basis_CreateStart
   MODULE PROCEDURE cmfe_Basis_CreateStartNumber
   MODULE PROCEDURE cmfe_Basis_CreateStartObj
 END INTERFACE cmfe_Basis_CreateStart

 !>Destroys a basis.
 INTERFACE cmfe_Basis_Destroy
   MODULE PROCEDURE cmfe_Basis_DestroyNumber
   MODULE PROCEDURE cmfe_Basis_DestroyObj
 END INTERFACE cmfe_Basis_Destroy

 !>Get the interpolation type in each Xi directions for a basis.
 INTERFACE cmfe_Basis_InterpolationXiGet
   MODULE PROCEDURE cmfe_Basis_InterpolationXiGetNumber
   MODULE PROCEDURE cmfe_Basis_InterpolationXiGetObj
 END INTERFACE cmfe_Basis_InterpolationXiGet

 !>Sets/changes the interpolation type in each Xi directions for a basis.
 INTERFACE cmfe_Basis_InterpolationXiSet
   MODULE PROCEDURE cmfe_Basis_InterpolationXiSetNumber
   MODULE PROCEDURE cmfe_Basis_InterpolationXiSetObj
 END INTERFACE cmfe_Basis_InterpolationXiSet

 !>Returns the number of local nodes in a basis.
 INTERFACE cmfe_Basis_NumberOfLocalNodesGet
   MODULE PROCEDURE cmfe_Basis_NumberOfLocalNodesGetNumber
   MODULE PROCEDURE cmfe_Basis_NumberOfLocalNodesGetObj
 END INTERFACE cmfe_Basis_NumberOfLocalNodesGet

 !>Returns the number of Xi directions in a basis.
 INTERFACE cmfe_Basis_NumberOfXiGet
   MODULE PROCEDURE cmfe_Basis_NumberOfXiGetNumber
   MODULE PROCEDURE cmfe_Basis_NumberOfXiGetObj
 END INTERFACE cmfe_Basis_NumberOfXiGet

 !>Sets/changes the number of Xi directions in a basis.
 INTERFACE cmfe_Basis_NumberOfXiSet
   MODULE PROCEDURE cmfe_Basis_NumberOfXiSetNumber
   MODULE PROCEDURE cmfe_Basis_NumberOfXiSetObj
 END INTERFACE cmfe_Basis_NumberOfXiSet

 !>Returns the number of Gauss points in each Xi direction on a basis quadrature.
 INTERFACE cmfe_Basis_QuadratureNumberOfGaussXiGet
   MODULE PROCEDURE cmfe_Basis_QuadratureNumberOfGaussXiGetNumber
   MODULE PROCEDURE cmfe_Basis_QuadratureNumberOfGaussXiGetObj
 END INTERFACE cmfe_Basis_QuadratureNumberOfGaussXiGet

 !>Sets/changes the number of Gauss points in each Xi direction on a basis quadrature.
 INTERFACE cmfe_Basis_QuadratureNumberOfGaussXiSet
   MODULE PROCEDURE cmfe_Basis_QuadratureNumberOfGaussXiSetNumber
   MODULE PROCEDURE cmfe_Basis_QuadratureNumberOfGaussXiSetObj
 END INTERFACE cmfe_Basis_QuadratureNumberOfGaussXiSet

 !>Returns the xi positions of Gauss points on a basis quadrature.
 INTERFACE cmfe_Basis_QuadratureGaussXiGet
   MODULE PROCEDURE cmfe_Basis_QuadratureGaussXiGetNumber0
   MODULE PROCEDURE cmfe_Basis_QuadratureGaussXiGetObj0
   MODULE PROCEDURE cmfe_Basis_QuadratureGaussXiGetNumber1
   MODULE PROCEDURE cmfe_Basis_QuadratureGaussXiGetObj1
 END INTERFACE cmfe_Basis_QuadratureGaussXiGet

 !>Returns the order of quadrature for a basis quadrature.
 INTERFACE cmfe_Basis_QuadratureOrderGet
   MODULE PROCEDURE cmfe_Basis_QuadratureOrderGetNumber
   MODULE PROCEDURE cmfe_Basis_QuadratureOrderGetObj
 END INTERFACE cmfe_Basis_QuadratureOrderGet

 !>Sets/changes the order of quadrature for a basis quadrature.
 INTERFACE cmfe_Basis_QuadratureOrderSet
   MODULE PROCEDURE cmfe_Basis_QuadratureOrderSetNumber
   MODULE PROCEDURE cmfe_Basis_QuadratureOrderSetObj
 END INTERFACE cmfe_Basis_QuadratureOrderSet

 !>Returns the quadrature type for a basis quadrature.
 INTERFACE cmfe_Basis_QuadratureTypeGet
   MODULE PROCEDURE cmfe_Basis_QuadratureTypeGetNumber
   MODULE PROCEDURE cmfe_Basis_QuadratureTypeGetObj
 END INTERFACE cmfe_Basis_QuadratureTypeGet

 !>Sets/changes the quadrature type for a basis quadrature.
 INTERFACE cmfe_Basis_QuadratureTypeSet
   MODULE PROCEDURE cmfe_Basis_QuadratureTypeSetNumber
   MODULE PROCEDURE cmfe_Basis_QuadratureTypeSetObj
 END INTERFACE cmfe_Basis_QuadratureTypeSet

 !>Sets/changes the local face gauss evaluatoin flag for a basis quadrature.
 INTERFACE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSet
   MODULE PROCEDURE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber
   MODULE PROCEDURE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj
 END INTERFACE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSet

 !>Returns the type of a basis.
 INTERFACE cmfe_Basis_TypeGet
   MODULE PROCEDURE cmfe_Basis_TypeGetNumber
   MODULE PROCEDURE cmfe_Basis_TypeGetObj
 END INTERFACE cmfe_Basis_TypeGet

 !>Sets/changes the type of a basis.
 INTERFACE cmfe_Basis_TypeSet
   MODULE PROCEDURE cmfe_Basis_TypeSetNumber
   MODULE PROCEDURE cmfe_Basis_TypeSetObj
 END INTERFACE cmfe_Basis_TypeSet

 PUBLIC CMFE_BASIS_LAGRANGE_HERMITE_TP_TYPE,CMFE_BASIS_SIMPLEX_TYPE,CMFE_BASIS_SERENDIPITY_TYPE,CMFE_BASIS_AUXILLIARY_TYPE, &
   & CMFE_BASIS_B_SPLINE_TP_TYPE,CMFE_BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE,CMFE_BASIS_EXTENDED_LAGRANGE_TP_TYPE

 PUBLIC CMFE_BASIS_LINEAR_LAGRANGE_INTERPOLATION,CMFE_BASIS_QUADRATIC_LAGRANGE_INTERPOLATION, &
   & CMFE_BASIS_CUBIC_LAGRANGE_INTERPOLATION, &
   & CMFE_BASIS_CUBIC_HERMITE_INTERPOLATION,CMFE_BASIS_QUADRATIC1_HERMITE_INTERPOLATION, &
   & CMFE_BASIS_QUADRATIC2_HERMITE_INTERPOLATION, &
   & CMFE_BASIS_LINEAR_SIMPLEX_INTERPOLATION,CMFE_BASIS_QUADRATIC_SIMPLEX_INTERPOLATION,CMFE_BASIS_CUBIC_SIMPLEX_INTERPOLATION

 PUBLIC CMFE_BASIS_DEFAULT_QUADRATURE_SCHEME,CMFE_BASIS_LOW_QUADRATURE_SCHEME,CMFE_BASIS_MID_QUADRATURE_SCHEME, &
   & CMFE_BASIS_HIGH_QUADRATURE_SCHEME

 PUBLIC CMFE_BASIS_GAUSS_LEGENDRE_QUADRATURE,CMFE_BASIS_GAUSS_LAGUERRE_QUADRATURE,CMFE_BASIS_GUASS_HERMITE_QUADRATURE, &
   & CMFE_BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE,CMFE_BASIS_GAUSS_SIMPLEX_QUADRATURE

 PUBLIC CMFE_BASIS_XI_COLLAPSED,CMFE_BASIS_COLLAPSED_AT_XI0,CMFE_BASIS_COLLAPSED_AT_XI1,CMFE_BASIS_NOT_COLLAPSED

 PUBLIC cmfe_Basis_CollapsedXiGet,cmfe_Basis_CollapsedXiSet

 PUBLIC cmfe_Basis_CreateFinish,cmfe_Basis_CreateStart,cmfe_Basis_Destroy

 PUBLIC cmfe_Basis_InterpolationXiGet,cmfe_Basis_InterpolationXiSet

 PUBLIC cmfe_Basis_NumberOfLocalNodesGet

 PUBLIC cmfe_Basis_NumberOfXiGet,cmfe_Basis_NumberOfXiSet

 PUBLIC cmfe_Basis_QuadratureNumberOfGaussXiGet,cmfe_Basis_QuadratureNumberOfGaussXiSet

 PUBLIC cmfe_Basis_QuadratureGaussXiGet

 PUBLIC cmfe_Basis_QuadratureOrderGet,cmfe_Basis_QuadratureOrderSet

 PUBLIC cmfe_Basis_QuadratureTypeGet,cmfe_Basis_QuadratureTypeSet,cmfe_Basis_QuadratureLocalFaceGaussEvaluateSet

 PUBLIC cmfe_Basis_TypeGet,cmfe_Basis_TypeSet

!==================================================================================================================================
!
! BoundaryConditionsRoutines
!
!==================================================================================================================================

 !Module parameters


 !> \addtogroup OpenCMISS_BoundaryConditionsConstants OpenCMISS::Iron::BoundaryConditions::Constants
 !> \brief Boundary conditions constants.
 !>@{
 !> \addtogroup OpenCMISS_BoundaryConditionsTypes OpenCMISS::Iron::BoundaryConditions::Types
 !> \brief Specific boundary condition types, which might only be applicable to certain equation sets.
 !> \see OpenCMISS::Iron::BoundaryConditions,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_NONE = BOUNDARY_CONDITION_NONE !<The dof is free.
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED = BOUNDARY_CONDITION_FIXED !<The dof is fixed as a boundary condition.
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_WALL = BOUNDARY_CONDITION_FIXED_WALL
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_INLET = BOUNDARY_CONDITION_FIXED_INLET
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_OUTLET = BOUNDARY_CONDITION_FIXED_OUTLET
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_MOVED_WALL = BOUNDARY_CONDITION_MOVED_WALL
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED = BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FREE_WALL = BOUNDARY_CONDITION_FREE_WALL
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_NEUMANN_POINT = BOUNDARY_CONDITION_NEUMANN_POINT !<Specify the normal derivative at a node, which is then integrated to find the nodal load term
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED = BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED !<Specify the normal derivative at a node, which is then integrated to find the nodal load term. The value is incremented inside a load incremented control loop.
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_NEUMANN_INTEGRATED = BOUNDARY_CONDITION_NEUMANN_INTEGRATED !<Set the integrated right hand side load value directly
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_DIRICHLET = BOUNDARY_CONDITION_DIRICHLET
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_CAUCHY = BOUNDARY_CONDITION_CAUCHY
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_ROBIN = BOUNDARY_CONDITION_ROBIN

 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_INCREMENTED = BOUNDARY_CONDITION_FIXED_INCREMENTED
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_PRESSURE = BOUNDARY_CONDITION_PRESSURE
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_PRESSURE = BOUNDARY_CONDITION_FIXED_PRESSURE
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_PRESSURE_INCREMENTED = BOUNDARY_CONDITION_PRESSURE_INCREMENTED

 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE = BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_IMPERMEABLE_WALL = BOUNDARY_CONDITION_IMPERMEABLE_WALL
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY = BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY !<A Neumann integrated boundary condition, and no point values will be integrated over a face or line that includes this dof
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_FITTED = BOUNDARY_CONDITION_FIXED_FITTED
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_NONREFLECTING = BOUNDARY_CONDITION_FIXED_NONREFLECTING
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_CELLML = BOUNDARY_CONDITION_FIXED_CELLML
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_STREE = BOUNDARY_CONDITION_FIXED_STREE
 !>@}
 !> \addtogroup OpenCMISS_BoundaryConditionSparsityTypes OpenCMISS::Iron::BoundaryConditions::SparsityTypes
 !> \brief Storage type for matrices used by boundary conditions.
 !> \see OpenCMISS::Iron::BoundaryConditions,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_SPARSE_MATRICES = BOUNDARY_CONDITION_SPARSE_MATRICES
 INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FULL_MATRICES = BOUNDARY_CONDITION_FULL_MATRICES
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Destroys boundary conditions.
 INTERFACE cmfe_BoundaryConditions_Destroy
   MODULE PROCEDURE cmfe_BoundaryConditions_DestroyNumber0
   MODULE PROCEDURE cmfe_BoundaryConditions_DestroyNumber1
   MODULE PROCEDURE cmfe_BoundaryConditions_DestroyObj
 END INTERFACE cmfe_BoundaryConditions_Destroy

 !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant.
 INTERFACE cmfe_BoundaryConditions_AddConstant
   MODULE PROCEDURE cmfe_BoundaryConditions_AddConstantNumber
   MODULE PROCEDURE cmfe_BoundaryConditions_AddConstantObj
 END INTERFACE cmfe_BoundaryConditions_AddConstant

 !>Sets the value of the specified constant as a boundary condition on the specified constant.
 INTERFACE cmfe_BoundaryConditions_SetConstant
   MODULE PROCEDURE cmfe_BoundaryConditions_SetConstantNumber
   MODULE PROCEDURE cmfe_BoundaryConditions_SetConstantObj
 END INTERFACE cmfe_BoundaryConditions_SetConstant

 !>Adds to the value of the element constant and sets this as a boundary condition on the specified element.
 INTERFACE cmfe_BoundaryConditions_AddElement
   MODULE PROCEDURE cmfe_BoundaryConditions_AddElementNumber
   MODULE PROCEDURE cmfe_BoundaryConditions_AddElementObj
 END INTERFACE cmfe_BoundaryConditions_AddElement

 !>Sets the value of the specified element as a boundary condition on the specified element.
 INTERFACE cmfe_BoundaryConditions_SetElement
   MODULE PROCEDURE cmfe_BoundaryConditions_SetElementNumber
   MODULE PROCEDURE cmfe_BoundaryConditions_SetElementObj
 END INTERFACE cmfe_BoundaryConditions_SetElement

 !>Adds to the value of the node constant and sets this as a boundary condition on the specified node.
 INTERFACE cmfe_BoundaryConditions_AddNode
   MODULE PROCEDURE cmfe_BoundaryConditions_AddNodeNumber
   MODULE PROCEDURE cmfe_BoundaryConditions_AddNodeObj
 END INTERFACE cmfe_BoundaryConditions_AddNode

 !>Sets the value of the specified node as a boundary condition on the specified node.
 INTERFACE cmfe_BoundaryConditions_SetNode
   MODULE PROCEDURE cmfe_BoundaryConditions_SetNodeNumber0
   MODULE PROCEDURE cmfe_BoundaryConditions_SetNodeNumber1
   MODULE PROCEDURE cmfe_BoundaryConditions_SetNodeObj
 END INTERFACE cmfe_BoundaryConditions_SetNode

 !>Sets the matrix sparsity type for Neumann integration matrices, used when integrating Neumann point values.
 INTERFACE cmfe_BoundaryConditions_NeumannSparsityTypeSet
   MODULE PROCEDURE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0
   MODULE PROCEDURE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1
   MODULE PROCEDURE cmfe_BoundaryConditions_NeumannSparsityTypeSetObj
 END INTERFACE cmfe_BoundaryConditions_NeumannSparsityTypeSet

 !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
 INTERFACE cmfe_BoundaryConditions_ConstrainNodeDofsEqual
   MODULE PROCEDURE cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber
   MODULE PROCEDURE cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj
 END INTERFACE cmfe_BoundaryConditions_ConstrainNodeDofsEqual

 PUBLIC CMFE_BOUNDARY_CONDITION_NONE,CMFE_BOUNDARY_CONDITION_FIXED, &
   & CMFE_BOUNDARY_CONDITION_FIXED_WALL,CMFE_BOUNDARY_CONDITION_FIXED_INLET,CMFE_BOUNDARY_CONDITION_MOVED_WALL, &
   & CMFE_BOUNDARY_CONDITION_FREE_WALL,CMFE_BOUNDARY_CONDITION_FIXED_OUTLET,CMFE_BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED, &
   & CMFE_BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE,CMFE_BOUNDARY_CONDITION_IMPERMEABLE_WALL, &
   & CMFE_BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY,CMFE_BOUNDARY_CONDITION_FIXED_FITTED, &
   & CMFE_BOUNDARY_CONDITION_FIXED_NONREFLECTING,CMFE_BOUNDARY_CONDITION_FIXED_CELLML,CMFE_BOUNDARY_CONDITION_FIXED_STREE

 PUBLIC CMFE_BOUNDARY_CONDITION_NEUMANN_POINT,CMFE_BOUNDARY_CONDITION_NEUMANN_INTEGRATED,CMFE_BOUNDARY_CONDITION_DIRICHLET
 PUBLIC CMFE_BOUNDARY_CONDITION_CAUCHY,CMFE_BOUNDARY_CONDITION_ROBIN,CMFE_BOUNDARY_CONDITION_FIXED_INCREMENTED
 PUBLIC CMFE_BOUNDARY_CONDITION_PRESSURE,CMFE_BOUNDARY_CONDITION_FIXED_PRESSURE,CMFE_BOUNDARY_CONDITION_PRESSURE_INCREMENTED
 PUBLIC CMFE_BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED

 PUBLIC CMFE_BOUNDARY_CONDITION_SPARSE_MATRICES,CMFE_BOUNDARY_CONDITION_FULL_MATRICES

 PUBLIC cmfe_BoundaryConditions_Destroy

 PUBLIC cmfe_BoundaryConditions_AddConstant,cmfe_BoundaryConditions_SetConstant

 PUBLIC cmfe_BoundaryConditions_AddElement,cmfe_BoundaryConditions_SetElement

 PUBLIC cmfe_BoundaryConditions_AddNode,cmfe_BoundaryConditions_SetNode

 PUBLIC cmfe_BoundaryConditions_NeumannSparsityTypeSet

 PUBLIC cmfe_BoundaryConditions_ConstrainNodeDofsEqual

!==================================================================================================================================
!
! CMISS
!
!==================================================================================================================================

 !Module parameters
 !> \addtogroup OpenCMISS_CMISSConstants OpenCMISS::Iron::cmfe_::Constants
 !> \brief CMISS constants.
 !>@{
 !> \addtogroup OpenCMISS_CMISSErrorHandlingModes OpenCMISS::Iron::cmfe_::ErrorHandlingModes
 !> \brief CMISS error handling mode parameters
 !> \see OpenCMISS::Iron::cmfe_,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_ERRORS_RETURN_ERROR_CODE = CMFE_RETURN_ERROR_CODE !<Just return the error code \see OpenCMISS_CMISSErrorHandlingModes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_ERRORS_OUTPUT_ERROR = CMFE_OUTPUT_ERROR !<Output the error traceback and return the error code \see OpenCMISS_CMISSErrorHandlingModes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_ERRORS_TRAP_ERROR = CMFE_TRAP_ERROR!<Trap the error by outputing the error traceback and stopping the program \see OpenCMISS_CMISSErrorHandlingModes,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Extracts the OpenCMISS error message.
 INTERFACE cmfe_ExtractErrorMessage
   MODULE PROCEDURE cmfe_ExtractErrorMessageC
   MODULE PROCEDURE cmfe_ExtractErrorMessageVS
 END INTERFACE cmfe_ExtractErrorMessage

 !>Extracts the OpenCMISS error stack.
 INTERFACE cmfe_ExtractErrorStack
   MODULE PROCEDURE cmfe_ExtractErrorStackC
   MODULE PROCEDURE cmfe_ExtractErrorStackVS
 END INTERFACE cmfe_ExtractErrorStack

 PUBLIC CMFE_ERRORS_RETURN_ERROR_CODE,CMFE_ERRORS_OUTPUT_ERROR,CMFE_ERRORS_TRAP_ERROR

 PUBLIC cmfe_ErrorHandlingModeGet,cmfe_ErrorHandlingModeSet

 PUBLIC cmfe_ExtractErrorMessage,cmfe_ExtractErrorStack

!==================================================================================================================================
!
! CmissCellML
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_CellMLConstants OpenCMISS::Iron::CellML::Constants
 !> \brief CellML constants.
 !>@{
 !> \addtogroup OpenCMISS_CellMLFieldTypes OpenCMISS::Iron::CellML::FieldTypes
 !> \brief CellML field type parameters.
 !> \see OpenCMISS::Iron::CellML,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_CELLML_MODELS_FIELD = CELLML_MODELS_FIELD !<CellML models field type \see OpenCMISS_CellMLFieldTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CELLML_STATE_FIELD = CELLML_STATE_FIELD !<CellML state field type \see OpenCMISS_CellMLFieldTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CELLML_INTERMEDIATE_FIELD = CELLML_INTERMEDIATE_FIELD !<CellML intermediate field type \see OpenCMISS_CellMLFieldTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CELLML_PARAMETERS_FIELD = CELLML_PARAMETERS_FIELD !<CellML parameters field type \see OpenCMISS_CellMLFieldTypes,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Set a CellML model variable as being known (the value will be set from an OpenCMISS field)
 INTERFACE cmfe_CellML_VariableSetAsKnown
   MODULE PROCEDURE cmfe_CellML_VariableSetAsKnownNumberC
   MODULE PROCEDURE cmfe_CellML_VariableSetAsKnownObjC
   MODULE PROCEDURE cmfe_CellML_VariableSetAsKnownNumberVS
   MODULE PROCEDURE cmfe_CellML_VariableSetAsKnownObjVS
 END INTERFACE cmfe_CellML_VariableSetAsKnown

 !>Set a CellML model variable as being wanted (the value will be extracted from the model to an OpenCMISS field)
 INTERFACE cmfe_CellML_VariableSetAsWanted
   MODULE PROCEDURE cmfe_CellML_VariableSetAsWantedNumberC
   MODULE PROCEDURE cmfe_CellML_VariableSetAsWantedObjC
   MODULE PROCEDURE cmfe_CellML_VariableSetAsWantedNumberVS
   MODULE PROCEDURE cmfe_CellML_VariableSetAsWantedObjVS
 END INTERFACE cmfe_CellML_VariableSetAsWanted

 !>Map a CellML model variable to a field variable component in this CellML environment.
 INTERFACE cmfe_CellML_CreateCellMLToFieldMap
   MODULE PROCEDURE cmfe_CellML_CreateCellMLToFieldMapNumberC
   MODULE PROCEDURE cmfe_CellML_CreateCellMLToFieldMapObjC
   MODULE PROCEDURE cmfe_CellML_CreateCellMLToFieldMapNumberVS
   MODULE PROCEDURE cmfe_CellML_CreateCellMLToFieldMapObjVS
 END INTERFACE cmfe_CellML_CreateCellMLToFieldMap

 !>Map a field variable component to a CellML model variable in this CellML environment.
 INTERFACE cmfe_CellML_CreateFieldToCellMLMap
   MODULE PROCEDURE cmfe_CellML_CreateFieldToCellMLMapNumberC
   MODULE PROCEDURE cmfe_CellML_CreateFieldToCellMLMapObjC
   MODULE PROCEDURE cmfe_CellML_CreateFieldToCellMLMapNumberVS
   MODULE PROCEDURE cmfe_CellML_CreateFieldToCellMLMapObjVS
 END INTERFACE cmfe_CellML_CreateFieldToCellMLMap

 !>Finishes the creation of a CellML environment. \see OpenCMISS::Iron::cmfe_CellML_CreateStart
 INTERFACE cmfe_CellML_CreateFinish
   MODULE PROCEDURE cmfe_CellML_CreateFinishNumber
   MODULE PROCEDURE cmfe_CellML_CreateFinishObj
 END INTERFACE cmfe_CellML_CreateFinish

 !>Starts the creation of a CellML environment. \see OpenCMISS::Iron::cmfe_CellML_CreateFinish
 INTERFACE cmfe_CellML_CreateStart
   MODULE PROCEDURE cmfe_CellML_CreateStartNumber
   MODULE PROCEDURE cmfe_CellML_CreateStartObj
 END INTERFACE cmfe_CellML_CreateStart

 !>Destroys a CellML environment.
 INTERFACE cmfe_CellML_Destroy
   MODULE PROCEDURE cmfe_CellML_DestroyNumber
   MODULE PROCEDURE cmfe_CellML_DestroyObj
 END INTERFACE cmfe_CellML_Destroy

 !>Finishes the creation of field maps for a CellML environment. \see OpenCMISS::Iron::cmfe_CellML_FieldMapsCreateStart
 INTERFACE cmfe_CellML_FieldMapsCreateFinish
   MODULE PROCEDURE cmfe_CellML_FieldMapsCreateFinishNumber
   MODULE PROCEDURE cmfe_CellML_FieldMapsCreateFinishObj
 END INTERFACE cmfe_CellML_FieldMapsCreateFinish

 !>Starts the creation of field maps for a CellML environment. \see OpenCMISS::Iron::cmfe_CellML_FieldMapsCreateFinish
 INTERFACE cmfe_CellML_FieldMapsCreateStart
   MODULE PROCEDURE cmfe_CellML_FieldMapsCreateStartNumber
   MODULE PROCEDURE cmfe_CellML_FieldMapsCreateStartObj
 END INTERFACE cmfe_CellML_FieldMapsCreateStart

 !>Imports the specified CellML model into a CellML models environment.
 INTERFACE cmfe_CellML_ModelImport
   MODULE PROCEDURE cmfe_CellML_ModelImportNumberC
   MODULE PROCEDURE cmfe_CellML_ModelImportObjC
   MODULE PROCEDURE cmfe_CellML_ModelImportNumberVS
   MODULE PROCEDURE cmfe_CellML_ModelImportObjVS
 END INTERFACE cmfe_CellML_ModelImport

 !>Finishes the creation of CellML models field. \see OpenCMISS::Iron::cmfe_CellML_ModelsFieldCreateStart
 INTERFACE cmfe_CellML_ModelsFieldCreateFinish
   MODULE PROCEDURE cmfe_CellML_ModelsFieldCreateFinishNumber
   MODULE PROCEDURE cmfe_CellML_ModelsFieldCreateFinishObj
 END INTERFACE cmfe_CellML_ModelsFieldCreateFinish

 !>Starts the creation of CellML models field. \see OpenCMISS::Iron::cmfe_CellML_ModelsFieldCreateFinish
 INTERFACE cmfe_CellML_ModelsFieldCreateStart
   MODULE PROCEDURE cmfe_CellML_ModelsFieldCreateStartNumber
   MODULE PROCEDURE cmfe_CellML_ModelsFieldCreateStartObj
 END INTERFACE cmfe_CellML_ModelsFieldCreateStart

 !>Returns the CellML models field for a CellML environment.
 INTERFACE cmfe_CellML_ModelsFieldGet
   MODULE PROCEDURE cmfe_CellML_ModelsFieldGetNumber
   MODULE PROCEDURE cmfe_CellML_ModelsFieldGetObj
 END INTERFACE cmfe_CellML_ModelsFieldGet

 !>Finishes the creation of CellML state field. \see OpenCMISS::Iron::cmfe_CellML_StateFieldCreateStart
 INTERFACE cmfe_CellML_StateFieldCreateFinish
   MODULE PROCEDURE cmfe_CellML_StateFieldCreateFinishNumber
   MODULE PROCEDURE cmfe_CellML_StateFieldCreateFinishObj
 END INTERFACE cmfe_CellML_StateFieldCreateFinish

 !>Starts the creation of CellML state field. \see OpenCMISS::Iron::cmfe_CellML_StateFieldCreateFinish
 INTERFACE cmfe_CellML_StateFieldCreateStart
   MODULE PROCEDURE cmfe_CellML_StateFieldCreateStartNumber
   MODULE PROCEDURE cmfe_CellML_StateFieldCreateStartObj
 END INTERFACE cmfe_CellML_StateFieldCreateStart

 !>Returns the CellML state field for a CellML environment.
 INTERFACE cmfe_CellML_StateFieldGet
   MODULE PROCEDURE cmfe_CellML_StateFieldGetNumber
   MODULE PROCEDURE cmfe_CellML_StateFieldGetObj
 END INTERFACE cmfe_CellML_StateFieldGet

 !>Returns the component for a given CellML field that corresponds to the specified CellML variable ID.
 INTERFACE cmfe_CellML_FieldComponentGet
   MODULE PROCEDURE cmfe_CellML_FieldComponentGetNumberC
   MODULE PROCEDURE cmfe_CellML_FieldComponentGetObjC
   MODULE PROCEDURE cmfe_CellML_FieldComponentGetNumberVS
   MODULE PROCEDURE cmfe_CellML_FieldComponentGetObjVS
 END INTERFACE cmfe_CellML_FieldComponentGet

 !>Finishes the creation of CellML intermediate field. \see OpenCMISS::Iron::cmfe_CellML_IntermediateFieldCreateStart
 INTERFACE cmfe_CellML_IntermediateFieldCreateFinish
   MODULE PROCEDURE cmfe_CellML_IntermediateFieldCreateFinishNumber
   MODULE PROCEDURE cmfe_CellML_IntermediateFieldCreateFinishObj
 END INTERFACE cmfe_CellML_IntermediateFieldCreateFinish

 !>Starts the creation of CellML intermediate field. \see OpenCMISS::Iron::cmfe_CellML_IntermediateFieldCreateFinish
 INTERFACE cmfe_CellML_IntermediateFieldCreateStart
   MODULE PROCEDURE cmfe_CellML_IntermediateFieldCreateStartNumber
   MODULE PROCEDURE cmfe_CellML_IntermediateFieldCreateStartObj
 END INTERFACE cmfe_CellML_IntermediateFieldCreateStart

 !>Returns the CellML intermediate field for a CellML environment.
 INTERFACE cmfe_CellML_IntermediateFieldGet
   MODULE PROCEDURE cmfe_CellML_IntermediateFieldGetNumber
   MODULE PROCEDURE cmfe_CellML_IntermediateFieldGetObj
 END INTERFACE cmfe_CellML_IntermediateFieldGet

 !>Finishes the creation of CellML parameters field. \see OpenCMISS::Iron::cmfe_CellML_ParametersFieldCreateStart
 INTERFACE cmfe_CellML_ParametersFieldCreateFinish
   MODULE PROCEDURE cmfe_CellML_ParametersFieldCreateFinishNumber
   MODULE PROCEDURE cmfe_CellML_ParametersFieldCreateFinishObj
 END INTERFACE cmfe_CellML_ParametersFieldCreateFinish

 !>Starts the creation of CellML parameters field. \see OpenCMISS::Iron::cmfe_CellML_ParametersFieldCreateFinish
 INTERFACE cmfe_CellML_ParametersFieldCreateStart
   MODULE PROCEDURE cmfe_CellML_ParametersFieldCreateStartNumber
   MODULE PROCEDURE cmfe_CellML_ParametersFieldCreateStartObj
 END INTERFACE cmfe_CellML_ParametersFieldCreateStart

 !>Returns the CellML parameters field for a CellML environment.
 INTERFACE cmfe_CellML_ParametersFieldGet
   MODULE PROCEDURE cmfe_CellML_ParametersFieldGetNumber
   MODULE PROCEDURE cmfe_CellML_ParametersFieldGetObj
 END INTERFACE cmfe_CellML_ParametersFieldGet

 !>Validate and instantiate the specified CellML environment.
 INTERFACE cmfe_CellML_Generate
   MODULE PROCEDURE cmfe_CellML_GenerateNumber
   MODULE PROCEDURE cmfe_CellML_GenerateObj
 END INTERFACE cmfe_CellML_Generate

 PUBLIC CMFE_CELLML_MODELS_FIELD,CMFE_CELLML_STATE_FIELD,CMFE_CELLML_INTERMEDIATE_FIELD,CMFE_CELLML_PARAMETERS_FIELD

 PUBLIC cmfe_CellML_VariableSetAsKnown,cmfe_CellML_VariableSetAsWanted

 PUBLIC cmfe_CellML_CreateCellMLToFieldMap,cmfe_CellML_CreateFieldToCellMLMap

 PUBLIC cmfe_CellML_CreateFinish,cmfe_CellML_CreateStart

 PUBLIC cmfe_CellML_Destroy

 PUBLIC cmfe_CellML_FieldMapsCreateStart,cmfe_CellML_FieldMapsCreateFinish

 PUBLIC cmfe_CellML_ModelImport

 PUBLIC cmfe_CellML_ModelsFieldCreateFinish,cmfe_CellML_ModelsFieldCreateStart,cmfe_CellML_ModelsFieldGet

 PUBLIC cmfe_CellML_StateFieldCreateFinish,cmfe_CellML_StateFieldCreateStart,cmfe_CellML_StateFieldGet

 PUBLIC cmfe_CellML_FieldComponentGet

 PUBLIC cmfe_CellML_IntermediateFieldCreateFinish,cmfe_CellML_IntermediateFieldCreateStart

 PUBLIC cmfe_CellML_IntermediateFieldGet

 PUBLIC cmfe_CellML_ParametersFieldCreateFinish,cmfe_CellML_ParametersFieldCreateStart,cmfe_CellML_ParametersFieldGet

 PUBLIC cmfe_CellML_Generate

!==================================================================================================================================
!
! Computation
!
!==================================================================================================================================

 !Module parameters

 !Module types

 !Module variables

 !Interfaces

 !>Returns the number of world nodes in the computation environment
 INTERFACE cmfe_ComputationEnvironment_NumberOfWorldNodesGet
   MODULE PROCEDURE cmfe_ComputationEnvironment_NumberOfWorldNodesGetNumber
   MODULE PROCEDURE cmfe_ComputationEnvironment_NumberOfWorldNodesGetObj
 END INTERFACE cmfe_ComputationEnvironment_NumberOfWorldNodesGet
   
 !>Returns the world communicator for the computation environment
 INTERFACE cmfe_ComputationEnvironment_WorldCommunicatorGet
   MODULE PROCEDURE cmfe_ComputationEnvironment_WorldCommunicatorGetNumber
   MODULE PROCEDURE cmfe_ComputationEnvironment_WorldCommunicatorGetObj
 END INTERFACE cmfe_ComputationEnvironment_WorldCommunicatorGet
   
 !>Returns the world node number for the computation environment
 INTERFACE cmfe_ComputationEnvironment_WorldNodeNumberGet
   MODULE PROCEDURE cmfe_ComputationEnvironment_WorldNodeNumberGetNumber
   MODULE PROCEDURE cmfe_ComputationEnvironment_WorldNodeNumberGetObj
 END INTERFACE cmfe_ComputationEnvironment_WorldNodeNumberGet
   
 !>Returns the world work group for the computation environment
 INTERFACE cmfe_ComputationEnvironment_WorldWorkGroupGet
   MODULE PROCEDURE cmfe_ComputationEnvironment_WorldWorkGroupGetNumber
   MODULE PROCEDURE cmfe_ComputationEnvironment_WorldWorkGroupGetObj
 END INTERFACE cmfe_ComputationEnvironment_WorldWorkGroupGet
   
 !>Starts the creation of a work group
 INTERFACE cmfe_WorkGroup_CreateStart
   MODULE PROCEDURE cmfe_WorkGroup_CreateStartNumber
   MODULE PROCEDURE cmfe_WorkGroup_CreateStartObj
 END INTERFACE cmfe_WorkGroup_CreateStart
   
 !>Finishes the creation of a work group
 INTERFACE cmfe_WorkGroup_CreateFinish
   MODULE PROCEDURE cmfe_WorkGroup_CreateFinishNumber
   MODULE PROCEDURE cmfe_WorkGroup_CreateFinishObj
 END INTERFACE cmfe_WorkGroup_CreateFinish
   
 !>Destroys a work group
 INTERFACE cmfe_WorkGroup_Destroy
   MODULE PROCEDURE cmfe_WorkGroup_DestroyNumber
   MODULE PROCEDURE cmfe_WorkGroup_DestroyObj
 END INTERFACE cmfe_WorkGroup_Destroy
   
 !>Gets the group communicator for a work group
 INTERFACE cmfe_WorkGroup_GroupCommunicatorGet
   MODULE PROCEDURE cmfe_WorkGroup_GroupCommunicatorGetNumber
   MODULE PROCEDURE cmfe_WorkGroup_GroupCommunicatorGetObj
 END INTERFACE cmfe_WorkGroup_GroupCommunicatorGet
   
 !>Returns the label of a work group.
 INTERFACE cmfe_WorkGroup_LabelGet
   MODULE PROCEDURE cmfe_WorkGroup_LabelGetCNumber
   MODULE PROCEDURE cmfe_WorkGroup_LabelGetCObj
   MODULE PROCEDURE cmfe_WorkGroup_LabelGetVSNumber
   MODULE PROCEDURE cmfe_WorkGroup_LabelGetVSObj
 END INTERFACE cmfe_WorkGroup_LabelGet
 
 !>Sets/changes the label of a work group.
 INTERFACE cmfe_WorkGroup_LabelSet
   MODULE PROCEDURE cmfe_WorkGroup_LabelSetCNumber
   MODULE PROCEDURE cmfe_WorkGroup_LabelSetCObj
   MODULE PROCEDURE cmfe_WorkGroup_LabelSetVSNumber
   MODULE PROCEDURE cmfe_WorkGroup_LabelSetVSObj
 END INTERFACE cmfe_WorkGroup_LabelSet

 !>Gets the group node number in a work group
 INTERFACE cmfe_WorkGroup_GroupNodeNumberGet
   MODULE PROCEDURE cmfe_WorkGroup_GroupNodeNumberGetNumber
   MODULE PROCEDURE cmfe_WorkGroup_GroupNodeNumberGetObj
 END INTERFACE cmfe_WorkGroup_GroupNodeNumberGet
   
 !>Gets the number of group nodes in a work group
 INTERFACE cmfe_WorkGroup_NumberOfGroupNodesGet
   MODULE PROCEDURE cmfe_WorkGroup_NumberOfGroupNodesGetNumber
   MODULE PROCEDURE cmfe_WorkGroup_NumberOfGroupNodesGetObj
 END INTERFACE cmfe_WorkGroup_NumberOfGroupNodesGet
   
 !>Sets/changes the number of group nodes in a work group
 INTERFACE cmfe_WorkGroup_NumberOfGroupNodesSet
   MODULE PROCEDURE cmfe_WorkGroup_NumberOfGroupNodesSetNumber
   MODULE PROCEDURE cmfe_WorkGroup_NumberOfGroupNodesSetObj
 END INTERFACE cmfe_WorkGroup_NumberOfGroupNodesSet
 
 PUBLIC cmfe_ComputationEnvironment_NumberOfWorldNodesGet

 PUBLIC cmfe_ComputationEnvironment_WorldCommunicatorGet
 
 PUBLIC cmfe_ComputationEnvironment_WorldNodeNumberGet

 PUBLIC cmfe_ComputationEnvironment_WorldWorkGroupGet

 PUBLIC cmfe_WorkGroup_CreateStart

 PUBLIC cmfe_WorkGroup_CreateFinish

 PUBLIC cmfe_WorkGroup_Destroy

 PUBLIC cmfe_WorkGroup_GroupCommunicatorGet

 PUBLIC cmfe_WorkGroup_GroupNodeNumberGet

 PUBLIC cmfe_WorkGroup_LabelGet,cmfe_WorkGroup_LabelSet

 PUBLIC cmfe_WorkGroup_NumberOfGroupNodesGet,cmfe_WorkGroup_NumberOfGroupNodesSet
 
!==================================================================================================================================
!
! ContextRoutines
!
!==================================================================================================================================

 !Module parameters

 !Module types

 !Module variables

 !Interfaces

 !>Gets the computation environment for an OpenCMISS context.
 INTERFACE cmfe_Context_ComputationEnvironmentGet
   MODULE PROCEDURE cmfe_Context_ComputationEnvironmentGetNumber
   MODULE PROCEDURE cmfe_Context_ComputationEnvironmentGetObj
 END INTERFACE cmfe_Context_ComputationEnvironmentGet
 
 !>Gets the random seeds for an OpenCMISS context.
 INTERFACE cmfe_Context_RandomSeedsGet    
   MODULE PROCEDURE cmfe_Context_RandomSeedsGetNumber0
   MODULE PROCEDURE cmfe_Context_RandomSeedsGetNumber1
   MODULE PROCEDURE cmfe_Context_RandomSeedsGetObj0
   MODULE PROCEDURE cmfe_Context_RandomSeedsGetObj1
 END INTERFACE cmfe_Context_RandomSeedsGet

 !>Gets the size of the random seeds for an OpenCMISS context.
 INTERFACE cmfe_Context_RandomSeedsSizeGet    
   MODULE PROCEDURE cmfe_Context_RandomSeedsSizeGetNumber
   MODULE PROCEDURE cmfe_Context_RandomSeedsSizeGetObj
 END INTERFACE cmfe_Context_RandomSeedsSizeGet

 !>Sets the random seeds for an OpenCMISS context.
 INTERFACE cmfe_Context_RandomSeedsSet    
   MODULE PROCEDURE cmfe_Context_RandomSeedsSetNumber0
   MODULE PROCEDURE cmfe_Context_RandomSeedsSetNumber1
   MODULE PROCEDURE cmfe_Context_RandomSeedsSetObj0
   MODULE PROCEDURE cmfe_Context_RandomSeedsSetObj1
 END INTERFACE cmfe_Context_RandomSeedsSet

 !>Gets the world region for an OpenCMISS context.
 INTERFACE cmfe_Context_WorldRegionGet
   MODULE PROCEDURE cmfe_Context_WorldRegionGetNumber
   MODULE PROCEDURE cmfe_Context_WorldRegionGetObj
 END INTERFACE cmfe_Context_WorldRegionGet
 
 PUBLIC cmfe_Context_ComputationEnvironmentGet

 PUBLIC cmfe_Context_RandomSeedsGet,cmfe_Context_RandomSeedsSizeGet,cmfe_Context_RandomSeedsSet
 
 PUBLIC cmfe_Context_UserNumberGet

 PUBLIC cmfe_Context_WorldRegionGet
 
!==================================================================================================================================
!
! Constants
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_Constants OpenCMISS::Iron::Constants
 !> \brief OpeCMISS constants.
 !>@{
 !> \addtogroup OpenCMISS_DataTypeConstants OpenCMISS::Iron::Constants::DataTypeConstants
 !> \brief Data type constants for base data types
 !> \see OpenCMISS_Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_INTEGER_TYPE = INTEGER_TYPE !<Integer data type \see OpenCMISS_DataTypeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SHORT_INTEGER_TYPE = SHORT_INTEGER_TYPE !<Short integer data type \see OpenCMISS_DataTypeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_LONG_INTEGER_TYPE = LONG_INTEGER_TYPE !<Long integer data type \see OpenCMISS_DataTypeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SINGLE_REAL_TYPE = SINGLE_REAL_TYPE !<Single precision real data type \see OpenCMISS_DataTypeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DOUBLE_REAL_TYPE = DOUBLE_REAL_TYPE !<Double precision real data type \see OpenCMISS_DataTypeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_QUADRAUPLE_REAL_TYPE = QUADRUPLE_REAL_TYPE !<Quadruple precision real data type \see OpenCMISS_DataTypeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CHARACTER_TYPE = CHARACTER_TYPE !<Character data type \see OpenCMISS_DataTypeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_LOGICAL_TYPE = LOGICAL_TYPE !<Logical data type \see OpenCMISS_DataTypeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SINGLE_COMPLEX_TYPE = SINGLE_COMPLEX_TYPE !<Single precision complex data type \see OpenCMISS_DataTypeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DOUBLE_COMPLEX_TYPE = DOUBLE_COMPLEX_TYPE !<Double precision complex data type \see OpenCMISS_DataTypeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_QUADRUPLE_COMPLEX_TYPE = QUADRUPLE_COMPLEX_TYPE !<Quadruple precision complex data type \see OpenCMISS_DataTypeConstants,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_GlobalDerivativeConstants OpenCMISS::Iron::Constants::GlobalDerivativeConstants
 !> \brief Global derivative constant identifiers
 !> \see OpenCMISS_Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_NO_GLOBAL_DERIV = NO_GLOBAL_DERIV !<No global derivative i.e., u \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S1 = GLOBAL_DERIV_S1 !<First global derivative in the s1 direction i.e., du/ds1 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S2 = GLOBAL_DERIV_S2 !<First global derivative in the s2 direction i.e., du/ds2 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S1_S2 = GLOBAL_DERIV_S1_S2 !<Global Cross derivative in the s1 and s2 direction i.e., d^2u/ds1ds2 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S3 = GLOBAL_DERIV_S3 !<First global derivative in the s3 direction i.e., du/ds3 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S1_S3 = GLOBAL_DERIV_S1_S3 !<Global Cross derivative in the s1 and s3 direction i.e., d^2u/ds1ds3 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S2_S3 = GLOBAL_DERIV_S2_S3 !<Global Cross derivative in the s2 and s3 direction i.e., d^2u/ds2ds3 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S1_S2_S3 = GLOBAL_DERIV_S1_S2_S3 !<Cross derivative in the s1, s2 and s3 direction i.e., d^3u/ds1ds2ds3 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_PartialDerivativeConstants OpenCMISS::Iron::Constants::PartialDerivativeConstants
 !> \brief Partial derivative constant identifiers
 !> \see OpenCMISS_Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_NO_PARTIAL_DERIV=NO_PART_DERIV !<No partial derivative i.e., u \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S1=PART_DERIV_S1 !<First partial derivative in the s1 direction i.e., du/ds1 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S1_S1=PART_DERIV_S1_S1 !<Second partial derivative in the s1 direction i.e., d^2u/ds1ds1 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S2=PART_DERIV_S2 !<First partial derivative in the s2 direction i.e., du/ds2 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S2_S2=PART_DERIV_S2_S2 !<Second partial derivative in the s2 direction i.e., d^2u/ds2ds2 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S1_S2=PART_DERIV_S1_S2 !<Cross derivative in the s1 and s2 direction i.e., d^2u/ds1ds2 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S3=PART_DERIV_S3 !<First partial derivative in the s3 direction i.e., du/ds3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S3_S3=PART_DERIV_S3_S3 !<Second partial derivative in the s3 direction i.e., d^2u/ds3ds3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S1_S3=PART_DERIV_S1_S3 !<Cross derivative in the s1 and s3 direction i.e., d^2u/ds1ds3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S2_S3=PART_DERIV_S2_S3 !<Cross derivative in the s2 and s3 direction i.e., d^2u/ds2ds3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S1_S2_S3=PART_DERIV_S1_S2_S3 !<Cross derivative in the s1, s2 and s3 direction i.e., d^3u/ds1ds2ds3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S4=PART_DERIV_S4 !<First partial derivative in the s4 direction i.e., du/ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S4_S4=PART_DERIV_S4_S4 !<Second partial derivative in the s4 direction i.e., d^2u/ds4ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S1_S4=PART_DERIV_S1_S4 !<Cross derivative in the s1 and s4 direction i.e., d^2u/ds1ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S2_S4=PART_DERIV_S2_S4 !<Cross derivative in the s2 and s4 direction i.e., d^2u/ds2ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S3_S4=PART_DERIV_S3_S4 !<Cross derivative in the s3 and s4 direction i.e., d^2u/ds3ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S1_S2_S4=PART_DERIV_S1_S2_S4 !<Cross derivative in the s1, s2 and s4 direction i.e., d^3u/ds1ds2ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S1_S3_S4=PART_DERIV_S1_S3_S4 !<Cross derivative in the s1, s3 and s4 direction i.e., d^3u/ds1ds3ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S2_S3_S4=PART_DERIV_S2_S3_S4 !<Cross derivative in the s2, s3 and s4 direction i.e., d^3u/ds2ds3ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S1_S4_S4=PART_DERIV_S1_S4_S4 !<Cross derivative in the s2, s4 and s4 direction i.e., d^3u/ds1ds4^2 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS  
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S2_S4_S4=PART_DERIV_S2_S4_S4 !<Cross derivative in the s2, s4 and s4 direction i.e., d^3u/ds2ds4^2 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS  
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S3_S4_S4=PART_DERIV_S3_S4_S4 !<Cross derivative in the s3, s4 and s4 direction i.e., d^3u/ds3ds4^2 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS  
 INTEGER(INTG), PARAMETER :: CMFE_PARTIAL_DERIV_S4_S4_S4=PART_DERIV_S4_S4_S4 !<Third partial derivative in the s4 direction i.e., d^3u/ds4^3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_ElementNormalXiDirections OpenCMISS::Iron::Constants::ElementNormalXiDirections
 !> \brief Xi directions normal to element faces and lines.
 !> \see OpenCMISS_CONSTANTS,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_ELEMENT_NORMAL_MINUS_XI1 = ELEMENT_NORMAL_MINUS_XI1 !<Negative xi 1 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_ELEMENT_NORMAL_MINUS_XI2 = ELEMENT_NORMAL_MINUS_XI2 !<Negative xi 2 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_ELEMENT_NORMAL_MINUS_XI3 = ELEMENT_NORMAL_MINUS_XI3 !<Negative xi 3 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_ELEMENT_NORMAL_MINUS_XI4 = ELEMENT_NORMAL_MINUS_XI4 !<Negative xi 4 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_ELEMENT_NORMAL_PLUS_XI1 = ELEMENT_NORMAL_PLUS_XI1 !<Positive xi 1 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_ELEMENT_NORMAL_PLUS_XI2 = ELEMENT_NORMAL_PLUS_XI2 !<Positive xi 2 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_ELEMENT_NORMAL_PLUS_XI3 = ELEMENT_NORMAL_PLUS_XI3 !<Positive xi 3 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_ELEMENT_NORMAL_PLUS_XI4 = ELEMENT_NORMAL_PLUS_XI4 !<Positive xi 4 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 PUBLIC CMFE_INTEGER_TYPE,CMFE_SHORT_INTEGER_TYPE,CMFE_LONG_INTEGER_TYPE,CMFE_SINGLE_REAL_TYPE,CMFE_DOUBLE_REAL_TYPE, &
   & CMFE_QUADRAUPLE_REAL_TYPE,CMFE_CHARACTER_TYPE,CMFE_LOGICAL_TYPE,CMFE_SINGLE_COMPLEX_TYPE,CMFE_DOUBLE_COMPLEX_TYPE, &
   & CMFE_QUADRUPLE_COMPLEX_TYPE

 PUBLIC CMFE_NO_GLOBAL_DERIV,CMFE_GLOBAL_DERIV_S1,CMFE_GLOBAL_DERIV_S2,CMFE_GLOBAL_DERIV_S1_S2, &
   & CMFE_GLOBAL_DERIV_S3,CMFE_GLOBAL_DERIV_S1_S3,CMFE_GLOBAL_DERIV_S2_S3,CMFE_GLOBAL_DERIV_S1_S2_S3

 PUBLIC CMFE_NO_PARTIAL_DERIV,CMFE_PARTIAL_DERIV_S1,CMFE_PARTIAL_DERIV_S1_S1,CMFE_PARTIAL_DERIV_S2,CMFE_PARTIAL_DERIV_S2_S2, &
   & CMFE_PARTIAL_DERIV_S1_S2,CMFE_PARTIAL_DERIV_S3,CMFE_PARTIAL_DERIV_S3_S3,CMFE_PARTIAL_DERIV_S1_S3,CMFE_PARTIAL_DERIV_S2_S3, &
   & CMFE_PARTIAL_DERIV_S1_S2_S3,CMFE_PARTIAL_DERIV_S4,CMFE_PARTIAL_DERIV_S4_S4,CMFE_PARTIAL_DERIV_S1_S4, &
   & CMFE_PARTIAL_DERIV_S2_S4,CMFE_PARTIAL_DERIV_S3_S4,CMFE_PARTIAL_DERIV_S1_S2_S4,CMFE_PARTIAL_DERIV_S1_S3_S4, &
   & CMFE_PARTIAL_DERIV_S2_S3_S4,CMFE_PARTIAL_DERIV_S1_S4_S4,CMFE_PARTIAL_DERIV_S2_S4_S4,CMFE_PARTIAL_DERIV_S3_S4_S4, &
   & CMFE_PARTIAL_DERIV_S4_S4_S4

 PUBLIC CMFE_ELEMENT_NORMAL_MINUS_XI1,CMFE_ELEMENT_NORMAL_MINUS_XI2,CMFE_ELEMENT_NORMAL_MINUS_XI3,CMFE_ELEMENT_NORMAL_MINUS_XI4, &
   & CMFE_ELEMENT_NORMAL_PLUS_XI1,CMFE_ELEMENT_NORMAL_PLUS_XI2,CMFE_ELEMENT_NORMAL_PLUS_XI3,CMFE_ELEMENT_NORMAL_PLUS_XI4

!==================================================================================================================================
!
! CONTROL_LOOP_ROUTINES
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_ControlLoopConstants OpenCMISS::Iron::ControlLoop::Constants
 !> \brief Control loops constants.
 !>@{
 !> \addtogroup OpenCMISS_ControlLoopIdentifiers OpenCMISS::Iron::ControlLoop::Identifiers
 !> \brief The control loop identification parameters.
 !> \see OpenCMISS::Iron::ControlLoop,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_CONTROL_LOOP_NODE = CONTROL_LOOP_NODE !<The identifier for a each "leaf" node in a control loop. \see OpenCMISS_ControlLoopIdentifiers,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_ControlLoopTypes OpenCMISS::Iron::ControlLoop::ControlLoopTypes
 !> \brief Control loop type parameters
 !> \see OpenCMISS::Iron::ControlLoop,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_CONTROL_SIMPLE_TYPE = CONTROL_SIMPLE_TYPE !<Simple, one iteration control loop. \see OpenCMISS_ControlLoopTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CONTROL_FIXED_LOOP_TYPE = CONTROL_FIXED_LOOP_TYPE !<Fixed iteration control loop. \see OpenCMISS_ControlLoopTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CONTROL_TIME_LOOP_TYPE = CONTROL_TIME_LOOP_TYPE !<Time control loop. \see OpenCMISS_ControlLoopTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CONTROL_WHILE_LOOP_TYPE = CONTROL_WHILE_LOOP_TYPE !<While control loop. \see OpenCMISS_ControlLoopTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CONTROL_LOAD_INCREMENT_LOOP_TYPE = CONTROL_LOAD_INCREMENT_LOOP_TYPE !<Load increment control loop. \see OpenCMISS_ControlLoopTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_ControlLoopOutputTypes OpenCMISS::Iron::ControlLoop::OutputTypes
 !> \brief The control loop output types.
 !> \see OpenCMISS::Iron::ControlLoop,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_CONTROL_LOOP_NO_OUTPUT = CONTROL_LOOP_NO_OUTPUT !<No output from the control loop. \see OpenCMISS_ControlLoopOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CONTROL_LOOP_PROGRESS_OUTPUT = CONTROL_LOOP_PROGRESS_OUTPUT !<Progress output from the control loop. \see OpenCMISS_ControlLoopOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CONTROL_LOOP_TIMING_OUTPUT = CONTROL_LOOP_TIMING_OUTPUT !<Timing output from the control loop. \see OpenCMISS_ControlLoopOutputTypes,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Returns the absolute convergence tolerance for a while control loop. 
 INTERFACE cmfe_ControlLoop_AbsoluteToleranceGet
   MODULE PROCEDURE cmfe_ControlLoop_AbsoluteToleranceGetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_AbsoluteToleranceGetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_AbsoluteToleranceGetObj
 END INTERFACE cmfe_ControlLoop_AbsoluteToleranceGet

 !>Sets/changes the absolute tolerance for a while control loop.
 INTERFACE cmfe_ControlLoop_AbsoluteToleranceSet
   MODULE PROCEDURE cmfe_ControlLoop_AbsoluteToleranceSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_AbsoluteToleranceSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_AbsoluteToleranceSetObj
 END INTERFACE cmfe_ControlLoop_AbsoluteToleranceSet

 !>Returns the continue loop status for a while control loop.
 INTERFACE cmfe_ControlLoop_ContinueLoopGet
   MODULE PROCEDURE cmfe_ControlLoop_ContinueLoopGetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_ContinueLoopGetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_ContinueLoopGetObj
 END INTERFACE cmfe_ControlLoop_ContinueLoopGet

 !>Returns the current time parameters for a time control loop.
 INTERFACE cmfe_ControlLoop_CurrentTimesGet
   MODULE PROCEDURE cmfe_ControlLoop_CurrentTimesGetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_CurrentTimesGetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_CurrentTimesGetObj
 END INTERFACE cmfe_ControlLoop_CurrentTimesGet

 !>Destroy a control loop.
 INTERFACE cmfe_ControlLoop_Destroy
   MODULE PROCEDURE cmfe_ControlLoop_DestroyNumber0
   MODULE PROCEDURE cmfe_ControlLoop_DestroyNumber1
   MODULE PROCEDURE cmfe_ControlLoop_DestroyObj
 END INTERFACE cmfe_ControlLoop_Destroy

 !>Returns the specified control loop as indexed by the control loop identifier from the control loop root.
 INTERFACE cmfe_ControlLoop_ControlLoopGet
   MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetNumber00
   MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetNumber10
   MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetNumber01
   MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetNumber11
   MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetObj0
   MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetObj1
 END INTERFACE cmfe_ControlLoop_ControlLoopGet

 !>Sets/changes the input frequency for a fixed control loop.
 INTERFACE cmfe_ControlLoop_FixedInputSet
   MODULE PROCEDURE cmfe_ControlLoop_FixedInputSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_FixedInputSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_FixedInputSetObj
 END INTERFACE cmfe_ControlLoop_FixedInputSet

 !>Sets/changes the output frequency for a fixed control loop.
 INTERFACE cmfe_ControlLoop_FixedOutputSet
   MODULE PROCEDURE cmfe_ControlLoop_FixedOutputSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_FixedOutputSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_FixedOutputSetObj
 END INTERFACE cmfe_ControlLoop_FixedOutputSet

 !>Sets/changes the iteration parameters for a fixed control loop. \todo need a get metod
 INTERFACE cmfe_ControlLoop_IterationsSet
   MODULE PROCEDURE cmfe_ControlLoop_IterationsSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_IterationsSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_IterationsSetObj
 END INTERFACE cmfe_ControlLoop_IterationsSet

 !>Returnss the iteration number for a control loop.
 INTERFACE cmfe_ControlLoop_IterationNumberGet
   MODULE PROCEDURE cmfe_ControlLoop_IterationNumberGetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_IterationNumberGetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_IterationNumberGetObj
 END INTERFACE cmfe_ControlLoop_IterationNumberGet

 !>Returns the label of a control loop.
 INTERFACE cmfe_ControlLoop_LabelGet
   MODULE PROCEDURE cmfe_ControlLoop_LabelGetCNumber0
   MODULE PROCEDURE cmfe_ControlLoop_LabelGetCNumber1
   MODULE PROCEDURE cmfe_ControlLoop_LabelGetCObj
   MODULE PROCEDURE cmfe_ControlLoop_LabelGetVSNumber0
   MODULE PROCEDURE cmfe_ControlLoop_LabelGetVSNumber1
   MODULE PROCEDURE cmfe_ControlLoop_LabelGetVSObj
 END INTERFACE cmfe_ControlLoop_LabelGet

 !>Sets/changes the label of a control loop.
 INTERFACE cmfe_ControlLoop_LabelSet
   MODULE PROCEDURE cmfe_ControlLoop_LabelSetCNumber0
   MODULE PROCEDURE cmfe_ControlLoop_LabelSetCNumber1
   MODULE PROCEDURE cmfe_ControlLoop_LabelSetCObj
   MODULE PROCEDURE cmfe_ControlLoop_LabelSetVSNumber0
   MODULE PROCEDURE cmfe_ControlLoop_LabelSetVSNumber1
   MODULE PROCEDURE cmfe_ControlLoop_LabelSetVSObj
 END INTERFACE cmfe_ControlLoop_LabelSet

 !>Sets/changes the maximum iterations for a while control loop. \todo need a get method
 INTERFACE cmfe_ControlLoop_MaximumIterationsSet
   MODULE PROCEDURE cmfe_ControlLoop_MaximumIterationsSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_MaximumIterationsSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_MaximumIterationsSetObj
 END INTERFACE cmfe_ControlLoop_MaximumIterationsSet

 !>Returns the number of iterations for a time control loop. If the returned value is 0, that means that the number has not yet been computed. 
 INTERFACE cmfe_ControlLoop_NumberOfIterationsGet
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfIterationsGetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfIterationsGetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfIterationsGetObj
 END INTERFACE cmfe_ControlLoop_NumberOfIterationsGet

 !>Sets/changes the number of iterations for a time control loop. If set to 0, it will be computed from time increment and start/stop time
 INTERFACE cmfe_ControlLoop_NumberOfIterationsSet
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfIterationsSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfIterationsSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfIterationsSetObj
 END INTERFACE cmfe_ControlLoop_NumberOfIterationsSet

 !>Returns the number of sub loops for a control loop.
 INTERFACE cmfe_ControlLoop_NumberOfSubLoopsGet
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsGetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsGetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsGetObj
 END INTERFACE cmfe_ControlLoop_NumberOfSubLoopsGet

 !>Sets/changes the number of sub loops for a control loop. \todo is this really a public method???
 INTERFACE cmfe_ControlLoop_NumberOfSubLoopsSet
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsSetObj
 END INTERFACE cmfe_ControlLoop_NumberOfSubLoopsSet

 !>Returns the relative convergence tolerance for a while control loop. 
 INTERFACE cmfe_ControlLoop_RelativeToleranceGet
   MODULE PROCEDURE cmfe_ControlLoop_RelativeToleranceGetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_RelativeToleranceGetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_RelativeToleranceGetObj
 END INTERFACE cmfe_ControlLoop_RelativeToleranceGet

 !>Sets/changes the relative tolerance for a while control loop.
 INTERFACE cmfe_ControlLoop_RelativeToleranceSet
   MODULE PROCEDURE cmfe_ControlLoop_RelativeToleranceSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_RelativeToleranceSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_RelativeToleranceSetObj
 END INTERFACE cmfe_ControlLoop_RelativeToleranceSet

 !>Sets/changes the output parameters for a time control loop.
 INTERFACE cmfe_ControlLoop_TimeOutputSet
   MODULE PROCEDURE cmfe_ControlLoop_TimeOutputSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_TimeOutputSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_TimeOutputSetObj
 END INTERFACE cmfe_ControlLoop_TimeOutputSet

 !>Returns the output type for a control loop.
 INTERFACE cmfe_ControlLoop_OutputTypeGet
   MODULE PROCEDURE cmfe_ControlLoop_OutputTypeGetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_OutputTypeGetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_OutputTypeGetObj
 END INTERFACE cmfe_ControlLoop_OutputTypeGet

 !>Sets/changes the output type for a control loop.
 INTERFACE cmfe_ControlLoop_OutputTypeSet
   MODULE PROCEDURE cmfe_ControlLoop_OutputTypeSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_OutputTypeSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_OutputTypeSetObj
 END INTERFACE cmfe_ControlLoop_OutputTypeSet

 !>Sets/changes the input parameters for a time control loop.
 INTERFACE cmfe_ControlLoop_TimeInputSet
   MODULE PROCEDURE cmfe_ControlLoop_TimeInputSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_TimeInputSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_TimeInputSetObj
 END INTERFACE cmfe_ControlLoop_TimeInputSet

 !>Returns the time parameters for a time control loop.
 INTERFACE cmfe_ControlLoop_TimesGet
   MODULE PROCEDURE cmfe_ControlLoop_TimesGetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_TimesGetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_TimesGetObj
 END INTERFACE cmfe_ControlLoop_TimesGet

 !>Sets/Changes the time parameters for a time control loop.
 INTERFACE cmfe_ControlLoop_TimesSet
   MODULE PROCEDURE cmfe_ControlLoop_TimesSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_TimesSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_TimesSetObj
 END INTERFACE cmfe_ControlLoop_TimesSet

 !>Sets/Changes the loop type for a control loop. \todo Is this really a public method? \todo need a get method
 INTERFACE cmfe_ControlLoop_TypeSet
   MODULE PROCEDURE cmfe_ControlLoop_TypeSetNumber0
   MODULE PROCEDURE cmfe_ControlLoop_TypeSetNumber1
   MODULE PROCEDURE cmfe_ControlLoop_TypeSetObj
 END INTERFACE cmfe_ControlLoop_TypeSet

 PUBLIC CMFE_CONTROL_LOOP_NODE

 PUBLIC CMFE_CONTROL_SIMPLE_TYPE,CMFE_CONTROL_FIXED_LOOP_TYPE,CMFE_CONTROL_TIME_LOOP_TYPE, &
   & CMFE_CONTROL_WHILE_LOOP_TYPE,CMFE_CONTROL_LOAD_INCREMENT_LOOP_TYPE
 
 PUBLIC CMFE_CONTROL_LOOP_NO_OUTPUT,CMFE_CONTROL_LOOP_PROGRESS_OUTPUT,CMFE_CONTROL_LOOP_TIMING_OUTPUT

 PUBLIC cmfe_ControlLoop_CurrentTimesGet

 PUBLIC cmfe_ControlLoop_Destroy

 PUBLIC cmfe_ControlLoop_ContinueLoopGet

 PUBLIC cmfe_ControlLoop_ControlLoopGet

 PUBLIC cmfe_ControlLoop_FixedInputSet,cmfe_ControlLoop_FixedOutputSet

 PUBLIC cmfe_ControlLoop_IterationsSet

 PUBLIC cmfe_ControlLoop_IterationNumberGet

 PUBLIC cmfe_ControlLoop_LabelGet,cmfe_ControlLoop_LabelSet

 PUBLIC cmfe_ControlLoop_LoadOutputSet

 PUBLIC cmfe_ControlLoop_MaximumIterationsSet

 PUBLIC cmfe_ControlLoop_AbsoluteToleranceGet,cmfe_ControlLoop_AbsoluteToleranceSet

 PUBLIC cmfe_ControlLoop_NumberOfIterationsGet,cmfe_ControlLoop_NumberOfIterationsSet
 
 PUBLIC cmfe_ControlLoop_NumberOfSubLoopsGet,cmfe_ControlLoop_NumberOfSubLoopsSet

 PUBLIC cmfe_ControlLoop_OutputTypeGet,cmfe_ControlLoop_OutputTypeSet

 PUBLIC cmfe_ControlLoop_RelativeToleranceGet,cmfe_ControlLoop_RelativeToleranceSet

 PUBLIC cmfe_ControlLoop_TimeOutputSet,cmfe_ControlLoop_TimeInputSet

 PUBLIC cmfe_ControlLoop_TimesGet,cmfe_ControlLoop_TimesSet

 PUBLIC cmfe_ControlLoop_TypeSet


!==================================================================================================================================
!
! CoordinateRoutines
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_CoordinateConstants OpenCMISS::Iron::Coordinate::Constants
 !> \brief Coordinate constants.
 !>@{
 !> \addtogroup OpenCMISS_CoordinateSystemTypes OpenCMISS::Iron::Coordinate::SystemTypes
 !> \brief Coordinate system type parameters.
 !> \see OpenCMISS::Iron::Coordinate,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_RECTANGULAR_CARTESIAN_TYPE = COORDINATE_RECTANGULAR_CARTESIAN_TYPE !<Rectangular Cartesian coordinate system type \see OpenCMISS_CoordinateSystemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_CYLINDRICAL_POLAR_TYPE = COORDINATE_CYLINDRICAL_POLAR_TYPE !<Cylindrical polar coordinate system type \see OpenCMISS_CoordinateSystemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_SPHERICAL_POLAR_TYPE = COORDINATE_SPHERICAL_POLAR_TYPE !<Spherical polar coordinate system type \see OpenCMISS_CoordinateSystemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_PROLATE_SPHEROIDAL_TYPE = COORDINATE_PROLATE_SPHEROIDAL_TYPE !<Prolate spheroidal coordinate system type \see OpenCMISS_CoordinateSystemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_OBLATE_SPHEROIDAL_TYPE = COORDINATE_OBLATE_SPHEROIDAL_TYPE !<Oblate spheroidal coordinate system type \see OpenCMISS_CoordinateSystemTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_CoordinateRadialInterpolations OpenCMISS::Iron::Coordinate::RadialInterpolations
 !> \brief The type of radial interpolation for polar coordinate systems
 !> \see OpenCMISS::Iron::Coordinate,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_NO_RADIAL_INTERPOLATION_TYPE = COORDINATE_NO_RADIAL_INTERPOLATION_TYPE !<No radial interpolation \see OpenCMISS_CoordinateRadialInterpolations,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_RADIAL_INTERPOLATION_TYPE = COORDINATE_RADIAL_INTERPOLATION_TYPE !<r radial interpolation \see OpenCMISS_CoordinateRadialInterpolations,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE = COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE !<r^2 radial interpolation \see OpenCMISS_CoordinateRadialInterpolations,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE = COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE !<r^3 radial interpolation \see OpenCMISS_CoordinateRadialInterpolations,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Finishes the creation of a coordinate system. \see OpenCMISS::Iron::cmfe_CoordinateSystem_CreateStart
 INTERFACE cmfe_CoordinateSystem_CreateFinish
   MODULE PROCEDURE cmfe_CoordinateSystem_CreateFinishNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_CreateFinishObj
 END INTERFACE cmfe_CoordinateSystem_CreateFinish

 !>Starts the creation of a coordinate system. \see OpenCMISS::Iron::cmfe_CoordinateSystem_CreateFinish
 INTERFACE cmfe_CoordinateSystem_CreateStart
   MODULE PROCEDURE cmfe_CoordinateSystem_CreateStartNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_CreateStartObj
 END INTERFACE cmfe_CoordinateSystem_CreateStart

 !>Destorys a coordinate system.
 INTERFACE cmfe_CoordinateSystem_Destroy
   MODULE PROCEDURE cmfe_CoordinateSystem_DestroyNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_DestroyObj
 END INTERFACE cmfe_CoordinateSystem_Destroy

 !>Returns the coordinate system dimension. \todo user number method \todo fix pointers
 INTERFACE cmfe_CoordinateSystem_DimensionGet
   MODULE PROCEDURE cmfe_CoordinateSystem_DimensionGetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_DimensionGetObj
 END INTERFACE cmfe_CoordinateSystem_DimensionGet

 !>Sets/changes the coordinate system dimension. \todo fix pointers
 INTERFACE cmfe_CoordinateSystem_DimensionSet
   MODULE PROCEDURE cmfe_CoordinateSystem_DimensionSetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_DimensionSetObj
 END INTERFACE cmfe_CoordinateSystem_DimensionSet

 !>Returns the coordinate system focus. \todo user number method \todo fix pointers
 INTERFACE cmfe_CoordinateSystem_FocusGet
   MODULE PROCEDURE cmfe_CoordinateSystem_FocusGetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_FocusGetObj
 END INTERFACE cmfe_CoordinateSystem_FocusGet

 !>Sets/changes the coordinate system focus. \todo user number method \todo fix pointers
 INTERFACE cmfe_CoordinateSystem_FocusSet
   MODULE PROCEDURE cmfe_CoordinateSystem_FocusSetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_FocusSetObj
 END INTERFACE cmfe_CoordinateSystem_FocusSet

 !>Returns the coordinate system radial interpolation type. \todo user number method \todo fix pointers
 INTERFACE cmfe_CoordinateSystem_RadialInterpolationGet
   MODULE PROCEDURE cmfe_CoordinateSystem_RadialInterpolationGetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_RadialInterpolationGetObj
 END INTERFACE cmfe_CoordinateSystem_RadialInterpolationGet

 !>Sets/changes the coordinate system radial interpolation type. \todo user number method \todo fix pointers
 INTERFACE cmfe_CoordinateSystem_RadialInterpolationSet
   MODULE PROCEDURE cmfe_CoordinateSystem_RadialInterpolationSetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_RadialInterpolationSetObj
 END INTERFACE cmfe_CoordinateSystem_RadialInterpolationSet

 !>Returns the coordinate system type. \todo user number method \todo fix pointers
 INTERFACE cmfe_CoordinateSystem_TypeGet
   MODULE PROCEDURE cmfe_CoordinateSystem_TypeGetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_TypeGetObj
 END INTERFACE cmfe_CoordinateSystem_TypeGet

 !>Sets/changes the coordinate system type. \todo user number method \todo fix pointers
 INTERFACE cmfe_CoordinateSystem_TypeSet
   MODULE PROCEDURE cmfe_CoordinateSystem_TypeSetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_TypeSetObj
 END INTERFACE cmfe_CoordinateSystem_TypeSet

 !>Returns the coordinate system orign.
 INTERFACE cmfe_CoordinateSystem_OriginGet
   MODULE PROCEDURE cmfe_CoordinateSystem_OriginGetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_OriginGetObj
 END INTERFACE cmfe_CoordinateSystem_OriginGet

 !>Sets/changes the coordinate system orign.
 INTERFACE cmfe_CoordinateSystem_OriginSet
   MODULE PROCEDURE cmfe_CoordinateSystem_OriginSetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_OriginSetObj
 END INTERFACE cmfe_CoordinateSystem_OriginSet

 !>Returns the coordinate system orientation.
 INTERFACE cmfe_CoordinateSystem_OrientationGet
   MODULE PROCEDURE cmfe_CoordinateSystem_OrientationGetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_OrientationGetObj
 END INTERFACE cmfe_CoordinateSystem_OrientationGet

 !>Sets/changes the coordinate system orientation.
 INTERFACE cmfe_CoordinateSystem_OrientationSet
   MODULE PROCEDURE cmfe_CoordinateSystem_OrientationSetNumber
   MODULE PROCEDURE cmfe_CoordinateSystem_OrientationSetObj
 END INTERFACE cmfe_CoordinateSystem_OrientationSet

 PUBLIC CMFE_COORDINATE_RECTANGULAR_CARTESIAN_TYPE,CMFE_COORDINATE_CYLINDRICAL_POLAR_TYPE, &
   & CMFE_COORDINATE_SPHERICAL_POLAR_TYPE, &
   & CMFE_COORDINATE_PROLATE_SPHEROIDAL_TYPE,CMFE_COORDINATE_OBLATE_SPHEROIDAL_TYPE

 PUBLIC CMFE_COORDINATE_NO_RADIAL_INTERPOLATION_TYPE,CMFE_COORDINATE_RADIAL_INTERPOLATION_TYPE, &
   & CMFE_COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE,CMFE_COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE

 PUBLIC cmfe_CoordinateSystem_CreateFinish,cmfe_CoordinateSystem_CreateStart

 PUBLIC cmfe_CoordinateSystem_Destroy

 PUBLIC cmfe_CoordinateSystem_DimensionGet,cmfe_CoordinateSystem_DimensionSet

 PUBLIC cmfe_CoordinateSystem_FocusGet,cmfe_CoordinateSystem_FocusSet

 PUBLIC cmfe_CoordinateSystem_RadialInterpolationGet,cmfe_CoordinateSystem_RadialInterpolationSet

 PUBLIC cmfe_CoordinateSystem_TypeGet,cmfe_CoordinateSystem_TypeSet

 PUBLIC cmfe_CoordinateSystem_OriginGet,cmfe_CoordinateSystem_OriginSet

 PUBLIC cmfe_CoordinateSystem_OrientationGet,cmfe_CoordinateSystem_OrientationSet

!==================================================================================================================================
!
! DataPointsRoutines
!
!==================================================================================================================================

 !Module parameters

 !Module types

 !Module variables

 !Interfaces

 !>Finishes the process of creating data points in a region. \see OpenCMISS::Iron::cmfe_DataPoints_CreateStart
 INTERFACE cmfe_DataPoints_CreateFinish
   MODULE PROCEDURE cmfe_DataPoints_CreateFinishNumber
   MODULE PROCEDURE cmfe_DataPoints_CreateFinishObj
 END INTERFACE cmfe_DataPoints_CreateFinish

 !>Starts the process of creating data points in a region. \see OpenCMISS::Iron::cmfe_DataPoints_CreateFinish
 INTERFACE cmfe_DataPoints_CreateStart
   MODULE PROCEDURE cmfe_DataPoints_CreateStartNumber
   MODULE PROCEDURE cmfe_DataPoints_CreateStartObj
   MODULE PROCEDURE cmfe_DataPoints_CreateStartInterfaceObj
 END INTERFACE cmfe_DataPoints_CreateStart

 !>Destroys data points.
 INTERFACE cmfe_DataPoints_Destroy
   MODULE PROCEDURE cmfe_DataPoints_DestroyNumber
   MODULE PROCEDURE cmfe_DataPoints_DestroyObj
 END INTERFACE cmfe_DataPoints_Destroy

 !>Returns the number of data points
 INTERFACE cmfe_DataPoints_NumberOfDataPointsGet
   MODULE PROCEDURE cmfe_DataPoints_NumberOfDataPointsGetNumber
   MODULE PROCEDURE cmfe_DataPoints_NumberOfDataPointsGetObj
 END INTERFACE cmfe_DataPoints_NumberOfDataPointsGet

 !>Returns the label for a data point identified by a given user number.
 INTERFACE cmfe_DataPoints_LabelGet
   MODULE PROCEDURE cmfe_DataPoints_LabelGetCNumber
   MODULE PROCEDURE cmfe_DataPoints_LabelGetCObj
   MODULE PROCEDURE cmfe_DataPoints_LabelGetVSNumber
   MODULE PROCEDURE cmfe_DataPoints_LabelGetVSObj
 END INTERFACE cmfe_DataPoints_LabelGet

 !>Sets/changes the label for a data point identified by a given user number.
 INTERFACE cmfe_DataPoints_LabelSet
   MODULE PROCEDURE cmfe_DataPoints_LabelSetCNumber
   MODULE PROCEDURE cmfe_DataPoints_LabelSetCObj
   MODULE PROCEDURE cmfe_DataPoints_LabelSetVSNumber
   MODULE PROCEDURE cmfe_DataPoints_LabelSetVSObj
 END INTERFACE cmfe_DataPoints_LabelSet

 !>Returns the user number for a data point identified by a given global number.
 INTERFACE cmfe_DataPoints_UserNumberGet
   MODULE PROCEDURE cmfe_DataPoints_UserNumberGetNumber
   MODULE PROCEDURE cmfe_DataPoints_UserNumberGetObj
 END INTERFACE cmfe_DataPoints_UserNumberGet

 !>Sets/changes the user number for a data point identified by a given global number.
 INTERFACE cmfe_DataPoints_UserNumberSet
   MODULE PROCEDURE cmfe_DataPoints_UserNumberSetNumber
   MODULE PROCEDURE cmfe_DataPoints_UserNumberSetObj
 END INTERFACE cmfe_DataPoints_UserNumberSet

 !>Returns the position for a data point identified by a given user number.
 INTERFACE cmfe_DataPoints_PositionGet
   MODULE PROCEDURE cmfe_DataPoints_PositionGetNumber
   MODULE PROCEDURE cmfe_DataPoints_PositionGetObj
 END INTERFACE cmfe_DataPoints_PositionGet

 !>Sets/changes the position for a data point identified by a given user number.
 INTERFACE cmfe_DataPoints_PositionSet
   MODULE PROCEDURE cmfe_DataPoints_PositionSetNumber
   MODULE PROCEDURE cmfe_DataPoints_PositionSetObj
 END INTERFACE cmfe_DataPoints_PositionSet

 !>Returns the weights for a data point identified by a given user number.
 INTERFACE cmfe_DataPoints_WeightsGet
   MODULE PROCEDURE cmfe_DataPoints_WeightsGetNumber
   MODULE PROCEDURE cmfe_DataPoints_WeightsGetObj
 END INTERFACE cmfe_DataPoints_WeightsGet

 !>Sets/changes the weights for a data point identified by a given user number.
 INTERFACE cmfe_DataPoints_WeightsSet
   MODULE PROCEDURE cmfe_DataPoints_WeightsSetNumber
   MODULE PROCEDURE cmfe_DataPoints_WeightsSetObj
 END INTERFACE cmfe_DataPoints_WeightsSet

 PUBLIC cmfe_DataPoints_CreateFinish,cmfe_DataPoints_CreateStart

 PUBLIC cmfe_DataPoints_Destroy

 PUBLIC cmfe_DataPoints_NumberOfDataPointsGet

 PUBLIC cmfe_DataPoints_LabelGet,cmfe_DataPoints_LabelSet

 PUBLIC cmfe_DataPoints_UserNumberGet,cmfe_DataPoints_UserNumberSet

 PUBLIC cmfe_DataPoints_PositionGet,cmfe_DataPoints_PositionSet

 PUBLIC cmfe_DataPoints_WeightsGet,cmfe_DataPoints_WeightsSet

!==================================================================================================================================
!
! DataProjectionRoutines
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_DataProjectionConstants OpenCMISS::Iron::DataProjection::Constants
 !> \brief DataProjection  constants.
 !>@{
 !> \addtogroup OpenCMISS_DataProjectionProjectionTypes OpenCMISS::Iron::DataProjection::ProjectionTypes
 !> \brief Data Projection types
 !> \see OpenCMISS::Iron::DataProjection,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE = DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE!<The boundary line projection type for data projection, only projects to boundary lines of the mesh. \see OpenCMISS_DataProjectionProjectionTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE = DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE!<The boundary face projection type for data projection, only projects to boundary faces of the mesh. \see OpenCMISS_DataProjectionProjectionTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE = DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE !<The element projection type for data projection, projects to all elements in mesh. \see OpenCMISS_DataProjectionProjectionTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_DataProjectionExitTags OpenCMISS::Iron::DataProjection::DataProjectionExitTags
 !> \brief Datapoint projection exit tags
 !> \see OpenCMISS::Iron::DataProjection,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_CANCELLED = DATA_PROJECTION_CANCELLED !<Data projection has been cancelled. \see OpenCMISS_DataProjectionExitTags,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_EXIT_TAG_CONVERGED = DATA_PROJECTION_EXIT_TAG_CONVERGED !<Data projection exited due to it being converged. \see OpenCMISS_DataProjectionExitTags,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_EXIT_TAG_BOUNDS = DATA_PROJECTION_EXIT_TAG_BOUNDS !<Data projection exited due to it hitting the bound and continue to travel out of the element. \see OpenCMISS_DataProjectionExitTags,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_EXIT_TAG_MAX_ITERATION = DATA_PROJECTION_EXIT_TAG_MAX_ITERATION !<Data projection exited due to it attaining maximum number of iteration specified by user. \see OpenCMISS_DataProjectionExitTags,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_EXIT_TAG_NO_ELEMENT = DATA_PROJECTION_EXIT_TAG_NO_ELEMENT !<Data projection exited due to no local element found, this happens when none of the candidate elements are within this computational node, and before MPI communication with other nodes. \see OpenCMISS_DataProjectionExitTags,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_DataProjectionDistanceRelations OpenCMISS::Iron::DataProjection::DataProjectionDistanceRelations
 !> \brief Datapoint projection distance relations to select data points based on distance.
 !> \see OpenCMISS::Iron::DataProjection,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_DISTANCE_GREATER = DATA_PROJECTION_DISTANCE_GREATER !<Data projection distance relation is greater than. \see OpenCMISS_DataProjectionDistanceRelations,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_DISTANCE_GREATER_EQUAL = DATA_PROJECTION_DISTANCE_GREATER_EQUAL !<Data projection distance relation is greater than or equal. \see OpenCMISS_DataProjectionDistanceRelations,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_DISTANCE_LESS = DATA_PROJECTION_DISTANCE_LESS !<Data projection distance relation is less than. \see OpenCMISS_DataProjectionDistanceRelations,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_DISTANCE_LESS_EQUAL = DATA_PROJECTION_DISTANCE_LESS_EQUAL !<Data projection distance relation is less than or equal. \see OpenCMISS_DataProjectionDistanceRelations,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Returns the absolute tolerance for a data projection.
 INTERFACE cmfe_DataProjection_AbsoluteToleranceGet
   MODULE PROCEDURE cmfe_DataProjection_AbsoluteToleranceGetNumber
   MODULE PROCEDURE cmfe_DataProjection_AbsoluteToleranceGetObj
 END INTERFACE cmfe_DataProjection_AbsoluteToleranceGet

 !>Sets/changes the absolute tolerance for a data projection.
 INTERFACE cmfe_DataProjection_AbsoluteToleranceSet
   MODULE PROCEDURE cmfe_DataProjection_AbsoluteToleranceSetNumber
   MODULE PROCEDURE cmfe_DataProjection_AbsoluteToleranceSetObj
 END INTERFACE cmfe_DataProjection_AbsoluteToleranceSet

 !>Finishes the creation of a new data projection. \see OpenCMISS::Iron::cmfe_DataProjection_CreateStart
 INTERFACE cmfe_DataProjection_CreateFinish
   MODULE PROCEDURE cmfe_DataProjection_CreateFinishNumber
   MODULE PROCEDURE cmfe_DataProjection_CreateFinishObj
 END INTERFACE cmfe_DataProjection_CreateFinish

 !>Starts the creation of a new data projection. \see OpenCMISS::Iron::cmfe_DataProjection_CreateFinish
 INTERFACE cmfe_DataProjection_CreateStart
   MODULE PROCEDURE cmfe_DataProjection_CreateStartNumber
   MODULE PROCEDURE cmfe_DataProjection_CreateStartObj
 END INTERFACE cmfe_DataProjection_CreateStart

 !>Destroy a data projection.
 INTERFACE cmfe_DataProjection_Destroy
   MODULE PROCEDURE cmfe_DataProjection_DestroyNumber
   MODULE PROCEDURE cmfe_DataProjection_DestroyObj
 END INTERFACE cmfe_DataProjection_Destroy

 !>Evaluate the data points position in a field based on data projection
 INTERFACE cmfe_DataProjection_DataPointsPositionEvaluate
   MODULE PROCEDURE cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber
   MODULE PROCEDURE cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber
   MODULE PROCEDURE cmfe_DataProjection_DataPointsPositionEvaluateObj
 END INTERFACE cmfe_DataProjection_DataPointsPositionEvaluate

 !>Starts the evluation of data projection on the geometric field.
 INTERFACE cmfe_DataProjection_DataPointsProjectionEvaluate
   MODULE PROCEDURE cmfe_DataProjection_DataPointsProjectionEvaluateNumber
   MODULE PROCEDURE cmfe_DataProjection_DataPointsProjectionEvaluateObj
 END INTERFACE cmfe_DataProjection_DataPointsProjectionEvaluate

 !>Returns the maximum iteration update for a data projection.
 INTERFACE cmfe_DataProjection_MaximumIterationUpdateGet
   MODULE PROCEDURE cmfe_DataProjection_MaximumIterationUpdateGetNumber
   MODULE PROCEDURE cmfe_DataProjection_MaximumIterationUpdateGetObj
 END INTERFACE cmfe_DataProjection_MaximumIterationUpdateGet

 !>Sets/changes the maximum iteration update for a data projection.
 INTERFACE cmfe_DataProjection_MaximumIterationUpdateSet
   MODULE PROCEDURE cmfe_DataProjection_MaximumIterationUpdateSetNumber
   MODULE PROCEDURE cmfe_DataProjection_MaximumIterationUpdateSetObj
 END INTERFACE cmfe_DataProjection_MaximumIterationUpdateSet

 !>Returns the maximum number of iterations for a data projection.
 INTERFACE cmfe_DataProjection_MaximumNumberOfIterationsGet
   MODULE PROCEDURE cmfe_DataProjection_MaximumNumberOfIterationsGetNumber
   MODULE PROCEDURE cmfe_DataProjection_MaximumNumberOfIterationsGetObj
 END INTERFACE cmfe_DataProjection_MaximumNumberOfIterationsGet

 !>Sets/changes the maximum number of iterations for a data projection.
 INTERFACE cmfe_DataProjection_MaximumNumberOfIterationsSet
   MODULE PROCEDURE cmfe_DataProjection_MaximumNumberOfIterationsSetNumber
   MODULE PROCEDURE cmfe_DataProjection_MaximumNumberOfIterationsSetObj
 END INTERFACE cmfe_DataProjection_MaximumNumberOfIterationsSet

 !>Returns the number of closest elements for a data projection.
 INTERFACE cmfe_DataProjection_NumberOfClosestElementsGet
   MODULE PROCEDURE cmfe_DataProjection_NumberOfClosestElementsGetNumber
   MODULE PROCEDURE cmfe_DataProjection_NumberOfClosestElementsGetObj
 END INTERFACE cmfe_DataProjection_NumberOfClosestElementsGet

 !>Sets/changes the number of closest elements for a data projection.
 INTERFACE cmfe_DataProjection_NumberOfClosestElementsSet
   MODULE PROCEDURE cmfe_DataProjection_NumberOfClosestElementsSetNumber
   MODULE PROCEDURE cmfe_DataProjection_NumberOfClosestElementsSetObj
 END INTERFACE cmfe_DataProjection_NumberOfClosestElementsSet

 !>Cancel the data projection for data points based on the data point user numbers.
 INTERFACE cmfe_DataProjection_ProjectionCancelByDataPoints
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber0
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber1
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByDataPointsInterNum0
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByDataPointsInterNum1
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByDataPointsObj0
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByDataPointsObj1
 END INTERFACE cmfe_DataProjection_ProjectionCancelByDataPoints

 !>Cancel the data projection for data points based on the projection distance.
 INTERFACE cmfe_DataProjection_ProjectionCancelByDistance
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByDistanceRegionNumber
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByDistanceInterfaceNumber
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByDistanceObj
 END INTERFACE cmfe_DataProjection_ProjectionCancelByDistance

 !>Cancel the data projection for data points based on the projection exit tag.
 INTERFACE cmfe_DataProjection_ProjectionCancelByExitTags
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber0
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber1
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByExitTagsObj0
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCancelByExitTagsObj1
 END INTERFACE cmfe_DataProjection_ProjectionCancelByExitTags

 !>Set the data projection candidate elements for an all elements projection type.
 INTERFACE cmfe_DataProjection_ProjectionCandidateElementsSet
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber0
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber1
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateElementsSetIntNum0
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateElementsSetIntNum1
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateElementsSetObj0
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateElementsSetObj1
 END INTERFACE cmfe_DataProjection_ProjectionCandidateElementsSet

 !>Set the data projection candidate elements for data points for an all elements projection type.
 INTERFACE cmfe_DataProjection_ProjectionDataCandidateElementsSet
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum00
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum01
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum10
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum11
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum00
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum01
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum10
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum11
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj00
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj01
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj10
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj11
 END INTERFACE cmfe_DataProjection_ProjectionDataCandidateElementsSet

 !>Set the data projection candidate faces for a boundary faces projection type.
 INTERFACE cmfe_DataProjection_ProjectionCandidateFacesSet
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber00
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber10
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber01
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber11
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum00
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum10
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum01
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum11
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetObj00
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetObj10
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetObj01
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateFacesSetObj11
 END INTERFACE cmfe_DataProjection_ProjectionCandidateFacesSet

 !>Set the data projection candidate faces for data points for a boundary faces projection type.
 INTERFACE cmfe_DataProjection_ProjectionDataCandidateFacesSet
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum000
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum011
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum100
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum111
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum000
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum011
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum100
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum111
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj000
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj011
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj100
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj111
 END INTERFACE cmfe_DataProjection_ProjectionDataCandidateFacesSet

 !>Set the data projection candidate lines for a boundary lines projection type.
 INTERFACE cmfe_DataProjection_ProjectionCandidateLinesSet
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber00
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber10
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber01
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber11
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum00
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum10
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum01
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum11
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetObj00
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetObj10
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetObj01
   MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidateLinesSetObj11
 END INTERFACE cmfe_DataProjection_ProjectionCandidateLinesSet

 !>Set the data projection candidate lines for data points for a boundary lines projection type.
 INTERFACE cmfe_DataProjection_ProjectionDataCandidateLinesSet
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum000
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum011
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum100
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum111
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum000
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum011
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum100
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum111
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj000
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj011
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj100
   MODULE PROCEDURE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj111
 END INTERFACE cmfe_DataProjection_ProjectionDataCandidateLinesSet

 !>Returns the projection type for a data projection.
 INTERFACE cmfe_DataProjection_ProjectionTypeGet
   MODULE PROCEDURE cmfe_DataProjection_ProjectionTypeGetNumber
   MODULE PROCEDURE cmfe_DataProjection_ProjectionTypeGetObj
 END INTERFACE cmfe_DataProjection_ProjectionTypeGet

 !>Sets/changes the projection type for a data projection.
 INTERFACE cmfe_DataProjection_ProjectionTypeSet
   MODULE PROCEDURE cmfe_DataProjection_ProjectionTypeSetNumber
   MODULE PROCEDURE cmfe_DataProjection_ProjectionTypeSetObj
 END INTERFACE cmfe_DataProjection_ProjectionTypeSet

 !>Returns the relative tolerance for a data projection.
 INTERFACE cmfe_DataProjection_RelativeToleranceGet
   MODULE PROCEDURE cmfe_DataProjection_RelativeToleranceGetNumber
   MODULE PROCEDURE cmfe_DataProjection_RelativeToleranceGetObj
 END INTERFACE cmfe_DataProjection_RelativeToleranceGet

 !>Sets/changes the relative tolerance for a data projection.
 INTERFACE cmfe_DataProjection_RelativeToleranceSet
   MODULE PROCEDURE cmfe_DataProjection_RelativeToleranceSetNumber
   MODULE PROCEDURE cmfe_DataProjection_RelativeToleranceSetObj
 END INTERFACE cmfe_DataProjection_RelativeToleranceSet

 !>Returns the starting xi for a data projection.
 INTERFACE cmfe_DataProjection_StartingXiGet
   MODULE PROCEDURE cmfe_DataProjection_StartingXiGetNumber
   MODULE PROCEDURE cmfe_DataProjection_StartingXiGetObj
 END INTERFACE cmfe_DataProjection_StartingXiGet

 !>Sets/changes the starting xi for a data projection.
 INTERFACE cmfe_DataProjection_StartingXiSet
   MODULE PROCEDURE cmfe_DataProjection_StartingXiSetNumber
   MODULE PROCEDURE cmfe_DataProjection_StartingXiSetObj
 END INTERFACE cmfe_DataProjection_StartingXiSet

 !>Sets/changes the element number for a data point projection.
 INTERFACE cmfe_DataProjection_ElementSet
   MODULE PROCEDURE cmfe_DataProjection_ElementSetRegionNumber
   MODULE PROCEDURE cmfe_DataProjection_ElementSetInterfaceNumber
   MODULE PROCEDURE cmfe_DataProjection_ElementSetObj
 END INTERFACE cmfe_DataProjection_ElementSet

 !>Gets the label for a data point projection.
 INTERFACE cmfe_DataProjection_LabelGet
   MODULE PROCEDURE cmfe_DataProjection_LabelGetCRegionNumber
   MODULE PROCEDURE cmfe_DataProjection_LabelGetCInterfaceNumber
   MODULE PROCEDURE cmfe_DataProjection_LabelGetCObj
   MODULE PROCEDURE cmfe_DataProjection_LabelGetVSRegionNumber
   MODULE PROCEDURE cmfe_DataProjection_LabelGetVSInterfaceNumber
   MODULE PROCEDURE cmfe_DataProjection_LabelGetVSObj
 END INTERFACE cmfe_DataProjection_LabelGet

 !>Sets/changes the label for a data point projection.
 INTERFACE cmfe_DataProjection_LabelSet
   MODULE PROCEDURE cmfe_DataProjection_LabelSetCRegionNumber
   MODULE PROCEDURE cmfe_DataProjection_LabelSetCInterfaceNumber
   MODULE PROCEDURE cmfe_DataProjection_LabelSetCObj
   MODULE PROCEDURE cmfe_DataProjection_LabelSetVSRegionNumber
   MODULE PROCEDURE cmfe_DataProjection_LabelSetVSInterfaceNumber
   MODULE PROCEDURE cmfe_DataProjection_LabelSetVSObj
 END INTERFACE cmfe_DataProjection_LabelSet

 !>Outputs an analysis of the data projection results
 INTERFACE cmfe_DataProjection_ResultAnalysisOutput
   MODULE PROCEDURE cmfe_DataProjection_ResultAnalysisOutputNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultAnalysisOutputObj
 END INTERFACE cmfe_DataProjection_ResultAnalysisOutput

 !>Returns the projection distance for a data point identified by a given user number.
 INTERFACE cmfe_DataProjection_ResultDistanceGet
   MODULE PROCEDURE cmfe_DataProjection_ResultDistanceGetNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultDistanceGetObj
 END INTERFACE cmfe_DataProjection_ResultDistanceGet

 !>Returns the projection element number for a data point identified by a given user number.
 INTERFACE cmfe_DataProjection_ResultElementNumberGet
   MODULE PROCEDURE cmfe_DataProjection_ResultElementNumberGetNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultElementNumberGetObj
 END INTERFACE cmfe_DataProjection_ResultElementNumberGet

 !>Returns the projection element face number for a data point identified by a given user number.
 INTERFACE cmfe_DataProjection_ResultElementFaceNumberGet
   MODULE PROCEDURE cmfe_DataProjection_ResultElementFaceNumberGetNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultElementFaceNumberGetObj
 END INTERFACE cmfe_DataProjection_ResultElementFaceNumberGet

 !>Returns the projection element line number for a data point identified by a given user number.
 INTERFACE cmfe_DataProjection_ResultElementLineNumberGet
   MODULE PROCEDURE cmfe_DataProjection_ResultElementLineNumberGetNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultElementLineNumberGetObj
 END INTERFACE cmfe_DataProjection_ResultElementLineNumberGet

 !>Returns the projection exit tag for a data point identified by a given user number.
 INTERFACE cmfe_DataProjection_ResultExitTagGet
   MODULE PROCEDURE cmfe_DataProjection_ResultExitTagGetNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultExitTagGetObj
 END INTERFACE cmfe_DataProjection_ResultExitTagGet

 !>Returns the maximum error for a data projection.
 INTERFACE cmfe_DataProjection_ResultMaximumErrorGet
   MODULE PROCEDURE cmfe_DataProjection_ResultMaximumErrorGetNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultMaximumErrorGetObj
 END INTERFACE cmfe_DataProjection_ResultMaximumErrorGet

 !>Returns the minimum error for a data projection.
 INTERFACE cmfe_DataProjection_ResultMinimumErrorGet
   MODULE PROCEDURE cmfe_DataProjection_ResultMinimumErrorGetNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultMinimumErrorGetObj
 END INTERFACE cmfe_DataProjection_ResultMinimumErrorGet

 !>Returns the RMS error for a data projection.
 INTERFACE cmfe_DataProjection_ResultRMSErrorGet
   MODULE PROCEDURE cmfe_DataProjection_ResultRMSErrorGetNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultRMSErrorGetObj
 END INTERFACE cmfe_DataProjection_ResultRMSErrorGet

 !>Returns the projection xi for a data point identified by a given user number.
 INTERFACE cmfe_DataProjection_ResultXiGet
   MODULE PROCEDURE cmfe_DataProjection_ResultXiGetNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultXiGetObj
 END INTERFACE cmfe_DataProjection_ResultXiGet

 !>Sets the projection xi for a data point identified by a given user number.
 INTERFACE cmfe_DataProjection_ResultXiSet
   MODULE PROCEDURE cmfe_DataProjection_ResultXiSetNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultXiSetObj
 END INTERFACE cmfe_DataProjection_ResultXiSet

 !>Returns the projection vector for a data point identified by a given user number.
 INTERFACE cmfe_DataProjection_ResultProjectionVectorGet
   MODULE PROCEDURE cmfe_DataProjection_ResultProjectionVectorGetNumber
   MODULE PROCEDURE cmfe_DataProjection_ResultProjectionVectorGetObj
 END INTERFACE cmfe_DataProjection_ResultProjectionVectorGet

 PUBLIC CMFE_DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE,CMFE_DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE, &
   & CMFE_DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE

 PUBLIC CMFE_DATA_PROJECTION_CANCELLED,CMFE_DATA_PROJECTION_EXIT_TAG_CONVERGED,CMFE_DATA_PROJECTION_EXIT_TAG_BOUNDS, &
   & CMFE_DATA_PROJECTION_EXIT_TAG_MAX_ITERATION,CMFE_DATA_PROJECTION_EXIT_TAG_NO_ELEMENT

 PUBLIC CMFE_DATA_PROJECTION_DISTANCE_GREATER,CMFE_DATA_PROJECTION_DISTANCE_GREATER_EQUAL,CMFE_DATA_PROJECTION_DISTANCE_LESS, &
   & CMFE_DATA_PROJECTION_DISTANCE_LESS_EQUAL

 PUBLIC cmfe_DataProjection_AbsoluteToleranceGet,cmfe_DataProjection_AbsoluteToleranceSet

 PUBLIC cmfe_DataProjection_CreateFinish,cmfe_DataProjection_CreateStart

 PUBLIC cmfe_DataProjection_Destroy

 PUBLIC cmfe_DataProjection_DataPointsPositionEvaluate

 PUBLIC cmfe_DataProjection_ProjectionCancelByDataPoints

 PUBLIC cmfe_DataProjection_ProjectionCancelByDistance

 PUBLIC cmfe_DataProjection_ProjectionCancelByExitTags

 PUBLIC cmfe_DataProjection_ProjectionCandidateElementsSet

 PUBLIC cmfe_DataProjection_ProjectionDataCandidateElementsSet

 PUBLIC cmfe_DataProjection_ProjectionCandidateFacesSet

 PUBLIC cmfe_DataProjection_ProjectionDataCandidateFacesSet

 PUBLIC cmfe_DataProjection_ProjectionCandidateLinesSet

 PUBLIC cmfe_DataProjection_ProjectionDataCandidateLinesSet

 PUBLIC cmfe_DataProjection_DataPointsProjectionEvaluate

 PUBLIC cmfe_DataProjection_MaximumIterationUpdateGet,cmfe_DataProjection_MaximumIterationUpdateSet

 PUBLIC cmfe_DataProjection_MaximumNumberOfIterationsGet,cmfe_DataProjection_MaximumNumberOfIterationsSet

 PUBLIC cmfe_DataProjection_NumberOfClosestElementsGet,cmfe_DataProjection_NumberOfClosestElementsSet

 PUBLIC cmfe_DataProjection_ProjectionTypeGet,cmfe_DataProjection_ProjectionTypeSet

 PUBLIC cmfe_DataProjection_RelativeToleranceGet,cmfe_DataProjection_RelativeToleranceSet

 PUBLIC cmfe_DataProjection_StartingXiGet,cmfe_DataProjection_StartingXiSet

 PUBLIC cmfe_DataProjection_ElementSet

 PUBLIC cmfe_DataProjection_LabelGet,cmfe_DataProjection_LabelSet

 PUBLIC cmfe_DataProjection_ResultAnalysisOutput

 PUBLIC cmfe_DataProjection_ResultDistanceGet,cmfe_DataProjection_ResultElementNumberGet

 PUBLIC cmfe_DataProjection_ResultElementFaceNumberGet,cmfe_DataProjection_ResultElementLineNumberGet

 PUBLIC cmfe_DataProjection_ResultExitTagGet

 PUBLIC cmfe_DataProjection_ResultMaximumErrorGet,cmfe_DataProjection_ResultMinimumErrorGet

 PUBLIC cmfe_DataProjection_ResultRMSErrorGet

 PUBLIC cmfe_DataProjection_ResultXiGet,cmfe_DataProjection_ResultXiSet

 PUBLIC cmfe_DataProjection_ResultProjectionVectorGet

!==================================================================================================================================
!
! EquationsRoutines
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_EquationsConstants OpenCMISS::Iron::Equations::Constants
 !> \brief Equations constants.
 !>@{
  !> \addtogroup OpenCMISS_EquationsDynamicMatrixTypes OpenCMISS::Iron::Equations::Constants::DynamicMatrixTypes
  !> \brief Type of dynamic matrix in a dynamic equations
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_MATRIX_STIFFNESS=EQUATIONS_MATRIX_STIFFNESS !<A stiffness matrix (multiplies displacement values) \see OpenCMISS_EquationsDynamicMatrixTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_MATRIX_DAMPING=EQUATIONS_MATRIX_DAMPING !<A damping matrix (multiplies velocity values) \see OpenCMISS_EquationsDynamicMatrixTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_MATRIX_MASS=EQUATIONS_MATRIX_MASS !<A mass matrix (multiplies acceleration values) \see OpenCMISS_EquationsDynamicMatrixTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsOutputTypes OpenCMISS::Iron::Equations::Constants::OutputTypes
 !> \brief Equations output types
 !> \see OpenCMISS::Iron::Equations,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_NO_OUTPUT = EQUATIONS_NO_OUTPUT!<No output from the equations \see OpenCMISS_EquationsOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_TIMING_OUTPUT = EQUATIONS_TIMING_OUTPUT !<Timing information output. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_MATRIX_OUTPUT = EQUATIONS_MATRIX_OUTPUT !<All below and equation matrices output. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_ELEMENT_MATRIX_OUTPUT = EQUATIONS_ELEMENT_MATRIX_OUTPUT !<All below and element matrices output. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_NODAL_MATRIX_OUTPUT = EQUATIONS_NODAL_MATRIX_OUTPUT !<All below and nodal matrices output. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_EquationsSparsityTypes OpenCMISS::Iron::Equations::Constants::SparsityTypes
 !> \brief Equations sparsity types
 !> \see OpenCMISS::Iron::Equations,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SPARSE_MATRICES = EQUATIONS_SPARSE_MATRICES !<Use sparse matrices for the equations. \see OpenCMISS_EquationsSparsityTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_FULL_MATRICES = EQUATIONS_FULL_MATRICES !<Use fully populated matrices for the equations. \see OpenCMISS_EquationsSparsityTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_EquationsLumpingTypes OpenCMISS::Iron::Equations::Constants::LumpingTypes
 !> \brief Equations lumping types
 !> \see OpenCMISS::Iron::Equations,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_UNLUMPED_MATRICES = EQUATIONS_UNLUMPED_MATRICES !<The equations matrices are not lumped. \see OpenCMISS_EquationsLumpingTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_LUMPED_MATRICES = EQUATIONS_LUMPED_MATRICES !<The equations matrices are "mass" lumped. \see OpenCMISS_EquationsLumpingTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_EquationsLinearityTypes OpenCMISS::Iron::Equations::Constants::LinearityTypes
 !> \brief The equations linearity types
 !> \see OpenCMISS::Iron::Equations,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_LINEAR = EQUATIONS_LINEAR !<The equations are linear. \see OpenCMISS_EquationsLinearityTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_NONLINEAR = EQUATIONS_NONLINEAR !<The equations are non-linear. \see \see OpenCMISS_EquationsLinearityTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_NONLINEAR_BCS = EQUATIONS_NONLINEAR_BCS !<The equations have non-linear boundary conditions. \see \see OpenCMISS_EquationsLinearityTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_EquationsTimeDependenceTypes OpenCMISS::Iron::Equations::Constants::TimeDependenceTypes
 !> \brief The equations time dependence types
 !> \see OpenCMISS::Iron::Equations,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_STATIC = EQUATIONS_STATIC !<The equations are static and have no time dependence. \see OpenCMISS_EquationsTimeDependenceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_QUASISTATIC = EQUATIONS_QUASISTATIC !<The equations are quasi-static. \see OpenCMISS_EquationsTimeDependenceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_FIRST_ORDER_DYNAMIC = EQUATIONS_FIRST_ORDER_DYNAMIC !<The equations are first order dynamic. \see OpenCMISS_EquationsTimeDependenceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SECOND_ORDER_DYNAMIC = EQUATIONS_SECOND_ORDER_DYNAMIC !<The equations are a second order dynamic. \see OpenCMISS_EquationsTimeDependenceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_TIME_STEPPING = EQUATIONS_TIME_STEPPING !<The equations are for time stepping. \see OpenCMISS_EquationsTimeDependenceTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_EquationsJacobianCalculated OpenCMISS::Iron::Equations::Constants::JacobianCalculated
 !> \brief Equations Jacobian matrices calculation types
 !> \see OpenCMISS::Iron::Equations,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_JACOBIAN_FINITE_DIFFERENCE_CALCULATED =  &
   & EQUATIONS_JACOBIAN_FINITE_DIFFERENCE_CALCULATED !<Evaluate Jacobian matrix using finite differences. \see OpenCMISS_EquationsJacobianCalculated
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_JACOBIAN_ANALYTIC_CALCULATED = EQUATIONS_JACOBIAN_ANALYTIC_CALCULATED !<Evaluate Jacobian matrix using analytic expressions. \see OpenCMISS_EquationsJacobianCalculated,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Destroys equations for an equations.
 INTERFACE cmfe_Equations_Destroy
   MODULE PROCEDURE cmfe_Equations_DestroyNumber
   MODULE PROCEDURE cmfe_Equations_DestroyObj
 END INTERFACE cmfe_Equations_Destroy

 !>Gets the distributed matrix for a dynamic matrix in an equations specified by matrix number.
 INTERFACE cmfe_Equations_DynamicMatrixGet
   MODULE PROCEDURE cmfe_Equations_DynamicMatrixGetObj
 END INTERFACE cmfe_Equations_DynamicMatrixGet

 !>Gets the distributed matrix for a dynamic matrix in an equation specified by matrix type.
 INTERFACE cmfe_Equations_DynamicMatrixGetByType
   MODULE PROCEDURE cmfe_Equations_DynamicMatrixGetByTypeObj
 END INTERFACE cmfe_Equations_DynamicMatrixGetByType

 !>Gets the type (stiffness, damping, mass) of a dynamic matrix in an equations specified by matrix number.
 INTERFACE cmfe_Equations_DynamicMatrixTypeGet
   MODULE PROCEDURE cmfe_Equations_DynamicMatrixTypeGetObj
 END INTERFACE cmfe_Equations_DynamicMatrixTypeGet

 !>Sets/changes the Jacobian matrix calculation types for equations
 INTERFACE cmfe_Equations_JacobianCalculationTypeSet
   MODULE PROCEDURE cmfe_Equations_JacobianCalculationTypeSetNumber
   MODULE PROCEDURE cmfe_Equations_JacobianCalculationTypeSetObj
 END INTERFACE cmfe_Equations_JacobianCalculationTypeSet
 
 !>Sets/changes the Jacobian matrix finite difference step size for equations
 INTERFACE cmfe_Equations_JacobianFiniteDifferenceStepSizeSet
   MODULE PROCEDURE cmfe_Equations_JacobianFiniteDifferenceStepSizeSetNumber
   MODULE PROCEDURE cmfe_Equations_JacobianFiniteDifferenceStepSizeSetObj
 END INTERFACE cmfe_Equations_JacobianFiniteDifferenceStepSizeSet
  
 !>Gets the distributed matrix for a Jacobian matrix in an equation specified by variable number.
 INTERFACE cmfe_Equations_JacobianMatrixGetByNumber
   MODULE PROCEDURE cmfe_Equations_JacobianMatrixGetByNumberObj
 END INTERFACE cmfe_Equations_JacobianMatrixGetByNumber

 !>Gets the distributed matrix for a Jacobian matrix in an equation specified by variable type.
 INTERFACE cmfe_Equations_JacobianMatrixGetByType
   MODULE PROCEDURE cmfe_Equations_JacobianMatrixGetByTypeObj
 END INTERFACE cmfe_Equations_JacobianMatrixGetByType

 !>Gets the linearity type for equations.
 INTERFACE cmfe_Equations_LinearityTypeGet
   MODULE PROCEDURE cmfe_Equations_LinearityTypeGetNumber
   MODULE PROCEDURE cmfe_Equations_LinearityTypeGetObj
 END INTERFACE cmfe_Equations_LinearityTypeGet

 !>Gets the distributed matrix for a linear matrix in equations.
 INTERFACE cmfe_Equations_LinearMatrixGet
   MODULE PROCEDURE cmfe_Equations_LinearMatrixGetObj
 END INTERFACE cmfe_Equations_LinearMatrixGet

 !>Gets the lumping type for equations.
 INTERFACE cmfe_Equations_LumpingTypeGet
   MODULE PROCEDURE cmfe_Equations_LumpingTypeGetNumber
   MODULE PROCEDURE cmfe_Equations_LumpingTypeGetObj
 END INTERFACE cmfe_Equations_LumpingTypeGet

 !>Sets/changes the lumping type for equations.
 INTERFACE cmfe_Equations_LumpingTypeSet
   MODULE PROCEDURE cmfe_Equations_LumpingTypeSetNumber
   MODULE PROCEDURE cmfe_Equations_LumpingTypeSetObj
 END INTERFACE cmfe_Equations_LumpingTypeSet

 !>Gets the number of dynamic matrices in the equations.
 INTERFACE cmfe_Equations_NumberOfDynamicMatricesGet
   MODULE PROCEDURE cmfe_Equations_NumberOfDynamicMatricesGetObj
 END INTERFACE cmfe_Equations_NumberOfDynamicMatricesGet

 !>Gets the number of Jacobian matrices in a residual vector in the equations.
 INTERFACE cmfe_Equations_NumberOfJacobianMatricesGet
   MODULE PROCEDURE cmfe_Equations_NumberOfJacobianMatricesGetObj
 END INTERFACE cmfe_Equations_NumberOfJacobianMatricesGet

 !>Gets the number of linear matrices in the equations.
 INTERFACE cmfe_Equations_NumberOfLinearMatricesGet
   MODULE PROCEDURE cmfe_Equations_NumberOfLinearMatricesGetObj
 END INTERFACE cmfe_Equations_NumberOfLinearMatricesGet

 !>Gets the number of residual vectors in the equations.
 INTERFACE cmfe_Equations_NumberOfResidualVectorsGet
   MODULE PROCEDURE cmfe_Equations_NumberOfResidualVectorsGetObj
 END INTERFACE cmfe_Equations_NumberOfResidualVectorsGet

 !>Gets the number of source vectors in the equations.
 INTERFACE cmfe_Equations_NumberOfSourceVectorsGet
   MODULE PROCEDURE cmfe_Equations_NumberOfSourceVectorsGetObj
 END INTERFACE cmfe_Equations_NumberOfSourceVectorsGet

 !>Gets the output type for equations.
 INTERFACE cmfe_Equations_OutputTypeGet
   MODULE PROCEDURE cmfe_Equations_OutputTypeGetNumber
   MODULE PROCEDURE cmfe_Equations_OutputTypeGetObj
 END INTERFACE cmfe_Equations_OutputTypeGet

 !>Sets/changes the output type for equations.
 INTERFACE cmfe_Equations_OutputTypeSet
   MODULE PROCEDURE cmfe_Equations_OutputTypeSetNumber
   MODULE PROCEDURE cmfe_Equations_OutputTypeSetObj
 END INTERFACE cmfe_Equations_OutputTypeSet

 !>Gets the number of variables in a residual vector in equations.
 INTERFACE cmfe_Equations_ResidualNumberOfVariablesGet
   MODULE PROCEDURE cmfe_Equations_ResidualNumberOfVariablesGetObj
 END INTERFACE cmfe_Equations_ResidualNumberOfVariablesGet

 !>Gets the variable type for a variable in a residual vector in equations.
 INTERFACE cmfe_Equations_ResidualVariableTypeGet
   MODULE PROCEDURE cmfe_Equations_ResidualVariableTypeGetObj
 END INTERFACE cmfe_Equations_ResidualVariableTypeGet

 !>Gets the variable types in a residual vector in equations.
 INTERFACE cmfe_Equations_ResidualVariableTypesGet
   MODULE PROCEDURE cmfe_Equations_ResidualVariableTypesGetObj
 END INTERFACE cmfe_Equations_ResidualVariableTypesGet

 !>Gets the distributed vector for a residual vector in equations.
 INTERFACE cmfe_Equations_ResidualVectorGet
   MODULE PROCEDURE cmfe_Equations_ResidualVectorGetObj
 END INTERFACE cmfe_Equations_ResidualVectorGet

 !>Gets the distributed vector for a right hand side vector in equations.
 INTERFACE cmfe_Equations_RHSVectorGet
   MODULE PROCEDURE cmfe_Equations_RHSVectorGetObj
 END INTERFACE cmfe_Equations_RHSVectorGet

 !>Gets the sparsity type for equations.
 INTERFACE cmfe_Equations_SparsityTypeGet
   MODULE PROCEDURE cmfe_Equations_SparsityTypeGetNumber
   MODULE PROCEDURE cmfe_Equations_SparsityTypeGetObj
 END INTERFACE cmfe_Equations_SparsityTypeGet

 !>Sets/changes the sparsity type for equations.
 INTERFACE cmfe_Equations_SparsityTypeSet
   MODULE PROCEDURE cmfe_Equations_SparsityTypeSetNumber
   MODULE PROCEDURE cmfe_Equations_SparsityTypeSetObj
 END INTERFACE cmfe_Equations_SparsityTypeSet

 !>Gets the distributed vector for a source vector in equations.
 INTERFACE cmfe_Equations_SourceVectorGet
   MODULE PROCEDURE cmfe_Equations_SourceVectorGetObj
 END INTERFACE cmfe_Equations_SourceVectorGet

 !>Gets the time dependence type for equations.
 INTERFACE cmfe_Equations_TimeDependenceTypeGet
   MODULE PROCEDURE cmfe_Equations_TimeDependenceTypeGetNumber
   MODULE PROCEDURE cmfe_Equations_TimeDependenceTypeGetObj
 END INTERFACE cmfe_Equations_TimeDependenceTypeGet

 PUBLIC CMFE_EQUATIONS_MATRIX_STIFFNESS,CMFE_EQUATIONS_MATRIX_DAMPING,CMFE_EQUATIONS_MATRIX_MASS
 
 PUBLIC CMFE_EQUATIONS_NO_OUTPUT,CMFE_EQUATIONS_TIMING_OUTPUT,CMFE_EQUATIONS_MATRIX_OUTPUT, &
   & CMFE_EQUATIONS_ELEMENT_MATRIX_OUTPUT,CMFE_EQUATIONS_NODAL_MATRIX_OUTPUT

 PUBLIC CMFE_EQUATIONS_SPARSE_MATRICES,CMFE_EQUATIONS_FULL_MATRICES

 PUBLIC CMFE_EQUATIONS_JACOBIAN_FINITE_DIFFERENCE_CALCULATED, CMFE_EQUATIONS_JACOBIAN_ANALYTIC_CALCULATED

 PUBLIC CMFE_EQUATIONS_UNLUMPED_MATRICES,CMFE_EQUATIONS_LUMPED_MATRICES

 PUBLIC CMFE_EQUATIONS_LINEAR,CMFE_EQUATIONS_NONLINEAR,CMFE_EQUATIONS_NONLINEAR_BCS

 PUBLIC CMFE_EQUATIONS_STATIC,CMFE_EQUATIONS_QUASISTATIC,CMFE_EQUATIONS_FIRST_ORDER_DYNAMIC, &
   & CMFE_EQUATIONS_SECOND_ORDER_DYNAMIC,CMFE_EQUATIONS_TIME_STEPPING

 PUBLIC cmfe_Equations_Destroy

 PUBLIC cmfe_Equations_DynamicMatrixGet

 PUBLIC cmfe_Equations_DynamicMatrixGetByType

 PUBLIC cmfe_Equations_DynamicMatrixTypeGet

 PUBLIC cmfe_Equations_JacobianCalculationTypeSet

 PUBLIC cmfe_Equations_JacobianFiniteDifferenceStepSizeSet

 PUBLIC cmfe_Equations_JacobianMatrixGetByNumber

 PUBLIC cmfe_Equations_JacobianMatrixGetByType

 PUBLIC cmfe_Equations_LinearityTypeGet

 PUBLIC cmfe_Equations_LinearMatrixGet

 PUBLIC cmfe_Equations_LumpingTypeGet,cmfe_Equations_LumpingTypeSet

 PUBLIC cmfe_Equations_NumberOfDynamicMatricesGet

 PUBLIC cmfe_Equations_NumberOfJacobianMatricesGet

 PUBLIC cmfe_Equations_NumberOfLinearMatricesGet

 PUBLIC cmfe_Equations_NumberOfResidualVectorsGet

 PUBLIC cmfe_Equations_NumberOfSourceVectorsGet

 PUBLIC cmfe_Equations_OutputTypeGet,cmfe_Equations_OutputTypeSet

 PUBLIC cmfe_Equations_ResidualNumberOfVariablesGet

 PUBLIC cmfe_Equations_ResidualVariableTypeGet

 PUBLIC cmfe_Equations_ResidualVariableTypesGet

 PUBLIC cmfe_Equations_ResidualVectorGet

 PUBLIC cmfe_Equations_RHSVectorGet

 PUBLIC cmfe_Equations_SourceVectorGet
 
 PUBLIC cmfe_Equations_SparsityTypeGet,cmfe_Equations_SparsityTypeSet

 PUBLIC cmfe_Equations_TimeDependenceTypeGet


!==================================================================================================================================
!
! EquationsSetRoutines
!
!==================================================================================================================================

 
 !Module parameters
 
 !> \addtogroup OpenCMISS_EquationsSetRoutines OpenCMISS::Iron::EquationsSet::Constants
 !> \brief Equations set constants.
 !>@{
 !> \addtogroup OpenCMISS_EquationsSetClasses OpenCMISS::Iron::EquationsSet::Classes
 !> \brief Equations set classes.
 !> \see OpenCMISS::Iron::EquationsSet,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_CLASS = EQUATIONS_SET_NO_CLASS !<No equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELASTICITY_CLASS = EQUATIONS_SET_ELASTICITY_CLASS !<Elasticity equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FLUID_MECHANICS_CLASS = EQUATIONS_SET_FLUID_MECHANICS_CLASS !<Fluid Mechanics equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELECTROMAGNETICS_CLASS = EQUATIONS_SET_ELECTROMAGNETICS_CLASS !<Electromagnetics equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CLASSICAL_FIELD_CLASS = EQUATIONS_SET_CLASSICAL_FIELD_CLASS !<Classical Field equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BIOELECTRICS_CLASS = EQUATIONS_SET_BIOELECTRICS_CLASS !<Bioelectrics equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MODAL_CLASS = EQUATIONS_SET_MODAL_CLASS !<Modal equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FITTING_CLASS = EQUATIONS_SET_FITTING_CLASS !<Fitting equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_OPTIMISATION_CLASS = EQUATIONS_SET_OPTIMISATION_CLASS !<Optimisation equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_PHYSICS_CLASS = EQUATIONS_SET_MULTI_PHYSICS_CLASS !<Multi Physics equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsSetTypes OpenCMISS::Iron::EquationsSet::Types
  !> \brief Equations set Types.
  !> \see OpenCMISS::Iron::EquationsSet,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_TYPE = EQUATIONS_SET_NO_TYPE !<No equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TYPE = EQUATIONS_SET_LINEAR_ELASTICITY_TYPE !<Linear elasticity equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_TYPE !<Finite elasticity equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TYPE = EQUATIONS_SET_STOKES_EQUATION_TYPE !<Stokes equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_TYPE = EQUATIONS_SET_DARCY_EQUATION_TYPE !<Darcy equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE = EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE !<Darcy pressure equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISEUILLE_EQUATION_TYPE = EQUATIONS_SET_POISEUILLE_EQUATION_TYPE !<Poiseuille equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BURGERS_EQUATION_TYPE = EQUATIONS_SET_BURGERS_EQUATION_TYPE !<Burgers equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE = EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE !<Characteristic equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STREE_EQUATION_TYPE = EQUATIONS_SET_STREE_EQUATION_TYPE !<Characteristic equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELECTROSTATIC_TYPE = EQUATIONS_SET_ELECTROSTATIC_TYPE !<Electrostatic equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MAGNETOSTATIC_TYPE = EQUATIONS_SET_MAGNETOSTATIC_TYPE !<Magnetostatic equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE = EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE !<Maxwells equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TYPE = EQUATIONS_SET_LAPLACE_EQUATION_TYPE !<Laplace equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISSON_EQUATION_TYPE = EQUATIONS_SET_POISSON_EQUATION_TYPE !<Poisson equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE = EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE !<Helmholtz equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_WAVE_EQUATION_TYPE = EQUATIONS_SET_WAVE_EQUATION_TYPE !<Wave equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_TYPE = EQUATIONS_SET_DIFFUSION_EQUATION_TYPE !<Diffusion equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ADVECTION_EQUATION_TYPE = EQUATIONS_SET_ADVECTION_EQUATION_TYPE !<Advection-Diffusion equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE = &
    & EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE = EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE = EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE !<Biharmonic equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE = EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE !<Monodomain equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE = EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE !<Bidomain equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE = EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE !<Linear elasticity modal equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE = EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE !<Data point fitting equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GAUSS_FITTING_EQUATION_TYPE = EQUATIONS_SET_GAUSS_FITTING_EQUATION_TYPE !<Gauss point fitting equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE = &
    & EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity Navier Stokes equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE = EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE = &
    & EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS

  !>@}
  !> \addtogroup OpenCMISS_EquationsSetSubtypes OpenCMISS::Iron::EquationsSet::Subtypes
  !> \brief Equations set subtypes.
  !> \see OpenCMISS::Iron::EquationsSet,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_SUBTYPE = EQUATIONS_SET_NO_SUBTYPE !<No equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE = EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE !<Three dimensional linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE = &
    & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE !<Plane stress linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE = &
    & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE !<Plane strain linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE = EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE !<One dimensional linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_PLATE_SUBTYPE = EQUATIONS_SET_PLATE_SUBTYPE !<Plate linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_SHELL_SUBTYPE = EQUATIONS_SET_SHELL_SUBTYPE !<Shell linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE = EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE !< Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE = &
  & EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE !< Incompressible Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE = &
  & EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE !< Nearly Incompressible Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE !< Mooney-Rivlin constitutive law with steady-state active contraction for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE !< St Venant Kirchoff constitutive law with steady-state active contraction for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE =&
    & EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE !< Active contraction/costa-based law with quasistatic time loop for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE = EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE !< Isotropic exponential constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE !< Transverse isotropic exponential constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE !< Transverse isotropic, active-contraction constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE = &
    & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE !< Transverse isotropic, active-contraction material-transition constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE !< Orthotropic Costa constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE= &
    & EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE !<Compressible version for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE= &
    & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE !<Compressible version for finite elasticity equations set with active contraction subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE !< Transverse isotropic Guccione constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE = &
    & EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE !< Isotropic active strain constitutive law based on multiplicative decomposition of the deformation gradient subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE = &
    & EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE !< Isotropic active strain constitutive law based on multiplicative decomposition of the deformation gradient and the cellular model of Razumova et al. (2000) subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE !< Determine the reference configuration using Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE = &
    & EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE !< Transverse isotropic Guccione constitutive law for finite elasticity equstions set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE !< Transverse isotropic Guccione constitutive law with active contraction subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMPRESS_FINITE_ELASTICITY_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE !<Incompressible version for finite elasticity coupled with Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE !<INRIA Model for finite elasticity coupled with Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELASTICITY_MULTI_COMP_DARCY_INRIA_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_MULTI_COMPARTMENT_DARCY_INRIA_SUBTYPE !<Multi Compartment Darcy INRIA Model coupled with finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMPRESS_ELASTICITY_DRIVEN_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE !< Incompressible finite elasticity with Darcy flow driven by solid hydrostatic pressure \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE !< Incompressible finite elasticity with Darcy flow driven by solid hydrostatic pressure, formulated in terms of modified invariants. \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMPRESS_ELAST_MULTI_COMP_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MEMBRANE_SUBTYPE = EQUATIONS_SET_MEMBRANE_SUBTYPE !<Compressible version for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ORTHOTROPIC_HOLZAPFEL_OGDEN_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE !< Orthotropic Holzapfel-Ogden constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE &
    & !< Orthotropic Holzapfel-Ogden constitutive law with active contraction for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELASTICITY_FLUID_PRES_STATIC_INRIA_SUBTYPE = &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE !< Static finite elasticity coupled with fluid pressure set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE !<Holmes and Mow's poroelastic constitutive relation subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELASTI_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE !<Holmes and Mow's poroelastic constitutive relation subtype with active contraction \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE !<Transverse isotropic constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE = &
    & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE !<Anisotropic polynomial constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE = &
    & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE !<Anisotropic polynomial active constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE= &
       & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE !<Humphrey and Yin transversely isotropic constitutive relation subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE = &
    & EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE !<Dynamic St Venant-Kirchoff constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE !<Dynamic Mooney-Rivlin constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE = &
    & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE !<Dynamic compressible St Venant-Kirchoff constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE !<Dynamic compressible Mooney-Rivlin constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE !<Compressible Mooney-Rivlin constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE = &
    & EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE !<St Venant-Kirchoff constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE = &
    & EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE !<Compressible St Venant-Kirchoff constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_STOKES_SUBTYPE = EQUATIONS_SET_STATIC_STOKES_SUBTYPE !<Static Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE = EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE = EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ALE_STOKES_SUBTYPE = EQUATIONS_SET_ALE_STOKES_SUBTYPE !<ALE Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE = EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE !<Transient residual-based stabilisation Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_RBS_NAVIER_STOKES_SUBTYPE =  &
    & EQUATIONS_SET_STATIC_RBS_NAVIER_STOKES_SUBTYPE !<Transient residual-based stabilisation Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTISCALE3D_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_MULTISCALE3D_NAVIER_STOKES_SUBTYPE !<Transient stabilised 3D Navier-Stokes equations set with coupled multiscale boundaries subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTITUTIVE_MU_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_CONSTITUTIVE_MU_NAVIER_STOKES_SUBTYPE !<Transient stabilised 3D Navier-Stokes equations set with coupled constitutive model for non-Newtonian viscosity \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT1D_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_TRANSIENT1D_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes equations set subtype with coupled Advection \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CHARACTERISTIC_SUBTYPE = &
    & EQUATIONS_SET_CHARACTERISTIC_SUBTYPE !<Static Characteristics equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COUPLED1D0D_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_COUPLED1D0D_NAVIER_STOKES_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype with coupled Advection \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STREE1D0D_SUBTYPE = &
    & EQUATIONS_SET_STREE1D0D_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype with coupled Advection \see
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STREE1D0D_ADV_SUBTYPE = &
    & EQUATIONS_SET_STREE1D0D_ADV_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype with coupled Advection \see
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ALE_RBS_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_ALE_RBS_NAVIER_STOKES_SUBTYPE !<ALE with RBS Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STANDARD_DARCY_SUBTYPE = EQUATIONS_SET_STANDARD_DARCY_SUBTYPE !<Standard Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE = EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ALE_DARCY_SUBTYPE = EQUATIONS_SET_ALE_DARCY_SUBTYPE !<ALE Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE = EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE = EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE !<Transient ALE Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE = EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE !<Multi Compartment Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BURGERS_SUBTYPE = EQUATIONS_SET_BURGERS_SUBTYPE !<Burgers equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE = EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE !<Generalised Burgers equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_BURGERS_SUBTYPE = EQUATIONS_SET_STATIC_BURGERS_SUBTYPE !<Static Burgers equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE = EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE !<Inviscid Burgers equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE = EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE = EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE !<Generalised Laplace equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE = EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE !<Moving mesh Laplace equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE = EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE !<Static Poiseuille equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE = EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE !<Dynamic Poiseuille equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE = &
    & EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_POISSON_SUBTYPE = EQUATIONS_SET_GENERALISED_POISSON_SUBTYPE !<Constant source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE !<Quadratic source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE !<Exponential source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE = &
    & EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE !<Poisson equations set subtype, that is the extracellular bidomain equation \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE = EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE !<No source Helmholtz equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE = EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE !<No source Helmholtz equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_DIFFUSION_SUBTYPE = EQUATIONS_SET_GENERALISED_DIFFUSION_SUBTYPE !<No source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE = EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE !<Linear source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE !<Quadratic source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE !<Exponential source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_ALE_DIFFUSION_SUBTYPE = EQUATIONS_SET_GENERALISED_ALE_DIFFUSION_SUBTYPE !<No source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE !<Linear source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE !<Quadratic source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE !<Exponential source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE !<Multi-compartment transport diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ADVECTION_SUBTYPE = &
    & EQUATIONS_SET_ADVECTION_SUBTYPE !<advection equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUBTYPE !<Generalised advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE !<Linear source advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE = &
    & EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE !<In CellML evaluated incompressible material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE = EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE !<Rubin rate based smooth model for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE =  &
    & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE !<Rubin compressible rate based smooth model for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE = &
    & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE !<Rubin rate based growth model for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE = &
    & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE !<Rubin compressible rate based growth model for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTIT_AND_GROWTH_LAW_IN_CELLML_SUBTYPE = &
    & EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE !<CellML evaluated growth and constituative material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE = &
    & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE !<CellML evaluated growth and Mooney-Rivlin constituative material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE = EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE !<CellML evaluated growth or finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE !<Generalsed ALE advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE !<Linear source ALE advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE !<Quadratic source ALE advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUBTYPE !<Exponential source ALE advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE !<Generalised static advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source static advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUPG_SUBTYPE !<Generalised source advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE !<Linear source advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE !<Quadratic source advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE !<Exponential source advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUPG_SUBTYPE !<Generalised ALE advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE !<Linear source ALE advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE !<Quadratic source ALE advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE !<Exponential source ALE advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<Generalised static advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<Linear source static advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE !<Coupled diffusion & advection-diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE !<Multi-component transport advection-diffusion equations set \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULT_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE !<Multi-component transport advection-diffusion equations set using SUPG scheme \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE !CellML Reaction Diffusion with order splitting \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE !CellML Reaction Diffusion without order splitting \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_REAC_DIFF_SUBTYPE !Standard generalised Reaction Diffusion without order splitting \see OpenCMISS_EquationsSetSubtypes,OpenCMISS


  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_CELLML_SUBTYPE= EQUATIONS_SET_MONODOMAIN_CELLML_SUBTYPE !<CellML monodomain equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE= EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE !<Bueno-Orovio monodomain equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE= EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE !<Ten Tusscher 2006 monodomain equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE = EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE !<First bidomain equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE = EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE !<Second bidomain equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE !<Generalised data point fitting equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_GAUSS_FITTING_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_GAUSS_FITTING_SUBTYPE !<Generalised Gauss point fitting equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MAT_PROPERTIES_GAUSS_FITTING_SUBTYPE = &
    & EQUATIONS_SET_MAT_PROPERTIES_GAUSS_FITTING_SUBTYPE !<Material Properties Galerkin Projection equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MAT_PROP_INRIA_GAUSS_FITTING_SUBTYPE = &
    & EQUATIONS_SET_MAT_PROPERTIES_INRIA_GAUSS_FITTING_SUBTYPE !<Material Properties INRIA Model Galerkin Projection equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIV_FREE_GAUSS_FITTING_SUBTYPE = &
    & EQUATIONS_SET_DIV_FREE_GAUSS_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS


  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STANDARD_ELASTICITY_DARCY_SUBTYPE = &
    & EQUATIONS_SET_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled diffusion-diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE =  &
    & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE !<Standard Monodomain Elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE =  &
    & EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE =  &
    & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype with titin \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE =  &
    & EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype with force-velocity relation \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE =  &
    & EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE = &
    & EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Finite Elasticity Navier Stokes ALE equations set subtype \see OpenCMISS_EquationsSetSubtype,OpenCMISS

  !>@}
  !> \addtogroup OpenCMISS_EquationsSetFittingSmoothingTypes OpenCMISS::Iron::EquationsSet::Fitting::SmoothingTypes
  !> \brief The smoothing types for fitting equations sets.
  !> \see OpenCMISS::Iron::EquationsSet,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FITTING_NO_SMOOTHING = &
    & EQUATIONS_SET_FITTING_NO_SMOOTHING !<No smoothing \see OpenCMISS_EquationsSetFittingSmoothingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FITTING_SOBOLEV_VALUE_SMOOTHING = &
    & EQUATIONS_SET_FITTING_SOBOLEV_VALUE_SMOOTHING !<Sobolev smoothing on the value of the dependent field \see OpenCMISS_EquationsSetFittingSmoothingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FITTING_SOBOLEV_DIFFERENCE_SMOOTHING = &
    & EQUATIONS_SET_FITTING_SOBOLEV_DIFFERENCE_SMOOTHING !<Sobolev smoothing on the difference between the current and initial value of the dependent field \see OpenCMISS_EquationsSetFittingSmoothingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FITTING_STRAIN_ENERGY_SMOOTHING = &
    & EQUATIONS_SET_FITTING_STRAIN_ENERGY_SMOOTHING !<Sobolev smoothing on the strain energy of the dependent field \see OpenCMISS_EquationsSetFittingSmoothingTypes,OpenCMISS
  !>@}

  !>@}
  !> \addtogroup OpenCMISS_EquationsSetSolutionMethods OpenCMISS::Iron::EquationsSet::SolutionMethods
  !> \brief The solution method parameters
  !> \see OpenCMISS::Iron::EquationsSet,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FEM_SOLUTION_METHOD = EQUATIONS_SET_FEM_SOLUTION_METHOD !<Finite Element Method solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BEM_SOLUTION_METHOD = EQUATIONS_SET_BEM_SOLUTION_METHOD !<Boundary Element Method solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FD_SOLUTION_METHOD = EQUATIONS_SET_FD_SOLUTION_METHOD !<Finite Difference solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FV_SOLUTION_METHOD = EQUATIONS_SET_FV_SOLUTION_METHOD !<Finite Volume solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GFEM_SOLUTION_METHOD = EQUATIONS_SET_GFEM_SOLUTION_METHOD !<Grid-based Finite Element Method solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GFD_SOLUTION_METHOD = EQUATIONS_SET_GFD_SOLUTION_METHOD !<Grid-based Finite Difference solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GFV_SOLUTION_METHOD = EQUATIONS_SET_GFV_SOLUTION_METHOD !<Grid-based Finite Volume solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  !>@}

  !> \addtogroup OpenCMISS_EquationsSetDerivedTensorTypes OpenCMISS::Iron::EquationsSet::DerivedTensorTypes
  !> \brief EquationsSet derived tensor type parameters
  !> \see OpenCMISS::Iron::EquationsSet,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DERIVED_DEFORMATION_GRADIENT = EQUATIONS_SET_DEFORMATION_GRADIENT_TENSOR !<Green strain tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DERIVED_DEFORMATION_GROWTH = EQUATIONS_SET_DEFORMATION_GROWTH_TENSOR !<Growth deformation tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DERIVED_R_CAUCHY_GREEN_DEFORMATION = &
    & EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR !<Right Cauchy-Green deformation field \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DERIVED_L_CAUCHY_GREEN_DEFORMATION = &
    & EQUATIONS_SET_L_CAUCHY_GREEN_DEFORMATION_TENSOR !<Left Cauchy-Green deformation field \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DERIVED_GREEN_LAGRANGE_STRAIN = EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR !<Green strain tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DERIVED_CAUCHY_STRESS = EQUATIONS_SET_CAUCHY_STRESS_TENSOR !<Cauchy stress tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DERIVED_FIRST_PK_STRESS = EQUATIONS_SET_FIRST_PK_STRESS_TENSOR !<1st Piola-Kirchoff stress tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DERIVED_SECOND_PK_STRESS = EQUATIONS_SET_SECOND_PK_STRESS_TENSOR !<2nd Piola-Kirchoff stress tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  !>@}

  !> \addtogroup OpenCMISS_EquationsSetOutputTypes OpenCMISS::Iron::EquationsSet::OutputTypes
  !> \brief Equations set output types
  !> \see OpenCMISS::Iron::EquationsSet,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_OUTPUT = EQUATIONS_SET_NO_OUTPUT!<No output from the equations set \see OpenCMISS_EquationsSetOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_PROGRESS_OUTPUT = EQUATIONS_SET_PROGRESS_OUTPUT !<Progress information output for the equations set. \see OpenCMISS_EquationsSetOutputTypes,OpenCMISS
  !>@}

  !> \addtogroup OpenCMISS_EquationsSetAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes
  !> \brief The analytic function types.
  !> \see OpenCMISS::Iron::EquationsSet,OpenCMISS
  !>@{
  !> \addtogroup OpenCMISS_EquationsSetLaplaceAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::Laplace
  !> \brief The analytic function types for a Laplace equation
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1 = EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1 !<u=x**2+2*x*y-y**2 \see OpenCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2 = EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2 !<u=cos(x)cosh(y) \see OpenCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1 = EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1 !<u=x**2-2*y**2+z**2 \see OpenCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2 = EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2 !<u=cos(x)*cosh(y)*z \see OpenCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsSetHelmholtzAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::Helmholtz
  !> \brief The analytic function types for a Helmholtz equation
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1 = EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1 !<u=cos(sqrt(2)*k*x)*sin(sqrt(2)*k*y) \see OpenCMISS_EquationsSetHelmholtzAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_PoiseuilleAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::Poiseuille
  !> \brief The analytic function types for a Poiseuille equation.
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1 = EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1 !<u=ln(4/(x+y+1^2)) \see OpenCMISS_EquationsSetPoiseuilleAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_PoissonAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::Poisson
  !> \brief The analytic function types for a Poisson equation.
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_1 = EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_1 !<u=ln(4/(x+y+1^2)) \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_2 = EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_1 = EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_1 !<u=ln(6/(x+y+z+1^2)) \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_2 = EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_3 = EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXPONENTIAL_POISSON_EQUATION_TWO_DIM_1 = EQUATIONS_SET_EXPONENTIAL_POISSON_EQUATION_TWO_DIM_1 !<\see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1 = EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2 = EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DiffusionAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::Diffusion
  !> \brief The analytic function types for a diffusion equation.
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OpenCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1 !<
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_THREE_DIM_1 = &
    & EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_EQUATION_THREE_DIM_1
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_ONE_DIM_1 = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_ONE_DIM_1 = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_EQUATION_ONE_DIM_1

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM !<Prescribed solution, using a source term to correct for error - 2D with 2 compartments
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 2 compartments
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 3 compartments
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 3 compartments
  !>@}
  !> \addtogroup OpenCMISS_AdvectionDiffusionAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::AdvectionDiffusion
  !> \brief The analytic function types for an advection-diffusion equation.
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1 = &
    & EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OpenCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OpenCMISS
  !> \addtogroup OpenCMISS_StokesAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::Stokes
  !> \brief The analytic function types for a Stokes equation.
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_NavierStokesAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::NavierStokes
  !> \brief The analytic function types for a Navier-Stokes equation.
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE !< fully developed 2D channel flow (parabolic) \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN !< 2D dynamic nonlinear Taylor-Green vortex decay \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FLOWRATE_AORTA= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_FLOWRATE_AORTA !< A fourier decomposed flow waveform for boundary conditions
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SINUSOID= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_SINUSOID !< A sinusoidal flow waveform
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SPLINT_FROM_FILE= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_SPLINT_FROM_FILE !< Spline integration of dependent values specified in a file
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DarcyAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::Darcy
  !> \brief The analytic function types for a Darcy equation.
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY = &
    & EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY !<this is a solution where the finite elasticity solve is skipped to allow easy analytic testing of the mass increase & velocity solve step of incompressible poromechanical model
  !>@}
  !> \addtogroup OpenCMISS_BurgersAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::Burgers
  !> \brief The analytic function types for a Burgers equation.
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1 = EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1 = &
    & EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2 = &
    & EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1 = &
    & EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1
  !>@}

  !> \addtogroup OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::LinearElasticity
  !> \brief The analytic function types for a LinearElasticity equation
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2 = EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2 = EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsSetFiniteElasticityAnalyticFunctionTypes OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes::FiniteElasticity
  !> \brief The analytic function types for a FiniteElasticity equation
  !> \see OpenCMISS::Iron::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER = EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER !<u=tbd \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  !>@}
  !>@}
  !>@}

  !> \addtogroup OpenCMISS_AnalyticParamIndices OpenCMISS::Iron::FiniteElasticity::AnalyticParamIndices
  !> \brief Indices for EquationsSetAnalyticType%analyticUserParams
  !> \see OpenCMISS::Iron::FiniteElasticity::AnalyticParamIndices,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX !<Inner pressure parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX !<Outer pressure parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX !<Lambda parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX !<Tsi parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX !<Inner radius parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX !<Outer radius parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX !<c1 parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX !<c2 parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMFE_EQUATIONS_SET_NO_CLASS,CMFE_EQUATIONS_SET_ELASTICITY_CLASS,CMFE_EQUATIONS_SET_FLUID_MECHANICS_CLASS, &
    & CMFE_EQUATIONS_SET_ELECTROMAGNETICS_CLASS,CMFE_EQUATIONS_SET_CLASSICAL_FIELD_CLASS,CMFE_EQUATIONS_SET_BIOELECTRICS_CLASS, &
    & CMFE_EQUATIONS_SET_MODAL_CLASS,CMFE_EQUATIONS_SET_FITTING_CLASS,CMFE_EQUATIONS_SET_OPTIMISATION_CLASS, &
    & CMFE_EQUATIONS_SET_MULTI_PHYSICS_CLASS

  PUBLIC CMFE_EQUATIONS_SET_NO_TYPE,CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TYPE,CMFE_EQUATIONS_SET_FINITE_ELASTICITY_TYPE, &
    & CMFE_EQUATIONS_SET_STOKES_EQUATION_TYPE,CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_DARCY_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE,CMFE_EQUATIONS_SET_BURGERS_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_STREE_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_ELECTROSTATIC_TYPE,CMFE_EQUATIONS_SET_MAGNETOSTATIC_TYPE,CMFE_EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE, &
    & CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TYPE,CMFE_EQUATIONS_SET_POISEUILLE_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_POISSON_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE,CMFE_EQUATIONS_SET_WAVE_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_TYPE,CMFE_EQUATIONS_SET_ADVECTION_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE,CMFE_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE,CMFE_EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE, &
    & CMFE_EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE,CMFE_EQUATIONS_SET_GAUSS_FITTING_EQUATION_TYPE

  PUBLIC CMFE_EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE, &
    & CMFE_EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE, CMFE_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE, &
    & CMFE_EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE, CMFE_EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE

  PUBLIC CMFE_EQUATIONS_SET_NO_SUBTYPE,CMFE_EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE,CMFE_EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE, &
    & CMFE_EQUATIONS_SET_PLATE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_SHELL_SUBTYPE, &
    & CMFE_EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE,CMFE_EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE, CMFE_EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE,CMFE_EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE,CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE,CMFE_EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,CMFE_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE,CMFE_EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE, &
    & CMFE_EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE,CMFE_EQUATIONS_SET_INCOMPRESS_FINITE_ELASTICITY_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE,CMFE_EQUATIONS_SET_ELASTICITY_MULTI_COMP_DARCY_INRIA_SUBTYPE, &
    & CMFE_EQUATIONS_SET_INCOMPRESS_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE, &
    & CMFE_EQUATIONS_SET_INCOMPRESS_ELAST_MULTI_COMP_DARCY_SUBTYPE,CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MEMBRANE_SUBTYPE, CMFE_EQUATIONS_SET_ORTHOTROPIC_HOLZAPFEL_OGDEN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE,  &
    & CMFE_EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,CMFE_EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,CMFE_EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE, CMFE_EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ELASTICITY_FLUID_PRES_STATIC_INRIA_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ELASTI_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_STATIC_STOKES_SUBTYPE, CMFE_EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE,CMFE_EQUATIONS_SET_ALE_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE, CMFE_EQUATIONS_SET_ALE_RBS_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE,CMFE_EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE,CMFE_EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSIENT1D_NAVIER_STOKES_SUBTYPE, CMFE_EQUATIONS_SET_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_STATIC_RBS_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CHARACTERISTIC_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE, CMFE_EQUATIONS_SET_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_STREE1D0D_SUBTYPE, CMFE_EQUATIONS_SET_STREE1D0D_ADV_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MULTISCALE3D_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CONSTITUTIVE_MU_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_COUPLED1D0D_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE,CMFE_EQUATIONS_SET_STANDARD_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE,CMFE_EQUATIONS_SET_ALE_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE,CMFE_EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE,CMFE_EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE,CMFE_EQUATIONS_SET_GENERALISED_POISSON_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE, CMFE_EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE, CMFE_EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE,&
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE,CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE,CMFE_EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE,CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE,CMFE_EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_ALE_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE,CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ADVECTION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE,CMFE_EQUATIONS_SET_MULT_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE,CMFE_EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MONODOMAIN_CELLML_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_GAUSS_FITTING_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MAT_PROPERTIES_GAUSS_FITTING_SUBTYPE,CMFE_EQUATIONS_SET_MAT_PROP_INRIA_GAUSS_FITTING_SUBTYPE, &
    & CMFE_EQUATIONS_SET_DIV_FREE_GAUSS_FITTING_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_BURGERS_SUBTYPE,CMFE_EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE, &
    & CMFE_EQUATIONS_SET_STATIC_BURGERS_SUBTYPE, &
    & CMFE_EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE,CMFE_EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE,CMFE_EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CONSTIT_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,CMFE_EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
    & CMFE_EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE,CMFE_EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE

  PUBLIC CMFE_EQUATIONS_SET_FITTING_NO_SMOOTHING,CMFE_EQUATIONS_SET_FITTING_SOBOLEV_VALUE_SMOOTHING, &
    & CMFE_EQUATIONS_SET_FITTING_SOBOLEV_DIFFERENCE_SMOOTHING,CMFE_EQUATIONS_SET_FITTING_STRAIN_ENERGY_SMOOTHING

  PUBLIC CMFE_EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE, CMFE_EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_REAC_DIFF_SUBTYPE

  PUBLIC CMFE_EQUATIONS_SET_FEM_SOLUTION_METHOD,CMFE_EQUATIONS_SET_BEM_SOLUTION_METHOD,CMFE_EQUATIONS_SET_FD_SOLUTION_METHOD, &
    & CMFE_EQUATIONS_SET_FV_SOLUTION_METHOD,CMFE_EQUATIONS_SET_GFEM_SOLUTION_METHOD,CMFE_EQUATIONS_SET_GFD_SOLUTION_METHOD, &
    & CMFE_EQUATIONS_SET_GFV_SOLUTION_METHOD

  PUBLIC CMFE_EQUATIONS_SET_DERIVED_DEFORMATION_GRADIENT,CMFE_EQUATIONS_SET_DERIVED_R_CAUCHY_GREEN_DEFORMATION, &
    & CMFE_EQUATIONS_SET_DERIVED_L_CAUCHY_GREEN_DEFORMATION,CMFE_EQUATIONS_SET_DERIVED_GREEN_LAGRANGE_STRAIN, &
    & CMFE_EQUATIONS_SET_DERIVED_CAUCHY_STRESS,CMFE_EQUATIONS_SET_DERIVED_FIRST_PK_STRESS, &
    & CMFE_EQUATIONS_SET_DERIVED_SECOND_PK_STRESS
 
  PUBLIC CMFE_EQUATIONS_SET_NO_OUTPUT,CMFE_EQUATIONS_SET_PROGRESS_OUTPUT

  PUBLIC CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1,CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2, &
    & CMFE_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1,CMFE_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2

  PUBLIC CMFE_EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1

  PUBLIC CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1,CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1, &
    & CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2,CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1, &
    & CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2

  PUBLIC CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1,CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1, &
    & CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_THREE_DIM_1,CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_ONE_DIM_1, &
    & CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_ONE_DIM_1,CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM, &
    & CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM,CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM, &
    & CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM

  PUBLIC CMFE_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1

  PUBLIC CMFE_EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1

  PUBLIC CMFE_EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1,CMFE_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1, &
    & CMFE_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2, &
    & CMFE_EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1

  PUBLIC CMFE_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_1,CMFE_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_2
  PUBLIC CMFE_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_1,CMFE_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_2, &
    & CMFE_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_EXPONENTIAL_POISSON_EQUATION_TWO_DIM_1
  PUBLIC CMFE_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1,CMFE_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2

  PUBLIC CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1,CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2, &
    & CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4,CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5
  PUBLIC CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1,CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2, &
    & CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4,CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5

  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE, &
    & CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN
  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FLOWRATE_AORTA, &
    &    CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SINUSOID, &
    &    CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SPLINT_FROM_FILE
  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1,CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2, &
    & CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4,CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5
  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1,CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2, &
    & CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4,CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5

  PUBLIC CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1,CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2, &
    & CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1,CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2, &
    & CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY

  PUBLIC CMFE_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER
  PUBLIC CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX,CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX
  PUBLIC CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX,CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX
  PUBLIC CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX,CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX
  PUBLIC CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX,CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX

!==================================================================================================================================
!
! EquationsSetRoutines
!
!==================================================================================================================================

 !Module parameters

 !Module types

 !Module variables

 !Interfaces

 !>Finish the creation of a analytic solution for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_AnalyticCreateStart
 INTERFACE cmfe_EquationsSet_AnalyticCreateFinish
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticCreateFinishNumber
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticCreateFinishObj
 END INTERFACE cmfe_EquationsSet_AnalyticCreateFinish

 !>Start the creation of a analytic solution for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_AnalyticCreateFinish
 INTERFACE cmfe_EquationsSet_AnalyticCreateStart
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticCreateStartNumber
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticCreateStartObj
 END INTERFACE cmfe_EquationsSet_AnalyticCreateStart

 !>Destroy the analytic solution for an equations set.
 INTERFACE cmfe_EquationsSet_AnalyticDestroy
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticDestroyNumber
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticDestroyObj
 END INTERFACE cmfe_EquationsSet_AnalyticDestroy

 !>Evaluates the current analytic solution for an equations set.
 INTERFACE cmfe_EquationsSet_AnalyticEvaluate
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticEvaluateNumber
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticEvaluateObj
 END INTERFACE cmfe_EquationsSet_AnalyticEvaluate

 !>Returns the analytic time for an equations set.
 INTERFACE cmfe_EquationsSet_AnalyticTimeGet
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticTimeGetNumber
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticTimeGetObj
 END INTERFACE cmfe_EquationsSet_AnalyticTimeGet

 !>Sets/changes the analytic time for an equations set.
 INTERFACE cmfe_EquationsSet_AnalyticTimeSet
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticTimeSetNumber
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticTimeSetObj
 END INTERFACE cmfe_EquationsSet_AnalyticTimeSet

 !>Finish the creation of an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_CreateStart
 INTERFACE cmfe_EquationsSet_CreateFinish
   MODULE PROCEDURE cmfe_EquationsSet_CreateFinishNumber
   MODULE PROCEDURE cmfe_EquationsSet_CreateFinishObj
 END INTERFACE cmfe_EquationsSet_CreateFinish

 !>Start the creation of an equations set on a region. \see OpenCMISS::Iron::cmfe_EquationsSet_CreateFinish
 INTERFACE cmfe_EquationsSet_CreateStart
   MODULE PROCEDURE cmfe_EquationsSet_CreateStartNumber
   MODULE PROCEDURE cmfe_EquationsSet_CreateStartObj
 END INTERFACE cmfe_EquationsSet_CreateStart

 !>Destroy an equations set.
 INTERFACE cmfe_EquationsSet_Destroy
   MODULE PROCEDURE cmfe_EquationsSet_DestroyNumber
   MODULE PROCEDURE cmfe_EquationsSet_DestroyObj
 END INTERFACE cmfe_EquationsSet_Destroy

 !>Finish the creation of dependent variables for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_DependentCreateStart
 INTERFACE cmfe_EquationsSet_DependentCreateFinish
   MODULE PROCEDURE cmfe_EquationsSet_DependentCreateFinishNumber
   MODULE PROCEDURE cmfe_EquationsSet_DependentCreateFinishObj
 END INTERFACE cmfe_EquationsSet_DependentCreateFinish

 !>Start the creation of dependent variables for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_DependentCreateFinish
 INTERFACE cmfe_EquationsSet_DependentCreateStart
   MODULE PROCEDURE cmfe_EquationsSet_DependentCreateStartNumber
   MODULE PROCEDURE cmfe_EquationsSet_DependentCreateStartObj
 END INTERFACE cmfe_EquationsSet_DependentCreateStart

 !>Destroy the dependent variables for an equations set.
 INTERFACE cmfe_EquationsSet_DependentDestroy
   MODULE PROCEDURE cmfe_EquationsSet_DependentDestroyNumber
   MODULE PROCEDURE cmfe_EquationsSet_DependentDestroyObj
 END INTERFACE cmfe_EquationsSet_DependentDestroy

 !>Finish the creation of derived variables for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_DerivedCreateStart
 INTERFACE cmfe_EquationsSet_DerivedCreateFinish
   MODULE PROCEDURE cmfe_EquationsSet_DerivedCreateFinishNumber
   MODULE PROCEDURE cmfe_EquationsSet_DerivedCreateFinishObj
 END INTERFACE cmfe_EquationsSet_DerivedCreateFinish

 !>Start the creation of derived variables for an equations set. These are used to store any intermediate
 !>calculated values, for example stress and strain fields in an elasticity problem. \see OpenCMISS::Iron::cmfe_EquationsSet_DerivedCreateFinish
 INTERFACE cmfe_EquationsSet_DerivedCreateStart
   MODULE PROCEDURE cmfe_EquationsSet_DerivedCreateStartNumber
   MODULE PROCEDURE cmfe_EquationsSet_DerivedCreateStartObj
 END INTERFACE cmfe_EquationsSet_DerivedCreateStart

 !>Destroy the derived variables for an equations set.
 INTERFACE cmfe_EquationsSet_DerivedDestroy
   MODULE PROCEDURE cmfe_EquationsSet_DerivedDestroyNumber
   MODULE PROCEDURE cmfe_EquationsSet_DerivedDestroyObj
 END INTERFACE cmfe_EquationsSet_DerivedDestroy

 !>Finish the creation of equations for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_EquationsCreateStart
 INTERFACE cmfe_EquationsSet_EquationsCreateFinish
   MODULE PROCEDURE cmfe_EquationsSet_EquationsCreateFinishNumber
   MODULE PROCEDURE cmfe_EquationsSet_EquationsCreateFinishObj
 END INTERFACE cmfe_EquationsSet_EquationsCreateFinish

 !>Start the creation of equations for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_EquationsCreateFinish
 INTERFACE cmfe_EquationsSet_EquationsCreateStart
   MODULE PROCEDURE cmfe_EquationsSet_EquationsCreateStartNumber
   MODULE PROCEDURE cmfe_EquationsSet_EquationsCreateStartObj
 END INTERFACE cmfe_EquationsSet_EquationsCreateStart

 !>Destroy the equations for an equations set.
 INTERFACE cmfe_EquationsSet_EquationsDestroy
   MODULE PROCEDURE cmfe_EquationsSet_EquationsDestroyNumber
   MODULE PROCEDURE cmfe_EquationsSet_EquationsDestroyObj
 END INTERFACE cmfe_EquationsSet_EquationsDestroy

 !>Finish the creation of independent fields for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_IndependentCreateStart
 INTERFACE cmfe_EquationsSet_IndependentCreateFinish
   MODULE PROCEDURE cmfe_EquationsSet_IndependentCreateFinishNumber
   MODULE PROCEDURE cmfe_EquationsSet_IndependentCreateFinishObj
 END INTERFACE cmfe_EquationsSet_IndependentCreateFinish

 !>Start the creation of independent fields for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_MaterialsCreateFinish
 INTERFACE cmfe_EquationsSet_IndependentCreateStart
   MODULE PROCEDURE cmfe_EquationsSet_IndependentCreateStartNumber
   MODULE PROCEDURE cmfe_EquationsSet_IndependentCreateStartObj
 END INTERFACE cmfe_EquationsSet_IndependentCreateStart

 !>Destroy the independent fields for an equations set.
 INTERFACE cmfe_EquationsSet_IndependentDestroy
   MODULE PROCEDURE cmfe_EquationsSet_IndependentDestroyNumber
   MODULE PROCEDURE cmfe_EquationsSet_IndependentDestroyObj
 END INTERFACE cmfe_EquationsSet_IndependentDestroy

 !>Returns the label for an equations set.
 INTERFACE cmfe_EquationsSet_LabelGet
   MODULE PROCEDURE cmfe_EquationsSet_LabelGetCNumber
   MODULE PROCEDURE cmfe_EquationsSet_LabelGetCObj
   MODULE PROCEDURE cmfe_EquationsSet_LabelGetVSNumber
   MODULE PROCEDURE cmfe_EquationsSet_LabelGetVSObj
 END INTERFACE cmfe_EquationsSet_LabelGet

 !>Sets/changes the label for an equations set.
 INTERFACE cmfe_EquationsSet_LabelSet
   MODULE PROCEDURE cmfe_EquationsSet_LabelSetCNumber
   MODULE PROCEDURE cmfe_EquationsSet_LabelSetCObj
   MODULE PROCEDURE cmfe_EquationsSet_LabelSetVSNumber
   MODULE PROCEDURE cmfe_EquationsSet_LabelSetVSObj
 END INTERFACE cmfe_EquationsSet_LabelSet

 !>Finish the creation of materials for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_MaterialsCreateStart
 INTERFACE cmfe_EquationsSet_MaterialsCreateFinish
   MODULE PROCEDURE cmfe_EquationsSet_MaterialsCreateFinishNumber
   MODULE PROCEDURE cmfe_EquationsSet_MaterialsCreateFinishObj
 END INTERFACE cmfe_EquationsSet_MaterialsCreateFinish

 !>Start the creation of materials for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_MaterialsCreateFinish
 INTERFACE cmfe_EquationsSet_MaterialsCreateStart
   MODULE PROCEDURE cmfe_EquationsSet_MaterialsCreateStartNumber
   MODULE PROCEDURE cmfe_EquationsSet_MaterialsCreateStartObj
 END INTERFACE cmfe_EquationsSet_MaterialsCreateStart

 !>Destroy the materials for an equations set.
 INTERFACE cmfe_EquationsSet_MaterialsDestroy
   MODULE PROCEDURE cmfe_EquationsSet_MaterialsDestroyNumber
   MODULE PROCEDURE cmfe_EquationsSet_MaterialsDestroyObj
 END INTERFACE cmfe_EquationsSet_MaterialsDestroy

 !>Gets the output type for an equations set.
 INTERFACE cmfe_EquationsSet_OutputTypeGet
   MODULE PROCEDURE cmfe_EquationsSet_OutputTypeGetNumber
   MODULE PROCEDURE cmfe_EquationsSet_OutputTypeGetObj
 END INTERFACE cmfe_EquationsSet_OutputTypeGet

 !>Sets/changes the output type an equations set.
 INTERFACE cmfe_EquationsSet_OutputTypeSet
   MODULE PROCEDURE cmfe_EquationsSet_OutputTypeSetNumber
   MODULE PROCEDURE cmfe_EquationsSet_OutputTypeSetObj
 END INTERFACE cmfe_EquationsSet_OutputTypeSet

 !>Returns the solution method for an equations set.
 INTERFACE cmfe_EquationsSet_SolutionMethodGet
   MODULE PROCEDURE cmfe_EquationsSet_SolutionMethodGetNumber
   MODULE PROCEDURE cmfe_EquationsSet_SolutionMethodGetObj
 END INTERFACE cmfe_EquationsSet_SolutionMethodGet

 !>Sets/changes the solution method for an equations set.
 INTERFACE cmfe_EquationsSet_SolutionMethodSet
   MODULE PROCEDURE cmfe_EquationsSet_SolutionMethodSetNumber
   MODULE PROCEDURE cmfe_EquationsSet_SolutionMethodSetObj
 END INTERFACE cmfe_EquationsSet_SolutionMethodSet

 !>Finish the creation of a source for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_SourceCreateStart
 INTERFACE cmfe_EquationsSet_SourceCreateFinish
   MODULE PROCEDURE cmfe_EquationsSet_SourceCreateFinishNumber
   MODULE PROCEDURE cmfe_EquationsSet_SourceCreateFinishObj
 END INTERFACE cmfe_EquationsSet_SourceCreateFinish

 !>Start the creation of a source for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_SourceCreateFinish
 INTERFACE cmfe_EquationsSet_SourceCreateStart
   MODULE PROCEDURE cmfe_EquationsSet_SourceCreateStartNumber
   MODULE PROCEDURE cmfe_EquationsSet_SourceCreateStartObj
 END INTERFACE cmfe_EquationsSet_SourceCreateStart

 !>Destroy the source for an equations set.
 INTERFACE cmfe_EquationsSet_SourceDestroy
   MODULE PROCEDURE cmfe_EquationsSet_SourceDestroyNumber
   MODULE PROCEDURE cmfe_EquationsSet_SourceDestroyObj
 END INTERFACE cmfe_EquationsSet_SourceDestroy

 !>Returns the equations set specification array
 INTERFACE cmfe_EquationsSet_SpecificationGet
   MODULE PROCEDURE cmfe_EquationsSet_SpecificationGetNumber
   MODULE PROCEDURE cmfe_EquationsSet_SpecificationGetObj
 END INTERFACE cmfe_EquationsSet_SpecificationGet

 !>Returns the size of the equations set specification array.
 INTERFACE cmfe_EquationsSet_SpecificationSizeGet
   MODULE PROCEDURE cmfe_EquationsSet_SpecificationSizeGetNumber
   MODULE PROCEDURE cmfe_EquationsSet_SpecificationSizeGetObj
 END INTERFACE cmfe_EquationsSet_SpecificationSizeGet

 !>Calculates an output field for the equations set.
 INTERFACE cmfe_EquationsSet_DerivedVariableCalculate
   MODULE PROCEDURE cmfe_EquationsSet_DerivedVariableCalculateNumber
   MODULE PROCEDURE cmfe_EquationsSet_DerivedVariableCalculateObj
 END INTERFACE cmfe_EquationsSet_DerivedVariableCalculate

 !>Set the derived field variable type to be used by a derived variable
 INTERFACE cmfe_EquationsSet_DerivedVariableSet
   MODULE PROCEDURE cmfe_EquationsSet_DerivedVariableSetNumber
   MODULE PROCEDURE cmfe_EquationsSet_DerivedVariableSetObj
 END INTERFACE cmfe_EquationsSet_DerivedVariableSet
 
 !>Evaluate a tensor at a given element Gauss location.
 INTERFACE cmfe_EquationsSet_TensorInterpolateGaussPoint
   MODULE PROCEDURE cmfe_EquationsSet_TensorInterpolateGaussPointNumber
   MODULE PROCEDURE cmfe_EquationsSet_TensorInterpolateGaussPointObj
 END INTERFACE cmfe_EquationsSet_TensorInterpolateGaussPoint

 !>Evaluate a tensor at a given element xi location.
 INTERFACE cmfe_EquationsSet_TensorInterpolateXi
   MODULE PROCEDURE cmfe_EquationsSet_TensorInterpolateXiNumber
   MODULE PROCEDURE cmfe_EquationsSet_TensorInterpolateXiObj
 END INTERFACE cmfe_EquationsSet_TensorInterpolateXi

 !>Returns the equations set current times
 INTERFACE cmfe_EquationsSet_TimesGet
   MODULE PROCEDURE cmfe_EquationsSet_TimesGetNumber
   MODULE PROCEDURE cmfe_EquationsSet_TimesGetObj
 END INTERFACE cmfe_EquationsSet_TimesGet

 !>Sets/changes the equations set current times
 INTERFACE cmfe_EquationsSet_TimesSet
   MODULE PROCEDURE cmfe_EquationsSet_TimesSetNumber
   MODULE PROCEDURE cmfe_EquationsSet_TimesSetObj
 END INTERFACE cmfe_EquationsSet_TimesSet

 !>Gets the equations set analytic user parameter
 INTERFACE cmfe_EquationsSet_AnalyticUserParamGet
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticUserParamGetNumber
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticUserParamGetObj
 END INTERFACE cmfe_EquationsSet_AnalyticUserParamGet

 !>Sets/changes the equations set analytic user parameter
 INTERFACE cmfe_EquationsSet_AnalyticUserParamSet
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticUserParamSetNumber
   MODULE PROCEDURE cmfe_EquationsSet_AnalyticUserParamSetObj
 END INTERFACE cmfe_EquationsSet_AnalyticUserParamSet

 PUBLIC cmfe_EquationsSet_AnalyticCreateFinish,cmfe_EquationsSet_AnalyticCreateStart

 PUBLIC cmfe_EquationsSet_AnalyticDestroy

 PUBLIC cmfe_EquationsSet_AnalyticEvaluate

 PUBLIC cmfe_EquationsSet_AnalyticTimeGet,cmfe_EquationsSet_AnalyticTimeSet

 PUBLIC cmfe_EquationsSet_CreateFinish,cmfe_EquationsSet_CreateStart

 PUBLIC cmfe_EquationsSet_Destroy

 PUBLIC cmfe_EquationsSet_DependentCreateFinish,cmfe_EquationsSet_DependentCreateStart

 PUBLIC cmfe_EquationsSet_DependentDestroy

 PUBLIC cmfe_EquationsSet_DerivedCreateFinish,cmfe_EquationsSet_DerivedCreateStart

 PUBLIC cmfe_EquationsSet_DerivedDestroy

 PUBLIC cmfe_EquationsSet_DerivedVariableCalculate,cmfe_EquationsSet_DerivedVariableSet

 PUBLIC cmfe_EquationsSet_EquationsCreateFinish,cmfe_EquationsSet_EquationsCreateStart

 PUBLIC cmfe_EquationsSet_EquationsDestroy

 PUBLIC cmfe_EquationsSet_IndependentCreateFinish,cmfe_EquationsSet_IndependentCreateStart

 PUBLIC cmfe_EquationsSet_IndependentDestroy

 PUBLIC cmfe_EquationsSet_LabelGet,cmfe_EquationsSet_LabelSet

 PUBLIC cmfe_EquationsSet_MaterialsCreateFinish,cmfe_EquationsSet_MaterialsCreateStart

 PUBLIC cmfe_EquationsSet_MaterialsDestroy

 PUBLIC cmfe_Equationsset_OutputTypeGet,cmfe_EquationsSet_OutputTypeSet

 PUBLIC cmfe_EquationsSet_SolutionMethodGet,cmfe_EquationsSet_SolutionMethodSet

 PUBLIC cmfe_EquationsSet_SourceCreateFinish,cmfe_EquationsSet_SourceCreateStart

 PUBLIC cmfe_EquationsSet_SourceDestroy

 PUBLIC cmfe_EquationsSet_SpecificationGet,cmfe_EquationsSet_SpecificationSizeGet

 PUBLIC cmfe_EquationsSet_TensorInterpolateGaussPoint

 PUBLIC cmfe_EquationsSet_TensorInterpolateXi

 PUBLIC cmfe_EquationsSet_TimesGet,cmfe_EquationsSet_TimesSet

 PUBLIC cmfe_EquationsSet_AnalyticUserParamSet,cmfe_EquationsSet_AnalyticUserParamGet

!==================================================================================================================================
!
! FieldRoutines
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_FieldConstants OpenCMISS::Iron::Field::Constants
 !> \brief Field constants.
 !>@{
 !> \addtogroup OpenCMISS_FieldDependentTypes OpenCMISS::Iron::Field::DependentTypes
 !> \brief Depedent field parameter types.
 !> \see OpenCMISS::Iron::Field,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_INDEPENDENT_TYPE = FIELD_INDEPENDENT_TYPE !<Independent field type \see OpenCMISS_FieldDependentTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEPENDENT_TYPE = FIELD_DEPENDENT_TYPE !<Dependent field type \see OpenCMISS_FieldDependentTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_FieldDimensionTypes OpenCMISS::Iron::Field::DimensionTypes
 !> \brief Field dimension parameter types.
 !> \see OpenCMISS::Iron::Field,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_SCALAR_DIMENSION_TYPE = FIELD_SCALAR_DIMENSION_TYPE !<Scalar field \see OpenCMISS_FieldDimensionTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_VECTOR_DIMENSION_TYPE = FIELD_VECTOR_DIMENSION_TYPE !<Vector field \see OpenCMISS_FieldDimensionTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_TENSOR_DIMENSION_TYPE = FIELD_TENSOR_DIMENSION_TYPE !<Tensor field \see OpenCMISS_FieldDimensionTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_FieldTypes OpenCMISS::Iron::Field::Types
 !> \brief Field type parameters.
 !> \see OpenCMISS::Iron::Field,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_GEOMETRIC_TYPE = FIELD_GEOMETRIC_TYPE !<Geometric field \see OpenCMISS_FieldTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_FIBRE_TYPE = FIELD_FIBRE_TYPE !<Fibre field \see OpenCMISS_FieldTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_GENERAL_TYPE = FIELD_GENERAL_TYPE !<General field \see OpenCMISS_FieldTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_MATERIAL_TYPE = FIELD_MATERIAL_TYPE !<Material field \see OpenCMISS_FieldTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_GEOMETRIC_GENERAL_TYPE = FIELD_GEOMETRIC_GENERAL_TYPE !<Geometric general field \see OpenCMISS_FieldTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_FieldInterpolationTypes OpenCMISS::Iron::Field::InterpolationTypes
 !> \brief Field interpolation parameters.
 !> \see OpenCMISS::Iron::Field,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_CONSTANT_INTERPOLATION = FIELD_CONSTANT_INTERPOLATION !<Constant interpolation. One parameter for the field \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_ELEMENT_BASED_INTERPOLATION = FIELD_ELEMENT_BASED_INTERPOLATION !<Element based interpolation. Parameters are different in each element \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_NODE_BASED_INTERPOLATION = FIELD_NODE_BASED_INTERPOLATION !<Node based interpolation. Parameters are nodal based and a basis function is used \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_GRID_POINT_BASED_INTERPOLATION = FIELD_GRID_POINT_BASED_INTERPOLATION !<Grid point based interpolation. Parameters are different at each grid point \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_GAUSS_POINT_BASED_INTERPOLATION = FIELD_GAUSS_POINT_BASED_INTERPOLATION !<Gauss point based interpolation. Parameters are different at each Gauss point \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DATA_POINT_BASED_INTERPOLATION = FIELD_DATA_POINT_BASED_INTERPOLATION !<Data point based interpolation. Parameters are different at each data point \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_FieldVariableTypes OpenCMISS::Iron::Field::VariableTypes
 !> \brief Field variable type parameters.
 !> \see OpenCMISS::Iron::Field,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_NUMBER_OF_VARIABLE_SUBTYPES = FIELD_NUMBER_OF_VARIABLE_SUBTYPES !<The number of subtypes of a variable - i.e., u, du/dn, du/dt, d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_U_VARIABLE_TYPE = FIELD_U_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELUDELN_VARIABLE_TYPE = FIELD_DELUDELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELUDELT_VARIABLE_TYPE = FIELD_DELUDELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2UDELT2_VARIABLE_TYPE = FIELD_DEL2UDELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_V_VARIABLE_TYPE = FIELD_V_VARIABLE_TYPE !<Second standard variable type i.e., v \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELVDELN_VARIABLE_TYPE = FIELD_DELVDELN_VARIABLE_TYPE !<Second normal derivative variable type i.e., dv/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELVDELT_VARIABLE_TYPE = FIELD_DELVDELT_VARIABLE_TYPE !<Second first time derivative variable type i.e., dv/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2VDELT2_VARIABLE_TYPE = FIELD_DEL2VDELT2_VARIABLE_TYPE !<Second second time derivative variable type i.e., d^2v/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_W_VARIABLE_TYPE = FIELD_W_VARIABLE_TYPE !<Third standard variable type i.e., w \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_U1_VARIABLE_TYPE = FIELD_U1_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU1DELN_VARIABLE_TYPE = FIELD_DELU1DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU1DELT_VARIABLE_TYPE = FIELD_DELU1DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U1DELT2_VARIABLE_TYPE = FIELD_DEL2U1DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_U2_VARIABLE_TYPE = FIELD_U2_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU2DELN_VARIABLE_TYPE = FIELD_DELU2DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU2DELT_VARIABLE_TYPE = FIELD_DELU2DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U2DELT2_VARIABLE_TYPE = FIELD_DEL2U2DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_U3_VARIABLE_TYPE = FIELD_U3_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU3DELN_VARIABLE_TYPE = FIELD_DELU3DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU3DELT_VARIABLE_TYPE = FIELD_DELU3DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U3DELT2_VARIABLE_TYPE = FIELD_DEL2U3DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_U4_VARIABLE_TYPE = FIELD_U4_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU4DELN_VARIABLE_TYPE = FIELD_DELU4DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU4DELT_VARIABLE_TYPE = FIELD_DELU4DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U4DELT2_VARIABLE_TYPE = FIELD_DEL2U4DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_U5_VARIABLE_TYPE = FIELD_U5_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU5DELN_VARIABLE_TYPE = FIELD_DELU5DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU5DELT_VARIABLE_TYPE = FIELD_DELU5DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U5DELT2_VARIABLE_TYPE = FIELD_DEL2U5DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_U6_VARIABLE_TYPE = FIELD_U6_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU6DELN_VARIABLE_TYPE = FIELD_DELU6DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU6DELT_VARIABLE_TYPE = FIELD_DELU6DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U6DELT2_VARIABLE_TYPE = FIELD_DEL2U6DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_U7_VARIABLE_TYPE = FIELD_U7_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU7DELN_VARIABLE_TYPE = FIELD_DELU7DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU7DELT_VARIABLE_TYPE = FIELD_DELU7DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U7DELT2_VARIABLE_TYPE = FIELD_DEL2U7DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_U8_VARIABLE_TYPE = FIELD_U8_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU8DELN_VARIABLE_TYPE = FIELD_DELU8DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU8DELT_VARIABLE_TYPE = FIELD_DELU8DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U8DELT2_VARIABLE_TYPE = FIELD_DEL2U8DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_U9_VARIABLE_TYPE = FIELD_U9_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU9DELN_VARIABLE_TYPE = FIELD_DELU9DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU9DELT_VARIABLE_TYPE = FIELD_DELU9DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U9DELT2_VARIABLE_TYPE = FIELD_DEL2U9DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_U10_VARIABLE_TYPE = FIELD_U10_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU10DELN_VARIABLE_TYPE = FIELD_DELU10DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU10DELT_VARIABLE_TYPE = FIELD_DELU10DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U10DELT2_VARIABLE_TYPE = FIELD_DEL2U10DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_FieldDataTypes OpenCMISS::Iron::Field::DataTypes
 !> \brief Field data types
 !> \see OpenCMISS::Iron::Field,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_INTG_TYPE = FIELD_INTG_TYPE !<Integer field data type \see OpenCMISS_FieldDataTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_SP_TYPE = FIELD_SP_TYPE !<Single precision real field data type \see OpenCMISS_FieldDataTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_DP_TYPE = FIELD_DP_TYPE !<Double precision real field data type \see OpenCMISS_FieldDataTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_L_TYPE = FIELD_L_TYPE !<Logical field data type \see OpenCMISS_FieldDataTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_FieldDOFOrderTypes OpenCMISS::Iron::Field::DOFOrderTypes
 !> \brief Field DOF order types
 !> \see OpenCMISS::Iron::Field,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_SEPARATED_COMPONENT_DOF_ORDER = FIELD_SEPARATED_COMPONENT_DOF_ORDER !<Field variable component dofs are not contiguous \see OpenCMISS_FieldDOFOrderTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER = FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER !<Field variable component dofs are contiguous \see OpenCMISS_FieldDOFOrderTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_FieldParameterSetTypes OpenCMISS::Iron::Field::ParameterSetTypes
 !> \brief Field parameter set type parameters
 !> \see OpenCMISS::Iron::Field,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_VALUES_SET_TYPE = FIELD_VALUES_SET_TYPE !<The parameter set corresponding to the field values (at time T+DT for dynamic problems) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_BOUNDARY_CONDITIONS_SET_TYPE = FIELD_BOUNDARY_CONDITIONS_SET_TYPE !<The parameter set corresponding to the field boundary condition values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_INITIAL_VALUES_SET_TYPE = FIELD_INITIAL_VALUES_SET_TYPE !<The parameter set corresponding to the field initial values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_INCREMENTAL_VALUES_SET_TYPE = FIELD_INCREMENTAL_VALUES_SET_TYPE !<The parameter set corresponding to the field incremental values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_ANALYTIC_VALUES_SET_TYPE = FIELD_ANALYTIC_VALUES_SET_TYPE !<The parameter set corresponding to the analytic field values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_PREVIOUS_VALUES_SET_TYPE = FIELD_PREVIOUS_VALUES_SET_TYPE !<The parameter set corresponding to the previous field values (at time T) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE = FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE !<The parameter set corresponding to the mean predicited avalues (at time T+DT) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_VELOCITY_VALUES_SET_TYPE = FIELD_VELOCITY_VALUES_SET_TYPE !<The parameter set corresponding to the velocity values (at time T+DT) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_INITIAL_VELOCITY_SET_TYPE = FIELD_INITIAL_VELOCITY_SET_TYPE !<The parameter set corresponding to the initial velocity values for dynamic problems. This is also the previous velocity values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_PREVIOUS_VELOCITY_SET_TYPE = FIELD_PREVIOUS_VELOCITY_SET_TYPE !<The parameter set corresponding to the previous velocity values (at time T). This is also the initial velocity values for dynamic problems. \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE = FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE !<The parameter set corresponding to the mean predicited velocity values (at time T+DT) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_ACCELERATION_VALUES_SET_TYPE = FIELD_ACCELERATION_VALUES_SET_TYPE !<The parameter set corresponding to the acceleration values (at time T+DT) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_INITIAL_ACCELERATION_SET_TYPE = FIELD_INITIAL_ACCELERATION_SET_TYPE !<The parameter set corresponding to the initial acceleration values for dynamic problems. This is also the previous accelearation values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_PREVIOUS_ACCELERATION_SET_TYPE = FIELD_PREVIOUS_ACCELERATION_SET_TYPE !<The parameter set corresponding to the previous acceleration values (at time T).This is also the initial acceleration values for dynamic problems. \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE = FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE !<The parameter set corresponding to the mean predicited acceleration values (at time T+DT) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_PRESSURE_VALUES_SET_TYPE = FIELD_PRESSURE_VALUES_SET_TYPE !<The parameter set corresponding to the surface pressure values. \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_PREVIOUS_PRESSURE_SET_TYPE = FIELD_PREVIOUS_PRESSURE_SET_TYPE !<The parameter set corresponding to the previous surface pressure values (at time T). \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE = FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE !<The parameter set corresponding to the impermeable flag values. \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_INTEGRATED_NEUMANN_SET_TYPE = FIELD_INTEGRATED_NEUMANN_SET_TYPE !<Stores integrated Neumann values calculated from Neumann point values. \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_MESH_DISPLACEMENT_SET_TYPE=FIELD_MESH_DISPLACEMENT_SET_TYPE !<The parameter set corresponding to the mesh displacement values for ALE \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_MESH_VELOCITY_SET_TYPE=FIELD_MESH_VELOCITY_SET_TYPE !<The parameter set corresponding to the mesh velocity values for ALE \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_FieldScalingTypes OpenCMISS::Iron::Field::ScalingTypes
 !> \brief Field scaling type parameters
 !> \see OpenCMISS::Iron::Field,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_NO_SCALING = FIELD_NO_SCALING !<The field is not scaled \see OpenCMISS_FieldScalingTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_UNIT_SCALING = FIELD_UNIT_SCALING !<The field has unit scaling \see OpenCMISS_FieldScalingTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_ARC_LENGTH_SCALING = FIELD_ARC_LENGTH_SCALING !<The field has arc length scaling \see OpenCMISS_FieldScalingTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_ARITHMETIC_MEAN_SCALING = FIELD_ARITHMETIC_MEAN_SCALING !<The field has arithmetic mean of the arc length scaling \see OpenCMISS_FieldScalingTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_GEOMETRIC_MEAN_SCALING = FIELD_GEOMETRIC_MEAN_SCALING !<The field has geometric mean of the arc length scaling \see OpenCMISS_FieldScalingTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_FIELD_HARMONIC_MEAN_SCALING = FIELD_HARMONIC_MEAN_SCALING !<The field has geometric mean of the arc length scaling \see OpenCMISS_FieldScalingTypes,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Returns the interpolation type for a field variable component.
 INTERFACE cmfe_Field_ComponentInterpolationGet
   MODULE PROCEDURE cmfe_Field_ComponentInterpolationGetNumber
   MODULE PROCEDURE cmfe_Field_ComponentInterpolationGetObj
 END INTERFACE cmfe_Field_ComponentInterpolationGet

 !>Sets/changes the interpolation type for a field variable component.
 INTERFACE cmfe_Field_ComponentInterpolationSet
   MODULE PROCEDURE cmfe_Field_ComponentInterpolationSetNumber
   MODULE PROCEDURE cmfe_Field_ComponentInterpolationSetObj
 END INTERFACE cmfe_Field_ComponentInterpolationSet

 !>Returns the label for a field variable component.
 INTERFACE cmfe_Field_ComponentLabelGet
   MODULE PROCEDURE cmfe_Field_ComponentLabelGetCNumber
   MODULE PROCEDURE cmfe_Field_ComponentLabelGetCObj
   MODULE PROCEDURE cmfe_Field_ComponentLabelGetVSNumber
   MODULE PROCEDURE cmfe_Field_ComponentLabelGetVSObj
 END INTERFACE cmfe_Field_ComponentLabelGet

 !>Sets/changes the label for a field variable component.
 INTERFACE cmfe_Field_ComponentLabelSet
   MODULE PROCEDURE cmfe_Field_ComponentLabelSetCNumber
   MODULE PROCEDURE cmfe_Field_ComponentLabelSetCObj
   MODULE PROCEDURE cmfe_Field_ComponentLabelSetVSNumber
   MODULE PROCEDURE cmfe_Field_ComponentLabelSetVSObj
 END INTERFACE cmfe_Field_ComponentLabelSet

 !>Returns the mesh component number for a field variable component.
 INTERFACE cmfe_Field_ComponentMeshComponentGet
   MODULE PROCEDURE cmfe_Field_ComponentMeshComponentGetNumber
   MODULE PROCEDURE cmfe_Field_ComponentMeshComponentGetObj
 END INTERFACE cmfe_Field_ComponentMeshComponentGet

 !>Sets/changes the mesh component number for a field variable component.
 INTERFACE cmfe_Field_ComponentMeshComponentSet
   MODULE PROCEDURE cmfe_Field_ComponentMeshComponentSetNumber
   MODULE PROCEDURE cmfe_Field_ComponentMeshComponentSetObj
 END INTERFACE cmfe_Field_ComponentMeshComponentSet

 !>Initialises the values of a parameter set of a field variable component to a constant value.
 INTERFACE cmfe_Field_ComponentValuesInitialise
   MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseIntgNumber
   MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseIntgObj
   MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseSPNumber
   MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseSPObj
   MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseDPNumber
   MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseDPObj
   MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseLNumber
   MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseLObj
 END INTERFACE cmfe_Field_ComponentValuesInitialise

 !>Returns the data type for a field variable.
 INTERFACE cmfe_Field_DataTypeGet
   MODULE PROCEDURE cmfe_Field_DataTypeGetNumber
   MODULE PROCEDURE cmfe_Field_DataTypeGetObj
 END INTERFACE cmfe_Field_DataTypeGet

 !>Sets/changes the data type for a field variable.
 INTERFACE cmfe_Field_DataTypeSet
   MODULE PROCEDURE cmfe_Field_DataTypeSetNumber
   MODULE PROCEDURE cmfe_Field_DataTypeSetObj
 END INTERFACE cmfe_Field_DataTypeSet

 !>Returns the DOF order type for a field variable.
 INTERFACE cmfe_Field_DOFOrderTypeGet
   MODULE PROCEDURE cmfe_Field_DOFOrderTypeGetNumber
   MODULE PROCEDURE cmfe_Field_DOFOrderTypeGetObj
 END INTERFACE cmfe_Field_DOFOrderTypeGet

 !>Sets/changes the DOF order type for a field variable. Note: for contiguous coponent DOF ordering all the components of the field variable must have the same interpolation type.
 INTERFACE cmfe_Field_DOFOrderTypeSet
   MODULE PROCEDURE cmfe_Field_DOFOrderTypeSetNumber
   MODULE PROCEDURE cmfe_Field_DOFOrderTypeSetObj
 END INTERFACE cmfe_Field_DOFOrderTypeSet

 !>Finishes the creation of a field. \see OpenCMISS::Iron::cmfe_Field_CreateStart
 INTERFACE cmfe_Field_CreateFinish
   MODULE PROCEDURE cmfe_Field_CreateFinishNumber
   MODULE PROCEDURE cmfe_Field_CreateFinishObj
 END INTERFACE cmfe_Field_CreateFinish

 !>Starts the creation of a field. \see OpenCMISS::Iron::cmfe_Field_CreateFinish
 INTERFACE cmfe_Field_CreateStart
   MODULE PROCEDURE cmfe_Field_CreateStartNumber
   MODULE PROCEDURE cmfe_Field_CreateStartInterfaceObj
   MODULE PROCEDURE cmfe_Field_CreateStartRegionObj
 END INTERFACE cmfe_Field_CreateStart

 !>Returns the dependent type for a field.
 INTERFACE cmfe_Field_DependentTypeGet
   MODULE PROCEDURE cmfe_Field_DependentTypeGetNumber
   MODULE PROCEDURE cmfe_Field_DependentTypeGetObj
 END INTERFACE cmfe_Field_DependentTypeGet

 !>Sets/changes the dependent type for a field.
 INTERFACE cmfe_Field_DependentTypeSet
   MODULE PROCEDURE cmfe_Field_DependentTypeSetNumber
   MODULE PROCEDURE cmfe_Field_DependentTypeSetObj
 END INTERFACE cmfe_Field_DependentTypeSet

 !>Destroys a field.
 INTERFACE cmfe_Field_Destroy
   MODULE PROCEDURE cmfe_Field_DestroyNumber
   MODULE PROCEDURE cmfe_Field_DestroyObj
 END INTERFACE cmfe_Field_Destroy

 !>Returns the field dimension for a field variable.
 INTERFACE cmfe_Field_DimensionGet
   MODULE PROCEDURE cmfe_Field_DimensionGetNumber
   MODULE PROCEDURE cmfe_Field_DimensionGetObj
 END INTERFACE cmfe_Field_DimensionGet

 !>Sets/changes the field dimension for a field variable.
 INTERFACE cmfe_Field_DimensionSet
   MODULE PROCEDURE cmfe_Field_DimensionSetNumber
   MODULE PROCEDURE cmfe_Field_DimensionSetObj
 END INTERFACE cmfe_Field_DimensionSet

 !>Returns the geometric field for a field.
 INTERFACE cmfe_Field_GeometricFieldGet
   MODULE PROCEDURE cmfe_Field_GeometricFieldGetNumber
   MODULE PROCEDURE cmfe_Field_GeometricFieldGetObj
 END INTERFACE cmfe_Field_GeometricFieldGet

 !>Sets/changes the geometric field for a field.
 INTERFACE cmfe_Field_GeometricFieldSet
   MODULE PROCEDURE cmfe_Field_GeometricFieldSetNumber
   MODULE PROCEDURE cmfe_Field_GeometricFieldSetObj
 END INTERFACE cmfe_Field_GeometricFieldSet

 !>Gets line lengths from a geometric field given an user element number and line xi normal directions.
 INTERFACE cmfe_Field_GeometricParametersElementLineLengthGet
   MODULE PROCEDURE cmfe_Field_GeometricParametersElementLineLengthGetNumber0
   MODULE PROCEDURE cmfe_Field_GeometricParametersElementLineLengthGetNumber1
   MODULE PROCEDURE cmfe_Field_GeometricParametersElementLineLengthGetObj0
   MODULE PROCEDURE cmfe_Field_GeometricParametersElementLineLengthGetObj1
 END INTERFACE cmfe_Field_GeometricParametersElementLineLengthGet

 !>Gets volumes from a geometric field given an user element number.
 INTERFACE cmfe_Field_GeometricParametersElementVolumeGet
   MODULE PROCEDURE cmfe_Field_GeometricParametersElementVolumeGetNumber
   MODULE PROCEDURE cmfe_Field_GeometricParametersElementVolumeGetObj
 END INTERFACE cmfe_Field_GeometricParametersElementVolumeGet

 !>Returns the label for a field.
 INTERFACE cmfe_Field_LabelGet
   MODULE PROCEDURE cmfe_Field_LabelGetCNumber
   MODULE PROCEDURE cmfe_Field_LabelGetCObj
   MODULE PROCEDURE cmfe_Field_LabelGetVSNumber
   MODULE PROCEDURE cmfe_Field_LabelGetVSObj
 END INTERFACE cmfe_Field_LabelGet

 !>Sets/changes the label for a field.
 INTERFACE cmfe_Field_LabelSet
   MODULE PROCEDURE cmfe_Field_LabelSetCNumber
   MODULE PROCEDURE cmfe_Field_LabelSetCObj
   MODULE PROCEDURE cmfe_Field_LabelSetVSNumber
   MODULE PROCEDURE cmfe_Field_LabelSetVSObj
 END INTERFACE cmfe_Field_LabelSet

 INTERFACE cmfe_Field_PositionNormalTangentCalculateNode
   MODULE PROCEDURE cmfe_Field_PositionNormalTangentCalculateNodeNumber
   MODULE PROCEDURE cmfe_Field_PositionNormalTangentCalculateNodeObj
 END INTERFACE

 !>Returns the mesh decomposition for a field.
 INTERFACE cmfe_Field_DecompositionGet
   MODULE PROCEDURE cmfe_Field_DecompositionGetNumber
   MODULE PROCEDURE cmfe_Field_DecompositionGetObj
 END INTERFACE cmfe_Field_DecompositionGet

 !>Sets/changes the mesh decomposition for a field. \todo remove when fields take decomposition argument on creation???
 INTERFACE cmfe_Field_DecompositionSet
   MODULE PROCEDURE cmfe_Field_DecompositionSetNumber
   MODULE PROCEDURE cmfe_Field_DecompositionSetObj
 END INTERFACE cmfe_Field_DecompositionSet

 !>Sets/changes the data projection for a field.
 INTERFACE cmfe_Field_DataProjectionSet
   MODULE PROCEDURE cmfe_Field_DataProjectionSetNumber
   MODULE PROCEDURE cmfe_Field_DataProjectionSetObj
 END INTERFACE cmfe_Field_DataProjectionSet

 !>Returns the number of field components for a field variable.
 INTERFACE cmfe_Field_NumberOfComponentsGet
   MODULE PROCEDURE cmfe_Field_NumberOfComponentsGetNumber
   MODULE PROCEDURE cmfe_Field_NumberOfComponentsGetObj
 END INTERFACE cmfe_Field_NumberOfComponentsGet

 !>Sets/changes the number of field components for a field variable.
 INTERFACE cmfe_Field_NumberOfComponentsSet
   MODULE PROCEDURE cmfe_Field_NumberOfComponentsSetNumber
   MODULE PROCEDURE cmfe_Field_NumberOfComponentsSetObj
 END INTERFACE cmfe_Field_NumberOfComponentsSet

 !>Returns the number of field variables for a field.
 INTERFACE cmfe_Field_NumberOfVariablesGet
   MODULE PROCEDURE cmfe_Field_NumberOfVariablesGetNumber
   MODULE PROCEDURE cmfe_Field_NumberOfVariablesGetObj
 END INTERFACE cmfe_Field_NumberOfVariablesGet

 !>Sets/changes the number of field variables for a field.
 INTERFACE cmfe_Field_NumberOfVariablesSet
   MODULE PROCEDURE cmfe_Field_NumberOfVariablesSetNumber
   MODULE PROCEDURE cmfe_Field_NumberOfVariablesSetObj
 END INTERFACE cmfe_Field_NumberOfVariablesSet

 !>Adds the given value to the given parameter set for the constant of the field variable component.
 INTERFACE cmfe_Field_ParameterSetAddConstant
   MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantLObj
 END INTERFACE cmfe_Field_ParameterSetAddConstant

 !>Adds the given value to the given parameter set for a particular user element of the field variable component.
 INTERFACE cmfe_Field_ParameterSetAddElement
   MODULE PROCEDURE cmfe_Field_ParameterSetAddElementIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddElementIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddElementSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddElementSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddElementDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddElementDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddElementLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddElementLObj
 END INTERFACE cmfe_Field_ParameterSetAddElement

 !>Adds the given value to the given parameter set for a particular Gauss point of a user element of the field variable component.
 INTERFACE cmfe_Field_ParameterSetAddGaussPoint
   MODULE PROCEDURE cmfe_Field_ParameterSetAddGaussPointIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddGaussPointIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddGaussPointSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddGaussPointSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddGaussPointDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddGaussPointDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddGaussPointLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddGaussPointLObj
 END INTERFACE cmfe_Field_ParameterSetAddGaussPoint

 !>Adds the given value to the given parameter set for a particular user node of the field variable component.
 INTERFACE cmfe_Field_ParameterSetAddNode
   MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeLObj
 END INTERFACE cmfe_Field_ParameterSetAddNode

 !>Creates a new parameter set of type set type for a field variable.
 INTERFACE cmfe_Field_ParameterSetCreate
   MODULE PROCEDURE cmfe_Field_ParameterSetCreateNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetCreateObj
 END INTERFACE cmfe_Field_ParameterSetCreate

 !>Destroy a parameter set of type set type for a field variable.
 INTERFACE cmfe_Field_ParameterSetDestroy
   MODULE PROCEDURE cmfe_Field_ParameterSetDestroyNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetDestroyObj
 END INTERFACE cmfe_Field_ParameterSetDestroy

 !>Returns a pointer to the specified field parameter set local data array. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
 INTERFACE cmfe_Field_ParameterSetDataGet
   MODULE PROCEDURE cmfe_Field_ParameterSetDataGetIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetDataGetIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetDataGetSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetDataGetSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetDataGetDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetDataGetDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetDataGetLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetDataGetLObj
 END INTERFACE cmfe_Field_ParameterSetDataGet

 !>Restores the specified field variable parameter set local array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call.
 INTERFACE cmfe_Field_ParameterSetDataRestore
   MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreLObj
 END INTERFACE cmfe_Field_ParameterSetDataRestore

 !>Returns from the given parameter set a value for the specified constant of a field variable component.
 INTERFACE cmfe_Field_ParameterSetGetConstant
   MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantLObj
 END INTERFACE cmfe_Field_ParameterSetGetConstant

 !>Returns from the given parameter set a value for the specified data pont of a field variable component.
 INTERFACE cmfe_Field_ParameterSetGetDataPoint
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointIntgNumberI !Interface
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointIntgNumberR !Region
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointSPNumberI !Interface
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointSPNumberR !Region
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointDPNumberI !Interface
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointDPNumberR !Region
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointLNumberI !Interface
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointLNumberR !Region
   MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointLObj
 END INTERFACE cmfe_Field_ParameterSetGetDataPoint

 !>Returns from the given parameter set a value for the specified element of a field variable component.
 INTERFACE cmfe_Field_ParameterSetGetElement
   MODULE PROCEDURE cmfe_Field_ParameterSetGetElementIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetElementIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetElementSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetElementSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetElementDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetElementDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetElementLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetElementLObj
 END INTERFACE cmfe_Field_ParameterSetGetElement

 !>Returns from the given parameter set a value for the specified node and derivative of a field variable component.
 INTERFACE cmfe_Field_ParameterSetGetNode
   MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeLObj
 END INTERFACE cmfe_Field_ParameterSetGetNode

 !>Returns from the given parameter set a value for the specified element and Gauss point of a field variable component.
 INTERFACE cmfe_Field_ParameterSetGetGaussPoint ! TODO: other versions
   MODULE PROCEDURE cmfe_Field_ParameterSetGetGaussPointDPObj
 END INTERFACE cmfe_Field_ParameterSetGetGaussPoint

 !>Updates the given parameter set with the given value for the constant of a field variable component.
 INTERFACE cmfe_Field_ParameterSetUpdateConstant
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantLObj
 END INTERFACE cmfe_Field_ParameterSetUpdateConstant

 !>Update the given parameter set a value for the specified data pont of a field variable component.
 INTERFACE cmfe_Field_ParameterSetUpdateDataPoint
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointIntgNumberI !Interface
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointIntgNumberR !Region
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointSPNumberI !Interface
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointSPNumberR !Region
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointDPNumberI !Interface
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointDPNumberR !Region
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointLNumberI !Interface
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointLNumberR !Region
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointLObj
 END INTERFACE cmfe_Field_ParameterSetUpdateDataPoint

 !>Updates the given parameter set with the given value for a particular user element of a field variable component.
 INTERFACE cmfe_Field_ParameterSetUpdateElement
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementLObj
 END INTERFACE cmfe_Field_ParameterSetUpdateElement

 !>Finishes the parameter set update for a field variable. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateStart
 INTERFACE cmfe_Field_ParameterSetUpdateFinish
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateFinishNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateFinishObj
 END INTERFACE cmfe_Field_ParameterSetUpdateFinish

 !>Updates the given parameter set with the given value for a particular user node of a field variable component.
 INTERFACE cmfe_Field_ParameterSetUpdateNode
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeLObj
 END INTERFACE cmfe_Field_ParameterSetUpdateNode

 !\todo: merge the two types of routines for getting scalefactors under the same interface declaration?
 !>Gets a scale factor for a particular node.
 INTERFACE cmfe_Field_ParameterSetNodeScaleFactorGet
   MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorGetNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorGetObj
 END INTERFACE cmfe_Field_ParameterSetNodeScaleFactorGet

 !>Gets the scale factors for all nodes
 INTERFACE cmfe_Field_ParameterSetNodeScaleFactorsGet
   MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorsGetNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorsGetObj
 END INTERFACE cmfe_Field_ParameterSetNodeScaleFactorsGet

 !>Sets a scale factor for a particular node.
 INTERFACE cmfe_Field_ParameterSetNodeScaleFactorSet
   MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorSetNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorSetObj
 END INTERFACE cmfe_Field_ParameterSetNodeScaleFactorSet

 !>Sets the scale factors for all nodes
 INTERFACE cmfe_Field_ParameterSetNodeScaleFactorsSet
   MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorsSetNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorsSetObj
 END INTERFACE cmfe_Field_ParameterSetNodeScaleFactorsSet

 !>Gets the number of scalefactor dofs
 INTERFACE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGet
   MODULE PROCEDURE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj
 END INTERFACE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGet

 !>Updates the given parameter set with the given value for a particular Gauss point of a field variable component.
 INTERFACE cmfe_Field_ParameterSetUpdateGaussPoint
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointIntgNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointIntgObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointSPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointSPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointDPNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointDPObj
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointLNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointLObj
 END INTERFACE cmfe_Field_ParameterSetUpdateGaussPoint

 !>Interpolates the given parameter set at a specified xi/set of xi locations for specified element and derviative.
 INTERFACE cmfe_Field_ParameterSetInterpolateXi
   MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateXiDPNumber0
   MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateXiDPObj0
   MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateXiDPNumber1
   MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateXiDPObj1
 END INTERFACE cmfe_Field_ParameterSetInterpolateXi

 !>Interpolates the given parameter set at a specified set of Gauss points for specified element and derviative. When interpolating at multiple Gauss points, if no Gauss points are specified then all Gauss points are interpolated.
 INTERFACE cmfe_Field_ParameterSetInterpolateGauss
   MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateGaussDPNumber0
   MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateGaussDPObj0
   MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateGaussDPNumber1
   MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateGaussDPObj1
 END INTERFACE cmfe_Field_ParameterSetInterpolateGauss

 !>Updates the given parameter set with the given value for a particular data point of a field variable component.
 INTERFACE cmfe_Field_ParameterSetUpdateElementDataPoint
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementDataPointDPObj
 END INTERFACE cmfe_Field_ParameterSetUpdateElementDataPoint

 !>Starts the parameter set update for a field variable. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateFinish
 INTERFACE cmfe_Field_ParameterSetUpdateStart
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateStartNumber
   MODULE PROCEDURE cmfe_Field_ParameterSetUpdateStartObj
 END INTERFACE cmfe_Field_ParameterSetUpdateStart

 !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
 !>a component of another field variable.
 INTERFACE cmfe_Field_ParametersToFieldParametersComponentCopy
   MODULE PROCEDURE cmfe_Field_ParametersToFieldParametersComponentCopyNumber
   MODULE PROCEDURE cmfe_Field_ParametersToFieldParametersComponentCopyObj
 END INTERFACE cmfe_Field_ParametersToFieldParametersComponentCopy

 !>Returns the scaling type for a field.
 INTERFACE cmfe_Field_ScalingTypeGet
   MODULE PROCEDURE cmfe_Field_ScalingTypeGetNumber
   MODULE PROCEDURE cmfe_Field_ScalingTypeGetObj
 END INTERFACE cmfe_Field_ScalingTypeGet

 !>Sets/changes the scaling type for a field.
 INTERFACE cmfe_Field_ScalingTypeSet
   MODULE PROCEDURE cmfe_Field_ScalingTypeSetNumber
   MODULE PROCEDURE cmfe_Field_ScalingTypeSetObj
 END INTERFACE cmfe_Field_ScalingTypeSet

 !>Returns the type for a field.
 INTERFACE cmfe_Field_TypeGet
   MODULE PROCEDURE cmfe_Field_TypeGetNumber
   MODULE PROCEDURE cmfe_Field_TypeGetObj
 END INTERFACE cmfe_Field_TypeGet

 !>Sets/changes the type for a field.
 INTERFACE cmfe_Field_TypeSet
   MODULE PROCEDURE cmfe_Field_TypeSetNumber
   MODULE PROCEDURE cmfe_Field_TypeSetObj
 END INTERFACE cmfe_Field_TypeSet

 !>Returns the label for a field variable.
 INTERFACE cmfe_Field_VariableLabelGet
   MODULE PROCEDURE cmfe_Field_VariableLabelGetCNumber
   MODULE PROCEDURE cmfe_Field_VariableLabelGetCObj
   MODULE PROCEDURE cmfe_Field_VariableLabelGetVSNumber
   MODULE PROCEDURE cmfe_Field_VariableLabelGetVSObj
 END INTERFACE cmfe_Field_VariableLabelGet

 !>Sets/changes the label for a field variable.
 INTERFACE cmfe_Field_VariableLabelSet
   MODULE PROCEDURE cmfe_Field_VariableLabelSetCNumber
   MODULE PROCEDURE cmfe_Field_VariableLabelSetCObj
   MODULE PROCEDURE cmfe_Field_VariableLabelSetVSNumber
   MODULE PROCEDURE cmfe_Field_VariableLabelSetVSObj
 END INTERFACE cmfe_Field_VariableLabelSet

 !>Returns the field variable types for a field.
 INTERFACE cmfe_Field_VariableTypesGet
   MODULE PROCEDURE cmfe_Field_VariableTypesGetNumber
   MODULE PROCEDURE cmfe_Field_VariableTypesGetObj
 END INTERFACE cmfe_Field_VariableTypesGet

 !>Sets/changes the field variable types for a field.
 INTERFACE cmfe_Field_VariableTypesSet
   MODULE PROCEDURE cmfe_Field_VariableTypesSetNumber
   MODULE PROCEDURE cmfe_Field_VariableTypesSetObj
 END INTERFACE cmfe_Field_VariableTypesSet


 PUBLIC CMFE_FIELD_DEPENDENT_TYPE,CMFE_FIELD_INDEPENDENT_TYPE

 PUBLIC CMFE_FIELD_SCALAR_DIMENSION_TYPE,CMFE_FIELD_VECTOR_DIMENSION_TYPE,CMFE_FIELD_TENSOR_DIMENSION_TYPE

 PUBLIC CMFE_FIELD_GEOMETRIC_TYPE,CMFE_FIELD_FIBRE_TYPE,CMFE_FIELD_GENERAL_TYPE,CMFE_FIELD_MATERIAL_TYPE, &
   & CMFE_FIELD_GEOMETRIC_GENERAL_TYPE

 PUBLIC CMFE_FIELD_CONSTANT_INTERPOLATION,CMFE_FIELD_ELEMENT_BASED_INTERPOLATION,CMFE_FIELD_NODE_BASED_INTERPOLATION, &
   & CMFE_FIELD_GRID_POINT_BASED_INTERPOLATION,CMFE_FIELD_GAUSS_POINT_BASED_INTERPOLATION, &
   & CMFE_FIELD_DATA_POINT_BASED_INTERPOLATION

 PUBLIC CMFE_FIELD_NUMBER_OF_VARIABLE_SUBTYPES

 PUBLIC CMFE_FIELD_U_VARIABLE_TYPE,CMFE_FIELD_DELUDELN_VARIABLE_TYPE,CMFE_FIELD_DELUDELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2UDELT2_VARIABLE_TYPE, &
   & CMFE_FIELD_V_VARIABLE_TYPE,CMFE_FIELD_DELVDELN_VARIABLE_TYPE,CMFE_FIELD_DELVDELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2VDELT2_VARIABLE_TYPE, &
   & CMFE_FIELD_W_VARIABLE_TYPE, &
   & CMFE_FIELD_U1_VARIABLE_TYPE,CMFE_FIELD_DELU1DELN_VARIABLE_TYPE,CMFE_FIELD_DELU1DELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2U1DELT2_VARIABLE_TYPE, &
   & CMFE_FIELD_U2_VARIABLE_TYPE,CMFE_FIELD_DELU2DELN_VARIABLE_TYPE,CMFE_FIELD_DELU2DELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2U2DELT2_VARIABLE_TYPE, &
   & CMFE_FIELD_U3_VARIABLE_TYPE,CMFE_FIELD_DELU3DELN_VARIABLE_TYPE,CMFE_FIELD_DELU3DELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2U3DELT2_VARIABLE_TYPE, &
   & CMFE_FIELD_U4_VARIABLE_TYPE,CMFE_FIELD_DELU4DELN_VARIABLE_TYPE,CMFE_FIELD_DELU4DELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2U4DELT2_VARIABLE_TYPE, &
   & CMFE_FIELD_U5_VARIABLE_TYPE,CMFE_FIELD_DELU5DELN_VARIABLE_TYPE,CMFE_FIELD_DELU5DELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2U5DELT2_VARIABLE_TYPE, &
   & CMFE_FIELD_U6_VARIABLE_TYPE,CMFE_FIELD_DELU6DELN_VARIABLE_TYPE,CMFE_FIELD_DELU6DELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2U6DELT2_VARIABLE_TYPE, &
   & CMFE_FIELD_U7_VARIABLE_TYPE,CMFE_FIELD_DELU7DELN_VARIABLE_TYPE,CMFE_FIELD_DELU7DELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2U7DELT2_VARIABLE_TYPE, &
   & CMFE_FIELD_U8_VARIABLE_TYPE,CMFE_FIELD_DELU8DELN_VARIABLE_TYPE,CMFE_FIELD_DELU8DELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2U8DELT2_VARIABLE_TYPE, &
   & CMFE_FIELD_U9_VARIABLE_TYPE,CMFE_FIELD_DELU9DELN_VARIABLE_TYPE,CMFE_FIELD_DELU9DELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2U9DELT2_VARIABLE_TYPE, &
   & CMFE_FIELD_U10_VARIABLE_TYPE,CMFE_FIELD_DELU10DELN_VARIABLE_TYPE,CMFE_FIELD_DELU10DELT_VARIABLE_TYPE, &
   & CMFE_FIELD_DEL2U10DELT2_VARIABLE_TYPE

 PUBLIC CMFE_FIELD_INTG_TYPE,CMFE_FIELD_SP_TYPE,CMFE_FIELD_DP_TYPE,CMFE_FIELD_L_TYPE

 PUBLIC CMFE_FIELD_SEPARATED_COMPONENT_DOF_ORDER,CMFE_FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER

 PUBLIC CMFE_FIELD_VALUES_SET_TYPE,CMFE_FIELD_INITIAL_VALUES_SET_TYPE,CMFE_FIELD_INCREMENTAL_VALUES_SET_TYPE, &
   & CMFE_FIELD_BOUNDARY_CONDITIONS_SET_TYPE, &
   & CMFE_FIELD_ANALYTIC_VALUES_SET_TYPE, &
   & CMFE_FIELD_PREVIOUS_VALUES_SET_TYPE,CMFE_FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,CMFE_FIELD_VELOCITY_VALUES_SET_TYPE, &
   & CMFE_FIELD_INITIAL_VELOCITY_SET_TYPE,CMFE_FIELD_PREVIOUS_VELOCITY_SET_TYPE,CMFE_FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE, &
   & CMFE_FIELD_ACCELERATION_VALUES_SET_TYPE,CMFE_FIELD_INITIAL_ACCELERATION_SET_TYPE, &
   & CMFE_FIELD_PREVIOUS_ACCELERATION_SET_TYPE, &
   & CMFE_FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE, CMFE_FIELD_PRESSURE_VALUES_SET_TYPE, &
   & CMFE_FIELD_PREVIOUS_PRESSURE_SET_TYPE, &
   & CMFE_FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE,CMFE_FIELD_INTEGRATED_NEUMANN_SET_TYPE, &
   & CMFE_FIELD_MESH_DISPLACEMENT_SET_TYPE,CMFE_FIELD_MESH_VELOCITY_SET_TYPE

 PUBLIC CMFE_FIELD_NO_SCALING,CMFE_FIELD_UNIT_SCALING,CMFE_FIELD_ARC_LENGTH_SCALING,CMFE_FIELD_ARITHMETIC_MEAN_SCALING, &
   & CMFE_FIELD_GEOMETRIC_MEAN_SCALING,CMFE_FIELD_HARMONIC_MEAN_SCALING

 PUBLIC cmfe_Field_ComponentInterpolationGet,cmfe_Field_ComponentInterpolationSet

 PUBLIC cmfe_Field_ComponentLabelGet,cmfe_Field_ComponentLabelSet

 PUBLIC cmfe_Field_ComponentMeshComponentGet,cmfe_Field_ComponentMeshComponentSet

 PUBLIC cmfe_Field_ComponentValuesInitialise

 PUBLIC cmfe_Field_DataTypeGet,cmfe_Field_DataTypeSet

 PUBLIC cmfe_Field_DOFOrderTypeGet,cmfe_Field_DOFOrderTypeSet

 PUBLIC cmfe_Field_CreateFinish,cmfe_Field_CreateStart

 PUBLIC cmfe_Field_DependentTypeGet,cmfe_Field_DependentTypeSet

 PUBLIC cmfe_Field_Destroy

 PUBLIC cmfe_Field_DimensionGet,cmfe_Field_DimensionSet

 PUBLIC cmfe_Field_GeometricFieldGet,cmfe_Field_GeometricFieldSet

 PUBLIC cmfe_Field_GeometricParametersElementLineLengthGet, cmfe_Field_GeometricParametersElementVolumeGet

 PUBLIC cmfe_Field_LabelGet,cmfe_Field_LabelSet

 PUBLIC cmfe_Field_DecompositionGet,cmfe_Field_DecompositionSet

 PUBLIC cmfe_Field_DataProjectionSet

 PUBLIC cmfe_Field_PositionNormalTangentCalculateNode

 PUBLIC cmfe_Field_NumberOfComponentsGet,cmfe_Field_NumberOfComponentsSet

 PUBLIC cmfe_Field_NumberOfVariablesGet,cmfe_Field_NumberOfVariablesSet

 PUBLIC cmfe_Field_ParameterSetAddConstant,cmfe_Field_ParameterSetAddElement,cmfe_Field_ParameterSetAddGaussPoint, &
   & cmfe_Field_ParameterSetAddNode

 PUBLIC cmfe_Field_ParameterSetCreate

 PUBLIC cmfe_Field_ParameterSetDestroy

 PUBLIC cmfe_Field_ParameterSetDataGet,cmfe_Field_ParameterSetDataRestore

 PUBLIC cmfe_Field_ParameterSetGetConstant,cmfe_Field_ParameterSetGetElement,cmfe_Field_ParameterSetGetNode

 PUBLIC cmfe_Field_ParameterSetGetDataPoint,cmfe_Field_ParameterSetUpdateDataPoint

 PUBLIC cmfe_Field_ParameterSetUpdateConstant,cmfe_Field_ParameterSetUpdateElement,cmfe_Field_ParameterSetUpdateNode

 PUBLIC cmfe_Field_ParameterSetNodeScaleFactorGet,cmfe_Field_ParameterSetNodeScaleFactorSet

 PUBLIC cmfe_Field_ParameterSetNodeScaleFactorsGet,cmfe_Field_ParameterSetNodeScaleFactorsSet

 PUBLIC cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGet
 
 PUBLIC cmfe_Field_ParameterSetUpdateGaussPoint,cmfe_Field_ParameterSetGetGaussPoint

 PUBLIC cmfe_Field_ParameterSetInterpolateXi

 PUBLIC cmfe_Field_ParameterSetInterpolateGauss

 PUBLIC cmfe_Field_ParameterSetUpdateElementDataPoint

 PUBLIC cmfe_Field_ParameterSetUpdateFinish,cmfe_Field_ParameterSetUpdateStart

 PUBLIC cmfe_Field_ParametersToFieldParametersComponentCopy

 PUBLIC cmfe_Field_ScalingTypeGet,cmfe_Field_ScalingTypeSet

 PUBLIC cmfe_Field_TypeGet,cmfe_Field_TypeSet

 PUBLIC cmfe_Field_VariableLabelGet,cmfe_Field_VariableLabelSet

 PUBLIC cmfe_Field_VariableTypesGet,cmfe_Field_VariableTypesSet

!==================================================================================================================================
!
! FIELD_IO_ROUTINES
!
!==================================================================================================================================

 !Module parameters

 !Module types

 !Module variables

 !Interfaces

 INTERFACE cmfe_Fields_ElementsExport
   MODULE PROCEDURE cmfe_Fields_ElementsExportCCNumber
   MODULE PROCEDURE cmfe_Fields_ElementsExportVSCNumber
   MODULE PROCEDURE cmfe_Fields_ElementsExportCVSNumber
   MODULE PROCEDURE cmfe_Fields_ElementsExportVSVSNumber
   MODULE PROCEDURE cmfe_Fields_ElementsExportCCObj
   MODULE PROCEDURE cmfe_Fields_ElementsExportVSCObj
   MODULE PROCEDURE cmfe_Fields_ElementsExportCVSObj
   MODULE PROCEDURE cmfe_Fields_ElementsExportVSVSObj
 END INTERFACE cmfe_Fields_ElementsExport

 INTERFACE cmfe_Fields_NodesExport
   MODULE PROCEDURE cmfe_Fields_NodesExportCCNumber
   MODULE PROCEDURE cmfe_Fields_NodesExportVSCNumber
   MODULE PROCEDURE cmfe_Fields_NodesExportCVSNumber
   MODULE PROCEDURE cmfe_Fields_NodesExportVSVSNumber
   MODULE PROCEDURE cmfe_Fields_NodesExportCCObj
   MODULE PROCEDURE cmfe_Fields_NodesExportVSCObj
   MODULE PROCEDURE cmfe_Fields_NodesExportCVSObj
   MODULE PROCEDURE cmfe_Fields_NodesExportVSVSObj
 END INTERFACE cmfe_Fields_NodesExport

 PUBLIC cmfe_Fields_ElementsExport,cmfe_Fields_NodesExport

!==================================================================================================================================
!
! GeneratedMeshRoutines
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_GeneratedMeshConstants OpenCMISS::Iron::GeneratedMesh::Constants
 !> \brief Generated mesh constants.
 !>@{
 !> \addtogroup OpenCMISS_GeneratedMeshTypes OpenCMISS::Iron::GeneratedMesh::Types
 !> \brief Generated mesh types.
 !> \see OpenCMISS::Iron::GeneratedMesh,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_MESH_TYPE = GENERATED_MESH_REGULAR_MESH_TYPE !<A regular generated mesh. \see OpenCMISS_GeneratedMeshTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_POLAR_MESH_TYPE = GENERATED_MESH_POLAR_MESH_TYPE !<A polar generated mesh. \see OpenCMISS_GeneratedMeshTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_FRACTAL_TREE_MESH_TYPE = GENERATED_MESH_FRACTAL_TREE_MESH_TYPE !<A fractal tree generated mesh. \see OpenCMISS_GeneratedMeshTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_CYLINDER_MESH_TYPE = GENERATED_MESH_CYLINDER_MESH_TYPE !<A cylinder generated mesh. \see OpenCMISS_GeneratedMeshTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_ELLIPSOID_MESH_TYPE = GENERATED_MESH_ELLIPSOID_MESH_TYPE !<An ellipsoid generated mesh. \see OpenCMISS_GeneratedMeshTypes,OpenCMISS
 !>@}
 !>@}

 !> \addtogroup OpenCMISS_GeneratedMeshConstants OpenCMISS::Iron::GeneratedMesh::Constants
 !> \brief Generated mesh constants.
 !>@{
 !> \addtogroup OpenCMISS_GeneratedMeshSurfaceTypes OpenCMISS::Iron::GeneratedMesh::SurfaceTypes
 !> \brief Generated mesh surface types.
 !> \see OpenCMISS::Iron::GeneratedMesh,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_CYLINDER_INNER_SURFACE = GENERATED_MESH_CYLINDER_INNER_SURFACE !<Cylinder inner surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_CYLINDER_OUTER_SURFACE = GENERATED_MESH_CYLINDER_OUTER_SURFACE !<Cylinder outer surface. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_CYLINDER_TOP_SURFACE = GENERATED_MESH_CYLINDER_TOP_SURFACE !<Cylinder top surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_CYLINDER_BOTTOM_SURFACE = GENERATED_MESH_CYLINDER_BOTTOM_SURFACE !<Cylinder bottom surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_ELLIPSOID_INNER_SURFACE = GENERATED_MESH_ELLIPSOID_INNER_SURFACE !<Ellipsoid inner surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_ELLIPSOID_OUTER_SURFACE = GENERATED_MESH_ELLIPSOID_OUTER_SURFACE !<Ellipsoid outer surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_ELLIPSOID_TOP_SURFACE = GENERATED_MESH_ELLIPSOID_TOP_SURFACE !<Ellipsoid top surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_LEFT_SURFACE = GENERATED_MESH_REGULAR_LEFT_SURFACE !<Regular left surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_RIGHT_SURFACE = GENERATED_MESH_REGULAR_RIGHT_SURFACE !<Regular right surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_TOP_SURFACE = GENERATED_MESH_REGULAR_TOP_SURFACE !<Regular top surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_BOTTOM_SURFACE = GENERATED_MESH_REGULAR_BOTTOM_SURFACE !<Regular bottom surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_FRONT_SURFACE = GENERATED_MESH_REGULAR_FRONT_SURFACE !<Regular front surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_BACK_SURFACE = GENERATED_MESH_REGULAR_BACK_SURFACE !<Regular back surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Returns the basis for a generated mesh.
 INTERFACE cmfe_GeneratedMesh_BasisGet
   MODULE PROCEDURE cmfe_GeneratedMesh_BasisGetNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_BasisGetObj
 END INTERFACE cmfe_GeneratedMesh_BasisGet

 !>Sets/changes the basis for a generated mesh.
 INTERFACE cmfe_GeneratedMesh_BasisSet
   MODULE PROCEDURE cmfe_GeneratedMesh_BasisSetNumber0
   MODULE PROCEDURE cmfe_GeneratedMesh_BasisSetNumber1
   MODULE PROCEDURE cmfe_GeneratedMesh_BasisSetObj0
   MODULE PROCEDURE cmfe_GeneratedMesh_BasisSetObj1
 END INTERFACE cmfe_GeneratedMesh_BasisSet

 !>Sets/changes the base vectors for a generated mesh.
 INTERFACE cmfe_GeneratedMesh_BaseVectorsSet
   MODULE PROCEDURE cmfe_GeneratedMesh_BaseVectorsSetNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_BaseVectorsSetObj
 END INTERFACE cmfe_GeneratedMesh_BaseVectorsSet

 !>Finishes the creation of a generated mesh. \see OpenCMISS::Iron::cmfe_GeneratedMesh_CreateStart
 INTERFACE cmfe_GeneratedMesh_CreateFinish
   MODULE PROCEDURE cmfe_GeneratedMesh_CreateFinishNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_CreateFinishObj
 END INTERFACE cmfe_GeneratedMesh_CreateFinish

 !>Starts the creation of a generated mesh. \see OpenCMISS::Iron::cmfe_GeneratedMesh_CreateFinish
 INTERFACE cmfe_GeneratedMesh_CreateStart
   MODULE PROCEDURE cmfe_GeneratedMesh_CreateStartNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_CreateStartInterfaceObj
   MODULE PROCEDURE cmfe_GeneratedMesh_CreateStartRegionObj
 END INTERFACE cmfe_GeneratedMesh_CreateStart

 !>Destroys a generated mesh.
 INTERFACE cmfe_GeneratedMesh_Destroy
   MODULE PROCEDURE cmfe_GeneratedMesh_DestroyNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_DestroyObj
 END INTERFACE cmfe_GeneratedMesh_Destroy

 !>Returns the extent of a generated mesh.
 INTERFACE cmfe_GeneratedMesh_ExtentGet
   MODULE PROCEDURE cmfe_GeneratedMesh_ExtentGetNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_ExtentGetObj
 END INTERFACE cmfe_GeneratedMesh_ExtentGet

 !>Sets/changes the extent of a generated mesh.
 INTERFACE cmfe_GeneratedMesh_ExtentSet
   MODULE PROCEDURE cmfe_GeneratedMesh_ExtentSetNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_ExtentSetObj
 END INTERFACE cmfe_GeneratedMesh_ExtentSet

 !>Returns the number of elements in a generated mesh.
 INTERFACE cmfe_GeneratedMesh_NumberOfElementsGet
   MODULE PROCEDURE cmfe_GeneratedMesh_NumberOfElementsGetNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_NumberOfElementsGetObj
 END INTERFACE cmfe_GeneratedMesh_NumberOfElementsGet

 !>Sets/changes the number of elements in a generated mesh.
 INTERFACE cmfe_GeneratedMesh_NumberOfElementsSet
   MODULE PROCEDURE cmfe_GeneratedMesh_NumberOfElementsSetNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_NumberOfElementsSetObj
 END INTERFACE cmfe_GeneratedMesh_NumberOfElementsSet

 !>Returns the origin of a generated mesh.
 INTERFACE cmfe_GeneratedMesh_OriginGet
   MODULE PROCEDURE cmfe_GeneratedMesh_OriginGetNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_OriginGetObj
 END INTERFACE cmfe_GeneratedMesh_OriginGet

 !>Sets/changes the origin of a generated mesh.
 INTERFACE cmfe_GeneratedMesh_OriginSet
   MODULE PROCEDURE cmfe_GeneratedMesh_OriginSetNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_OriginSetObj
 END INTERFACE cmfe_GeneratedMesh_OriginSet

 !>Returns the type of a generated mesh.
 INTERFACE cmfe_GeneratedMesh_TypeGet
   MODULE PROCEDURE cmfe_GeneratedMesh_TypeGetNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_TypeGetObj
 END INTERFACE cmfe_GeneratedMesh_TypeGet

 !>Sets/changes the type of a generated mesh.
 INTERFACE cmfe_GeneratedMesh_TypeSet
   MODULE PROCEDURE cmfe_GeneratedMesh_TypeSetNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_TypeSetObj
 END INTERFACE cmfe_GeneratedMesh_TypeSet

 !>Calculates and sets the geometric field parameters for a generated mesh
 INTERFACE cmfe_GeneratedMesh_GeometricParametersCalculate
   MODULE PROCEDURE cmfe_GeneratedMesh_GeometricParametersCalculateNumber
   MODULE PROCEDURE cmfe_GeneratedMesh_GeometricParametersCalculateObj
 END INTERFACE cmfe_GeneratedMesh_GeometricParametersCalculate

 !>Returns a list of nodes belonging to a surface of given type
 INTERFACE cmfe_GeneratedMesh_SurfaceGet
   MODULE PROCEDURE cmfe_GeneratedMesh_SurfaceGetNumber0
   MODULE PROCEDURE cmfe_GeneratedMesh_SurfaceGetNumber1
   MODULE PROCEDURE cmfe_GeneratedMesh_SurfaceGetObj0
   MODULE PROCEDURE cmfe_GeneratedMesh_SurfaceGetObj1
 END INTERFACE cmfe_GeneratedMesh_SurfaceGet

 !>Creates an embedding of one mesh in another
 INTERFACE cmfe_MeshEmbedding_Create
   MODULE PROCEDURE cmfe_MeshEmbedding_CreateNumber
   MODULE PROCEDURE cmfe_MeshEmbedding_CreateObj
 END INTERFACE cmfe_MeshEmbedding_Create

 !>Sets the embedded nodes for one parent element
 INTERFACE cmfe_MeshEmbedding_SetChildNodePosition
   MODULE PROCEDURE cmfe_MeshEmbedding_SetChildNodePositionObj
 END INTERFACE cmfe_MeshEmbedding_SetChildNodePosition

 !>Pushes data from the parent field to the child field
 INTERFACE cmfe_MeshEmbedding_PushData
   MODULE PROCEDURE cmfe_MeshEmbedding_PushDataObj
 END INTERFACE cmfe_MeshEmbedding_PushData

 INTERFACE cmfe_MeshEmbedding_SetGaussPointData
   MODULE PROCEDURE cmfe_MeshEmbedding_SetGaussPointDataObj
 END INTERFACE cmfe_MeshEmbedding_SetGaussPointData

 INTERFACE cmfe_MeshEmbedding_PullGaussPointData
   MODULE PROCEDURE cmfe_MeshEmbedding_PullGaussPointDataObj
 END INTERFACE cmfe_MeshEmbedding_PullGaussPointData

 INTERFACE cmfe_MeshEmbedding_GetGaussPointCoord
   MODULE PROCEDURE cmfe_Field_ParameterSetGetGaussPointCoordObj
 END INTERFACE cmfe_MeshEmbedding_GetGaussPointCoord
 
 PUBLIC cmfe_MeshEmbedding_Create,cmfe_MeshEmbedding_SetChildNodePosition, cmfe_MeshEmbeddingType

 PUBLIC cmfe_MeshEmbedding_Initialise,cmfe_MeshEmbedding_SetGaussPointData

 PUBLIC cmfe_MeshEmbedding_PushData,cmfe_MeshEmbedding_PullGaussPointData

 PUBLIC cmfe_MeshEmbedding_GetGaussPointCoord

 PUBLIC CMFE_GENERATED_MESH_REGULAR_MESH_TYPE,CMFE_GENERATED_MESH_POLAR_MESH_TYPE,CMFE_GENERATED_MESH_FRACTAL_TREE_MESH_TYPE

 PUBLIC CMFE_GENERATED_MESH_CYLINDER_MESH_TYPE, CMFE_GENERATED_MESH_ELLIPSOID_MESH_TYPE

 PUBLIC CMFE_GENERATED_MESH_CYLINDER_INNER_SURFACE,CMFE_GENERATED_MESH_CYLINDER_OUTER_SURFACE

 PUBLIC CMFE_GENERATED_MESH_CYLINDER_TOP_SURFACE, CMFE_GENERATED_MESH_CYLINDER_BOTTOM_SURFACE

 PUBLIC CMFE_GENERATED_MESH_ELLIPSOID_INNER_SURFACE, CMFE_GENERATED_MESH_ELLIPSOID_OUTER_SURFACE

 PUBLIC CMFE_GENERATED_MESH_ELLIPSOID_TOP_SURFACE

 PUBLIC CMFE_GENERATED_MESH_REGULAR_LEFT_SURFACE, CMFE_GENERATED_MESH_REGULAR_RIGHT_SURFACE, &
   & CMFE_GENERATED_MESH_REGULAR_TOP_SURFACE

 PUBLIC CMFE_GENERATED_MESH_REGULAR_BOTTOM_SURFACE, CMFE_GENERATED_MESH_REGULAR_FRONT_SURFACE, &
   & CMFE_GENERATED_MESH_REGULAR_BACK_SURFACE

 PUBLIC cmfe_GeneratedMesh_BasisGet,cmfe_GeneratedMesh_BasisSet

 PUBLIC cmfe_GeneratedMesh_BaseVectorsSet

 PUBLIC cmfe_GeneratedMesh_CreateFinish,cmfe_GeneratedMesh_CreateStart

 PUBLIC cmfe_GeneratedMesh_Destroy

 PUBLIC cmfe_GeneratedMesh_ExtentGet,cmfe_GeneratedMesh_ExtentSet
 
 PUBLIC cmfe_GeneratedMesh_NumberOfElementsGet,cmfe_GeneratedMesh_NumberOfElementsSet

 PUBLIC cmfe_GeneratedMesh_OriginGet,cmfe_GeneratedMesh_OriginSet

 PUBLIC cmfe_GeneratedMesh_TypeGet,cmfe_GeneratedMesh_TypeSet

 PUBLIC cmfe_GeneratedMesh_GeometricParametersCalculate

 PUBLIC cmfe_GeneratedMesh_SurfaceGet


!==================================================================================================================================
!
! INTERFACE_ROUTINES
!
!==================================================================================================================================

 !Module parameters

 !Module types

 !Module variables

 !Interfaces

 !>Adds a mesh to an interface.
 INTERFACE cmfe_Interface_MeshAdd
   MODULE PROCEDURE cmfe_Interface_MeshAddNumber
   MODULE PROCEDURE cmfe_Interface_MeshAddObj
 END INTERFACE cmfe_Interface_MeshAdd

 !>Finishes the creation of an interface. \see OpenCMISS::Iron::cmfe_Interface_CreateStart
 INTERFACE cmfe_Interface_CreateFinish
   MODULE PROCEDURE cmfe_Interface_CreateFinishNumber
   MODULE PROCEDURE cmfe_Interface_CreateFinishObj
 END INTERFACE cmfe_Interface_CreateFinish

 !>Starts the creation of an interface. \see OpenCMISS::Iron::cmfe_Interface_CreateFinish
 INTERFACE cmfe_Interface_CreateStart
   MODULE PROCEDURE cmfe_Interface_CreateStartNumber
   MODULE PROCEDURE cmfe_Interface_CreateStartObj
 END INTERFACE cmfe_Interface_CreateStart

 !>Set the coordinate system of an inteface
 INTERFACE cmfe_Interface_CoordinateSystemSet
   MODULE PROCEDURE cmfe_Interface_CoordinateSystemSetNumber
   MODULE PROCEDURE cmfe_Interface_CoordinateSystemSetObj
 END INTERFACE cmfe_Interface_CoordinateSystemSet

 !>Get the coordinate system of an inteface
 INTERFACE cmfe_Interface_CoordinateSystemGet
   MODULE PROCEDURE cmfe_Interface_CoordinateSystemGetNumber
   MODULE PROCEDURE cmfe_Interface_CoordinateSystemGetObj
 END INTERFACE cmfe_Interface_CoordinateSystemGet

 !>Destroys an interface.
 INTERFACE cmfe_Interface_Destroy
   MODULE PROCEDURE cmfe_Interface_DestroyNumber
   MODULE PROCEDURE cmfe_Interface_DestroyObj
 END INTERFACE cmfe_Interface_Destroy

 !>Returns the label of an interface.
 INTERFACE cmfe_Interface_LabelGet
   MODULE PROCEDURE cmfe_Interface_LabelGetCNumber
   MODULE PROCEDURE cmfe_Interface_LabelGetCObj
   MODULE PROCEDURE cmfe_Interface_LabelGetVSNumber
   MODULE PROCEDURE cmfe_Interface_LabelGetVSObj
 END INTERFACE cmfe_Interface_LabelGet

 !>Sets/changes the label of an interface.
 INTERFACE cmfe_Interface_LabelSet
   MODULE PROCEDURE cmfe_Interface_LabelSetCNumber
   MODULE PROCEDURE cmfe_Interface_LabelSetCObj
   MODULE PROCEDURE cmfe_Interface_LabelSetVSNumber
   MODULE PROCEDURE cmfe_Interface_LabelSetVSObj
 END INTERFACE cmfe_Interface_LabelSet

 !>Returns the nodes for a interface.
 INTERFACE cmfe_Interface_NodesGet
   MODULE PROCEDURE cmfe_Interface_NodesGetObj
 END INTERFACE cmfe_Interface_NodesGet

 !>Finishes the creation of an interface meshes connectivity. \see OpenCMISS::Iron::cmfe_InterfaceMeshConnectivity_CreateStart
 INTERFACE cmfe_InterfaceMeshConnectivity_CreateFinish
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_CreateFinishNumber
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_CreateFinishObj
 END INTERFACE cmfe_InterfaceMeshConnectivity_CreateFinish

 !>Starts the creation of an interface meshes connectivity.
 INTERFACE cmfe_InterfaceMeshConnectivity_CreateStart
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_CreateStartNumber
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_CreateStartObj
 END INTERFACE cmfe_InterfaceMeshConnectivity_CreateStart

 !>Sets the element xi values for the mesh connectivity between an element in the interface mesh and an element in a region mesh
 INTERFACE cmfe_InterfaceMeshConnectivity_ElementXiSet
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_ElementXiSetNumber
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_ElementXiSetObj
 END INTERFACE cmfe_InterfaceMeshConnectivity_ElementXiSet

 !>Sets the number of elements coupled through a given interface mesh element
 INTERFACE cmfe_InterfaceMeshConnectivity_ElementNumberSet
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_ElementNumberSetObj
 END INTERFACE cmfe_InterfaceMeshConnectivity_ElementNumberSet

 !>Sets the coupled node numbers
 INTERFACE cmfe_InterfaceMeshConnectivity_NodeNumberSet
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_NodeNumberSetNumber
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_NodeNumberSetObj
 END INTERFACE cmfe_InterfaceMeshConnectivity_NodeNumberSet

 !>Sets the number of elements coupled through a given interface mesh element
 INTERFACE cmfe_InterfaceMeshConnectivity_BasisSet
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_BasisSetNumber
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_BasisSetObj
 END INTERFACE cmfe_InterfaceMeshConnectivity_BasisSet

 !>Destroys an interface meshes connectivity.
 INTERFACE cmfe_InterfaceMeshConnectivity_Destroy
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_DestroyNumber
   MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_DestroyObj
 END INTERFACE cmfe_InterfaceMeshConnectivity_Destroy

 !>Finishes the creation of an interface points connectivity.
 INTERFACE cmfe_InterfacePointsConnectivity_CreateFinish
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_CreateFinishNumber
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_CreateFinishObj
 END INTERFACE cmfe_InterfacePointsConnectivity_CreateFinish

 !>Starts the creation of an interface points connectivity.
 INTERFACE cmfe_InterfacePointsConnectivity_CreateStart
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_CreateStartNumber
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_CreateStartObj
 END INTERFACE cmfe_InterfacePointsConnectivity_CreateStart

 !>Destroys an interface points connectivity.
 INTERFACE cmfe_InterfacePointsConnectivity_Destroy
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_DestroyNumber
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_DestroyObj
 END INTERFACE cmfe_InterfacePointsConnectivity_Destroy

 !>Get the coupled mesh element number that defines points connectivity
 INTERFACE cmfe_InterfacePointsConnectivity_ElementNumberGet
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_ElementNumberGetNumber
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_ElementNumberGetObj
 END INTERFACE cmfe_InterfacePointsConnectivity_ElementNumberGet

 !>Gets the element xi values for the points connectivity between a data point in the interface mesh and an element in a region mesh
 INTERFACE cmfe_InterfacePointsConnectivity_PointXiGet
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_PointXiGetNumber
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_PointXiGetObj
 END INTERFACE cmfe_InterfacePointsConnectivity_PointXiGet

 !>Sets the coupled mesh element number that defines points connectivity
 INTERFACE cmfe_InterfacePointsConnectivity_ElementNumberSet
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_ElementNumberSetNumber
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_ElementNumberSetObj
 END INTERFACE cmfe_InterfacePointsConnectivity_ElementNumberSet

 !>Sets the element xi values for the points connectivity between a data point in the interface mesh and an element in a region mesh
 INTERFACE cmfe_InterfacePointsConnectivity_PointXiSet
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_PointXiSetNumber
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_PointXiSetObj
 END INTERFACE cmfe_InterfacePointsConnectivity_PointXiSet

 !>Update points connectivity information with projection results
 INTERFACE cmfe_InterfacePointsConnectivity_UpdateFromProjection
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber
   MODULE PROCEDURE cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj
 END INTERFACE cmfe_InterfacePointsConnectivity_UpdateFromProjection

 PUBLIC cmfe_Interface_MeshAdd

 PUBLIC cmfe_Interface_CreateFinish,cmfe_Interface_CreateStart

 PUBLIC cmfe_Interface_CoordinateSystemSet,cmfe_Interface_CoordinateSystemGet

 PUBLIC cmfe_Interface_Destroy

 PUBLIC cmfe_Interface_LabelGet,cmfe_Interface_LabelSet

 PUBLIC cmfe_Interface_NodesGet

 PUBLIC cmfe_InterfaceMeshConnectivity_CreateFinish,cmfe_InterfaceMeshConnectivity_CreateStart

 PUBLIC cmfe_InterfaceMeshConnectivity_Destroy,cmfe_InterfaceMeshConnectivity_BasisSet

 PUBLIC cmfe_InterfaceMeshConnectivity_ElementNumberSet,cmfe_InterfaceMeshConnectivity_ElementXiSet

 PUBLIC cmfe_InterfaceMeshConnectivity_NodeNumberSet

 PUBLIC cmfe_InterfacePointsConnectivity_CreateFinish,cmfe_InterfacePointsConnectivity_CreateStart

 PUBLIC cmfe_InterfacePointsConnectivity_Destroy

 PUBLIC cmfe_InterfacePointsConnectivity_ElementNumberGet,cmfe_InterfacePointsConnectivity_PointXiGet

 PUBLIC cmfe_InterfacePointsConnectivity_ElementNumberSet,cmfe_InterfacePointsConnectivity_PointXiSet

 PUBLIC cmfe_InterfacePointsConnectivity_UpdateFromProjection

!==================================================================================================================================
!
! INTERFACE_CONDITION_ROUTINES
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_InterfaceConditionConstants OpenCMISS::Iron::InterfaceConditions::Constants
 !> \brief Interface conditions constants.
 !>@{
 !> \addtogroup OpenCMISS_InterfaceConditionMethods OpenCMISS::Iron::InterfaceConditions::Constants::Methods
 !> \brief Interface condition methods.
 !> \see OpenCMISS::Iron::InterfaceConditions,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD = &
   & INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD !<Lagrange multipliers interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD = INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD !<Augmented Lagrange multiplers interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_PENALTY_METHOD = INTERFACE_CONDITION_PENALTY_METHOD !<Penalty interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_POINT_TO_POINT_METHOD = INTERFACE_CONDITION_POINT_TO_POINT_METHOD !<Point to point interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_InterfaceConditionOperators OpenCMISS::Iron::InterfaceConditions::Constants::Operators
 !> \brief Interface condition operator types.
 !> \see OpenCMISS::Iron::InterfaceConditions,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR = &
   & INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR !<Continuous field operator, i.e., lambda.(u1_gauss-u2_gauss). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR = &
   & INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR !<Continuous field normal operator, i.e., lambda(u_1.n_1-u_2.n_2). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_FLS_CONTACT_OPERATOR= &
   & INTERFACE_CONDITION_FLS_CONTACT_OPERATOR !<Frictionless contact operator, i.e., lambda.(x_1.n-x_2.n). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR= &
   & INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR !<Frictionless contact operator, reproject at each newton iteration and has geometric linearisation terms i.e., lambda.(x_1.n-x_2.n). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_SOLID_FLUID_OPERATOR = INTERFACE_CONDITION_SOLID_FLUID_OPERATOR !<Solid fluid operator, i.e., lambda.(v_f-du_s/dt). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR = &
   & INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR !<Solid fluid normal operator, i.e., lambda(v_f.n_f-du_s/dt.n_s). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_InterfaceConditionOutputTypes OpenCMISS::Iron::InterfaceConditions::Constants::OutputTypes
 !> \brief Interface conditions output types
 !> \see OpenCMISS::Iron::InterfaceConditions,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_NO_OUTPUT = INTERFACE_CONDITION_NO_OUTPUT!<No output from the interface condition \see OpenCMISS_InterfaceConditionOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_PROGRESS_OUTPUT = INTERFACE_CONDITION_PROGRESS_OUTPUT !<Progress information output for the interface condition \see OpenCMISS_InterfaceConditionOutputTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_InterfaceConditionIntegrationTypes OpenCMISS::Iron::InterfaceConditions::Constants::IntegrationTypes
 !> \brief Interface condition integration types.
 !> \see OpenCMISS::Iron::InterfaceConditions,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_GAUSS_INTEGRATION=INTERFACE_CONDITION_GAUSS_INTEGRATION !<Gauss points integration type, i.e. Loop over element Gauss points and sum up their contribution. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_DATA_POINTS_INTEGRATION=INTERFACE_CONDITION_DATA_POINTS_INTEGRATION !< Data points integration type i.e. Loop over data points and  sum up their contribution. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Finishes the creation of an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_CreateStart
 INTERFACE cmfe_InterfaceCondition_CreateFinish
   MODULE PROCEDURE cmfe_InterfaceCondition_CreateFinishNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_CreateFinishObj
 END INTERFACE cmfe_InterfaceCondition_CreateFinish

 !>Starts the creation of an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_CreateFinish
 INTERFACE cmfe_InterfaceCondition_CreateStart
   MODULE PROCEDURE cmfe_InterfaceCondition_CreateStartNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_CreateStartObj
 END INTERFACE cmfe_InterfaceCondition_CreateStart

 !>Adds in a dependent variable to an interface condition.
 INTERFACE cmfe_InterfaceCondition_DependentVariableAdd
   MODULE PROCEDURE cmfe_InterfaceCondition_DependentVariableAddNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_DependentVariableAddObj
 END INTERFACE cmfe_InterfaceCondition_DependentVariableAdd

 !>Destroys an interface condition.
 INTERFACE cmfe_InterfaceCondition_Destroy
   MODULE PROCEDURE cmfe_InterfaceCondition_DestroyNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_DestroyObj
 END INTERFACE cmfe_InterfaceCondition_Destroy

 !>Finishes the creation of equations for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_EquationsCreateStart
 INTERFACE cmfe_InterfaceCondition_EquationsCreateFinish
   MODULE PROCEDURE cmfe_InterfaceCondition_EquationsCreateFinishNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_EquationsCreateFinishObj
 END INTERFACE cmfe_InterfaceCondition_EquationsCreateFinish

 !>Starts the creation of equations for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_EquationsCreateFinish
 INTERFACE cmfe_InterfaceCondition_EquationsCreateStart
   MODULE PROCEDURE cmfe_InterfaceCondition_EquationsCreateStartNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_EquationsCreateStartObj
 END INTERFACE cmfe_InterfaceCondition_EquationsCreateStart

 !>Destroys the interface equations for an interface condition.
 INTERFACE cmfe_InterfaceCondition_EquationsDestroy
   MODULE PROCEDURE cmfe_InterfaceCondition_EquationsDestroyNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_EquationsDestroyObj
 END INTERFACE cmfe_InterfaceCondition_EquationsDestroy

 !>Returns the integration type for an interface condition.
 INTERFACE cmfe_InterfaceCondition_IntegrationTypeGet
   MODULE PROCEDURE cmfe_InterfaceCondition_IntegrationTypeGetNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_IntegrationTypeGetObj
 END INTERFACE cmfe_InterfaceCondition_IntegrationTypeGet

 !>Sets/changes the integration type for an interface condition.
 INTERFACE cmfe_InterfaceCondition_IntegrationTypeSet
   MODULE PROCEDURE cmfe_InterfaceCondition_IntegrationTypeSetNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_IntegrationTypeSetObj
 END INTERFACE cmfe_InterfaceCondition_IntegrationTypeSet

 !>Finishes the creation of a Lagrange multipliers field for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_LagrangeFieldCreateStart
 INTERFACE cmfe_InterfaceCondition_LagrangeFieldCreateFinish
   MODULE PROCEDURE cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj
 END INTERFACE cmfe_InterfaceCondition_LagrangeFieldCreateFinish

 !>Starts the creation of a Lagrange multipliers field for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_LagrangeFieldCreateFinish
 INTERFACE cmfe_InterfaceCondition_LagrangeFieldCreateStart
   MODULE PROCEDURE cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_LagrangeFieldCreateStartObj
 END INTERFACE cmfe_InterfaceCondition_LagrangeFieldCreateStart

 !>Returns the label for an interface condition.
 INTERFACE cmfe_InterfaceCondition_LabelGet
   MODULE PROCEDURE cmfe_InterfaceCondition_LabelGetCNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_LabelGetCObj
   MODULE PROCEDURE cmfe_InterfaceCondition_LabelGetVSNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_LabelGetVSObj
 END INTERFACE cmfe_InterfaceCondition_LabelGet

 !>Sets/changes the label for an interface condition.
 INTERFACE cmfe_InterfaceCondition_LabelSet
   MODULE PROCEDURE cmfe_InterfaceCondition_LabelSetCNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_LabelSetCObj
   MODULE PROCEDURE cmfe_InterfaceCondition_LabelSetVSNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_LabelSetVSObj
 END INTERFACE cmfe_InterfaceCondition_LabelSet

 !>Gets the output type for an interface condition.
 INTERFACE cmfe_InterfaceCondition_OutputTypeGet
   MODULE PROCEDURE cmfe_InterfaceCondition_OutputTypeGetNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_OutputTypeGetObj
 END INTERFACE cmfe_InterfaceCondition_OutputTypeGet

 !>Sets/changes the output type an equations set.
 INTERFACE cmfe_InterfaceCondition_OutputTypeSet
   MODULE PROCEDURE cmfe_InterfaceCondition_OutputTypeSetNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_OutputTypeSetObj
 END INTERFACE cmfe_InterfaceCondition_OutputTypeSet

 !>Finishes the creation of a Penalty field for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_PenaltyFieldCreateStart
 INTERFACE cmfe_InterfaceCondition_PenaltyFieldCreateFinish
   MODULE PROCEDURE cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj
 END INTERFACE cmfe_InterfaceCondition_PenaltyFieldCreateFinish

 !>Starts the creation of a Penalty field for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_PenaltyFieldCreateFinish
 INTERFACE cmfe_InterfaceCondition_PenaltyFieldCreateStart
   MODULE PROCEDURE cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_PenaltyFieldCreateStartObj
 END INTERFACE cmfe_InterfaceCondition_PenaltyFieldCreateStart

 !>Returns the method for an interface condition.
 INTERFACE cmfe_InterfaceCondition_MethodGet
   MODULE PROCEDURE cmfe_InterfaceCondition_MethodGetNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_MethodGetObj
 END INTERFACE cmfe_InterfaceCondition_MethodGet

 !>Sets/changes the method for an interface condition.
 INTERFACE cmfe_InterfaceCondition_MethodSet
   MODULE PROCEDURE cmfe_InterfaceCondition_MethodSetNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_MethodSetObj
 END INTERFACE cmfe_InterfaceCondition_MethodSet

 !>Returns the operator for an interface condition.
 INTERFACE cmfe_InterfaceCondition_OperatorGet
   MODULE PROCEDURE cmfe_InterfaceCondition_OperatorGetNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_OperatorGetObj
 END INTERFACE cmfe_InterfaceCondition_OperatorGet

 !>Sets/changes the operator for an interface condition.
 INTERFACE cmfe_InterfaceCondition_OperatorSet
   MODULE PROCEDURE cmfe_InterfaceCondition_OperatorSetNumber
   MODULE PROCEDURE cmfe_InterfaceCondition_OperatorSetObj
 END INTERFACE cmfe_InterfaceCondition_OperatorSet
 
 PUBLIC CMFE_INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,CMFE_INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD, &
   & CMFE_INTERFACE_CONDITION_PENALTY_METHOD,CMFE_INTERFACE_CONDITION_POINT_TO_POINT_METHOD

 PUBLIC CMFE_INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR,CMFE_INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR, &
   & CMFE_INTERFACE_CONDITION_FLS_CONTACT_OPERATOR,CMFE_INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR, &
   & CMFE_INTERFACE_CONDITION_SOLID_FLUID_OPERATOR,CMFE_INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR

 PUBLIC CMFE_INTERFACE_CONDITION_GAUSS_INTEGRATION,CMFE_INTERFACE_CONDITION_DATA_POINTS_INTEGRATION

 PUBLIC CMFE_INTERFACE_CONDITION_NO_OUTPUT,CMFE_INTERFACE_CONDITION_PROGRESS_OUTPUT

 PUBLIC cmfe_InterfaceCondition_CreateFinish,cmfe_InterfaceCondition_CreateStart

 PUBLIC cmfe_InterfaceCondition_DependentVariableAdd

 PUBLIC cmfe_InterfaceCondition_Destroy

 PUBLIC cmfe_InterfaceCondition_EquationsCreateFinish,cmfe_InterfaceCondition_EquationsCreateStart

 PUBLIC cmfe_InterfaceCondition_EquationsDestroy

 PUBLIC cmfe_InterfaceCondition_IntegrationTypeGet,cmfe_InterfaceCondition_IntegrationTypeSet

 PUBLIC cmfe_InterfaceCondition_LagrangeFieldCreateFinish,cmfe_InterfaceCondition_LagrangeFieldCreateStart

 PUBLIC cmfe_InterfaceCondition_LabelGet,cmfe_InterfaceCondition_LabelSet

 PUBLIC cmfe_InterfaceCondition_OutputTypeGet,cmfe_InterfaceCondition_OutputTypeSet

 PUBLIC cmfe_InterfaceCondition_PenaltyFieldCreateFinish,cmfe_InterfaceCondition_PenaltyFieldCreateStart

 PUBLIC cmfe_InterfaceCondition_MethodGet,cmfe_InterfaceCondition_MethodSet

 PUBLIC cmfe_InterfaceCondition_OperatorGet,cmfe_InterfaceCondition_OperatorSet

!==================================================================================================================================
!
! InterfaceEquationsRoutines
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_InterfaceEquationsConstants OpenCMISS::Iron::InterfaceEquations::Constants
 !> \brief Interface equations constants.
 !>@{
 !> \addtogroup OpenCMISS_InterfaceEquationsLinearityTypes OpenCMISS::Iron::InterfaceEquations::Constants::LinearityTypes
 !> \brief Interface equations linearity types.
 !> \see OpenCMISS::Iron::InterfaceEquations,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_LINEAR = INTERFACE_EQUATIONS_LINEAR !<The interface equations are linear. \see OpenCMISS_InterfaceEquationsLinearity,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_NONLINEAR = INTERFACE_EQUATIONS_NONLINEAR !<The interface equations are nonlinear. \see OpenCMISS_InterfaceEquationsLinearity,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_NONLINEAR_BCS = INTERFACE_EQUATIONS_NONLINEAR_BCS !<The interface equations have nonlinear boundary conditions. \see OpenCMISS_InterfaceEquationsLinearity,OpenCMISS
 !>@}
  !> \addtogroup OpenCMISS_InterfaceEquationsOutputTypes OpenCMISS::Iron::InterfaceEquations::Constants::OutputTypes
  !> \brief The interface equations output types
  !> \see OpenCMISS::Iron::InterfaceEquations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_NO_OUTPUT=INTERFACE_EQUATIONS_NO_OUTPUT !<No output. \see OpenCMISS_InterfaceEquationsOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_TIMING_OUTPUT=INTERFACE_EQUATIONS_TIMING_OUTPUT !<Timing information output. \see 
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_MATRIX_OUTPUT=INTERFACE_EQUATIONS_MATRIX_OUTPUT !<All below and equation matrices output. \see 
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_ELEMENT_MATRIX_OUTPUT=INTERFACE_EQUATIONS_ELEMENT_MATRIX_OUTPUT !<All below and element matrices output. \see OpenCMISS_InterfaceEquationsOutputTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_InterfaceEquationsSparsityTypes OpenCMISS::Iron::InterfaceEquations::Constants::SparsityTypes
  !> \brief Interface equations matrices sparsity types
  !> \see OpenCMISS::Iron::InterfaceEquations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_SPARSE_MATRICES=INTERFACE_EQUATIONS_SPARSE_MATRICES !<Use sparse matrices for the interface equations. \see OpenCMISS_InterfaceEquationsSparsityTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_FULL_MATRICES=INTERFACE_EQUATIONS_FULL_MATRICES !<Use fully populated matrices for the interface equations. \see OpenCMISS_InterfaceEquationsSparsityTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_InterfaceEquationsTimeDependenceTypes OpenCMISS::Iron::InterfaceEquations::Constants::TimeDependenceTypes
  !> \brief The interface equations time dependence type parameters
  !> \see OpenCMISS::Iron::InterfaceEquations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_STATIC=INTERFACE_EQUATIONS_STATIC !<The interface conditions are static and have no time dependence. \see OpenCMISS_InterfaceEquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_QUASISTATIC=INTERFACE_EQUATIONS_QUASISTATIC !<The interface conditions are quasi-static. \see OpenCMISS_InterfaceEquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_FIRST_ORDER_DYNAMIC=INTERFACE_EQUATIONS_FIRST_ORDER_DYNAMIC !<The interface conditions are first order dynamic. \see OpenCMISS_InterfaceEquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_SECOND_ORDER_DYNAMIC=INTERFACE_EQUATIONS_SECOND_ORDER_DYNAMIC !<The interface conditions are a second order dynamic. \see OpenCMISS_InterfaceEquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_EQUATIONS_TIME_STEPPING=INTERFACE_EQUATIONS_TIME_STEPPING !<The interface conditions are for time stepping. \see OpenCMISS_InterfaceEquationsTimeDependenceTypes,OpenCMISS
  !>@}
  !>@}  

 !Module types

 !Module variables

 !Interfaces

 !>Returns the linearity type for interface equations.
 INTERFACE cmfe_InterfaceEquations_LinearityTypeGet
   MODULE PROCEDURE cmfe_InterfaceEquations_LinearityTypeGetNumber
   MODULE PROCEDURE cmfe_InterfaceEquations_LinearityTypeGetObj
 END INTERFACE cmfe_InterfaceEquations_LinearityTypeGet
 
 !>Returns the interface matrix time dependence type for interface equations.
 INTERFACE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGet
   MODULE PROCEDURE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0
   MODULE PROCEDURE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1
   MODULE PROCEDURE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj0
   MODULE PROCEDURE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj1
 END INTERFACE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGet

 !>Sets/changes the interface matrix time dependence type for interface equations.
 INTERFACE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSet
   MODULE PROCEDURE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0
   MODULE PROCEDURE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1
   MODULE PROCEDURE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj0
   MODULE PROCEDURE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj1
 END INTERFACE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSet

 !>Returns the output type for interface equations.
 INTERFACE cmfe_InterfaceEquations_OutputTypeGet
   MODULE PROCEDURE cmfe_InterfaceEquations_OutputTypeGetNumber
   MODULE PROCEDURE cmfe_InterfaceEquations_OutputTypeGetObj
 END INTERFACE cmfe_InterfaceEquations_OutputTypeGet

 !>Sets/changes the output type for interface equations.
 INTERFACE cmfe_InterfaceEquations_OutputTypeSet
   MODULE PROCEDURE cmfe_InterfaceEquations_OutputTypeSetNumber
   MODULE PROCEDURE cmfe_InterfaceEquations_OutputTypeSetObj
 END INTERFACE cmfe_InterfaceEquations_OutputTypeSet

 !>Returns the sparsity for interface equations.
 INTERFACE cmfe_InterfaceEquations_SparsityGet
   MODULE PROCEDURE cmfe_InterfaceEquations_SparsityGetNumber
   MODULE PROCEDURE cmfe_InterfaceEquations_SparsityGetObj
 END INTERFACE cmfe_InterfaceEquations_SparsityGet

 !>Sets/changes the sparsity for interface equations.
 INTERFACE cmfe_InterfaceEquations_SparsitySet
   MODULE PROCEDURE cmfe_InterfaceEquations_SparsitySetNumber
   MODULE PROCEDURE cmfe_InterfaceEquations_SparsitySetObj
 END INTERFACE cmfe_InterfaceEquations_SparsitySet

  !>Returns the time dependence type for interface equations.
 INTERFACE cmfe_InterfaceEquations_TimeDependenceTypeGet
   MODULE PROCEDURE cmfe_InterfaceEquations_TimeDependenceTypeGetNumber
   MODULE PROCEDURE cmfe_InterfaceEquations_TimeDependenceTypeGetObj
 END INTERFACE cmfe_InterfaceEquations_TimeDependenceTypeGet
 
 PUBLIC CMFE_INTERFACE_EQUATIONS_LINEAR,CMFE_INTERFACE_EQUATIONS_NONLINEAR,CMFE_INTERFACE_EQUATIONS_NONLINEAR_BCS

 PUBLIC CMFE_INTERFACE_EQUATIONS_NO_OUTPUT,CMFE_INTERFACE_EQUATIONS_TIMING_OUTPUT,CMFE_INTERFACE_EQUATIONS_MATRIX_OUTPUT, &
   & CMFE_INTERFACE_EQUATIONS_ELEMENT_MATRIX_OUTPUT

 PUBLIC CMFE_INTERFACE_EQUATIONS_SPARSE_MATRICES,CMFE_INTERFACE_EQUATIONS_FULL_MATRICES

 PUBLIC CMFE_INTERFACE_EQUATIONS_STATIC,CMFE_INTERFACE_EQUATIONS_QUASISTATIC,CMFE_INTERFACE_EQUATIONS_FIRST_ORDER_DYNAMIC, &
   & CMFE_INTERFACE_EQUATIONS_SECOND_ORDER_DYNAMIC,CMFE_INTERFACE_EQUATIONS_TIME_STEPPING

 PUBLIC cmfe_InterfaceEquations_LinearityTypeGet

 PUBLIC cmfe_InterfaceEquations_MatrixTimeDependenceTypeGet,cmfe_InterfaceEquations_MatrixTimeDependenceTypeSet

 PUBLIC cmfe_InterfaceEquations_OutputTypeGet,cmfe_InterfaceEquations_OutputTypeSet

 PUBLIC cmfe_InterfaceEquations_SparsityGet,cmfe_InterfaceEquations_SparsitySet

 PUBLIC cmfe_InterfaceEquations_TimeDependenceTypeGet

!==================================================================================================================================
!
! INTERFACE MATRICES ROUTINES
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_InterfaceMatricesTimeDependenceTypes OpenCMISS::Iron::InterfaceMatrices::TimeDependenceTypes
 !> \brief Interface matrices time dependency types
 !> \see OpenCMISS::Iron::InterfaceEquations,OpenCMISS
  !>@{
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_MATRIX_STATIC=INTERFACE_MATRIX_STATIC !<Interface matrix is of static type \see OpenCMISS_InterfaceMatricesTimeDependenceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_MATRIX_QUASI_STATIC=INTERFACE_MATRIX_QUASI_STATIC !<Interface matrix is of quasi-static type \see OpenCMISS_InterfaceMatricesTimeDependenceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC=INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC !<Interface matrix is of first order dynamic type \see OpenCMISS_InterfaceMatricesTimeDependenceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC=INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC !<Interface matrix is of second order dynamic type \see OpenCMISS_InterfaceMatricesTimeDependenceTypes,OpenCMISS
 !>@}

 !Module types

 !Module variables

 !Interfaces

 PUBLIC CMFE_INTERFACE_MATRIX_STATIC,CMFE_INTERFACE_MATRIX_QUASI_STATIC,CMFE_INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC, &
   & CMFE_INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC

!==================================================================================================================================
!
! MESH_ROUTINES
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_MeshConstants OpenCMISS::Iron::Mesh::Constants
 !> \brief Mesh constants.
 !>@{
 !> \addtogroup OpenCMISS_MeshBoundaryTypes OpenCMISS::Iron::Mesh::MeshBoundaryTypes
 !> \brief The boundary type parameters for a mesh domain
 !> \see OpenCMISS::Iron::Mesh,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_MESH_OFF_DOMAIN_BOUNDARY = MESH_OFF_DOMAIN_BOUNDARY !<The node/element is not on the mesh domain boundary \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_MESH_ON_DOMAIN_BOUNDARY = MESH_ON_DOMAIN_BOUNDARY !<The node/element is on the mesh domain boundary \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces
 !>Finishes the creation of a mesh. \see OpenCMISS::Iron::cmfe_Mesh_CreateStart
 INTERFACE cmfe_Mesh_CreateFinish
   MODULE PROCEDURE cmfe_Mesh_CreateFinishNumber
   MODULE PROCEDURE cmfe_Mesh_CreateFinishObj
 END INTERFACE cmfe_Mesh_CreateFinish

 !>Starts the creation of a mesh. \see OpenCMISS::Iron::cmfe_Mesh_CreateFinish
 INTERFACE cmfe_Mesh_CreateStart
   MODULE PROCEDURE cmfe_Mesh_CreateStartNumber
   MODULE PROCEDURE cmfe_Mesh_CreateStartObj
   MODULE PROCEDURE cmfe_Mesh_CreateStartInterfaceObj
 END INTERFACE cmfe_Mesh_CreateStart

 !>Destroys a mesh.
 INTERFACE cmfe_Mesh_Destroy
   MODULE PROCEDURE cmfe_Mesh_DestroyNumber
   MODULE PROCEDURE cmfe_Mesh_DestroyObj
 END INTERFACE cmfe_Mesh_Destroy

 !>Returns the number of mesh components in a mesh.
 INTERFACE cmfe_Mesh_NumberOfComponentsGet
   MODULE PROCEDURE cmfe_Mesh_NumberOfComponentsGetNumber
   MODULE PROCEDURE cmfe_Mesh_NumberOfComponentsGetObj
 END INTERFACE cmfe_Mesh_NumberOfComponentsGet

 !>Sets/changes the number of mesh components in a mesh.
 INTERFACE cmfe_Mesh_NumberOfComponentsSet
   MODULE PROCEDURE cmfe_Mesh_NumberOfComponentsSetNumber
   MODULE PROCEDURE cmfe_Mesh_NumberOfComponentsSetObj
 END INTERFACE cmfe_Mesh_NumberOfComponentsSet

 !>Returns the number of elements in a mesh.
 INTERFACE cmfe_Mesh_NumberOfElementsGet
   MODULE PROCEDURE cmfe_Mesh_NumberOfElementsGetNumber
   MODULE PROCEDURE cmfe_Mesh_NumberOfElementsGetObj
 END INTERFACE cmfe_Mesh_NumberOfElementsGet

 !>Sets/changes the number of elements in a mesh.
 INTERFACE cmfe_Mesh_NumberOfElementsSet
   MODULE PROCEDURE cmfe_Mesh_NumberOfElementsSetNumber
   MODULE PROCEDURE cmfe_Mesh_NumberOfElementsSetObj
 END INTERFACE cmfe_Mesh_NumberOfElementsSet

 !>Sets/changes the surrounding elements calculate flag for the mesh.
 INTERFACE cmfe_Mesh_SurroundingElementsCalculateSet
   MODULE PROCEDURE cmfe_Mesh_SurroundingElementsCalculateSetNumber
   MODULE PROCEDURE cmfe_Mesh_SurroundingElementsCalculateSetObj
 END INTERFACE cmfe_Mesh_SurroundingElementsCalculateSet

 !>Sets/changes whether data points topology should be calculated for the decomposition.
 INTERFACE cmfe_Mesh_TopologyDataPointsCalculateProjection
   MODULE PROCEDURE cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber
   MODULE PROCEDURE cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber
   MODULE PROCEDURE cmfe_Mesh_TopologyDataPointsCalculateProjectionObj
 END INTERFACE cmfe_Mesh_TopologyDataPointsCalculateProjection

 !>Returns the basis for an element in a mesh.
 INTERFACE cmfe_MeshElements_BasisGet
   MODULE PROCEDURE cmfe_MeshElements_BasisGetNumber
   MODULE PROCEDURE cmfe_MeshElements_BasisGetObj
 END INTERFACE cmfe_MeshElements_BasisGet

 !>Sets/changes the basis for an element in a mesh.
 INTERFACE cmfe_MeshElements_BasisSet
   MODULE PROCEDURE cmfe_MeshElements_BasisSetNumber
   MODULE PROCEDURE cmfe_MeshElements_BasisSetObj
 END INTERFACE cmfe_MeshElements_BasisSet

 !>Returns the adjacent elements for a given element and adjacent xi direction for an element in a mesh.
 INTERFACE cmfe_MeshElements_AdjacentElementGet
   MODULE PROCEDURE cmfe_MeshElements_AdjacentElementGetNumber
   MODULE PROCEDURE cmfe_MeshElements_AdjacentElementGetObj
 END INTERFACE cmfe_MeshElements_AdjacentElementGet

 !>Finishes the creation of a mesh elements for a mesh component. \see OpenCMISS::Iron::cmfe_MeshElements_CreateStart
 INTERFACE cmfe_MeshElements_CreateFinish
   MODULE PROCEDURE cmfe_MeshElements_CreateFinishNumber
   MODULE PROCEDURE cmfe_MeshElements_CreateFinishObj
 END INTERFACE cmfe_MeshElements_CreateFinish

 !>Starts the creation of a mesh elements for a mesh component. \see OpenCMISS::Iron::cmfe_MeshElements_CreateFinish
 INTERFACE cmfe_MeshElements_CreateStart
   MODULE PROCEDURE cmfe_MeshElements_CreateStartNumber
   MODULE PROCEDURE cmfe_MeshElements_CreateStartObj
 END INTERFACE cmfe_MeshElements_CreateStart

 !>Gets the mesh boundary type for an element
 INTERFACE cmfe_MeshElements_ElementOnBoundaryGet
   MODULE PROCEDURE cmfe_MeshElements_ElementOnBoundaryGetNumber
   MODULE PROCEDURE cmfe_MeshElements_ElementOnBoundaryGetObj
 END INTERFACE cmfe_MeshElements_ElementOnBoundaryGet

 !>Get the mesh elements belonging to a mesh component.
 INTERFACE cmfe_Mesh_ElementsGet
   MODULE PROCEDURE cmfe_Mesh_ElementsGetNumber
   MODULE PROCEDURE cmfe_Mesh_ElementsGetObj
 END INTERFACE cmfe_Mesh_ElementsGet

 !>Returns the element nodes for an element in a mesh.
 INTERFACE cmfe_MeshElements_NodesGet
   MODULE PROCEDURE cmfe_MeshElements_NodesGetNumber
   MODULE PROCEDURE cmfe_MeshElements_NodesGetObj
 END INTERFACE cmfe_MeshElements_NodesGet

 !>Sets/changes the element nodes for an element in a mesh.
 INTERFACE cmfe_MeshElements_NodesSet
   MODULE PROCEDURE cmfe_MeshElements_NodesSetNumber
   MODULE PROCEDURE cmfe_MeshElements_NodesSetObj
 END INTERFACE cmfe_MeshElements_NodesSet

 !>Sets/changes a user node's derivative version for an element in a mesh.
 INTERFACE cmfe_MeshElements_UserNodeVersionSet
   MODULE PROCEDURE cmfe_MeshElements_UserNodeVersionSetNumber
   MODULE PROCEDURE cmfe_MeshElements_UserNodeVersionSetObj
 END INTERFACE cmfe_MeshElements_UserNodeVersionSet

 !>Sets/changes a local element's node derivative version for an element in a mesh.
 INTERFACE cmfe_MeshElements_LocalElementNodeVersionSet
   MODULE PROCEDURE cmfe_MeshElements_LocalElementNodeVersionSetNumber
   MODULE PROCEDURE cmfe_MeshElements_LocalElementNodeVersionSetObj
 END INTERFACE cmfe_MeshElements_LocalElementNodeVersionSet

 !>Returns the element user number for an element in a mesh.
 INTERFACE cmfe_MeshElements_UserNumberGet
   MODULE PROCEDURE cmfe_MeshElements_UserNumberGetNumber
   MODULE PROCEDURE cmfe_MeshElements_UserNumberGetObj
 END INTERFACE cmfe_MeshElements_UserNumberGet

 !>Sets/changes the element user number for an element in a mesh.
 INTERFACE cmfe_MeshElements_UserNumberSet
   MODULE PROCEDURE cmfe_MeshElements_UserNumberSetNumber
   MODULE PROCEDURE cmfe_MeshElements_UserNumberSetObj
 END INTERFACE cmfe_MeshElements_UserNumberSet

 !>Sets/changes the element user numbers for all element in a mesh.
 INTERFACE cmfe_MeshElements_UserNumbersAllSet
   MODULE PROCEDURE cmfe_MeshElements_UserNumbersAllSetNumber
   MODULE PROCEDURE cmfe_MeshElements_UserNumbersAllSetObj
 END INTERFACE cmfe_MeshElements_UserNumbersAllSet

 !>Returns true if the given node is in the given mesh component.
 INTERFACE cmfe_Mesh_NodeExists
   MODULE PROCEDURE cmfe_Mesh_NodeExistsNumber
   MODULE PROCEDURE cmfe_Mesh_NodeExistsObj
 END INTERFACE cmfe_Mesh_NodeExists

 !>Returns true if the given element is in the given mesh component.
 INTERFACE cmfe_Mesh_ElementExists
   MODULE PROCEDURE cmfe_Mesh_ElementExistsNumber
   MODULE PROCEDURE cmfe_Mesh_ElementExistsObj
 END INTERFACE cmfe_Mesh_ElementExists

 !>Get the mesh nodes belonging to a mesh component.
 INTERFACE cmfe_Mesh_NodesGet
   MODULE PROCEDURE cmfe_Mesh_NodesGetNumber
   MODULE PROCEDURE cmfe_Mesh_NodesGetObj
 END INTERFACE cmfe_Mesh_NodesGet

 !>Get the mesh boundary type for a node.
 INTERFACE cmfe_MeshNodes_NodeOnBoundaryGet
   MODULE PROCEDURE cmfe_MeshNodes_NodeOnBoundaryGetNumber
   MODULE PROCEDURE cmfe_MeshNodes_NodeOnBoundaryGetObj
 END INTERFACE cmfe_MeshNodes_NodeOnBoundaryGet

 !>Returns the number of derivatives for a node in a mesh.
 INTERFACE cmfe_MeshNodes_NumberOfDerivativesGet
   MODULE PROCEDURE cmfe_MeshNodes_NumberOfDerivativesGetNumber
   MODULE PROCEDURE cmfe_MeshNodes_NumberOfDerivativesGetObj
 END INTERFACE cmfe_MeshNodes_NumberOfDerivativesGet

 !>Returns the derivatives for a node in a mesh.
 INTERFACE cmfe_MeshNodes_DerivativesGet
   MODULE PROCEDURE cmfe_MeshNodes_DerivativesGetNumber
   MODULE PROCEDURE cmfe_MeshNodes_DerivativesGetObj
 END INTERFACE cmfe_MeshNodes_DerivativesGet

 !>Returns the number of versions for a derivative at a node in a mesh.
 INTERFACE cmfe_MeshNodes_NumberOfVersionsGet
   MODULE PROCEDURE cmfe_MeshNodes_NumberOfVersionsGetNumber
   MODULE PROCEDURE cmfe_MeshNodes_NumberOfVersionsGetObj
 END INTERFACE cmfe_MeshNodes_NumberOfVersionsGet

 !>Returns the number of nodes in a mesh.
 INTERFACE cmfe_MeshNodes_NumberOfNodesGet
   MODULE PROCEDURE cmfe_MeshNodes_NumberOfNodesGetNumber
   MODULE PROCEDURE cmfe_MeshNodes_NumberOfNodesGetObj
 END INTERFACE cmfe_MeshNodes_NumberOfNodesGet
 
 PUBLIC CMFE_MESH_OFF_DOMAIN_BOUNDARY,CMFE_MESH_ON_DOMAIN_BOUNDARY

 PUBLIC cmfe_Mesh_CreateFinish,cmfe_Mesh_CreateStart

 PUBLIC cmfe_Mesh_Destroy

 PUBLIC cmfe_Mesh_NumberOfComponentsGet,cmfe_Mesh_NumberOfComponentsSet

 PUBLIC cmfe_Mesh_NumberOfElementsGet,cmfe_Mesh_NumberOfElementsSet

 PUBLIC cmfe_MeshElements_BasisGet,cmfe_MeshElements_BasisSet

 PUBLIC cmfe_MeshElements_AdjacentElementGet

 PUBLIC cmfe_MeshElements_ElementOnBoundaryGet

 PUBLIC cmfe_MeshElements_UserNodeVersionSet,cmfe_MeshElements_LocalElementNodeVersionSet

 PUBLIC cmfe_MeshElements_CreateFinish,cmfe_MeshElements_CreateStart

 PUBLIC cmfe_MeshElements_NodesGet,cmfe_MeshElements_NodesSet

 PUBLIC cmfe_MeshElements_UserNumberGet,cmfe_MeshElements_UserNumberSet

 PUBLIC cmfe_MeshElements_UserNumbersAllSet

 PUBLIC cmfe_MeshNodes_NodeOnBoundaryGet

 PUBLIC cmfe_MeshNodes_NumberOfDerivativesGet,cmfe_MeshNodes_DerivativesGet

 PUBLIC cmfe_MeshNodes_NumberOfVersionsGet

 PUBLIC cmfe_MeshNodes_NumberOfNodesGet

 PUBLIC cmfe_Mesh_ElementsGet

 PUBLIC cmfe_Mesh_NodesGet

 PUBLIC cmfe_Mesh_NodeExists,cmfe_Mesh_ElementExists

 PUBLIC cmfe_Mesh_SurroundingElementsCalculateSet

 PUBLIC cmfe_Mesh_TopologyDataPointsCalculateProjection

!==================================================================================================================================
!
! DecompositionRoutines
!
!==================================================================================================================================

 !> \addtogroup OpenCMISS_DecomposerConstants OpenCMISS::Iron::Decomposer::Constants
 !> \brief Decomposer constants.
 !>@{
 !> \addtogroup OpenCMISS_DecomposerOutputTypes  OpenCMISS::Iron::Decomposer::DecomposerOutputTypes
 !> \brief The Decomposer output type parameters
 !> \see OpenCMISS::Iron::Decomposer,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_DECOMPOSER_NO_OUTPUT=DECOMPOSER_NO_OUTPUT !<No decomposer output. \see OpenCMISS_DecomposerTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DECOMPOSER_TIMING_OUTPUT=DECOMPOSER_TIMING_OUTPUT !<Timing decomposer output. \see OpenCMISS_DecomposerTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DECOMPOSER_ALL_OUTPUT=DECOMPOSER_ALL_OUTPUT !<All decomposer output. \see OpenCMISS_DecomposerTypes,OpenCMISS
 !>@}
 !>@}
 
 !> \addtogroup OpenCMISS_DecompositionConstants OpenCMISS::Iron::Decomposition::Constants
 !> \brief Decomposition constants.
 !>@{
 !> \addtogroup OpenCMISS_DecompositionTypes OpenCMISS::Iron::Decomposition::DecompositionTypes
 !> \brief The Decomposition types parameters
 !> \see OpenCMISS::Iron::Decomposition,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_DECOMPOSITION_ALL_TYPE = DECOMPOSITION_ALL_TYPE !<The decomposition contains all elements. \see OpenCMISS_DecompositionTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DECOMPOSITION_CALCULATED_TYPE = DECOMPOSITION_CALCULATED_TYPE !<The element decomposition is calculated by graph partitioning. \see OpenCMISS_DecompositionTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_DECOMPOSITION_USER_DEFINED_TYPE = DECOMPOSITION_USER_DEFINED_TYPE !<The user will set the element decomposition. \see OpenCMISS_DecompositionTypes,OpenCMISS
 !>@}
 !>@}

 !>Finishes the creation of a decomposer. \see OpenCMISS::Iron::cmfe_Decomposer_CreateStart
 INTERFACE cmfe_Decomposer_CreateFinish
   MODULE PROCEDURE cmfe_Decomposer_CreateFinishNumber
   MODULE PROCEDURE cmfe_Decomposer_CreateFinishObj
 END INTERFACE cmfe_Decomposer_CreateFinish

 !>Start the creation of a decomposer. \see OpenCMISS::Iron::cmfe_Decomposer_CreateFinish
 INTERFACE cmfe_Decomposer_CreateStart
   MODULE PROCEDURE cmfe_Decomposer_CreateStartNumber
   MODULE PROCEDURE cmfe_Decomposer_CreateStartObj
 END INTERFACE cmfe_Decomposer_CreateStart

 !>Adds a decomposition to a decomposer.
 INTERFACE cmfe_Decomposer_DecompositionAdd
   MODULE PROCEDURE cmfe_Decomposer_DecompositionAddNumber
   MODULE PROCEDURE cmfe_Decomposer_DecompositionAddObj
 END INTERFACE cmfe_Decomposer_DecompositionAdd

 !>Destroys a decomposer.
 INTERFACE cmfe_Decomposer_Destroy
   MODULE PROCEDURE cmfe_Decomposer_DestroyNumber
   MODULE PROCEDURE cmfe_Decomposer_DestroyObj
 END INTERFACE cmfe_Decomposer_Destroy

 !>Returns the output type for a decomposer.
 INTERFACE cmfe_Decomposer_OutputTypeGet
   MODULE PROCEDURE cmfe_Decomposer_OutputTypeGetNumber
   MODULE PROCEDURE cmfe_Decomposer_OutputTypeGetObj
 END INTERFACE cmfe_Decomposer_OutputTypeGet

 !>Sets/changes the output type for a decomposer.
 INTERFACE cmfe_Decomposer_OutputTypeSet
   MODULE PROCEDURE cmfe_Decomposer_OutputTypeSetNumber
   MODULE PROCEDURE cmfe_Decomposer_OutputTypeSetObj
 END INTERFACE cmfe_Decomposer_OutputTypeSet

 !>Finishes the creation of a domain decomposition. \see OpenCMISS::Iron::cmfe_Decomposition_CreateStart
 INTERFACE cmfe_Decomposition_CreateFinish
   MODULE PROCEDURE cmfe_Decomposition_CreateFinishNumber
   MODULE PROCEDURE cmfe_Decomposition_CreateFinishObj
 END INTERFACE cmfe_Decomposition_CreateFinish

 !>Start the creation of a domain decomposition for a given mesh. \see OpenCMISS::Iron::cmfe_Decomposition_CreateFinish
 INTERFACE cmfe_Decomposition_CreateStart
   MODULE PROCEDURE cmfe_Decomposition_CreateStartNumber
   MODULE PROCEDURE cmfe_Decomposition_CreateStartObj
 END INTERFACE cmfe_Decomposition_CreateStart

 !>Destroys a domain decomposition.
 INTERFACE cmfe_Decomposition_Destroy
   MODULE PROCEDURE cmfe_Decomposition_DestroyNumber
   MODULE PROCEDURE cmfe_Decomposition_DestroyObj
 END INTERFACE cmfe_Decomposition_Destroy

! !>Calculates the element domains for the decomposition of a mesh.
! INTERFACE cmfe_Decomposition_ElementDomainCalculate
!   MODULE PROCEDURE cmfe_Decomposition_ElementDomainCalculateNumber
!   MODULE PROCEDURE cmfe_Decomposition_ElementDomainCalculateObj
! END INTERFACE cmfe_Decomposition_ElementDomainCalculate

 !>Returns the domain for a given element in a decomposition of a mesh.
 INTERFACE cmfe_Decomposition_ElementDomainGet
   MODULE PROCEDURE cmfe_Decomposition_ElementDomainGetNumber
   MODULE PROCEDURE cmfe_Decomposition_ElementDomainGetObj
 END INTERFACE cmfe_Decomposition_ElementDomainGet

 !>Sets/changes the domain for a given element in a decomposition of a mesh.
 INTERFACE cmfe_Decomposition_ElementDomainSet
   MODULE PROCEDURE cmfe_Decomposition_ElementDomainSetNumber
   MODULE PROCEDURE cmfe_Decomposition_ElementDomainSetObj
 END INTERFACE cmfe_Decomposition_ElementDomainSet

 !>Returns the mesh component number used for the decomposition of a mesh.
 INTERFACE cmfe_Decomposition_MeshComponentGet
   MODULE PROCEDURE cmfe_Decomposition_MeshComponentGetNumber
   MODULE PROCEDURE cmfe_Decomposition_MeshComponentGetObj
 END INTERFACE cmfe_Decomposition_MeshComponentGet

 !>Sets/changes the mesh component number used for the decomposition of a mesh.
 INTERFACE cmfe_Decomposition_MeshComponentSet
   MODULE PROCEDURE cmfe_Decomposition_MeshComponentSetNumber
   MODULE PROCEDURE cmfe_Decomposition_MeshComponentSetObj
 END INTERFACE cmfe_Decomposition_MeshComponentSet

 !>Returns the type of decomposition.
 INTERFACE cmfe_Decomposition_TypeGet
   MODULE PROCEDURE cmfe_Decomposition_TypeGetNumber
   MODULE PROCEDURE cmfe_Decomposition_TypeGetObj
 END INTERFACE cmfe_Decomposition_TypeGet

 !>Sets/changes the type of decomposition.
 INTERFACE cmfe_Decomposition_TypeSet
   MODULE PROCEDURE cmfe_Decomposition_TypeSetNumber
   MODULE PROCEDURE cmfe_Decomposition_TypeSetObj
 END INTERFACE cmfe_Decomposition_TypeSet

 !>Sets/changes the work group for a decomposition.
 INTERFACE cmfe_Decomposition_WorkGroupSet
   MODULE PROCEDURE cmfe_Decomposition_WorkGroupSetNumber
   MODULE PROCEDURE cmfe_Decomposition_WorkGroupSetObj
 END INTERFACE cmfe_Decomposition_WorkGroupSet

 !>Sets/changes whether lines should be calculated for the decomposition.
 INTERFACE cmfe_Decomposition_CalculateLinesSet
   MODULE PROCEDURE cmfe_Decomposition_CalculateLinesSetNumber
   MODULE PROCEDURE cmfe_Decomposition_CalculateLinesSetObj
 END INTERFACE cmfe_Decomposition_CalculateLinesSet

 !>Sets/changes whether faces should be calculated for the decomposition.
 INTERFACE cmfe_Decomposition_CalculateFacesSet
   MODULE PROCEDURE cmfe_Decomposition_CalculateFacesSetNumber
   MODULE PROCEDURE cmfe_Decomposition_CalculateFacesSetObj
 END INTERFACE cmfe_Decomposition_CalculateFacesSet

 !>Returns the domain for a given element in a decomposition of a mesh.
 INTERFACE cmfe_Decomposition_NodeDomainGet
   MODULE PROCEDURE cmfe_Decomposition_NodeDomainGetNumber
   MODULE PROCEDURE cmfe_Decomposition_NodeDomainGetObj
 END INTERFACE cmfe_Decomposition_NodeDomainGet

 !>Calculates the decomposition topology for data points .
 INTERFACE cmfe_Decomposition_DataProjectionCalculate
   MODULE PROCEDURE cmfe_Decomposition_DataProjectionCalculateObj
 END INTERFACE cmfe_Decomposition_DataProjectionCalculate

 !>Gets the local data point number for data points projected on an element
 INTERFACE cmfe_Decomposition_ElementDataPointLocalNumberGet
   MODULE PROCEDURE cmfe_Decomposition_ElementDataPointLocalNumberGetObj
 END INTERFACE cmfe_Decomposition_ElementDataPointLocalNumberGet

 !>Gets the user data point number for data points projected on an element
 INTERFACE cmfe_Decomposition_ElementDataPointUserNumberGet
   MODULE PROCEDURE cmfe_Decomposition_ElementDataPointUserNumberGetObj
 END INTERFACE cmfe_Decomposition_ElementDataPointUserNumberGet

 !>Gets the number of data points projected on an element
 INTERFACE cmfe_Decomposition_NumberOfElementDataPointsGet
   MODULE PROCEDURE cmfe_Decomposition_NumberOfElementDataPointsGetObj
 END INTERFACE cmfe_Decomposition_NumberOfElementDataPointsGet

 PUBLIC CMFE_DECOMPOSER_NO_OUTPUT,CMFE_DECOMPOSER_TIMING_OUTPUT,CMFE_DECOMPOSER_ALL_OUTPUT

 PUBLIC CMFE_DECOMPOSITION_ALL_TYPE,CMFE_DECOMPOSITION_CALCULATED_TYPE,CMFE_DECOMPOSITION_USER_DEFINED_TYPE

 PUBLIC cmfe_Decomposer_CreateFinish,cmfe_Decomposer_CreateStart

 PUBLIC cmfe_Decomposer_DecompositionAdd

 PUBLIC cmfe_Decomposer_Destroy

 PUBLIC cmfe_Decomposer_OutputTypeGet,cmfe_Decomposer_OutputTypeSet

 PUBLIC cmfe_Decomposition_CreateFinish,cmfe_Decomposition_CreateStart

 PUBLIC cmfe_Decomposition_CalculateFacesSet,cmfe_Decomposition_CalculateLinesSet

 PUBLIC cmfe_Decomposition_Destroy

! PUBLIC cmfe_Decomposition_ElementDomainCalculate

 PUBLIC cmfe_Decomposition_ElementDomainGet,cmfe_Decomposition_ElementDomainSet

 PUBLIC cmfe_Decomposition_MeshComponentGet,cmfe_Decomposition_MeshComponentSet

 PUBLIC cmfe_Decomposition_NodeDomainGet
 
 PUBLIC cmfe_Decomposition_DataProjectionCalculate

 PUBLIC cmfe_Decomposition_ElementDataPointLocalNumberGet

 PUBLIC cmfe_Decomposition_ElementDataPointUserNumberGet

 PUBLIC cmfe_Decomposition_NumberOfElementDataPointsGet

 PUBLIC cmfe_Decomposition_TypeGet,cmfe_Decomposition_TypeSet

 PUBLIC cmfe_Decomposition_WorkGroupSet


!==================================================================================================================================
!
! DistributedMatrixVector
!
!==================================================================================================================================

 !> \addtogroup OpenCMISS_MatrixVectorConstants OpenCMISS::Iron::MatrixVector::Constants
 !> \brief Distributed matrix and vector function constants.
 !>@{
 !> \addtogroup OpenCMISS_MatrixStorageTypes OpenCMISS::Iron::MatrixVector::MatrixStorageTypes
 !> \brief Type of matrix storage.
 !> \see OpenCMISS::Iron::MatrixVectorConstants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_MATRIX_BLOCK_STORAGE_TYPE=DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE !<Distributed matrix block storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_MATRIX_DIAGONAL_STORAGE_TYPE=DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE !<Distributed matrix diagonal storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_MATRIX_COLUMN_MAJOR_STORAGE_TYPE=DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE !<Distributed matrix column major storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_MATRIX_ROW_MAJOR_STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE !<Distributed matrix row major storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_MATRIX_COMPRESSED_ROW_STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE !<Distributed matrix compressed row storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE !<Distributed matrix compressed column storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_MATRIX_ROW_COLUMN_STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE !<Distributed matrix row-column storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_MatrixVectorDataTypes OpenCMISS::Iron::MatrixVector::DataTypes
 !> \brief Type of data stored in matrices and vectors.
 !> \see OpenCMISS::Iron::MatrixVectorConstants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_MATRIX_VECTOR_INTG_TYPE=DISTRIBUTED_MATRIX_VECTOR_INTG_TYPE !<Integer distributed matrix-vector data type \see OpenCMISS_MatrixVectorDataTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_MATRIX_VECTOR_SP_TYPE=DISTRIBUTED_MATRIX_VECTOR_SP_TYPE !<Single precision real distributed matrix-vector data type \see OpenCMISS_MatrixVectorDataTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_MATRIX_VECTOR_DP_TYPE=DISTRIBUTED_MATRIX_VECTOR_DP_TYPE !<Double precision real distributed matrix-vector data type \see OpenCMISS_MatrixVectorDataTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_MATRIX_VECTOR_L_TYPE=DISTRIBUTED_MATRIX_VECTOR_L_TYPE !<Logical distributed matrix-vector data type \see OpenCMISS_MatrixVectorDataTypes,OpenCMISS
 !>@}
 !>@}

 PUBLIC CMFE_MATRIX_BLOCK_STORAGE_TYPE,CMFE_MATRIX_DIAGONAL_STORAGE_TYPE,CMFE_MATRIX_COLUMN_MAJOR_STORAGE_TYPE, &
   & CMFE_MATRIX_ROW_MAJOR_STORAGE_TYPE,CMFE_MATRIX_COMPRESSED_ROW_STORAGE_TYPE,CMFE_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE, &
   & CMFE_MATRIX_ROW_COLUMN_STORAGE_TYPE

 PUBLIC CMFE_MATRIX_VECTOR_INTG_TYPE,CMFE_MATRIX_VECTOR_SP_TYPE,CMFE_MATRIX_VECTOR_DP_TYPE,CMFE_MATRIX_VECTOR_L_TYPE

 !Note that currently we don't have any user number based routines for distributed matrices
 !as if we can't use a pointer to a CMISS object, a pointer to matrix data isn't going to
 !be much use either. It's also more awkward when matrices and vectors themselves don't have
 !user numbers and there are multiple ways to access them through user numbers, eg. solver equations
 !matrices or equations set matrices

 !>Get the storage type for a distributed matrix
 INTERFACE cmfe_DistributedMatrix_StorageTypeGet
   MODULE PROCEDURE cmfe_DistributedMatrix_StorageTypeGetObj
 END INTERFACE cmfe_DistributedMatrix_StorageTypeGet

 !>Get the data type for a distributed matrix
 INTERFACE cmfe_DistributedMatrix_DataTypeGet
   MODULE PROCEDURE cmfe_DistributedMatrix_DataTypeGetObj
 END INTERFACE cmfe_DistributedMatrix_DataTypeGet

 !>Get the dimensions for a distributed matrix on this computation node
 INTERFACE cmfe_DistributedMatrix_DimensionsGet
   MODULE PROCEDURE cmfe_DistributedMatrix_DimensionsGetObj
 END INTERFACE cmfe_DistributedMatrix_DimensionsGet

 !>Get the row indices and column indices for a sparse matrix
 INTERFACE cmfe_DistributedMatrix_StorageLocationsGet
   MODULE PROCEDURE cmfe_DistributedMatrix_StorageLocationsGetObj
 END INTERFACE cmfe_DistributedMatrix_StorageLocationsGet

 !>Get the data array for this matrix on this computation node
 INTERFACE cmfe_DistributedMatrix_DataGet
   MODULE PROCEDURE cmfe_DistributedMatrix_DataGetIntgObj
   MODULE PROCEDURE cmfe_DistributedMatrix_DataGetDPObj
   MODULE PROCEDURE cmfe_DistributedMatrix_DataGetSPObj
   MODULE PROCEDURE cmfe_DistributedMatrix_DataGetLObj
 END INTERFACE cmfe_DistributedMatrix_DataGet

 !>Restore the data array for this matrix once it has finished being used
 INTERFACE cmfe_DistributedMatrix_DataRestore
   MODULE PROCEDURE cmfe_DistributedMatrix_DataRestoreIntgObj
   MODULE PROCEDURE cmfe_DistributedMatrix_DataRestoreDPObj
   MODULE PROCEDURE cmfe_DistributedMatrix_DataRestoreSPObj
   MODULE PROCEDURE cmfe_DistributedMatrix_DataRestoreLObj
 END INTERFACE cmfe_DistributedMatrix_DataRestore

 !>Get the data type for a distributed vector
 INTERFACE cmfe_DistributedVector_DataTypeGet
   MODULE PROCEDURE cmfe_DistributedVector_DataTypeGetObj
 END INTERFACE cmfe_DistributedVector_DataTypeGet

 !>Get the data array for this vector on this computation node
 INTERFACE cmfe_DistributedVector_DataGet
   MODULE PROCEDURE cmfe_DistributedVector_DataGetIntgObj
   MODULE PROCEDURE cmfe_DistributedVector_DataGetDPObj
   MODULE PROCEDURE cmfe_DistributedVector_DataGetSPObj
   MODULE PROCEDURE cmfe_DistributedVector_DataGetLObj
 END INTERFACE cmfe_DistributedVector_DataGet

 !>Restore the data array for this vector once it has finished being used
 INTERFACE cmfe_DistributedVector_DataRestore
   MODULE PROCEDURE cmfe_DistributedVector_DataRestoreIntgObj
   MODULE PROCEDURE cmfe_DistributedVector_DataRestoreDPObj
   MODULE PROCEDURE cmfe_DistributedVector_DataRestoreSPObj
   MODULE PROCEDURE cmfe_DistributedVector_DataRestoreLObj
 END INTERFACE cmfe_DistributedVector_DataRestore

 PUBLIC cmfe_DistributedMatrix_StorageTypeGet,cmfe_DistributedMatrix_StorageLocationsGet
 PUBLIC cmfe_DistributedMatrix_DataTypeGet,cmfe_DistributedMatrix_DimensionsGet
 PUBLIC cmfe_DistributedMatrix_DataGet,cmfe_DistributedMatrix_DataRestore
 PUBLIC cmfe_DistributedVector_DataTypeGet
 PUBLIC cmfe_DistributedVector_DataGet,cmfe_DistributedVector_DataRestore

!==================================================================================================================================
!
! NODE_ROUTINES
!
!==================================================================================================================================

 !Module parameters

 !Module types

 !Module variables

 !Interfaces

 !>Finishes the process of creating nodes in a region. \see OpenCMISS::Iron::cmfe_Nodes_CreateStart
 INTERFACE cmfe_Nodes_CreateFinish
   MODULE PROCEDURE cmfe_Nodes_CreateFinishNumber
   MODULE PROCEDURE cmfe_Nodes_CreateFinishObj
 END INTERFACE cmfe_Nodes_CreateFinish

 !>Starts the process of creating nodes in a region. \see OpenCMISS::Iron::cmfe_Nodes_CreateFinish
 INTERFACE cmfe_Nodes_CreateStart
   MODULE PROCEDURE cmfe_Nodes_CreateStartNumber
   MODULE PROCEDURE cmfe_Nodes_CreateStartObj
   MODULE PROCEDURE cmfe_Nodes_CreateStartInterfaceObj
 END INTERFACE cmfe_Nodes_CreateStart

 !>Destroys nodes.
 INTERFACE cmfe_Nodes_Destroy
   MODULE PROCEDURE cmfe_Nodes_DestroyNumber
   MODULE PROCEDURE cmfe_Nodes_DestroyObj
 END INTERFACE cmfe_Nodes_Destroy

 !>Returns the number of nodes
 INTERFACE cmfe_Nodes_NumberOfNodesGet
   MODULE PROCEDURE cmfe_Nodes_NumberOfNodesGetNumber
   MODULE PROCEDURE cmfe_Nodes_NumberOfNodesGetObj
 END INTERFACE cmfe_Nodes_NumberOfNodesGet

 !>Returns the label for a node identified by a given global number. \todo should this be a user number?
 INTERFACE cmfe_Nodes_LabelGet
   MODULE PROCEDURE cmfe_Nodes_LabelGetCNumber
   MODULE PROCEDURE cmfe_Nodes_LabelGetCObj
   MODULE PROCEDURE cmfe_Nodes_LabelGetVSNumber
   MODULE PROCEDURE cmfe_Nodes_LabelGetVSObj
 END INTERFACE cmfe_Nodes_LabelGet

 !>Sets/changes the label for a node identified by a given global number. \todo should this be a user number?
 INTERFACE cmfe_Nodes_LabelSet
   MODULE PROCEDURE cmfe_Nodes_LabelSetCNumber
   MODULE PROCEDURE cmfe_Nodes_LabelSetCObj
   MODULE PROCEDURE cmfe_Nodes_LabelSetVSNumber
   MODULE PROCEDURE cmfe_Nodes_LabelSetVSObj
 END INTERFACE cmfe_Nodes_LabelSet

 !>Returns the user number for a node identified by a given global number.
 INTERFACE cmfe_Nodes_UserNumberGet
   MODULE PROCEDURE cmfe_Nodes_UserNumberGetNumber
   MODULE PROCEDURE cmfe_Nodes_UserNumberGetObj
 END INTERFACE cmfe_Nodes_UserNumberGet

 !>Sets/changes the user number for a node identified by a given global number.
 INTERFACE cmfe_Nodes_UserNumberSet
   MODULE PROCEDURE cmfe_Nodes_UserNumberSetNumber
   MODULE PROCEDURE cmfe_Nodes_UserNumberSetObj
 END INTERFACE cmfe_Nodes_UserNumberSet

 !>Sets/changes the all user number for nodes.
 INTERFACE cmfe_Nodes_UserNumbersAllSet
   MODULE PROCEDURE cmfe_Nodes_UserNumbersAllSetNumber
   MODULE PROCEDURE cmfe_Nodes_UserNumbersAllSetObj
 END INTERFACE cmfe_Nodes_UserNumbersAllSet

 PUBLIC cmfe_Nodes_CreateFinish,cmfe_Nodes_CreateStart

 PUBLIC cmfe_Nodes_Destroy

 PUBLIC cmfe_Nodes_NumberOfNodesGet

 PUBLIC cmfe_Nodes_LabelGet,cmfe_Nodes_LabelSet

 PUBLIC cmfe_Nodes_UserNumberGet,cmfe_Nodes_UserNumberSet,cmfe_Nodes_UserNumbersAllSet

!==================================================================================================================================
!
! ProblemRoutines
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_ProblemConstants OpenCMISS::Iron::Problem::Constants
 !> \brief Problem constants.
 !>@{
 !> \addtogroup OpenCMISS_ProblemClasses OpenCMISS::Iron::Problem::Classes
 !> \brief Problem classes.
 !> \see OpenCMISS::Iron::Problem,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NO_CLASS = PROBLEM_NO_CLASS !<No problem class \see OpenCMISS_ProblemClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ELASTICITY_CLASS = PROBLEM_ELASTICITY_CLASS !<Elasticity problem class \see OpenCMISS_ProblemClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FLUID_MECHANICS_CLASS = PROBLEM_FLUID_MECHANICS_CLASS !<Fluid mechanics problem class \see OpenCMISS_ProblemClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ELECTROMAGNETICS_CLASS = PROBLEM_ELECTROMAGNETICS_CLASS !<Electromagnetics problem class \see OpenCMISS_ProblemClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CLASSICAL_FIELD_CLASS = PROBLEM_CLASSICAL_FIELD_CLASS !<Classical field problem class \see OpenCMISS_ProblemClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIOELECTRICS_CLASS = PROBLEM_BIOELECTRICS_CLASS !<Bioelectrics problem class \see OpenCMISS_ProblemClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MODAL_CLASS = PROBLEM_MODAL_CLASS !<Modal problem class \see OpenCMISS_ProblemClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FITTING_CLASS = PROBLEM_FITTING_CLASS !<Fitting problem class \see OpenCMISS_ProblemClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_OPTIMISATION_CLASS = PROBLEM_OPTIMISATION_CLASS !<Optimisation problem class \see OpenCMISS_ProblemClasses,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MULTI_PHYSICS_CLASS = PROBLEM_MULTI_PHYSICS_CLASS !<Multi physics problem class \see OpenCMISS_ProblemClasses,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_ProblemTypes OpenCMISS::Iron::Problem::Types
 !> \brief Problem Types.
 !> \see OpenCMISS::Iron::Problem,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NO_TYPE = PROBLEM_NO_TYPE !<No problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_ELASTICITY_TYPE = PROBLEM_LINEAR_ELASTICITY_TYPE !<Linear elasticity problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_TYPE = PROBLEM_FINITE_ELASTICITY_TYPE !<Finite elasticity problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE = PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE !<Linear elasticity problem subject to contact contstraint type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE = PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE !<Finite elasticity problem subject to contact constraint type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STOKES_EQUATION_TYPE = PROBLEM_STOKES_EQUATION_TYPE !<Stokes equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NAVIER_STOKES_EQUATION_TYPE = PROBLEM_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DARCY_EQUATION_TYPE = PROBLEM_DARCY_EQUATION_TYPE !<Darcy equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_POISEUILLE_EQUATION_TYPE = PROBLEM_POISEUILLE_EQUATION_TYPE !<Poiseuille equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BURGERS_EQUATION_TYPE = PROBLEM_BURGERS_EQUATION_TYPE !<Burgers equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ELECTROSTATIC_TYPE = PROBLEM_ELECTROSTATIC_TYPE !<Electrostatic problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MAGNETOSTATIC_TYPE = PROBLEM_MAGNETOSTATIC_TYPE !<Magnetostatic problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MAXWELLS_EQUATIONS_TYPE = PROBLEM_MAXWELLS_EQUATIONS_TYPE !<Maxwell's equations problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LAPLACE_EQUATION_TYPE = PROBLEM_LAPLACE_EQUATION_TYPE !<Laplace problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_POISSON_EQUATION_TYPE = PROBLEM_POISSON_EQUATION_TYPE !<Poisson problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_HELMHOLTZ_EQUATION_TYPE = PROBLEM_HELMHOLTZ_EQUATION_TYPE !<Helmholtz problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_WAVE_EQUATION_TYPE = PROBLEM_WAVE_EQUATION_TYPE !<Wave equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DIFFUSION_EQUATION_TYPE = PROBLEM_DIFFUSION_EQUATION_TYPE !<Diffusion equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE = PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE = PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIHARMONIC_EQUATION_TYPE = PROBLEM_BIHARMONIC_EQUATION_TYPE !<Bi-harmonic equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_EQUATION_TYPE = PROBLEM_MONODOMAIN_EQUATION_TYPE !<Monodomain equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIDOMAIN_EQUATION_TYPE = PROBLEM_BIDOMAIN_EQUATION_TYPE !<Bidomain equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_ELASTIC_MODAL_TYPE = PROBLEM_LINEAR_ELASTIC_MODAL_TYPE !<Linear elastic modal problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FITTING_TYPE = PROBLEM_FITTING_TYPE !<Galerkin projection problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_DARCY_TYPE = PROBLEM_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_STOKES_TYPE = PROBLEM_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE = PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity NavierStokes problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DIFFUSION_DIFFUSION_TYPE = PROBLEM_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE = PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE = PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE !<Multi-compartment transport problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE = PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE !<Finite elasticity fluid pressure problem type \see OpenCMISS_ProblemTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE = PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE !<Monodomain finite elasticity problem type \see OpenCMISS_ProblemTypes,OpenCMISS

 !>@}
 !> \addtogroup OpenCMISS_ProblemSubtypes OpenCMISS::Iron::Problem::Subtypes
 !> \brief Problem Subtypes.
 !> \see OpenCMISS::Iron::Problem,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NO_SUBTYPE = PROBLEM_NO_SUBTYPE !<No problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STATIC_STOKES_SUBTYPE = PROBLEM_STATIC_STOKES_SUBTYPE !<Static Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LAPLACE_STOKES_SUBTYPE = PROBLEM_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT_STOKES_SUBTYPE = PROBLEM_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ALE_STOKES_SUBTYPE = PROBLEM_ALE_STOKES_SUBTYPE !<ALE Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_OPTIMISED_STOKES_SUBTYPE = PROBLEM_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE = PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE = PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE !<Transient stabilised Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MULTISCALE_NAVIER_STOKES_SUBTYPE = &
   & PROBLEM_MULTISCALE_NAVIER_STOKES_SUBTYPE !<Transient stabilised Navier-Stokes problem with multiscale boundary coupling subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT1D_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT1D_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_COUPLED1D0D_NAVIER_STOKES_SUBTYPE = PROBLEM_COUPLED1D0D_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes problem subtype with Advection \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE = PROBLEM_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype with Advection \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STREE1D0D_SUBTYPE = PROBLEM_STREE1D0D_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype with Advection \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STREE1D0D_ADV_SUBTYPE = PROBLEM_STREE1D0D_ADV_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype with Advection \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ALE_NAVIER_STOKES_SUBTYPE = PROBLEM_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE = PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_DARCY_SUBTYPE = PROBLEM_STANDARD_DARCY_SUBTYPE !<Standard Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_QUASISTATIC_DARCY_SUBTYPE = PROBLEM_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ALE_DARCY_SUBTYPE = PROBLEM_ALE_DARCY_SUBTYPE !<ALE Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT_DARCY_SUBTYPE = PROBLEM_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_LAPLACE_SUBTYPE = PROBLEM_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STATIC_POISEUILLE_SUBTYPE = PROBLEM_STATIC_POISEUILLE_SUBTYPE !<Static Poiseuille problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE = PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE !<Static Poiseuille problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE = PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE !<Linear source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE = PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE = PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE = PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE = PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE = PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE = PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE !<Nonlinear source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE = PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE !<No source Helmholtz problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE = PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE !<No source Helmholtz problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_DIFFUSION_SUBTYPE = PROBLEM_LINEAR_DIFFUSION_SUBTYPE !<Linear source Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_DIFFUSION_SUBTYPE = PROBLEM_NONLINEAR_DIFFUSION_SUBTYPE !<Nonlinear source Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_ALE_DIFFUSION_SUBTYPE = PROBLEM_LINEAR_ALE_DIFFUSION_SUBTYPE !<Linear source Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_ALE_DIFFUSION_SUBTYPE = PROBLEM_NONLINEAR_ALE_DIFFUSION_SUBTYPE !<Nonlinear source Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GENERALISED_ADVEC_DIFF_SUBTYPE = &
   & PROBLEM_GENERALISED_ADVEC_DIFF_SUBTYPE !<Generalised advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE = &
   & PROBLEM_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_SOURCE_ADVEC_DIFF_SUBTYPE = &
   & PROBLEM_NONLINEAR_SOURCE_ADVEC_DIFF_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE = &
   & PROBLEM_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE !<Generalised ALE advection-diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
   & PROBLEM_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE !<Linear source ALE advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
   & PROBLEM_NONLINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE !<Nonlinear source ALE advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS

 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE = PROBLEM_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE !<Generlised static advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
   & PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source static advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
   & PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Nonlinear source static advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STATIC_BURGERS_SUBTYPE = PROBLEM_STATIC_BURGERS_SUBTYPE !<static Burgers problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DYNAMIC_BURGERS_SUBTYPE = PROBLEM_DYNAMIC_BURGERS_SUBTYPE !<dynamic Burgers problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE = &
   & PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE !<CellML reaction integrated strang-split subtype of reaction diffusion \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE = &
   & PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE !<CellML reaction evaluated no-split subtype of reaction diffusion \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_REAC_DIFF_NO_SPLIT_SUBTYPE = &
   & PROBLEM_REAC_DIFF_NO_SPLIT_SUBTYPE !<Standard constant reaction reaction diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS

 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STATIC_FITTING_SUBTYPE = &
   & PROBLEM_STATIC_FITTING_SUBTYPE !<Static fitting problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_QUASISTATIC_FITTING_SUBTYPE = &
   & PROBLEM_QUASISTATIC_FITTING_SUBTYPE !<Quasistatic fitting problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DIV_FREE_VELOCITY_FITTING_SUBTYPE = &
   & PROBLEM_DIV_FREE_VELOCITY_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS

 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE = PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE = &
   & PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE !<Quasistatic Elasticity Transient Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE = &
   & PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE !<Quasistatic Elasticity Transient Darcy Material Solve problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE = &
   & PROBLEM_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled diffusion-diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_COUPLED_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE = &
   & PROBLEM_COUPLED_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE !<Coupled diffusion & advection-diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE = &
   & PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE !<Standard multi-compartment transport problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE = &
   & PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE !<Standard elasticity fluid pressure problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE = &
   & PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE = &
   & PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE = &
   & PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE !<Transient monodomain simple elasticity problem subtype with titin \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE = &
   & PROBLEM_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype with force-velocity relation \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_1D3D_ACTIVE_STRAIN_SUBTYPE = &
   & PROBLEM_MONODOMAIN_1D3D_ACTIVE_STRAIN_SUBTYPE !<Transient monodomain active strain elasticity problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE = &
   & PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Coupled Finite Elasticity Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_RBS_NAVIER_STOKES_ALE_SUBTYPE = &
   & PROBLEM_FINITE_ELASTICITY_RBS_NAVIER_STOKES_ALE_SUBTYPE !<Coupled Finite Elasticity RBS Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GROWTH_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE = &
   & PROBLEM_GROWTH_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Coupled Finite Elasticity with growth Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GROWTH_FINITE_ELAST_RBS_NAVIER_STOKES_ALE_SUBTYPE = &
   & PROBLEM_GROWTH_FINITE_ELASTICITY_RBS_NAVIER_STOKES_ALE_SUBTYPE !<Coupled Finite Elasticity with growth RBS Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DYNAMIC_FINITE_ELAST_NAV_STOKES_ALE_SUBTYPE = &
    & PROBLEM_DYNAMIC_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Coupled dynamic Finite Elasticity Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DYNAMIC_FINITE_ELAST_RBS_NAV_STOKES_ALE_SUBTYPE = &
    & PROBLEM_DYNAMIC_FINITE_ELASTICITY_RBS_NAVIER_STOKES_ALE_SUBTYPE !<Coupled dynamic Finite Elasticity RBS Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS


 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE = PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE !<Static finite elasticity subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE = PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE !<Quasistatic finite elasticity subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE = &
   & PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE !<Quasistatic finite elasticity with growth subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE = PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE !<Dynamic finite elasticity subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE = PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE !<Quasistatic finite elasticity with active subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE = PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE !<Finite elasticity with CellML subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE =  &
   & PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE !<Finite elasticity with growth and CellML subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS

 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE = PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE !<Monodomain Gudunov split problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE = PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE !<Monodomain Gudunov split problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_DIRECT_MODEL_SUBTYPE = PROBLEM_MONODOMAIN_DIRECT_MODEL_SUBTYPE !<Monodomain Gudunov split problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE = PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE !<Monodomain Bueno-Orovio problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE = PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE !<Monodomain ten Tusscher 06 problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE = PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE !<Bidomain Gudunov split problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE = PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE !<Bidomain Gudunov split problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS

 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE=PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments and reproject at Newton iterations \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE=PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE=PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, reproject at Newton iterations \see OpenCMISS_ProblemSubtypes,OpenCMISS

 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE=PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments and reproject at Newton iterations \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE=PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE !<finear elasticity problem subject to contact constraint, transform field at load increments \see OpenCMISS_ProblemSubtypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE=PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE !<finear elasticity problem subject to contact constraint, reproject at Newton iterations \see OpenCMISS_ProblemSubtypes,OpenCMISS

 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 PUBLIC CMFE_PROBLEM_NO_CLASS,CMFE_PROBLEM_ELASTICITY_CLASS,CMFE_PROBLEM_FLUID_MECHANICS_CLASS, &
   & CMFE_PROBLEM_ELECTROMAGNETICS_CLASS, &
   & CMFE_PROBLEM_CLASSICAL_FIELD_CLASS,CMFE_PROBLEM_BIOELECTRICS_CLASS,CMFE_PROBLEM_MODAL_CLASS,CMFE_PROBLEM_FITTING_CLASS, &
   & CMFE_PROBLEM_OPTIMISATION_CLASS,CMFE_PROBLEM_MULTI_PHYSICS_CLASS

 PUBLIC CMFE_PROBLEM_NO_TYPE

 PUBLIC CMFE_PROBLEM_LINEAR_ELASTICITY_TYPE,CMFE_PROBLEM_FINITE_ELASTICITY_TYPE

 PUBLIC CMFE_PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE, CMFE_PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE

 PUBLIC CMFE_PROBLEM_STOKES_EQUATION_TYPE,CMFE_PROBLEM_NAVIER_STOKES_EQUATION_TYPE,CMFE_PROBLEM_DARCY_EQUATION_TYPE, &
   & CMFE_PROBLEM_POISEUILLE_EQUATION_TYPE,CMFE_PROBLEM_BURGERS_EQUATION_TYPE

 PUBLIC CMFE_PROBLEM_ELECTROSTATIC_TYPE,CMFE_PROBLEM_MAGNETOSTATIC_TYPE,CMFE_PROBLEM_MAXWELLS_EQUATIONS_TYPE

 PUBLIC CMFE_PROBLEM_LAPLACE_EQUATION_TYPE,CMFE_PROBLEM_POISSON_EQUATION_TYPE,CMFE_PROBLEM_HELMHOLTZ_EQUATION_TYPE, &
   & CMFE_PROBLEM_WAVE_EQUATION_TYPE,CMFE_PROBLEM_DIFFUSION_EQUATION_TYPE,CMFE_PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE, &
   & CMFE_PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE,CMFE_PROBLEM_BIHARMONIC_EQUATION_TYPE

 PUBLIC CMFE_PROBLEM_MONODOMAIN_EQUATION_TYPE,CMFE_PROBLEM_BIDOMAIN_EQUATION_TYPE

 PUBLIC CMFE_PROBLEM_LINEAR_ELASTIC_MODAL_TYPE

 PUBLIC CMFE_PROBLEM_FITTING_TYPE

 PUBLIC CMFE_PROBLEM_FINITE_ELASTICITY_DARCY_TYPE, &
   & CMFE_PROBLEM_FINITE_ELASTICITY_STOKES_TYPE, CMFE_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE, &
   & CMFE_PROBLEM_DIFFUSION_DIFFUSION_TYPE, CMFE_PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE, &
   & CMFE_PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE,CMFE_PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE, &
   & CMFE_PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE

 PUBLIC CMFE_PROBLEM_NO_SUBTYPE

 PUBLIC CMFE_PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE, CMFE_PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE, &
   & CMFE_PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE

 PUBLIC CMFE_PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE, CMFE_PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE, &
   & CMFE_PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE

 PUBLIC CMFE_PROBLEM_STATIC_STOKES_SUBTYPE,CMFE_PROBLEM_LAPLACE_STOKES_SUBTYPE,CMFE_PROBLEM_TRANSIENT_STOKES_SUBTYPE, &
   & CMFE_PROBLEM_OPTIMISED_STOKES_SUBTYPE,CMFE_PROBLEM_ALE_STOKES_SUBTYPE

 PUBLIC CMFE_PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE,CMFE_PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE, &
   & CMFE_PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE,CMFE_PROBLEM_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE, &
   & CMFE_PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE, &
   & CMFE_PROBLEM_TRANSIENT1D_NAVIER_STOKES_SUBTYPE,CMFE_PROBLEM_COUPLED1D0D_NAVIER_STOKES_SUBTYPE, &
   & CMFE_PROBLEM_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE,CMFE_PROBLEM_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE, &
   & CMFE_PROBLEM_STREE1D0D_ADV_SUBTYPE,CMFE_PROBLEM_STREE1D0D_SUBTYPE, &
   & CMFE_PROBLEM_ALE_NAVIER_STOKES_SUBTYPE,CMFE_PROBLEM_MULTISCALE_NAVIER_STOKES_SUBTYPE

 PUBLIC CMFE_PROBLEM_STANDARD_DARCY_SUBTYPE,CMFE_PROBLEM_QUASISTATIC_DARCY_SUBTYPE,CMFE_PROBLEM_ALE_DARCY_SUBTYPE, &
   & CMFE_PROBLEM_TRANSIENT_DARCY_SUBTYPE

 PUBLIC CMFE_PROBLEM_STATIC_POISEUILLE_SUBTYPE,CMFE_PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE

 PUBLIC CMFE_PROBLEM_STATIC_BURGERS_SUBTYPE,CMFE_PROBLEM_DYNAMIC_BURGERS_SUBTYPE

 PUBLIC CMFE_PROBLEM_STANDARD_LAPLACE_SUBTYPE

 PUBLIC CMFE_PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE,CMFE_PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE, &
   & CMFE_PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE,CMFE_PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE, &
   & CMFE_PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE, CMFE_PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE, &
   & CMFE_PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE

 PUBLIC CMFE_PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE,CMFE_PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE

 PUBLIC CMFE_PROBLEM_LINEAR_DIFFUSION_SUBTYPE,CMFE_PROBLEM_NONLINEAR_DIFFUSION_SUBTYPE

 PUBLIC CMFE_PROBLEM_LINEAR_ALE_DIFFUSION_SUBTYPE,CMFE_PROBLEM_NONLINEAR_ALE_DIFFUSION_SUBTYPE

 PUBLIC CMFE_PROBLEM_GENERALISED_ADVEC_DIFF_SUBTYPE,CMFE_PROBLEM_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE, &
   & CMFE_PROBLEM_NONLINEAR_SOURCE_ADVEC_DIFF_SUBTYPE

 PUBLIC CMFE_PROBLEM_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE,CMFE_PROBLEM_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE, &
   & CMFE_PROBLEM_NONLINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE

 PUBLIC CMFE_PROBLEM_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE,CMFE_PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
   & CMFE_PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE

 PUBLIC CMFE_PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE, &
   & CMFE_PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE, &
   & CMFE_PROBLEM_REAC_DIFF_NO_SPLIT_SUBTYPE

 PUBLIC CMFE_PROBLEM_STATIC_FITTING_SUBTYPE,CMFE_PROBLEM_QUASISTATIC_FITTING_SUBTYPE, &
   & CMFE_PROBLEM_DIV_FREE_VELOCITY_FITTING_SUBTYPE

 PUBLIC CMFE_PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE,CMFE_PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE, &
   & CMFE_PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE,CMFE_PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE

 PUBLIC CMFE_PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE, CMFE_PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE

 PUBLIC CMFE_PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE, &
   & CMFE_PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE,CMFE_PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE, &
   & CMFE_PROBLEM_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE, CMFE_PROBLEM_COUPLED_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE, &
   & CMFE_PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE,CMFE_PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE, &
   & CMFE_PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE,CMFE_PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE, &
   & CMFE_PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE,CMFE_PROBLEM_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
   & CMFE_PROBLEM_MONODOMAIN_1D3D_ACTIVE_STRAIN_SUBTYPE, &
   & CMFE_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE, &
   & CMFE_PROBLEM_FINITE_ELASTICITY_RBS_NAVIER_STOKES_ALE_SUBTYPE,&
   & CMFE_PROBLEM_GROWTH_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE, &
   & CMFE_PROBLEM_GROWTH_FINITE_ELAST_RBS_NAVIER_STOKES_ALE_SUBTYPE, &
   & CMFE_PROBLEM_DYNAMIC_FINITE_ELAST_NAV_STOKES_ALE_SUBTYPE, &
   & CMFE_PROBLEM_DYNAMIC_FINITE_ELAST_RBS_NAV_STOKES_ALE_SUBTYPE

 PUBLIC CMFE_PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE,CMFE_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE, &
   & CMFE_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE,CMFE_PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE

 PUBLIC CMFE_PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE,CMFE_PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE, &
   & CMFE_PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE

!==================================================================================================================================
!
! PROBLEM_ROUTINES
!
!==================================================================================================================================

 !Module parameters

 !Module types

 !Module variables

 !Interfaces

 !>Finish the creation of CellML equations for a problem. \see OpenCMISS::Iron::cmfe_Problem_CellMLEquationsCreateStart
 INTERFACE cmfe_Problem_CellMLEquationsCreateFinish
   MODULE PROCEDURE cmfe_Problem_CellMLEquationsCreateFinishNumber
   MODULE PROCEDURE cmfe_Problem_CellMLEquationsCreateFinishObj
 END INTERFACE cmfe_Problem_CellMLEquationsCreateFinish

 !>Start the creation of solver equations for a problem. \see OpenCMISS::Iron::cmfe_Problem_CellMLEquationsCreateFinish
 INTERFACE cmfe_Problem_CellMLEquationsCreateStart
   MODULE PROCEDURE cmfe_Problem_CellMLEquationsCreateStartNumber
   MODULE PROCEDURE cmfe_Problem_CellMLEquationsCreateStartObj
 END INTERFACE cmfe_Problem_CellMLEquationsCreateStart

 !>Returns the CellML equations for a problem.
 INTERFACE cmfe_Problem_CellMLEquationsGet
   MODULE PROCEDURE cmfe_Problem_CellMLEquationsGetNumber0
   MODULE PROCEDURE cmfe_Problem_CellMLEquationsGetNumber1
   MODULE PROCEDURE cmfe_Problem_CellMLEquationsGetObj0
   MODULE PROCEDURE cmfe_Problem_CellMLEquationsGetObj1
 END INTERFACE cmfe_Problem_CellMLEquationsGet

 !>Finishes the process of creating a problem. \see OpenCMISS::Iron::cmfe_Problem_CreateStart
 INTERFACE cmfe_Problem_CreateFinish
   MODULE PROCEDURE cmfe_Problem_CreateFinishNumber
   MODULE PROCEDURE cmfe_Problem_CreateFinishObj
 END INTERFACE cmfe_Problem_CreateFinish

 !>Start the process of creating a problem. \see OpenCMISS::Iron::cmfe_Problem_CreateFinish
 INTERFACE cmfe_Problem_CreateStart
   MODULE PROCEDURE cmfe_Problem_CreateStartNumber
   MODULE PROCEDURE cmfe_Problem_CreateStartObj
 END INTERFACE cmfe_Problem_CreateStart

 !>Finishes the process of creating a control loop on a problem. \see OpenCMISS::Iron::cmfe_Problem_ControlLoopCreateStart
 INTERFACE cmfe_Problem_ControlLoopCreateFinish
   MODULE PROCEDURE cmfe_Problem_ControlLoopCreateFinishNumber
   MODULE PROCEDURE cmfe_Problem_ControlLoopCreateFinishObj
 END INTERFACE cmfe_Problem_ControlLoopCreateFinish

 !>Starts the process of creating a control loop on a problem. \see OpenCMISS::Iron::cmfe_Problem_ControlLoopCreateFinish
 INTERFACE cmfe_Problem_ControlLoopCreateStart
   MODULE PROCEDURE cmfe_Problem_ControlLoopCreateStartNumber
   MODULE PROCEDURE cmfe_Problem_ControlLoopCreateStartObj
 END INTERFACE cmfe_Problem_ControlLoopCreateStart

 !>Destroys the control loop for a problem.
 INTERFACE cmfe_Problem_ControlLoopDestroy
   MODULE PROCEDURE cmfe_Problem_ControlLoopDestroyNumber
   MODULE PROCEDURE cmfe_Problem_ControlLoopDestroyObj
 END INTERFACE cmfe_Problem_ControlLoopDestroy

 !>Returns a control loop for a problem.
 INTERFACE cmfe_Problem_ControlLoopGet
   MODULE PROCEDURE cmfe_Problem_ControlLoopGetNumber0
   MODULE PROCEDURE cmfe_Problem_ControlLoopGetNumber1
   MODULE PROCEDURE cmfe_Problem_ControlLoopGetObj0
   MODULE PROCEDURE cmfe_Problem_ControlLoopGetObj1
 END INTERFACE cmfe_Problem_ControlLoopGet

 !>Destroys a problem.
 INTERFACE cmfe_Problem_Destroy
   MODULE PROCEDURE cmfe_Problem_DestroyNumber
   MODULE PROCEDURE cmfe_Problem_DestroyObj
 END INTERFACE cmfe_Problem_Destroy

 !>Solve a problem.
 INTERFACE cmfe_Problem_Solve
   MODULE PROCEDURE cmfe_Problem_SolveNumber
   MODULE PROCEDURE cmfe_Problem_SolveObj
 END INTERFACE cmfe_Problem_Solve

 !>Returns the solver for a problem control loop.
 INTERFACE cmfe_Problem_SolverGet
   MODULE PROCEDURE cmfe_Problem_SolverGetNumber0
   MODULE PROCEDURE cmfe_Problem_SolverGetNumber1
   MODULE PROCEDURE cmfe_Problem_SolverGetObj0
   MODULE PROCEDURE cmfe_Problem_SolverGetObj1
 END INTERFACE cmfe_Problem_SolverGet

 !>Set boundary conditions for solver equations according to the analytic equations.
 INTERFACE cmfe_SolverEquations_BoundaryConditionsAnalytic
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsAnalyticObj
 END INTERFACE cmfe_SolverEquations_BoundaryConditionsAnalytic

 !>Finish the creation of solver equations for a problem. \see OpenCMISS::Iron::cmfe_Problem_SolverEquationsCreateStart
 INTERFACE cmfe_Problem_SolverEquationsCreateFinish
   MODULE PROCEDURE cmfe_Problem_SolverEquationsCreateFinishNumber
   MODULE PROCEDURE cmfe_Problem_SolverEquationsCreateFinishObj
 END INTERFACE cmfe_Problem_SolverEquationsCreateFinish

 !>Start the creation of solver equations for a problem. \see OpenCMISS::Iron::cmfe_Problem_SolverEquationsCreateFinish
 INTERFACE cmfe_Problem_SolverEquationsCreateStart
   MODULE PROCEDURE cmfe_Problem_SolverEquationsCreateStartNumber
   MODULE PROCEDURE cmfe_Problem_SolverEquationsCreateStartObj
 END INTERFACE cmfe_Problem_SolverEquationsCreateStart

 !>Destroys the solver equations for a problem.
 INTERFACE cmfe_Problem_SolverEquationsDestroy
   MODULE PROCEDURE cmfe_Problem_SolverEquationsDestroyNumber
   MODULE PROCEDURE cmfe_Problem_SolverEquationsDestroyObj
 END INTERFACE cmfe_Problem_SolverEquationsDestroy

 !>Returns the solver equations for a problem.
 INTERFACE cmfe_Problem_SolverEquationsGet
   MODULE PROCEDURE cmfe_Problem_SolverEquationsGetNumber0
   MODULE PROCEDURE cmfe_Problem_SolverEquationsGetNumber1
   MODULE PROCEDURE cmfe_Problem_SolverEquationsGetObj0
   MODULE PROCEDURE cmfe_Problem_SolverEquationsGetObj1
 END INTERFACE cmfe_Problem_SolverEquationsGet

 !>Finish the creation of solvers for a problem. \see OpenCMISS::Iron::cmfe_Problem_SolversCreateStart
 INTERFACE cmfe_Problem_SolversCreateFinish
   MODULE PROCEDURE cmfe_Problem_SolversCreateFinishNumber
   MODULE PROCEDURE cmfe_Problem_SolversCreateFinishObj
 END INTERFACE cmfe_Problem_SolversCreateFinish

 !>Start the creation of solvers for a problem. \see OpenCMISS::Iron::cmfe_Problem_SolversCreateFinish
 INTERFACE cmfe_Problem_SolversCreateStart
   MODULE PROCEDURE cmfe_Problem_SolversCreateStartNumber
   MODULE PROCEDURE cmfe_Problem_SolversCreateStartObj
 END INTERFACE cmfe_Problem_SolversCreateStart

 !>Destroy the solvers for a problem.
 INTERFACE cmfe_Problem_SolversDestroy
   MODULE PROCEDURE cmfe_Problem_SolversDestroyNumber
   MODULE PROCEDURE cmfe_Problem_SolversDestroyObj
 END INTERFACE cmfe_Problem_SolversDestroy

 !>Returns the problem specification array for a problem.
 INTERFACE cmfe_Problem_SpecificationGet
   MODULE PROCEDURE cmfe_Problem_SpecificationGetNumber
   MODULE PROCEDURE cmfe_Problem_SpecificationGetObj
 END INTERFACE cmfe_Problem_SpecificationGet

 !>Returns the size of the problem specification array for a problem.
 INTERFACE cmfe_Problem_SpecificationSizeGet
   MODULE PROCEDURE cmfe_Problem_SpecificationSizeGetNumber
   MODULE PROCEDURE cmfe_Problem_SpecificationSizeGetObj
 END INTERFACE cmfe_Problem_SpecificationSizeGet

 !>Sets/changes the work group for a problem.
 INTERFACE cmfe_Problem_WorkGroupSet
   MODULE PROCEDURE cmfe_Problem_WorkGroupSetNumber
   MODULE PROCEDURE cmfe_Problem_WorkGroupSetObj
 END INTERFACE cmfe_Problem_WorkGroupSet

 PUBLIC cmfe_Problem_CellMLEquationsCreateFinish,cmfe_Problem_CellMLEquationsCreateStart

 PUBLIC cmfe_Problem_CellMLEquationsGet

 PUBLIC cmfe_Problem_CreateFinish,cmfe_Problem_CreateStart

 PUBLIC cmfe_Problem_ControlLoopCreateFinish,cmfe_Problem_ControlLoopCreateStart

 PUBLIC cmfe_Problem_ControlLoopDestroy

 PUBLIC cmfe_Problem_ControlLoopGet

 PUBLIC cmfe_Problem_Destroy

 PUBLIC cmfe_Problem_Solve

 PUBLIC cmfe_Problem_SolverGet

 PUBLIC cmfe_SolverEquations_BoundaryConditionsAnalytic

 PUBLIC cmfe_Problem_SolverEquationsCreateFinish,cmfe_Problem_SolverEquationsCreateStart

 PUBLIC cmfe_Problem_SolverEquationsDestroy

 PUBLIC cmfe_Problem_SolverEquationsGet

 PUBLIC cmfe_Problem_SolversCreateFinish,cmfe_Problem_SolversCreateStart

 PUBLIC cmfe_Problem_SolversDestroy

 PUBLIC cmfe_Problem_SpecificationGet,cmfe_Problem_SpecificationSizeGet

 PUBLIC cmfe_Problem_WorkGroupSet

!==================================================================================================================================
!
! RegionRoutines
!
!==================================================================================================================================

 !Module parameters

 !Module types

 !Module variables

 !Interfaces

 !>Returns the coordinate system of region.
 INTERFACE cmfe_Region_CoordinateSystemGet
   MODULE PROCEDURE cmfe_Region_CoordinateSystemGetNumber
   MODULE PROCEDURE cmfe_Region_CoordinateSystemGetObj
 END INTERFACE cmfe_Region_CoordinateSystemGet

 !>Sets/changes the coordinate system of region.
 INTERFACE cmfe_Region_CoordinateSystemSet
   MODULE PROCEDURE cmfe_Region_CoordinateSystemSetNumber
   MODULE PROCEDURE cmfe_Region_CoordinateSystemSetObj
 END INTERFACE cmfe_Region_CoordinateSystemSet

 !>Finishes the creation of a region. \see OpenCMISS::Iron::cmfe_Region_CreateStart
 INTERFACE cmfe_Region_CreateFinish
   MODULE PROCEDURE cmfe_Region_CreateFinishNumber
   MODULE PROCEDURE cmfe_Region_CreateFinishObj
 END INTERFACE cmfe_Region_CreateFinish

 !>Starts the creation of a region. \see OpenCMISS::Iron::cmfe_Region_CreateFinish
 INTERFACE cmfe_Region_CreateStart
   MODULE PROCEDURE cmfe_Region_CreateStartNumber
   MODULE PROCEDURE cmfe_Region_CreateStartObj
 END INTERFACE cmfe_Region_CreateStart

 !>Returns the data points for a region.
 INTERFACE cmfe_Region_DataPointsGet
   MODULE PROCEDURE cmfe_Region_DataPointsGetObj
 END INTERFACE cmfe_Region_DataPointsGet

 !>Destroys a region.
 INTERFACE cmfe_Region_Destroy
   MODULE PROCEDURE cmfe_Region_DestroyNumber
   MODULE PROCEDURE cmfe_Region_DestroyObj
 END INTERFACE cmfe_Region_Destroy

 !>Returns the label of a region.
 INTERFACE cmfe_Region_LabelGet
   MODULE PROCEDURE cmfe_Region_LabelGetCNumber
   MODULE PROCEDURE cmfe_Region_LabelGetCObj
   MODULE PROCEDURE cmfe_Region_LabelGetVSNumber
   MODULE PROCEDURE cmfe_Region_LabelGetVSObj
 END INTERFACE cmfe_Region_LabelGet

 !>Sets/changes the label of a region.
 INTERFACE cmfe_Region_LabelSet
   MODULE PROCEDURE cmfe_Region_LabelSetCNumber
   MODULE PROCEDURE cmfe_Region_LabelSetCObj
   MODULE PROCEDURE cmfe_Region_LabelSetVSNumber
   MODULE PROCEDURE cmfe_Region_LabelSetVSObj
 END INTERFACE cmfe_Region_LabelSet

 !>Returns the nodes for a region.
 INTERFACE cmfe_Region_NodesGet
   MODULE PROCEDURE cmfe_Region_NodesGetObj
 END INTERFACE cmfe_Region_NodesGet

 PUBLIC cmfe_Region_CoordinateSystemGet,cmfe_Region_CoordinateSystemSet

 PUBLIC cmfe_Region_CreateFinish,cmfe_Region_CreateStart

 PUBLIC cmfe_Region_DataPointsGet

 PUBLIC cmfe_Region_Destroy

 PUBLIC cmfe_Region_LabelGet,cmfe_Region_LabelSet

 PUBLIC cmfe_Region_NodesGet

!==================================================================================================================================
!
! SolverRoutines
!
!==================================================================================================================================

 !Module parameters

 !> \addtogroup OpenCMISS_CellMLEquationsConstants OpenCMISS::Iron::CellMLEquations::Constants
 !> \brief CellML equations constants.
 !>@{
 !> \addtogroup OpenCMISS_CellMLEquationsLinearityTypes OpenCMISS::Iron::CellMLEquations::Constants::LinearityTypes
 !> \brief The CellML equations linearity types
 !> \see OpenCMISS::Iron::CellMLEquations,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_CELLML_EQUATIONS_LINEAR = CELLML_EQUATIONS_LINEAR !<The CellML equations are linear. \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CELLML_EQUATIONS_NONLINEAR = CELLML_EQUATIONS_NONLINEAR !<The CellML equations are non-linear. \see \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_CellMLEquationsTimeDependenceTypes OpenCMISS::Iron::CellMLEquations::Constants:TimeDependenceTypes
 !> \brief The CellML equations time dependence types
 !> \see OpenCMISS::Iron::CellMLEquations,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_CELLML_EQUATIONS_STATIC = CELLML_EQUATIONS_STATIC !<The CellML equations are static and have no time dependence. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CELLML_EQUATIONS_QUASISTATIC = CELLML_EQUATIONS_QUASISTATIC !<The CellML equations are quasi-static. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_CELLML_EQUATIONS_DYNAMIC = CELLML_EQUATIONS_DYNAMIC !<The equations are dynamic. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
 !>@}
 !>@}

 !> \addtogroup OpenCMISS_SolverConstants OpenCMISS::Iron::Solver::Constants
 !> \brief Solver constants.
 !>@{
 !> \addtogroup OpenCMISS_SolverTypes OpenCMISS::Iron::Solver::SolverTypes
 !> \brief The types of solver
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_LINEAR_TYPE = SOLVER_LINEAR_TYPE !<A linear solver. \see OpenCMISS_SolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NONLINEAR_TYPE = SOLVER_NONLINEAR_TYPE !<A nonlinear solver. \see OpenCMISS_SolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_TYPE = SOLVER_DYNAMIC_TYPE !<A dynamic solver. \see  OpenCMISS_SolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_TYPE = SOLVER_DAE_TYPE !<A differential-algebraic equation solver. \see OpenCMISS_SolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_EIGENPROBLEM_TYPE = SOLVER_EIGENPROBLEM_TYPE !<A eigenproblem solver. \see OpenCMISS_SolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_OPTIMISER_TYPE = SOLVER_OPTIMISER_TYPE !<An optimiser solver. \see OpenCMISS_SolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: cmfe_SolverCellMLEvaluatorType = SOLVER_CELLML_EVALUATOR_TYPE !<A CellML evaluator solver. \see OpenCMISS_SolverTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_SolverLibraries OpenCMISS::Iron::Solver::SolverLibraries
 !> \brief The types of solver libraries.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_CMISS_LIBRARY = SOLVER_CMISS_LIBRARY !<CMISS (internal) solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_PETSC_LIBRARY = SOLVER_PETSC_LIBRARY !<PETSc solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_MUMPS_LIBRARY = SOLVER_MUMPS_LIBRARY !<MUMPS solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SUPERLU_LIBRARY = SOLVER_SUPERLU_LIBRARY !<SuperLU solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SPOOLES_LIBRARY = SOLVER_SPOOLES_LIBRARY !<SPOOLES solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_UMFPACK_LIBRARY = SOLVER_UMFPACK_LIBRARY !<UMFPACK solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_LUSOL_LIBRARY = SOLVER_LUSOL_LIBRARY !<LUSOL solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ESSL_LIBRARY = SOLVER_ESSL_LIBRARY !<ESSL solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_LAPACK_LIBRARY = SOLVER_LAPACK_LIBRARY !<LAPACK solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_HYPRE_LIBRARY = SOLVER_HYPRE_LIBRARY !<Hypre solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_PASTIX_LIBRARY = SOLVER_PASTIX_LIBRARY !<PaStiX solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_LinearSolverTypes OpenCMISS::Iron::Solver::LinearSolverTypes
 !> \brief The types of linear solvers.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_LINEAR_DIRECT_SOLVE_TYPE = SOLVER_LINEAR_DIRECT_SOLVE_TYPE !<Direct linear solver type. \see OpenCMISS_LinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE = SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE !<Iterative linear solver type. \see OpenCMISS_LinearSolverTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_DirectLinearSolverTypes OpenCMISS::Iron::Solver::DirectLinearSolverTypes
 !> \brief The types of direct linear solvers. \todo Move libraries to a more appropriate place.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DIRECT_LU = SOLVER_DIRECT_LU !<LU direct linear solver. \see OpenCMISS_DirectLinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DIRECT_CHOLESKY = SOLVER_DIRECT_CHOLESKY !<Cholesky direct linear solver. \see OpenCMISS_DirectLinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DIRECT_SVD = SOLVER_DIRECT_SVD !<SVD direct linear solver. \see OpenCMISS_DirectLinearSolverTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_IterativeLinearSolverTypes OpenCMISS::Iron::Solver::IterativeLinearSolverTypes
 !> \brief The types of iterative linear solvers.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_RICHARDSON = SOLVER_ITERATIVE_RICHARDSON !<Richardson iterative solver type. \see  OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_CHEBYSHEV = SOLVER_ITERATIVE_CHEBYSHEV !<Chebychev iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_CONJUGATE_GRADIENT = SOLVER_ITERATIVE_CONJUGATE_GRADIENT !<Conjugate gradient iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_BICONJUGATE_GRADIENT = SOLVER_ITERATIVE_BICONJUGATE_GRADIENT !<Bi-conjugate gradient iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_GMRES = SOLVER_ITERATIVE_GMRES !<Generalised minimum residual iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_BiCGSTAB = SOLVER_ITERATIVE_BiCGSTAB !<Stabalised bi-conjugate gradient iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_CONJGRAD_SQUARED = SOLVER_ITERATIVE_CONJGRAD_SQUARED !<Conjugate gradient squared iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_IterativePreconditionerTypes OpenCMISS::Iron::Solver::IterativePreconditionerTypes
 !> \brief The types of iterative preconditioners.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_NO_PRECONDITIONER = SOLVER_ITERATIVE_NO_PRECONDITIONER !<No preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_JACOBI_PRECONDITIONER = SOLVER_ITERATIVE_JACOBI_PRECONDITIONER !<Jacobi preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER = SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER !<Iterative block Jacobi preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_SOR_PRECONDITIONER = SOLVER_ITERATIVE_SOR_PRECONDITIONER !<Successive over relaxation preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER = &
   & SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER !<Incomplete Cholesky preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER = SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER !<Incomplete LU preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER =  &
   & SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER !<Additive Schwrz preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_NonlinearSolverTypes OpenCMISS::Iron::Solver::NonlinearSolverTypes
 !> \brief The types of nonlinear solvers.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NONLINEAR_NEWTON = SOLVER_NONLINEAR_NEWTON !<Newton nonlinear solver type. \see OpenCMISS_NonlinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NONLINEAR_BFGS_INVERSE = SOLVER_NONLINEAR_BFGS_INVERSE !<BFGS inverse nonlinear solver type. \see OpenCMISS_NonlinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NONLINEAR_SQP = SOLVER_NONLINEAR_SQP !<Sequential Quadratic Program nonlinear solver type. \see OpenCMISS_NonlinearSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NONLINEAR_QUASI_NEWTON = SOLVER_NONLINEAR_QUASI_NEWTON !<Quasi-Newton nonlinear solver type. \see OpenCMISS_NonlinearSolverTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_QuasiNewtonSolverTypes OpenCMISS::Iron::Solver::QuasiNewtonSolverTypes
 !> \brief The types of nonlinear Quasi-Newton solvers
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_LINESEARCH=SOLVER_QUASI_NEWTON_LINESEARCH !<Quasi-Newton line search nonlinear solver type \see OpenCMISS_QuasiNewtonSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_TRUSTREGION=SOLVER_QUASI_NEWTON_TRUSTREGION !<Quasi-Newton trust region nonlinear solver type \see OpenCMISS_QuasiNewtonSolverTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_QuasiNewtonTypes OpenCMISS::Iron::Solver::QuasiNewtonTypes
 !> \brief The nonlinear Quasi-Newton types
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_LBFGS=SOLVER_QUASI_NEWTON_LBFGS !<LBFGS Quasi-Newton type \see OpenCMISS_QuasiNewtonTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_GOODBROYDEN=SOLVER_QUASI_NEWTON_GOODBROYDEN !<"Good" Broyden Quasi-Newton type \see OpenCMISS_QuasiNewtonTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_BADBROYDEN=SOLVER_QUASI_NEWTON_BADBROYDEN !<"Bad" Broyden Quasi-Newton type \see OpenCMISS_QuasiNewtonTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_QuasiNewtonLineSearchTypes OpenCMISS::Iron::Solver::NonlinearQuasiNewtonLineSearchTypes
 !> \brief The types of line search techniques for Quasi-Newton line search nonlinear solvers
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_BASIC=SOLVER_QUASI_NEWTON_LINESEARCH_BASIC !<Simple damping line search. \see OpenCMISS_QuasiNewtonLineSearchTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_L2=SOLVER_QUASI_NEWTON_LINESEARCH_L2 !<Secant line search over the L2 norm of the function \see OpenCMISS_QuasiNewtonLineSearchTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_CP=SOLVER_QUASI_NEWTON_LINESEARCH_CP !<Critical point secant line search \see OpenCMISS_QuasiNewtonLineSearchTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_QuasiNewtonRestartTypes OpenCMISS::Iron::Solver::QuasiNewtonRestartTypes
 !> \brief The nonlinear Quasi-Newton restart types
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_RESTART_NONE=SOLVER_QUASI_NEWTON_RESTART_NONE !<Never restart \see OpenCMISS_QuasiNewtonRestartTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_RESTART_POWELL=SOLVER_QUASI_NEWTON_RESTART_POWELL !<Restart based upon descent criteria \see OpenCMISS_QuasiNewtonRestartTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_RESTART_PERIODIC=SOLVER_QUASI_NEWTON_RESTART_PERIODIC !<Restart after a fixed number of iterations \see OpenCMISS_QuasiNewtonRestartTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_QuasiNewtonScaleTypes OpenCMISS::Iron::Solver::QuasiNewtonScaleTypes
 !> \brief The nonlinear Quasi-Newton scale types
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_SCALE_NONE=SOLVER_QUASI_NEWTON_SCALE_NONE !<Don't scale the problem \see OpenCMISS_QuasiNewtonScaleTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_SCALE_SHANNO=SOLVER_QUASI_NEWTON_SCALE_SHANNO !<Use Shanno scaling \see OpenCMISS_QuasiNewtonScaleTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_SCALE_LINESEARCH=SOLVER_QUASI_NEWTON_SCALE_LINESEARCH !<Scale based upon line search lambda \see OpenCMISS_QuasiNewtonScaleTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_SCALE_JACOBIAN=SOLVER_QUASI_NEWTON_SCALE_JACOBIAN !<Scale by inverting a previously computed Jacobian \see OpenCMISS_QuasiNewtonScaleTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_NewtonSolverTypes OpenCMISS::Iron::Solver::NewtonSolverTypes
 !> \brief The types of nonlinear Newton solvers.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_LINESEARCH = SOLVER_NEWTON_LINESEARCH !<Newton line search nonlinear solver type. \see OpenCMISS_NewtonSolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_TRUSTREGION = SOLVER_NEWTON_TRUSTREGION !<Newton trust region nonlinear solver type. \see OpenCMISS_NewtonSolverTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_NewtonLineSearchTypes OpenCMISS::Iron::Solver::NewtonLineSearchTypes
 !> \brief The types line search techniques for Newton line search nonlinear solvers.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_LINESEARCH_LINEAR = SOLVER_NEWTON_LINESEARCH_LINEAR !<Linear line search for Newton line search nonlinear solves \see OpenCMISS_NewtonLineSearchTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_LINESEARCH_QUADRATIC = SOLVER_NEWTON_LINESEARCH_QUADRATIC !<Quadratic search for Newton line search nonlinear solves \see OpenCMISS_NewtonLineSearchTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_LINESEARCH_CUBIC = SOLVER_NEWTON_LINESEARCH_CUBIC !<Cubic search for Newton line search nonlinear solves \see OpenCMISS_NewtonLineSearchTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_JacobianCalculationTypes OpenCMISS::Iron::Solver::JacobianCalculationTypes
 !> \brief The Jacobian calculation types for a nonlinear solver.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED = SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED !<The Jacobian values will not be calculated for the nonlinear equations set. \see OpenCMISS_JacobianCalculationTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED = SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED !<The Jacobian values will be calculated  analytically for the nonlinear equations set. \see OpenCMISS_JacobianCalculationTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_JACOBIAN_FD_CALCULATED = SOLVER_NEWTON_JACOBIAN_FD_CALCULATED !<The Jacobian values will be calcualted using finite differences for the nonlinear equations set. \see OpenCMISS_JacobianCalculationTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_NewtonConvergenceTypes OpenCMISS::Iron::Solver::NewtonConvergenceTypes
 !> \brief The convergence test types for a nonlinear newton solver.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT = SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT !<Newton solver Petsc default convergence test type. \see OpenCMISS_NewtonConvergenceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM = SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM !<Newton solver energy norm convergence test type. \see OpenCMISS_NewtonConvergenceTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO = SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO !<Newton solver Sum of differentiated ratios of unconstrained to constrained residuals convergence test type. \see OpenCMISS_NewtonConvergenceTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_DynamicOrderTypes OpenCMISS::Iron::Solver::DynamicOrderTypes
 !> \brief The order types for a dynamic solver.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_FIRST_ORDER = SOLVER_DYNAMIC_FIRST_ORDER !<Dynamic solver has first order terms. \see OpenCMISS_DynamicOrderTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_SECOND_ORDER = SOLVER_DYNAMIC_SECOND_ORDER !<Dynamic solver has second order terms. \see OpenCMISS_DynamicOrderTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_DynamicLinearityTypes OpenCMISS::Iron::Solver::DynamicLinearityTypes
 !> \brief The time linearity types for a dynamic solver.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_LINEAR = SOLVER_DYNAMIC_LINEAR !<Dynamic solver has linear terms. \see OpenCMISS_DynamicLinearityTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_NONLINEAR = SOLVER_DYNAMIC_NONLINEAR !<Dynamic solver has nonlinear terms. \see OpenCMISS_DynamicLinearityTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_DynamicDegreeTypes OpenCMISS::Iron::Solver::DynamicDegreeTypes
 !> \brief The time interpolation polynomial degree types for a dynamic solver.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_FIRST_DEGREE = SOLVER_DYNAMIC_FIRST_DEGREE !<Dynamic solver uses a first degree polynomial for time interpolation. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_SECOND_DEGREE = SOLVER_DYNAMIC_SECOND_DEGREE !<Dynamic solver uses a second degree polynomial for time interpolation. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_THIRD_DEGREE = SOLVER_DYNAMIC_THIRD_DEGREE !<Dynamic solver uses a third degree polynomial for time interpolation. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_DynamicSchemeTypes OpenCMISS::Iron::Solver::DynamicSchemeTypes
 !> \brief The types of dynamic solver scheme.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_EULER_SCHEME = SOLVER_DYNAMIC_EULER_SCHEME !<Euler (explicit) dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME = SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME !<Backward Euler (implicit) dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME = SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME !<Crank-Nicolson dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_GALERKIN_SCHEME = SOLVER_DYNAMIC_GALERKIN_SCHEME !<Galerkin dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_ZLAMAL_SCHEME = SOLVER_DYNAMIC_ZLAMAL_SCHEME !<Zlamal dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME !<2nd degree Gear dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME !<1st 2nd degree Liniger dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME !<2nd 2nd degree Liniger dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_NEWMARK1_SCHEME = SOLVER_DYNAMIC_NEWMARK1_SCHEME !<1st Newmark dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_NEWMARK2_SCHEME = SOLVER_DYNAMIC_NEWMARK2_SCHEME !<2nd Newmark dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_NEWMARK3_SCHEME = SOLVER_DYNAMIC_NEWMARK3_SCHEME !<3rd Newmark dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME !<3rd degree Gear dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME !<1st 3rd degree Liniger dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME !<2nd 3rd degree Liniger dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_HOUBOLT_SCHEME = SOLVER_DYNAMIC_HOUBOLT_SCHEME !<Houbolt dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_WILSON_SCHEME = SOLVER_DYNAMIC_WILSON_SCHEME !<Wilson dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME = SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME !<1st Bossak-Newmark dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME = SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME !<2nd Bossak-Newmark dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_USER_DEFINED_SCHEME = SOLVER_DYNAMIC_USER_DEFINED_SCHEME !<User specified degree and theta dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_DAETypes OpenCMISS::Iron::Solver::DAETypes
 !> \brief The type of differential-algebraic equation.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_DIFFERENTIAL_ONLY = SOLVER_DAE_DIFFERENTIAL_ONLY !<Differential equations only. \see OpenCMISS_DAETypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_INDEX_1 = SOLVER_DAE_INDEX_1 !<Index 1 differential-algebraic equation. \see OpenCMISS_DAETypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_INDEX_2 = SOLVER_DAE_INDEX_2 !<Index 2 differential-algebraic equation. \see OpenCMISS_DAETypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_INDEX_3 = SOLVER_DAE_INDEX_3 !<Index 3 differential-algebraic equation. \see OpenCMISS_DAETypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_DAESolverTypes OpenCMISS::Iron::Solver::DAESolverTypes
 !> \brief The differential-algebraic equation solver types for a differential-algebraic equation solver.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_EULER = SOLVER_DAE_EULER !<Euler differential-algebraic equation solver. \see
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_CRANK_NICOLSON = SOLVER_DAE_CRANK_NICOLSON !<Crank-Nicolson differential-algebraic equation solver. \see
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_RUNGE_KUTTA = SOLVER_DAE_RUNGE_KUTTA !<Runge-Kutta differential-algebraic equation solver. \see
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_ADAMS_MOULTON = SOLVER_DAE_ADAMS_MOULTON !<Adams-Moulton differential-algebraic equation solver. \see
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_BDF = SOLVER_DAE_BDF !<General BDF differential-algebraic equation solver. \see
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_RUSH_LARSON = SOLVER_DAE_RUSH_LARSON !<Rush-Larson differential-algebraic equation solver. \see
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_EXTERNAL = SOLVER_DAE_EXTERNAL !<External (e.g., CellML generated) differential-algebraic equation solver. \see
 !>@}
 !> \addtogroup OpenCMISS_EulerDAESolverTypes OpenCMISS::Iron::Solver::EulerDAESolverTypes
 !> \brief The Euler solver types for a differential-algebriac equation solver.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_EULER_FORWARD = SOLVER_DAE_EULER_FORWARD !<Forward Euler differential equation solver. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_EULER_BACKWARD = SOLVER_DAE_EULER_BACKWARD !<Backward Euler differential equation solver. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_EULER_IMPROVED = SOLVER_DAE_EULER_IMPROVED !<Improved Euler differential equation solver. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_SolutionInitialiseTypes OpenCMISS::Iron::Solver::SolutionInitialiseTypes
 !> \brief The types of solution initialisation.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SOLUTION_INITIALISE_ZERO = SOLVER_SOLUTION_INITIALISE_ZERO !<Initialise the solution by zeroing it before a solve. \see OpenCMISS_SolutionInitialiseTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD = SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD !<Initialise the solution by copying in the current dependent field values. \see OpenCMISS_SolutionInitialiseTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SOLUTION_INITIALISE_NO_CHANGE = SOLVER_SOLUTION_INITIALISE_NO_CHANGE !<Do not change the solution before a solve. \see OpenCMISS_SolutionInitialiseTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_SolverOutputTypes OpenCMISS::Iron::Solver::OutputTypes
 !> \brief The types of output.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NO_OUTPUT = SOLVER_NO_OUTPUT !<No output from the solver routines. \see OpenCMISS_SolverOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_MONITOR_OUTPUT = SOLVER_MONITOR_OUTPUT !<Monitor output from solver routines. \see OpenCMISS_SolverOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_PROGRESS_OUTPUT = SOLVER_PROGRESS_OUTPUT !<Progress output from solver routines. \see OpenCMISS_SolverOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_TIMING_OUTPUT = SOLVER_TIMING_OUTPUT !<Timing output from the solver routines plus below. \see OpenCMISS_SolverOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SOLVER_OUTPUT = SOLVER_SOLVER_OUTPUT !<Solver specific output from the solver routines plus below. \see OpenCMISS_SolverOutputTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_MATRIX_OUTPUT = SOLVER_MATRIX_OUTPUT !<Solver matrices output from the solver routines plus below. \see OpenCMISS_SolverOutputTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_SolverEquationsSparsityTypes OpenCMISS::Iron::SolverEquations::SparsityTypes
 !> \brief The types of sparse solver equations matrices.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SPARSE_MATRICES = SOLVER_SPARSE_MATRICES !<Use sparse solver matrices. \see OpenCMISS_SolverEquationsSparsityTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_FULL_MATRICES = SOLVER_FULL_MATRICES !<Use fully populated solver matrices. \see OpenCMISS_SolverEquationsSparsityTypes,OpenCMISS
 !>@}
 !> \addtogroup OpenCMISS_SolverEquationsSymmetryTypes OpenCMISS::Iron::SolverEquations::SymmetryTypes
 !> \brief The types of symmetry for the solver equations matrices.
 !> \see OpenCMISS::Iron::Solver::Constants,OpenCMISS
 !>@{
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SYMMETRIC_MATRICES = SOLVER_SYMMETRIC_MATRICES !<Use symmetric solver matrices. \see OpenCMISS_SolverEquationsSymmetryTypes,OpenCMISS
 INTEGER(INTG), PARAMETER :: CMFE_SOLVER_UNSYMMETRIC_MATRICES = SOLVER_UNSYMMETRIC_MATRICES !<Use unsymmetric solver matrices. \see OpenCMISS_SolverEquationsSymmetryTypes,OpenCMISS
 !>@}
 !>@}

 !Module types

 !Module variables

 !Interfaces

 !>Returns the CellML equations for a solver.
 INTERFACE cmfe_Solver_CellMLEquationsGet
   MODULE PROCEDURE cmfe_Solver_CellMLEquationsGetNumber0
   MODULE PROCEDURE cmfe_Solver_CellMLEquationsGetNumber1
   MODULE PROCEDURE cmfe_Solver_CellMLEquationsGetObj
 END INTERFACE cmfe_Solver_CellMLEquationsGet

 !>Adds CellML environments to CellML equations.
 INTERFACE cmfe_CellMLEquations_CellMLAdd
   MODULE PROCEDURE cmfe_CellMLEquations_CellMLAddNumber0
   MODULE PROCEDURE cmfe_CellMLEquations_CellMLAddNumber1
   MODULE PROCEDURE cmfe_CellMLEquations_CellMLAddObj
 END INTERFACE cmfe_CellMLEquations_CellMLAdd

 !>Returns the linearity type of CellML equations.
 INTERFACE cmfe_CellMLEquations_LinearityTypeGet
   MODULE PROCEDURE cmfe_CellMLEquations_LinearityTypeGetNumber
   MODULE PROCEDURE cmfe_CellMLEquations_LinearityTypeGetObj
 END INTERFACE cmfe_CellMLEquations_LinearityTypeGet

 !>Sets/changes the linearity type of CellML equations.
 INTERFACE cmfe_CellMLEquations_LinearityTypeSet
   MODULE PROCEDURE cmfe_CellMLEquations_LinearityTypeSetNumber
   MODULE PROCEDURE cmfe_CellMLEquations_LinearityTypeSetObj
 END INTERFACE cmfe_CellMLEquations_LinearityTypeSet

 !>Returns the time dependence type of CellML equations.
 INTERFACE cmfe_CellMLEquations_TimeDependenceTypeGet
   MODULE PROCEDURE cmfe_CellMLEquations_TimeDependenceTypeGetNumber
   MODULE PROCEDURE cmfe_CellMLEquations_TimeDependenceTypeGetObj
 END INTERFACE cmfe_CellMLEquations_TimeDependenceTypeGet

 !>Sets/changes the time dependence type of CellML equations.
 INTERFACE cmfe_CellMLEquations_TimeDependenceTypeSet
   MODULE PROCEDURE cmfe_CellMLEquations_TimeDependenceTypeSetNumber
   MODULE PROCEDURE cmfe_CellMLEquations_TimeDependenceTypeSetObj
 END INTERFACE cmfe_CellMLEquations_TimeDependenceTypeSet

 !>Returns the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolver_DAEEulerSolverTypeGet???
 INTERFACE cmfe_Solver_DAEEulerSolverTypeGet
   MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeGetNumber0
   MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeGetNumber1
   MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeGetObj
 END INTERFACE cmfe_Solver_DAEEulerSolverTypeGet

 !>Sets/changes the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolver_DAEEulerSolverTypeSet???
 INTERFACE cmfe_Solver_DAEEulerSolverTypeSet
   MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeSetObj
 END INTERFACE cmfe_Solver_DAEEulerSolverTypeSet

 !>Returns the solver type for an differential-algebraic equation solver.
 INTERFACE cmfe_Solver_DAESolverTypeGet
   MODULE PROCEDURE cmfe_Solver_DAESolverTypeGetNumber0
   MODULE PROCEDURE cmfe_Solver_DAESolverTypeGetNumber1
   MODULE PROCEDURE cmfe_Solver_DAESolverTypeGetObj
 END INTERFACE cmfe_Solver_DAESolverTypeGet

 !>Sets/changes the solver type for an differential-algebraic equation solver.
 INTERFACE cmfe_Solver_DAESolverTypeSet
   MODULE PROCEDURE cmfe_Solver_DAESolverTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_DAESolverTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_DAESolverTypeSetObj
 END INTERFACE cmfe_Solver_DAESolverTypeSet

 !>Sets/changes the times for a differential-algebraic equation solver.
 INTERFACE cmfe_Solver_DAETimesSet
   MODULE PROCEDURE cmfe_Solver_DAETimesSetNumber0
   MODULE PROCEDURE cmfe_Solver_DAETimesSetNumber1
   MODULE PROCEDURE cmfe_Solver_DAETimesSetObj
 END INTERFACE cmfe_Solver_DAETimesSet

 !>Sets/changes the (initial) time step for a differential-algebraic equation solver.
 INTERFACE cmfe_Solver_DAETimeStepSet
   MODULE PROCEDURE cmfe_Solver_DAETimeStepSetNumber0
   MODULE PROCEDURE cmfe_Solver_DAETimeStepSetNumber1
   MODULE PROCEDURE cmfe_Solver_DAETimeStepSetObj
 END INTERFACE cmfe_Solver_DAETimeStepSet

 !>Returns the degree of the polynomial used to interpolate time for a dynamic solver.
 INTERFACE cmfe_Solver_DynamicDegreeGet
   MODULE PROCEDURE cmfe_Solver_DynamicDegreeGetNumber0
   MODULE PROCEDURE cmfe_Solver_DynamicDegreeGetNumber1
   MODULE PROCEDURE cmfe_Solver_DynamicDegreeGetObj
 END INTERFACE cmfe_Solver_DynamicDegreeGet

 !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver.
 INTERFACE cmfe_Solver_DynamicDegreeSet
   MODULE PROCEDURE cmfe_Solver_DynamicDegreeSetNumber0
   MODULE PROCEDURE cmfe_Solver_DynamicDegreeSetNumber1
   MODULE PROCEDURE cmfe_Solver_DynamicDegreeSetObj
 END INTERFACE cmfe_Solver_DynamicDegreeSet

 !>Returns the linearity type for the dynamic solver.
 INTERFACE cmfe_Solver_DynamicLinearityTypeGet
   MODULE PROCEDURE cmfe_Solver_DynamicLinearityTypeGetNumber0
   MODULE PROCEDURE cmfe_Solver_DynamicLinearityTypeGetNumber1
   MODULE PROCEDURE cmfe_Solver_DynamicLinearityTypeGetObj
 END INTERFACE cmfe_Solver_DynamicLinearityTypeGet

 !>Returns the linear solver associated with a linear dynamic solver.
 INTERFACE cmfe_Solver_DynamicLinearSolverGet
   MODULE PROCEDURE cmfe_Solver_DynamicLinearSolverGetNumber0
   MODULE PROCEDURE cmfe_Solver_DynamicLinearSolverGetNumber1
   MODULE PROCEDURE cmfe_Solver_DynamicLinearSolverGetObj
 END INTERFACE cmfe_Solver_DynamicLinearSolverGet

 !>Returns the nonlinear solver associated with a nonlinear dynamic solver.
 INTERFACE cmfe_Solver_DynamicNonlinearSolverGet
   MODULE PROCEDURE cmfe_Solver_DynamicNonlinearSolverGetNumber0
   MODULE PROCEDURE cmfe_Solver_DynamicNonlinearSolverGetNumber1
   MODULE PROCEDURE cmfe_Solver_DynamicNonlinearSolverGetObj
 END INTERFACE cmfe_Solver_DynamicNonlinearSolverGet

 !>Sets/changes the scheme for a dynamic solver.
 INTERFACE cmfe_Solver_DynamicSchemeSet
   MODULE PROCEDURE cmfe_Solver_DynamicSchemeSetNumber0
   MODULE PROCEDURE cmfe_Solver_DynamicSchemeSetNumber1
   MODULE PROCEDURE cmfe_Solver_DynamicSchemeSetObj
 END INTERFACE cmfe_Solver_DynamicSchemeSet

 !>Sets/changes the theta scheme values for a dynamic solver.
 INTERFACE cmfe_Solver_DynamicThetaSet
   MODULE PROCEDURE cmfe_Solver_DynamicThetaSetNumber00
   MODULE PROCEDURE cmfe_Solver_DynamicThetaSetNumber01
   MODULE PROCEDURE cmfe_Solver_DynamicThetaSetNumber10
   MODULE PROCEDURE cmfe_Solver_DynamicThetaSetNumber11
   MODULE PROCEDURE cmfe_Solver_DynamicThetaSetObj0
   MODULE PROCEDURE cmfe_Solver_DynamicThetaSetObj1
 END INTERFACE cmfe_Solver_DynamicThetaSet

 !>Sets/changes the dynamic times for a dynamic solver.
 INTERFACE cmfe_Solver_DynamicTimesSet
   MODULE PROCEDURE cmfe_Solver_DynamicTimesSetNumber0
   MODULE PROCEDURE cmfe_Solver_DynamicTimesSetNumber1
   MODULE PROCEDURE cmfe_Solver_DynamicTimesSetObj
 END INTERFACE cmfe_Solver_DynamicTimesSet

 !Sets the arbitrary path logical for the transformation
 INTERFACE cmfe_Solver_GeometricTransformationArbitraryPathSet
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationArbitraryPathSetNumber
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationArbitraryPathSetObj
 END INTERFACE cmfe_Solver_GeometricTransformationArbitraryPathSet

 !Clear transformation for a geometric transformation solver
 INTERFACE cmfe_Solver_GeometricTransformationClear
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationClearNumber
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationClearObj
 END INTERFACE cmfe_Solver_GeometricTransformationClear

 !Sets the field to transform
 INTERFACE cmfe_Solver_GeometricTransformationFieldSet
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationFieldSetNumber
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationFieldSetObj
 END INTERFACE cmfe_Solver_GeometricTransformationFieldSet

 !Sets the full transformation matrix for a geometric transformation
 INTERFACE cmfe_Solver_GeometricTransformationMatrixSet
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationMatrixSetNumber0
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationMatrixSetObj0
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationMatrixSetNumber1
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationMatrixSetObj1
 END INTERFACE cmfe_Solver_GeometricTransformationMatrixSet

 !Sets number of load increments for the transformation
 INTERFACE cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSet
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetNumber
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetObj
 END INTERFACE cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSet

 !Sets the rotation for a geometric transformation
 INTERFACE cmfe_Solver_GeometricTransformationRotationSet
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationRotationSetNumber0
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationRotationSetObj0
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationRotationSetNumber1
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationRotationSetObj1
 END INTERFACE cmfe_Solver_GeometricTransformationRotationSet

 !Sets the scalings for a uni-directional geometric transformation
 INTERFACE cmfe_Solver_GeometricTransformationScalingsSet
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationScalingsSetNumber
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationScalingsSetObj
 END INTERFACE cmfe_Solver_GeometricTransformationScalingsSet

 !Sets the translation for a geometric transformation
 INTERFACE cmfe_Solver_GeometricTransformationTranslationSet
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationTranslationSetNumber0
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationTranslationSetObj0
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationTranslationSetNumber1
   MODULE PROCEDURE cmfe_Solver_GeometricTransformationTranslationSetObj1
 END INTERFACE cmfe_Solver_GeometricTransformationTranslationSet

 !>Returns the label of a solver.
 INTERFACE cmfe_Solver_LabelGet
   MODULE PROCEDURE cmfe_Solver_LabelGetCNumber0
   MODULE PROCEDURE cmfe_Solver_LabelGetCNumber1
   MODULE PROCEDURE cmfe_Solver_LabelGetCObj
   MODULE PROCEDURE cmfe_Solver_LabelGetVSNumber0
   MODULE PROCEDURE cmfe_Solver_LabelGetVSNumber1
   MODULE PROCEDURE cmfe_Solver_LabelGetVSObj
 END INTERFACE cmfe_Solver_LabelGet

 !>Sets/changes the label of a control loop.
 INTERFACE cmfe_Solver_LabelSet
   MODULE PROCEDURE cmfe_Solver_LabelSetCNumber0
   MODULE PROCEDURE cmfe_Solver_LabelSetCNumber1
   MODULE PROCEDURE cmfe_Solver_LabelSetCObj
   MODULE PROCEDURE cmfe_Solver_LabelSetVSNumber0
   MODULE PROCEDURE cmfe_Solver_LabelSetVSNumber1
   MODULE PROCEDURE cmfe_Solver_LabelSetVSObj
 END INTERFACE cmfe_Solver_LabelSet

 !>Returns the type of library to use for the solver.
 INTERFACE cmfe_Solver_LibraryTypeGet
   MODULE PROCEDURE cmfe_Solver_LibraryTypeGetNumber0
   MODULE PROCEDURE cmfe_Solver_LibraryTypeGetNumber1
   MODULE PROCEDURE cmfe_Solver_LibraryTypeGetObj
 END INTERFACE cmfe_Solver_LibraryTypeGet

 !>Sets/changes the type of library to use for the solver.
 INTERFACE cmfe_Solver_LibraryTypeSet
   MODULE PROCEDURE cmfe_Solver_LibraryTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_LibraryTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_LibraryTypeSetObj
 END INTERFACE cmfe_Solver_LibraryTypeSet

 !>Sets/changes the type of direct linear solver.
 INTERFACE cmfe_Solver_LinearDirectTypeSet
   MODULE PROCEDURE cmfe_Solver_LinearDirectTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_LinearDirectTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_LinearDirectTypeSetObj
 END INTERFACE cmfe_Solver_LinearDirectTypeSet

 !>Sets/changes the absolute tolerance for an iterative linear solver.
 INTERFACE cmfe_Solver_LinearIterativeAbsoluteToleranceSet
   MODULE PROCEDURE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0
   MODULE PROCEDURE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1
   MODULE PROCEDURE cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj
 END INTERFACE cmfe_Solver_LinearIterativeAbsoluteToleranceSet

 !>Sets/changes the divergence tolerance for an iterative linear solver.
 INTERFACE cmfe_Solver_LinearIterativeDivergenceToleranceSet
   MODULE PROCEDURE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0
   MODULE PROCEDURE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1
   MODULE PROCEDURE cmfe_Solver_LinearIterativeDivergenceToleranceSetObj
 END INTERFACE cmfe_Solver_LinearIterativeDivergenceToleranceSet

 !>Sets/changes the GMRES restart value for a GMRES iterative linear solver.
 INTERFACE cmfe_Solver_LinearIterativeGMRESRestartSet
   MODULE PROCEDURE cmfe_Solver_LinearIterativeGMRESRestartSetNumber0
   MODULE PROCEDURE cmfe_Solver_LinearIterativeGMRESRestartSetNumber1
   MODULE PROCEDURE cmfe_Solver_LinearIterativeGMRESRestartSetObj
 END INTERFACE cmfe_Solver_LinearIterativeGMRESRestartSet

 !>Sets/changes the maximum number of iterations for an iterative linear solver.
 INTERFACE cmfe_Solver_LinearIterativeMaximumIterationsSet
   MODULE PROCEDURE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0
   MODULE PROCEDURE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1
   MODULE PROCEDURE cmfe_Solver_LinearIterativeMaximumIterationsSetObj
 END INTERFACE cmfe_Solver_LinearIterativeMaximumIterationsSet

 !>Sets/changes the type of preconditioner for an iterative linear solver.
 INTERFACE cmfe_Solver_LinearIterativePreconditionerTypeSet
   MODULE PROCEDURE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_LinearIterativePreconditionerTypeSetObj
 END INTERFACE cmfe_Solver_LinearIterativePreconditionerTypeSet

 !>Sets/changes the relative tolerance for an iterative linear solver.
 INTERFACE cmfe_Solver_LinearIterativeRelativeToleranceSet
   MODULE PROCEDURE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0
   MODULE PROCEDURE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1
   MODULE PROCEDURE cmfe_Solver_LinearIterativeRelativeToleranceSetObj
 END INTERFACE cmfe_Solver_LinearIterativeRelativeToleranceSet

 !>Sets/changes the type of iterative linear solver.
 INTERFACE cmfe_Solver_LinearIterativeTypeSet
   MODULE PROCEDURE cmfe_Solver_LinearIterativeTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_LinearIterativeTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_LinearIterativeTypeSetObj
 END INTERFACE cmfe_Solver_LinearIterativeTypeSet

 !>Sets/changes the type of linear solver.
 INTERFACE cmfe_Solver_LinearTypeSet
   MODULE PROCEDURE cmfe_Solver_LinearTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_LinearTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_LinearTypeSetObj
 END INTERFACE cmfe_Solver_LinearTypeSet

 !>Sets/changes the absolute tolerance for a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonAbsoluteToleranceSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonAbsoluteToleranceSet

 !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver.
 INTERFACE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSet

 !>Sets/changes the Jacobian calculation type for a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSet

 !>Returns the linear solver associated with a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonLinearSolverGet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLinearSolverGetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLinearSolverGetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLinearSolverGetObj
 END INTERFACE cmfe_Solver_QuasiNewtonLinearSolverGet

 !>Returns the linear solver associated with a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonCellMLSolverGet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonCellMLSolverGetObj
 END INTERFACE cmfe_Solver_QuasiNewtonCellMLSolverGet

 !>Sets/change the convergence test for a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonConvergenceTestTypeSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonConvergenceTestTypeSet

 !>Sets/changes the line search maximum step for a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonLineSearchMaxStepSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonLineSearchMaxStepSet

 !>Sets/changes the line search step tolerance for a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonLineSearchStepTolSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonLineSearchStepTolSet

 !>Sets/changes the type of line search for a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonLineSearchTypeSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchTypeSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonLineSearchTypeSet

 !>Sets/changes the maximum number of function evaluations for a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSet

 !>Sets/changes the maximum number of iterations for a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonMaximumIterationsSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumIterationsSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonMaximumIterationsSet

 !>Sets/changes the relative tolerance for a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonRelativeToleranceSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonRelativeToleranceSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonRelativeToleranceSet

 !>Sets/changes the solution tolerance for a nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonSolutionToleranceSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolutionToleranceSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonSolutionToleranceSet

 !>Sets/changes the trust region delta0 tolerance for a nonlinear Quasi-Newton trust region solver.
 INTERFACE cmfe_Solver_QuasiNewtonTrustRegionDelta0Set
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj
 END INTERFACE cmfe_Solver_QuasiNewtonTrustRegionDelta0Set

 !>Sets/changes the trust region tolerance for a nonlinear Quasi-Newton trust region solver.
 INTERFACE cmfe_Solver_QuasiNewtonTrustRegionToleranceSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonTrustRegionToleranceSet

 !>Sets/changes the nonlinear Quasi-Newton restart.
 INTERFACE cmfe_Solver_QuasiNewtonRestartSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonRestartSet

 !>Sets/changes the nonlinear Quasi-Newton restart type.
 INTERFACE cmfe_Solver_QuasiNewtonRestartTypeSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartTypeSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonRestartTypeSet

 !>Sets/changes the nonlinear Quasi-Newton scale type.
 INTERFACE cmfe_Solver_QuasiNewtonScaleTypeSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonScaleTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonScaleTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonScaleTypeSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonScaleTypeSet

 !>Sets/changes the type of nonlinear Quasi-Newton solver.
 INTERFACE cmfe_Solver_QuasiNewtonSolveTypeSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolveTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolveTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolveTypeSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonSolveTypeSet

 !>Sets/changes the nonlinear Quasi-Newton type.
 INTERFACE cmfe_Solver_QuasiNewtonTypeSet
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_QuasiNewtonTypeSetObj
 END INTERFACE cmfe_Solver_QuasiNewtonTypeSet

 !>Sets/changes the absolute tolerance for a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonAbsoluteToleranceSet
   MODULE PROCEDURE cmfe_Solver_NewtonAbsoluteToleranceSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonAbsoluteToleranceSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonAbsoluteToleranceSetObj
 END INTERFACE cmfe_Solver_NewtonAbsoluteToleranceSet

 !>Enables/disables output monitoring for a nonlinear Newton line search solver.
 INTERFACE cmfe_Solver_NewtonLineSearchMonitorOutputSet
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMonitorOutputSetObj
 END INTERFACE cmfe_Solver_NewtonLineSearchMonitorOutputSet

 !>Sets/changes the Jacobian calculation type for a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonJacobianCalculationTypeSet
   MODULE PROCEDURE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonJacobianCalculationTypeSetObj
 END INTERFACE cmfe_Solver_NewtonJacobianCalculationTypeSet

 !>Returns the linear solver associated with a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonLinearSolverGet
   MODULE PROCEDURE cmfe_Solver_NewtonLinearSolverGetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonLinearSolverGetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonLinearSolverGetObj
 END INTERFACE cmfe_Solver_NewtonLinearSolverGet

 !>Returns the linear solver associated with a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonCellMLSolverGet
   MODULE PROCEDURE cmfe_Solver_NewtonCellMLSolverGetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonCellMLSolverGetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonCellMLSolverGetObj
 END INTERFACE cmfe_Solver_NewtonCellMLSolverGet

 !>Sets/change the convergence test for a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonConvergenceTestTypeSet
   MODULE PROCEDURE cmfe_Solver_NewtonConvergenceTestTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonConvergenceTestTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonConvergenceTestTypeSetObj
 END INTERFACE cmfe_Solver_NewtonConvergenceTestTypeSet

 !>Sets/changes the line search alpha for a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonLineSearchAlphaSet
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchAlphaSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchAlphaSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchAlphaSetObj
 END INTERFACE cmfe_Solver_NewtonLineSearchAlphaSet

 !>Sets/changes the line search maximum step for a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonLineSearchMaxStepSet
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMaxStepSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMaxStepSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMaxStepSetObj
 END INTERFACE cmfe_Solver_NewtonLineSearchMaxStepSet

 !>Sets/changes the line search step tolerance for a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonLineSearchStepTolSet
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchStepTolSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchStepTolSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchStepTolSetObj
 END INTERFACE cmfe_Solver_NewtonLineSearchStepTolSet

 !>Sets/changes the type of line search for a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonLineSearchTypeSet
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonLineSearchTypeSetObj
 END INTERFACE cmfe_Solver_NewtonLineSearchTypeSet

 !>Sets/changes the maximum number of function evaluations for a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonMaximumFunctionEvaluationsSet
   MODULE PROCEDURE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj
 END INTERFACE cmfe_Solver_NewtonMaximumFunctionEvaluationsSet

 !>Sets/changes the maximum number of iterations for a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonMaximumIterationsSet
   MODULE PROCEDURE cmfe_Solver_NewtonMaximumIterationsSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonMaximumIterationsSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonMaximumIterationsSetObj
 END INTERFACE cmfe_Solver_NewtonMaximumIterationsSet

 !>Sets/changes the relative tolerance for a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonRelativeToleranceSet
   MODULE PROCEDURE cmfe_Solver_NewtonRelativeToleranceSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonRelativeToleranceSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonRelativeToleranceSetObj
 END INTERFACE cmfe_Solver_NewtonRelativeToleranceSet

 !>Sets/changes the solution tolerance for a nonlinear Newton solver.
 INTERFACE cmfe_Solver_NewtonSolutionToleranceSet
   MODULE PROCEDURE cmfe_Solver_NewtonSolutionToleranceSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonSolutionToleranceSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonSolutionToleranceSetObj
 END INTERFACE cmfe_Solver_NewtonSolutionToleranceSet

 !>Sets/changes the trust region delta0 tolerance for a nonlinear Newton trust region solver.
 INTERFACE cmfe_Solver_NewtonTrustRegionDelta0Set
   MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionDelta0SetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionDelta0SetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionDelta0SetObj
 END INTERFACE cmfe_Solver_NewtonTrustRegionDelta0Set

 !>Sets/changes the trust region tolerance for a nonlinear Newton trust region solver.
 INTERFACE cmfe_Solver_NewtonTrustRegionToleranceSet
   MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionToleranceSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionToleranceSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionToleranceSetObj
 END INTERFACE cmfe_Solver_NewtonTrustRegionToleranceSet

 !>Sets/changes the type of nonlinear Newton trust region solver.
 INTERFACE cmfe_Solver_NewtonTypeSet
   MODULE PROCEDURE cmfe_Solver_NewtonTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_NewtonTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_NewtonTypeSetObj
 END INTERFACE cmfe_Solver_NewtonTypeSet

 !>Sets/changes the type of nonlinear solver.
 INTERFACE cmfe_Solver_NonlinearTypeSet
   MODULE PROCEDURE cmfe_Solver_NonlinearTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_NonlinearTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_NonlinearTypeSetObj
 END INTERFACE cmfe_Solver_NonlinearTypeSet

 !>Sets/changes the output type for a solver.
 INTERFACE cmfe_Solver_OutputTypeSet
   MODULE PROCEDURE cmfe_Solver_OutputTypeSetNumber0
   MODULE PROCEDURE cmfe_Solver_OutputTypeSetNumber1
   MODULE PROCEDURE cmfe_Solver_OutputTypeSetObj
 END INTERFACE cmfe_Solver_OutputTypeSet

 !>Returns the solver equations for a solver.
 INTERFACE cmfe_Solver_SolverEquationsGet
   MODULE PROCEDURE cmfe_Solver_SolverEquationsGetNumber0
   MODULE PROCEDURE cmfe_Solver_SolverEquationsGetNumber1
   MODULE PROCEDURE cmfe_Solver_SolverEquationsGetObj
 END INTERFACE cmfe_Solver_SolverEquationsGet

 !>Adds equations sets to solver equations.
 INTERFACE cmfe_SolverEquations_EquationsSetAdd
   MODULE PROCEDURE cmfe_SolverEquations_EquationsSetAddNumber0
   MODULE PROCEDURE cmfe_SolverEquations_EquationsSetAddNumber1
   MODULE PROCEDURE cmfe_SolverEquations_EquationsSetAddObj
 END INTERFACE cmfe_SolverEquations_EquationsSetAdd

 !>Adds an interface condition to solver equations.
 INTERFACE cmfe_SolverEquations_InterfaceConditionAdd
   MODULE PROCEDURE cmfe_SolverEquations_InterfaceConditionAddNumber0
   MODULE PROCEDURE cmfe_SolverEquations_InterfaceConditionAddNumber1
   MODULE PROCEDURE cmfe_SolverEquations_InterfaceConditionAddObj
 END INTERFACE cmfe_SolverEquations_InterfaceConditionAdd

 !>Gets the sparsity type for solver equations.
 INTERFACE cmfe_SolverEquations_SparsityTypeGet
   MODULE PROCEDURE cmfe_SolverEquations_SparsityTypeGetNumber0
   MODULE PROCEDURE cmfe_SolverEquations_SparsityTypeGetNumber1
   MODULE PROCEDURE cmfe_SolverEquations_SparsityTypeGetObj
 END INTERFACE cmfe_SolverEquations_SparsityTypeGet

 !>Sets/changes the sparsity type for solver equations.
 INTERFACE cmfe_SolverEquations_SparsityTypeSet
   MODULE PROCEDURE cmfe_SolverEquations_SparsityTypeSetNumber0
   MODULE PROCEDURE cmfe_SolverEquations_SparsityTypeSetNumber1
   MODULE PROCEDURE cmfe_SolverEquations_SparsityTypeSetObj
 END INTERFACE cmfe_SolverEquations_SparsityTypeSet

 !>Gets the symmetry type for solver equations.
 INTERFACE cmfe_SolverEquations_SymmetryTypeGet
   MODULE PROCEDURE cmfe_SolverEquations_SymmetryTypeGetNumber0
   MODULE PROCEDURE cmfe_SolverEquations_SymmetryTypeGetNumber1
   MODULE PROCEDURE cmfe_SolverEquations_SymmetryTypeGetObj
 END INTERFACE cmfe_SolverEquations_SymmetryTypeGet

 !>Sets/changes the symmetry type for solver equations.
 INTERFACE cmfe_SolverEquations_SymmetryTypeSet
   MODULE PROCEDURE cmfe_SolverEquations_SymmetryTypeSetNumber0
   MODULE PROCEDURE cmfe_SolverEquations_SymmetryTypeSetNumber1
   MODULE PROCEDURE cmfe_SolverEquations_SymmetryTypeSetObj
 END INTERFACE cmfe_SolverEquations_SymmetryTypeSet

 !>Finish the creation of boundary conditions for solver equations. \see OpenCMISS::Iron::cmfe_SolverEquations_BoundaryConditionsCreateStart
 INTERFACE cmfe_SolverEquations_BoundaryConditionsCreateFinish
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateFinishObj
 END INTERFACE cmfe_SolverEquations_BoundaryConditionsCreateFinish

 !>Start the creation of boundary conditions for solver equations. \see OpenCMISS::Iron::cmfe_SolverEquations_BoundaryConditionsCreateFinish
 INTERFACE cmfe_SolverEquations_BoundaryConditionsCreateStart
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateStartObj
 END INTERFACE cmfe_SolverEquations_BoundaryConditionsCreateStart

 !>Get the boundary conditions for solver equations. \see OpenCMISS::Iron::cmfe_SolverEquations_BoundaryConditionsCreateFinish
 INTERFACE cmfe_SolverEquations_BoundaryConditionsGet
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsGetNumber0
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsGetNumber1
   MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsGetObj
 END INTERFACE cmfe_SolverEquations_BoundaryConditionsGet

 PUBLIC CMFE_CELLML_EQUATIONS_LINEAR,CMFE_CELLML_EQUATIONS_NONLINEAR

 PUBLIC CMFE_CELLML_EQUATIONS_STATIC,CMFE_CELLML_EQUATIONS_QUASISTATIC,CMFE_CELLML_EQUATIONS_DYNAMIC

 PUBLIC CMFE_SOLVER_LINEAR_TYPE,CMFE_SOLVER_NONLINEAR_TYPE,CMFE_SOLVER_DYNAMIC_TYPE,CMFE_SOLVER_DAE_TYPE, &
   & CMFE_SOLVER_EIGENPROBLEM_TYPE, &
   & CMFE_SOLVER_OPTIMISER_TYPE

 PUBLIC CMFE_SOLVER_CMISS_LIBRARY,CMFE_SOLVER_PETSC_LIBRARY,CMFE_SOLVER_MUMPS_LIBRARY,CMFE_SOLVER_SUPERLU_LIBRARY, &
   & CMFE_SOLVER_SPOOLES_LIBRARY,CMFE_SOLVER_UMFPACK_LIBRARY,CMFE_SOLVER_LUSOL_LIBRARY,CMFE_SOLVER_ESSL_LIBRARY, &
   & CMFE_SOLVER_LAPACK_LIBRARY,CMFE_SOLVER_HYPRE_LIBRARY,CMFE_SOLVER_PASTIX_LIBRARY

 PUBLIC CMFE_SOLVER_LINEAR_DIRECT_SOLVE_TYPE,CMFE_SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE

 PUBLIC CMFE_SOLVER_DIRECT_LU,CMFE_SOLVER_DIRECT_CHOLESKY,CMFE_SOLVER_DIRECT_SVD

  PUBLIC CMFE_SOLVER_ITERATIVE_RICHARDSON,CMFE_SOLVER_ITERATIVE_CONJUGATE_GRADIENT,CMFE_SOLVER_ITERATIVE_CHEBYSHEV, &
   & CMFE_SOLVER_ITERATIVE_BICONJUGATE_GRADIENT,CMFE_SOLVER_ITERATIVE_GMRES,CMFE_SOLVER_ITERATIVE_BiCGSTAB, &
   & CMFE_SOLVER_ITERATIVE_CONJGRAD_SQUARED

 PUBLIC CMFE_SOLVER_ITERATIVE_NO_PRECONDITIONER,CMFE_SOLVER_ITERATIVE_JACOBI_PRECONDITIONER, &
   & CMFE_SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER,CMFE_SOLVER_ITERATIVE_SOR_PRECONDITIONER, &
   & CMFE_SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER,CMFE_SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER, &
   & CMFE_SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER

 PUBLIC CMFE_SOLVER_NONLINEAR_NEWTON,CMFE_SOLVER_NONLINEAR_BFGS_INVERSE,CMFE_SOLVER_NONLINEAR_SQP

 PUBLIC CMFE_SOLVER_NONLINEAR_QUASI_NEWTON

 PUBLIC CMFE_SOLVER_QUASI_NEWTON_LINESEARCH,CMFE_SOLVER_QUASI_NEWTON_TRUSTREGION

 PUBLIC CMFE_SOLVER_QUASI_NEWTON_LBFGS,CMFE_SOLVER_QUASI_NEWTON_GOODBROYDEN,CMFE_SOLVER_QUASI_NEWTON_BADBROYDEN

 PUBLIC CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_BASIC,CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_L2, &
   & CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_CP

 PUBLIC CMFE_SOLVER_QUASI_NEWTON_RESTART_NONE,CMFE_SOLVER_QUASI_NEWTON_RESTART_POWELL, &
   & CMFE_SOLVER_QUASI_NEWTON_RESTART_PERIODIC

 PUBLIC CMFE_SOLVER_QUASI_NEWTON_SCALE_NONE,CMFE_SOLVER_QUASI_NEWTON_SCALE_SHANNO, &
   & CMFE_SOLVER_QUASI_NEWTON_SCALE_LINESEARCH,CMFE_SOLVER_QUASI_NEWTON_SCALE_JACOBIAN

 PUBLIC CMFE_SOLVER_NEWTON_LINESEARCH,CMFE_SOLVER_NEWTON_TRUSTREGION

 PUBLIC CMFE_SOLVER_NEWTON_LINESEARCH_LINEAR,CMFE_SOLVER_NEWTON_LINESEARCH_QUADRATIC,CMFE_SOLVER_NEWTON_LINESEARCH_CUBIC

 PUBLIC CMFE_SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED,CMFE_SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED, &
   & CMFE_SOLVER_NEWTON_JACOBIAN_FD_CALCULATED

 PUBLIC CMFE_SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT,CMFE_SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM, &
   & CMFE_SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO

 PUBLIC CMFE_SOLVER_DYNAMIC_FIRST_ORDER,CMFE_SOLVER_DYNAMIC_SECOND_ORDER

 PUBLIC CMFE_SOLVER_DYNAMIC_LINEAR,CMFE_SOLVER_DYNAMIC_NONLINEAR

 PUBLIC CMFE_SOLVER_DYNAMIC_FIRST_DEGREE,CMFE_SOLVER_DYNAMIC_SECOND_DEGREE,CMFE_SOLVER_DYNAMIC_THIRD_DEGREE

 PUBLIC CMFE_SOLVER_DYNAMIC_EULER_SCHEME,CMFE_SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME,CMFE_SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME, &
   & CMFE_SOLVER_DYNAMIC_GALERKIN_SCHEME,CMFE_SOLVER_DYNAMIC_ZLAMAL_SCHEME,CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME, &
   & CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME,CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME, &
   & CMFE_SOLVER_DYNAMIC_NEWMARK1_SCHEME,CMFE_SOLVER_DYNAMIC_NEWMARK2_SCHEME,CMFE_SOLVER_DYNAMIC_NEWMARK3_SCHEME, &
   & CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME,CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME, &
   & CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME,CMFE_SOLVER_DYNAMIC_HOUBOLT_SCHEME,CMFE_SOLVER_DYNAMIC_WILSON_SCHEME, &
   & CMFE_SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME,CMFE_SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME, &
   & CMFE_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME, &
   & CMFE_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME,CMFE_SOLVER_DYNAMIC_USER_DEFINED_SCHEME

 PUBLIC CMFE_SOLVER_DAE_DIFFERENTIAL_ONLY,CMFE_SOLVER_DAE_INDEX_1,CMFE_SOLVER_DAE_INDEX_2,CMFE_SOLVER_DAE_INDEX_3

 PUBLIC CMFE_SOLVER_DAE_EULER,CMFE_SOLVER_DAE_CRANK_NICOLSON,CMFE_SOLVER_DAE_RUNGE_KUTTA,CMFE_SOLVER_DAE_ADAMS_MOULTON, &
   & CMFE_SOLVER_DAE_BDF, &
   & CMFE_SOLVER_DAE_RUSH_LARSON,CMFE_SOLVER_DAE_EXTERNAL

 PUBLIC CMFE_SOLVER_DAE_EULER_FORWARD,CMFE_SOLVER_DAE_EULER_BACKWARD,CMFE_SOLVER_DAE_EULER_IMPROVED

 PUBLIC CMFE_SOLVER_SOLUTION_INITIALISE_ZERO,CMFE_SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD, &
   & CMFE_SOLVER_SOLUTION_INITIALISE_NO_CHANGE

 PUBLIC CMFE_SOLVER_NO_OUTPUT,CMFE_SOLVER_MONITOR_OUTPUT,CMFE_SOLVER_PROGRESS_OUTPUT,CMFE_SOLVER_TIMING_OUTPUT, &
   & CMFE_SOLVER_SOLVER_OUTPUT,CMFE_SOLVER_MATRIX_OUTPUT

 PUBLIC CMFE_SOLVER_SPARSE_MATRICES,CMFE_SOLVER_FULL_MATRICES

 PUBLIC CMFE_SOLVER_SYMMETRIC_MATRICES,CMFE_SOLVER_UNSYMMETRIC_MATRICES

 PUBLIC cmfe_Solver_CellMLEquationsGet

 PUBLIC cmfe_CellMLEquations_CellMLAdd

 PUBLIC cmfe_CellMLEquations_LinearityTypeGet,cmfe_CellMLEquations_LinearityTypeSet

 PUBLIC cmfe_CellMLEquations_TimeDependenceTypeGet,cmfe_CellMLEquations_TimeDependenceTypeSet

 PUBLIC cmfe_Solver_DAEEulerSolverTypeGet,cmfe_Solver_DAEEulerSolverTypeSet

 PUBLIC cmfe_Solver_DAESolverTypeGet,cmfe_Solver_DAESolverTypeSet

 PUBLIC cmfe_Solver_DAETimesSet,cmfe_Solver_DAETimeStepSet

 PUBLIC cmfe_Solver_DynamicDegreeGet,cmfe_Solver_DynamicDegreeSet

 PUBLIC cmfe_Solver_DynamicLinearityTypeGet

 PUBLIC cmfe_Solver_DynamicLinearSolverGet,cmfe_Solver_DynamicNonlinearSolverGet

 PUBLIC cmfe_Solver_DynamicSchemeSet

 PUBLIC cmfe_Solver_DynamicThetaSet

 PUBLIC cmfe_Solver_DynamicTimesSet

 PUBLIC cmfe_Solver_GeometricTransformationArbitraryPathSet,cmfe_Solver_GeometricTransformationClear

 PUBLIC cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSet

 PUBLIC cmfe_Solver_GeometricTransformationScalingsSet

 PUBLIC cmfe_Solver_GeometricTransformationFieldSet

 PUBLIC cmfe_Solver_GeometricTransformationMatrixSet

 PUBLIC cmfe_Solver_GeometricTransformationRotationSet,cmfe_Solver_GeometricTransformationTranslationSet

 PUBLIC cmfe_Solver_LabelGet,cmfe_Solver_LabelSet

 PUBLIC cmfe_Solver_LibraryTypeGet,cmfe_Solver_LibraryTypeSet

 PUBLIC cmfe_Solver_LinearDirectTypeSet

 PUBLIC cmfe_Solver_MumpsSetIcntl,cmfe_Solver_MumpsSetCntl

 PUBLIC cmfe_Solver_LinearIterativeAbsoluteToleranceSet

 PUBLIC cmfe_Solver_LinearIterativeDivergenceToleranceSet

 PUBLIC cmfe_Solver_LinearIterativeGMRESRestartSet

 PUBLIC cmfe_Solver_LinearIterativeMaximumIterationsSet

 PUBLIC cmfe_Solver_LinearIterativePreconditionerTypeSet

 PUBLIC cmfe_Solver_LinearIterativeRelativeToleranceSet

 PUBLIC cmfe_Solver_LinearIterativeTypeSet

 PUBLIC cmfe_Solver_LinearTypeSet

 PUBLIC cmfe_Solver_NewtonAbsoluteToleranceSet

 PUBLIC cmfe_Solver_NewtonLineSearchMonitorOutputSet

 PUBLIC cmfe_Solver_NewtonJacobianCalculationTypeSet

 PUBLIC cmfe_Solver_NewtonLinearSolverGet

 PUBLIC cmfe_Solver_NewtonCellMLSolverGet

 PUBLIC cmfe_Solver_NewtonConvergenceTestTypeSet

 PUBLIC cmfe_Solver_NewtonLineSearchAlphaSet

 PUBLIC cmfe_Solver_NewtonLineSearchMaxStepSet

 PUBLIC cmfe_Solver_NewtonLineSearchStepTolSet

 PUBLIC cmfe_Solver_NewtonLineSearchTypeSet

 PUBLIC cmfe_Solver_NewtonMaximumFunctionEvaluationsSet

 PUBLIC cmfe_Solver_NewtonMaximumIterationsSet

 PUBLIC cmfe_Solver_NewtonRelativeToleranceSet

 PUBLIC cmfe_Solver_NewtonSolutionToleranceSet

 PUBLIC cmfe_Solver_NewtonTrustRegionDelta0Set

 PUBLIC cmfe_Solver_NewtonTrustRegionToleranceSet

 PUBLIC cmfe_Solver_NewtonTypeSet

 PUBLIC cmfe_Solver_QuasiNewtonAbsoluteToleranceSet

 PUBLIC cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSet

 PUBLIC cmfe_Solver_QuasiNewtonJacobianCalculationTypeSet

 PUBLIC cmfe_Solver_QuasiNewtonLinearSolverGet

 PUBLIC cmfe_Solver_QuasiNewtonCellMLSolverGet

 PUBLIC cmfe_Solver_QuasiNewtonConvergenceTestTypeSet

 PUBLIC cmfe_Solver_QuasiNewtonLineSearchMaxStepSet

 PUBLIC cmfe_Solver_QuasiNewtonLineSearchStepTolSet

 PUBLIC cmfe_Solver_QuasiNewtonLineSearchTypeSet

 PUBLIC cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSet

 PUBLIC cmfe_Solver_QuasiNewtonMaximumIterationsSet

 PUBLIC cmfe_Solver_QuasiNewtonRelativeToleranceSet

 PUBLIC cmfe_Solver_QuasiNewtonSolutionToleranceSet

 PUBLIC cmfe_Solver_QuasiNewtonTrustRegionDelta0Set

 PUBLIC cmfe_Solver_QuasiNewtonTrustRegionToleranceSet

 PUBLIC cmfe_Solver_QuasiNewtonRestartSet

 PUBLIC cmfe_Solver_QuasiNewtonRestartTypeSet

 PUBLIC cmfe_Solver_QuasiNewtonScaleTypeSet

 PUBLIC cmfe_Solver_QuasiNewtonSolveTypeSet

 PUBLIC cmfe_Solver_QuasiNewtonTypeSet

 PUBLIC cmfe_Solver_NonlinearTypeSet

 PUBLIC cmfe_Solver_OutputTypeSet

 PUBLIC cmfe_Solver_SolverEquationsGet

 PUBLIC cmfe_SolverEquations_BoundaryConditionsCreateFinish,cmfe_SolverEquations_BoundaryConditionsCreateStart

 PUBLIC cmfe_SolverEquations_BoundaryConditionsGet

 PUBLIC cmfe_SolverEquations_EquationsSetAdd

 PUBLIC cmfe_SolverEquations_InterfaceConditionAdd

 PUBLIC cmfe_SolverEquations_JacobianMatrixGet

 PUBLIC cmfe_SolverEquations_MatrixGet

 PUBLIC cmfe_SolverEquations_NumberOfMatricesGet

 PUBLIC cmfe_SolverEquations_ResidualVectorGet

 PUBLIC cmfe_SolverEquations_RHSVectorGet

 PUBLIC cmfe_SolverEquations_SparsityTypeGet,cmfe_SolverEquations_SparsityTypeSet

 PUBLIC cmfe_SolverEquations_SymmetryTypeGet,cmfe_SolverEquations_SymmetryTypeSet

 PUBLIC cmfe_SolverEquations_VectorGet

 PUBLIC cmfe_BioelectricsFiniteElasticity_UpdateGeometricField

!==================================================================================================================================
!
! FieldML routines
!
!==================================================================================================================================

 !> Provides input and output of fields through the FieldML API
 TYPE cmfe_FieldMLIOType
   PRIVATE
#ifdef WITH_FIELDML
   TYPE(FIELDML_IO_TYPE), POINTER :: fieldmlInfo
#endif
 END TYPE cmfe_FieldMLIOType

 !> Creates a mesh component using the given FieldML evaluator.
 INTERFACE cmfe_FieldML_InputCreateMeshComponent
   MODULE PROCEDURE cmfe_FieldML_InputCreateMeshComponentObjVS
   MODULE PROCEDURE cmfe_FieldML_InputCreateMeshComponentNumberVS
   MODULE PROCEDURE cmfe_FieldML_InputCreateMeshComponentObjC
   MODULE PROCEDURE cmfe_FieldML_InputCreateMeshComponentNumberC
 END INTERFACE cmfe_FieldML_InputCreateMeshComponent

 !> Creates a field component using the given FieldML evaluator.
 INTERFACE cmfe_FieldML_InputFieldCreateStart
   MODULE PROCEDURE cmfe_FieldML_InputFieldCreateStartObjVS
   MODULE PROCEDURE cmfe_FieldML_InputFieldCreateStartNumberVS
   MODULE PROCEDURE cmfe_FieldML_InputFieldCreateStartObjC
   MODULE PROCEDURE cmfe_FieldML_InputFieldCreateStartNumberC
 END INTERFACE cmfe_FieldML_InputFieldCreateStart

 !> Updates the given field's dofs using the given parameter evaluator.
 INTERFACE cmfe_FieldML_InputFieldParametersUpdate
   MODULE PROCEDURE cmfe_FieldML_InputFieldParametersUpdateObjVS
   MODULE PROCEDURE cmfe_FieldML_InputFieldParametersUpdateNumberVS
   MODULE PROCEDURE cmfe_FieldML_InputFieldParametersUpdateObjC
   MODULE PROCEDURE cmfe_FieldML_InputFieldParametersUpdateNumberC
 END INTERFACE cmfe_FieldML_InputFieldParametersUpdate

 !> Creates a basis using the given FieldML evaluator.
 INTERFACE cmfe_FieldML_InputBasisCreateStart
   MODULE PROCEDURE cmfe_FieldML_InputBasisCreateStartObjVS
   MODULE PROCEDURE cmfe_FieldML_InputBasisCreateStartNumberVS
   MODULE PROCEDURE cmfe_FieldML_InputBasisCreateStartObjC
   MODULE PROCEDURE cmfe_FieldML_InputBasisCreateStartNumberC
 END INTERFACE cmfe_FieldML_InputBasisCreateStart

 !> Creates the region's nodes using the given FieldML evaluator.
 INTERFACE cmfe_FieldML_InputNodesCreateStart
   MODULE PROCEDURE cmfe_FieldML_InputNodesCreateStartObjVS
   MODULE PROCEDURE cmfe_FieldML_InputNodesCreateStartNumberVS
   MODULE PROCEDURE cmfe_FieldML_InputNodesCreateStartObjC
   MODULE PROCEDURE cmfe_FieldML_InputNodesCreateStartNumberC
 END INTERFACE cmfe_FieldML_InputNodesCreateStart

 !> Creates the region's coordinate system using the given FieldML evaluator.
 INTERFACE cmfe_FieldML_InputCoordinateSystemCreateStart
   MODULE PROCEDURE cmfe_FieldML_InputCoordinateSystemCreateStartObjVS
   MODULE PROCEDURE cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS
   MODULE PROCEDURE cmfe_FieldML_InputCoordinateSystemCreateStartObjC
   MODULE PROCEDURE cmfe_FieldML_InputCoordinateSystemCreateStartNumberC
 END INTERFACE cmfe_FieldML_InputCoordinateSystemCreateStart

 !> Creates a mesh using the given FieldML evaluator.
 INTERFACE cmfe_FieldML_InputMeshCreateStart
   MODULE PROCEDURE cmfe_FieldML_InputMeshCreateStartObjVS
   MODULE PROCEDURE cmfe_FieldML_InputMeshCreateStartNumberVS
   MODULE PROCEDURE cmfe_FieldML_InputMeshCreateStartObjC
   MODULE PROCEDURE cmfe_FieldML_InputMeshCreateStartNumberC
 END INTERFACE cmfe_FieldML_InputMeshCreateStart

 !> Initialise the given FieldML context using the given FieldML XML file.
 INTERFACE cmfe_FieldML_InputCreateFromFile
   MODULE PROCEDURE cmfe_FieldML_InputCreateFromFileVS
   MODULE PROCEDURE cmfe_FieldML_InputCreateFromFileC
 END INTERFACE cmfe_FieldML_InputCreateFromFile

 PUBLIC :: cmfe_FieldML_InputCreateFromFile,cmfe_FieldML_InputMeshCreateStart, &
   & cmfe_FieldML_InputCoordinateSystemCreateStart,cmfe_FieldML_InputCreateMeshComponent, &
   & cmfe_FieldML_InputFieldCreateStart,cmfe_FieldML_InputBasisCreateStart,cmfe_FieldML_InputNodesCreateStart, &
   & cmfe_FieldML_InputFieldParametersUpdate

 PUBLIC :: cmfe_FieldMLIO_Finalise,cmfe_FieldMLIO_Initialise,cmfe_FieldMLIO_GetSession

 !> Add the given field to the current FieldML context.
 INTERFACE cmfe_FieldML_OutputAddField
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldNoTypeObjVS
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldNoTypeNumberVS
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldWithTypeObjVS
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldWithTypeNumberVS
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldNoTypeObjC
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldNoTypeNumberC
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldWithTypeObjC
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldWithTypeNumberC
 END INTERFACE cmfe_FieldML_OutputAddField

 !> Initialise a new FieldML context.
 INTERFACE cmfe_FieldML_OutputCreate
   MODULE PROCEDURE cmfe_FieldML_OutputCreateObjVS
   MODULE PROCEDURE cmfe_FieldML_OutputCreateNumberVS
   MODULE PROCEDURE cmfe_FieldML_OutputCreateObjC
   MODULE PROCEDURE cmfe_FieldML_OutputCreateNumberC
 END INTERFACE cmfe_FieldML_OutputCreate

 !> Add the given field to the current FieldML context, using only the given components.
 INTERFACE cmfe_FieldML_OutputAddFieldComponents
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldComponentsObjVS
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldComponentsNumberVS
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldComponentsObjC
   MODULE PROCEDURE cmfe_FieldML_OutputAddFieldComponentsNumberC
 END INTERFACE cmfe_FieldML_OutputAddFieldComponents

 !> Write the current FieldML document to the given file.
 INTERFACE cmfe_FieldML_OutputWrite
   MODULE PROCEDURE cmfe_FieldML_OutputWriteVS
   MODULE PROCEDURE cmfe_FieldML_OutputWriteC
 END INTERFACE cmfe_FieldML_OutputWrite

 PUBLIC :: cmfe_FieldMLIOType

 PUBLIC :: cmfe_FieldML_OutputWrite,cmfe_FieldML_OutputAddField,cmfe_FieldML_OutputCreate, &
   & cmfe_FieldML_OutputAddFieldComponents, &
   & cmfe_FieldML_OutputAddImport

!==================================================================================================================================
!
! GENERAL_ROUTINES
!
!==================================================================================================================================

 !>Returns the user number of an object.
 INTERFACE cmfe_UserNumberGet
   MODULE PROCEDURE cmfe_Region_UserNumberGet
   MODULE PROCEDURE cmfe_Mesh_UserNumberGet
   MODULE PROCEDURE cmfe_Basis_UserNumberGet
 END INTERFACE cmfe_UserNumberGet

 PUBLIC cmfe_UserNumberGet


!==================================================================================================================================


CONTAINS

 !
 !================================================================================================================================
 !

 !>Finalises an OpenCMISS context specified by user number.
 SUBROUTINE cmfe_FinaliseNumber(contextUserNumber,err)
   !DLLEXPORT(cmfe_FinaliseNumber)

   !Argument variables
   INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to finalise.
   INTEGER(INTG), INTENT(OUT) :: err !<The error code.
   !Local variables
   TYPE(ContextType), POINTER :: context

   NULLIFY(context)
   CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
   CALL cmfe_Finalise_(context,err,error,*999)

   RETURN
999 CALL cmfe_HandleError(err,error)
   RETURN

 END SUBROUTINE cmfe_FinaliseNumber

 !
 !================================================================================================================================
 !

 !>Finalises an OpenCMISS context specified by an object.
 SUBROUTINE cmfe_FinaliseObj(context,err)
   !DLLEXPORT(cmfe_FinaliseObj)

   !Argument variables
   TYPE(cmfe_ContextType), INTENT(INOUT) :: context !<The context o finalise
   INTEGER(INTG), INTENT(OUT) :: err !<The error code.
   !Local variables

   CALL cmfe_Finalise_(context%context,err,error,*999)

   RETURN
999 CALL cmfe_HandleError(err,error)
   RETURN

 END SUBROUTINE cmfe_FinaliseObj

 !
 !================================================================================================================================
 !

 !>Initialises OpenCMISS context returning a user number new context.
 SUBROUTINE cmfe_InitialiseNumber(newContextUserNumber,err)
   !DLLEXPORT(cmfe_InitialiseNumber)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: newContextUserNumber !<On return, the context user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: newContext

    NULLIFY(newContext)
    CALL cmfe_Initialise_(newContext,err,error,*999)
    CALL Context_UserNumberGet(newContext,newContextUserNumber,err,error,*999)
 
    RETURN
999 CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InitialiseNumber

  !
  !================================================================================================================================
  !

  !>Initialises OpenCMISS returning a pointer to the new context.
  SUBROUTINE cmfe_InitialiseObj(newContext,err)
    !DLLEXPORT(cmfe_InitialiseObj)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(INOUT) :: newContext !<On return, the new context. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL cmfe_Initialise_(newContext%context,err,error,*999)

    RETURN
999 CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InitialiseObj

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_ContextType object.
  SUBROUTINE cmfe_Context_Finalise(cmfe_Context,err)
    !DLLEXPORT(cmfe_Context_Finalise)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(OUT) :: cmfe_Context !<The cmfe_ContextType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Context_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Context%context))  &
      & CALL Context_Destroy(cmfe_Context%context,err,error,*999)

    EXITS("cmfe_Context_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Context_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_ContextType object.
  SUBROUTINE cmfe_Context_Initialise(cmfe_Context,err)
    !DLLEXPORT(cmfe_Context_Initialise)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(OUT) :: cmfe_Context !<The cmfe_ContextType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Context_Initialise",err,error,*999)

    NULLIFY(cmfe_Context%context)

    EXITS("cmfe_Context_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Context_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_Initialise

  !
  !================================================================================================================================
  !

  !>Sets a PETSc option (so that they can be set from python when we don't have the command line.)
  SUBROUTINE cmfe_PetscOptionsSetValue(name,VALUE,err)
    !DLLEXPORT(cmfe_PetscOptionsSetValue)

    !Argument variables
    CHARACTER(LEN=*), INTENT(IN) :: name !<The name of the PETSc option
    CHARACTER(LEN=*), INTENT(IN) :: value !<The value of the PETSc option
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_PetscOptionsSetValue",err,error,*999)

    CALL Petsc_OptionsSetValue(name,VALUE,err,error,*999)

    EXITS("cmfe_PetscOptionsSetValue")
    RETURN
999 ERRORSEXITS("cmfe_PetscOptionsSetValue",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_PetscOptionsSetValue

  !
  !================================================================================================================================
  !

  !>Returns the working precision
  SUBROUTINE cmfe_WorkingRealPrecisionGet(workingRealPrecision,err)
    !DLLEXPORT(cmfe_WorkingRealPrecisionGet)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: workingRealPrecision !<On return, the working real precision
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_WorkingRealPrecisionGet",err,error,*999)

#ifdef SINGLE_REAL_PRECISION
    workingRealPrecision=CMFE_SINGLE_REAL_TYPE
#else
    workingRealPrecision=CMFE_DOUBLE_REAL_TYPE
#endif

    EXITS("cmfe_WorkingRealPrecisionGet")
    RETURN
999 ERRORSEXITS("cmfe_WorkingRealPrecisionGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkingRealPrecisionGet

  !
  !================================================================================================================================
  !

  !>Copy an array of cmfe_BasisTypes from C to an allocated Fortran array, for use by the C bindings
  SUBROUTINE cmfe_BasisTypesCopy(bases,basesSize,basesPtr,err)
    !DLLEXPORT(cmfe_BasisTypesCopy)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: bases(:) !<On return, the array of cmfe_BasisTypes
    INTEGER(C_INT), INTENT(IN) :: basesSize !<The length of the C array of pointers to cmfe_BasisTypes
    TYPE(C_PTR), INTENT(IN) :: basesPtr !<The pointer to the first cmfe_BasisType pointer
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: basis_idx
    TYPE(C_PTR), POINTER :: BasesCPtrs(:)
    TYPE(cmfe_BasisType), POINTER :: Basis

    ENTERS("cmfe_BasisTypesCopy",err,error,*999)

    IF(C_ASSOCIATED(basesPtr)) THEN
      CALL C_F_POINTER(basesPtr,BasesCPtrs,[basesSize])
      IF(ASSOCIATED(BasesCPtrs)) THEN
        DO basis_idx=1,basesSize
          CALL C_F_POINTER(BasesCPtrs(basis_idx),Basis)
          IF(ASSOCIATED(BasesCPtrs)) THEN
            bases(basis_idx)%basis => Basis%basis
          ELSE
            CALL FlagError("error converting C pointer.",ERR,error,*999)
          END IF
        END DO
      ELSE
        CALL FlagError("error converting C pointer.",ERR,error,*999)
      END IF
    ELSE
      CALL FlagError("bases C pointer is not associated.",ERR,error,*999)
    END IF

    EXITS("cmfe_BasisTypesCopy")
    RETURN
999 ERRORSEXITS("cmfe_BasisTypesCopy",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BasisTypesCopy

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_BasisType object.
  SUBROUTINE cmfe_Basis_Finalise(cmfe_Basis,err)
    !DLLEXPORT(cmfe_Basis_Finalise)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(OUT) :: cmfe_Basis !<The cmfe_BasisType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Basis%basis)) CALL Basis_Destroy(cmfe_Basis%basis,err,error,*999)

    EXITS("cmfe_Basis_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Basis_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_BasisType object.
  SUBROUTINE cmfe_Basis_Initialise(cmfe_Basis,err)
    !DLLEXPORT(cmfe_Basis_Initialise)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(OUT) :: cmfe_Basis !<The cmfe_BasisType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_Initialise",err,error,*999)

    NULLIFY(cmfe_Basis%basis)

    EXITS("cmfe_Basis_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Basis_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_BoundaryConditionsType object.
  SUBROUTINE cmfe_BoundaryConditions_Finalise(cmfe_BoundaryConditions,err)
    !DLLEXPORT(cmfe_BoundaryConditions_Finalise)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(OUT) :: cmfe_BoundaryConditions !<The cmfe_BoundaryConditionsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_BoundaryConditions%boundaryConditions))  &
      & CALL BoundaryConditions_Destroy(cmfe_BoundaryConditions%boundaryConditions,err,error,*999)

    EXITS("cmfe_BoundaryConditions_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_BoundaryConditionsType object.
  SUBROUTINE cmfe_BoundaryConditions_Initialise(cmfe_BoundaryConditions,err)
    !DLLEXPORT(cmfe_BoundaryConditions_Initialise)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(OUT) :: cmfe_BoundaryConditions !<The cmfe_BoundaryConditionsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_Initialise",err,error,*999)

    NULLIFY(cmfe_BoundaryConditions%boundaryConditions)

    EXITS("cmfe_BoundaryConditions_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_CellMLType object.
  SUBROUTINE cmfe_CellML_Finalise(cmfe_CellML,err)
    !DLLEXPORT(cmfe_CellML_Finalise)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(OUT) :: cmfe_CellML !<The cmfe_CellMLType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_CellML%cellml)) CALL Cellml_Destroy(cmfe_CellML%cellml,err,error,*999)

    EXITS("cmfe_CellML_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_CellML_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_CellMLType object.
  SUBROUTINE cmfe_CellML_Initialise(cmfe_CellML,err)
    !DLLEXPORT(cmfe_CellML_Initialise)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(OUT) :: cmfe_CellML !<The cmfe_CellMLType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_Initialise",err,error,*999)

    NULLIFY(cmfe_CellML%cellml)

    EXITS("cmfe_CellML_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_CellML_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_CellMLEquationsType object.
  SUBROUTINE cmfe_CellMLEquations_Finalise(cmfe_CellMLEquations,err)
    !DLLEXPORT(cmfe_CellMLEquations_Finalise)

    !Argument variables
    TYPE(cmfe_CellMLEquationsType), INTENT(OUT) :: cmfe_CellMLEquations !<The cmfe_CellMLEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellMLEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_CellMLEquations%cellmlEquations))  &
      & CALL CellMLEquations_Destroy(cmfe_CellMLEquations%cellmlEquations,err,error,*999)

    EXITS("cmfe_CellMLEquations_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_CellMLEquationsType object.
  SUBROUTINE cmfe_CellMLEquations_Initialise(cmfe_CellMLEquations,err)
    !DLLEXPORT(cmfe_CellMLEquations_Initialise)

    !Argument variables
    TYPE(cmfe_CellMLEquationsType), INTENT(OUT) :: cmfe_CellMLEquations !<The cmfe_CellMLEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellMLEquations_Initialise",err,error,*999)

    NULLIFY(cmfe_CellMLEquations%cellmlEquations)

    EXITS("cmfe_CellMLEquations_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_ComputationEnvironmentType object.
  SUBROUTINE cmfe_ComputationEnvironment_Finalise(cmfe_ComputationEnvironment,err)
    !DLLEXPORT(cmfe_ComputationEnvironment_Finalise)

    !Argument variables
    TYPE(cmfe_ComputationEnvironmentType), INTENT(OUT) :: cmfe_ComputationEnvironment !<The cmfe_ComputationEnvironmentType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ComputationEnvironment_Finalise",err,error,*999)

    NULLIFY(cmfe_ComputationEnvironment%computationEnvironment)

    EXITS("cmfe_ComputationEnvironment_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_ComputationEnvironment_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationEnvironment_Finalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_ComputationEnvironmentType object.
  SUBROUTINE cmfe_ComputationEnvironment_Initialise(cmfe_ComputationEnvironment,err)
    !DLLEXPORT(cmfe_ComputationEnvironment_Initialise)

    !Argument variables
    TYPE(cmfe_ComputationEnvironmentType), INTENT(OUT) :: cmfe_ComputationEnvironment !<The cmfe_ComputationEnvironmentType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ComputationEnvironment_Initialise",err,error,*999)

    NULLIFY(cmfe_ComputationEnvironment%computationEnvironment)

    EXITS("cmfe_ComputationEnvironment_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_ComputationEnvironment_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationEnvironment_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_ControlLoopType object.
  SUBROUTINE cmfe_ControlLoop_Finalise(cmfe_ControlLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_Finalise)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(OUT) :: cmfe_ControlLoop !<The cmfe_ControlLoopType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_ControlLoop%controlLoop))  &
      & CALL ControlLoop_Destroy(cmfe_ControlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_Finalise
  
  !  
  !================================================================================================================================
  !

  !>Initialises a cmfe_ControlLoopType object.
  SUBROUTINE cmfe_ControlLoop_Initialise(cmfe_ControlLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_Initialise)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(OUT) :: cmfe_ControlLoop !<The cmfe_ControlLoopType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_Initialise",err,error,*999)

    NULLIFY(cmfe_ControlLoop%controlLoop)

    EXITS("cmfe_ControlLoop_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_CoordinateSystemType object.
  SUBROUTINE cmfe_CoordinateSystem_Finalise(cmfe_CoordinateSystem,err)
    !DLLEXPORT(cmfe_CoordinateSystem_Finalise)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(OUT) :: cmfe_CoordinateSystem !<The cmfe_CoordinateSystemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_CoordinateSystem%coordinateSystem))  &
      & CALL CoordinateSystem_Destroy(cmfe_CoordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_CoordinateSystem_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_CoordinateSystemType object.
  SUBROUTINE cmfe_CoordinateSystem_Initialise(cmfe_CoordinateSystem,err)
    !DLLEXPORT(cmfe_CoordinateSystem_Initialise)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(OUT) :: cmfe_CoordinateSystem !<The cmfe_CoordinateSystemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_Initialise",err,error,*999)

    NULLIFY(cmfe_CoordinateSystem%coordinateSystem)

    EXITS("cmfe_CoordinateSystem_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_DataPointsType object.
  SUBROUTINE cmfe_DataPoints_Finalise(cmfe_DataPoints,err)
    !DLLEXPORT(cmfe_DataPoints_Finalise)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(OUT) :: cmfe_DataPoints !<The cmfe_DataPointsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_DataPoints%dataPoints))  &
      & CALL DataPoints_Destroy(cmfe_DataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_DataPointsType object.
  SUBROUTINE cmfe_DataPoints_Initialise(cmfe_DataPoints,err)
    !DLLEXPORT(cmfe_DataPoints_Initialise)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(OUT) :: cmfe_DataPoints !<The cmfe_DataPointsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_Initialise",err,error,*999)

    NULLIFY(cmfe_DataPoints%dataPoints)

    EXITS("cmfe_DataPoints_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_DataProjectionType object.
  SUBROUTINE cmfe_DataProjection_Finalise(cmfe_DataProjection,err)
    !DLLEXPORT(cmfe_DataProjection_Finalise)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(OUT) :: cmfe_DataProjection !<The cmfe_DataProjectionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_DataProjection%dataProjection))  &
      & CALL DataProjection_Destroy(cmfe_DataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_DataProjection_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_DataProjectionType object.
  SUBROUTINE cmfe_DataProjection_Initialise(cmfe_DataProjection,err)
    !DLLEXPORT(cmfe_DataProjection_Initialise)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(OUT) :: cmfe_DataProjection !<The cmfe_DataProjectionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_Initialise",err,error,*999)

    NULLIFY(cmfe_DataProjection%dataProjection)

    EXITS("cmfe_DataProjection_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_DecomposerType object.
  SUBROUTINE cmfe_Decomposer_Finalise(cmfe_Decomposer,err)
    !DLLEXPORT(cmfe_Decomposer_Finalise)

    !Argument variables
    TYPE(cmfe_DecomposerType), INTENT(OUT) :: cmfe_Decomposer !<The cmfe_DecomposerType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposer_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Decomposer%decomposer)) CALL Decomposer_Destroy(cmfe_Decomposer%decomposer,err,error,*999)

    EXITS("cmfe_Decomposer_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_DecomposerType object.
  SUBROUTINE cmfe_Decomposer_Initialise(cmfe_Decomposer,err)
    !DLLEXPORT(cmfe_Decomposer_Initialise)

    !Argument variables
    TYPE(cmfe_DecomposerType), INTENT(OUT) :: cmfe_Decomposer !<The cmfe_DecomposerType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposer_Initialise",err,error,*999)

    NULLIFY(cmfe_Decomposer%decomposer)

    EXITS("cmfe_Decomposer_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_DecompositionType object.
  SUBROUTINE cmfe_Decomposition_Finalise(cmfe_Decomposition,err)
    !DLLEXPORT(cmfe_Decomposition_Finalise)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(OUT) :: cmfe_Decomposition !<The cmfe_DecompositionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Decomposition%decomposition))  &
      & CALL DECOMPOSITION_DESTROY(cmfe_Decomposition%decomposition,err,error,*999)

    EXITS("cmfe_Decomposition_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_DecompositionType object.
  SUBROUTINE cmfe_Decomposition_Initialise(cmfe_Decomposition,err)
    !DLLEXPORT(cmfe_Decomposition_Initialise)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(OUT) :: cmfe_Decomposition !<The cmfe_DecompositionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_Initialise",err,error,*999)

    NULLIFY(cmfe_Decomposition%decomposition)

    EXITS("cmfe_Decomposition_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_Initialise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_DistributedMatrixType object.
  SUBROUTINE cmfe_DistributedMatrix_Initialise(cmfe_DistributedMatrix,err)
    !DLLEXPORT(cmfe_DistributedMatrix_Initialise)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(OUT) :: cmfe_DistributedMatrix !<The cmfe_DistributedMatrixType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DistributedMatrix_Initialise",err,error,*999)

    NULLIFY(cmfe_DistributedMatrix%distributedMatrix)

    EXITS("cmfe_DistributedMatrix_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_Initialise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_DistributedVectorType object.
  SUBROUTINE cmfe_DistributedVector_Initialise(cmfe_DistributedVector,err)
    !DLLEXPORT(cmfe_DistributedVector_Initialise)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(OUT) :: cmfe_DistributedVector !<The cmfe_DistributedVectorType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DistributedVector_Initialise",err,error,*999)

    NULLIFY(cmfe_DistributedVector%distributedVector)

    EXITS("cmfe_DistributedVector_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_EquationsType object.
  SUBROUTINE cmfe_Equations_Finalise(cmfe_Equations,err)
    !DLLEXPORT(cmfe_Equations_Finalise)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(OUT) :: cmfe_Equations !<The cmfe_EquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Equations%equations))  &
      & CALL Equations_Destroy(cmfe_Equations%equations,err,error,*999)

    EXITS("cmfe_Equations_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Equations_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_EquationsType object.
  SUBROUTINE cmfe_Equations_Initialise(cmfe_Equations,err)
    !DLLEXPORT(cmfe_Equations_Initialise)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(OUT) :: cmfe_Equations !<The cmfe_EquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_Initialise",err,error,*999)

    NULLIFY(cmfe_Equations%equations)

    EXITS("cmfe_Equations_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Equations_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_EquationsSetType object.
  SUBROUTINE cmfe_EquationsSet_Finalise(cmfe_EquationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_Finalise)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(OUT) :: cmfe_EquationsSet !<The cmfe_EquationsSetType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_EquationsSet%equationsSet))  &
      & CALL EquationsSet_Destroy(cmfe_EquationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_EquationsSetType object.
  SUBROUTINE cmfe_EquationsSet_Initialise(cmfe_EquationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_Initialise)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(OUT) :: cmfe_EquationsSet !<The cmfe_EquationsSetType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_Initialise",err,error,*999)

    NULLIFY(cmfe_EquationsSet%equationsSet)

    EXITS("cmfe_EquationsSet_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_FieldType object.
  SUBROUTINE cmfe_Field_Finalise(cmfe_Field,err)
    !DLLEXPORT(cmfe_Field_Finalise)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(OUT) :: cmfe_Field !<The cmfe_FieldType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Field%field)) CALL Field_Destroy(cmfe_Field%field,err,error,*999)

    EXITS("cmfe_Field_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Field_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_FieldType object.
  SUBROUTINE cmfe_Field_Initialise(cmfe_Field,err)
    !DLLEXPORT(cmfe_Field_Initialise)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(OUT) :: cmfe_Field !<The cmfe_FieldType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_Initialise",err,error,*999)

    NULLIFY(cmfe_Field%field)

    EXITS("cmfe_Field_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Field_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_Initialise

  !
  !================================================================================================================================
  !

  !>Creates a cmfe_FieldsType object for an inteface by an object reference.
  SUBROUTINE cmfe_Fields_CreateInterface(interface,fields,err)
    !DLLEXPORT(cmfe_Fields_CreateInterface)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to get the fields from
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<On return, the fields attached to the specified interface. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_CreateInterface",err,error,*999)

    IF(ASSOCIATED(interface%interface)) THEN
      IF(ASSOCIATED(fields%fields)) THEN
        CALL FlagError("Fields is already associated.",err,error,*999)
      ELSE
        fields%fields=>interface%interface%fields
      END IF
    ELSE
      CALL FlagError("The interface is not associated.",err,error,*999)
    END IF

    EXITS("cmfe_Fields_CreateInterface")
    RETURN
999 ERRORSEXITS("cmfe_Fields_CreateInterface",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_CreateInterface

  !
  !================================================================================================================================
  !

  !>Creates a cmfe_FieldsType object for a region by an object reference.
  SUBROUTINE cmfe_Fields_CreateRegion(region,fields,err)
    !DLLEXPORT(cmfe_Fields_CreateRegion)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the fields from
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<On return, the fields attached to the specified region. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_CreateRegion",err,error,*999)

    IF(ASSOCIATED(region%region)) THEN
      IF(ASSOCIATED(fields%fields)) THEN
        CALL FlagError("fields is already associated.",err,error,*999)
      ELSE
        fields%fields=>region%region%fields
      END IF
    ELSE
      CALL FlagError("The region is not associated.",err,error,*999)
    END IF

    EXITS("cmfe_Fields_CreateRegion")
    RETURN
999 ERRORSEXITS("cmfe_Fields_CreateRegion",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_CreateRegion

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_FieldsType object.
  SUBROUTINE cmfe_Fields_Finalise(cmfe_Fields,err)
    !DLLEXPORT(cmfe_Fields_Finalise)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(OUT) :: cmfe_Fields !<The cmfe_FieldsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_Finalise",err,error,*999)

    NULLIFY(cmfe_Fields%fields)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Fields Type')
#endif

    EXITS("cmfe_Fields_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Fields_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_FieldsType object.
  SUBROUTINE cmfe_Fields_Initialise(cmfe_Fields,err)
    !DLLEXPORT(cmfe_Fields_Initialise)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(OUT) :: cmfe_Fields !<The cmfe_FieldsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_Initialise",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Fields Type')
#endif

    NULLIFY(cmfe_Fields%fields)

    EXITS("cmfe_Fields_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Fields_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_GeneratedMeshType object.
  SUBROUTINE cmfe_GeneratedMesh_Finalise(cmfe_GeneratedMesh,err)
    !DLLEXPORT(cmfe_GeneratedMesh_Finalise)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(OUT) :: cmfe_GeneratedMesh !<The cmfe_GeneratedMeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_GeneratedMesh%generatedMesh))  &
      & CALL GeneratedMesh_Destroy(cmfe_GeneratedMesh%generatedMesh,err,error,*999)

    EXITS("cmfe_GeneratedMesh_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_GeneratedMeshType object.
  SUBROUTINE cmfe_GeneratedMesh_Initialise(cmfe_GeneratedMesh,err)
    !DLLEXPORT(cmfe_GeneratedMesh_Initialise)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(OUT) :: cmfe_GeneratedMesh !<The cmfe_GeneratedMeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_Initialise",err,error,*999)

    NULLIFY(cmfe_GeneratedMesh%generatedMesh)

    EXITS("cmfe_GeneratedMesh_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_InterfaceType object.
  SUBROUTINE cmfe_Interface_Finalise(cmfe_Interface,err)
    !DLLEXPORT(cmfe_Interface_Finalise)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(OUT) :: cmfe_Interface !<The cmfe_InterfaceType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Interface%interface))  &
      & CALL Interface_Destroy(cmfe_Interface%interface,err,error,*999)

    EXITS("cmfe_Interface_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Interface_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_InterfaceType object.
  SUBROUTINE cmfe_Interface_Initialise(cmfe_Interface,err)
    !DLLEXPORT(cmfe_Interface_Initialise)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(OUT) :: cmfe_Interface !<The cmfe_InterfaceType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_Initialise",err,error,*999)

    NULLIFY(cmfe_Interface%interface)

    EXITS("cmfe_Interface_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Interface_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_InterfaceConditionType object.
  SUBROUTINE cmfe_InterfaceCondition_Finalise(cmfe_InterfaceCondition,err)
    !DLLEXPORT(cmfe_InterfaceCondition_Finalise)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(OUT) :: cmfe_InterfaceCondition !<The cmfe_InterfaceConditionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_InterfaceCondition%interfaceCondition))  &
      & CALL InterfaceCondition_Destroy(cmfe_InterfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_InterfaceConditionType object.
  SUBROUTINE cmfe_InterfaceCondition_Initialise(cmfe_InterfaceCondition,err)
    !DLLEXPORT(cmfe_InterfaceCondition_Initialise)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(OUT) :: cmfe_InterfaceCondition !<The cmfe_InterfaceConditionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_Initialise",err,error,*999)

    NULLIFY(cmfe_InterfaceCondition%interfaceCondition)

    EXITS("cmfe_InterfaceCondition_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_Initialise

   !
  !================================================================================================================================
  !

  !>Finalises a cmfe_InterfaceEquationsType object.
  SUBROUTINE cmfe_InterfaceEquations_Finalise(cmfe_InterfaceEquations,err)
    !DLLEXPORT(cmfe_InterfaceEquations_Finalise)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(OUT) :: cmfe_InterfaceEquations !<The cmfe_InterfaceEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_InterfaceEquations%interfaceEquations))  &
      & CALL InterfaceEquations_Destroy(cmfe_InterfaceEquations%interfaceEquations,err,error,*999)

    EXITS("cmfe_InterfaceEquations_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_InterfaceEquationsType object.
  SUBROUTINE cmfe_InterfaceEquations_Initialise(cmfe_InterfaceEquations,err)
    !DLLEXPORT(cmfe_InterfaceEquations_Initialise)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(OUT) :: cmfe_InterfaceEquations !<The cmfe_InterfaceEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_Initialise",err,error,*999)

    NULLIFY(cmfe_InterfaceEquations%interfaceEquations)

    EXITS("cmfe_InterfaceEquations_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_Initialise

  !
  !================================================================================================================================
  !

  !>Finalise a cmfe_InterfaceMeshConnectivityType object.
  SUBROUTINE cmfe_InterfacePointsConnectivity_Finalise(cmfe_InterfacePointsConnectivity,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_Finalise)

    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(OUT) :: cmfe_InterfacePointsConnectivity !<The cmfe_InterfacePointsConnectivityType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfacePointsConnectivity_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_InterfacePointsConnectivity%pointsConnectivity)) &
      & CALL InterfacePointsConnectivity_DESTROY(cmfe_InterfacePointsConnectivity%pointsConnectivity,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_InterfacePointsConnectivity_Finalise",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_InterfaceMeshConnectivityType object.
  SUBROUTINE cmfe_InterfacePointsConnectivity_Initialise(cmfe_InterfacePointsConnectivity,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_Initialise)

    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(OUT) :: cmfe_InterfacePointsConnectivity !<The cmfe_InterfacePointsConnectivityType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfacePointsConnectivity_Initialise",err,error,*999)

    NULLIFY(cmfe_InterfacePointsConnectivity%pointsConnectivity)

    EXITS("cmfe_InterfacePointsConnectivity_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_InterfacePointsConnectivity_Initialise",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_Initialise

  !
  !================================================================================================================================
  !

   !>Finalises a cmfe_InterfaceMeshConnectivityType object.
   SUBROUTINE cmfe_InterfaceMeshConnectivity_Finalise(cmfe_InterfaceMeshConnectivity,err)
     !DLLEXPORT(cmfe_InterfaceMeshConnectivity_Finalise)

     !Argument variables
     TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(OUT) :: cmfe_InterfaceMeshConnectivity !<The cmfe_InterfaceMeshConnectivityType object to finalise.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
     !Local variables

     ENTERS("cmfe_InterfaceMeshConnectivity_Finalise",err,error,*999)

     IF(ASSOCIATED(cmfe_InterfaceMeshConnectivity%meshConnectivity)) &
       & CALL InterfaceMeshConnectivity_Destroy(cmfe_InterfaceMeshConnectivity%meshConnectivity,err,error,*999)

     EXITS("cmfe_InterfaceMeshConnectivity_Finalise")
     RETURN
 999 ERRORSEXITS("cmfe_InterfaceMeshConnectivity_Finalise",err,error)
     CALL cmfe_HandleError(err,error)
     RETURN

   END SUBROUTINE cmfe_InterfaceMeshConnectivity_Finalise

  !
  !================================================================================================================================
  !

   !>Initialises a cmfe_InterfaceMeshConnectivityType object.
   SUBROUTINE cmfe_InterfaceMeshConnectivity_Initialise(cmfe_InterfaceMeshConnectivity,err)
     !DLLEXPORT(cmfe_InterfaceMeshConnectivity_Initialise)

     !Argument variables
     TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(OUT) :: cmfe_InterfaceMeshConnectivity !<The cmfe_InterfaceMeshConnectivityType object to initialise.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
     !Local variables

     ENTERS("cmfe_InterfaceMeshConnectivity_Initialise",err,error,*999)

     NULLIFY(cmfe_InterfaceMeshConnectivity%meshConnectivity)

     EXITS("cmfe_InterfaceMeshConnectivity_Initialise")
     RETURN
 999 ERRORSEXITS("cmfe_InterfaceMeshConnectivity_Initialise",err,error)
     CALL cmfe_HandleError(err,error)
     RETURN

   END SUBROUTINE cmfe_InterfaceMeshConnectivity_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_HistoryType object.
  SUBROUTINE cmfe_History_Finalise(cmfe_History,err)
    !DLLEXPORT(cmfe_History_Finalise)

    !Argument variables
    TYPE(cmfe_HistoryType), INTENT(OUT) :: cmfe_History !<The cmfe_HistoryType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_History_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_History%history))  &
      & CALL History_Destroy(cmfe_History%history,err,error,*999)

    EXITS("cmfe_History_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_History_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_History_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_HistoryType object.
  SUBROUTINE cmfe_History_Initialise(cmfe_History,err)
    !DLLEXPORT(cmfe_History_Initialise)

    !Argument variables
    TYPE(cmfe_HistoryType), INTENT(OUT) :: cmfe_History !<The cmfe_HistoryType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_History_Initialise",err,error,*999)

    NULLIFY(cmfe_History%history)

    EXITS("cmfe_History_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_History_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_History_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_MeshType object.
  SUBROUTINE cmfe_Mesh_Finalise(cmfe_Mesh,err)
    !DLLEXPORT(cmfe_Mesh_Finalise)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(OUT) :: cmfe_Mesh !<The cmfe_MeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Mesh%mesh))  &
      & CALL Mesh_Destroy(cmfe_Mesh%mesh,err,error,*999)

    EXITS("cmfe_Mesh_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_MeshType object.
  SUBROUTINE cmfe_Mesh_Initialise(cmfe_Mesh,err)
    !DLLEXPORT(cmfe_Mesh_Initialise)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(OUT) :: cmfe_Mesh !<The cmfe_MeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_Initialise",err,error,*999)

    NULLIFY(cmfe_Mesh%mesh)

    EXITS("cmfe_Mesh_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_Mesh_Initialise

  !
  !================================================================================================================================
  !7

  !>Finalises a cmfe_MeshElementsType object.
  SUBROUTINE cmfe_MeshElements_Finalise(cmfe_MeshElements,err)
    !DLLEXPORT(cmfe_MeshElements_Finalise)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(OUT) :: cmfe_MeshElements !<The cmfe_MeshElementsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_MeshElements%meshElements)) CALL MeshElements_Destroy(cmfe_MeshElements%meshElements,err,error,*999)

    EXITS("cmfe_MeshElements_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_MeshElementsType object.
  SUBROUTINE cmfe_MeshElements_Initialise(cmfe_MeshElements,err)
    !DLLEXPORT(cmfe_MeshElements_Initialise)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(OUT) :: cmfe_MeshElements !<The cmfe_MeshElementsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_Initialise",err,error,*999)

    NULLIFY(cmfe_MeshElements%meshElements)

    EXITS("cmfe_MeshElements_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_MeshNodesType object.
  SUBROUTINE cmfe_MeshNodes_Finalise(cmfe_MeshNodes,err)
    !DLLEXPORT(cmfe_MeshNodes_Finalise)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(OUT) :: cmfe_MeshNodes !<The cmfe_MeshNodesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_MeshNodes%meshNodes))  &
      & CALL MeshTopology_NodesDestroy(cmfe_MeshNodes%meshNodes,err,error,*999)

    EXITS("cmfe_MeshNodes_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_MeshNodesType object.
  SUBROUTINE cmfe_MeshNodes_Initialise(cmfe_MeshNodes,err)
    !DLLEXPORT(cmfe_MeshNodes_Initialise)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(OUT) :: cmfe_MeshNodes !<The cmfe_MeshNodesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_Initialise",err,error,*999)

    NULLIFY(cmfe_MeshNodes%meshNodes)

    EXITS("cmfe_MeshNodes_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_NodesType object.
  SUBROUTINE cmfe_Nodes_Finalise(cmfe_Nodes,err)
    !DLLEXPORT(cmfe_Nodes_Finalise)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(OUT) :: cmfe_Nodes !<The cmfe_NodesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Nodes%nodes)) CALL Nodes_Destroy(cmfe_Nodes%nodes,err,error,*999)

    EXITS("cmfe_Nodes_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_NodesType object.
  SUBROUTINE cmfe_Nodes_Initialise(cmfe_Nodes,err)
    !DLLEXPORT(cmfe_Nodes_Initialise)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(OUT) :: cmfe_Nodes !<The cmfe_NodesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_Initialise",err,error,*999)

    NULLIFY(cmfe_Nodes%nodes)

    EXITS("cmfe_Nodes_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_ProblemType object.
  SUBROUTINE cmfe_Problem_Finalise(cmfe_Problem,err)
    !DLLEXPORT(cmfe_Problem_Finalise)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(OUT) :: cmfe_Problem !<The cmfe_ProblemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Problem%problem)) CALL Problem_Destroy(cmfe_Problem%problem,err,error,*999)

    EXITS("cmfe_Problem_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Problem_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_ProblemType object.
  SUBROUTINE cmfe_Problem_Initialise(cmfe_Problem,err)
    !DLLEXPORT(cmfe_Problem_Initialise)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(OUT) :: cmfe_Problem !<The cmfe_ProblemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_Initialise",err,error,*999)

    NULLIFY(cmfe_Problem%problem)

    EXITS("cmfe_Problem_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Problem_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_QuadratureType object.
  SUBROUTINE cmfe_Quadrature_Finalise(cmfe_Quadrature,err)
    !DLLEXPORT(cmfe_Quadrature_Finalise)

    !Argument variables
    TYPE(cmfe_QuadratureType), INTENT(OUT) :: cmfe_Quadrature !<The cmfe_QuadratureType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Quadrature_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Quadrature%quadrature))  &
      & CALL Basis_QuadratureDestroy(cmfe_Quadrature%quadrature,err,error,*999)

    EXITS("cmfe_Quadrature_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Quadrature_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Quadrature_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_QuadratureType object.
  SUBROUTINE cmfe_Quadrature_Initialise(cmfe_Quadrature,err)
    !DLLEXPORT(cmfe_Quadrature_Initialise)

    !Argument variables
    TYPE(cmfe_QuadratureType), INTENT(OUT) :: cmfe_Quadrature !<The cmfe_QuadratureType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Quadrature_Initialise",err,error,*999)

    NULLIFY(cmfe_Quadrature%quadrature)

    EXITS("cmfe_Quadrature_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Quadrature_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Quadrature_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_RegionType object.
  SUBROUTINE cmfe_Region_Finalise(cmfe_Region,err)
    !DLLEXPORT(cmfe_Region_Finalise)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(OUT) :: cmfe_Region !<The cmfe_RegionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Region%region))  &
      & CALL Region_Destroy(cmfe_Region%region,err,error,*999)

    EXITS("cmfe_Region_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Region_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_RegionType object.
  SUBROUTINE cmfe_Region_Initialise(cmfe_Region,err)
    !DLLEXPORT(cmfe_Region_Initialise)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(OUT) :: cmfe_Region !<The cmfe_RegionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_Initialise",err,error,*999)

    NULLIFY(cmfe_Region%region)

    EXITS("cmfe_Region_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Region_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_SolverType object.
  SUBROUTINE cmfe_Solver_Finalise(cmfe_Solver,err)
    !DLLEXPORT(cmfe_Solver_Finalise)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(OUT) :: cmfe_Solver !<The cmfe_SolverType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Solver%solver)) CALL Solver_Destroy(cmfe_Solver%solver,err,error,*999)

    EXITS("cmfe_Solver_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Solver_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_SolverType object.
  SUBROUTINE cmfe_Solver_Initialise(cmfe_Solver,err)
    !DLLEXPORT(cmfe_Solver_Initialise)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(OUT) :: cmfe_Solver !<The cmfe_SolverType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_Initialise",err,error,*999)

    NULLIFY(cmfe_Solver%solver)

    EXITS("cmfe_Solver_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Solver_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_SolverEquationsType object.
  SUBROUTINE cmfe_SolverEquations_Finalise(cmfe_SolverEquations,err)
    !DLLEXPORT(cmfe_SolverEquations_Finalise)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(OUT) :: cmfe_SolverEquations !<The cmfe_SolverEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_SolverEquations%solverEquations))  &
      & CALL SolverEquations_Destroy(cmfe_SolverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_SolverEquations_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_SolverEquationsType object.
  SUBROUTINE cmfe_SolverEquations_Initialise(cmfe_SolverEquations,err)
    !DLLEXPORT(cmfe_SolverEquations_Initialise)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(OUT) :: cmfe_SolverEquations !<The cmfe_SolverEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_Initialise",err,error,*999)

    NULLIFY(cmfe_SolverEquations%solverEquations)

    EXITS("cmfe_SolverEquations_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_WorkGroupType object.
  SUBROUTINE cmfe_WorkGroup_Finalise(cmfe_WorkGroup,err)
    !DLLEXPORT(cmfe_WorkGroup_Finalise)

    !Argument variables
    TYPE(cmfe_WorkGroupType), INTENT(OUT) :: cmfe_WorkGroup !<The cmfe_WorkGroupType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_WorkGroup_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_WorkGroup%workGroup)) CALL WorkGroup_Destroy(cmfe_WorkGroup%workGroup,err,error,*999)

    EXITS("cmfe_WorkGroup_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_Finalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_WorkGroupType object.
  SUBROUTINE cmfe_WorkGroup_Initialise(cmfe_WorkGroup,err)
    !DLLEXPORT(cmfe_WorkGroup_Initialise)

    !Argument variables
    TYPE(cmfe_WorkGroupType), INTENT(OUT) :: cmfe_WorkGroup !<The cmfe_WorkGroupType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_WorkGroup_Initialise",err,error,*999)

    NULLIFY(cmfe_WorkGroup%workGroup)

    EXITS("cmfe_WorkGroup_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_Initialise

!!==================================================================================================================================
!!
!! AnalyticAnalysisRoutines
!!
!!==================================================================================================================================

  !>Output the analytic error analysis for a field specified by a user number compared to the analytic values parameter set.
  SUBROUTINE cmfe_AnalyticAnalysis_OutputNumber(contextUserNumber,regionUserNumber,fieldUserNumber,fileName,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_OutputNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_OutputNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_Output(field,fileName,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_OutputNumber")
    RETURN
999 ERRORSEXITS("cmfe_AnalyticAnalysis_OutputNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_OutputNumber

  !
  !================================================================================================================================
  !

  !>Output the analytic error analysis for a field identified by an object compared to the analytic values parameter set.
  SUBROUTINE cmfe_AnalyticAnalysis_OutputObj(field,fileName,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_OutputObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_OutputObj",err,error,*999)

    CALL AnalyticAnalysis_Output(field%field,fileName,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_OutputObj")
    RETURN
999 ERRORSEXITS("cmfe_AnalyticAnalysis_OutputObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_OutputObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber, nodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_AbsoluteErrorGetNode(field,variableType,versionNumber,derivativeNumber,nodeNumber,componentNumber, &
      & VALUE,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_AbsoluteErrorGetNode(field%field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_PercentageErrorGetNode(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_PercentageErrorGetNode(field%field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_RelativeErrorGetNode(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_RelativeErrorGetNode(field%field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj")
    CALL cmfe_HandleError(err,error)
   RETURN

 END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & elementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_AbsoluteErrorGetElement(field,variableType,elementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj(field,variableType,elementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj",err,error,*999)

    CALL AnalyticAnalysis_AbsoluteErrorGetElement(field%field,variableType,elementNumber,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,elementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_PercentageErrorGetElement(field,variableType,elementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetElementObj(field,variableType,elementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_PercentageErrorGetElementObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetElementObj",err,error,*999)

    CALL AnalyticAnalysis_PercentageErrorGetElement(field%field,variableType,elementNumber,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetElementObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetElementObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetElementObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetElementObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & elementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_RelativeErrorGetElement(field,variableType,elementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetElementObj(field,variableType,elementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_RelativeErrorGetElementObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: value !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetElementObj",err,error,*999)

    CALL AnalyticAnalysis_RelativeErrorGetElement(field%field,variableType,elementNumber,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetElementObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RelativeErrorGetElementObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetElementObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_AbsoluteErrorGetConstant(field,variableType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj(field,variableType,componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj",err,error,*999)

    CALL AnalyticAnalysis_AbsoluteErrorGetConstant(field%field,variableType,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_PercentageErrorGetConstant(field,variableType,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj(field,variableType,componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj",err,error,*999)

    CALL AnalyticAnalysis_PercentageErrorGetConstant(field%field,variableType,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,value,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_RelativeErrorGetConstant(field,variableType,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj(field,variableType,componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: value !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj",err,error,*999)

    CALL AnalyticAnalysis_RelativeErrorGetConstant(field%field,variableType,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj

  !
  !================================================================================================================================
  !

  !>Get rms error value for nodes in a field compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,errorType,localValue,localGhostValue,globalValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue(8) !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue(8) !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue(8) !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_RMSErrorGetNode(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber")
    RETURN
999 ERRORSEXITS("cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get rms error value for nodes in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetNodeObj(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
    & globalValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_RMSErrorGetNodeObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue(8) !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue(8) !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue(8) !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_RMSErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_RMSErrorGetNode(field%field,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RMSErrorGetNodeObj")
    RETURN
999 ERRORSEXITS("cmfe_AnalyticAnalysis_RMSErrorGetNodeObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get rms error value for elements in a field compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetElementNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,errorType,localValue,localGhostValue,globalValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_RMSErrorGetElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_RMSErrorGetElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_RMSErrorGetElement(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RMSErrorGetElementNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RMSErrorGetElementNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_RMSErrorGetElementNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetElementObj(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
    & globalValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_RMSErrorGetElementObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_RMSErrorGetElementObj",err,error,*999)

    CALL AnalyticAnalysis_RMSErrorGetElement(field%field,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RMSErrorGetElementObj")
    RETURN
999 ERRORSEXITS("cmfe_AnalyticAnalysis_RMSErrorGetElementObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the numerical values.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralNumericalValueGet(field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the numerical values.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralNumericalValueGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the analytic values.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralAnalyticValueGet(field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the analytic values.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralAnalyticValueGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the percentage errors.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralPercentageErrorGet(field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the percentage errors.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralPercentageErrorGet(field%field,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the absolute errors.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralAbsoluteErrorGet(field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the absolute errors.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralAbsoluteErrorGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the relative error.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralRelativeErrorGet(field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the relative error.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralRelativeErrorGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid numerical.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralNIDNumericalValueGet(field,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid numerical.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralNIDNumericalValueGet(field%field,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid error.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDErrorGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralNIDErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralNIDErrorGet(field,variableType,componentNumber,integralValue,ghostIntegralValue,err, &
      & error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid error.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj(field,variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralNIDErrorGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue,err, &
      & error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj")
     CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj


!!==================================================================================================================================
!!
!! BaseRoutines
!!
!!==================================================================================================================================

  !>Sets diagnostics off. \see OpenCMISS::Iron::cmfe_DiagnosticsSetOn
  SUBROUTINE cmfe_DiagnosticsSetOff(err)
    !DLLEXPORT(cmfe_DiagnosticsSetOff)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_DiagnosticsSetOff",err,error,*999)

    CALL DiagnosticsSetOff(err,error,*999)

    EXITS("cmfe_DiagnosticsSetOff")
    RETURN
999 ERRORSEXITS("cmfe_DiagnosticsSetOff",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DiagnosticsSetOff

  !
  !================================================================================================================================
  !

  !>Sets diagnostics on \see OpenCMISS::Iron::cmfe_DiagnosticsSetOff
  SUBROUTINE cmfe_DiagnosticsSetOn(diagType,levelList,diagFilename,routineList,err)
    !DLLEXPORT(cmfe_DiagnosticsSetOn)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: diagType !<The type of diagnostics to set on \see OpenCMISS_DiagnosticTypes.
    INTEGER(INTG), INTENT(IN) :: levelList(:) !<The list of diagnostic levels to set on.
    CHARACTER(LEN=*), INTENT(IN) :: diagFilename !<If present the name of the file to output diagnostic information to. If omitted the diagnostic output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: routineList(:) !<The list of routines to set diagnostics on in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_DiagnosticsSetOn",err,error,*999)

    CALL DiagnosticsSetOn(diagType,levelList,diagFilename,routineList,err,error,*999)

    EXITS("cmfe_DiagnosticsSetOn")
    RETURN
999 ERRORSEXITS("cmfe_DiagnosticsSetOn",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DiagnosticsSetOn

  !
  !================================================================================================================================
  !

  !>Sets output off \see OpenCMISS::Iron::cmfe_OutputSetOff
  SUBROUTINE cmfe_OutputSetOff(err)
    !DLLEXPORT(cmfe_OutputSetOff)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_OutputSetOff",err,error,*999)

    CALL OutputSetOff(err,error,*999)

    EXITS("cmfe_OutputSetOff")
    RETURN
999 ERRORSEXITS("cmfe_OutputSetOff",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_OutputSetOff

  !
  !================================================================================================================================
  !

  !>Sets output on \see OpenCMISS::Iron::cmfe_OutputSetOff
  SUBROUTINE cmfe_OutputSetOn(echoFilename,err)
    !DLLEXPORT(cmfe_OutputSetOn)

    !Argument variables
    CHARACTER(LEN=*), INTENT(IN) :: echoFilename !<The filename of the file to echo output to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_OutputSetOn",err,error,*999)

    CALL OutputSetOn(echoFilename,err,error,*999)

    EXITS("cmfe_OutputSetOn")
    RETURN
999 ERRORSEXITS("cmfe_OutputSetOn",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_OutputSetOn

  !
  !================================================================================================================================
  !

  !>Sets timing off \see OpenCMISS::Iron::cmfe_TimingSetOn
  SUBROUTINE cmfe_TimingSetOff(err)
    !DLLEXPORT(cmfe_TimingSetOff)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_TimingSetOff",err,error,*999)

    CALL TimingSetOff(err,error,*999)

    EXITS("cmfe_TimingSetOff")
    RETURN
999 ERRORSEXITS("cmfe_TimingSetOff",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_TimingSetOff

  !
  !================================================================================================================================
  !

  !>Sets timing on \see OpenCMISS::Iron::cmfe_TimingSetOff
  SUBROUTINE cmfe_TimingSetOn(timingType,timingSummaryFlag,timingFilename,routineList,err)
    !DLLEXPORT(cmfe_TimingSetOn)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: timingType !<The type of timing to set on \see OpenCMISS_TimingTypes.
    LOGICAL, INTENT(IN) :: timingSummaryFlag !<.TRUE. if the timing information will be output with subsequent OpenCMISS::Iron::cmfe_TimingSummaryOutput calls, .FALSE. if the timing information will be output every time the routine exits.
    CHARACTER(LEN=*), INTENT(IN) :: timingFilename !<If present the name of the file to output timing information to. If omitted the timing output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: routineList(:) !<The list of routines to set timing on in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_TimingSetOn",err,error,*999)

    CALL TimingSetOn(timingType,timingSummaryFlag,timingFilename,routineList,err,error,*999)

    EXITS("cmfe_TimingSetOn")
    RETURN
999 ERRORSEXITS("cmfe_TimingSetOn",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_TimingSetOn

  !
  !================================================================================================================================
  !

  !>Outputs the timing summary.
  SUBROUTINE cmfe_TimingSummaryOutput(err)
    !DLLEXPORT(cmfe_TimingSummaryOutput)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    !Local variables

    ENTERS("cmfe_TimingSummaryOutput",err,error,*999)

    CALL TimingSummaryOutput(err,error,*999)

    EXITS("cmfe_TimingSummaryOutput")
    RETURN
999 ERRORSEXITS("cmfe_TimingSummaryOutput",err,error)
    RETURN

  END SUBROUTINE cmfe_TimingSummaryOutput

!!==================================================================================================================================
!!
!! BASIS_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the collapsed Xi flags of a basis identified by user number.
  SUBROUTINE cmfe_Basis_CollapsedXiGetNumber(contextUserNumber,basisUserNumber,collapsedXi,err)
    !DLLEXPORT(cmfe_Basis_CollapsedXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: collapsedXi(:) !<collapsedXi(xiIdx). On return, the collapsed Xi parameter for the xiIdx'th Xi direction. \see OpenCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_CollapsedXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_CollapsedXiGet(basis,collapsedXi,err,error,*999)

    EXITS("cmfe_Basis_CollapsedXiGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CollapsedXiGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CollapsedXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE cmfe_Basis_CollapsedXiGetObj(basis,collapsedXi,err)
    !DLLEXPORT(cmfe_Basis_CollapsedXiGetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: collapsedXi(:) !<collapsedXi(xiIdx). On return, the collapsed Xi parameter for the xiIdx'th Xi direction. \see OpenCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_CollapsedXiGetObj",err,error,*999)

    CALL Basis_CollapsedXiGet(basis%basis,collapsedXi,err,error,*999)

    EXITS("cmfe_Basis_CollapsedXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CollapsedXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_Basis_CollapsedXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the collapsed Xi flags of a basis identified by a user number.
  SUBROUTINE cmfe_Basis_CollapsedXiSetNumber(contextUserNumber,basisUserNumber,collapsedXi,err)
    !DLLEXPORT(cmfe_Basis_CollapsedXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: collapsedXi(:) !<collapsedXi(xiIdx). The collapsed Xi parameter for the xiIdx'th Xi direction to set. \see OpenCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_CollapsedXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_CollapsedXiSet(basis,collapsedXi,err,error,*999)

    EXITS("cmfe_Basis_CollapsedXiSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CollapsedXiSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CollapsedXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE cmfe_Basis_CollapsedXiSetObj(basis,collapsedXi,err)
    !DLLEXPORT(cmfe_Basis_CollapsedXiSetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: collapsedXi(:) !<collapsedXi(xiIdx). The collapsed Xi parameter for the xiIdx'th Xi direction to set. \see OpenCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_CollapsedXiSetObj",err,error,*999)

    CALL Basis_CollapsedXiSet(basis%basis,collapsedXi,err,error,*999)

    EXITS("cmfe_Basis_CollapsedXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CollapsedXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CollapsedXiSetObj

  !
  !================================================================================================================================
  !

   !>Finishes the creation of a new basis identified by a user number.
  SUBROUTINE cmfe_Basis_CreateFinishNumber(contextUserNumber,basisUserNumber,err)
    !DLLEXPORT(cmfe_Basis_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_CreateFinish(basis,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Basis Create')
#endif

    EXITS("cmfe_Basis_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new basis identified by an object.
  SUBROUTINE cmfe_Basis_CreateFinishObj(basis,err)
    !DLLEXPORT(cmfe_Basis_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_Basis_CreateFinishObj",err,error,*999)

    CALL Basis_CreateFinish(basis%basis,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('basis Create')
#endif

    EXITS("cmfe_Basis_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new basis for a basis identified by a user number.
  SUBROUTINE cmfe_Basis_CreateStartNumber(basisUserNumber,contextUserNumber,err)
    !DLLEXPORT(cmfe_Basis_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Basis Create')
#endif

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_CreateStart(basisUserNumber,basisFunctions,basis,err,error,*999)

    EXITS("cmfe_Basis_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new basis for a basis identified by an object.
  SUBROUTINE cmfe_Basis_CreateStartObj(userNumber,context,basis,err)
    !DLLEXPORT(cmfe_Basis_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to start the creation of.
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The context to create the basis function for.
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<On exit, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('basis Create')
#endif

    NULLIFY(basisFunctions)
    CALL Context_BasisFunctionsGet(context%context,basisFunctions,err,error,*999)
    CALL Basis_CreateStart(userNumber,basisFunctions,basis%basis,err,error,*999)

    EXITS("cmfe_Basis_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a basis identified by its basis user number.
  SUBROUTINE cmfe_Basis_DestroyNumber(contextUserNumber,basisUserNumber,err)
    !DLLEXPORT(cmfe_Basis_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_Destroy(basis,err,error,*999)

    EXITS("cmfe_Basis_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a basis identified by an object.
  SUBROUTINE cmfe_Basis_DestroyObj(basis,err)
    !DLLEXPORT(cmfe_Basis_DestroyObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_DestroyObj",err,error,*999)

    CALL Basis_Destroy(basis%basis,err,error,*999)

    EXITS("cmfe_Basis_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_DestroyObj

  !
  !================================================================================================================================
  !

  !>Get the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE cmfe_Basis_InterpolationXiGetNumber(contextUserNumber,basisUserNumber,interpolationXi,err)
    !DLLEXPORT(cmfe_Basis_InterpolationXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: interpolationXi(:) !<interpolationXi(xiIdx). On return, the interpolation xi parameters for each Xi direction \see OpenCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_InterpolationXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_InterpolationXiGet(basis,interpolationXi,err,error,*999)

    EXITS("cmfe_Basis_InterpolationXiGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_InterpolationXiGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_InterpolationXiGetNumber

  !
  !================================================================================================================================
  !

  !>Get the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE cmfe_Basis_InterpolationXiGetObj(basis,interpolationXi,err)
    !DLLEXPORT(cmfe_Basis_InterpolationXiGetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: interpolationXi(:) !<interpolationXi(xiIdx). On return, the interpolation xi parameters for each Xi direction \see OpenCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_InterpolationXiGetObj",err,error,*999)

    CALL Basis_InterpolationXiGet(basis%basis,interpolationXi,err,error,*999)

    EXITS("cmfe_Basis_InterpolationXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_InterpolationXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_InterpolationXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE cmfe_Basis_InterpolationXiSetNumber(contextUserNumber,basisUserNumber,interpolationXi,err)
    !DLLEXPORT(cmfe_Basis_InterpolationXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi(:) !<interpolationXi(xiIdx). The interpolation xi parameters for each Xi direction \see OpenCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_InterpolationXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_InterpolationXiSet(basis,interpolationXi,err,error,*999)

    EXITS("cmfe_Basis_InterpolationXiSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_InterpolationXiSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_InterpolationXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE cmfe_Basis_InterpolationXiSetObj(basis,interpolationXi,err)
    !DLLEXPORT(cmfe_Basis_InterpolationXiSetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi(:) !<interpolationXi(xiIdx). The interpolation xi parameters for each Xi direction \see OpenCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_InterpolationXiSetObj",err,error,*999)

    CALL Basis_InterpolationXiSet(basis%basis,interpolationXi,err,error,*999)

    EXITS("cmfe_Basis_InterpolationXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_InterpolationXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_InterpolationXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a basis identified by a user number.
  SUBROUTINE cmfe_Basis_NumberOfLocalNodesGetNumber(contextUserNumber,basisUserNumber,numberOfLocalNodes,err)
    !DLLEXPORT(cmfe_Basis_NumberOfLocalNodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_NumberOfLocalNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_NumberOfLocalNodesGet(basis,numberOfLocalNodes,err,error,*999)

    EXITS("cmfe_Basis_NumberOfLocalNodesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfLocalNodesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfLocalNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a basis identified by an object.
  SUBROUTINE cmfe_Basis_NumberOfLocalNodesGetObj(basis,numberOfLocalNodes,err)
    !DLLEXPORT(cmfe_Basis_NumberOfLocalNodesGetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the number of local nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_NumberOfLocalNodesGetObj",err,error,*999)

    CALL Basis_NumberOfLocalNodesGet(basis%basis,numberOfLocalNodes,err,error,*999)

    EXITS("cmfe_Basis_NumberOfLocalNodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfLocalNodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfLocalNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of Xi directions in a basis identified by a user number.
  SUBROUTINE cmfe_Basis_NumberOfXiGetNumber(contextUserNumber,basisUserNumber,numberOfXi,err)
    !DLLEXPORT(cmfe_Basis_NumberOfXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the number xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_NumberOfXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_NumberOfXiGet(basis,numberOfXi,err,error,*999)

    EXITS("cmfe_Basis_NumberOfXiGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfXiGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of Xi directions in a basis identified by an object.
  SUBROUTINE cmfe_Basis_NumberOfXiGetObj(basis,numberOfXi,err)
    !DLLEXPORT(cmfe_Basis_NumberOfXiGetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the number of xi directions for.
    INTEGER(INTG), INTENT(OUT) :: numberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_NumberOfXiGetObj",err,error,*999)

    CALL Basis_NumberOfXiGet(basis%basis,numberOfXi,err,error,*999)

    EXITS("cmfe_Basis_NumberOfXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Xi directions in a basis identified by a user number.
  SUBROUTINE cmfe_Basis_NumberOfXiSetNumber(contextUserNumber,basisUserNumber,numberOfXi,err)
    !DLLEXPORT(cmfe_Basis_NumberOfXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set the number xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_NumberOfXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_NumberOfXiSet(basis,numberOfXi,err,error,*999)

    EXITS("cmfe_Basis_NumberOfXiSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfXiSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Xi directions in a basis identified by an object.
  SUBROUTINE cmfe_Basis_NumberOfXiSetObj(basis,numberOfXi,err)
    !DLLEXPORT(cmfe_Basis_NumberOfXiSetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to set the number of xi directions for.
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_NumberOfXiSetObj",err,error,*999)

    CALL Basis_NumberOfXiSet(basis%basis,numberOfXi,err,error,*999)

    EXITS("cmfe_Basis_NumberOfXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiGetNumber(contextUserNumber,basisUserNumber,numberOfGaussXi,err)
    !DLLEXPORT(cmfe_Basis_QuadratureNumberOfGaussXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussXi(:) !<numberOfGauss(xiIdx). On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_QuadratureNumberOfGaussXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureNumberOfGaussXiGet(basis,numberOfGaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiGetNumber")
    RETURN
999 ERRORS("cmfe_Basis_QuadratureNumberOfGaussXiGetNumber",err,error)
    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiGetObj(basis,numberOfGaussXi,err)
    !DLLEXPORT(cmfe_Basis_QuadratureNumberOfGaussXiGetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussXi(:) !<numberOfGaussXi(xiIdx). On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureNumberOfGaussXiGetObj",err,error,*999)

    CALL Basis_QuadratureNumberOfGaussXiGet(basis%basis,numberOfGaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureNumberOfGaussXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiSetNumber(contextUserNumber,basisUserNumber,numberOfGaussXi,err)
    !DLLEXPORT(cmfe_Basis_QuadratureNumberOfGaussXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi(:) !<numberOfGaussXi(xiIdx). The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_QuadratureNumberOfGaussXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureNumberOfGaussXiSet(basis,numberOfGaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiSetNumber")
    RETURN
999 ERRORS("cmfe_Basis_QuadratureNumberOfGaussXiSetNumber",err,error)
    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiSetObj(basis,numberOfGaussXi,err)
    !DLLEXPORT(cmfe_Basis_QuadratureNumberOfGaussXiSetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi(:) !<numberOfGaussXi(xiIdx). The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureNumberOfGaussXiSetObj",err,error,*999)

    CALL Basis_QuadratureNumberOfGaussXiSet(basis%basis,numberOfGaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureNumberOfGaussXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiSetObj

  !
  !================================================================================================================================
  !
  !>Returns the xi position of a Gauss point on a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureGaussXiGetNumber0(contextUserNumber,basisUserNumber,quadratureScheme,gaussPoint,gaussXi,err)
    !DLLEXPORT(cmfe_Basis_QuadratureGaussXiGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss positions for.
    INTEGER(INTG), INTENT(IN) :: gaussPoint !<The Gauss point to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: gaussXi(:) !<On return, gaussXi(xiIdx) the xi position of the specified Gauss point for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_QuadratureGaussXiGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureGaussXiGet(basis,quadratureScheme,gaussPoint,gaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureGaussXiGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureGaussXiGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureGaussXiGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the xi position of a Gauss point on a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureGaussXiGetObj0(basis,quadratureScheme,gaussPoint,gaussXi,err)
    !DLLEXPORT(cmfe_Basis_QuadratureGaussXiGetObj0)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss xi positions for.
    INTEGER(INTG), INTENT(IN) :: gaussPoint !<The Gauss point to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: gaussXi(:) !<On return, gaussXi(xiIdx) the xi position of the specified Gauss point for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureGaussXiGetObj0",err,error,*999)

    CALL Basis_QuadratureGaussXiGet(basis%basis,quadratureScheme,gaussPoint,gaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureGaussXiGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureGaussXiGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureGaussXiGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the xi positions of Gauss points on a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureGaussXiGetNumber1(contextUserNumber,basisUserNumber,quadratureScheme,gaussPoints,gaussXi, &
    & err)
    !DLLEXPORT(cmfe_Basis_QuadratureGaussXiGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss positions for.
    INTEGER(INTG), INTENT(IN) :: gaussPoints(:) !<gaussPoints(gaussPointIdx). The Gauss points to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: gaussXi(:,:) !<gaussXi(gaussPointIdx,xiIdx). On return, the Gauss xi positions for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_QuadratureGaussXiGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureGaussXiGet(basis,quadratureScheme,gaussPoints,gaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureGaussXiGetNumber1")
    RETURN
999 ERRORS("cmfe_Basis_QuadratureGaussXiGetNumber1",err,error)
    EXITS("cmfe_Basis_QuadratureGaussXiGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureGaussXiGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the xi positions of Gauss points on a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureGaussXiGetObj1(basis,quadratureScheme,gaussPoints,gaussXi,err)
    !DLLEXPORT(cmfe_Basis_QuadratureGaussXiGetObj1)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss xi positions for.
    INTEGER(INTG), INTENT(IN) :: gaussPoints(:) !<gaussPoints(gaussPointIdx). The Gauss points to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: gaussXi(:,:) !<gaussXi(gaussPointIdx,xiIdx). On return, the Gauss xi positions for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureGaussXiGetObj1",err,error,*999)

    CALL Basis_QuadratureGaussXiGet(basis%basis,quadratureScheme,gaussPoints,gaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureGaussXiGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureGaussXiGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureGaussXiGetObj1

  !
  !================================================================================================================================
  !

  !>Returns the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureOrderGetNumber(contextUserNumber,basisUserNumber,quadratureOrder,err)
    !DLLEXPORT(cmfe_Basis_QuadratureOrderGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_QuadratureOrderGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureOrderGet(basis,quadratureOrder,err,error,*999)

    EXITS("cmfe_Basis_QuadratureOrderGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureOrderGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureOrderGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureOrderGetObj(basis,quadratureOrder,err)
    !DLLEXPORT(cmfe_Basis_QuadratureOrderGetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureOrderGetObj",err,error,*999)

    CALL Basis_QuadratureOrderGet(basis%basis,quadratureOrder,err,error,*999)

    EXITS("cmfe_Basis_QuadratureOrderGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureOrderGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureOrderGetObj


  !
  !================================================================================================================================
  !

  !>Sets/changes the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureOrderSetNumber(contextUserNumber,basisUserNumber,quadratureOrder,err)
    !DLLEXPORT(cmfe_Basis_QuadratureOrderSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: quadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_QuadratureOrderSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureOrderSet(basis,quadratureOrder,err,error,*999)

    EXITS("cmfe_Basis_QuadratureOrderSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureOrderSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureOrderSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureOrderSetObj(basis,quadratureOrder,err)
    !DLLEXPORT(cmfe_Basis_QuadratureOrderSetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: quadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureOrderSetObj",err,error,*999)

    CALL Basis_QuadratureOrderSet(basis%basis,quadratureOrder,err,error,*999)

    EXITS("cmfe_Basis_QuadratureOrderSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureOrderSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureOrderSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureTypeGetNumber(contextUserNumber,basisUserNumber,quadratureType,err)
    !DLLEXPORT(cmfe_Basis_QuadratureTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<On return, the type of quadrature in the specified basis. \see OpenCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_QuadratureTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureTypeGet(basis,quadratureType,err,error,*999)

    EXITS("cmfe_Basis_QuadratureTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureTypeGetObj(basis,quadratureType,err)
    !DLLEXPORT(cmfe_Basis_QuadratureTypeGetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<On return, the type of quadrature in the specified basis. \see OpenCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureTypeGetObj",err,error,*999)

    CALL Basis_QuadratureTypeGet(basis%basis,quadratureType,err,error,*999)

    EXITS("cmfe_Basis_QuadratureTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureTypeSetNumber(contextUserNumber,basisUserNumber,quadratureType,err)
    !DLLEXPORT(cmfe_Basis_QuadratureTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(IN) :: quadratureType !<The type of quadrature in the specified basis to set. \see OpenCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_QuadratureTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureTypeSet(basis,quadratureType,err,error,*999)

    EXITS("cmfe_Basis_QuadratureTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureTypeSetObj(basis,quadratureType,err)
    !DLLEXPORT(cmfe_Basis_QuadratureTypeSetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to get the quadrature type for.
    INTEGER(INTG), INTENT(IN) :: quadratureType !<The type of quadrature in the specified basis to set. \see OpenCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureTypeSetObj",err,error,*999)

    CALL Basis_QuadratureTypeSet(basis%basis,quadratureType,err,error,*999)

    EXITS("cmfe_Basis_QuadratureTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the local face Gauss scheme calculation, on a basis identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber(contextUserNumber,basisUserNumber,faceGaussEvaluate,err)
    !DLLEXPORT(cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the quadrature type for.
    LOGICAL, INTENT(IN) :: faceGaussEvaluate !<The value to set face Gauss evaluation flag to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureLocalFaceGaussEvaluateSet(basis,faceGaussEvaluate,err,error,*999)

    EXITS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber")
    RETURN
999 ERRORS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber",err,error)
    EXITS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the local face Gauss scheme calculation, on a basis identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj(basis,faceGaussEvaluate,err)
    !DLLEXPORT(cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to get the quadrature type for.
    LOGICAL, INTENT(IN) :: faceGaussEvaluate !<The type of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj",err,error,*999)

    CALL Basis_QuadratureLocalFaceGaussEvaluateSet(basis%basis,faceGaussEvaluate,err,error,*999)

    EXITS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj")
    RETURN
999 ERRORS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj",err,error)
    EXITS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a basis identified by a user number.
  SUBROUTINE cmfe_Basis_TypeGetNumber(contextUserNumber,basisUserNumber,basisType_,err)
    !DLLEXPORT(cmfe_Basis_TypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: basisType_ !<On return, the type of the specified basis. \see OpenCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_TypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_TypeGet(basis,basisType_,err,error,*999)

    EXITS("cmfe_Basis_TypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_TypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a basis identified by an object.
  SUBROUTINE cmfe_Basis_TypeGetObj(basis,basisType_,err)
    !DLLEXPORT(cmfe_Basis_TypeGetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: basisType_ !<On return, the type of the specified basis. \see OpenCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_TypeGetObj",err,error,*999)

    CALL Basis_TypeGet(basis%basis,basisType_,err,error,*999)

    EXITS("cmfe_Basis_TypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_TypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a basis identified by a user number.
  SUBROUTINE cmfe_Basis_TypeSetNumber(contextUserNumber,basisUserNumber,basisType_,err)
    !DLLEXPORT(cmfe_Basis_TypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: basisType_ !<The type of the specified basis to set. \see OpenCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_Basis_TypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_TypeSet(basis,basisType_,err,error,*999)

    EXITS("cmfe_Basis_TypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_TypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a basis identified by an object.
  SUBROUTINE cmfe_Basis_TypeSetObj(basis,basisType_,err)
    !DLLEXPORT(cmfe_Basis_TypeSetObj)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: basisType_ !<The type of the specified basis to set. \see OpenCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_TypeSetObj",err,error,*999)

    CALL Basis_TypeSet(basis%basis,basisType_,err,error,*999)

    EXITS("cmfe_Basis_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_TypeSetObj


!!==================================================================================================================================
!!
!! BoundaryConditionsRoutines
!!
!!==================================================================================================================================

  !>Destroys the boundary conditions for solver equations identified by a control loop identifier.
  SUBROUTINE cmfe_BoundaryConditions_DestroyNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,err)
    !DLLEXPORT(cmfe_BoundaryConditions_DestroyNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
 
    ENTERS("cmfe_BoundaryConditions_DestroyNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_Destroy(boundaryConditions,err,error,*999)

    EXITS("cmfe_BoundaryConditions_DestroyNumber0")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_DestroyNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_DestroyNumber0

  !
  !================================================================================================================================
  !

  !>Destroys the boundary conditions for solver equations identified by a control loop identifier.
  SUBROUTINE cmfe_BoundaryConditions_DestroyNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,err)
    !DLLEXPORT(cmfe_BoundaryConditions_DestroyNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
 
    ENTERS("cmfe_BoundaryConditions_DestroyNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_Destroy(boundaryConditions,err,error,*999)

    EXITS("cmfe_BoundaryConditions_DestroyNumber1")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_DestroyNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_DestroyNumber1

  !
  !================================================================================================================================
  !

  !>Destroys boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_DestroyObj(boundaryConditions,err)
    !DLLEXPORT(cmfe_BoundaryConditions_DestroyObj)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<The boundary conditions to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_DestroyObj",err,error,*999)

    CALL BoundaryConditions_Destroy(boundaryConditions%boundaryConditions,err,error,*999)

    EXITS("cmfe_BoundaryConditions_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_DestroyObj

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_AddConstantNumber(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,componentNumber,condition,value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_AddConstantNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the dependent field to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_BoundaryConditions_AddConstantNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_AddConstant(boundaryConditions,dependentField,variableType,componentNumber, &
      & condition,VALUE,err,error,*999)

    EXITS("cmfe_BoundaryConditions_AddConstantNumber")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddConstantNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddConstantNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_AddConstantObj(boundaryConditions,field,variableType,componentNumber,condition,value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_AddConstantObj)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the constant to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_AddConstantObj",err,error,*999)

    CALL BoundaryConditions_AddConstant(boundaryConditions%boundaryConditions,field%field,variableType,componentNumber, &
      & condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_AddConstantObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddConstantObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddConstantObj

  !
  !================================================================================================================================
  !


  !>Sets the value of the specified constant as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_SetConstantNumber(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifiers,solverIndex,regionUserNumber,fieldUserNumber,variableType,componentNumber,condition,value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_SetConstantNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_BoundaryConditions_SetConstantNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_SetConstant(boundaryConditions,dependentField,variableType,componentNumber, &
      & condition,VALUE,err,error,*999)

    EXITS("cmfe_BoundaryConditions_SetConstantNumber")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetConstantNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetConstantNumber

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_SetConstantObj(boundaryConditions,field,variableType,componentNumber,condition,value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_SetConstantObj)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the constant to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_SetConstantObj",err,error,*999)

    CALL BoundaryConditions_SetConstant(boundaryConditions%boundaryConditions,field%field,variableType,componentNumber, &
      & condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_SetConstantObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetConstantObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetConstantObj

  !
  !================================================================================================================================
  !

  !>Adds the value to the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_AddElementNumber(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,elementUserNumber,componentNumber,condition,value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_AddElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_BoundaryConditions_AddElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_AddElement(boundaryConditions,dependentField,variableType,elementUserNumber, &
      & componentNumber,condition,VALUE,err,error,*999)

    EXITS("cmfe_BoundaryConditions_AddElementNumber")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddElementNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddElementNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_AddElementObj(boundaryConditions,field,variableType,elementUserNumber,componentNumber, &
    & condition,value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_AddElementObj)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the element to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_AddElementObj",err,error,*999)

    CALL BoundaryConditions_AddElement(boundaryConditions%boundaryConditions,field%field,variableType,elementUserNumber, &
      & componentNumber,condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_AddElementObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddElementObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddElementObj

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified element as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_SetElementNumber(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,elementUserNumber,componentNumber,condition,value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_SetElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_BoundaryConditions_SetElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_SetElement(boundaryConditions,dependentField,variableType,elementUserNumber, &
      & componentNumber,condition,VALUE,err,error,*999)

    EXITS("cmfe_BoundaryConditions_SetElementNumber")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetElementNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetElementNumber

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified element and sets this as a boundary condition on the specified elements for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_SetElementObj(boundaryConditions,field,variableType,elementUserNumber,componentNumber, &
    & condition,value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_SetElementObj)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the element to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_SetElementObj",err,error,*999)

    CALL BoundaryConditions_SetElement(boundaryConditions%boundaryConditions,field%field,variableType,elementUserNumber, &
      & componentNumber,condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_SetElementObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetElementObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetElementObj

  !
  !================================================================================================================================
  !

  !>Adds the value to the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_AddNodeNumber(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition, &
    & value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_AddNodeNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_BoundaryConditions_AddNodeNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_AddNode(boundaryConditions,dependentField,variableType,versionNumber,derivativeNumber, &
      & nodeUserNumber,componentNumber,condition,VALUE,err,error,*999)

    EXITS("cmfe_BoundaryConditions_AddNodeNumber")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddNodeNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddNodeNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_AddNodeObj(boundaryConditions,field,variableType,versionNumber,derivativeNumber, &
      & nodeUserNumber,componentNumber,condition,value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_AddNodeObj)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the node to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_AddNodeObj",err,error,*999)

    CALL BoundaryConditions_AddNode(boundaryConditions%boundaryConditions,field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_AddNodeObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddNodeObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddNodeObj

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_SetNodeNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition, &
    & value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_SetNodeNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_BoundaryConditions_SetNodeNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_SetNode(boundaryConditions,dependentField,variableType,versionNumber,derivativeNumber, &
      & nodeUserNumber,componentNumber,condition,VALUE,err,error,*999)

    EXITS("cmfe_BoundaryConditions_SetNodeNumber0")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetNodeNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetNodeNumber0

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_SetNodeNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition, &
    & value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_SetNodeNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_BoundaryConditions_SetNodeNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_SetNode(boundaryConditions,dependentField,variableType,versionNumber,derivativeNumber, &
      & nodeUserNumber,componentNumber,condition,VALUE,err,error,*999)

    EXITS("cmfe_BoundaryConditions_SetNodeNumber1")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetNodeNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetNodeNumber1

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_SetNodeObj(boundaryConditions,field,variableType,versionNumber,derivativeNumber, &
    & nodeUserNumber,componentNumber,condition,value,err)
    !DLLEXPORT(cmfe_BoundaryConditions_SetNodeObj)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the node to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_SetNodeObj",err,error,*999)

    CALL BoundaryConditions_SetNode(boundaryConditions%boundaryConditions,field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_SetNodeObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetNodeObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetNodeObj

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity for boundary conditions identified by a control loop identifier.
  SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,sparsityType,err)
    !DLLEXPORT(cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier of the solver equations containing the boundary conditions.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OpenCMISS_BoundaryConditionSparsityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions,sparsityType,err,error,*999)

    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0",err,error)
    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity for boundary conditions identified by a control loop identifier.
  SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,sparsityType,err)    
    !DLLEXPORT(cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OpenCMISS_BoundaryConditionSparsityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions,sparsityType,err,error,*999)

    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1",err,error)
    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity type for the boundary conditions
  SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetObj(boundaryConditions,sparsityType,err)
    !DLLEXPORT(cmfe_BoundaryConditions_NeumannSparsityTypeSetObj)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<The boundary conditions
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OpenCMISS_BoundaryConditionSparsityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_NeumannSparsityTypeSetObj",err,error,*999)

    CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions%boundaryConditions,sparsityType,err,error,*999)

    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetObj")
    RETURN
999 ERRORS("cmfe_BoundaryConditions_NeumannSparsityTypeSetObj",err,error)
    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
  SUBROUTINE cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,regionUserNumber,fieldUserNumber,fieldVariableType,versionNumber,derivativeNumber,component,nodes, &
    & coefficient,err)
    !DLLEXPORT(cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index of the solver equations.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field DOFs to constrain.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field containing the DOFs to contrain.
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The variable type of the dependent field containing the DOFs to constrain. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number.
    INTEGER(INTG), INTENT(IN) :: component !<The field component number of the DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: nodes(:) !<The user numbers of the nodes to be constrained to be equal.
    REAL(DP), INTENT(IN) :: coefficient !<The coefficient of constraint, applied to all but the first node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(field)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_ConstrainNodeDofsEqual(boundaryConditions,field, &
      & fieldVariableType,versionNumber,derivativeNumber,component,nodes,coefficient,err,error,*999)

    EXITS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber")
    RETURN
999 ERRORS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber",err,error)
    EXITS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber

  !
  !================================================================================================================================
  !

  !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
  SUBROUTINE cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj(boundaryConditions,field,fieldVariableType,versionNumber, &
    & derivativeNumber,component,nodes,coefficient,err)
    !DLLEXPORT(cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to constrain the DOFs in.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The equations dependent field containing the field DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type of the DOFs to be constrained. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number.
    INTEGER(INTG), INTENT(IN) :: component !<The field component number of the DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: nodes(:) !<The user numbers of the nodes to be constrained to be equal.
    REAL(DP), INTENT(IN) :: coefficient !<The coefficient of constraint, applied to all but the first node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj",err,error,*999)

    CALL BoundaryConditions_ConstrainNodeDofsEqual(boundaryConditions%boundaryConditions,field%field, &
      & fieldVariableType,versionNumber,derivativeNumber,component,nodes,coefficient,err,error,*999)

    EXITS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj")
    RETURN
999 ERRORS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj",err,error)
    EXITS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj

!!==================================================================================================================================
!!
!! CMISS
!!
!!==================================================================================================================================

  !>Returns the error handling mode for OpenCMISS
  SUBROUTINE cmfe_ErrorHandlingModeGet(errorHandlingMode,err)
    !DLLEXPORT(cmfe_ErrorHandlingModeGet)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: errorHandlingMode !<On return, the error handling mode. \see OpenCMISS_CMISSErrorHandlingModes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ErrorHandlingModeGet",err,error,*999)

    CALL cmfe_ErrorHandlingModeGet_(errorHandlingMode,err,error,*999)

    EXITS("cmfe_ErrorHandlingModeGet")
    RETURN
999 ERRORSEXITS("cmfe_ErrorHandlingModeGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ErrorHandlingModeGet

  !
  !================================================================================================================================
  !

  !>Sets the error handling mode for OpenCMISS
  SUBROUTINE cmfe_ErrorHandlingModeSet(errorHandlingMode,err)
    !DLLEXPORT(cmfe_ErrorHandlingModeSet)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: errorHandlingMode !<The error handling mode to set. \see OpenCMISS_CMISSErrorHandlingModes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ErrorHandlingModeSet",err,error,*999)

    CALL cmfe_ErrorHandlingModeSet_(errorHandlingMode,err,error,*999)

    EXITS("cmfe_ErrorHandlingModeSet")
    RETURN
999 ERRORSEXITS("cmfe_ErrorHandlingModeSet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ErrorHandlingModeSet

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE cmfe_ExtractErrorMessageC(errorMessage,err)
    !DLLEXPORT(cmfe_ExtractErrorMessageC)

    !Argument variables
    CHARACTER(LEN=*), INTENT(OUT) :: errorMessage !<On return, the extracted error message.
    INTEGER(INTG), INTENT(IN) :: err !<The error code.
    !Local variables

    CALL ExtractErrorMessage(errorMessage,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE cmfe_ExtractErrorMessageC

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE cmfe_ExtractErrorMessageVS(errorMessage,err)
    !DLLEXPORT(cmfe_ExtractErrorMessageVS)

    !Argument variables
    TYPE(VARYING_STRING), INTENT(OUT) :: errorMessage !<On return, the extracted error message.
    INTEGER(INTG), INTENT(IN) :: err !<The error code.
    !Local variables

    CALL ExtractErrorMessage(errorMessage,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE cmfe_ExtractErrorMessageVS

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE cmfe_ExtractErrorStackC(errorStack,err)
    !DLLEXPORT(cmfe_ExtractErrorStackC)

    !Argument variables
    CHARACTER(LEN=*), INTENT(OUT) :: errorStack !<On return, the extracted error stack.
    INTEGER(INTG), INTENT(IN) :: err !<The error code.
    !Local variables

    CALL ExtractErrorStack(errorStack,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE cmfe_ExtractErrorStackC

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error stack for OpenCMISS
  SUBROUTINE cmfe_ExtractErrorStackVS(errorStack,err)
    !DLLEXPORT(cmfe_ExtractErrorStackVS)

    !Argument variables
    TYPE(VARYING_STRING), INTENT(OUT) :: errorStack !<On return, the extracted error stack.
    INTEGER(INTG), INTENT(IN) :: err !<The error code.
    !Local variables

    CALL ExtractErrorStack(errorStack,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE cmfe_ExtractErrorStackVS


!!==================================================================================================================================
!!
!! CmissCellML
!!
!!==================================================================================================================================

  !>Sets a CellML model variable to be known by user number.
  SUBROUTINE cmfe_CellML_VariableSetAsKnownNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,err)
    !DLLEXPORT(cmfe_CellML_VariableSetAsKnownNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_VariableSetAsKnownNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML
    
    NULLIFY(context)    
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_VariableSetAsKnown(cellml,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("cmfe_CellML_VariableSetAsKnownNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsKnownNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsKnownNumberC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by object.
  SUBROUTINE cmfe_CellML_VariableSetAsKnownObjC(CellML,cellMLModelUserNumber,variableID,err)
    !DLLEXPORT(cmfe_CellML_VariableSetAsKnownObjC)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_VariableSetAsKnownObjC",err,error,*999)
    
    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML
    
    CALL CellML_VariableSetAsKnown(CellML%cellML,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("cmfe_CellML_VariableSetAsKnownObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsKnownObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsKnownObjC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by user number.
  SUBROUTINE cmfe_CellML_VariableSetAsKnownNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,err)
    !DLLEXPORT(cmfe_CellML_VariableSetAsKnownNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_VariableSetAsKnownNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML
    
    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_VariableSetAsKnown(cellml,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("cmfe_CellML_VariableSetAsKnownNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsKnownNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsKnownNumberVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by object.
  SUBROUTINE cmfe_CellML_VariableSetAsKnownObjVS(CellML,cellMLModelUserNumber,variableID,err)
    !DLLEXPORT(cmfe_CellML_VariableSetAsKnownObjVS)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_VariableSetAsKnownObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML
    
    CALL CellML_VariableSetAsKnown(CellML%cellML,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("cmfe_CellML_VariableSetAsKnownObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsKnownObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsKnownObjVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by user number.
  SUBROUTINE cmfe_CellML_VariableSetAsWantedNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,err)
    !DLLEXPORT(cmfe_CellML_VariableSetAsWantedNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_VariableSetAsWantedNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_VariableSetAsWanted(cellml,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("cmfe_CellML_VariableSetAsWantedNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsWantedNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsWantedNumberC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by object.
  SUBROUTINE cmfe_CellML_VariableSetAsWantedObjC(CellML,cellMLModelUserNumber,variableID,err)
    !DLLEXPORT(cmfe_CellML_VariableSetAsWantedObjC)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_VariableSetAsWantedObjC",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML

    CALL CellML_VariableSetAsWanted(CellML%cellML,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("cmfe_CellML_VariableSetAsWantedObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsWantedObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsWantedObjC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by user number.
  SUBROUTINE cmfe_CellML_VariableSetAsWantedNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,err)
    !DLLEXPORT(cmfe_CellML_VariableSetAsWantedNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_VariableSetAsWantedNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_VariableSetAsWanted(cellml,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("cmfe_CellML_VariableSetAsWantedNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsWantedNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsWantedNumberVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by object.
  SUBROUTINE cmfe_CellML_VariableSetAsWantedObjVS(CellML,cellMLModelUserNumber,variableID,err)
    !DLLEXPORT(cmfe_CellML_VariableSetAsWantedObjVS)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_VariableSetAsWantedObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_VariableSetAsWanted(CellML%cellML,cellMLModelUserNumber,variableID,err,error,*999)

#endif

    EXITS("cmfe_CellML_VariableSetAsWantedObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsWantedObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsWantedObjVS

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by user number
  SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,cellMLParameterSet,fieldUserNumber,variableType,componentNumber,fieldParameterSet,err)
    !DLLEXPORT(cmfe_CellML_CreateCellMLToFieldMapNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map fom.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map from.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map to
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_CreateCellMLToFieldMapNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL CellML_CreateCellMLToFieldMap(cellml,cellMLModelUserNumber,variableID,cellMLParameterSet, &
      & FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)

#endif

    EXITS("cmfe_CellML_CreateCellMLToFieldMapNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateCellMLToFieldMapNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapNumberC

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by object.
  SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapObjC(cellML,cellMLModelUserNumber,variableID,cellMLParameterSet, &
    & field,variableType,componentNumber,fieldParameterSet,err)
    !DLLEXPORT(cmfe_CellML_CreateCellMLToFieldMapObjC)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: cellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map from.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to map to.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateCellMLToFieldMapObjC",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML

    CALL CellML_CreateCellMLToFieldMap(cellML%cellML,cellMLModelUserNumber,variableID,cellMLParameterSet, &
      & field%field,variableType,componentNumber,fieldParameterSet,err,error,*999)

#endif

    EXITS("cmfe_CellML_CreateCellMLToFieldMapObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateCellMLToFieldMapObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapObjC

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by user number
  SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,cellMLParameterSet,fieldUserNumber,variableType,componentNumber,fieldParameterSet,err)
    !DLLEXPORT(cmfe_CellML_CreateCellMLToFieldMapNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable ID in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_CreateCellMLToFieldMapNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL CellML_CreateCellMLToFieldMap(cellml,cellMLModelUserNumber,variableID,cellMLParameterSet, &
      & FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)

#endif

    EXITS("cmfe_CellML_CreateCellMLToFieldMapNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateCellMLToFieldMapNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapNumberVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map, by object.
  SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapObjVS(cellML,cellMLModelUserNumber,variableID,cellMLParameterSet, &
    & field,variableType,componentNumber,fieldParameterSet,err)
    !DLLEXPORT(cmfe_CellML_CreateCellMLToFieldMapObjVS)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: cellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map from.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to map to.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateCellMLToFieldMapObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_CreateCellMLToFieldMap(cellML%cellML,cellMLModelUserNumber,variableID,cellMLParameterSet, &
      & field%field,variableType,componentNumber,fieldParameterSet,err,error,*999)

#endif
    
    EXITS("cmfe_CellML_CreateCellMLToFieldMapObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateCellMLToFieldMapObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapObjVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by user number.
  SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,fieldUserNumber, &
    & variableType,componentNumber,fieldParameterSet,cellMLModelUserNumber,variableID,cellMLParameterSet,err)
    !DLLEXPORT(cmfe_CellML_CreateFieldToCellMLMapNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map to.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_CreateFieldToCellMLMapNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL CellML_CreateFieldToCellMLMap(cellml,field,variableType,componentNumber,fieldParameterSet, &
      & cellMLModelUserNumber,variableID,cellMLParameterSet,err,error,*999)

#endif

    EXITS("cmfe_CellML_CreateFieldToCellMLMapNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFieldToCellMLMapNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapNumberC

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by object.
  SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapObjC(cellML,field,variableType,componentNumber,fieldParameterSet, &
    & cellMLModelUserNumber,variableID,cellMLParameterSet,err)
    !DLLEXPORT(cmfe_CellML_CreateFieldToCellMLMapObjC)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: cellML !<The CellML enviroment.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number to map from the given field variable.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map to.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateFieldToCellMLMapObjC",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML

    CALL CellML_CreateFieldToCellMLMap(cellML%cellML,field%field,variableType,componentNumber,fieldParameterSet, &
      & cellMLModelUserNumber,variableID,cellMLParameterSet,err,error,*999)

#endif

    EXITS("cmfe_CellML_CreateFieldToCellMLMapObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFieldToCellMLMapObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapObjC

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by user number
  SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,fieldUserNumber, &
    & variableType,fieldParameterSet,componentNumber,cellMLModelUserNumber,variableID,cellMLParameterSet,err)
    !DLLEXPORT(cmfe_CellML_CreateFieldToCellMLMapNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map to.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_CreateFieldToCellMLMapNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL CellML_CreateFieldToCellMLMap(cellml,field,variableType,componentNumber,fieldParameterSet, &
      & cellMLModelUserNumber,variableID,cellMLParameterSet,err,error,*999)

#endif

    EXITS("cmfe_CellML_CreateFieldToCellMLMapNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFieldToCellMLMapNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapNumberVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by by object.
  SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapObjVS(cellML,field,variableType,componentNumber,fieldParameterSet, &
    & cellMLModelUserNumber,variableID,cellMLParameterSet,err)
    !DLLEXPORT(cmfe_CellML_CreateFieldToCellMLMapObjVS)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: cellML !<The CellML enviroment.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map to.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable ID in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateFieldToCellMLMapObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_CreateFieldToCellMLMap(cellML%cellML,field%field,variableType,componentNumber,fieldParameterSet, &
      & cellMLModelUserNumber,variableID,cellMLParameterSet,err,error,*999)

#endif

    EXITS("cmfe_CellML_CreateFieldToCellMLMapObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFieldToCellMLMapObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_CreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(cmfe_CellML_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_CreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_CreateFinish(cellml,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

#endif

    EXITS("cmfe_CellML_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_CreateFinishObj(cellML,err)
    !DLLEXPORT(cmfe_CellML_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML
    
    CALL CellML_CreateFinish(cellML%cellML,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

#endif

    EXITS("cmfe_CellML_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_CreateStartNumber(cellMLUserNumber,contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(cmfe_CellML_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to start creating.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the field to start the CellML enviroment creation on.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_CreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL CellML_CreateStart(cellMLUserNumber,region,cellml,err,error,*999)

#endif

    EXITS("cmfe_CellML_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_CreateStartObj(cellMLUserNumber,region,cellML,err)
    !DLLEXPORT(cmfe_CellML_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to start creating.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region containing the field to start the CellML enviroment creation on.
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<On return, the created CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL CellML_CreateStart(cellMLUserNumber,region%region,cellML%cellML,err,error,*999)

#endif

    EXITS("cmfe_CellML_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_DestroyNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(cmfe_CellML_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to destroy.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_DestroyNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CELLML_DESTROY(cellml,err,error,*999)

#endif

    EXITS("cmfe_CellML_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_DestroyObj(cellML,err)
    !DLLEXPORT(cmfe_CellML_DestroyObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_DestroyObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CELLML_DESTROY(cellML%cellML,err,error,*999)

#endif

    EXITS("cmfe_CellML_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of field maps for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_FieldMapsCreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(cmfe_CellML_FieldMapsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_FieldMapsCreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_FieldMapsCreateFinish(cellml,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

#endif

    EXITS("cmfe_CellML_FieldMapsCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldMapsCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldMapsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of field maps for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_FieldMapsCreateFinishObj(cellML,err)
    !DLLEXPORT(cmfe_CellML_FieldMapsCreateFinishObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_FieldMapsCreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_FieldMapsCreateFinish(cellML%cellML,err,error,*999)

#endif

    EXITS("cmfe_CellML_FieldMapsCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldMapsCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldMapsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of field maps for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_FieldMapsCreateStartNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(cmfe_CellML_FieldMapsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to start creating the maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_FieldMapsCreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML
    
    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_FieldMapsCreateStart(cellml,err,error,*999)

#endif

    EXITS("cmfe_CellML_FieldMapsCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldMapsCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldMapsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of field maps for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_FieldMapsCreateStartObj(cellML,err)
    !DLLEXPORT(cmfe_CellML_FieldMapsCreateStartObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment object to start the creation of maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_FieldMapsCreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML
    
    CALL CellML_FieldMapsCreateStart(cellML%cellML,err,error,*999)

#endif

    EXITS("cmfe_CellML_FieldMapsCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldMapsCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldMapsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ModelImportNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,URI,modelIndex,err)
    !DLLEXPORT(cmfe_CellML_ModelImportNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to import the model into.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_CellML_ModelImportNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ModelImport(cellml,URI,modelIndex,err,error,*999)

#endif

    EXITS("cmfe_CellML_ModelImportNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelImportNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelImportNumberC

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ModelImportObjC(cellML,URI,modelIndex,err)
    !DLLEXPORT(cmfe_CellML_ModelImportObjC)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ModelImportObjC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ModelImport(cellML%cellML,URI,modelIndex,err,error,*999)

#endif

    EXITS("cmfe_CellML_ModelImportObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelImportObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelImportObjC

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ModelImportNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,URI,modelIndex,err)
    !DLLEXPORT(cmfe_CellML_ModelImportNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to import the model into.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_ModelImportNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML    

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)    
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ModelImport(cellml,URI,modelIndex,err,error,*999)

#endif

    EXITS("cmfe_CellML_ModelImportNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelImportNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelImportNumberVS

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ModelImportObjVS(cellML,URI,modelIndex,err)
    !DLLEXPORT(cmfe_CellML_ModelImportObjVS)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ModelImportObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ModelImport(cellML%cellML,URI,modelIndex,err,error,*999)

#endif

    EXITS("cmfe_CellML_ModelImportObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelImportObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelImportObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ModelsFieldCreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(cmfe_CellML_ModelsFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating the models field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_ModelsFieldCreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)    
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ModelsFieldCreateFinish(cellml,err,error,*999)

#endif

    EXITS("cmfe_CellML_ModelsFieldCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ModelsFieldCreateFinishObj(cellML,err)
    !DLLEXPORT(cmfe_CellML_ModelsFieldCreateFinishObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of the models field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ModelsFieldCreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ModelsFieldCreateFinish(cellML%cellML,err,error,*999)

#endif

    EXITS("cmfe_CellML_ModelsFieldCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ModelsFieldCreateStartNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLModelsFieldUserNumber,err)
    !DLLEXPORT(cmfe_CellML_ModelsFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to start creating the models field for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_ModelsFieldCreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML
    
    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ModelsFieldCreateStart(cellMLModelsFieldUserNumber,cellml,field,err,error,*999)

#endif

    EXITS("cmfe_CellML_ModelsFieldCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ModelsFieldCreateStartObj(cellML,cellMLModelsFieldUserNumber,field,err)
    !DLLEXPORT(cmfe_CellML_ModelsFieldCreateStartObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to start the creation of models field for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created CellML models field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ModelsFieldCreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ModelsFieldCreateStart(cellMLModelsFieldUserNumber,cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("cmfe_CellML_ModelsFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML models field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ModelsFieldGetNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelsFieldUserNumber,err)
    !DLLEXPORT(cmfe_CellML_ModelsFieldGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to get the CellML models field for.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the CellML models field for.
    INTEGER(INTG), INTENT(OUT) :: cellMLModelsFieldUserNumber !<On return, the user number of the CellML models field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_ModelsFieldGetNumber",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)   
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ModelsFieldGet(cellml,field,err,error,*999)
    cellMLModelsFieldUserNumber = FIELD%userNumber

#else

    cellMLModelsFieldUserNumber = 0
    
#endif

    EXITS("cmfe_CellML_ModelsFieldGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML models field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ModelsFieldGetObj(cellML,field,err)
    !DLLEXPORT(cmfe_CellML_ModelsFieldGetObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the models field for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the CellML models field. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ModelsFieldGetObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ModelsFieldGet(cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("cmfe_CellML_ModelsFieldGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_StateFieldCreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(cmfe_CellML_StateFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating the state field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_StateFieldCreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_StateFieldCreateFinish(cellml,err,error,*999)

#endif

    EXITS("cmfe_CellML_StateFieldCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_StateFieldCreateFinishObj(cellML,err)
    !DLLEXPORT(cmfe_CellML_StateFieldCreateFinishObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of the state field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_StateFieldCreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_StateFieldCreateFinish(cellML%cellML,err,error,*999)

#endif

    EXITS("cmfe_CellML_StateFieldCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_StateFieldCreateStartNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLStateFieldUserNumber,err)
    !DLLEXPORT(cmfe_CellML_StateFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to start creating the state field for.
    INTEGER(INTG), INTENT(IN) :: cellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_StateFieldCreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_StateFieldCreateStart(cellMLStateFieldUserNumber,cellml,field,err,error,*999)

#endif

    EXITS("cmfe_CellML_StateFieldCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_StateFieldCreateStartObj(cellML,cellMLStateFieldUserNumber,field,err)
    !DLLEXPORT(cmfe_CellML_StateFieldCreateStartObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to start the creation of state field for.
    INTEGER(INTG), INTENT(IN) :: cellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_StateFieldCreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_StateFieldCreateStart(cellMLStateFieldUserNumber,cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("cmfe_CellML_StateFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML state field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_StateFieldGetNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLStateFieldUserNumber,err)
    !DLLEXPORT(cmfe_CellML_StateFieldGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the CellML state field for.
    INTEGER(INTG), INTENT(OUT) :: cellMLStateFieldUserNumber !<On return, the user number of the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_StateFieldGetNumber",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_StateFieldGet(cellml,field,err,error,*999)
    cellMLStateFieldUserNumber = field%userNumber

#else

    cellMLStateFieldUserNumber = 0

#endif

    EXITS("cmfe_CellML_StateFieldGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML state field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_StateFieldGetObj(cellML,field,err)
    !DLLEXPORT(cmfe_CellML_StateFieldGetObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the state field for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_StateFieldGetObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_StateFieldGet(cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("cmfe_CellML_StateFieldGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldGetObj

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a character string VariableID for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_FieldComponentGetNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & cellMLFieldType,variableID,fieldComponent,err)
    !DLLEXPORT(cmfe_CellML_FieldComponentGetNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map fom.
    INTEGER(INTG), INTENT(IN) :: cellMLFieldType !<The type of CellML field to get the component for. \see OpenCMISS_CellMLFieldTypes,OpenCMISS
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The variable ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_FieldComponentGetNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_FieldComponentGet(cellml,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err,error,*999)

#else
    
    fieldComponent=0
    
#endif

    EXITS("cmfe_CellML_FieldComponentGetNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldComponentGetNumberC",err,error)
    CALL cmfe_HandleError(err,error)

    RETURN

  END SUBROUTINE cmfe_CellML_FieldComponentGetNumberC

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a character string variable ID for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_FieldComponentGetObjC(cellML,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err)
    !DLLEXPORT(cmfe_CellML_FieldComponentGetObjC)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLFieldType !<The type of CellML field to get the component for. \see OpenCMISS_CellMLFieldTypes,OpenCMISS
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_FieldComponentGetObjC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_FieldComponentGet(cellML%cellML,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err,error,*999)

#else

    fieldComponent=0

#endif

    EXITS("cmfe_CellML_FieldComponentGetObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldComponentGetObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldComponentGetObjC

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a varying string variable ID for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_FieldComponentGetNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & cellMLFieldType,variableID,fieldComponent,err)
    !DLLEXPORT(cmfe_CellML_FieldComponentGetNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLFieldType !<The type of CellML field to get the component for. \see OpenCMISS_CellMLFieldTypes,OpenCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_FieldComponentGetNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_FieldComponentGet(cellml,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err,error,*999)

#else

    fieldComponent=0

#endif

    EXITS("cmfe_CellML_FieldComponentGetNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldComponentGetNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldComponentGetNumberVS

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a varying string variable ID for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_FieldComponentGetObjVS(cellML,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err)
    !DLLEXPORT(cmfe_CellML_FieldComponentGetObjVS)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLFieldType !<The type of CellML field to get the component for. \see OpenCMISS_CellMLFieldTypes,OpenCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_FieldComponentGetObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_FieldComponentGet(cellML%cellML,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err,error,*999)

#else

    fieldComponent=0
    
#endif

    EXITS("cmfe_CellML_FieldComponentGetObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldComponentGetObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldComponentGetObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_IntermediateFieldCreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(cmfe_CellML_IntermediateFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_IntermediateFieldCreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_IntermediateFieldCreateFinish(cellml,err,error,*999)

#endif

    EXITS("cmfe_CellML_IntermediateFieldCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_CellML_IntermediateFieldCreateFinishNumber",err,error)
    EXITS("cmfe_CellML_IntermediateFieldCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_IntermediateFieldCreateFinishObj(cellML,err)
    !DLLEXPORT(cmfe_CellML_IntermediateFieldCreateFinishObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_IntermediateFieldCreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_IntermediateFieldCreateFinish(cellML%cellML,err,error,*999)

#endif

    EXITS("cmfe_CellML_IntermediateFieldCreateFinishObj")
    RETURN
999 ERRORS("cmfe_CellML_IntermediateFieldCreateFinishObj",err,error)
    EXITS("cmfe_CellML_IntermediateFieldCreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_IntermediateFieldCreateStartNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLIntermediateFieldUserNumber,err)
    !DLLEXPORT(cmfe_CellML_IntermediateFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to start creating the intermediate field for.
    INTEGER(INTG), INTENT(IN) :: cellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_IntermediateFieldCreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_IntermediateFieldCreateStart(cellMLIntermediateFieldUserNumber,cellml,field,err,error,*999)

#endif

    EXITS("cmfe_CellML_IntermediateFieldCreateStartNumber")
    RETURN
999 ERRORS("cmfe_CellML_IntermediateFieldCreateStartNumber",err,error)
    EXITS("cmfe_CellML_IntermediateFieldCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_IntermediateFieldCreateStartObj(cellML,cellMLIntermediateFieldUserNumber,field,err)
    !DLLEXPORT(cmfe_CellML_IntermediateFieldCreateStartObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to start the creation of intermediate field for.
    INTEGER(INTG), INTENT(IN) :: cellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_IntermediateFieldCreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_IntermediateFieldCreateStart(cellMLIntermediateFieldUserNumber,cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("cmfe_CellML_IntermediateFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_IntermediateFieldCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_IntermediateFieldGetNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLIntermediateFieldUserNumber,err)
    !DLLEXPORT(cmfe_CellML_IntermediateFieldGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the CellML intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: cellMLIntermediateFieldUserNumber !<On return, the user number of the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_IntermediateFieldGetNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_IntermediateFieldGet(cellml,field,err,error,*999)
    cellMLIntermediateFieldUserNumber = field%userNumber

#else

    cellMLIntermediateFieldUserNumber=0

#endif

    EXITS("cmfe_CellML_IntermediateFieldGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_IntermediateFieldGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_IntermediateFieldGetObj(cellML,field,err)
    !DLLEXPORT(cmfe_CellML_IntermediateFieldGetObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the intermediate field for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_IntermediateFieldGetObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_IntermediateFieldGet(cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("cmfe_CellML_IntermediateFieldGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_IntermediateFieldGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ParametersFieldCreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(cmfe_CellML_ParametersFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_ParametersFieldCreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ParametersFieldCreateFinish(cellml,err,error,*999)

#endif

    EXITS("cmfe_CellML_ParametersFieldCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_CellML_ParametersFieldCreateFinishNumber",err,error)
    EXITS("cmfe_CellML_ParametersFieldCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ParametersFieldCreateFinishObj(cellML,err)
    !DLLEXPORT(cmfe_CellML_ParametersFieldCreateFinishObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ParametersFieldCreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

   CALL CellML_ParametersFieldCreateFinish(cellML%cellML,err,error,*999)

#endif

    EXITS("cmfe_CellML_ParametersFieldCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ParametersFieldCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ParametersFieldCreateStartNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLParametersFieldUserNumber,err)
    !DLLEXPORT(cmfe_CellML_ParametersFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to start creating the parameters field for.
    INTEGER(INTG), INTENT(IN) :: cellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_ParametersFieldCreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ParametersFieldCreateStart(cellMLParametersFieldUserNumber,cellml,field,err,error,*999)

#endif

    EXITS("cmfe_CellML_ParametersFieldCreateStartNumber")
    RETURN
999 ERRORS("cmfe_CellML_ParametersFieldCreateStartNumber",err,error)
    EXITS("cmfe_CellML_ParametersFieldCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ParametersFieldCreateStartObj(cellML,cellMLParametersFieldUserNumber,field,err)
    !DLLEXPORT(cmfe_CellML_ParametersFieldCreateStartObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to start the creation of parameters field for.
    INTEGER(INTG), INTENT(IN) :: cellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ParametersFieldCreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML

    CALL CellML_ParametersFieldCreateStart(cellMLParametersFieldUserNumber,cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("cmfe_CellML_ParametersFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ParametersFieldCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ParametersFieldGetNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLParametersFieldUserNumber,err)
    !DLLEXPORT(cmfe_CellML_ParametersFieldGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the CellML parameters field for.
    INTEGER(INTG), INTENT(OUT) :: cellMLParametersFieldUserNumber !<On return, the user number of the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_ParametersFieldGetNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ParametersFieldGet(cellml,field,err,error,*999)
    cellMLParametersFieldUserNumber = field%userNumber

#else

    cellMLParametersFieldUserNumber=0

#endif

    EXITS("cmfe_CellML_ParametersFieldGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ParametersFieldGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ParametersFieldGetObj(cellML,field,err)
    !DLLEXPORT(cmfe_CellML_ParametersFieldGetObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the parameters field for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ParametersFieldGetObj",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML

    CALL CellML_ParametersFieldGet(cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("cmfe_CellML_ParametersFieldGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ParametersFieldGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldGetObj

  !
  !================================================================================================================================
  !

  !>Validiate and instantiate a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_GenerateNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(cmfe_CellML_GenerateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_CellML_GenerateNumber",err,error,*999)

    ASSERT_WITH_CELLML()
    
#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CELLML_GENERATE(cellml,err,error,*999)

#endif

    EXITS("cmfe_CellML_GenerateNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_GenerateNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_GenerateNumber

  !
  !================================================================================================================================
  !

  !>Validiate and instantiate a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_GenerateObj(cellML,err)
    !DLLEXPORT(cmfe_CellML_GenerateObj)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_GenerateObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CELLML_GENERATE(cellML%cellML,err,error,*999)

#endif

    EXITS("cmfe_CellML_GenerateObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_GenerateObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_GenerateObj


!!==================================================================================================================================
!!
!! Computation
!!
!!==================================================================================================================================


  !>Returns the number of computation nodes in the world communicator identified by user number.
  SUBROUTINE cmfe_ComputationEnvironment_NumberOfWorldNodesGetNumber(contextUserNumber,numberOfWorldNodes,err)
    !DLLEXPORT(cmfe_ComputationEnvironment_NumberOfWorldNodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(OUT) :: numberOfWorldNodes !<On return, the number of computation nodes in the world communicator.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context

    ENTERS("cmfe_ComputationEnvironment_NumberOfWorldNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL ComputationEnvironment_NumberOfWorldNodesGet(computationEnvironment,numberOfWorldNodes,err,error,*999)

    EXITS("cmfe_ComputationEnvironment_NumberOfWorldNodesGetNumber")
    RETURN
999 ERRORS("cmfe_ComputationEnvironment_NumberOfWorldNodesGetNumber",err,error)
    EXITS("cmfe_ComputationEnvironment_NumberOfWorldNodesGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationEnvironment_NumberOfWorldNodesGetNumber
  
  !  
  !================================================================================================================================
  !
  
  !>Returns the number of computation nodes in the world communicator identified by object.
  SUBROUTINE cmfe_ComputationEnvironment_NumberOfWorldNodesGetObj(computationEnvironment,numberOfWorldNodes,err)
    !DLLEXPORT(cmfe_ComputationEnvironment_NumberOfWorldNodesGetObj)

    !Argument variables
    TYPE(cmfe_ComputationEnvironmentType), INTENT(IN) :: computationEnvironment !<The computation environment to get the number of nodes in the world communicator for.
    INTEGER(INTG), INTENT(OUT) :: numberOfWorldNodes !<On return, the number of computation nodes in the world communicator.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ComputationEnvironment_NumberOfWorldNodesGetObj",err,error,*999)

    CALL ComputationEnvironment_NumberOfWorldNodesGet(computationEnvironment%computationEnvironment,numberOfWorldNodes, &
      & err,error,*999)

    EXITS("cmfe_ComputationEnvironment_NumberOfWorldNodesGetObj")
    RETURN
999 ERRORS("cmfe_ComputationEnvironment_NumberOfWorldNodesGetObj",err,error)
    EXITS("cmfe_ComputationEnvironment_NumberOfWorldNodesGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationEnvironment_NumberOfWorldNodesGetObj
  
  !  
  !================================================================================================================================
  !

  !>Returns the current world communicator for the computation environment identified by user number.
  SUBROUTINE cmfe_ComputationEnvironment_WorldCommunicatorGetNumber(contextUserNumber,worldCommunicator,err)
    !DLLEXPORT(cmfe_ComputationEnvironment_WorldCommunicatorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(OUT) :: worldCommunicator !<On return, the current world communicator.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context

    ENTERS("cmfe_ComputationEnvironment_WorldCommunicatorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL ComputationEnvironment_WorldCommunicatorGet(computationEnvironment,worldCommunicator,err,error,*999)

    EXITS("cmfe_ComputationEnvironment_WorldCommunicatorGetNumber")
    RETURN
999 ERRORS("cmfe_ComputationEnvironment_WorldCommunicatorGetNumber",err,error)
    EXITS("cmfe_ComputationEnvironment_WorldCommunicatorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationEnvironment_WorldCommunicatorGetNumber

  !  
  !================================================================================================================================
  !

  !>Returns the current world communicator for the computation environment indentified by object.
  SUBROUTINE cmfe_ComputationEnvironment_WorldCommunicatorGetObj(computationEnvironment,worldCommunicator,err)
    !DLLEXPORT(cmfe_ComputationEnvironment_WorldCommunicatorGetObj)

    !Argument variables
    TYPE(cmfe_ComputationEnvironmentType), INTENT(IN) :: computationEnvironment !<The computation environment to get the world communicator for.
    INTEGER(INTG), INTENT(OUT) :: worldCommunicator !<On return, the current world communicator.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ComputationEnvironment_WorldCommunicatorGetObj",err,error,*999)

    CALL ComputationEnvironment_WorldCommunicatorGet(computationEnvironment%computationEnvironment,worldCommunicator, &
      & err,error,*999)

    EXITS("cmfe_ComputationEnvironment_WorldCommunicatorGetObj")
    RETURN
999 ERRORS("cmfe_ComputationEnvironment_WorldCommunicatorGetObj",err,error)
    EXITS("cmfe_ComputationEnvironment_WorldCommunicatorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationEnvironment_WorldCommunicatorGetObj

  !
  !================================================================================================================================
  !

  !>Returns the computation node number in the world communicator identified by user number.
  SUBROUTINE cmfe_ComputationEnvironment_WorldNodeNumberGetNumber(contextUserNumber,worldNodeNumber,err)
    !DLLEXPORT(cmfe_ComputationEnvironment_WorldNodeNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(OUT) :: worldNodeNumber !<On return, the computation node number in the world communicator.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context

    ENTERS("cmfe_ComputationEnvironment_WorldNodeNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL ComputationEnvironment_WorldNodeNumberGet(computationEnvironment,worldNodeNumber,err,error,*999)

    EXITS("cmfe_ComputationEnvironment_WorldNodeNumberGetNumber")
    RETURN
999 ERRORS("cmfe_ComputationEnvironment_WorldNodeNumberGetNumber",err,error)
    EXITS("cmfe_ComputationEnvironment_WorldNodeNumberGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationEnvironment_WorldNodeNumberGetNumber
  
  !
  !================================================================================================================================
  !

  !>Returns the computation node number in the world communicator.
  SUBROUTINE cmfe_ComputationEnvironment_WorldNodeNumberGetObj(computationEnvironment,worldNodeNumber,err)
    !DLLEXPORT(cmfe_ComputationEnvironment_WorldNodeNumberGetObj)

    !Argument variables
    TYPE(cmfe_ComputationEnvironmentType), INTENT(IN) :: computationEnvironment !<The computation environment to get the node number in the world communicator for.
    INTEGER(INTG), INTENT(OUT) :: worldNodeNumber !<On return, the computation node number in the world communicator.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ComputationEnvironment_WorldNodeNumberGetObj",err,error,*999)

    CALL ComputationEnvironment_WorldNodeNumberGet(computationEnvironment%computationEnvironment,worldNodeNumber, &
      & err,error,*999)

    EXITS("cmfe_ComputationEnvironment_WorldNodeNumberGetObj")
    RETURN
999 ERRORS("cmfe_ComputationEnvironment_WorldNodeNumberGetObj",err,error)
    EXITS("cmfe_ComputationEnvironment_WorldNodeNumberGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationEnvironment_WorldNodeNumberGetObj
  
  !  
  !================================================================================================================================
  !

  !>Returns the world work group for the computation environment indentified by user number.
  SUBROUTINE cmfe_ComputationEnvironment_WorldWorkGroupGetNumber(contextUserNumber,worldWorkGroupUserNumber,err)
    !DLLEXPORT(cmfe_ComputationEnvironment_WorldWorkGroupGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(OUT) :: worldWorkGroupUserNumber !<On return, the world work group user number for the computation environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: worldWorkGroup

    ENTERS("cmfe_ComputationEnvironment_WorldWorkGroupGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(worldWorkGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL ComputationEnvironment_WorldWorkGroupGet(computationEnvironment,worldWorkGroup,err,error,*999)
    worldWorkGroupUserNumber=worldWorkGroup%userNumber

    EXITS("cmfe_ComputationEnvironment_WorldWorkGroupGetNumber")
    RETURN
999 ERRORS("cmfe_ComputationEnvironment_WorldWorkGroupGetNumber",err,error)
    EXITS("cmfe_ComputationEnvironment_WorldWorkGroupGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationEnvironment_WorldWorkGroupGetNumber

  !  
  !================================================================================================================================
  !

  !>Returns the world work group for the computation environment.
  SUBROUTINE cmfe_ComputationEnvironment_WorldWorkGroupGetObj(computationEnvironment,worldWorkGroup,err)
    !DLLEXPORT(cmfe_ComputationEnvironment_WorldWorkGroupGetObj)

    !Argument variables
    TYPE(cmfe_ComputationEnvironmentType), INTENT(IN) :: computationEnvironment !<The computation environment to get the world work group for.
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: worldWorkGroup !<On return, the world work group for the computation environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ComputationEnvironment_WorldWorkGroupGetObj",err,error,*999)

    CALL ComputationEnvironment_WorldWorkGroupGet(computationEnvironment%computationEnvironment,worldWorkGroup%workGroup, &
      & err,error,*999)

    EXITS("cmfe_ComputationEnvironment_WorldWorkGroupGetObj")
    RETURN
999 ERRORS("cmfe_ComputationEnvironment_WorldWorkGroupGetObj",err,error)
    EXITS("cmfe_ComputationEnvironment_WorldWorkGroupGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationEnvironment_WorldWorkGroupGetObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a computation work group specified by number.
  SUBROUTINE cmfe_WorkGroup_CreateStartNumber(workGroupUserNumber,contextUserNumber,parentWorkGroupUserNumber,err)
    !DLLEXPORT(cmfe_WorkGroup_CreateStartNumber)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: parentWorkGroupUserNumber !<The user number of the parent work group to start the creation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: parentWorkGroup,workGroup 

    ENTERS("cmfe_WorkGroup_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(parentWorkGroup)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,parentWorkGroupUserNumber,parentWorkGroup,err,error,*999)
    CALL WorkGroup_CreateStart(workGroupUserNumber,parentWorkGroup,workGroup,err,error,*999)

    EXITS("cmfe_WorkGroup_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_CreateStartNumber

  !  
  !================================================================================================================================
  !

  !>Start the creation of a computation work group specified by object under a parent work group
  SUBROUTINE cmfe_WorkGroup_CreateStartObj(userNumber,parentWorkGroup,workGroup,err)
    !DLLEXPORT(cmfe_WorkGroup_CreateStartObj)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of computation nodes to create
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: parentWorkGroup !<The parent work group to create the work group under
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: workGroup !<On exit, the created work group. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_WorkGroup_CreateStartObj",err,error,*999)

    CALL WorkGroup_CreateStart(userNumber,parentWorkGroup%workGroup,workGroup%workGroup,err,error,*999)

    EXITS("cmfe_WorkGroup_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of a computation work group specified by number.
  SUBROUTINE cmfe_WorkGroup_CreateFinishNumber(contextUserNumber,workGroupUserNumber,err)
    !DLLEXPORT(cmfe_WorkGroup_CreateFinishNumber)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("cmfe_WorkGroup_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_CreateFinish(workGroup,err,error,*999)

    EXITS("cmfe_WorkGroup_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a computation work group specified by object.
  SUBROUTINE cmfe_WorkGroup_CreateFinishObj(workGroup,err)
    !DLLEXPORT(cmfe_WorkGroup_CreateFinishObj)
    
    !Argument Variables
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_WorkGroup_CreateFinishObj",err,error,*999)

    CALL WorkGroup_CreateFinish(workGroup%workGroup,err,error,*999)

    EXITS("cmfe_WorkGroup_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Destroy a work group specified by number.
  SUBROUTINE cmfe_WorkGroup_DestroyNumber(contextUserNumber,workGroupUserNumber,err)
    !DLLEXPORT(cmfe_WorkGroup_DestroyNumber)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("cmfe_WorkGroup_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_Destroy(workGroup,err,error,*999)

    EXITS("cmfe_WorkGroup_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy a work group specified by object.
  SUBROUTINE cmfe_WorkGroup_DestroyObj(workGroup,err)
    !DLLEXPORT(cmfe_WorkGroup_DestroyObj)
    
    !Argument Variables
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_WorkGroup_DestroyObj",err,error,*999)

    CALL WorkGroup_Destroy(workGroup%workGroup,err,error,*999)

    EXITS("cmfe_WorkGroup_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the group communicator for a work group specified by a user number.
  SUBROUTINE cmfe_WorkGroup_GroupCommunicatorGetNumber(contextUserNumber,workGroupUserNumber,groupCommunicator,err)
    !DLLEXPORT(cmfe_WorkGroup_GroupCommunicatorGetNumber)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to get the group communicator for.
    INTEGER(INTG), INTENT(OUT) :: groupCommunicator !<On return, the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("cmfe_WorkGroup_GroupCommunicatorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_GroupCommunicatorGet(workGroup,groupCommunicator,err,error,*999)

    EXITS("cmfe_WorkGroup_GroupCommunicatorGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_GroupCommunicatorGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_GroupCommunicatorGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the group communicator for a work group specified by an object.
  SUBROUTINE cmfe_WorkGroup_GroupCommunicatorGetObj(workGroup,groupCommunicator,err)
    !DLLEXPORT(cmfe_WorkGroup_GroupCommunicatorGetObj)
    
    !Argument Variables
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to get the group communicator for
    INTEGER(INTG), INTENT(OUT) :: groupCommunicator !<On return, the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_WorkGroup_GroupCommunicatorGetObj",err,error,*999)

    CALL WorkGroup_GroupCommunicatorGet(workGroup%workGroup,groupCommunicator,err,error,*999)

    EXITS("cmfe_WorkGroup_GroupCommunicatorGetObj")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_GroupCommunicatorGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_GroupCommunicatorGetObj

  !
  !================================================================================================================================
  !

  !>Returns the group node number a work group specified by a user number.
  SUBROUTINE cmfe_WorkGroup_GroupNodeNumberGetNumber(contextUserNumber,workGroupUserNumber,groupNodeNumber,err)
    !DLLEXPORT(cmfe_WorkGroup_GroupNodeNumberGetNumber)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to get the group node number for.
    INTEGER(INTG), INTENT(OUT) :: groupNodeNumber !<On return, the node number in the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("cmfe_WorkGroup_GroupNodeNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_GroupNodeNumberGet(workGroup,groupNodeNumber,err,error,*999)

    EXITS("cmfe_WorkGroup_GroupNodeNumberGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_GroupNodeNumberGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_GroupNodeNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the group node number for a work group specified by an object.
  SUBROUTINE cmfe_WorkGroup_GroupNodeNumberGetObj(workGroup,groupNodeNumber,err)
    !DLLEXPORT(cmfe_WorkGroup_GroupNodeNumberGetObj)
    
    !Argument Variables
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to get the group node number for
    INTEGER(INTG), INTENT(OUT) :: groupNodeNumber !<On return, the node number in the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_WorkGroup_GroupNodeNumberGetObj",err,error,*999)

    CALL WorkGroup_GroupNodeNumberGet(workGroup%workGroup,groupNodeNumber,err,error,*999)

    EXITS("cmfe_WorkGroup_GroupNodeNumberGetObj")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_GroupNodeNumberGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_GroupNodeNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the character label a work group specified by a user number.
  SUBROUTINE cmfe_WorkGroup_LabelGetCNumber(contextUserNumber,workGroupUserNumber,label,err)
    !DLLEXPORT(cmfe_WorkGroup_LabelGetCNumber)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("cmfe_WorkGroup_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_LabelGet(workGroup,label,err,error,*999)

    EXITS("cmfe_WorkGroup_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a work group specified by an object.
  SUBROUTINE cmfe_WorkGroup_LabelGetCObj(workGroup,label,err)
    !DLLEXPORT(cmfe_WorkGroup_LabelGetCObj)
    
    !Argument Variables
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to get the label for
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_WorkGroup_LabelGetCObj",err,error,*999)

    CALL WorkGroup_LabelGet(workGroup%workGroup,label,err,error,*999)

    EXITS("cmfe_WorkGroup_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label a work group specified by a user number.
  SUBROUTINE cmfe_WorkGroup_LabelGetVSNumber(contextUserNumber,workGroupUserNumber,label,err)
    !DLLEXPORT(cmfe_WorkGroup_LabelGetVSNumber)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("cmfe_WorkGroup_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_LabelGet(workGroup,label,err,error,*999)

    EXITS("cmfe_WorkGroup_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a work group specified by an object.
  SUBROUTINE cmfe_WorkGroup_LabelGetVSObj(workGroup,label,err)
    !DLLEXPORT(cmfe_WorkGroup_LabelGetVSObj)
    
    !Argument Variables
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to get the label for
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_WorkGroup_LabelGetVSObj",err,error,*999)

    CALL WorkGroup_LabelGet(workGroup%workGroup,label,err,error,*999)

    EXITS("cmfe_WorkGroup_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label a work group specified by a user number.
  SUBROUTINE cmfe_WorkGroup_LabelSetCNumber(contextUserNumber,workGroupUserNumber,label,err)
    !DLLEXPORT(cmfe_WorkGroup_LabelSetCNumber)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("cmfe_WorkGroup_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_LabelSet(workGroup,label,err,error,*999)

    EXITS("cmfe_WorkGroup_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a work group specified by an object.
  SUBROUTINE cmfe_WorkGroup_LabelSetCObj(workGroup,label,err)
    !DLLEXPORT(cmfe_WorkGroup_LabelSetCObj)
    
    !Argument Variables
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to set the label for
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_WorkGroup_LabelSetCObj",err,error,*999)

    CALL WorkGroup_LabelSet(workGroup%workGroup,label,err,error,*999)

    EXITS("cmfe_WorkGroup_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label a work group specified by a user number.
  SUBROUTINE cmfe_WorkGroup_LabelSetVSNumber(contextUserNumber,workGroupUserNumber,label,err)
    !DLLEXPORT(cmfe_WorkGroup_LabelSetVSNumber)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("cmfe_WorkGroup_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_LabelSet(workGroup,label,err,error,*999)

    EXITS("cmfe_WorkGroup_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a work group specified by an object.
  SUBROUTINE cmfe_WorkGroup_LabelSetVSObj(workGroup,label,err)
    !DLLEXPORT(cmfe_WorkGroup_LabelSetVSObj)
    
    !Argument Variables
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to set the label for
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_WorkGroup_LabelSetVSObj",err,error,*999)

    CALL WorkGroup_LabelSet(workGroup%workGroup,label,err,error,*999)

    EXITS("cmfe_WorkGroup_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the group number of nodes in a work group specified by a user number.
  SUBROUTINE cmfe_WorkGroup_NumberOfGroupNodesGetNumber(contextUserNumber,workGroupUserNumber,numberOfGroupNodes,err)
    !DLLEXPORT(cmfe_WorkGroup_NumberOfGroupNodesGetNumber)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to get the group number of nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGroupNodes !<On return, the number of nodes in the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("cmfe_WorkGroup_NumberOfGroupNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_NumberOfGroupNodesGet(workGroup,numberOfGroupNodes,err,error,*999)

    EXITS("cmfe_WorkGroup_NumberOfGroupNodesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_NumberOfGroupNodesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_NumberOfGroupNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the group number of nodes for a work group specified by an object.
  SUBROUTINE cmfe_WorkGroup_NumberOfGroupNodesGetObj(workGroup,numberOfGroupNodes,err)
    !DLLEXPORT(cmfe_WorkGroup_NumberOfGroupNodesGetObj)
    
    !Argument Variables
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to get the group number of nodes for
    INTEGER(INTG), INTENT(OUT) :: numberOfGroupNodes !<On return, the number of nodes in the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_WorkGroup_NumberOfGroupNodesGetObj",err,error,*999)

    CALL WorkGroup_NumberOfGroupNodesGet(workGroup%workGroup,numberOfGroupNodes,err,error,*999)

    EXITS("cmfe_WorkGroup_NumberOfGroupNodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_NumberOfGroupNodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_NumberOfGroupNodesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/Changes the group number of nodes for a work group specified by a user number.
  SUBROUTINE cmfe_WorkGroup_NumberOfGroupNodesSetNumber(contextUserNumber,workGroupUserNumber,numberOfGroupNodes,err)
    !DLLEXPORT(cmfe_WorkGroup_NumberOfGroupNodesSetNumber)
    
    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to set the group number of nodes for.
    INTEGER(INTG), INTENT(IN) :: numberOfGroupNodes !<The number of nodes in the group communicator to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("cmfe_WorkGroup_NumberOfGroupNodesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_NumberOfGroupNodesSet(workGroup,numberOfGroupNodes,err,error,*999)

    EXITS("cmfe_WorkGroup_NumberOfGroupNodesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_NumberOfGroupNodesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_NumberOfGroupNodesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/Changes the group number of nodes for a work group specified by an object.
  SUBROUTINE cmfe_WorkGroup_NumberOfGroupNodesSetObj(workGroup,numberOfGroupNodes,err)
    !DLLEXPORT(cmfe_WorkGroup_NumberOfGroupNodesSetObj)
    
    !Argument Variables
    TYPE(cmfe_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to set the group number of nodes for
    INTEGER(INTG), INTENT(IN) :: numberOfGroupNodes !<The number of nodes in the group communicator to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_WorkGroup_NumberOfGroupNodesSetObj",err,error,*999)

    CALL WorkGroup_NumberOfGroupNodesSet(workGroup%workGroup,numberOfGroupNodes,err,error,*999)

    EXITS("cmfe_WorkGroup_NumberOfGroupNodesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_WorkGroup_NumberOfGroupNodesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_WorkGroup_NumberOfGroupNodesSetObj

!!==================================================================================================================================
!!
!! ContextRoutines
!!
!!==================================================================================================================================


  !>Returns the computation environment for an OpenCMISS context given by user number.
  SUBROUTINE cmfe_Context_ComputationEnvironmentGetNumber(contextUserNumber,computationEnvironment,err)
    !DLLEXPORT(cmfe_Context_ComputationEnvironmentGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The OpenCMISS context user number to get the computation environment for.
    TYPE(cmfe_ComputationEnvironmentType), INTENT(INOUT) :: computationEnvironment !<On return, the computation environment for the OpenCMISS context.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context

    ENTERS("cmfe_Context_ComputationEnvironmentGetNumber",err,error,*999)
    
    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment%computationEnvironment,err,error,*999)

    EXITS("cmfe_Context_ComputationEnvironmentGetNumber")
    RETURN
999 ERRORS("cmfe_Context_ComputationEnvironmentGetNumber",err,error)
    EXITS("cmfe_Context_ComputationEnvironmentGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_ComputationEnvironmentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a computation environment object for an OpenCMISS context object.
  SUBROUTINE cmfe_Context_ComputationEnvironmentGetObj(context,computationEnvironment,err)
    !DLLEXPORT(cmfe_Context_ComputationEnvironmentGetObj)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The OpenCMISS context to get the computation environment for
    TYPE(cmfe_ComputationEnvironmentType), INTENT(INOUT) :: computationEnvironment !<On return, the computation environment for the context
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Context_ComputationEnvironmentGetObj",err,error,*999)
    
    CALL Context_ComputationEnvironmentGet(context%context,computationEnvironment%computationEnvironment,err,error,*999)

    EXITS("cmfe_Context_ComputationEnvironmentGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Context_ComputationEnvironmentGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_ComputationEnvironmentGetObj

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for an OpenCMISS context specified by user number.
  SUBROUTINE cmfe_Context_RandomSeedsGetNumber0(contextUserNumber,randomSeed,err)
    !DLLEXPORT(cmfe_Context_RandomSeedsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to get the random seeds for.
    INTEGER(INTG), INTENT(OUT) :: randomSeed !<On return, the random seed.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: randomSeeds(1)
    TYPE(ContextType), POINTER :: context

    ENTERS("cmfe_Context_RandomSeedsGetNumber0",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RandomSeedsGet(context,randomSeeds,err,error,*999)
    randomSeed=randomSeeds(1)

    EXITS("cmfe_Context_RandomSeedsGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Context_RandomSeedsGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_RandomSeedsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for an OpenCMISS context specified by user number.
  SUBROUTINE cmfe_Context_RandomSeedsGetNumber1(contextUserNumber,randomSeeds,err)
    !DLLEXPORT(cmfe_Context_RandomSeedsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to get the random seeds for.
    INTEGER(INTG), INTENT(OUT) :: randomSeeds(:) !<On return, the random seeds.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context

    ENTERS("cmfe_Context_RandomSeedsGetNumber1",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RandomSeedsGet(context,randomSeeds,err,error,*999)

    EXITS("cmfe_Context_RandomSeedsGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Context_RandomSeedsGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_RandomSeedsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for an OpenCMISS context specified by object.
  SUBROUTINE cmfe_Context_RandomSeedsGetObj0(context,randomSeed,err)
    !DLLEXPORT(cmfe_Context_RandomSeedsGetObj0)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The context to get the random seeds for.
    INTEGER(INTG), INTENT(OUT) :: randomSeed !<On return, the random seed.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: randomSeeds(1)

    ENTERS("cmfe_Context_RandomSeedsGetObj0",err,error,*999)

    CALL Context_RandomSeedsGet(context%context,randomSeeds,err,error,*999)
    randomSeed=randomSeeds(1)

    EXITS("cmfe_Context_RandomSeedsGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Context_RandomSeedsGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_RandomSeedsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for an OpenCMISS context specified by object.
  SUBROUTINE cmfe_Context_RandomSeedsGetObj1(context,randomSeeds,err)
    !DLLEXPORT(cmfe_Context_RandomSeedsGetObj1)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The context to get the random seeds for.
    INTEGER(INTG), INTENT(OUT) :: randomSeeds(:) !<On return, the random seeds.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Context_RandomSeedsGetObj1",err,error,*999)

    CALL Context_RandomSeedsGet(context%context,randomSeeds,err,error,*999)

    EXITS("cmfe_Context_RandomSeedsGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Context_RandomSeedsGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_RandomSeedsGetObj1

  !
  !================================================================================================================================
  !

  !>Returns the size of the random seeds array for an OpenCMISS context specified by user number
  SUBROUTINE cmfe_Context_RandomSeedsSizeGetNumber(contextUserNumber,randomSeedsSize,err)
    !DLLEXPORT(cmfe_Context_RandomSeedsSizeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to get the random seeds size for.
    INTEGER(INTG), INTENT(OUT) :: randomSeedsSize !<On return, the size of the random seeds array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context

    ENTERS("cmfe_Context_RandomSeedsSizeGetNumber",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)     
    CALL Context_RandomSeedsSizeGet(context,randomSeedsSize,err,error,*999)

    EXITS("cmfe_Context_RandomSeedsSizeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Context_RandomSeedsSizeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_RandomSeedsSizeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the size of the random seeds array for an OpenCMISS context specified by object
  SUBROUTINE cmfe_Context_RandomSeedsSizeGetObj(context,randomSeedsSize,err)
    !DLLEXPORT(cmfe_Context_RandomSeedsSizeGetObj)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The context to get the random seeds size for.
    INTEGER(INTG), INTENT(OUT) :: randomSeedsSize !<On return, the size of the random seeds array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Context_RandomSeedsSizeGetObj",err,error,*999)

    CALL Context_RandomSeedsSizeGet(context%context,randomSeedsSize,err,error,*999)

    EXITS("cmfe_Context_RandomSeedsSizeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Context_RandomSeedsSizeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_RandomSeedsSizeGetObj

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for an OpenCMISS context specified by user number.
  SUBROUTINE cmfe_Context_RandomSeedsSetNumber0(contextUserNumber,randomSeed,err)
    !DLLEXPORT(cmfe_Context_RandomSeedsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to set the random seeds for.
    INTEGER(INTG), INTENT(IN) :: randomSeed !<The random seed to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context

    ENTERS("cmfe_Context_RandomSeedsSetNumber0",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)     
    CALL Context_RandomSeedsSet(context,[randomSeed],err,error,*999)

    EXITS("cmfe_Context_RandomSeedsSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Context_RandomSeedsSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_RandomSeedsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for an OpenCMISS context specified by user number
  SUBROUTINE cmfe_Context_RandomSeedsSetNumber1(contextUserNumber,randomSeeds,err)
    !DLLEXPORT(cmfe_Context_RandomSeedsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to set the random seeds for.
    INTEGER(INTG), INTENT(IN) :: randomSeeds(:) !<The random seeds to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context

    ENTERS("cmfe_Context_RandomSeedsSetNumber1",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)     
    CALL Context_RandomSeedsSet(context,randomSeeds,err,error,*999)

    EXITS("cmfe_Context_RandomSeedsSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Context_RandomSeedsSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_RandomSeedsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for an OpenCMISS context specified by object.
  SUBROUTINE cmfe_Context_RandomSeedsSetObj0(context,randomSeed,err)
    !DLLEXPORT(cmfe_Context_RandomSeedsSetObj0)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The context to set the random seeds for.
    INTEGER(INTG), INTENT(IN) :: randomSeed !<The random seed to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Context_RandomSeedsSetObj0",err,error,*999)

    CALL Context_RandomSeedsSet(context%context,[randomSeed],err,error,*999)

    EXITS("cmfe_Context_RandomSeedsSetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Context_RandomSeedsSetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_RandomSeedsSetObj0

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for an OpenCMISS context specified by object.
  SUBROUTINE cmfe_Context_RandomSeedsSetObj1(context,randomSeeds,err)
    !DLLEXPORT(cmfe_Context_RandomSeedsSetObj1)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The context to set the random seeds for.
    INTEGER(INTG), INTENT(IN) :: randomSeeds(:) !<The random seeds to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Context_RandomSeedsSetObj1",err,error,*999)

    CALL Context_RandomSeedsSet(context%context,randomSeeds,err,error,*999)

    EXITS("cmfe_Context_RandomSeedsSetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Context_RandomSeedsSetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_RandomSeedsSetObj1

  !
  !================================================================================================================================
  !

  !>Returns the world region user number for an OpenCMISS context given by user number.
  SUBROUTINE cmfe_Context_WorldRegionGetNumber(contextUserNumber,worldRegionUserNumber,err)
    !DLLEXPORT(cmfe_Context_WorldRegionGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The OpenCMISS context user number to get the world region for.
    INTEGER(INTG), INTENT(OUT) :: worldRegionUserNumber !<On return, the world region user number for the OpenCMISS context.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: worldRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Context_WorldRegionGetNumber",err,error,*999)
    
    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(worldRegion)    
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Regions_WorldRegionGet(regions,worldRegion,err,error,*999)
    CALL Region_UserNumberGet(worldRegion,worldRegionUserNumber,err,error,*999)

    EXITS("cmfe_Context_WorldRegionGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Context_WorldRegionGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_WorldRegionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a world region object for an OpenCMISS context object.
  SUBROUTINE cmfe_Context_WorldRegionGetObj(context,worldRegion,err)
    !DLLEXPORT(cmfe_Context_WorldRegionGetObj)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The OpenCMISS context to get the world region for
    TYPE(cmfe_RegionType), INTENT(INOUT) :: worldRegion !<On return, the world region for the context
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Context_WorldRegionGetObj",err,error,*999)
    
    NULLIFY(regions)
    CALL Context_RegionsGet(context%context,regions,err,error,*999)
    CALL Regions_WorldRegionGet(regions,worldRegion%region,err,error,*999)

    EXITS("cmfe_Context_WorldRegionGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Context_WorldRegionGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_WorldRegionGetObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for an OpenCMISS context object.
  SUBROUTINE cmfe_Context_UserNumberGet(context,contextUserNumber,err)
    !DLLEXPORT(cmfe_Context_UserNumberGet)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The OpenCMISS context to get the user number for
    INTEGER(INTG), INTENT(OUT) :: contextUserNumber !<On return, the user number for the context
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Context_UserNumberGet",err,error,*999)
    
    CALL Context_UserNumberGet(context%context,contextUserNumber,err,error,*999)

    EXITS("cmfe_Context_UserNumberGet")
    RETURN
999 ERRORSEXITS("cmfe_Context_UserNumberGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Context_UserNumberGet

  
!!==================================================================================================================================
!!
!! CONTROL_LOOP_ROUTINES
!!
!!==================================================================================================================================

  !>Gets the continue loop status for a while control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_ContinueLoopGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,continueLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_ContinueLoopGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    LOGICAL, INTENT(OUT) :: continueLoop !<On return, the continue loop status of the while control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
 
    ENTERS("cmfe_ControlLoop_ContinueLoopGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_ContinueLoopGet(controlLoop,continueLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_ContinueLoopGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ContinueLoopGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ContinueLoopGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the continue loop status for a while control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_ContinueLoopGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,continueLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_ContinueLoopGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    LOGICAL, INTENT(OUT) :: continueLoop !<On return, the continue loop status of the while control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
 
    ENTERS("cmfe_ControlLoop_ContinueLoopGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_ContinueLoopGet(controlLoop,continueLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_ContinueLoopGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ContinueLoopGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ContinueLoopGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the continue loop status for a while control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_ContinueLoopGetObj(controlLoop,continueLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_ContinueLoopGetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the continue loop status for
    LOGICAL, INTENT(OUT) :: continueLoop !<On return, the continue loop status of the while control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_ContinueLoopGetObj",err,error,*999)

    CALL ControlLoop_ContinueLoopGet(controlLoop%controlLoop,continueLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_ContinueLoopGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ContinueLoopGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ContinueLoopGetObj

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_CurrentTimesGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,currentTime, &
    & timeIncrement,err)
    !DLLEXPORT(cmfe_ControlLoop_CurrentTimesGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
 
    ENTERS("cmfe_ControlLoop_CurrentTimesGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_CurrentTimesGet(controlLoop,currentTime,timeIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_CurrentTimesGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_CurrentTimesGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_CurrentTimesGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_CurrentTimesGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,currentTime, &
    & timeIncrement,err)
    !DLLEXPORT(cmfe_ControlLoop_CurrentTimesGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
 
    ENTERS("cmfe_ControlLoop_CurrentTimesGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_CurrentTimesGet(controlLoop,currentTime,timeIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_CurrentTimesGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_CurrentTimesGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_CurrentTimesGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_CurrentTimesGetObj(controlLoop,currentTime,timeIncrement,err)
    !DLLEXPORT(cmfe_ControlLoop_CurrentTimesGetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the current times for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_CurrentTimesGetObj",err,error,*999)

    CALL ControlLoop_CurrentTimesGet(controlLoop%controlLoop,currentTime,timeIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_CurrentTimesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_CurrentTimesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_CurrentTimesGetObj

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_DestroyNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,err)
    !DLLEXPORT(cmfe_ControlLoop_DestroyNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_DestroyNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_Destroy(controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_DestroyNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_DestroyNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_DestroyNumber0

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_DestroyNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,err)
    !DLLEXPORT(cmfe_ControlLoop_DestroyNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_DestroyNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_Destroy(controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_DestroyNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_DestroyNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_DestroyNumber1

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_DestroyObj(controlLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_DestroyObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_DestroyObj",err,error,*999)

    CALL ControlLoop_Destroy(controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber00(contextUserNumber,problemUserNumber,controlLoopRootIdentifier, &
    & controlLoopIdentifier,controlLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_ControlLoopGetNumber00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: rootControlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
 
    ENTERS("cmfe_ControlLoop_ControlLoopGetNumber00",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(rootControlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopRootIdentifier,rootControlLoop,err,error,*999)
    CALL ControlLoop_Get(rootControlLoop,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_ControlLoopGetNumber00")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetNumber00",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber00

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber10(contextUserNumber,problemUserNumber,controlLoopRootIdentifiers, &
    & controlLoopIdentifier,controlLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_ControlLoopGetNumber10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: rootControlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_ControlLoopGetNumber10",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(rootControlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopRootIdentifiers,rootControlLoop,err,error,*999)
    CALL ControlLoop_Get(rootControlLoop,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_ControlLoopGetNumber10")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetNumber10",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber10

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber01(contextUserNumber,problemUserNumber,controlLoopRootIdentifier, &
    & controlLoopIdentifiers,controlLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_ControlLoopGetNumber01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: rootControlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_ControlLoopGetNumber01",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(rootControlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopRootIdentifier,rootControlLoop,err,error,*999)
    CALL ControlLoop_Get(rootControlLoop,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_ControlLoopGetNumber01")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetNumber01",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber01

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber11(contextUserNumber,problemUserNumber,controlLoopRootIdentifiers, &
    & controlLoopIdentifiers,controlLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_ControlLoopGetNumber11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: rootControlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_ControlLoopGetNumber11",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(rootControlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopRootIdentifiers,rootControlLoop,err,error,*999)
    CALL ControlLoop_Get(rootControlLoop,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_ControlLoopGetNumber11")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetNumber11",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber11

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetObj0(controlLoopRoot,controlLoopIdentifier,controlLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_ControlLoopGetObj0)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_ControlLoopGetObj0",err,error,*999)

    CALL ControlLoop_Get(controlLoopRoot%controlLoop,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_ControlLoopGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifiers from the control loop root.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetObj1(controlLoopRoot,controlLoopIdentifiers,controlLoop,err)
    !DLLEXPORT(cmfe_ControlLoop_ControlLoopGetObj1)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(INOUT) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(cmfe_ControlLoopType), INTENT(OUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_ControlLoopGetObj1",err,error,*999)

    CALL ControlLoop_Get(controlLoopRoot%controlLoop,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_ControlLoopGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a fixed control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_FixedInputSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,inputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_FixedInputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the input frequency for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_FixedInputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_FixedOutputSet(controlLoop,inputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_FixedInputSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_FixedInputSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_FixedInputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a fixed control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_FixedInputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,inputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_FixedInputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the input frequency for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_FixedInputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_FixedInputSet(controlLoop,inputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_FixedInputSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_FixedInputSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_FixedInputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a fixed control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_FixedInputSetObj(controlLoop,inputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_FixedInputSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the input frequency for.
    INTEGER(INTG), INTENT(IN) ::  inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_FixedInputSetObj",err,error,*999)

    CALL ControlLoop_FixedInputSet(controlLoop%controlLoop,inputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_FixedInputSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_FixedInputSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_ControlLoop_FixedInputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a fixed control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_FixedOutputSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,outputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_FixedOutputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_FixedOutputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_FixedOutputSet(controlLoop,outputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_FixedOutputSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_FixedOutputSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_FixedOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a fixed control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_FixedOutputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,outputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_FixedOutputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_FixedOutputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_FixedOutputSet(controlLoop,outputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_FixedOutputSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_FixedOutputSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_FixedOutputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a fixed control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_FixedOutputSetObj(controlLoop,outputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_FixedOutputSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_FixedOutputSetObj",err,error,*999)

    CALL ControlLoop_FixedOutputSet(controlLoop%controlLoop,outputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_FixedOutputSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_FixedOutputSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_ControlLoop_FixedOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_IterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,startIteration, &
    & stopIteration,iterationIncrement,err)
    !DLLEXPORT(cmfe_ControlLoop_IterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_IterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_IterationsSet(controlLoop,startIteration,stopIteration,iterationIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_IterationsSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_IterationsSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_IterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_IterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,startIteration, &
    & stopIteration,iterationIncrement,err)
    !DLLEXPORT(cmfe_ControlLoop_IterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_IterationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_IterationsSet(controlLoop,startIteration,stopIteration,iterationIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_IterationsSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_IterationsSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_IterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_IterationsSetObj(controlLoop,startIteration,stopIteration,iterationIncrement,err)
    !DLLEXPORT(cmfe_ControlLoop_IterationsSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_IterationsSetObj",err,error,*999)

    CALL ControlLoop_IterationsSet(controlLoop%controlLoop,startIteration,stopIteration,iterationIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_IterationsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_IterationsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_IterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the iteration number for control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_IterationNumberGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & iterationNumber,err)
    !DLLEXPORT(cmfe_ControlLoop_IterationNumberGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the iteration number for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: iterationNumber !<On exit, the iteration number of the control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_IterationNumberGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_IterationNumberGet(controlLoop,iterationNumber,err,error,*999)

    EXITS("cmfe_ControlLoop_IterationNumberGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_IterationNumberGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_IterationNumberGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the iteration number for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_IterationNumberGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & iterationNumber,err)
    !DLLEXPORT(cmfe_ControlLoop_IterationNumberGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the iteration number for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: iterationNumber !<On return, the iteration number of the control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_IterationNumberGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_IterationNumberGet(controlLoop,iterationNumber,err,error,*999)

    EXITS("cmfe_ControlLoop_IterationNumberGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_IterationNumberGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_IterationNumberGetNumber1

  !================================================================================================================================
  !

  !>Returns the iteration number for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_IterationNumberGetObj(controlLoop,iterationNumber,err)
    !DLLEXPORT(cmfe_ControlLoop_IterationNumberGetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to get the iteration number for.
    INTEGER(INTG), INTENT(OUT) :: iterationNumber !<On return, the iteration number for the control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_IterationNumberGetObj",err,error,*999)

    CALL ControlLoop_IterationNumberGet(controlLoop%controlLoop,iterationNumber,err,error,*999)

    EXITS("cmfe_ControlLoop_IterationNumberGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_IterationNumberGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_IterationNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelGetCNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelGetCNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_LabelGetCNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_LabelGet(controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelGetCNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetCNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetCNumber0

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelGetCNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelGetCNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_LabelGetCNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_LabelGet(controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelGetCNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetCNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetCNumber1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_LabelGetCObj(controlLoop,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelGetCObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_LabelGetCObj",err,error,*999)

    CALL ControlLoop_LabelGet(controlLoop%controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelGetVSNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelGetVSNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_LabelGetVSNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_LabelGet(controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelGetVSNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetVSNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetVSNumber0

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelGetVSNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelGetVSNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_LabelGetVSNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_LabelGet(controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelGetVSNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetVSNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetVSNumber1

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_LabelGetVSObj(controlLoop,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelGetVSObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_LabelGetVSObj",err,error,*999)

    CALL ControlLoop_LabelGet(controlLoop%controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelSetCNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelSetCNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_LabelSetCNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_LabelSet(controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelSetCNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetCNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetCNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelSetCNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelSetCNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_LabelSetCNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_LabelSet(controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelSetCNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetCNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetCNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_LabelSetCObj(controlLoop,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelSetCObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_LabelSetCObj",err,error,*999)

    CALL ControlLoop_LabelSet(controlLoop%controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelSetVSNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelSetVSNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_LabelSetVSNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_LabelSet(controlLoop,CHAR(label),err,error,*999)

    EXITS("cmfe_ControlLoop_LabelSetVSNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetVSNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetVSNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelSetVSNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelSetVSNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_LabelSetVSNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_LabelSet(controlLoop,CHAR(label),err,error,*999)

    EXITS("cmfe_ControlLoop_LabelSetVSNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetVSNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetVSNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_LabelSetVSObj(controlLoop,label,err)
    !DLLEXPORT(cmfe_ControlLoop_LabelSetVSObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_LabelSetVSObj",err,error,*999)

    CALL ControlLoop_LabelSet(controlLoop%controlLoop,CHAR(label),err,error,*999)

    EXITS("cmfe_ControlLoop_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & maximumIterations,err)
    !DLLEXPORT(cmfe_ControlLoop_MaximumIterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_MaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_MaximumIterationsSet(controlLoop,maximumIterations,err,error,*999)

    EXITS("cmfe_ControlLoop_MaximumIterationsSetNumber0")
    RETURN
999 ERRORS("cmfe_ControlLoop_MaximumIterationsSetNumber0",err,error)
    EXITS("cmfe_ControlLoop_MaximumIterationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & maximumIterations,err)
    !DLLEXPORT(cmfe_ControlLoop_MaximumIterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_MaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_MaximumIterationsSet(controlLoop,maximumIterations,err,error,*999)

    EXITS("cmfe_ControlLoop_MaximumIterationsSetNumber1")
    RETURN
999 ERRORS("cmfe_ControlLoop_MaximumIterationsSetNumber1",err,error)
    EXITS("cmfe_ControlLoop_MaximumIterationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetObj(controlLoop,maximumIterations,err)
    !DLLEXPORT(cmfe_ControlLoop_MaximumIterationsSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_MaximumIterationsSetObj",err,error,*999)

    CALL ControlLoop_MaximumIterationsSet(controlLoop%controlLoop,maximumIterations,err,error,*999)

    EXITS("cmfe_ControlLoop_MaximumIterationsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_MaximumIterationsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a load control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_LoadOutputSet(controlLoop,outputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_LoadOutputSet)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_LoadOutputSet",err,error,*999)

    CALL ControlLoop_LoadOutputSet(controlLoop%controlLoop,outputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_LoadOutputSet")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LoadOutputSet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LoadOutputSet

  !
  !================================================================================================================================
  !

  !>Returns the absolute tolerance for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & absoluteTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_AbsoluteToleranceGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On return, the absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_AbsoluteToleranceGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_AbsoluteToleranceGet(controlLoop,absoluteTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_AbsoluteToleranceGetNumber0")
    RETURN
999 ERRORS("cmfe_ControlLoop_AbsoluteToleranceGetNumber0",err,error)
    EXITS("cmfe_ControlLoop_AbsoluteToleranceGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the absolute tolerance for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & absoluteTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_AbsoluteToleranceGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On return, the absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_AbsoluteToleranceGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_AbsoluteToleranceGet(controlLoop,absoluteTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_AbsoluteToleranceGetNumber1")
    RETURN
999 ERRORS("cmfe_ControlLoop_AbsoluteToleranceGetNumber1",err,error)
    EXITS("cmfe_ControlLoop_AbsoluteToleranceGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the absolute tolerance for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceGetObj(controlLoop,absoluteTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_AbsoluteToleranceGetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to get the absolute tolerance for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On return, the absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_AbsoluteToleranceGetObj",err,error,*999)

    CALL ControlLoop_AbsoluteToleranceGet(controlLoop%controlLoop,absoluteTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_AbsoluteToleranceGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_AbsoluteToleranceGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & absoluteTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_AbsoluteToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_AbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_AbsoluteToleranceSet(controlLoop,absoluteTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_AbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_ControlLoop_AbsoluteToleranceSetNumber0",err,error)
    EXITS("cmfe_ControlLoop_AbsoluteToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & absoluteTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_AbsoluteToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_AbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_AbsoluteToleranceSet(controlLoop,absoluteTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_AbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_ControlLoop_AbsoluteToleranceSetNumber1",err,error)
    EXITS("cmfe_ControlLoop_AbsoluteToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetObj(controlLoop,absoluteTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_AbsoluteToleranceSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the maximum iterations for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_AbsoluteToleranceSetObj",err,error,*999)

    CALL ControlLoop_AbsoluteToleranceSet(controlLoop%controlLoop,absoluteTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_AbsoluteToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_AbsoluteToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !
  
  !>Gets the number of iterations for a time control loop identified by user number.
  SUBROUTINE cmfe_ControlLoop_NumberOfIterationsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & numberOfIterations,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfIterationsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: numberOfIterations !<The number of iterations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_NumberOfIterationsGetNumber0",err,error,*999) 

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfIterationsGet(controlLoop,numberOfIterations,err,error,*999)
     
    EXITS("cmfe_ControlLoop_NumberOfIterationsGetNumber0")
    RETURN
999 ERRORS("cmfe_ControlLoop_NumberOfIterationsGetNumber0",err,error)
    EXITS("cmfe_ControlLoop_NumberOfIterationsGetNumber0") 
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfIterationsGetNumber0

  !
  !================================================================================================================================
  !
  
  !>Gets the number of iterations for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_NumberOfIterationsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & numberOfIterations,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfIterationsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to get the number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: numberOfIterations !<The number of iterations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_NumberOfIterationsGetNumber1",err,error,*999) 

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfIterationsGet(controlLoop,numberOfIterations,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfIterationsGetNumber1")  
    RETURN
999 ERRORS("cmfe_ControlLoop_NumberOfIterationsGetNumber1",err,error)   
    EXITS("cmfe_ControlLoop_NumberOfIterationsGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfIterationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the number of iterations for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_NumberOfIterationsGetObj(controlLoop,numberOfIterations,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfIterationsGetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: numberOfIterations !<The number of iterations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_NumberOfIterationsGetObj",err,error,*999)

    CALL ControlLoop_NumberOfIterationsGet(controlLoop%controlLoop,numberOfIterations,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfIterationsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfIterationsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfIterationsGetObj

  !
  !================================================================================================================================
  !
  
  !>Sets the number of iterations for a time control loop identified by user number.
  SUBROUTINE cmfe_ControlLoop_NumberOfIterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & numberOfIterations,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfIterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: numberOfIterations !<The number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_NumberOfIterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfIterationsSet(controlLoop,numberOfIterations,err,error,*999)
   
    EXITS("cmfe_ControlLoop_NumberOfIterationsSetNumber0") 
    RETURN
999 ERRORS("cmfe_ControlLoop_NumberOfIterationsSetNumber0",err,error) 
    EXITS("cmfe_ControlLoop_NumberOfIterationsSetNumber0")  
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfIterationsSetNumber0

  !
  !================================================================================================================================
  !
  
  !>Sets the number of iterations for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_NumberOfIterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & numberOfIterations,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfIterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to set the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: numberOfIterations !<The number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_NumberOfIterationsSetNumber1",err,error,*999) 

    NULLIFY(context)
    NULLIFY(problems)    
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfIterationsSet(controlLoop,numberOfIterations,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfIterationsSetNumber1") 
    RETURN
999 ERRORS("cmfe_ControlLoop_NumberOfIterationsSetNumber1",err,error)
    EXITS("cmfe_ControlLoop_NumberOfIterationsSetNumber1")   
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfIterationsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the number of iterations for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_NumberOfIterationsSetObj(controlLoop,numberOfIterations,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfIterationsSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: numberOfIterations !<The number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_NumberOfIterationsSetObj",err,error,*999)

    CALL ControlLoop_NumberOfIterationsSet(controlLoop%controlLoop,numberOfIterations,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfIterationsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfIterationsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & numberOfSubLoops,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfSubLoopsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfSubLoopsGet(controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & numberOfSubLoops,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfSubLoopsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfSubLoopsGet(controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetObj(controlLoop,numberOfSubLoops,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfSubLoopsGetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the number of sub loops for.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_NumberOfSubLoopsGetObj",err,error,*999)

    CALL ControlLoop_NumberOfSubLoopsGet(controlLoop%controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & numberOfSubLoops,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfSubLoopsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_NumberOfSubLoopsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfSubLoopsSet(controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & numberOfSubLoops,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfSubLoopsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_NumberOfSubLoopsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfSubLoopsSet(controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by an object. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetObj(controlLoop,numberOfSubLoops,err)
    !DLLEXPORT(cmfe_ControlLoop_NumberOfSubLoopsSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_NumberOfSubLoopsSetObj",err,error,*999)

    CALL ControlLoop_NumberOfSubLoopsSet(controlLoop%controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_OutputTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,outputType,err)
    !DLLEXPORT(cmfe_ControlLoop_OutputTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_OutputTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_OutputTypeGet(controlLoop,outputType,err,error,*999)

    EXITS("cmfe_ControlLoop_OutputTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_OutputTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,outputType,err)
    !DLLEXPORT(cmfe_ControlLoop_OutputTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_OutputTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_OutputTypeGet(controlLoop,outputType,err,error,*999)

    EXITS("cmfe_ControlLoop_OutputTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_OutputTypeGetObj(controlLoop,outputType,err)
    !DLLEXPORT(cmfe_ControlLoop_OutputTypeGetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_OutputTypeGetObj",err,error,*999)

    CALL ControlLoop_OutputTypeGet(controlLoop%controlLoop,outputType,err,error,*999)

    EXITS("cmfe_ControlLoop_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_OutputTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,outputType,err)
    !DLLEXPORT(cmfe_ControlLoop_OutputTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_OutputTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_OutputTypeSet(controlLoop,outputType,err,error,*999)

    EXITS("cmfe_ControlLoop_OutputTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_OutputTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,outputType,err)
    !DLLEXPORT(cmfe_ControlLoop_OutputTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_OutputTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_OutputTypeSet(controlLoop,outputType,err,error,*999)

    EXITS("cmfe_ControlLoop_OutputTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_OutputTypeSetObj(controlLoop,outputType,err)
    !DLLEXPORT(cmfe_ControlLoop_OutputTypeSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_OutputTypeSetObj",err,error,*999)

    CALL ControlLoop_OutputTypeSet(controlLoop%controlLoop,outputType,err,error,*999)

    EXITS("cmfe_ControlLoop_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_RelativeToleranceGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & relativeTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_RelativeToleranceGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On return, the relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_RelativeToleranceGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_RelativeToleranceGet(controlLoop,relativeTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_RelativeToleranceGetNumber0")
    RETURN
999 ERRORS("cmfe_ControlLoop_RelativeToleranceGetNumber0",err,error)
    EXITS("cmfe_ControlLoop_RelativeToleranceGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_RelativeToleranceGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_RelativeToleranceGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & relativeTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_RelativeToleranceGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On return, the relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_RelativeToleranceGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_RelativeToleranceGet(controlLoop,relativeTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_RelativeToleranceGetNumber1")
    RETURN
999 ERRORS("cmfe_ControlLoop_RelativeToleranceGetNumber1",err,error)
    EXITS("cmfe_ControlLoop_RelativeToleranceGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_RelativeToleranceGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_RelativeToleranceGetObj(controlLoop,relativeTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_RelativeToleranceGetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to get the relative tolerance for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On return, the relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_RelativeToleranceGetObj",err,error,*999)

    CALL ControlLoop_RelativeToleranceGet(controlLoop%controlLoop,relativeTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_RelativeToleranceGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_RelativeToleranceGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_RelativeToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_RelativeToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & relativeTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_RelativeToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_RelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_RelativeToleranceSet(controlLoop,relativeTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_RelativeToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_ControlLoop_RelativeToleranceSetNumber0",err,error)
    EXITS("cmfe_ControlLoop_RelativeToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_RelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_RelativeToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & relativeTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_RelativeToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_RelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_RelativeToleranceSet(controlLoop,relativeTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_RelativeToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_ControlLoop_RelativeToleranceSetNumber1",err,error)
    EXITS("cmfe_ControlLoop_RelativeToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_RelativeToleranceSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_RelativeToleranceSetObj(controlLoop,relativeTolerance,err)
    !DLLEXPORT(cmfe_ControlLoop_RelativeToleranceSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the maximum iterations for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_RelativeToleranceSetObj",err,error,*999)

    CALL ControlLoop_RelativeToleranceSet(controlLoop%controlLoop,relativeTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_RelativeToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_RelativeToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_RelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimeOutputSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,outputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_TimeOutputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_TimeOutputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_TimeOutputSet(controlLoop,outputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_TimeOutputSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeOutputSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimeOutputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,outputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_TimeOutputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_TimeOutputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_TimeOutputSet(controlLoop,outputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_TimeOutputSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeOutputSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeOutputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_TimeOutputSetObj(controlLoop,outputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_TimeOutputSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_TimeOutputSetObj",err,error,*999)

    CALL ControlLoop_TimeOutputSet(controlLoop%controlLoop,outputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_TimeOutputSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeOutputSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimeInputSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,inputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_TimeInputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the input frequency for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_TimeInputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_TimeInputSet(controlLoop,inputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_TimeInputSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeInputSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeInputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimeInputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,inputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_TimeInputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the input frequency for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_TimeInputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_TimeInputSet(controlLoop,inputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_TimeInputSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeInputSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeInputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_TimeInputSetObj(controlLoop,inputFrequency,err)
    !DLLEXPORT(cmfe_ControlLoop_TimeInputSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the input frequency for.
    INTEGER(INTG), INTENT(IN) ::  inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_TimeInputSetObj",err,error,*999)

    CALL ControlLoop_TimeInputSet(controlLoop%controlLoop,inputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_TimeInputSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeInputSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeInputSetObj

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimesGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,startTime,stopTime, &
    & timeIncrement,currentTime,currentLoopIteration,outputIterationNumber,inputIterationNumber,err)
    !DLLEXPORT(cmfe_ControlLoop_TimesGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: currentLoopIteration !<On return, the iteration number for the current loop.
    INTEGER(INTG), INTENT(OUT) :: outputIterationNumber !<On return, the output iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: inputIterationNumber !<On return, the inputer iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_TimesGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_CurrentTimeInformationGet(controlLoop,startTime,stopTime,currentTime,timeIncrement, &
      & currentLoopIteration,outputIterationNumber,inputIterationNumber,err,error,*999)

    EXITS("cmfe_ControlLoop_TimesGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimesGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,startTime,stopTime, &
    & timeIncrement,currentTime,currentLoopIteration,outputIterationNumber,inputIterationNumber,err)
    !DLLEXPORT(cmfe_ControlLoop_TimesGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: currentLoopIteration !<On return, the iteration number for the current loop.
    INTEGER(INTG), INTENT(OUT) :: outputIterationNumber !<On return, the output iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: inputIterationNumber !<On return, the inputer iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_TimesGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_CurrentTimeInformationGet(controlLoop,startTime,stopTime,currentTime,timeIncrement, &
      & currentLoopIteration,outputIterationNumber,inputIterationNumber,err,error,*999)

    EXITS("cmfe_ControlLoop_TimesGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_TimesGetObj(controlLoop,startTime,stopTime,timeIncrement,currentTime, &
    & currentLoopIteration,outputIterationNumber,inputIterationNumber,err)
    !DLLEXPORT(cmfe_ControlLoop_TimesGetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the times for.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: currentLoopIteration !<On return, the iteration number for the current loop.
    INTEGER(INTG), INTENT(OUT) :: outputIterationNumber !<On return, the output iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: inputIterationNumber !<On return, the inputer iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_TimesGetObj",err,error,*999)

    CALL ControlLoop_CurrentTimeInformationGet(controlLoop%controlLoop,startTime,stopTime,currentTime,timeIncrement, &
      & currentLoopIteration,outputIterationNumber,inputIterationNumber,err,error,*999)

    EXITS("cmfe_ControlLoop_TimesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimesSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,startTime,stopTime, &
    & timeIncrement,err)
    !DLLEXPORT(cmfe_ControlLoop_TimesSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_TimesSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_TimesSet(controlLoop,startTime,stopTime,timeIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_TimesSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimesSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,startTime,stopTime, &
    & timeIncrement,err)
    !DLLEXPORT(cmfe_ControlLoop_TimesSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_TimesSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_TimesSet(controlLoop,startTime,stopTime,timeIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_TimesSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_TimesSetObj(controlLoop,startTime,stopTime,timeIncrement,err)
    !DLLEXPORT(cmfe_ControlLoop_TimesSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_TimesSetObj",err,error,*999)

    CALL ControlLoop_TimesSet(controlLoop%controlLoop,startTime,stopTime,timeIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_TimesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_TypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,loopType,err)
    !DLLEXPORT(cmfe_ControlLoop_TypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OpenCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_TypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_TypeSet(controlLoop,loopType,err,error,*999)

    EXITS("cmfe_ControlLoop_TypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_TypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,loopType,err)
    !DLLEXPORT(cmfe_ControlLoop_TypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OpenCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_ControlLoop_TypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_TypeSet(controlLoop,loopType,err,error,*999)

    EXITS("cmfe_ControlLoop_TypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by an object. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_TypeSetObj(controlLoop,loopType,err)
    !DLLEXPORT(cmfe_ControlLoop_TypeSetObj)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OpenCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_TypeSetObj",err,error,*999)

    CALL ControlLoop_TypeSet(controlLoop%controlLoop,loopType,err,error,*999)

    EXITS("cmfe_ControlLoop_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TypeSetObj

!!==================================================================================================================================
!!
!! CoordinateRoutines
!!
!!==================================================================================================================================

  !>Finishes the creation of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_CreateFinishNumber(contextUserNumber,coordinateSystemUserNumber,err)
    !DLLEXPORT(cmfe_CoordinateSystem_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems
    
    ENTERS("cmfe_CoordinateSystem_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_CreateFinish(coordinateSystem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    EXITS("cmfe_CoordinateSystem_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_CreateFinishObj(coordinateSystem,err)
    !DLLEXPORT(cmfe_CoordinateSystem_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_CreateFinishObj",err,error,*999)

    CALL CoordinateSystem_CreateFinish(coordinateSystem%coordinateSystem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    EXITS("cmfe_CoordinateSystem_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_CreateStartNumber(contextUserNumber,coordinateSystemUserNumber,err)
    !DLLEXPORT(cmfe_CoordinateSystem_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_CreateStart(coordinateSystemUserNumber,coordinateSystems,coordinateSystem,err,error,*999)

    EXITS("cmfe_CoordinateSystem_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_CreateStartObj(coordinateSystemUserNumber,context,coordinateSystem,err)
    !DLLEXPORT(cmfe_CoordinateSystem_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The context to create the coordinate system for. 
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<On return, the coordinate system that has been created.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif

    NULLIFY(coordinateSystems)
    CALL Context_CoordinateSystemsGet(context%context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_CreateStart(coordinateSystemUserNumber,coordinateSystems,coordinateSystem%coordinateSystem, &
      & err,error,*999)

    EXITS("cmfe_CoordinateSystem_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_DestroyNumber(contextUserNumber,coordinateSystemUserNumber,err)
    !DLLEXPORT(cmfe_CoordinateSystem_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_Destroy(coordinateSystem,err,error,*999)

    EXITS("cmfe_CoordinateSystem_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_DestroyObj(coordinateSystem,err)
    !DLLEXPORT(cmfe_CoordinateSystem_DestroyObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_DestroyObj",err,error,*999)

    CALL CoordinateSystem_Destroy(coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_CoordinateSystem_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the dimension of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_DimensionGetNumber(contextUserNumber,coordinateSystemUserNumber,coordinateSystemDimension,err)
    !DLLEXPORT(cmfe_CoordinateSystem_DimensionGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemDimension !<On return, the dimension of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_DimensionGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_DimensionGet(coordinateSystem,coordinateSystemDimension,err,error,*999)

    EXITS("cmfe_CoordinateSystem_DimensionGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DimensionGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DimensionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dimension of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_DimensionGetObj(coordinateSystem,coordinateSystemDimension,err)
    !DLLEXPORT(cmfe_CoordinateSystem_DimensionGetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemDimension !<On return, the dimension of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_DimensionGetObj",err,error,*999)

    CALL CoordinateSystem_DimensionGet(coordinateSystem%coordinateSystem,coordinateSystemDimension,err,error,*999)

    EXITS("cmfe_CoordinateSystem_DimensionGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DimensionGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DimensionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_DimensionSetNumber(contextUserNumber,coordinateSystemUserNumber,coordinateSystemDimension,err)
    !DLLEXPORT(cmfe_CoordinateSystem_DimensionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_DimensionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_DimensionSet(coordinateSystem,coordinateSystemDimension,err,error,*999)

    EXITS("cmfe_CoordinateSystem_DimensionSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DimensionSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DimensionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_DimensionSetObj(coordinateSystem,coordinateSystemDimension,err)
    !DLLEXPORT(cmfe_CoordinateSystem_DimensionSetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT)  :: coordinateSystem !<The coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_DimensionSetObj",err,error,*999)

    CALL CoordinateSystem_DimensionSet(coordinateSystem%coordinateSystem,coordinateSystemDimension,err,error,*999)

    EXITS("cmfe_CoordinateSystem_DimensionSetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DimensionSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DimensionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the focus of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_FocusGetNumber(contextUserNumber,coordinateSystemUserNumber,focus,err)
    !DLLEXPORT(cmfe_CoordinateSystem_FocusGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: focus !<On return, the focus of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_FocusGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_FocusGet(coordinateSystem,focus,err,error,*999)

    EXITS("cmfe_CoordinateSystem_FocusGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_FocusGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_FocusGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the focus of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_FocusGetObj(coordinateSystem,focus,err)
    !DLLEXPORT(cmfe_CoordinateSystem_FocusGetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: focus !<On return, the focus of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_FocusGetObj",err,error,*999)

    CALL CoordinateSystem_FocusGet(coordinateSystem%coordinateSystem,focus,err,error,*999)

    EXITS("cmfe_CoordinateSystem_FocusGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_FocusGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_FocusGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the focus of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_FocusSetNumber(contextUserNumber,coordinateSystemUserNumber,focus,err)
    !DLLEXPORT(cmfe_CoordinateSystem_FocusSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_FocusSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_FocusSet(coordinateSystem,focus,err,error,*999)

    EXITS("cmfe_CoordinateSystem_FocusSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_FocusSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_FocusSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the focus of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_FocusSetObj(coordinateSystem,focus,err)
    !DLLEXPORT(cmfe_CoordinateSystem_FocusSetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_FocusSetObj",err,error,*999)

    CALL CoordinateSystem_FocusSet(coordinateSystem%coordinateSystem,focus,err,error,*999)

    EXITS("cmfe_CoordinateSystem_FocusSetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_FocusSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_FocusSetObj

  !
  !================================================================================================================================
  !

  !>Returns the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationGetNumber(contextUserNumber,coordinateSystemUserNumber, &
    & radialInterpolationType,err)
    !DLLEXPORT(cmfe_CoordinateSystem_RadialInterpolationGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the radial interpolation for.
    INTEGER(INTG), INTENT(OUT) :: radialInterpolationType !<On return, the radial interpolation type of the coordinate system \see OpenCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_RadialInterpolationGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_RadialInterpolationTypeGet(coordinateSystem,radialInterpolationType,err,error,*999)

    EXITS("cmfe_CoordinateSystem_RadialInterpolationGetNumber")
    RETURN
999 ERRORS("cmfe_CoordinateSystem_RadialInterpolationGetNumber",err,error)
    EXITS("cmfe_CoordinateSystem_RadialInterpolationGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationGetObj(coordinateSystem,radialInterpolationType,err)
    !DLLEXPORT(cmfe_CoordinateSystem_RadialInterpolationGetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to get the radial interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: radialInterpolationType !<On return, the radial interpolation type of the coordinate system. \see OpenCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_RadialInterpolationGetObj",err,error,*999)

    CALL CoordinateSystem_RadialInterpolationTypeGet(coordinateSystem%coordinateSystem,radialInterpolationType,err,error,*999)

    EXITS("cmfe_CoordinateSystem_RadialInterpolationGetObj")
    RETURN
999 ERRORS("cmfe_CoordinateSystem_RadialInterpolationGetObj",err,error)
    EXITS("cmfe_CoordinateSystem_RadialInterpolationGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationSetNumber(contextUserNumber,coordinateSystemUserNumber, &
    & radialInterpolationType,err)
    !DLLEXPORT(cmfe_CoordinateSystem_RadialInterpolationSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the radial interpolation for.
    INTEGER(INTG), INTENT(IN) :: radialInterpolationType !<The radial interpolation type of the coordinate system to set.\see OpenCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_RadialInterpolationSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_RadialInterpolationTypeSet(coordinateSystem,radialInterpolationType,err,error,*999)

    EXITS("cmfe_CoordinateSystem_RadialInterpolationSetNumber")
    RETURN
999 ERRORS("cmfe_CoordinateSystem_RadialInterpolationSetNumber",err,error)
    EXITS("cmfe_CoordinateSystem_RadialInterpolationSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationSetObj(coordinateSystem,radialInterpolationType,err)
    !DLLEXPORT(cmfe_CoordinateSystem_RadialInterpolationSetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT)  :: coordinateSystem !<The coordinate system to set the radial interpolation type for.
    INTEGER(INTG), INTENT(IN) :: radialInterpolationType !<The radial interpolation type of the coordinate system to set. \see OpenCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_RadialInterpolationSetObj",err,error,*999)

    CALL CoordinateSystem_RadialInterpolationTypeSet(coordinateSystem%coordinateSystem,radialInterpolationType,err,error,*999)

    EXITS("cmfe_CoordinateSystem_RadialInterpolationSetObj")
    RETURN
999 ERRORS("cmfe_CoordinateSystem_RadialInterpolationSetObj",err,error)
    EXITS("cmfe_CoordinateSystem_RadialInterpolationSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_TypeGetNumber(contextUserNumber,coordinateSystemUserNumber,coordinateSystemType_,err)
    !DLLEXPORT(cmfe_CoordinateSystem_TypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemType_ !<On return, the type of the coordinate system. \see OpenCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_TypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_TypeGet(coordinateSystem,coordinateSystemType_,err,error,*999)

    EXITS("cmfe_CoordinateSystem_TypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_TypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_TypeGetObj(coordinateSystem,coordinateSystemType_,err)
    !DLLEXPORT(cmfe_CoordinateSystem_TypeGetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemType_ !<On return, the type of the coordinate system. \see OpenCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_TypeGetObj",err,error,*999)

    CALL CoordinateSystem_TypeGet(coordinateSystem%coordinateSystem,coordinateSystemType_,err,error,*999)

    EXITS("cmfe_CoordinateSystem_TypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_TypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_TypeSetNumber(contextUserNumber,coordinateSystemUserNumber,coordinateSystemType_,err)
    !DLLEXPORT(cmfe_CoordinateSystem_TypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemType_ !<The type of the coordinate system to set. \see OpenCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_TypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_TypeSet(coordinateSystem,coordinateSystemType_,err,error,*999)

    EXITS("cmfe_CoordinateSystem_TypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_TypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_TypeSetObj(coordinateSystem,coordinateSystemType_,err)
    !DLLEXPORT(cmfe_CoordinateSystem_TypeSetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemType_ !<The type of the coordinate system to set. \see OpenCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_TypeSetObj",err,error,*999)

    CALL CoordinateSystem_TypeSet(coordinateSystem%coordinateSystem,coordinateSystemType_,err,error,*999)

    EXITS("cmfe_CoordinateSystem_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the origin of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_OriginGetNumber(contextUserNumber,coordinateSystemUserNumber,origin,err)
    !DLLEXPORT(cmfe_CoordinateSystem_OriginGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(coordinateIdx). On return, the orign of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_OriginGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_OriginGet(coordinateSystem,origin,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OriginGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OriginGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OriginGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the origin of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_OriginGetObj(coordinateSystem,origin,err)
    !DLLEXPORT(cmfe_CoordinateSystem_OriginGetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(coordinateIdx). On return, the origin of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_OriginGetObj",err,error,*999)

    CALL CoordinateSystem_OriginGet(coordinateSystem%coordinateSystem,origin,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OriginGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OriginGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OriginGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_OriginSetNumber(contextUserNumber,coordinateSystemUserNumber,origin,err)
    !DLLEXPORT(cmfe_CoordinateSystem_OriginSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<The orign of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_OriginSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_OriginSet(coordinateSystem,origin,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OriginSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OriginSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OriginSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_OriginSetObj(coordinateSystem,origin,err)
    !DLLEXPORT(cmfe_CoordinateSystem_OriginSetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<The origin of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_OriginSetObj",err,error,*999)

    CALL CoordinateSystem_OriginSet(coordinateSystem%coordinateSystem,origin,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OriginSetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OriginSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OriginSetObj

  !
  !================================================================================================================================
  !

  !>Returns the orientation of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_OrientationGetNumber(contextUserNumber,coordinateSystemUserNumber,orientation,err)
    !DLLEXPORT(cmfe_CoordinateSystem_OrientationGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_OrientationGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_OrientationGet(coordinateSystem,orientation,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OrientationGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OrientationGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OrientationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the orientation of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_OrientationGetObj(coordinateSystem,orientation,err)
    !DLLEXPORT(cmfe_CoordinateSystem_OrientationGetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_OrientationGetObj",err,error,*999)

    CALL CoordinateSystem_OrientationGet(coordinateSystem%coordinateSystem,orientation,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OrientationGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OrientationGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OrientationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the orientation of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_OrientationSetNumber(contextUserNumber,coordinateSystemUserNumber,orientation,err)
    !DLLEXPORT(cmfe_CoordinateSystem_OrientationSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_CoordinateSystem_OrientationSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_OrientationSet(coordinateSystem,orientation,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OrientationSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OrientationSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OrientationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the orientation of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_OrientationSetObj(coordinateSystem,orientation,err)
    !DLLEXPORT(cmfe_CoordinateSystem_OrientationSetObj)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_OrientationSetObj",err,error,*999)

    CALL CoordinateSystem_OrientationSet(coordinateSystem%coordinateSystem,orientation,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OrientationSetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OrientationSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OrientationSetObj

!!==================================================================================================================================
!!
!! DataPointsRoutines
!!
!!==================================================================================================================================

  !>Finishes the process of creating data points in a region for data points identified by user number.
  SUBROUTINE cmfe_DataPoints_CreateFinishNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,err)
    !DLLEXPORT(cmfe_DataPoints_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_CreateFinish(dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a data points in a region for data points identified by an object.
  SUBROUTINE cmfe_DataPoints_CreateFinishObj(dataPoints,err)
    !DLLEXPORT(cmfe_DataPoints_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_CreateFinishObj",err,error,*999)

    CALL DataPoints_CreateFinish(dataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating data points in a region for data points identified by user number.
  SUBROUTINE cmfe_DataPoints_CreateStartNumber(dataPointsUserNumber,contextUserNumber,regionUserNumber,numberOfDataPoints,err)
    !DLLEXPORT(cmfe_DataPoints_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points to create in the region.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL DataPoints_CreateStart(dataPointsUserNumber,region,numberOfDataPoints,dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a data points in a region for data points identified by an object.
  SUBROUTINE cmfe_DataPoints_CreateStartObj(dataPointsUserNumber,region,numberOfDataPoints,dataPoints,err)
    !DLLEXPORT(cmfe_DataPoints_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points to create in the region.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to start the creation of data points on.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    TYPE(cmfe_DataPointsType), INTENT(INOUT) :: dataPoints !<On return, the created data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_CreateStartObj",err,error,*999)

    CALL DataPoints_CreateStart(dataPointsUserNumber,region%region,numberOfDataPoints,dataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a data points in a region for data points identified by an object.
  SUBROUTINE cmfe_DataPoints_CreateStartInterfaceObj(dataPointsUserNumber,interface,numberOfDataPoints,dataPoints,err)
    !DLLEXPORT(cmfe_DataPoints_CreateStartInterfaceObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points to create in the interface.
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of data points on.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<On return, the created data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('dataPoints Create')
#endif

    CALL DataPoints_CreateStart(dataPointsUserNumber,interface%interface,numberOfDataPoints,dataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_CreateStartInterfaceObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_CreateStartInterfaceObj


  !
  !================================================================================================================================
  !

  !>Destroys the data points in a region for data points identified by user number.
  SUBROUTINE cmfe_DataPoints_DestroyNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,err)
    !DLLEXPORT(cmfe_DataPoints_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to destroy.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_Destroy(dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the data points in a region for data points identified by an object.
  SUBROUTINE cmfe_DataPoints_DestroyObj(dataPoints,err)
    !DLLEXPORT(cmfe_DataPoints_DestroyObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_DestroyObj",err,error,*999)

    CALL DataPoints_Destroy(dataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of data points
  SUBROUTINE cmfe_DataPoints_NumberOfDataPointsGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & numberOfDataPoints,err)
    !DLLEXPORT(cmfe_DataPoints_NumberOfDataPointsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get data point count for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<On return, the number of data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_NumberOfDataPointsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_NumberOfDataPointsGet(dataPoints,numberOfDataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_NumberOfDataPointsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_NumberOfDataPointsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_NumberOfDataPointsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of data points
  SUBROUTINE cmfe_DataPoints_NumberOfDataPointsGetObj(dataPoints,numberOfDataPoints,err)
    !DLLEXPORT(cmfe_DataPoints_NumberOfDataPointsGetObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points get data point count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<The number of data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_NumberOfDataPointsGetObj",err,error,*999)

    CALL DataPoints_NumberOfDataPointsGet(dataPoints%dataPoints,numberOfDataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_NumberOfDataPointsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_NumberOfDataPointsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_NumberOfDataPointsGetObj


  !
  !================================================================================================================================
  !

  !>Returns the character label for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_LabelGetCNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber,label,err)
    !DLLEXPORT(cmfe_DataPoints_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelGet(dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a data point in a set of data points identified by an object and user number.
  SUBROUTINE cmfe_DataPoints_LabelGetCObj(dataPoints,dataPointUserNumber,label,err)
    !DLLEXPORT(cmfe_DataPoints_LabelGetCObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("cmfe_DataPoints_LabelGetCObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelGet(dataPoints%dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_LabelGetVSNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber,label,err)
    !DLLEXPORT(cmfe_DataPoints_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelGet(dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a data point in a set of data points identified by an object and user number.
  SUBROUTINE cmfe_DataPoints_LabelGetVSObj(dataPoints,dataPointUserNumber,label,err)
    !DLLEXPORT(cmfe_DataPoints_LabelGetVSObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("cmfe_DataPoints_LabelGetVSObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelGet(dataPoints%dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_LabelSetCNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber,label,err)
    !DLLEXPORT(cmfe_DataPoints_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelSet(dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a data point in a set of data points identified by an object and user number.
  SUBROUTINE cmfe_DataPoints_LabelSetCObj(dataPoints,dataPointUserNumber,label,err)
    !DLLEXPORT(cmfe_DataPoints_LabelSetCObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("cmfe_DataPoints_LabelSetCObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelSet(dataPoints%dataPoints,dataPointUserNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_LabelSetVSNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber,label,err)
    !DLLEXPORT(cmfe_DataPoints_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelSet(dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a data point in a set of data points identified by an object and user number.
  SUBROUTINE cmfe_DataPoints_LabelSetVSObj(dataPoints,dataPointUserNumber,label,err)
    !DLLEXPORT(cmfe_DataPoints_LabelSetVSObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("cmfe_DataPoints_LabelSetVSObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelSet(dataPoints%dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_UserNumberGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointGlobalNumber, &
    & dataPointUserNumber,err)
    !DLLEXPORT(cmfe_DataPoints_UserNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<On return, the user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_UserNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataUserNumberGet(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    EXITS("cmfe_DataPoints_UserNumberGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_UserNumberGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the user number for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_UserNumberGetObj(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err)
    !DLLEXPORT(cmfe_DataPoints_UserNumberGetObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<On return, the user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_UserNumberGetObj",err,error,*999)

    CALL DataPoints_DataUserNumberGet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    EXITS("cmfe_DataPoints_UserNumberGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_UserNumberGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_UserNumberSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointGlobalNumber, &
    & dataPointUserNumber,err)
    !DLLEXPORT(cmfe_DataPoints_UserNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_UserNumberSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataUserNumberSet(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    EXITS("cmfe_DataPoints_UserNumberSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_UserNumberSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_UserNumberSetObj(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err)
    !DLLEXPORT(cmfe_DataPoints_UserNumberSetObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_UserNumberSetObj",err,error,*999)

    CALL DataPoints_DataUserNumberSet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    EXITS("cmfe_DataPoints_UserNumberSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_UserNumberSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_UserNumberSetObj

  !
  !================================================================================================================================
  !

  !>Returns the position for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_PositionGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber, &
    & dataPointPosition,err)
    !DLLEXPORT(cmfe_DataPoints_PositionGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the data point position for.
    REAL(DP), INTENT(OUT) :: dataPointPosition(:) !<On return, the values for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_PositionGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataPositionGet(dataPoints,dataPointGlobalNumber,dataPointPosition,err,error,*999)

    EXITS("cmfe_DataPoints_PositionGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_PositionGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_PositionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the position for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_PositionGetObj(dataPoints,dataPointUserNumber,dataPointPosition,err)
    !DLLEXPORT(cmfe_DataPoints_PositionGetObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the data point position for.
    REAL(DP), INTENT(OUT) :: dataPointPosition(:) !<On return, the position for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("cmfe_DataPoints_PositionGetObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataPositionGet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointPosition,err,error,*999)

    EXITS("cmfe_DataPoints_PositionGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_PositionGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_PositionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the position for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_PositionSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber, &
    & dataPointPosition,err)
    !DLLEXPORT(cmfe_DataPoints_PositionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to set the data point position for.
    REAL(DP), INTENT(IN) :: dataPointPosition(:) !<The position for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_PositionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataPositionSet(dataPoints,dataPointGlobalNumber,dataPointPosition,err,error,*999)

    EXITS("cmfe_DataPoints_PositionSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_PositionSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_PositionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the position for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_PositionSetObj(dataPoints,dataPointUserNumber,dataPointPosition,err)
    !DLLEXPORT(cmfe_DataPoints_PositionSetObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to set the data point position for.
    REAL(DP), INTENT(IN) :: dataPointPosition(:) !<The position for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("cmfe_DataPoints_PositionSetObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataPositionSet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointPosition,err,error,*999)

    EXITS("cmfe_DataPoints_PositionSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_PositionSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_PositionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the weights for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_WeightsGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber, &
    & dataPointWeights,err)
    !DLLEXPORT(cmfe_DataPoints_WeightsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get the data point weights for.
    REAL(DP), INTENT(OUT) :: dataPointWeights(:) !<On return, the weights for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_WeightsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataWeightsGet(dataPoints,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    EXITS("cmfe_DataPoints_WeightsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_WeightsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_WeightsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the weights for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_WeightsGetObj(dataPoints,dataPointUserNumber,dataPointWeights,err)
    !DLLEXPORT(cmfe_DataPoints_WeightsGetObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get the data point weights for.
    REAL(DP), INTENT(OUT) :: dataPointWeights(:) !<On return, the weights for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("cmfe_DataPoints_WeightsGetObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataWeightsGet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    EXITS("cmfe_DataPoints_WeightsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_WeightsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_WeightsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the weights for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_WeightsSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber, &
    & dataPointWeights,err)
    !DLLEXPORT(cmfe_DataPoints_WeightsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set the data point weights for.
    REAL(DP), INTENT(IN) :: dataPointWeights(:) !<The weights for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataPoints_WeightsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_WeightsSet(dataPoints,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    EXITS("cmfe_DataPoints_WeightsSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_WeightsSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_WeightsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the weights for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_WeightsSetObj(dataPoints,dataPointUserNumber,dataPointWeights,err)
    !DLLEXPORT(cmfe_DataPoints_WeightsSetObj)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set the data point weightsfor.
    REAL(DP), INTENT(IN) :: dataPointWeights(:) !<The weights for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("cmfe_DataPoints_WeightsSetObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_WeightsSet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    EXITS("cmfe_DataPoints_WeightsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_WeightsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_WeightsSetObj

!!==================================================================================================================================
!!
!! DataProjectionRoutines
!!
!!==================================================================================================================================

  !>Returns the absolute tolerance of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_AbsoluteToleranceGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,absoluteTolerance,err)
    !DLLEXPORT(cmfe_DataProjection_AbsoluteToleranceGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On exit, the absolute tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_AbsoluteToleranceGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_AbsoluteToleranceGet(dataProjection,absoluteTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_AbsoluteToleranceGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_AbsoluteToleranceGetNumber",err,error)
    EXITS("cmfe_DataProjection_AbsoluteToleranceGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_AbsoluteToleranceGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the absolute tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_AbsoluteToleranceGetObj(dataProjection,absoluteTolerance,err)
    !DLLEXPORT(cmfe_DataProjection_AbsoluteToleranceGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On exit, the absolute tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_AbsoluteToleranceGetObj",err,error,*999)

    CALL DataProjection_AbsoluteToleranceGet(dataProjection%dataProjection,absoluteTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_AbsoluteToleranceGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_AbsoluteToleranceGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_AbsoluteToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_AbsoluteToleranceSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,absoluteTolerance,err)
    !DLLEXPORT(cmfe_DataProjection_AbsoluteToleranceSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<the absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_AbsoluteToleranceSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_AbsoluteToleranceSet(dataProjection,absoluteTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_AbsoluteToleranceSetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_AbsoluteToleranceSetNumber",err,error)
    EXITS("cmfe_DataProjection_AbsoluteToleranceSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_AbsoluteToleranceSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_AbsoluteToleranceSetObj(dataProjection,absoluteTolerance,err)
    !DLLEXPORT(cmfe_DataProjection_AbsoluteToleranceSetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<the absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_AbsoluteToleranceSetObj",err,error,*999)

    CALL DataProjection_AbsoluteToleranceSet(dataProjection%dataProjection,absoluteTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_AbsoluteToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_AbsoluteToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_AbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_CreateFinishNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points which associates to the data projection to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_CreateFinish(dataProjection,err,error,*999)

    EXITS("cmfe_DataProjection_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new data projection identified by an object.
  SUBROUTINE cmfe_DataProjection_CreateFinishObj(dataProjection,err)
    !DLLEXPORT(cmfe_DataProjection_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_DataProjection_CreateFinishObj",err,error,*999)

    CALL DataProjection_CreateFinish(dataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_DataProjection_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new data projection for a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_CreateStartNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,projectionFieldUserNumber,projectionFieldVariableType,err)
    !DLLEXPORT(cmfe_DataProjection_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data points to be projected.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number.
    INTEGER(INTG), INTENT(IN) :: projectionFieldUserNumber !<The user number of the field for the data projection
    INTEGER(INTG), INTENT(IN) :: projectionFieldVariableType !<The variable type of the projection field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(FieldType), POINTER :: projectionField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(projectionField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL Region_FieldGet(region,projectionFieldUserNumber,projectionField,err,error,*999)
    CALL DataProjection_CreateStart(dataProjectionUserNumber,dataPoints,projectionField,projectionFieldVariableType, &
      & dataProjection,err,error,*999)

    EXITS("cmfe_DataProjection_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new data projection for a data projection identified by an object.
  SUBROUTINE cmfe_DataProjection_CreateStartObj(dataProjectionUserNumber,dataPoints,projectionField,projectionVariableType, &
    & dataProjection,err)
    !DLLEXPORT(cmfe_DataProjection_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number.
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to be projected
    TYPE(cmfe_FieldType), INTENT(IN) :: projectionField !<The field where the data points are projected.
    INTEGER(INTG), INTENT(IN) :: projectionVariableType !<The variable type of the field where the data points are projected.
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<On exit, the newly created data projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_CreateStartObj",err,error,*999)

    CALL DataProjection_CreateStart(dataProjectionUserNumber,dataPoints%dataPoints,projectionField%field,projectionVariableType, &
      & dataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_DataProjection_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a data projection identified by region user number.
  SUBROUTINE cmfe_DataProjection_DestroyNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataProjectionUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to destroy.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_Destroy(dataProjection,err,error,*999)

    EXITS("cmfe_DataProjection_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a data projection identified by an object.
  SUBROUTINE cmfe_DataProjection_DestroyObj(dataProjection,err)
    !DLLEXPORT(cmfe_DataProjection_DestroyObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_DestroyObj",err,error,*999)

    CALL DataProjection_Destroy(dataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_DataProjection_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DestroyObj

  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in a region, identified by user number
  SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,fieldUserNumber,fieldVariableType,fieldParameterSetType,err)
    !DLLEXPORT(cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection and field
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number of the field to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldParameterSetType !<The field parameter set type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DataPointsPositionEvaluate(dataProjection,field,fieldVariableType,fieldParameterSetType,err,error,*999)

    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber",err,error)
    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber

  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in an interface, identified by user number
  SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,fieldUserNumber,fieldVariableType, &
    & fieldParameterSetType,err)
    !DLLEXPORT(cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number of the field to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldParameterSetType !<The field parameter set type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL DataProjection_DataPointsPositionEvaluate(dataProjection,field,fieldVariableType,fieldParameterSetType, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection, identified by object
  SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateObj(dataProjection,field,fieldVariableType,fieldParameterSetType,err)
    !DLLEXPORT(cmfe_DataProjection_DataPointsPositionEvaluateObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to interpolate
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldParameterSetType !<The field parameter set type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_DataPointsPositionEvaluateObj",err,error,*999)

    CALL DataProjection_DataPointsPositionEvaluate(dataProjection%dataProjection,field%field,fieldVariableType, &
      & fieldParameterSetType,err,error,*999)

    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateObj")
    RETURN
999 ERRORS("cmfe_DataProjection_DataPointsPositionEvaluateObj",err,error)
    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateObj

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on a data point user number in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber0(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber0",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber1(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],err)

    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber0")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber0",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber1(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByDataPoints(dataProjection,dataPointGlobalNumbers,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber1")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber1",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsRegionNumber1

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsInterNum0(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByDataPointsInterNum0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCancelByDataPointsInterNum0",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCancelByDataPointsInterNum1(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],err)

    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsInterNum0")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByDataPointsInterNum0",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsInterNum0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsInterNum0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsInterNum1(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByDataPointsInterNum1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCancelByDataPointsInterNum1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByDataPoints(dataProjection,dataPointGlobalNumbers,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsInterNum1")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByDataPointsInterNum1",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsInterNum1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsInterNum1

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag as specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsObj0(dataProjection,dataPointUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByDataPointsObj0)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCancelByDataPointsObj0",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCancelByDataPointsObj1(dataProjection,[dataPointUserNumber],err)

    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsObj0")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByDataPointsObj0",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsObj0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag as specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsObj1(dataProjection,dataPointUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByDataPointsObj1)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("cmfe_DataProjection_ProjectionCancelByDataPointsObj1",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataProjection_ProjectionCancelByDataPoints(dataProjection%dataProjection,dataPointGlobalNumbers,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsObj1")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByDataPointsObj1",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByDataPointsObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByDataPointsObj1

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection distance in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByDistanceRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,distanceRelation,distance,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByDistanceRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: distanceRelation !<The distance relation to use to cancel projections \see OpenCMISS_DataProjectionDistanceRelations
    REAL(DP), INTENT(IN) :: distance !<The distance by which to select the data points to cancel.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCancelByDistanceRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByDistance(dataProjection,distanceRelation,distance,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCancelByDistanceRegionNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByDistanceRegionNumber",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByDistanceRegionNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByDistanceRegionNumber

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection distance in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByDistanceInterfaceNumber(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,distanceRelation,distance,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByDistanceInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: distanceRelation !<The distance relation to use to cancel projections \see OpenCMISS_DataProjectionDistanceRelations
    REAL(DP), INTENT(IN) :: distance !<The distance by which to select the data points to cancel.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCancelByDistanceInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByDistance(dataProjection,distanceRelation,distance,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCancelByDistanceInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByDistanceInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByDistanceInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByDistanceInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection distance as specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByDistanceObj(dataProjection,distanceRelation,distance,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByDistanceObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: distanceRelation !<The distance relation to use to cancel projections \see OpenCMISS_DataProjectionDistanceRelations
    REAL(DP), INTENT(IN) :: distance !<The distance by which to select the data points to cancel.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCancelByDistanceObj",err,error,*999)

    CALL DataProjection_ProjectionCancelByDistance(dataProjection%dataProjection,distanceRelation,distance,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCancelByDistanceObj")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByDistanceObj",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByDistanceObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByDistanceObj

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber0(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,exitTag,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: exitTag !<The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber0",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber1(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
      & dataProjectionUserNumber,[exitTag],err)

    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber0")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber0",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber1(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,exitTags,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: exitTags(:) !<exitTags(tagIdx). The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByExitTags(dataProjection,exitTags,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber1")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber1",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsRegionNumber1

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,exitTag,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: exitTag !<The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[exitTag],err)

    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,exitTags,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: exitTags(:) !<exitTags(tagIdx). The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByExitTags(dataProjection,exitTags,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag as specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsObj0(dataProjection,exitTag,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByExitTagsObj0)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: exitTag !<The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCancelByExitTagsObj0",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCancelByExitTagsObj1(dataProjection,[exitTag],err)

    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsObj0")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByExitTagsObj0",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsObj0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag as specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsObj1(dataProjection,exitTags,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCancelByExitTagsObj1)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: exitTags(:) !<exitTags(tagIdx). The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCancelByExitTagsObj1",err,error,*999)

    CALL DataProjection_ProjectionCancelByExitTags(dataProjection%dataProjection,exitTags,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsObj1")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCancelByExitTagsObj1",err,error)
    EXITS("cmfe_DataProjection_ProjectionCancelByExitTagsObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCancelByExitTagsObj1

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for an all elements projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber0(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber0",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber1(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],err)

    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber0")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber0",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber0

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for an all elements projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber1(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateElementsSet(dataProjection,candidateElementLocalNumbers,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber1")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber1",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetRegionNumber1

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for an all elements projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetIntNum0(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateElementsSetIntNum0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateElementsSetIntNum0",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateElementsSetIntNum1(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],err)
    
    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetIntNum0")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateElementsSetIntNum0",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetIntNum0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetIntNum0

  !
  !================================================================================================================================
  !

  !>ESet the data projection candidate elements for an all elements projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetIntNum1(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateElementsSetIntNum1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCandidateElementsSetIntNum1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateElementsSet(dataProjection,candidateElementLocalNumbers,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetIntNum1")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateElementsSetIntNum1",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetIntNum1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetIntNum1

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for an all elements projection type specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetObj0(dataProjection,candidateElementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateElementsSetObj0)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateElementsSetObj0",err,error,*999)
    
    CALL cmfe_DataProjection_ProjectionCandidateElementsSetObj1(dataProjection,[candidateElementUserNumber],err)

    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetObj0")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateElementsSetObj0",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetObj0

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for an all elements projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetObj1(dataProjection,candidateElementUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateElementsSetObj1)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
 
    ENTERS("cmfe_DataProjection_ProjectionCandidateElementsSetObj1",err,error,*999)

    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateElementsSet(dataProjection%dataProjection,candidateElementLocalNumbers,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetObj1")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateElementsSetObj1",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateElementsSetObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateElementsSetObj1

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for a data point for an all elements projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum00(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum00",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],[candidateElementUserNumber],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum00")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum00",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum00")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for a data point for an all elements projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum01(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate elements user numbers for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum01",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],candidateElementUserNumbers,err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum01")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum01",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum01")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for data points for an all elements projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum10(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum10",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,[candidateElementUserNumber],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum10")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum10",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum10")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for data points for an all elements projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum11(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionElements)
    NULLIFY(decompositionTopology)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateElementsSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum11")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum11",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum11")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetRegNum11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for a data point for an all elements projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum00(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number.
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum00",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],[candidateElementUserNumber],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum00")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum00",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum00")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for a data point for an all elements projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum01(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers.
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum01",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],candidateElementUserNumbers,err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum01")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum01",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum01")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for data points for an all elements projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum10(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum10",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,[candidateElementUserNumber],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum10")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum10",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum10")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for data points for an all elements projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum11(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionElements)
    NULLIFY(decompositionTopology)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateElementsSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum11")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum11",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum11")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetIntNum11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for a data point for an all elements projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj00(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetObj00)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj00",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateElementsSetObj11(dataProjection,[dataPointUserNumber], &
      & [candidateElementUserNumber],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj00")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj00",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj00")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for a data point for an all elements projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj01(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetObj01)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj01",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateElementsSetObj11(dataProjection,[dataPointUserNumber], &
      & candidateElementUserNumbers,err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj01")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj01",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj01")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for data points for an all elements projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj10(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetObj10)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj10",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateElementsSetObj11(dataProjection,dataPointUserNumbers, &
      & [candidateElementUserNumber],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj10")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj10",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj10")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for data points for an all elements projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj11(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumbers,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateElementsSetObj11)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj11",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionElements)
    NULLIFY(decompositionTopology)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateElementsSet(dataProjection%dataProjection,dataPointGlobalNumbers, &
      & candidateElementLocalNumbers,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj11")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj11",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateElementsSetObj11")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateElementsSetObj11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber00(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber00",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],[candidateFaceNormal],err)
 
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber00")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber00",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber00")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber00
  
  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber10(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber10",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,[candidateFaceNormal],err)
 
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber10")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber10",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber10")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber10
  
  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber01(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber01",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateFaceNormals,err)
 
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber01")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber01",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber01")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber01
  
  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber11(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateFacesSet(dataProjection,candidateElementLocalNumbers,candidateFaceNormals, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber11")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber11",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber11")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetRegionNumber11
  
  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum00(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum00",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum00")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum00",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum00")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum10(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum10",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,[candidateFaceNormal],err)

    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum10")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum10",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum10")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum01(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum01",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateFaceNormals,err)

    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum01")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum01",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum01")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateFacesSet(dataProjection,candidateElementLocalNumbers,candidateFaceNormals, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum11")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum11",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum11")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetInterfaceNum11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetObj00(dataProjection,candidateElementUserNumber, &
    & candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetObj00)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetObj00",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateFacesSetObj11(dataProjection,[candidateElementUserNumber], &
      & [candidateFaceNormal],err)

    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetObj00")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetObj00",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetObj00")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetObj00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetObj10(dataProjection,candidateElementUserNumbers, &
    & candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetObj10)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetObj10",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateFacesSetObj11(dataProjection,candidateElementUserNumbers, &
      & [candidateFaceNormal],err)

    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetObj10")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetObj10",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetObj10")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetObj10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetObj01(dataProjection,candidateElementUserNumber, &
    & candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetObj01)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetObj01",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateFacesSetObj11(dataProjection,[candidateElementUserNumber], &
      & candidateFaceNormals,err)

    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetObj01")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetObj01",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetObj01")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetObj01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetObj11(dataProjection,candidateElementUserNumbers, &
    & candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateFacesSetObj11)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("cmfe_DataProjection_ProjectionCandidateFacesSetObj11",err,error,*999)

    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateFacesSet(dataProjection%dataProjection,candidateElementLocalNumbers, &
      & candidateFaceNormals,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetObj11")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateFacesSetObj11",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateFacesSetObj11")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateFacesSetObj11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for a data point in a boundary faces projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum000(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum000)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum000",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum111(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
      & dataProjectionUserNumber,[dataPointUserNumber],[candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum000")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum000",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum000")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a data point in a boundary faces projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum011(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum011)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum011",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum111(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
      & dataProjectionUserNumber,[dataPointUserNumber],candidateElementUserNumbers,candidateFaceNormals,err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum011")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum011",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum011")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for data points in a boundary faces projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum100(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum100)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum100",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum111(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
      & dataProjectionUserNumber,dataPointUserNumbers,[candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum100")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum100",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum100")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for data points in a boundary faces projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum111(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum111)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum111",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateFacesSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & candidateFaceNormals,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum111")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum111",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum111")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetRegNum111

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for a data point for a boundary faces projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum000(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber, &
    & candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum000)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum000",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber], &
      & [candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum000")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum000",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum000")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a data point for a boundary faces projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum011(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers, &
    & candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum011)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum011",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber], &
      & candidateElementUserNumbers,candidateFaceNormals,err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum011")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum011",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum011")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for data points for a boundary faces projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum100(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber, &
    & candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum100)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum100",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers, &
      & [candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum100")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum100",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum100")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for data points for a boundary faces projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers, &
    & candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum111)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum111",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateFacesSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & candidateFaceNormals,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum111")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum111",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum111")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetIntNum111

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for a data point for a boundary faces projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj000(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetObj000)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj000",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateFacesSetObj111(dataProjection,[dataPointUserNumber], &
    & [candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj000")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj000",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj000")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a data point for a boundary faces projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj011(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetObj011)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj011",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateFacesSetObj111(dataProjection,[dataPointUserNumber], &
    & candidateElementUserNumbers,candidateFaceNormals,err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj011")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj011",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj011")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for data points for a boundary faces projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj100(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetObj100)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj100",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateFacesSetObj111(dataProjection,dataPointUserNumbers, &
    & [candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj100")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj100",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj100")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for data points for a boundary faces projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj111(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateFacesSetObj111)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
 
    ENTERS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj111",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateFacesSet(dataProjection%dataProjection,dataPointGlobalNumbers, &
      & candidateElementLocalNumbers,candidateFaceNormals,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj111")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj111",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateFacesSetObj111")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateFacesSetObj111

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber00(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateLineNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),1)
 
    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber00",err,error,*999)

    candidateLineNormals(1:SIZE(candidateLineNormal,1),1)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    CALL cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateLineNormals,err)

    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber00")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber00",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber00")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber10(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),SIZE(candidateElementUserNumbers,1)),elementIdx
 
    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber10",err,error,*999)

    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      candidateLineNormals(1:SIZE(candidateLineNormal,1),elementIdx)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    ENDDO !elementIdx
    CALL cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormals,err)

    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber10")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber10",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber10")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber01(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
 
    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber01",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateLineNormals,err)

    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber01")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber01",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber01")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber11(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateLinesSet(dataProjection,candidateElementLocalNumbers,candidateLineNormals, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber11")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber11",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber11")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetRegionNumber11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum00(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateLineNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),1)

    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum00",err,error,*999)

    candidateLineNormals(1:SIZE(candidateLineNormal,1),1)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    CALL cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateLineNormals,err)

    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum00")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum00",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum00")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum10(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),SIZE(candidateElementUserNumbers,1)),elementIdx

    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum10",err,error,*999)

    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      candidateLineNormals(1:SIZE(candidateLineNormal,1),elementIdx)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    ENDDO !elementIdx
    CALL cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormals,err)

    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum10")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum10",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum10")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum01(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum01",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateLineNormals,err)

    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum01")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum01",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum01")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum01
  
  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateLinesSet(dataProjection,candidateElementLocalNumbers,candidateLineNormals, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum11")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum11",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum11")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetInterfaceNum11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetObj00(dataProjection,candidateElementUserNumber, &
    & candidateLineNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetObj00)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormal(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),1)

    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetObj00",err,error,*999)

    candidateLineNormals(1:SIZE(candidateLineNormal,1),1)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    CALL cmfe_DataProjection_ProjectionCandidateLinesSetObj11(dataProjection,[candidateElementUserNumber], &
      & candidateLineNormals,err)
 
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetObj00")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetObj00",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetObj00")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetObj00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetObj10(dataProjection,candidateElementUserNumbers, &
    & candidateLineNormal,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetObj10)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormal(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),SIZE(candidateElementUserNumbers,1)),elementIdx

    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetObj10",err,error,*999)

    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      candidateLineNormals(1:SIZE(candidateLineNormal,1),elementIdx)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    ENDDO !elementIdx
    CALL cmfe_DataProjection_ProjectionCandidateLinesSetObj11(dataProjection,candidateElementUserNumbers, &
      & candidateLineNormals,err)
 
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetObj10")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetObj10",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetObj10")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetObj10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetObj01(dataProjection,candidateElementUserNumber, &
    & candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetObj01)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormal(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetObj01",err,error,*999)

    CALL cmfe_DataProjection_ProjectionCandidateLinesSetObj11(dataProjection,[candidateElementUserNumber], &
      & candidateLineNormals,err)
 
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetObj01")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetObj01",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetObj01")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetObj01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetObj11(dataProjection,candidateElementUserNumbers, &
    & candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionCandidateLinesSetObj11)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("cmfe_DataProjection_ProjectionCandidateLinesSetObj11",err,error,*999)

    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateLinesSet(dataProjection%dataProjection,candidateElementLocalNumbers, &
      & candidateLineNormals,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetObj11")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidateLinesSetObj11",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidateLinesSetObj11")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidateLinesSetObj11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for a data point for a boundary lines projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum000(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum000)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum000",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum111(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],[candidateElementUserNumber], &
      & RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum000")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum000",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum000")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a data point for a boundary lines projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum011(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers,candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum011)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum011",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum111(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],candidateElementUserNumbers, &
      & candidateLineNormals,err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum011")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum011",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum011")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for data points for a boundary lines projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum100(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum100)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
     INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum100",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum111(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,[candidateElementUserNumber], &
      & RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum100")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum100",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum100")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for data points for a boundary lines projection type in a region specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum111(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers, &
    & candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum111)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum111",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateLinesSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & candidateLineNormals,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum111")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum111",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum111")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetRegNum111

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for a data point for a boundary lines projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum000(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber, &
    & candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum000)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum000",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber], &
      & [candidateElementUserNumber],RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum000")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum000",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum000")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a data point for a boundary lines projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum011(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers, &
    & candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum011)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum011",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],candidateElementUserNumbers, &
      & candidateLineNormals,err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum011")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum011",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum011")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for data points for a boundary lines projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum100(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber, &
    & candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum100)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum100",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers, &
      & [candidateElementUserNumber],RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum100")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum100",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum100")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for data points for a boundary lines projection type in an interface specified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers, &
    & candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum111)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions
  
    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum111",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateLinesSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & candidateLineNormals,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum111")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum111",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum111")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetIntNum111

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for a data point for a boundary lines projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj000(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetObj000)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj000",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateLinesSetObj111(dataProjection,[dataPointUserNumber], &
    & [candidateElementUserNumber],RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj000")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj000",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj000")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a data point for a boundary lines projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj011(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumbers,candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetObj011)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj011",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateLinesSetObj111(dataProjection,[dataPointUserNumber], &
      & candidateElementUserNumbers,candidateLineNormals,err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj011")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj011",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj011")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for data points for a boundary lines projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj100(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetObj100)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj100",err,error,*999)

    CALL cmfe_DataProjection_ProjectionDataCandidateLinesSetObj111(dataProjection,dataPointUserNumbers, &
      & [candidateElementUserNumber],RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj100")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj100",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj100")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for data points for a boundary lines projection type in a region specified by object
  SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj111(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumbers,candidateLineNormals,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionDataCandidateLinesSetObj111)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
 
    ENTERS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj111",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)    
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateLinesSet(dataProjection%dataProjection,dataPointGlobalNumbers, &
      & candidateElementLocalNumbers,candidateLineNormals,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj111")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj111",err,error)
    EXITS("cmfe_DataProjection_ProjectionDataCandidateLinesSetObj111")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionDataCandidateLinesSetObj111

  !
  !================================================================================================================================
  !

  !>Evaluate a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_DataPointsProjectionEvaluateNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,projectionFieldSetType,err)
    !DLLEXPORT(cmfe_DataProjection_DataPointsProjectionEvaluateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to evaluate.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: projectionFieldSetType !<The parameter set type of the field data points are be projected on.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_DataPointsProjectionEvaluateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DataPointsProjectionEvaluate(dataProjection,projectionFieldSetType,err,error,*999)

    EXITS("cmfe_DataProjection_DataPointsProjectionEvaluateNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_DataPointsProjectionEvaluateNumber",err,error)
    EXITS("cmfe_DataProjection_DataPointsProjectionEvaluateNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DataPointsProjectionEvaluateNumber

  !
  !================================================================================================================================
  !

  !>Evaluate a data projection identified by an object.
  SUBROUTINE cmfe_DataProjection_DataPointsProjectionEvaluateObj(dataProjection,projectionFieldSetType,err)
    !DLLEXPORT(cmfe_DataProjection_DataPointsProjectionEvaluateObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to evaluate.
    INTEGER(INTG), INTENT(IN) :: projectionFieldSetType !<The parameter set type of the field data points are be projected on.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_DataPointsProjectionEvaluateObj",err,error,*999)

    CALL DataProjection_DataPointsProjectionEvaluate(dataProjection%dataProjection,projectionFieldSetType,err,error,*999)

    EXITS("cmfe_DataProjection_DataPointsProjectionEvaluateObj")
    RETURN
999 ERRORS("cmfe_DataProjection_DataPointsProjectionEvaluateObj",err,error)
    EXITS("cmfe_DataProjection_DataPointsProjectionEvaluateObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DataPointsProjectionEvaluateObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,maximumIterationUpdate,err)
    !DLLEXPORT(cmfe_DataProjection_MaximumIterationUpdateGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: maximumIterationUpdate !<On exit, the maximum iteration update of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_MaximumIterationUpdateGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_MaximumInterationUpdateGet(dataProjection,maximumIterationUpdate,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumIterationUpdateGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumIterationUpdateGetNumber",err,error)
    EXITS("cmfe_DataProjection_MaximumIterationUpdateGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateGetObj(dataProjection,maximumIterationUpdate,err)
    !DLLEXPORT(cmfe_DataProjection_MaximumIterationUpdateGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: maximumIterationUpdate !<On exit, the maximum iteration update of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_MaximumIterationUpdateGetObj",err,error,*999)

    CALL DataProjection_MaximumInterationUpdateGet(dataProjection%dataProjection,maximumIterationUpdate,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumIterationUpdateGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumIterationUpdateGetObj",err,error)
    EXITS("cmfe_DataProjection_MaximumIterationUpdateGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,maximumIterationUpdate,err)
    !DLLEXPORT(cmfe_DataProjection_MaximumIterationUpdateSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(IN) :: maximumIterationUpdate !<the maximum iteration update to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_MaximumIterationUpdateSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_MaximumInterationUpdateSet(dataProjection,maximumIterationUpdate,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumIterationUpdateSetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumIterationUpdateSetNumber",err,error)
    EXITS("cmfe_DataProjection_MaximumIterationUpdateSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateSetObj(dataProjection,maximumIterationUpdate,err)
    !DLLEXPORT(cmfe_DataProjection_MaximumIterationUpdateSetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: maximumIterationUpdate !<the maximum iteration update to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_MaximumIterationUpdateSetObj",err,error,*999)

    CALL DataProjection_MaximumInterationUpdateSet(dataProjection%dataProjection,maximumIterationUpdate,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumIterationUpdateSetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumIterationUpdateSetObj",err,error)
    EXITS("cmfe_DataProjection_MaximumIterationUpdateSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the maximum number of iterations of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,maximumNumberOfIterations,err)
    !DLLEXPORT(cmfe_DataProjection_MaximumNumberOfIterationsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(OUT) :: maximumNumberOfIterations !<On exit, the maximum number of iterations of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_MaximumNumberOfIterationsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_MaximumNumberOfIterationsGet(dataProjection,maximumNumberOfIterations,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumNumberOfIterationsGetNumber",err,error)
    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the maximum number of iterations of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsGetObj(dataProjection,maximumNumberOfIterations,err)
    !DLLEXPORT(cmfe_DataProjection_MaximumNumberOfIterationsGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get maximum number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: maximumNumberOfIterations !<On exit, the maximum number of iterations of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_MaximumNumberOfIterationsGetObj",err,error,*999)

    CALL DataProjection_MaximumNumberOfIterationsGet(dataProjection%dataProjection,maximumNumberOfIterations,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumNumberOfIterationsGetObj",err,error)
    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsGetObj

  !
  !================================================================================================================================
  !

  !>Outputs the analysis of data projection results for a data projection identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultAnalysisOutputNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,filename,err)
    !DLLEXPORT(cmfe_DataProjection_ResultAnalysisOutputNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to output the analysis for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to output the analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: filename !<If not empty, the filename to output the data projection result analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ResultAnalysisOutputNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultAnalysisOutput(dataProjection,filename,err,error,*999)

    EXITS("cmfe_DataProjection_ResultAnalysisOutputNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultAnalysisOutputNumber",err,error)
    EXITS("cmfe_DataProjection_ResultAnalysisOutputNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultAnalysisOutputNumber

  !
  !================================================================================================================================
  !

  !>Outputs the analysis of data projection results for a data projection identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultAnalysisOutputObj(dataProjection,filename,err)
    !DLLEXPORT(cmfe_DataProjection_ResultAnalysisOutputObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<A pointer to the data projection to output the result analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: filename !<If not empty, the filename to output the data projection result analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ResultAnalysisOutputObj",err,error,*999)

    CALL DataProjection_ResultAnalysisOutput(dataProjection%dataProjection,filename,err,error,*999)

    EXITS("cmfe_DataProjection_ResultAnalysisOutputObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultAnalysisOutputObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultAnalysisOutputObj

  !
  !================================================================================================================================
  !

  !>Returns the projection distance for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultDistanceGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionDistance,err)
    !DLLEXPORT(cmfe_DataProjection_ResultDistanceGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionDistance !<On return, the projection distance for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ResultDistanceGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultDistanceGet(dataProjection,dataPointGlobalNumber,projectionDistance,err,error,*999)

    EXITS("cmfe_DataProjection_ResultDistanceGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultDistanceGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultDistanceGetNumber


   !
   !================================================================================================================================
   !

  !>Returns the projection distance for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultDistanceGetObj(dataProjection,dataPointUserNumber,projectionDistance,err)
    !DLLEXPORT(cmfe_DataProjection_ResultDistanceGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionDistance !<On return, the projection distance for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("cmfe_DataProjection_ResultDistanceGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultDistanceGet(dataProjection%dataProjection,dataPointGlobalNumber,projectionDistance, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ResultDistanceGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultDistanceGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultDistanceGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element number for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultElementNumberGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionElementNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ResultElementNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementNumber !<On return, the projection element number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ResultElementNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultElementNumberGet(dataProjection,dataPointGlobalNumber,projectionElementNumber,err,error,*999)
!!TODO: convert element to user number    

    EXITS("cmfe_DataProjection_ResultElementNumberGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementNumberGetNumber",err,error)
    EXITS("cmfe_DataProjection_ResultElementNumberGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element number for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultElementNumberGetObj(dataProjection,dataPointUserNumber,projectionElementNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ResultElementNumberGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementNumber !<On return, the projection element number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("cmfe_DataProjection_ResultElementNumberGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultElementNumberGet(dataProjection%dataProjection,dataPointGlobalNumber,projectionElementNumber, &
      & err,error,*999)
!!TODO: convert element to user number    

    EXITS("cmfe_DataProjection_ResultElementNumberGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementNumberGetObj",err,error)
    EXITS("cmfe_DataProjection_ResultElementNumberGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element face number for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultElementFaceNumberGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionElementFaceNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ResultElementFaceNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementFaceNumber !<On return, the projection element face number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ResultElementFaceNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultElementFaceNumberGet(dataProjection,dataPointGlobalNumber,projectionElementFaceNumber,err, &
      & error,*999)

    EXITS("cmfe_DataProjection_ResultElementFaceNumberGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementFaceNumberGetNumber",err,error)
    EXITS("cmfe_DataProjection_ResultElementFaceNumberGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementFaceNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element face number for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultElementFaceNumberGetObj(dataProjection,dataPointUserNumber, &
    & projectionElementFaceNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ResultElementFaceNumberGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementFaceNumber !<On return, the projection element face number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("cmfe_DataProjection_ResultElementFaceNumberGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultElementFaceNumberGet(dataProjection%dataProjection,dataPointGlobalNumber, &
      & projectionElementFaceNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ResultElementFaceNumberGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementFaceNumberGetObj",err,error)
    EXITS("cmfe_DataProjection_ResultElementFaceNumberGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementFaceNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element line number for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultElementLineNumberGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionElementLineNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ResultElementLineNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementLineNumber !<On return, the projection element line number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ResultElementLineNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultElementLineNumberGet(dataProjection,dataPointGlobalNumber,projectionElementLineNumber,err, &
      & error,*999)

    EXITS("cmfe_DataProjection_ResultElementLineNumberGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementLineNumberGetNumber",err,error)
    EXITS("cmfe_DataProjection_ResultElementLineNumberGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementLineNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element line number for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultElementLineNumberGetObj(dataProjection,dataPointUserNumber, &
    & projectionElementLineNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ResultElementLineNumberGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementLineNumber !<On return, the projection element line number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("cmfe_DataProjection_ResultElementLineNumberGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultElementLineNumberGet(dataProjection%dataProjection,dataPointGlobalNumber, &
      & projectionElementLineNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ResultElementLineNumberGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementLineNumberGetObj",err,error)
    EXITS("cmfe_DataProjection_ResultElementLineNumberGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementLineNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection exit tag for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultExitTagGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionExitTag,err)
    !DLLEXPORT(cmfe_DataProjection_ResultExitTagGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionExitTag !<On return, the projection exit tag for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ResultExitTagGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultExitTagGet(dataProjection,dataPointGlobalNumber,projectionExitTag,err,error,*999)

    EXITS("cmfe_DataProjection_ResultExitTagGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultExitTagGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultExitTagGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection exit tag for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultExitTagGetObj(dataProjection,dataPointUserNumber,projectionExitTag,err)
    !DLLEXPORT(cmfe_DataProjection_ResultExitTagGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionExitTag !<On return, the projection exit tag for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("cmfe_DataProjection_ResultExitTagGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultExitTagGet(dataProjection%dataProjection,dataPointGlobalNumber,projectionExitTag, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ResultExitTagGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultExitTagGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultExitTagGetObj

  !
  !================================================================================================================================
  !

  !>Returns the maximum error for a data projection given by numbers.
  SUBROUTINE cmfe_DataProjection_ResultMaximumErrorGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,maximumDataPointUserNumber,maximumError,err)
    !DLLEXPORT(cmfe_DataProjection_ResultMaximumErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the maximum error for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get the maximum error for.
    INTEGER(INTG), INTENT(OUT) :: maximumDataPointUserNumber !<On return, the user number of the data point that has the maximum error.
    REAL(DP), INTENT(OUT) :: maximumError !<On return, the maximum error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: maximumDataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ResultMaximumErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultMaximumErrorGet(dataProjection,maximumDataPointGlobalNumber,maximumError,err,error,*999)
    CALL DataPoints_DataUserNumberGet(dataPoints,maximumDataPointGlobalNumber,maximumDataPointUserNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ResultMaximumErrorGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultMaximumErrorGetNumber",err,error)
    EXITS("cmfe_DataProjection_ResultMaximumErrorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultMaximumErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the maximum error for a data projection given by an object.
  SUBROUTINE cmfe_DataProjection_ResultMaximumErrorGetObj(dataProjection,maximumDataPointUserNumber,maximumError,err)
    !DLLEXPORT(cmfe_DataProjection_ResultMaximumErrorGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get the maximum error for.
    INTEGER(INTG), INTENT(OUT) :: maximumDataPointUserNumber !<On return, the user number of the data point that has the maximum error.
    REAL(DP), INTENT(OUT) :: maximumError !<On return, the maximum error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: maximumDataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("cmfe_DataProjection_ResultMaximumErrorGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataProjection_ResultMaximumErrorGet(dataProjection%dataProjection,maximumDataPointGlobalNumber,maximumError, &
      & err,error,*999)
    CALL DataPoints_DataUserNumberGet(dataPoints,maximumDataPointGlobalNumber,maximumDataPointUserNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ResultMaximumErrorGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultMaximumErrorGetObj",err,error)
    EXITS("cmfe_DataProjection_ResultMaximumErrorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultMaximumErrorGetObj

  !
  !================================================================================================================================
  !

  !>Returns the minimum error for a data projection given by numbers.
  SUBROUTINE cmfe_DataProjection_ResultMinimumErrorGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,minimumDataPointUserNumber,minimumError,err)
    !DLLEXPORT(cmfe_DataProjection_ResultMinimumErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the minimum error for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get the minimum error for.
    INTEGER(INTG), INTENT(OUT) :: minimumDataPointUserNumber !<On return, the user number of the data point that has the minimum error.
    REAL(DP), INTENT(OUT) :: minimumError !<On return, the minimum error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: minimumDataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ResultMinimumErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultMinimumErrorGet(dataProjection,minimumDataPointGlobalNumber,minimumError,err,error,*999)
    CALL DataPoints_DataUserNumberGet(dataPoints,minimumDataPointGlobalNumber,minimumDataPointUserNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ResultMinimumErrorGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultMinimumErrorGetNumber",err,error)
    EXITS("cmfe_DataProjection_ResultMinimumErrorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultMinimumErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the minimum error for a data projection given by an object.
  SUBROUTINE cmfe_DataProjection_ResultMinimumErrorGetObj(dataProjection,minimumDataPointUserNumber,minimumError,err)
    !DLLEXPORT(cmfe_DataProjection_ResultMinimumErrorGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get the minimum error for.
    INTEGER(INTG), INTENT(OUT) :: minimumDataPointUserNumber !<On return, the user number of the data point that has the minimum error.
    REAL(DP), INTENT(OUT) :: minimumError !<On return, the minimum error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: minimumDataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("cmfe_DataProjection_ResultMinimumErrorGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataProjection_ResultMinimumErrorGet(dataProjection%dataProjection,minimumDataPointGlobalNumber,minimumError, &
      & err,error,*999)
    CALL DataPoints_DataUserNumberGet(dataPoints,minimumDataPointGlobalNumber,minimumDataPointUserNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ResultMinimumErrorGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultMinimumErrorGetObj",err,error)
    EXITS("cmfe_DataProjection_ResultMinimumErrorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultMinimumErrorGetObj

  !
  !================================================================================================================================
  !

  !>Returns the RMS error for a data projection given by numbers.
  SUBROUTINE cmfe_DataProjection_ResultRMSErrorGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,rmsError,err)
    !DLLEXPORT(cmfe_DataProjection_ResultRMSErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the RMS error for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get the RMS error for.
    REAL(DP), INTENT(OUT) :: rmsError !<On return, the RMS error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_DataProjection_ResultRMSErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultRMSErrorGet(dataProjection,rmsError,err,error,*999)

    EXITS("cmfe_DataProjection_ResultRMSErrorGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultRMSErrorGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultRMSErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the RMS error for a data projection given by an object.
  SUBROUTINE cmfe_DataProjection_ResultRMSErrorGetObj(dataProjection,rmsError,err)
    !DLLEXPORT(cmfe_DataProjection_ResultRMSErrorGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get the RMS error for.
    REAL(DP), INTENT(OUT) :: rmsError !<On return, the RMS error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ResultRMSErrorGetObj",err,error,*999)

    CALL DataProjection_ResultRMSErrorGet(dataProjection%dataProjection,rmsError,err,error,*999)

    EXITS("cmfe_DataProjection_ResultRMSErrorGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultRMSErrorGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultRMSErrorGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection xi for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultXiGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionXi,err)
    !DLLEXPORT(cmfe_DataProjection_ResultXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOfProjectionXi
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ResultXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultXiGet(dataProjection,dataPointGlobalNumber,numberOfProjectionXi,projectionXi,err,error,*999)

    EXITS("cmfe_DataProjection_ResultXiGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultXiGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection xi for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultXiGetObj(dataProjection,dataPointUserNumber,projectionXi,err)
    !DLLEXPORT(cmfe_DataProjection_ResultXiGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOfProjectionXi
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("cmfe_DataProjection_ResultXiGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultXiGet(dataProjection%dataProjection,dataPointGlobalNumber,numberOfProjectionXi,projectionXi, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ResultXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets the projection xi for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultXiSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionXi,err)
    !DLLEXPORT(cmfe_DataProjection_ResultXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for.
    REAL(DP), INTENT(IN) :: projectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ResultXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultXiSet(dataProjection,dataPointglobalNumber,projectionXi,err,error,*999)

    EXITS("cmfe_DataProjection_ResultXiSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultXiSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the projection xi for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultXiSetObj(dataProjection,dataPointUserNumber,projectionXi,err)
    !DLLEXPORT(cmfe_DataProjection_ResultXiSetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for
    REAL(DP), INTENT(IN) :: projectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("cmfe_DataProjection_ResultXiSetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultXiSet(dataProjection%dataProjection,dataPointGlobalNumber,projectionXi,err,error,*999)

    EXITS("cmfe_DataProjection_ResultXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection vector for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultProjectionVectorGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionVector,err)
    !DLLEXPORT(cmfe_DataProjection_ResultProjectionVectorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionVector(:) !<On return, the projection vector for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ResultProjectionVectorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultProjectionVectorGet(dataProjection,dataPointGlobalNumber,projectionVector,err,error,*999)

    EXITS("cmfe_DataProjection_ResultProjectionVectorGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultProjectionVectorGetNumber",err,error)
    EXITS("cmfe_DataProjection_ResultProjectionVectorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultProjectionVectorGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection vector for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultProjectionVectorGetObj(dataProjection,dataPointUserNumber,projectionVector,err)
    !DLLEXPORT(cmfe_DataProjection_ResultProjectionVectorGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionVector(:) !<On return, the projection vector for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("cmfe_DataProjection_ResultProjectionVectorGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultProjectionVectorGet(dataProjection%dataProjection,dataPointGlobalNumber, &
      & projectionVector,err,error,*999)

    EXITS("cmfe_DataProjection_ResultProjectionVectorGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultProjectionVectorGetObj",err,error)
    EXITS("cmfe_DataProjection_ResultProjectionVectorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultProjectionVectorGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,maximumNumberOfIterations,err)
    !DLLEXPORT(cmfe_DataProjection_MaximumNumberOfIterationsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set maximum number of iterations for
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: maximumNumberOfIterations !<the maximum number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_MaximumNumberOfIterationsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_MaximumNumberOfIterationsSet(dataProjection,maximumNumberOfIterations,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsSetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumNumberOfIterationsSetNumber",err,error)
    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsSetObj(dataProjection,maximumNumberOfIterations,err)
    !DLLEXPORT(cmfe_DataProjection_MaximumNumberOfIterationsSetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumNumberOfIterations !<the maximum number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_MaximumNumberOfIterationsSetObj",err,error,*999)

    CALL DataProjection_MaximumNumberOfIterationsSet(dataProjection%dataProjection,maximumNumberOfIterations,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsSetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumNumberOfIterationsSetObj",err,error)
    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of closest elements of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,numberOfClosestElements,err)
    !DLLEXPORT(cmfe_DataProjection_NumberOfClosestElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfClosestElements !<On exit, the number of closest elements of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_NumberOfClosestElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_NumberOfClosestElementsGet(dataProjection,numberOfClosestElements,err,error,*999)

    EXITS("cmfe_DataProjection_NumberOfClosestElementsGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_NumberOfClosestElementsGetNumber",err,error)
    EXITS("cmfe_DataProjection_NumberOfClosestElementsGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of closest elements of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsGetObj(dataProjection,numberOfClosestElements,err)
    !DLLEXPORT(cmfe_DataProjection_NumberOfClosestElementsGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get number of closest elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfClosestElements !<On exit, the number of closest elements of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_NumberOfClosestElementsGetObj",err,error,*999)

    CALL DataProjection_NumberOfClosestElementsGet(dataProjection%dataProjection,numberOfClosestElements,err,error,*999)

    EXITS("cmfe_DataProjection_NumberOfClosestElementsGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_NumberOfClosestElementsGetObj",err,error)
    EXITS("cmfe_DataProjection_NumberOfClosestElementsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of closest elements of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,numberOfClosestElements,err)
    !DLLEXPORT(cmfe_DataProjection_NumberOfClosestElementsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfClosestElements !<the number of closest elements to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_DataProjection_NumberOfClosestElementsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_NumberOfClosestElementsSet(dataProjection,numberOfClosestElements,err,error,*999)

    EXITS("cmfe_DataProjection_NumberOfClosestElementsSetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_NumberOfClosestElementsSetNumber",err,error)
    EXITS("cmfe_DataProjection_NumberOfClosestElementsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of closest elements of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsSetObj(dataProjection,numberOfClosestElements,err)
    !DLLEXPORT(cmfe_DataProjection_NumberOfClosestElementsSetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfClosestElements !<the number of closest elements to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_NumberOfClosestElementsSetObj",err,error,*999)

    CALL DataProjection_NumberOfClosestElementsSet(dataProjection%dataProjection,numberOfClosestElements,err,error,*999)

    EXITS("cmfe_DataProjection_NumberOfClosestElementsSetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_NumberOfClosestElementsSetObj",err,error)
    EXITS("cmfe_DataProjection_NumberOfClosestElementsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection type of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_ProjectionTypeGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,projectionType,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get projection type for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(OUT) :: projectionType !<On exit, the projection type of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionTypeGet(dataProjection,projectionType,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ProjectionTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection type of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_ProjectionTypeGetObj(dataProjection,projectionType,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionTypeGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get projection type for.
    INTEGER(INTG), INTENT(OUT) :: projectionType !<On exit, the projection type of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionTypeGetObj",err,error,*999)

    CALL DataProjection_ProjectionTypeGet(dataProjection%dataProjection,projectionType,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ProjectionTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection type of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_ProjectionTypeSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,projectionType,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set projection type for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: projectionType !<the projection type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ProjectionTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionTypeSet(dataProjection,projectionType,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ProjectionTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection type of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_ProjectionTypeSetObj(dataProjection,projectionType,err)
    !DLLEXPORT(cmfe_DataProjection_ProjectionTypeSetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set projection type for.
    INTEGER(INTG), INTENT(IN) :: projectionType !<the projection type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionTypeSetObj",err,error,*999)

    CALL DataProjection_ProjectionTypeSet(dataProjection%dataProjection,projectionType,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ProjectionTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified by a data projection user number and a region user number.
  SUBROUTINE cmfe_DataProjection_RelativeToleranceGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,relativeTolerance,err)
    !DLLEXPORT(cmfe_DataProjection_RelativeToleranceGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On exit, the absolute relative tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_RelativeToleranceGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_RelativeToleranceGet(dataProjection,relativeTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_RelativeToleranceGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_RelativeToleranceGetNumber",err,error)
    EXITS("cmfe_DataProjection_RelativeToleranceGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_RelativeToleranceGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_RelativeToleranceGetObj(dataProjection,relativeTolerance,err)
    !DLLEXPORT(cmfe_DataProjection_RelativeToleranceGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get relative tolerance for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On exit, the absolute relative tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_RelativeToleranceGetObj",err,error,*999)

    CALL DataProjection_RelativeToleranceGet(dataProjection%dataProjection,relativeTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_RelativeToleranceGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_RelativeToleranceGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_RelativeToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified by a data projection user number and a region user number.
  SUBROUTINE cmfe_DataProjection_RelativeToleranceSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,relativeTolerance,err)
    !DLLEXPORT(cmfe_DataProjection_RelativeToleranceSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<the absolute relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_RelativeToleranceSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_RelativeToleranceSet(dataProjection,relativeTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_RelativeToleranceSetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_RelativeToleranceSetNumber",err,error)
    EXITS("cmfe_DataProjection_RelativeToleranceSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_RelativeToleranceSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_RelativeToleranceSetObj(dataProjection,relativeTolerance,err)
    !DLLEXPORT(cmfe_DataProjection_RelativeToleranceSetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<the absolute relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_RelativeToleranceSetObj",err,error,*999)

    CALL DataProjection_RelativeToleranceSet(dataProjection%dataProjection,relativeTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_RelativeToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_RelativeToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_RelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Returns the starting xi of data projection identified by a data projection user number and region user number.
  SUBROUTINE cmfe_DataProjection_StartingXiGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,startingXi,err)
    !DLLEXPORT(cmfe_DataProjection_StartingXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: startingXi(:) !<On exit, the absolute starting xi of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: numberOfStartingXi
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_StartingXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_StartingXiGet(dataProjection,numberOfStartingXi,startingXi,err,error,*999)

    EXITS("cmfe_DataProjection_StartingXiGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_StartingXiGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_StartingXiGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the starting xi of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_StartingXiGetObj(dataProjection,startingXi,err)
    !DLLEXPORT(cmfe_DataProjection_StartingXiGetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: startingXi(:) !<On exit, the absolute starting xi of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: numberOfStartingXi

    ENTERS("cmfe_DataProjection_StartingXiGetObj",err,error,*999)

    CALL DataProjection_StartingXiGet(dataProjection%dataProjection,numberOfStartingXi,startingXi,err,error,*999)

    EXITS("cmfe_DataProjection_StartingXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_StartingXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_StartingXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_StartingXiSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,startingXi,err)
    !DLLEXPORT(cmfe_DataProjection_StartingXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(IN) :: startingXi(:) !<the absolute starting xi to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_StartingXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_StartingXiSet(dataProjection,startingXi,err,error,*999)

    EXITS("cmfe_DataProjection_StartingXiSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_StartingXiSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_StartingXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_StartingXiSetObj(dataProjection,startingXi,err)
    !DLLEXPORT(cmfe_DataProjection_StartingXiSetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set starting xi for.
    REAL(DP), INTENT(IN) :: startingXi(:) !<the absolute starting xi to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_StartingXiSetObj",err,error,*999)

    CALL DataProjection_StartingXiSet(dataProjection%dataProjection,startingXi,err,error,*999)

    EXITS("cmfe_DataProjection_StartingXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_StartingXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_StartingXiSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_ElementSetInterfaceNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,elementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ElementSetInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<the element user number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,elementLocalNumber
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_DataProjection_ElementSetInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_LocalNumberGet(decompositionElements,elementUserNumber,elementLocalNumber, &
      & ghostElement,err,error,*999)
    CALL DataProjection_ElementSet(dataProjection,dataPointGlobalNumber,elementLocalNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ElementSetInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ElementSetInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_ElementSetInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ElementSetInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_ElementSetRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,elementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ElementSetRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<the element user number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,elementLocalNumber
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_ElementSetRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_LocalNumberGet(decompositionElements,elementUserNumber,elementLocalNumber, &
      & ghostElement,err,error,*999)
    CALL DataProjection_ElementSet(dataProjection,dataPointGlobalNumber,elementLocalNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ElementSetRegionNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ElementSetRegionNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ElementSetRegionNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_ElementSetObj(dataProjection,dataPointUserNumber,elementUserNumber,err)
    !DLLEXPORT(cmfe_DataProjection_ElementSetObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<the element user number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,elementLocalNumber
    LOGICAL :: ghostElement
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("cmfe_DataProjection_ElementSetObj",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_LocalNumberGet(decompositionElements,elementUserNumber,elementLocalNumber, &
      & ghostElement,err,error,*999)
    CALL DataProjection_ElementSet(dataProjection%dataProjection,dataPointGlobalNumber,elementLocalNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ElementSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ElementSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ElementSetObj

  !
  !================================================================================================================================
  !

  !>Get the character string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelGetCInterfaceNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelGetCInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_LabelGetCInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelGet(dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelGetCInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_LabelGetCInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_LabelGetCInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetCInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Get the varying string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelGetVSInterfaceNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelGetVSInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_LabelGetVSInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelGet(dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelGetVSInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_LabelGetVSInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_LabelGetVSInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetVSInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Get the character string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelGetCRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelGetCRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_LabelGetCRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelGet(dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelGetCRegionNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelGetCRegionNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetCRegionNumber

  !
  !================================================================================================================================
  !

  !>Get the varying string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelGetVSRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelGetVSRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_LabelGetVSRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelGet(dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelGetVSRegionNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelGetVSRegionNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetVSRegionNumber

  !
  !================================================================================================================================
  !

  !>Gets the character string label of a data projection identified an object.
  SUBROUTINE cmfe_DataProjection_LabelGetCObj(dataProjection,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelGetCObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_LabelGetCObj",err,error,*999)

    CALL DataProjection_LabelGet(dataProjection%dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Gets the varying string label of a data projection identified an object.
  SUBROUTINE cmfe_DataProjection_LabelGetVSObj(dataProjection,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelGetVSObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_LabelGetVSObj",err,error,*999)

    CALL DataProjection_LabelGet(dataProjection%dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelSetCInterfaceNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelSetCInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_LabelSetCInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelSet(dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelSetCInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_LabelSetCInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_LabelSetCInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetCInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelSetVSInterfaceNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelSetVSInterfaceNumber)

    !Argument variables
     INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
   INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionsType), POINTER :: regions
    TYPE(RegionType), POINTER :: parentRegion

    ENTERS("cmfe_DataProjection_LabelSetVSInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelSet(dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelSetVSInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_LabelSetVSInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_LabelSetVSInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetVSInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelSetCRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelSetCRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_DataProjection_LabelSetCRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelSet(dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelSetCRegionNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelSetCRegionNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetCRegionNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelSetVSRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelSetVSRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_DataProjection_LabelSetVSRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelSet(dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelSetVSRegionNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelSetVSRegionNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetVSRegionNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified an object.
  SUBROUTINE cmfe_DataProjection_LabelSetCObj(dataProjection,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelSetCObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_LabelSetCObj",err,error,*999)

    CALL DataProjection_LabelSet(dataProjection%dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified an object.
  SUBROUTINE cmfe_DataProjection_LabelSetVSObj(dataProjection,label,err)
    !DLLEXPORT(cmfe_DataProjection_LabelSetVSObj)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_LabelSetVSObj",err,error,*999)

    CALL DataProjection_LabelSet(dataProjection%dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetVSObj

!!==================================================================================================================================
!!
!! EquationsRoutines
!!
!!==================================================================================================================================

  !>Destroys equations for equations identified by a user number.
  SUBROUTINE cmfe_Equations_DestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_Equations_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to destroy.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Equations_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_Destroy(equations,err,error,*999)

    EXITS("cmfe_Equations_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy equations for equations identified by an object.
  SUBROUTINE cmfe_Equations_DestroyObj(equations,err)
    !DLLEXPORT(cmfe_Equations_DestroyObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(INOUT) :: equations !<The equations to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_DestroyObj",err,error,*999)

    CALL Equations_Destroy(equations%equations,err,error,*999)

    EXITS("cmfe_Equations_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_DestroyObj

  !
  !================================================================================================================================
  !

  !>Get a dynamic equations distributed matrix from equations using the dynamic matrix index
  SUBROUTINE cmfe_Equations_DynamicMatrixGetObj(equations,matrixIndex,matrix,err)
    !DLLEXPORT(cmfe_Equations_DynamicMatrixGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the dynamic matrix to get
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested dynamic matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesDynamicType), POINTER :: dynamicMatrices
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatrixType), POINTER :: dynamicMatrix
    TYPE(EquationsVectorType), POINTER :: vectorEquations
  
    ENTERS("cmfe_Equations_DynamicMatrixGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(dynamicMatrices)
    NULLIFY(dynamicMatrix)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_DynamicMatricesExists(vectorMatrices,dynamicMatrices,err,error,*999)
    IF(ASSOCIATED(dynamicMatrices)) THEN
      CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,matrixIndex,dynamicMatrix,err,error,*999)
      CALL EquationsMatrix_DistributedMatrixGet(dynamicMatrix,matrix%distributedMatrix,err,error,*999)
    ELSE
      NULLIFY(matrix%distributedMatrix)
    ENDIF

    EXITS("cmfe_Equations_DynamicMatrixGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_DynamicMatrixGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_DynamicMatrixGetObj

  !
  !================================================================================================================================
  !

  !>Get a dynamic equations distributed matrix from equations using the dynamic matrix type
  SUBROUTINE cmfe_Equations_DynamicMatrixGetByTypeObj(equations,matrixType,matrix,err)
    !DLLEXPORT(cmfe_Equations_DynamicMatrixGetByTypeObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix for
    INTEGER(INTG), INTENT(IN) :: matrixType !<The type of the dynamic matrix to get. \see OpenCMISS_EquationsDynamicMatrixTypes
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested dynamic matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    INTEGER(INTG) :: matrixNumber
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesDynamicType), POINTER :: dynamicMatrices
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatrixType), POINTER :: dynamicMatrix
    TYPE(EquationsVectorType), POINTER :: vectorEquations
 
    ENTERS("cmfe_Equations_DynamicMatrixGetByTypeObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(dynamicMapping)
    NULLIFY(vectorMatrices)
    NULLIFY(dynamicMatrices)
    NULLIFY(dynamicMatrix)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_DynamicMappingExists(vectorMapping,dynamicMapping,err,error,*999)
    IF(ASSOCIATED(dynamicMatrices)) THEN
      CALL EquationsMappingDynamic_MatrixTypeNumberGet(dynamicMapping,matrixType,matrixNumber,err,error,*999)
      IF(matrixNumber/=0) THEN
        CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
        CALL EquationsMatricesVector_DynamicMatricesGet(vectorMatrices,dynamicMatrices,err,error,*999)
        CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,matrixNumber,dynamicMatrix,err,error,*999)
        CALL EquationsMatrix_DistributedMatrixGet(dynamicMatrix,matrix%distributedMatrix,err,error,*999)
      ELSE
        NULLIFY(matrix%distributedMatrix)
      ENDIF
    ELSE
      NULLIFY(matrix%distributedMatrix)
    ENDIF

    EXITS("cmfe_Equations_DynamicMatrixGetByTypeObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_DynamicMatrixGetByTypeObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_DynamicMatrixGetByTypeObj

  !
  !================================================================================================================================
  !

  !>Get the type of a dynamic matrix from an equations set equations
  SUBROUTINE cmfe_Equations_DynamicMatrixTypeGetObj(equations,matrixIndex,matrixType,err)
    !DLLEXPORT(cmfe_Equations_DynamicMatrixTypeGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix type from
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the dynamic matrix to get the type of
    INTEGER(INTG), INTENT(OUT) :: matrixType !<On return, the dynamic matrix type. \see OpenCMISS_EquationsDynamicMatrixTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("cmfe_Equations_DynamicMatrixTypeGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(dynamicMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_DynamicMappingExists(vectorMapping,dynamicMapping,err,error,*999)
    IF(ASSOCIATED(dynamicMapping)) THEN
      CALL EquationsMappingDynamic_MatrixTypeGet(dynamicMapping,matrixIndex,matrixType,err,error,*999)
    ELSE
      matrixType=0
      CALL FlagError("The specified equations do not contain any dynamic matrices.",err,error,*999)
    ENDIF

    EXITS("cmfe_Equations_DynamicMatrixTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_DynamicMatrixTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_DynamicMatrixTypeGetObj
  
  !
  !================================================================================================================================
  !

  !>Setting Jacobian matrix calculation type for a matrix specified by user numbers.
  SUBROUTINE cmfe_Equations_JacobianCalculationTypeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & variableType,residualIndex,jacobianCalculationType,err)
    !DLLEXPORT(cmfe_Equations_JacobianCalculationTypeSetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations to set the Jacobian calculation type for
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type that the residual is differentiated with respect to for this Jacobian. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector of the Jacobian
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The type of Jacobian calculation. \see OpenCMISS_EquationsJacobianCalculated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Equations_JacobianCalculationTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_JacobianCalculationTypeSet(vectorMatrices,variableType,residualIndex, &
      & jacobianCalculationType,err,error,*999)

    EXITS("cmfe_Equations_JacobianCalculationTypeSetNumber")
    RETURN
999 ERRORS("cmfe_Equations_JacobianCalculationTypeSetNumber",err,error)
    EXITS("cmfe_Equations_JacobianCalculationTypeSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_JacobianCalculationTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Setting Jacobian matrix calculation type for a matrix specified by obj.
  SUBROUTINE cmfe_Equations_JacobianCalculationTypeSetObj(equations,variableType,residualIndex,jacobianCalculationType,err)
    !DLLEXPORT(cmfe_Equations_JacobianCalculationTypeSetObj)
    
    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to set the Jacobian evaluation type for. 
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type that the residual is differentiated with respect to for this Jacobian. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector of the Jacobian
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The type of Jacobian calculation. \see OpenCMISS_EquationsJacobianCalculated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices

    ENTERS("cmfe_Equations_JacobianCalculationTypeSetObj",err,error,*999)

    NULLIFY(vectorEquations)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    NULLIFY(vectorMatrices)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_JacobianCalculationTypeSet(vectorMatrices,variableType,residualIndex, &
      & jacobianCalculationType,err,error,*999)

    EXITS("cmfe_Equations_JacobianCalculationTypeSetObj")
    RETURN
999 ERRORS("cmfe_Equations_JacobianCalculationTypeSetObj",err,error)
    EXITS("cmfe_Equations_JacobianCalculationTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_JacobianCalculationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets the Jacobian matrix finite difference step size type for a matrix specified by user numbers.
  SUBROUTINE cmfe_Equations_JacobianFiniteDifferenceStepSizeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & variableType,residualIndex,jacobianFiniteDifferenceStepSize,err)
    !DLLEXPORT(cmfe_Equations_JacobianFiniteDifferenceStepSizeSetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations to set the Jacobian calculation type for
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type that the residual is differentiated with respect to for this Jacobian. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector of the Jacobian
    REAL(DP), INTENT(IN) :: jacobianFiniteDifferenceStepSize !<The finite difference step size to calculate the Jacobian with.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Equations_JacobianFiniteDifferenceStepSizeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_JacobianFiniteDifferenceStepSizeSet(vectorMatrices,variableType,residualIndex, &
      & jacobianFiniteDifferenceStepSize,err,error,*999)

    EXITS("cmfe_Equations_JacobianFiniteDifferenceStepSizeSetNumber")
    RETURN
999 ERRORS("cmfe_Equations_JacobianFiniteDifferenceStepSizeSetNumber",err,error)
    EXITS("cmfe_Equations_JacobianFiniteDifferenceStepSizeSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_JacobianFiniteDifferenceStepSizeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the finite difference step size used for calculating the Jacobian
  SUBROUTINE cmfe_Equations_JacobianFiniteDifferenceStepSizeSetObj(equations,variableType,residualIndex, &
    & jacobianFiniteDifferenceStepSize,err)
    !DLLEXPORT(cmfe_Equations_JacobianFiniteDifferenceStepSizeSetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to set the Jacobian finite difference step size for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type that the residual is differentiated with respect to for this Jacobian. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector of the Jacobian
    REAL(DP), INTENT(IN) :: jacobianFiniteDifferenceStepSize !<The finite difference step size to calculate the Jacobian with.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices

    ENTERS("cmfe_Equations_JacobianFiniteDifferenceStepSizeSetObj",err,error,*999)

    NULLIFY(vectorEquations)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    NULLIFY(vectorMatrices)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_JacobianFiniteDifferenceStepSizeSet(vectorMatrices,variableType,residualIndex, &
      & jacobianFiniteDifferenceStepSize,err,error,*999)

    EXITS("cmfe_Equations_JacobianFiniteDifferenceStepSizeSetObj")
    RETURN
999 ERRORS("cmfe_Equations_JacobianFiniteDifferenceStepSizeSetObj",err,error)
    EXITS("cmfe_Equations_JacobianFiniteDifferenceStepSizeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_JacobianFiniteDifferenceStepSizeSetObj

  !
  !================================================================================================================================
  !

  !>Get a Jacobian matrix distributed matrix for a specified residual and variable indices from equations
  SUBROUTINE cmfe_Equations_JacobianMatrixGetByNumberObj(equations,residualIndex,variableIndex,matrix,err)
    !DLLEXPORT(cmfe_Equations_JacobianMatrixGetByNumberObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: variableIndex !<The index of the residual variable to get the Jacobian matrix for
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested Jacobian matrix distributed matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(JacobianMatrixType), POINTER :: jacobianMatrix

    ENTERS("cmfe_Equations_JacobianMatrixGetByNumberObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(nonlinearMatrices)
    NULLIFY(residualVector)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_NonlinearMatricesExists(vectorMatrices,nonlinearMatrices,err,error,*999)
    IF(ASSOCIATED(nonlinearMatrices)) THEN
      CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,residualIndex,residualVector,err,error,*999)
      CALL EquationsMatricesResidual_JacobianMatrixGet(residualVector,variableIndex,jacobianMatrix,err,error,*999)
      CALL JacobianMatrix_DistributedMatrixGet(jacobianMatrix,matrix%distributedMatrix,err,error,*999)
    ELSE
      CALL FlagError("The specified equations do not contain any nonlinear matrices.",err,error,*999)
    ENDIF

    EXITS("cmfe_Equations_JacobianMatrixGetByNumberObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_JacobianMatrixGetByNumberObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_JacobianMatrixGetByNumberObj

  !
  !================================================================================================================================
  !

  !>Get a Jacobian matrix distributed matrix for a specified residual index and variable type from an equations
  SUBROUTINE cmfe_Equations_JacobianMatrixGetByTypeObj(equations,residualIndex,variableType,matrix,err)
    !DLLEXPORT(cmfe_Equations_JacobianMatrixGetByTypeObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the Jacobian matrix for
     INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type in the residual is differentiated with respect to for this Jacobian. \see OpenCMISS_FieldVariableTypes
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested Jacobian matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    INTEGER(INTG) :: variableIndex
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(JacobianMatrixType), POINTER :: jacobianMatrix

    ENTERS("cmfe_Equations_JacobianMatrixGetByTypeObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    NULLIFY(vectorMatrices)
    NULLIFY(nonlinearMatrices)
    NULLIFY(residualVector)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,residualIndex,residualMapping,err,error,*999)
      CALL EquationsMappingResidual_VariableIndexGet(residualMapping,variableType,variableIndex,err,error,*999)
      IF(variableIndex/=0) THEN
        CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
        CALL EquationsMatricesVector_NonlinearMatricesExists(vectorMatrices,nonlinearMatrices,err,error,*999)
        CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,residualIndex,residualVector,err,error,*999)
        CALL EquationsMatricesResidual_JacobianMatrixGet(residualVector,variableIndex,jacobianMatrix,err,error,*999)
        CALL JacobianMatrix_DistributedMatrixGet(jacobianMatrix,matrix%distributedMatrix,err,error,*999)
      ELSE
        NULLIFY(matrix%distributedMatrix)
      ENDIF
    ELSE
      CALL FlagError("The specified equations do not contain any nonlinear matrices.",err,error,*999)
    ENDIF

    EXITS("cmfe_Equations_JacobianMatrixGetByTypeObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_JacobianMatrixGetByTypeObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_JacobianMatrixGetByTypeObj

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_LinearityTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,linearityType,err)
    !DLLEXPORT(cmfe_Equations_LinearityTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the linearity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the linearity type of the equations \see OpenCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Equations_LinearityTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_LinearityTypeGet(equations,linearityType,err,error,*999)

    EXITS("cmfe_Equations_LinearityTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LinearityTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LinearityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for equations identified by an object.
  SUBROUTINE cmfe_Equations_LinearityTypeGetObj(equations,linearityType,err)
    !DLLEXPORT(cmfe_Equations_LinearityTypeGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the linearity type of the equations \see OpenCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_LinearityTypeGetObj",err,error,*999)

    CALL Equations_LinearityTypeGet(equations%equations,linearityType,err,error,*999)

    EXITS("cmfe_Equations_LinearityTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LinearityTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get a linear equations distributed matrix from the equations
  SUBROUTINE cmfe_Equations_LinearMatrixGetObj(equations,matrixIndex,matrix,err)
    !DLLEXPORT(cmfe_Equations_LinearMatrixGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the linear matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the linear matrix to get
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested linear matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesLinearType), POINTER :: linearMatrices
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatrixType), POINTER :: linearMatrix
    TYPE(EquationsVectorType), POINTER :: vectorEquations
  
    ENTERS("cmfe_Equations_LinearMatrixGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(linearMatrices)
    NULLIFY(linearMatrix)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_LinearMatricesExists(vectorMatrices,linearMatrices,err,error,*999)
    IF(ASSOCIATED(linearMatrices)) THEN
      CALL EquationsMatricesLinear_EquationsMatrixGet(linearMatrices,matrixIndex,linearMatrix,err,error,*999)
      CALL EquationsMatrix_DistributedMatrixGet(linearMatrix,matrix%distributedMatrix,err,error,*999)
    ELSE
      NULLIFY(matrix%distributedMatrix)
    ENDIF

    EXITS("cmfe_Equations_LinearMatrixGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LinearMatrixGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LinearMatrixGetObj

  !
  !================================================================================================================================
  !

  !>Gets the lumping type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_LumpingTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,lumpingType,err)
    !DLLEXPORT(cmfe_Equations_LumpingTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the lumping type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: lumpingType !<On return, the lumping type of the equations \see OpenCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Equations_LumpingTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_LumpingTypeGet(equations,lumpingType,err,error,*999)

    EXITS("cmfe_Equations_LumpingTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LumpingTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LumpingTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the lumping type for equations identified by an object.
  SUBROUTINE cmfe_Equations_LumpingTypeGetObj(equations,lumpingType,err)
    !DLLEXPORT(cmfe_Equations_LumpingTypeGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: lumpingType !<On return, the lumping type of the equations \see OpenCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_LumpingTypeGetObj",err,error,*999)

    CALL Equations_LumpingTypeGet(equations%equations,lumpingType,err,error,*999)

    EXITS("cmfe_Equations_LumpingTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LumpingTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LumpingTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the lumping type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_LumpingTypeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,lumpingType,err)
    !DLLEXPORT(cmfe_Equations_LumpingTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: lumpingType !<The lumping type of the equations to set\see OpenCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Equations_LumpingTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_LumpingTypeSet(equations,lumpingType,err,error,*999)

    EXITS("cmfe_Equations_LumpingTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LumpingTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LumpingTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the lumping type for equations identified by an object.
  SUBROUTINE cmfe_Equations_LumpingTypeSetObj(equations,lumpingType,err)
    !DLLEXPORT(cmfe_Equations_LumpingTypeSetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(INOUT) :: equations !<The equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: lumpingType !<The lumping type of the equations to set\see OpenCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_LumpingTypeSetObj",err,error,*999)

    CALL Equations_LumpingTypeSet(equations%equations,lumpingType,err,error,*999)

    EXITS("cmfe_Equations_LumpingTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LumpingTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LumpingTypeSetObj

  !
  !================================================================================================================================
  !

  !>Get the number of dynamic matrices in the equations
  SUBROUTINE cmfe_Equations_NumberOfDynamicMatricesGetObj(equations,numberOfMatrices,err)
    !DLLEXPORT(cmfe_Equations_NumberOfDynamicMatricesGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the number of dynamic matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of dynamic matrices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("cmfe_Equations_NumberOfDynamicMatricesGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(dynamicMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_DynamicMappingExists(vectorMapping,dynamicMapping,err,error,*999)
    IF(ASSOCIATED(dynamicMapping)) THEN
      CALL EquationsMappingDynamic_NumberOfDynamicMatricesGet(dynamicMapping,numberOfMatrices,err,error,*999)
    ELSE
      numberOfMatrices=0
    ENDIF

    EXITS("cmfe_Equations_NumberOfDynamicMatricesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_NumberOfDynamicMatricesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_NumberOfDynamicMatricesGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of Jacobian matrices in a residual vector in the equations
  SUBROUTINE cmfe_Equations_NumberOfJacobianMatricesGetObj(equations,residualNumber,numberOfMatrices,err)
    !DLLEXPORT(cmfe_Equations_NumberOfJacobianMatricesGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the number of Jacobian matrices for
    INTEGER(INTG), INTENT(IN) :: residualNumber !<The residual number to get the number of Jacobian matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of Jacobian matrices for the residual vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("cmfe_Equations_NumberOfJacobianMatricesGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,residualNumber,residualMapping,err,error,*999)
      CALL EquationsMappingResidual_NumberOfJacobianMatricesGet(residualMapping,numberOfMatrices,err,error,*999)
    ELSE
      numberOfMatrices=0
    ENDIF

    EXITS("cmfe_Equations_NumberOfJacobianMatricesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_NumberOfJacobianMatricesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_NumberOfJacobianMatricesGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of linear matrices in the equations
  SUBROUTINE cmfe_Equations_NumberOfLinearMatricesGetObj(equations,numberOfMatrices,err)
    !DLLEXPORT(cmfe_Equations_NumberOfLinearMatricesGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the number of linear matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of linear matrices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingLinearType), POINTER :: linearMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("cmfe_Equations_NumberOfLinearMatricesGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(linearMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_LinearMappingExists(vectorMapping,linearMapping,err,error,*999)
    IF(ASSOCIATED(linearMapping)) THEN
      CALL EquationsMappingLinear_NumberOfLinearMatricesGet(linearMapping,numberOfMatrices,err,error,*999)
    ELSE
      numberOfMatrices=0
    ENDIF

    EXITS("cmfe_Equations_NumberOfLinearMatricesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_NumberOfLinearMatricesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_NumberOfLinearMatricesGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of residual vectors in the equations
  SUBROUTINE cmfe_Equations_NumberOfResidualVectorsGetObj(equations,numberOfVectors,err)
    !DLLEXPORT(cmfe_Equations_NumberOfResidualVectorsGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the number of residual vectors for
    INTEGER(INTG), INTENT(OUT) :: numberOfVectors !<On return, the number of residual vectors in the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("cmfe_Equations_NumberOfResidualVectorsGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_NumberOfResidualsGet(nonlinearMapping,numberOfVectors,err,error,*999)
    ELSE
      numberOfVectors=0
    ENDIF

    EXITS("cmfe_Equations_NumberOfResidualVectorsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_NumberOfResidualVectorsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_NumberOfResidualVectorsGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of source vectors in the equations
  SUBROUTINE cmfe_Equations_NumberOfSourceVectorsGetObj(equations,numberOfVectors,err)
    !DLLEXPORT(cmfe_Equations_NumberOfSourceVectorsGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the number of source vectors for
    INTEGER(INTG), INTENT(OUT) :: numberOfVectors !<On return, the number of source vectors in the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingSourcesType), POINTER :: sourcesMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("cmfe_Equations_NumberOfSourceVectorsGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(sourcesMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_SourcesMappingExists(vectorMapping,sourcesMapping,err,error,*999)
    IF(ASSOCIATED(sourcesMapping)) THEN
      CALL EquationsMappingSources_NumberOfSourcesGet(sourcesMapping,numberOfVectors,err,error,*999)
    ELSE
      numberOfVectors=0
    ENDIF

    EXITS("cmfe_Equations_NumberOfSourceVectorsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_NumberOfSourceVectorsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_NumberOfSourceVectorsGetObj

  !
  !================================================================================================================================
  !

  !>Gets the output type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_OutputTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,outputType,err)
    !DLLEXPORT(cmfe_Equations_OutputTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations \see OpenCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Equations_OutputTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_OutputTypeGet(equations,outputType,err,error,*999)

    EXITS("cmfe_Equations_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_OutputTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type for equations identified by an object.
  SUBROUTINE cmfe_Equations_OutputTypeGetObj(equations,outputType,err)
    !DLLEXPORT(cmfe_Equations_OutputTypeGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations \see OpenCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_OutputTypeGetObj",err,error,*999)

    CALL Equations_OutputTypeGet(equations%equations,outputType,err,error,*999)

    EXITS("cmfe_Equations_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_OutputTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_OutputTypeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,outputType,err)
    !DLLEXPORT(cmfe_Equations_OutputTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations to set \see OpenCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Equations_OutputTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_OutputTypeSet(equations,outputType,err,error,*999)

    EXITS("cmfe_Equations_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_OutputTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for equations identified by an object.
  SUBROUTINE cmfe_Equations_OutputTypeSetObj(equations,outputType,err)
    !DLLEXPORT(cmfe_Equations_OutputTypeSetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(INOUT) :: equations !<The equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations to set \see OpenCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_OutputTypeSetObj",err,error,*999)

    CALL Equations_OutputTypeSet(equations%equations,outputType,err,error,*999)

    EXITS("cmfe_Equations_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_OutputTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Get the number of field variables that contribute to the residual vector
  SUBROUTINE cmfe_Equations_ResidualNumberOfVariablesGetObj(equations,residualIndex,numberOfVariables,err)
    !DLLEXPORT(cmfe_Equations_ResidualNumberOfVariablesGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the residual vector number of variables for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the number of variables for
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables that contribute to the residual vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("cmfe_Equations_ResidualNumberOfVariablesGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,residualIndex,residualMapping,err,error,*999)
      CALL EquationsMappingResidual_NumberOfResidualVariablesGet(residualMapping,numberOfVariables,err,error,*999)
    ELSE
      numberOfVariables=0
    ENDIF
 
    EXITS("cmfe_Equations_ResidualNumberOfVariablesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_ResidualNumberOfVariablesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_ResidualNumberOfVariablesGetObj

  !
  !================================================================================================================================
  !

  !>Get the field variable type in a residual vector
  SUBROUTINE cmfe_Equations_ResidualVariableTypeGetObj(equations,residualIndex,variableIndex,residualVariableType,err)
    !DLLEXPORT(cmfe_Equations_ResidualVariableTypeGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the residual vector variables for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the variable type for
    INTEGER(INTG), INTENT(IN) :: variableIndex !<The index of the variable in the residual vector to get the variable type for
    INTEGER(INTG), INTENT(OUT) :: residualVariableType !<On return, the field variable type for the variableIndex'th residual variable. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("cmfe_Equations_ResidualVariableTypeGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,residualIndex,residualMapping,err,error,*999)
      CALL EquationsMappingResidual_VariableTypeGet(residualMapping,variableIndex,residualVariableType,err,error,*999)
    ELSE
      residualVariableType=0
    ENDIF

    EXITS("cmfe_Equations_ResidualVariableTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_ResidualVariableTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_ResidualVariableTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the field variables that contribute to the residual vector
  SUBROUTINE cmfe_Equations_ResidualVariableTypesGetObj(equations,residualIndex,residualVariableTypes,err)
    !DLLEXPORT(cmfe_Equations_ResidualVariableTypesGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the residual vector variables for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the variables for
    INTEGER(INTG), INTENT(OUT) :: residualVariableTypes(:) !<residualVariableTypes(varIdx). On return, the field variable type for the varIdx'th residual variable. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    INTEGER(INTG) :: numberOfVariables,variableIdx
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Equations_ResidualVariableTypesGetObj",err,error,*999)

    residualVariableTypes=0
    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,residualIndex,residualMapping,err,error,*999)
      CALL EquationsMappingResidual_NumberOfResidualVariablesGet(residualMapping,numberOfVariables,err,error,*999)
      IF(SIZE(residualVariableTypes,1)<numberOfVariables) THEN
        localError="The size of the specified residual variable types array of "// &
          & TRIM(NumberToVString(SIZE(residualVariableTypes,1),"*",err,error))// &
          & " is too small. The size of the residual variable types array should be >= "// &
          & TRIM(NumberToVString(numberOfVariables,"*",err,error))//" for residual number "// &
          & TRIM(NumberToVString(residualIndex,"*",err,error))//" of the equations."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      DO variableIdx=1,numberOfVariables
        CALL EquationsMappingResidual_VariableTypeGet(residualMapping,variableIdx,residualVariableTypes(variableIdx), &
          & err,error,*999)
      ENDDO !variableIdx
    ENDIF

    EXITS("cmfe_Equations_ResidualVariableTypesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_ResidualVariableTypesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_ResidualVariableTypesGetObj

  !
  !================================================================================================================================
  !

  !>Get a residual distributed vector for equations
  SUBROUTINE cmfe_Equations_ResidualVectorGetObj(equations,residualIndex,vector,err)
    !DLLEXPORT(cmfe_Equations_ResidualVectorGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the residual vector for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: vector !<On return, the residual distributed vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("cmfe_Equations_ResidualVectorGetObj",err,error,*999)
    
    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(nonlinearMatrices)
    NULLIFY(residualVector)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_NonlinearMatricesExists(vectorMatrices,nonlinearMatrices,err,error,*999)
    IF(ASSOCIATED(nonlinearMatrices)) THEN
      CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,residualIndex,residualVector,err,error,*999)
      CALL EquationsMatricesResidual_DistributedVectorGet(residualVector,EQUATIONS_MATRICES_CURRENT_VECTOR, &
        & vector%distributedVector,err,error,*999)
    ELSE
      NULLIFY(vector%distributedVector)
    ENDIF

    EXITS("cmfe_Equations_ResidualVectorGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_ResidualVectorGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_ResidualVectorGetObj

  !
  !================================================================================================================================
  !

  !>Get the right hand side distributed vector for equations
  SUBROUTINE cmfe_Equations_RHSVectorGetObj(equations,vector,err)
    !DLLEXPORT(cmfe_Equations_RHSVectorGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the right hand side vector for
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: vector !<On return, the right hand side distributed vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesRHSType), POINTER :: rhsVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("cmfe_Equations_RHSVectorGetObj",err,error,*999)
    
    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(rhsVector)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_RHSVectorExists(vectorMatrices,rhsVector,err,error,*999)
    IF(ASSOCIATED(rhsVector)) THEN
      CALL EquationsMatricesRHS_DistributedVectorGet(rhsVector,EQUATIONS_MATRICES_CURRENT_VECTOR,vector%distributedVector, &
        & err,error,*999)
    ELSE
      NULLIFY(vector%distributedVector)
    ENDIF

    EXITS("cmfe_Equations_RHSVectorGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_RHSVectorGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_RHSVectorGetObj

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_SparsityTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,sparsityType,err)
    !DLLEXPORT(cmfe_Equations_SparsityTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the equations \see OpenCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Equations_SparsityTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_SparsityTypeGet(equations,sparsityType,err,error,*999)

    EXITS("cmfe_Equations_SparsityTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_SparsityTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_SparsityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for equations identified by an object.
  SUBROUTINE cmfe_Equations_SparsityTypeGetObj(equations,sparsityType,err)
    !DLLEXPORT(cmfe_Equations_SparsityTypeGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the equations \see OpenCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_SparsityTypeGetObj",err,error,*999)

    CALL Equations_SparsityTypeGet(equations%equations,sparsityType,err,error,*999)

    EXITS("cmfe_Equations_SparsityTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_SparsityTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_SparsityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_SparsityTypeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,sparsityType,err)
    !DLLEXPORT(cmfe_Equations_SparsityTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type of the equations to set \see OpenCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Equations_SparsityTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_SparsityTypeSet(equations,sparsityType,err,error,*999)

    EXITS("cmfe_Equations_SparsityTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_SparsityTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_SparsityTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for equations identified by an object.
  SUBROUTINE cmfe_Equations_SparsityTypeSetObj(equations,sparsityType,err)
    !DLLEXPORT(cmfe_Equations_SparsityTypeSetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(INOUT) :: equations !<The equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type of the equations to set \see OpenCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_SparsityTypeSetObj",err,error,*999)

    CALL Equations_SparsityTypeSet(equations%equations,sparsityType,err,error,*999)

    EXITS("cmfe_Equations_SparsityTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_SparsityTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_SparsityTypeSetObj
  
  !
  !================================================================================================================================
  !

  !>Get the source distributed vector for equations
  SUBROUTINE cmfe_Equations_SourceVectorGetObj(equations,sourceIndex,vector,err)
    !DLLEXPORT(cmfe_Equations_SourceVectorGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the source vector for
    INTEGER(INTG), INTENT(IN) :: sourceIndex !<The index of the source vector to get the distributed vector for
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: vector !<On return, the source distributed vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesSourceType), POINTER :: sourceVector
    TYPE(EquationsMatricesSourcesType), POINTER :: sourceVectors
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("cmfe_Equations_SourceVectorGetObj",err,error,*999)
    
    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(sourceVectors)
    NULLIFY(sourceVector)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_SourceVectorsExists(vectorMatrices,sourceVectors,err,error,*999)
    IF(ASSOCIATED(sourceVectors)) THEN
      CALL EquationsMatricesSources_SourceVectorGet(sourceVectors,sourceIndex,sourceVector,err,error,*999)
      CALL EquationsMatricesSource_DistributedVectorGet(sourceVector,EQUATIONS_MATRICES_CURRENT_VECTOR,vector%distributedVector, &
        & err,error,*999)
    ELSE
      NULLIFY(vector%distributedVector)
    ENDIF

    EXITS("cmfe_Equations_SourceVectorGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_SourceVectorGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_SourceVectorGetObj

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_TimeDependenceTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & timeDependenceType,err)
    !DLLEXPORT(cmfe_Equations_TimeDependenceTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the time dependence type of the equations \see OpenCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_Equations_TimeDependenceTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_TimeDependenceTypeGet(equations,timeDependenceType,err,error,*999)

    EXITS("cmfe_Equations_TimeDependenceTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_TimeDependenceTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_TimeDependenceTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for equations identified by an object.
  SUBROUTINE cmfe_Equations_TimeDependenceTypeGetObj(equations,timeDependenceType,err)
    !DLLEXPORT(cmfe_Equations_TimeDependenceTypeGetObj)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the time dependence type of the equations \see OpenCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_TimeDependenceTypeGetObj",err,error,*999)

    CALL Equations_TimeDependenceTypeGet(equations%equations,timeDependenceType,err,error,*999)

    EXITS("cmfe_Equations_TimeDependenceTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_TimeDependenceTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_TimeDependenceTypeGetObj

!!==================================================================================================================================
!!
!! EquationsSetRoutines
!!
!!==================================================================================================================================

  !>Finish the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_AnalyticCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticCreateFinish(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_AnalyticCreateFinishNumber",err,error)
    EXITS("cmfe_EquationsSet_AnalyticCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a analytic solution for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticCreateFinishObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticCreateFinishObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticCreateFinishObj",err,error,*999)

    CALL EquationsSet_AnalyticCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & analyticFunctionType,analyticFieldUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: analyticFunctionType !<The analytic function type to use. \see OpenCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: analyticFieldUserNumber !<The user number of the field for the analytic function
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: analyticField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_AnalyticCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(analyticField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(analyticFieldUserNumber,region,analyticField,err,error,*999)
    CALL EquationsSet_AnalyticCreateStart(equationsSet,analyticFunctionType,analyticFieldUserNumber,analyticField, &
      & err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of an analytic solution for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticCreateStartObj(equationsSet,analyticFunctionType,analyticFieldUserNumber,analyticField,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticCreateStartObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the analytic creation on.
    INTEGER(INTG), INTENT(IN) :: analyticFunctionType !<The analytic function type to use. \see OpenCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: analyticFieldUserNumber !<The user number of the field for the analytic function
    TYPE(cmfe_FieldType), INTENT(INOUT) :: analyticField !<If associated on entry, the user created analytic field which has the same user number as the specified analytic field user number. If not associated on entry, on return, the created analytic field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticCreateStartObj",err,error,*999)

    CALL EquationsSet_AnalyticCreateStart(equationsSet%equationsSet,analyticFunctionType,analyticFieldUserNumber, &
      & analyticField%field,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the analytic solution for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_AnalyticDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticDestroy(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the analytic solution for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticDestroyObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticDestroyObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the analytic for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticDestroyObj",err,error,*999)

    CALL EquationsSet_AnalyticDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticDestroyObj


  !
  !================================================================================================================================
  !

  !>Evaluates the current analytic solution for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticEvaluateNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticEvaluateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to evaluate.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to evaluate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_AnalyticEvaluateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticEvaluate(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticEvaluateNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticEvaluateNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticEvaluateNumber

  !
  !================================================================================================================================
  !

  !>Evaluates the current analytic solution for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticEvaluateObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticEvaluateObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to evaluate the current analytic solution for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticEvaluateObj",err,error,*999)

    CALL EquationsSet_AnalyticEvaluate(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticEvaluateObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticEvaluateObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticEvaluateObj

  !
  !================================================================================================================================
  !

  !>Returns the analytic time for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticTimeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,time,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticTimeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set get the analytic time for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the analytic time get.
    REAL(DP), INTENT(OUT) :: time !<On return, the analytic time for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_AnalyticTimeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticTimeGet(equationsSet,time,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticTimeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticTimeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticTimeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the analytic time for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticTimeGetObj(equationsSet,time,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticTimeGetObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to get the analytic time for.
    REAL(DP), INTENT(OUT) :: time !<On return, the analytic time for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticTimeGetObj",err,error,*999)

    CALL EquationsSet_AnalyticTimeGet(equationsSet%equationsSet,time,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticTimeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticTimeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticTimeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the analytic time for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticTimeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,time,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticTimeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set get the analytic time for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the analytic time get.
    REAL(DP), INTENT(IN) :: time !<The analytic time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_AnalyticTimeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticTimeSet(equationsSet,time,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticTimeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticTimeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticTimeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the analytic time for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticTimeSetObj(equationsSet,time,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticTimeSetObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic time for.
    REAL(DP), INTENT(IN) :: time !<The analytic time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticTimeSetObj",err,error,*999)

    CALL EquationsSet_AnalyticTimeSet(equationsSet%equationsSet,time,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticTimeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticTimeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticTimeSetObj

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE cmfe_EquationsSet_AnalyticUserParamSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & paramIdx,param,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticUserParamSetNumber)
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(IN) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_AnalyticUserParamSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticUserParamSet(equationsSet,paramIdx,param,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticUserParamSetNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_AnalyticUserParamSetNumber",err,error)
    EXITS("cmfe_EquationsSet_AnalyticUserParamSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticUserParamSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE cmfe_EquationsSet_AnalyticUserParamSetObj(equationsSet,paramIdx,param,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticUserParamSetObj)
    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic user parameter.
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(IN) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticUserParamSetObj",err,error,*999)

    CALL EquationsSet_AnalyticUserParamSet(equationsSet%equationsSet,paramIdx,param,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticUserParamSetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticUserParamSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticUserParamSetObj

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE cmfe_EquationsSet_AnalyticUserParamGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & paramIdx,param,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticUserParamGetNumber)
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(OUT) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_AnalyticUserParamGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticUserParamGet(equationsSet,paramIdx,param,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticUserParamGetNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_AnalyticUserParamGetNumber",err,error)
    EXITS("cmfe_EquationsSet_AnalyticUserParamGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticUserParamGetNumber

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE cmfe_EquationsSet_AnalyticUserParamGetObj(equationsSet,paramIdx,param,err)
    !DLLEXPORT(cmfe_EquationsSet_AnalyticUserParamGetObj)
    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic user parameter.
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(OUT) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticUserParamGetObj",err,error,*999)

    CALL EquationsSet_AnalyticUserParamGet(equationsSet%equationsSet,paramIdx,param,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticUserParamGetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticUserParamGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticUserParamGetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_CreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_CreateFinish(equationsSet,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    EXITS("cmfe_EquationsSet_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_CreateFinishObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_CreateFinishObj",err,error,*999)

    CALL EquationsSet_CreateFinish(equationsSet%equationsSet,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    EXITS("cmfe_EquationsSet_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_CreateStartNumber(equationsSetUserNumber,contextUserNumber,regionUserNumber,&
      & geomFibreFieldUserNumber,equationsSetSpecification,equationsSetFieldUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to be created.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of an equations set on.
    INTEGER(INTG), INTENT(IN) :: geomFibreFieldUserNumber !<The user number of the Geometric/Fibre field for the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetSpecification(:) !<The equations set specification array, containing the equations class, type etc
    INTEGER(INTG), INTENT(IN) :: equationsSetFieldUserNumber !<The user number of the equations set field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: geometryFibreField,equationsSetField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Equations Set Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(geometryFibreField)
    NULLIFY(equationsSetField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,geomFibreFieldUserNumber,geometryFibreField,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(equationsSetFieldUserNumber,region,equationsSetField,err,error,*999)
    CALL EquationsSet_CreateStart(equationsSetUserNumber,region,geometryFibreField,&
      & equationsSetSpecification,equationsSetFieldUserNumber,&
      & equationsSetField,equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_CreateStartObj(equationsSetUserNumber,region,geomFibreField,&
      & equationsSetSpecification,equationsSetFieldUserNumber,&
      & equationsSetFieldField,equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to be created.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to create the equations set on.
    TYPE(cmfe_FieldType), INTENT(IN) :: geomFibreField !<The Geometric/Fibre field for the creation of the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetSpecification(:) !<The equations set specification array, containing the equations class, type etc
    INTEGER(INTG), INTENT(IN) :: equationsSetFieldUserNumber !<The user number of the equations set field
    TYPE(cmfe_FieldType), INTENT(INOUT) :: equationsSetFieldField !<On return, a pointer to the equations set field
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<On return, the created equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_CreateStartObj",err,error,*999)

    CALL EquationsSet_CreateStart(equationsSetUserNumber,region%region,geomFibreField%field, &
      & equationsSetSpecification,equationsSetFieldUserNumber,equationsSetFieldField%field, &
      & equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of derived variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DerivedCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_DerivedCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to finish the creation of derived variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_DerivedCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DerivedCreateFinish(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of derived variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DerivedCreateFinishObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_DerivedCreateFinishObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DerivedCreateFinishObj",err,error,*999)

    CALL EquationsSet_DerivedCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of derived variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DerivedCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & derivedFieldUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_DerivedCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to start the creation of derived variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of derived variables for.
    INTEGER(INTG), INTENT(IN) :: derivedFieldUserNumber !<The user number of the derived field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: derivedField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_DerivedCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(derivedField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(derivedFieldUserNumber,region,derivedField,err,error,*999)
    CALL EquationsSet_DerivedCreateStart(equationsSet,derivedFieldUserNumber,derivedField,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of derived variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DerivedCreateStartObj(equationsSet,derivedFieldUserNumber,derivedField,err)
    !DLLEXPORT(cmfe_EquationsSet_DerivedCreateStartObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of derived variables on.
    INTEGER(INTG), INTENT(IN) :: derivedFieldUserNumber !<The user number of the derived field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: derivedField !<If associated on entry, the user created derived field which has the same user number as the specified derived field user number. If not associated on entry, on return, the created derived field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DerivedCreateStartObj",err,error,*999)

    CALL EquationsSet_DerivedCreateStart(equationsSet%equationsSet,derivedFieldUserNumber,derivedField%field, &
      & err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the derived variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DerivedDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_DerivedDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to destroy the derived variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_DerivedDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DerivedDestroy(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the derived variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DerivedDestroyObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_DerivedDestroyObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DerivedDestroyObj",err,error,*999)

    CALL EquationsSet_DerivedDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedDestroyObj

  !
  !================================================================================================================================
  !

  !>Calculates a derived field value for the equations set and stores the result in the derived field previously set up
  SUBROUTINE cmfe_EquationsSet_DerivedVariableCalculateNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & derivedTensorType,err)
    !DLLEXPORT(cmfe_EquationsSet_DerivedVariableCalculateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The derived variable type to calculate. \see OpenCMISS_EquationsSetDerivedTensorTypes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_DerivedVariableCalculateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DerivedVariableCalculate(equationsSet,derivedTensorType,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedVariableCalculateNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_DerivedVariableCalculateNumber",err,error)
    EXITS("cmfe_EquationsSet_DerivedVariableCalculateNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedVariableCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculates a derived field value for the equations set and stores the result in the derived field previously set up
  SUBROUTINE cmfe_EquationsSet_DerivedVariableCalculateObj(equationsSet,derivedTensorType,err)
    !DLLEXPORT(cmfe_EquationsSet_DerivedVariableCalculateObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The derived field tensor type to calculate. \see OpenCMISS_EquationsSetDerivedTensorTypes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_EquationsSet_DerivedVariableCalculateObj",err,error,*999)

    CALL EquationsSet_DerivedVariableCalculate(equationsSet%equationsSet,derivedTensorType,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedVariableCalculateObj")
    RETURN
999 ERRORS("cmfe_EquationsSet_DerivedVariableCalculateObj",err,error)
    EXITS("cmfe_EquationsSet_DerivedVariableCalculateObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedVariableCalculateObj

  !
  !================================================================================================================================
  !

  !>Sets the field variable type of the derived field to be used to store a derived variable
  SUBROUTINE cmfe_EquationsSet_DerivedVariableSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & derivedTensorType,fieldVariableType,err)
    !DLLEXPORT(cmfe_EquationsSet_DerivedVariableSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The derived variable tensor type to calculate. \see OpenCMISS_EquationsSetDerivedTensorTypes.
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to store the calculated values in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_EquationsSet_DerivedVariableSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DerivedVariableSet(equationsSet,derivedTensorType,fieldVariableType,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedVariableSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedVariableSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedVariableSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the field variable type of the derived field to be used to store a derived variable
  SUBROUTINE cmfe_EquationsSet_DerivedVariableSetObj(equationsSet,derivedTensorType,fieldVariableType,err)
    !DLLEXPORT(cmfe_EquationsSet_DerivedVariableSetObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The derived field type to calculate. \see OpenCMISS_EquationsSetDerivedTensorTypes.
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to store the calculated values in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_EquationsSet_DerivedVariableSetObj",err,error,*999)

    CALL EquationsSet_DerivedVariableSet(equationsSet%equationsSet,derivedTensorType,fieldVariableType,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedVariableSetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedVariableSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedVariableSetObj

  !
  !================================================================================================================================
  !

  !>Destroy an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destory.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_Destroy(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DestroyObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_DestroyObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DestroyObj",err,error,*999)

    CALL EquationsSet_Destroy(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DependentCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_DependentCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_DependentCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DependentCreateFinish(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DependentCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_DependentCreateFinishNumber",err,error)
    EXITS("cmfe_EquationsSet_DependentCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DependentCreateFinishObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_DependentCreateFinishObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DependentCreateFinishObj",err,error,*999)

    CALL EquationsSet_DependentCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DependentCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DependentCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DependentCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & dependentFieldUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_DependentCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: dependentFieldUserNumber !<The user number of the dependent field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: dependentField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_DependentCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(dependentFieldUserNumber,region,dependentField,err,error,*999)
    CALL EquationsSet_DependentCreateStart(equationsSet,dependentFieldUserNumber,dependentField,err,error,*999)

    EXITS("cmfe_EquationsSet_DependentCreateStartNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_DependentCreateStartNumber",err,error)
    EXITS("cmfe_EquationsSet_DependentCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DependentCreateStartObj(equationsSet,dependentFieldUserNumber,dependentField,err)
    !DLLEXPORT(cmfe_EquationsSet_DependentCreateStartObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of dependent variables on.
    INTEGER(INTG), INTENT(IN) :: dependentFieldUserNumber !<The user number of the dependent field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: dependentField !<If associated on entry, the user created dependent field which has the same user number as the specified dependent field user number. If not associated on entry, on return, the created dependent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DependentCreateStartObj",err,error,*999)

    CALL EquationsSet_DependentCreateStart(equationsSet%equationsSet,dependentFieldUserNumber,dependentField%field, &
      & err,error,*999)

    EXITS("cmfe_EquationsSet_DependentCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DependentCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the dependent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DependentDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_DependentDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_DependentDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DependentDestroy(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DependentDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DependentDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the dependent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DependentDestroyObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_DependentDestroyObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DependentDestroyObj",err,error,*999)

    CALL EquationsSet_DependentDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DependentDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DependentDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentDestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of equations for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_EquationsCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_EquationsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_EquationsSet_EquationsCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsCreateFinish(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_EquationsCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_EquationsCreateFinishNumber",err,error)
    EXITS("cmfe_EquationsSet_EquationsCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of equations for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_EquationsCreateFinishObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_EquationsCreateFinishObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_EquationsCreateFinishObj",err,error,*999)

    CALL EquationsSet_EquationsCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_EquationsCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_EquationsCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of equations for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_EquationsCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_EquationsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_EquationsCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsCreateStart(equationsSet,equations,err,error,*999)

    EXITS("cmfe_EquationsSet_EquationsCreateStartNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_EquationsCreateStartNumber",err,error)
    EXITS("cmfe_EquationsSet_EquationsCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of equations for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_EquationsCreateStartObj(equationsSet,equations,err)
    !DLLEXPORT(cmfe_EquationsSet_EquationsCreateStartObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of equations on.
    TYPE(cmfe_EquationsType), INTENT(INOUT) :: equations !<On return, the created equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_EquationsCreateStartObj",err,error,*999)

    CALL EquationsSet_EquationsCreateStart(equationsSet%equationsSet,equations%equations,err,error,*999)

    EXITS("cmfe_EquationsSet_EquationsCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_EquationsCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the equations for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_EquationsDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_EquationsDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_EquationsDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsDestroy(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_EquationsDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_EquationsDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the equations for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_EquationsDestroyObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_EquationsDestroyObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_EquationsDestroyObj",err,error,*999)

    CALL EquationsSet_EquationsDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_EquationsDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_EquationsDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_IndependentCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_IndependentCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_IndependentCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_IndependentCreateFinish(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_IndependentCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_IndependentCreateFinishNumber",err,error)
    EXITS("cmfe_EquationsSet_IndependentCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of independent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_IndependentCreateFinishObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_IndependentCreateFinishObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_IndependentCreateFinishObj",err,error,*999)

    CALL EquationsSet_IndependentCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_IndependentCreateFinishObj")
    RETURN
999 ERRORS("cmfe_EquationsSet_IndependentCreateFinishObj",err,error)
    EXITS("cmfe_EquationsSet_IndependentCreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_IndependentCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & independentFieldUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_IndependentCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: independentFieldUserNumber !<The user number of the independent field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: independentField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_IndependentCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(independentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(independentFieldUserNumber,region,independentField,err,error,*999)
    CALL EquationSet_IndependentCreateStart(equationsSet,independentFieldUserNumber,independentField,err,error,*999)

    EXITS("cmfe_EquationsSet_IndependentCreateStartNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_IndependentCreateStartNumber",err,error)
    EXITS("cmfe_EquationsSet_IndependentCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of independent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_IndependentCreateStartObj(equationsSet,independentFieldUserNumber,independentField,err)
    !DLLEXPORT(cmfe_EquationsSet_IndependentCreateStartObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of independent variables on.
    INTEGER(INTG), INTENT(IN) :: independentFieldUserNumber !<The user number of the dependent field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: independentField !<If associated on entry, the user created independent field which has the same user number as the specified independent field user number. If not associated on entry, on return, the created independent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_IndependentCreateStartObj",err,error,*999)

    CALL EquationSet_IndependentCreateStart(equationsSet%equationsSet,independentFieldUserNumber,independentField%field, &
      & err,error,*999)

    EXITS("cmfe_EquationsSet_IndependentCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_IndependentCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the independent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_IndependentDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_IndependentDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_IndependentDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_IndependentDestroy(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_IndependentDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_IndependentDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the independent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_IndependentDestroyObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_IndependentDestroyObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_IndependentDestroyObj",err,error,*999)

    CALL EquationsSet_IndependentDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_IndependentDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_IndependentDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_LabelGetCNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,label,err)
    !DLLEXPORT(cmfe_EquationsSet_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to get the label for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the equationss set label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_LabelGet(equationsSet,label,err,error,*999)

    EXITS("cmfe_EquationsSet_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_LabelGetCObj(equationsSet,label,err)
    !DLLEXPORT(cmfe_EquationsSet_LabelGetCObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the equations set label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_LabelGetCObj",err,error,*999)

    CALL EquationsSet_LabelGet(equationsSet%equationsSet,label,err,error,*999)

    EXITS("cmfe_EquationsSet_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_LabelGetVSNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,label,err)
    !DLLEXPORT(cmfe_EquationsSet_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to get the label for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the equations set label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_LabelGet(equationsSet,label,err,error,*999)

    EXITS("cmfe_EquationsSet_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_LabelGetVSObj(equationsSet,label,err)
    !DLLEXPORT(cmfe_EquationsSet_LabelGetVSObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the equations set label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_LabelGetVSObj",err,error,*999)

    CALL EquationsSet_LabelGet(equationsSet%equationsSet,label,err,error,*999)

    EXITS("cmfe_EquationsSet_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_LabelSetCNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,label,err)
    !DLLEXPORT(cmfe_EquationsSet_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the label for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The equations set label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_LabelSet(equationsSet,label,err,error,*999)

    EXITS("cmfe_EquationsSet_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_LabelSetCObj(equationsSet,label,err)
    !DLLEXPORT(cmfe_EquationsSet_LabelSetCObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The equations set label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_LabelSetCObj",err,error,*999)

    CALL EquationsSet_LabelSet(equationsSet%equationsSet,label,err,error,*999)

    EXITS("cmfe_EquationsSet_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_LabelSetVSNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,label,err)
    !DLLEXPORT(cmfe_EquationsSet_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the label for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The equations set label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_LabelSet(equationsSet,label,err,error,*999)

    EXITS("cmfe_EquationsSet_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_LabelSetVSObj(equationsSet,label,err)
    !DLLEXPORT(cmfe_EquationsSet_LabelSetVSObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The equations set label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_LabelSetVSObj",err,error,*999)

    CALL EquationsSet_LabelSet(equationsSet%equationsSet,label,err,error,*999)

    EXITS("cmfe_EquationsSet_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of materials for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_MaterialsCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_MaterialsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_MaterialsCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_MaterialsCreateFinish(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_MaterialsCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_MaterialsCreateFinishNumber",err,error)
    EXITS("cmfe_EquationsSet_MaterialsCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of materials for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_MaterialsCreateFinishObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_MaterialsCreateFinishObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_MaterialsCreateFinishObj",err,error,*999)

    CALL EquationsSet_MaterialsCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_MaterialsCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_MaterialsCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of materials for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_MaterialsCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & materialsFieldUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_MaterialsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: materialsFieldUserNumber !<The user number of the materials field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: materialsField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_MaterialsCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(materialsField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(materialsFieldUserNumber,region,materialsField,err,error,*999)
    CALL EquationsSet_MaterialsCreateStart(equationsSet,materialsFieldUserNumber,materialsField,err,error,*999)

    EXITS("cmfe_EquationsSet_MaterialsCreateStartNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_MaterialsCreateStartNumber",err,error)
    EXITS("cmfe_EquationsSet_MaterialsCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of materials for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_MaterialsCreateStartObj(equationsSet,materialsFieldUserNumber,materialsField,err)
    !DLLEXPORT(cmfe_EquationsSet_MaterialsCreateStartObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of materials on.
    INTEGER(INTG), INTENT(IN) :: materialsFieldUserNumber !<The user number of the materials field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: materialsField !<If associated on entry, the user created materials field which has the same user number as the specified materials field user number. If not associated on entry, on return, the created materials field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_MaterialsCreateStartObj",err,error,*999)

    CALL EquationsSet_MaterialsCreateStart(equationsSet%equationsSet,materialsFieldUserNumber,materialsField%field, &
      & err,error,*999)

    EXITS("cmfe_EquationsSet_MaterialsCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_MaterialsCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the materials for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_MaterialsDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_MaterialsDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_MaterialsDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_MaterialsDestroy(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_MaterialsDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_MaterialsDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the materials for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_MaterialsDestroyObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_MaterialsDestroyObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_MaterialsDestroyObj",err,error,*999)

    CALL EquationsSet_MaterialsDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_MaterialsDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_MaterialsDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsDestroyObj

  !
  !================================================================================================================================
  !

  !>Gets the output type an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_OutputTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,outputType,err)
    !DLLEXPORT(cmfe_EquationsSet_OutputTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations set \see OpenCMISS_EquationsSetOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_OutputTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_OutputTypeGet(equationsSet,outputType,err,error,*999)

    EXITS("cmfe_EquationsSet_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_OutputTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_OutputTypeGetObj(equationsSet,outputType,err)
    !DLLEXPORT(cmfe_EquationsSet_OutputTypeGetObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations set \see OpenCMISS_EquationsSetOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_OutputTypeGetObj",err,error,*999)

    CALL EquationsSet_OutputTypeGet(equationsSet%equationsSet,outputType,err,error,*999)

    EXITS("cmfe_EquationsSet_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_OutputTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_OutputTypeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,outputType,err)
    !DLLEXPORT(cmfe_EquationsSet_OutputTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations set to set \see OpenCMISS_EquationsSetOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_OutputTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_OutputTypeSet(equationsSet,outputType,err,error,*999)

    EXITS("cmfe_EquationsSet_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_OutputTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_OutputTypeSetObj(equationsSet,outputType,err)
    !DLLEXPORT(cmfe_EquationsSet_OutputTypeSetObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations set to set \see OpenCMISS_EquationsSetOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_OutputTypeSetObj",err,error,*999)

    CALL EquationsSet_OutputTypeSet(equationsSet%equationsSet,outputType,err,error,*999)

    EXITS("cmfe_EquationsSet_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_OutputTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solution method for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SolutionMethodGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & solutionMethod,err)
    !DLLEXPORT(cmfe_EquationsSet_SolutionMethodGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the solution method for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: solutionMethod !<On return, the solution method. \see OpenCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_SolutionMethodGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)

    EXITS("cmfe_EquationsSet_SolutionMethodGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SolutionMethodGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SolutionMethodGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the solution method for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SolutionMethodGetObj(equationsSet,solutionMethod,err)
    !DLLEXPORT(cmfe_EquationsSet_SolutionMethodGetObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: solutionMethod !<On Return, the solution method. \see OpenCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SolutionMethodGetObj",err,error,*999)

    CALL EquationsSet_SolutionMethodGet(equationsSet%equationsSet,solutionMethod,err,error,*999)

    EXITS("cmfe_EquationsSet_SolutionMethodGetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SolutionMethodGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SolutionMethodGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SolutionMethodSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & solutionMethod,err)
    !DLLEXPORT(cmfe_EquationsSet_SolutionMethodSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: solutionMethod !<The solution method to set. \see OpenCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_SolutionMethodSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SolutionMethodSet(equationsSet,solutionMethod,err,error,*999)

    EXITS("cmfe_EquationsSet_SolutionMethodSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SolutionMethodSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SolutionMethodSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SolutionMethodSetObj(equationsSet,solutionMethod,err)
    !DLLEXPORT(cmfe_EquationsSet_SolutionMethodSetObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: solutionMethod !<The solution method to set. \see OpenCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SolutionMethodSetObj",err,error,*999)

    CALL EquationsSet_SolutionMethodSet(equationsSet%equationsSet,solutionMethod,err,error,*999)

    EXITS("cmfe_EquationsSet_SolutionMethodSetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SolutionMethodSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SolutionMethodSetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of a source for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SourceCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_SourceCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_SourceCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SourceCreateFinish(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_SourceCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a source for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SourceCreateFinishObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_SourceCreateFinishObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SourceCreateFinishObj",err,error,*999)

    CALL EquationsSet_SourceCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_SourceCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a source for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SourceCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & sourceFieldUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_SourceCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: sourceFieldUserNumber !<The user number of the source field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: sourceField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_SourceCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(sourceField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(sourceFieldUserNumber,region,sourceField,err,error,*999)
    CALL EquationsSet_SourceCreateStart(equationsSet,sourceFieldUserNumber,sourceField,err,error,*999)

    EXITS("cmfe_EquationsSet_SourceCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of a source for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SourceCreateStartObj(equationsSet,sourceFieldUserNumber,sourceField,err)
    !DLLEXPORT(cmfe_EquationsSet_SourceCreateStartObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of a source on.
    INTEGER(INTG), INTENT(IN) :: sourceFieldUserNumber !<The user number of the source field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: sourceField !<If associated on entry, the user created source field which has the same user number as the specified source field user number. If not associated on entry, on return, the created source field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SourceCreateStartObj",err,error,*999)

    CALL EquationsSet_SourceCreateStart(equationsSet%equationsSet,sourceFieldUserNumber,sourceField%field,err,error,*999)

    EXITS("cmfe_EquationsSet_SourceCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the source for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SourceDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(cmfe_EquationsSet_SourceDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_SourceDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SourceDestroy(equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_SourceDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the source for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SourceDestroyObj(equationsSet,err)
    !DLLEXPORT(cmfe_EquationsSet_SourceDestroyObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SourceDestroyObj",err,error,*999)

    CALL EquationsSet_SourceDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_SourceDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the equations set specification array for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SpecificationGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & equationsSetSpecification,err)
    !DLLEXPORT(cmfe_EquationsSet_SpecificationGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: equationsSetSpecification(:) !<On return, the equations set specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_SpecificationGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SpecificationGet(equationsSet,0,equationsSetSpecification,err,error,*999)

    EXITS("cmfe_EquationsSet_SpecificationGetNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_SpecificationGetNumber",err,error)
    EXITS("cmfe_EquationsSet_SpecificationGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SpecificationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the equations set specification array for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SpecificationGetObj(equationsSet,equationsSetSpecification,err)
    !DLLEXPORT(cmfe_EquationsSet_SpecificationGetObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: equationsSetSpecification(:) !<On return, the equations set specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SpecificationGetObj",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet%equationsSet,0,equationsSetSpecification,err,error,*999)

    EXITS("cmfe_EquationsSet_SpecificationGetObj")
    RETURN
999 ERRORS("cmfe_EquationsSet_SpecificationGetObj",err,error)
    EXITS("cmfe_EquationsSet_SpecificationGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SpecificationGetObj

  !
  !================================================================================================================================
  !

  !>Returns the size of the equations set specification array for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SpecificationSizeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & specificationSize,err)
    !DLLEXPORT(cmfe_EquationsSet_SpecificationSizeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the specification size for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the specification size for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the equations set specification array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_SpecificationSizeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SpecificationSizeGet(equationsSet,specificationSize,err,error,*999)

    EXITS("cmfe_EquationsSet_SpecificationSizeGetNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_SpecificationSizeGetNumber",err,error)
    EXITS("cmfe_EquationsSet_SpecificationSizeGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SpecificationSizeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the size of the equations set specification array for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SpecificationSizeGetObj(equationsSet,specificationSize,err)
    !DLLEXPORT(cmfe_EquationsSet_SpecificationSizeGetObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the specification size for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the equations set specification array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SpecificationSizeGetObj",err,error,*999)

    CALL EquationsSet_SpecificationSizeGet(equationsSet%equationsSet,specificationSize,err,error,*999)

    EXITS("cmfe_EquationsSet_SpecificationSizeGetObj")
    RETURN
999 ERRORS("cmfe_EquationsSet_SpecificationSizeGetObj",err,error)
    EXITS("cmfe_EquationsSet_SpecificationSizeGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SpecificationSizeGetObj

  !
  !================================================================================================================================
  !

  !>Evaluate a tensor at a given element Gauss point, for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_TensorInterpolateGaussPointNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & derivedTensorType,gaussPointNumber,userElementNumber,values,err)
    !DLLEXPORT(cmfe_EquationsSet_TensorInterpolateGaussPointNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to evalaute the tensor for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The type of derived tensor to interpolate. \see OpenCMISS_EquationsSetDerivedTensorTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(OUT) :: values(:,:) !On exit, the interpolated tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_TensorInterpolateGaussPointNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_TensorInterpolateGaussPoint(equationsSet,derivedTensorType,gaussPointNumber,userElementNumber,values, &
      & err,error,*999)

    EXITS("cmfe_EquationsSet_TensorInterpolateGaussPointNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_TensorInterpolateGaussPointNumber",err,error)
    EXITS("cmfe_EquationsSet_TensorInterpolateGaussPointNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_TensorInterpolateGaussPointNumber

  !
  !================================================================================================================================
  !

  !>Evaluate a tensor at a given element Gauss point, for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_TensorInterpolateGaussPointObj(equationsSet,derivedTensorType,gaussPointNumber,userElementNumber, &
    & values,err)
    !DLLEXPORT(cmfe_EquationsSet_TensorInterpolateGaussPointObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<A pointer to the equations set to evaluate the tensor for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The type of derived tensor to interpolate. \see OpenCMISS_EquationsSetDerivedTensorTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(OUT) :: values(:,:) !<On exit, the interpolated tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_EquationsSet_TensorInterpolateGaussPointObj",err,error,*999)

    CALL EquationsSet_TensorInterpolateGaussPoint(equationsSet%equationsSet,derivedTensorType,gaussPointNumber,userElementNumber, &
      & values,err,error,*999)

    EXITS("cmfe_EquationsSet_TensorInterpolateGaussPointObj")
    RETURN
999 ERRORS("cmfe_EquationsSet_TensorInterpolateGaussPointObj",err,error)
    EXITS("cmfe_EquationsSet_TensorInterpolateGaussPointObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_TensorInterpolateGaussPointObj

  !
  !================================================================================================================================
  !

  !>Evaluate a tensor at a given element xi location, for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_TensorInterpolateXiNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & derivedTensorType,userElementNumber,xi,values,err)
    !DLLEXPORT(cmfe_EquationsSet_TensorInterpolateXiNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to evalaute the tensor for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The type of derived tensor to interpolate. \see OpenCMISS_EquationsSetDerivedTensorTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_TensorInterpolateXiNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_TensorInterpolateXi(equationsSet,derivedTensorType,userElementNumber,xi,values,err,error,*999)

    EXITS("cmfe_EquationsSet_TensorInterpolateXiNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_TensorInterpolateXiNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_TensorInterpolateXiNumber

  !
  !================================================================================================================================
  !

  !>Evaluate a tensor at a given element xi location, for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_TensorInterpolateXiObj(equationsSet,derivedTensorType,userElementNumber,xi,values,err)
    !DLLEXPORT(cmfe_EquationsSet_TensorInterpolateXiObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<A pointer to the equations set to evaluate the tensor for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The type of tensor to evaluate. \see OpenCMISS_EquationsSetDerivedTensorTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_EquationsSet_TensorInterpolateXiObj",err,error,*999)

    CALL EquationsSet_TensorInterpolateXi(equationsSet%equationsSet,derivedTensorType,userElementNumber,xi, &
      & values,err,error,*999)

    EXITS("cmfe_EquationsSet_TensorInterpolateXiObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_TensorInterpolateXiObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_TensorInterpolateXiObj

  !
  !================================================================================================================================
  !

  !>Returns the equations set current times for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_TimesGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,currentTime,deltaTime,err)
    !DLLEXPORT(cmfe_EquationsSet_TimesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the times for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the times for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the equations set current time.
    REAL(DP), INTENT(OUT) :: deltaTime !<On return, the equations set current delta time.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_EquationsSet_TimesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_TimesGet(equationsSet,currentTime,deltaTime,err,error,*999)

    EXITS("cmfe_EquationsSet_TimesGetNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_TimesGetNumber",err,error)
    EXITS("cmfe_EquationsSet_TimesGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_TimesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the equations set current times for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_TimesGetObj(equationsSet,currentTime,deltaTime,err)
    !DLLEXPORT(cmfe_EquationsSet_TimesGetObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the times for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the equations set current time.
    REAL(DP), INTENT(OUT) :: deltaTime !<On return, the equations set current delta time.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_TimesGetObj",err,error,*999)

    CALL EquationsSet_TimesGet(equationsSet%equationsSet,currentTime,deltaTime,err,error,*999)

    EXITS("cmfe_EquationsSet_TimesGetObj")
    RETURN
999 ERRORS("cmfe_EquationsSet_TimesGetObj",err,error)
    EXITS("cmfe_EquationsSet_TimesGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_TimesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the equations set current times for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_TimesSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,currentTime,deltaTime,err)
    !DLLEXPORT(cmfe_EquationsSet_TimesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the times for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The equations set current time to set.
    REAL(DP), INTENT(IN) :: deltaTime !<The equations set current delta time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_EquationsSet_TimesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_TimesSet(equationsSet,currentTime,deltaTime,err,error,*999)

    EXITS("cmfe_EquationsSet_TimesSetNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_TimesSetNumber",err,error)
    EXITS("cmfe_EquationsSet_TimesSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_TimesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the equations set current times for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_TimesSetObj(equationsSet,currentTime,deltaTime,err)
    !DLLEXPORT(cmfe_EquationsSet_TimesSetObj)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The equations set current time to set.
    REAL(DP), INTENT(IN) :: deltaTime !<The equations set current delta time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_TimesSetObj",err,error,*999)

    CALL EquationsSet_TimesSet(equationsSet%equationsSet,currentTime,deltaTime,err,error,*999)

    EXITS("cmfe_EquationsSet_TimesSetObj")
    RETURN
999 ERRORS("cmfe_EquationsSet_TimesSetObj",err,error)
    EXITS("cmfe_EquationsSet_TimesSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_TimesSetObj

!!==================================================================================================================================
!!
!! FieldRoutines
!!
!!==================================================================================================================================

  !>Returns the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentInterpolationGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,interpolationType,err)
    !DLLEXPORT(cmfe_Field_ComponentInterpolationGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: interpolationType !<On return, the interpolation type. \see OpenCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentInterpolationGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentInterpolationGet(field,variableType,componentNumber,interpolationType,err,error,*999)

    EXITS("cmfe_Field_ComponentInterpolationGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentInterpolationGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentInterpolationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentInterpolationGetObj(field,variableType,componentNumber,interpolationType,err)
    !DLLEXPORT(cmfe_Field_ComponentInterpolationGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: interpolationType !<On return, the interpolation type. \see OpenCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentInterpolationGetObj",err,error,*999)

    CALL Field_ComponentInterpolationGet(field%field,variableType,componentNumber,interpolationType,err,error,*999)

    EXITS("cmfe_Field_ComponentInterpolationGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentInterpolationGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentInterpolationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentInterpolationSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,interpolationType,err)
    !DLLEXPORT(cmfe_Field_ComponentInterpolationSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set. \see OpenCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentInterpolationSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentInterpolationSet(field,variableType,componentNumber,interpolationType,err,error,*999)

    EXITS("cmfe_Field_ComponentInterpolationSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentInterpolationSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentInterpolationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentInterpolationSetObj(field,variableType,componentNumber,interpolationType,err)
    !DLLEXPORT(cmfe_Field_ComponentInterpolationSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set. \see OpenCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentInterpolationSetObj",err,error,*999)

    CALL Field_ComponentInterpolationSet(field%field,variableType,componentNumber,interpolationType,err,error,*999)

    EXITS("cmfe_Field_ComponentInterpolationSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentInterpolationSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentInterpolationSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentLabelGetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,label,err)
    !DLLEXPORT(cmfe_Field_ComponentLabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentLabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentLabelGet(field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentLabelGetCObj(field,variableType,componentNumber,label,err)
    !DLLEXPORT(cmfe_Field_ComponentLabelGetCObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentLabelGetCObj",err,error,*999)

    CALL Field_ComponentLabelGet(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentLabelGetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,label,err)
    !DLLEXPORT(cmfe_Field_ComponentLabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentLabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentLabelGet(field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentLabelGetVSObj(field,variableType,componentNumber,label,err)
    !DLLEXPORT(cmfe_Field_ComponentLabelGetVSObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentLabelGetVSObj",err,error,*999)

    CALL Field_ComponentLabelGet(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentLabelSetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,label,err)
    !DLLEXPORT(cmfe_Field_ComponentLabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentLabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentLabelSet(field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentLabelSetCObj(field,variableType,componentNumber,label,err)
    !DLLEXPORT(cmfe_Field_ComponentLabelSetCObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentLabelSetCObj",err,error,*999)

    CALL Field_ComponentLabelSet(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentLabelSetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,label,err)
    !DLLEXPORT(cmfe_Field_ComponentLabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentLabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentLabelSet(field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentLabelSetVSObj(field,variableType,componentNumber,label,err)
    !DLLEXPORT(cmfe_Field_ComponentLabelSetVSObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentLabelSetVSObj",err,error,*999)

    CALL Field_ComponentLabelSet(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentMeshComponentGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,meshComponent,err)
    !DLLEXPORT(cmfe_Field_ComponentMeshComponentGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the mesh component number for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: meshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentMeshComponentGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentMeshComponentGet(field,variableType,componentNumber,meshComponent,err,error,*999)

    EXITS("cmfe_Field_ComponentMeshComponentGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentMeshComponentGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentMeshComponentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentMeshComponentGetObj(field,variableType,componentNumber,meshComponent,err)
    !DLLEXPORT(cmfe_Field_ComponentMeshComponentGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the mesh component number for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: meshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentMeshComponentGetObj",err,error,*999)

    CALL Field_ComponentMeshComponentGet(field%field,variableType,componentNumber,meshComponent,err,error,*999)

    EXITS("cmfe_Field_ComponentMeshComponentGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentMeshComponentGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentMeshComponentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentMeshComponentSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,meshComponent,err)
    !DLLEXPORT(cmfe_Field_ComponentMeshComponentSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the mesh component number for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentMeshComponentSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentMeshComponentSet(field,variableType,componentNumber,meshComponent,err,error,*999)

    EXITS("cmfe_Field_ComponentMeshComponentSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentMeshComponentSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentMeshComponentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentMeshComponentSetObj(field,variableType,componentNumber,meshComponent,err)
    !DLLEXPORT(cmfe_Field_ComponentMeshComponentSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the mesh component number for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentMeshComponentSetObj",err,error,*999)

    CALL Field_ComponentMeshComponentSet(field%field,variableType,componentNumber,meshComponent,err,error,*999)

    EXITS("cmfe_Field_ComponentMeshComponentSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentMeshComponentSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentMeshComponentSetObj

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ComponentValuesInitialiseIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentValuesInitialiseIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentValuesInitialise(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ComponentValuesInitialiseIntgNumber",err,error)
    EXITS("cmfe_Field_ComponentValuesInitialiseIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseIntgNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseIntgObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ComponentValuesInitialiseIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentValuesInitialiseIntgObj",err,error,*999)

    CALL Field_ComponentValuesInitialise(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentValuesInitialiseIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseIntgObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ComponentValuesInitialiseSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentValuesInitialiseSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentValuesInitialise(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseSPNumber")
    RETURN
999 ERRORS("cmfe_Field_ComponentValuesInitialiseSPNumber",err,error)
    EXITS("cmfe_Field_ComponentValuesInitialiseSPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseSPNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseSPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ComponentValuesInitialiseSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentValuesInitialiseSPObj",err,error,*999)

    CALL Field_ComponentValuesInitialise(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentValuesInitialiseSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseSPObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ComponentValuesInitialiseDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentValuesInitialiseDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentValuesInitialise(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ComponentValuesInitialiseDPNumber",err,error)
    EXITS("cmfe_Field_ComponentValuesInitialiseDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseDPNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseDPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ComponentValuesInitialiseDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentValuesInitialiseDPObj",err,error,*999)

    CALL Field_ComponentValuesInitialise(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentValuesInitialiseDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseDPObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ComponentValuesInitialiseLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ComponentValuesInitialiseLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentValuesInitialise(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentValuesInitialiseLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseLNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseLObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ComponentValuesInitialiseLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentValuesInitialiseLObj",err,error,*999)

    CALL Field_ComponentValuesInitialise(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentValuesInitialiseLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseLObj

  !
  !================================================================================================================================
  !

  !>Returns the data type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_DataTypeGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,dataType,err)
    !DLLEXPORT(cmfe_Field_DataTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the field variable data type. \see OpenCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DataTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DataTypeGet(field,variableType,dataType,err,error,*999)

    EXITS("cmfe_Field_DataTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the data type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_DataTypeGetObj(field,variableType,dataType,err)
    !DLLEXPORT(cmfe_Field_DataTypeGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the field variable data type. \see OpenCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DataTypeGetObj",err,error,*999)

    CALL Field_DataTypeGet(field%field,variableType,dataType,err,error,*999)

    EXITS("cmfe_Field_DataTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_DataTypeSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,dataType,err)
    !DLLEXPORT(cmfe_Field_DataTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the data type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dataType !<The field variable data type to set. \see OpenCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DataTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DataTypeSet(field,variableType,dataType,err,error,*999)

    EXITS("cmfe_Field_DataTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_DataTypeSetObj(field,variableType,dataType,err)
    !DLLEXPORT(cmfe_Field_DataTypeSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the data type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dataType !<The field variable data type to set. \see OpenCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DataTypeSetObj",err,error,*999)

    CALL Field_DataTypeSet(field%field,variableType,dataType,err,error,*999)

    EXITS("cmfe_Field_DataTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_DOFOrderTypeGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,DOFOrderType,err)
    !DLLEXPORT(cmfe_Field_DOFOrderTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the DOF Order type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DOFOrderType !<On return, the field variable DOF Order type. \see OpenCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DOFOrderTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DOFOrderTypeGet(field,variableType,DOFOrderType,err,error,*999)

    EXITS("cmfe_Field_DOFOrderTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DOFOrderTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DOFOrderTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_DOFOrderTypeGetObj(field,variableType,DOFOrderType,err)
    !DLLEXPORT(cmfe_Field_DOFOrderTypeGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the DOF order type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DOFOrderType !<On return, the field variable DOF order type. \see OpenCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DOFOrderTypeGetObj",err,error,*999)

    CALL Field_DOFOrderTypeGet(field%field,variableType,DOFOrderType,err,error,*999)

    EXITS("cmfe_Field_DOFOrderTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DOFOrderTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DOFOrderTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_DOFOrderTypeSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,DOFOrderType,err)
    !DLLEXPORT(cmfe_Field_DOFOrderTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the DOF Order type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DOFOrderType !<The field variable DOF Order type to set. \see OpenCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DOFOrderTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DOFOrderTypeSet(field,variableType,DOFOrderType,err,error,*999)

    EXITS("cmfe_Field_DOFOrderTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DOFOrderTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DOFOrderTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_DOFOrderTypeSetObj(field,variableType,DOFOrderType,err)
    !DLLEXPORT(cmfe_Field_DOFOrderTypeSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the DOF order type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DOFOrderType !<The field variable DOF order type to set. \see OpenCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DOFOrderTypeSetObj",err,error,*999)

    CALL Field_DOFOrderTypeSet(field%field,variableType,DOFOrderType,err,error,*999)

    EXITS("cmfe_Field_DOFOrderTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DOFOrderTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DOFOrderTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field identified by a user number.
  SUBROUTINE cmfe_Field_CreateFinishNumber(contextUserNumber,regionUserNumber,fieldUserNumber,err)
    !DLLEXPORT(cmfe_Field_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_CreateFinish(field,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Field Create')
#endif

    EXITS("cmfe_Field_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field identified by an object.
  SUBROUTINE cmfe_Field_CreateFinishObj(field,err)
    !DLLEXPORT(cmfe_Field_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<The field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_CreateFinishObj",err,error,*999)

    CALL Field_CreateFinish(field%field,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('field Create')
#endif

    EXITS("cmfe_Field_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field identified by a user number.
  SUBROUTINE cmfe_Field_CreateStartNumber(fieldUserNumber,contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(cmfe_Field_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Field Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Field_CreateStart(fieldUserNumber,region,field,err,error,*999)

    EXITS("cmfe_Field_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field on an interface identified by an object.
  SUBROUTINE cmfe_Field_CreateStartInterfaceObj(fieldUserNumber,interface,field,err)
    !DLLEXPORT(cmfe_Field_CreateStartInterfaceObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to create the field on.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_CreateStartInterfaceObj",err,error,*999)

    CALL Field_CreateStart(fieldUserNumber,interface%interface,field%field,err,error,*999)

    EXITS("cmfe_Field_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_CreateStartInterfaceObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

   !>Starts the creation of a field on a region identified by an object.
  SUBROUTINE cmfe_Field_CreateStartRegionObj(fieldUserNumber,region,field,err)
    !DLLEXPORT(cmfe_Field_CreateStartRegionObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to create the field on.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_CreateStartRegionObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('field Create')
#endif

    CALL Field_CreateStart(fieldUserNumber,region%region,field%field,err,error,*999)

    EXITS("cmfe_Field_CreateStartRegionObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_CreateStartRegionObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_CreateStartRegionObj

  !
  !================================================================================================================================
  !

  !>Returns the dependent type for a field identified by a user number.
  SUBROUTINE cmfe_Field_DependentTypeGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,dependentType,err)
    !DLLEXPORT(cmfe_Field_DependentTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: dependentType !<On return, the field dependent type. \see OpenCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DependentTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DependentTypeGet(field,dependentType,err,error,*999)

    EXITS("cmfe_Field_DependentTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DependentTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DependentTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dependent type for a field identified by an object.
  SUBROUTINE cmfe_Field_DependentTypeGetObj(field,dependentType,err)
    !DLLEXPORT(cmfe_Field_DependentTypeGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: dependentType !<On return, the field dependent type. \see OpenCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DependentTypeGetObj",err,error,*999)

    CALL Field_DependentTypeGet(field%field,dependentType,err,error,*999)

    EXITS("cmfe_Field_DependentTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DependentTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DependentTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field identified by a user number.
  SUBROUTINE cmfe_Field_DependentTypeSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,dependentType,err)
    !DLLEXPORT(cmfe_Field_DependentTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: dependentType !<The field dependent type to set. \see OpenCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DependentTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DependentTypeSet(field,dependentType,err,error,*999)

    EXITS("cmfe_Field_DependentTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DependentTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DependentTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field identified by an object.
  SUBROUTINE cmfe_Field_DependentTypeSetObj(field,dependentType,err)
    !DLLEXPORT(cmfe_Field_DependentTypeSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the dependent type for.
    INTEGER(INTG), INTENT(IN) :: dependentType !<The field dependent type to set. \see OpenCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DependentTypeSetObj",err,error,*999)

    CALL Field_DependentTypeSet(field%field,dependentType,err,error,*999)

    EXITS("cmfe_Field_DependentTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DependentTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DependentTypeSetObj

  !
  !================================================================================================================================
  !

  !>Destroys a field identified by a user number.
  SUBROUTINE cmfe_Field_DestroyNumber(contextUserNumber,regionUserNumber,fieldUserNumber,err)
    !DLLEXPORT(cmfe_Field_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to destroy.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_Destroy(field,err,error,*999)

    EXITS("cmfe_Field_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a field identified by an object.
  SUBROUTINE cmfe_Field_DestroyObj(field,err)
    !DLLEXPORT(cmfe_Field_DestroyObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DestroyObj",err,error,*999)

    CALL Field_Destroy(field%field,err,error,*999)

    EXITS("cmfe_Field_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the dimension for a field identified by a user number.
  SUBROUTINE cmfe_Field_DimensionGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,dimension,err)
    !DLLEXPORT(cmfe_Field_DimensionGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dimension !<On return, the field dimension. \see OpenCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DimensionGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DimensionGet(field,variableType,DIMENSION,err,error,*999)

    EXITS("cmfe_Field_DimensionGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DimensionGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DimensionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dimension for a field identified by an object.
  SUBROUTINE cmfe_Field_DimensionGetObj(field,variableType,dimension,err)
    !DLLEXPORT(cmfe_Field_DimensionGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Dimension !<On return, the field dimension. \see OpenCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DimensionGetObj",err,error,*999)

    CALL Field_DimensionGet(field%field,variableType,dimension,err,error,*999)

    EXITS("cmfe_Field_DimensionGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DimensionGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DimensionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension for a field identified by a user number.
  SUBROUTINE cmfe_Field_DimensionSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,DIMENSION,err)
    !DLLEXPORT(cmfe_Field_DimensionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: Dimension !<The field dimension to set. \see OpenCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DimensionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DimensionSet(field,variableType,DIMENSION,err,error,*999)

    EXITS("cmfe_Field_DimensionSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DimensionSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DimensionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension for a field identified by an object.
  SUBROUTINE cmfe_Field_DimensionSetObj(field,variableType,dimension,err)
    !DLLEXPORT(cmfe_Field_DimensionSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dimension !<The field dimension to set. \see OpenCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DimensionSetObj",err,error,*999)

    CALL Field_DimensionSet(field%field,variableType,DIMENSION,err,error,*999)

    EXITS("cmfe_Field_DimensionSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DimensionSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DimensionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the geometric field for a field identified by a user number.
  SUBROUTINE cmfe_Field_GeometricFieldGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,geometricFieldUserNumber,err)
    !DLLEXPORT(cmfe_Field_GeometricFieldGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the geometric field for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the geometric field for.
    INTEGER(INTG), INTENT(OUT) :: geometricFieldUserNumber !<On return, the field geometric field user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_GeometricFieldGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(geometricField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
    geometricFieldUserNumber=geometricField%userNumber

    EXITS("cmfe_Field_GeometricFieldGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_GeometricFieldGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the geometric field for a field identified by an object.
  SUBROUTINE cmfe_Field_GeometricFieldGetObj(field,geometricField,err)
    !DLLEXPORT(cmfe_Field_GeometricFieldGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the geometric field for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: geometricField !<On return, the geometric field for the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_GeometricFieldGetObj",err,error,*999)

    CALL Field_GeometricFieldGet(field%field,geometricField%field,err,error,*999)

    EXITS("cmfe_Field_GeometricFieldGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_GeometricFieldGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricFieldGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field identified by a user number.
  SUBROUTINE cmfe_Field_GeometricFieldSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,geometricFieldUserNumber,err)
    !DLLEXPORT(cmfe_Field_GeometricFieldSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the geometric field for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the geometric field for.
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The field geometric field user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_GeometricFieldSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(geometricField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Region_FieldGet(region,geometricFieldUserNumber,geometricField,err,error,*999)
    CALL Field_GeometricFieldSet(field,geometricField,err,error,*999)

    EXITS("cmfe_Field_GeometricFieldSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_GeometricFieldSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricFieldSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field identified by an object.
  SUBROUTINE cmfe_Field_GeometricFieldSetObj(field,geometricField,err)
    !DLLEXPORT(cmfe_Field_GeometricFieldSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the geometric field for.
    TYPE(cmfe_FieldType), INTENT(IN) :: geometricField !<The geometric field for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_GeometricFieldSetObj",err,error,*999)

    CALL Field_GeometricFieldSet(field%field,geometricField%field,err,error,*999)

    EXITS("cmfe_Field_GeometricFieldSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_GeometricFieldSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricFieldSetObj

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given user element number and line xi normal directions by a user number.
  SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetNumber0(contextUserNumber,regionUserNumber, &
    & geometricFieldUserNumber,userElementNumber,xiNormalDirection,lineLength,err)
    !DLLEXPORT(cmfe_Field_GeometricParametersElementLineLengthGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to obtain the line length from
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The geometric field user number to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The element to get the line length for
    INTEGER(INTG), INTENT(IN) :: xiNormalDirection !<The xi normal direction to specify the line
    REAL(DP), INTENT(OUT) :: lineLength !<On return, the line length of the chosen line 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: geometricField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_GeometricParametersElementLineLengthGetNumber0",err,error,*999)
    
    CALL cmfe_Field_GeometricParametersElementLineLengthGetNumber1(contextUserNumber,regionUserNumber, &
      & geometricFieldUserNumber,userElementNumber,[xiNormalDirection],lineLength,err)
    
    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetNumber0")
    RETURN
999 ERRORS("cmfe_Field_GeometricParametersElementLineLengthGetNumber0",err,error)
    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetNumber0
  
  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given element number and element basis line number by a user number.
  SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetNumber1(contextUserNumber,regionUserNumber, &
    & geometricFieldUserNumber,userElementNumber,xiNormalDirections,lineLength,err)
    !DLLEXPORT(cmfe_Field_GeometricParametersElementLineLengthGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to obtain the line length from
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The geometric field user number to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The element to get the line length for
    INTEGER(INTG), INTENT(IN) :: xiNormalDirections(:) !<xiNormalDirections(xiIdx). The xi normal directions to specify the line
    REAL(DP), INTENT(OUT) :: lineLength !<On return, the line length of the chosen line 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: geometricField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_GeometricParametersElementLineLengthGetNumber1",err,error,*999)
    
    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(geometricField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,geometricFieldUserNumber,geometricField,err,error,*999)
    CALL Field_GeometricParametersElementLineLengthGet(geometricField,userElementNumber,xiNormalDirections,lineLength, &
      & err,error,*999)

    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetNumber1")
    RETURN
999 ERRORS("cmfe_Field_GeometricParametersElementLineLengthGetNumber1",err,error)
    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetNumber1
  
  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given user element number and line xi normal direction by an object.
  SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetObj0(geometricField,userElementNumber,xiNormalDirection, &
    & lineLength,err)
    !DLLEXPORT(cmfe_Field_GeometricParametersElementLineLengthGetObj0)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: geometricField !<The geometric field to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The user element to get the line length for
    INTEGER(INTG), INTENT(IN) :: xiNormalDirection !<The line xi normal direction to get the length for
    REAL(DP), INTENT(OUT) :: lineLength !<The line length of the chosen element line number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_GeometricParametersElementLineLengthGetObj0",err,error,*999)

    CALL cmfe_Field_GeometricParametersElementLineLengthGetObj1(geometricField,userElementNumber,[xiNormalDirection], &
      & lineLength,err)

    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetObj0")
    RETURN
999 ERRORS("cmfe_Field_GeometricParametersElementLineLengthGetObj0",err,error)
    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetObj0

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given user element number and line xi normal directions  by an object.
  SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetObj1(geometricField,userElementNumber,xiNormalDirections, &
    & lineLength,err)
    !DLLEXPORT(cmfe_Field_GeometricParametersElementLineLengthGetObj1)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: geometricField !<The geometric field to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The user element to get the line length for
    INTEGER(INTG), INTENT(IN) :: xiNormalDirections(:) !<xiNormalDirections(xiIdx). The element basis line to get the length for
    REAL(DP), INTENT(OUT) :: lineLength !<The line length of the chosen element line number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_GeometricParametersElementLineLengthGetObj1",err,error,*999)

    CALL Field_GeometricParametersElementLineLengthGet(geometricField%field,userElementNumber,xiNormalDirections,lineLength, &
      & err,error,*999)

    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetObj1")
    RETURN
999 ERRORS("cmfe_Field_GeometricParametersElementLineLengthGetObj1",err,error)
    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetObj1

  !
  !================================================================================================================================
  !

  !>Gets the volume for a given user element number by a user number.
  SUBROUTINE cmfe_Field_GeometricParametersElementVolumeGetNumber(contextUserNumber,regionUserNumber,geometricFieldUserNumber, &
    & userElementNumber,elementVolume,err)
    !DLLEXPORT(cmfe_Field_GeometricParametersElementVolumeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to obtain the volume from
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The geometric field user number to obtain the volume from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The user element number to get the volume for
    REAL(DP), INTENT(OUT) :: elementVolume !<On return, the volume of the chosen element number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: geometricField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_GeometricParametersElementVolumeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(geometricField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,geometricFieldUserNumber,geometricField,err,error,*999)
    CALL Field_GeometricParametersElementVolumeGet(geometricField,userElementNumber,elementVolume,err,error,*999)

    EXITS("cmfe_Field_GeometricParametersElementVolumeGetNumber")
    RETURN
999 ERRORS("cmfe_Field_GeometricParametersElementVolumeGetNumber",err,error)
    EXITS("cmfe_Field_GeometricParametersElementVolumeGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricParametersElementVolumeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the volume for a given user element number by an object.
  SUBROUTINE cmfe_Field_GeometricParametersElementVolumeGetObj(geometricField,userElementNumber,elementVolume,err)
    !DLLEXPORT(cmfe_Field_GeometricParametersElementVolumeGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: geometricField !<The geometric field to obtain the volume from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The user element to get the volume for
    REAL(DP), INTENT(OUT) :: elementVolume !<On return, the volume of the chosen element 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_GeometricParametersElementVolumeGetObj",err,error,*999)

    CALL Field_GeometricParametersElementVolumeGet(geometricField%field,userElementNumber,elementVolume, &
      & err,error,*999)

    EXITS("cmfe_Field_GeometricParametersElementVolumeGetObj")
    RETURN
999 ERRORS("cmfe_Field_GeometricParametersElementVolumeGetObj",err,error)
    EXITS("cmfe_Field_GeometricParametersElementVolumeGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricParametersElementVolumeGetObj


  !
  !================================================================================================================================
  !

  !>Gets the scale factor for a particular node identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)
    !DLLEXPORT(cmfe_Field_ParameterSetNodeScaleFactorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetNodeScaleFactorGet(field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorGetNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorGetNumber",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the scale factor for a particular node identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorGetObj(field,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)
    !DLLEXPORT(cmfe_Field_ParameterSetNodeScaleFactorGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorGetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorGet(field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorGetObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorGetObj",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorGetObj

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & meshComponentNumber,scaleFactors,err)
    !DLLEXPORT(cmfe_Field_ParameterSetNodeScaleFactorsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetNodeScaleFactorsGet(field,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsGetNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorsGetNumber",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsGetObj(field,variableType,meshComponentNumber,scaleFactors,err)
    !DLLEXPORT(cmfe_Field_ParameterSetNodeScaleFactorsGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorsGetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorsGet(field%field,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsGetObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorsGetObj",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsGetObj
  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs, identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,meshComponentNumber,numberOfScaleFactorsDofs,err)
    !DLLEXPORT(cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of scalefactors for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber",err,error)
    EXITS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs, identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj(field,variableType,meshComponentNumber, &
    & numberOfScaleFactorsDofs,err)
    !DLLEXPORT(cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj",err,error,*999)

    CALL Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field%field,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj",err,error)
    EXITS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj

  !
  !================================================================================================================================
  !

  !>Sets the scale factor for a particular node identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)
    !DLLEXPORT(cmfe_Field_ParameterSetNodeScaleFactorSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetNodeScaleFactorSet(field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorSetNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorSetNumber",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the scale factor for a particular node identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorSetObj(field,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)
    !DLLEXPORT(cmfe_Field_ParameterSetNodeScaleFactorSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorSetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorSet(field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorSetObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorSetObj",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorSetObj

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & meshComponentNumber,scaleFactors,err)
    !DLLEXPORT(cmfe_Field_ParameterSetNodeScaleFactorsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetNodeScaleFactorsSet(field,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsSetNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorsSetNumber",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsSetObj(field,variableType,meshComponentNumber,scaleFactors,err)
    !DLLEXPORT(cmfe_Field_ParameterSetNodeScaleFactorsSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorsSetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorsSet(field%field,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsSetObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorsSetObj",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field identified by a user number.
  SUBROUTINE cmfe_Field_LabelGetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,label,err)
    !DLLEXPORT(cmfe_Field_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_LabelGet(field,label,err,error,*999)

    EXITS("cmfe_Field_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field identified by an object.
  SUBROUTINE cmfe_Field_LabelGetCObj(field,label,err)
    !DLLEXPORT(cmfe_Field_LabelGetCObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_LabelGetCObj",err,error,*999)

    CALL Field_LabelGet(field%field,label,err,error,*999)

    EXITS("cmfe_Field_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field identified by a user number.
  SUBROUTINE cmfe_Field_LabelGetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,label,err)
    !DLLEXPORT(cmfe_Field_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_LabelGet(field,label,err,error,*999)

    EXITS("cmfe_Field_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field identified by an object.
  SUBROUTINE cmfe_Field_LabelGetVSObj(field,label,err)
    !DLLEXPORT(cmfe_Field_LabelGetVSObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_LabelGetVSObj",err,error,*999)

    CALL Field_LabelGet(field%field,label,err,error,*999)

    EXITS("cmfe_Field_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field identified by a user number.
  SUBROUTINE cmfe_Field_LabelSetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,label,err)
    !DLLEXPORT(cmfe_Field_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_Field_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_LabelSet(field,label,err,error,*999)

    EXITS("cmfe_Field_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field identified by an object.
  SUBROUTINE cmfe_Field_LabelSetCObj(field,label,err)
    !DLLEXPORT(cmfe_Field_LabelSetCObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_LabelSetCObj",err,error,*999)

    CALL Field_LabelSet(field%field,label,err,error,*999)

    EXITS("cmfe_Field_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field identified by a user number.
  SUBROUTINE cmfe_Field_LabelSetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,label,err)
    !DLLEXPORT(cmfe_Field_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_LabelSet(field,label,err,error,*999)

    EXITS("cmfe_Field_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field identified by an object.
  SUBROUTINE cmfe_Field_LabelSetVSObj(field,label,err)
    !DLLEXPORT(cmfe_Field_LabelSetVSObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_LabelSetVSObj",err,error,*999)

    CALL Field_LabelSet(field%field,label,err,error,*999)

    EXITS("cmfe_Field_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_PositionNormalTangentCalculateNodeNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,localNodeNumber,position,normal,tangents,err)
    !DLLEXPORT(cmfe_Field_PositionNormalTangentCalculateNodeNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number of the field variable to get the data type for.
    REAL(DP), INTENT(OUT) :: position(:),normal(:),tangents(:,:) !<Actual useful outputs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_PositionNormalTangentCalculateNodeNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_PositionNormalTangentsCalculateNode(field,variableType,componentNumber,localNodeNumber, &
      & position,normal,tangents,err,error,*999)

    EXITS("cmfe_Field_PositionNormalTangentCalculateNodeNumber")
    RETURN
999 ERRORS("cmfe_Field_PositionNormalTangentCalculateNodeNumber",err,error)
    EXITS("cmfe_Field_PositionNormalTangentCalculateNodeNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_PositionNormalTangentCalculateNodeNumber

  !
  !================================================================================================================================
  !

  !>Returns the position, normal and tangents for a field node for a field identified by an object.
  SUBROUTINE cmfe_Field_PositionNormalTangentCalculateNodeObj(field,variableType,componentNumber,localNodeNumber, &
    & position,normal,tangents,err)
    !DLLEXPORT(cmfe_Field_PositionNormalTangentCalculateNodeObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data type for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number of the field variable to get the data type for.
    REAL(DP), INTENT(OUT) :: position(:),normal(:),tangents(:,:) !<Actual useful outputs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_PositionNormalTangentCalculateNodeObj",err,error,*999)

    CALL Field_PositionNormalTangentsCalculateNode(field%field,variableType,componentNumber,localNodeNumber, &
    & position,normal,tangents,err,error,*999)

    EXITS("cmfe_Field_PositionNormalTangentCalculateNodeObj")
    RETURN
999 ERRORS("cmfe_Field_PositionNormalTangentCalculateNodeObj",err,error)
    EXITS("cmfe_Field_PositionNormalTangentCalculateNodeObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_PositionNormalTangentCalculateNodeObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh decomposition for a field identified by a user number.
  SUBROUTINE cmfe_Field_DecompositionGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,decompositionUserNumber,err)
    !DLLEXPORT(cmfe_Field_DecompositionGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(OUT) :: decompositionUserNumber !<On return, the field decomposition user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DecompositionGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    decompositionUserNumber=decomposition%userNumber

    EXITS("cmfe_Field_DecompositionGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DecompositionGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DecompositionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh decomposition for a field identified by an object.
  SUBROUTINE cmfe_Field_DecompositionGetObj(field,meshDecomposition,err)
    !DLLEXPORT(cmfe_Field_DecompositionGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(cmfe_DecompositionType), INTENT(INOUT) :: meshDecomposition !<On return, the mesh decomposition for the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DecompositionGetObj",err,error,*999)

    CALL Field_DecompositionGet(field%field,meshDecomposition%decomposition,err,error,*999)

    EXITS("cmfe_Field_DecompositionGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DecompositionGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DecompositionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field identified by a user number.
  SUBROUTINE cmfe_Field_DecompositionSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,meshUserNumber, &
    & decompositionUserNumber,err)
    !DLLEXPORT(cmfe_Field_DecompositionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The field mesh decomposition user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DecompositionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(decomposition)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Field_DecompositionSet(field,decomposition,err,error,*999)

    EXITS("cmfe_Field_DecompositionSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DecompositionSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DecompositionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field identified by an object.
  SUBROUTINE cmfe_Field_DecompositionSetObj(field,meshDecomposition,err)
    !DLLEXPORT(cmfe_Field_DecompositionSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(cmfe_DecompositionType), INTENT(IN) :: meshDecomposition !<The mesh decomposition for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DecompositionSetObj",err,error,*999)

    CALL Field_DecompositionSet(field%field,meshDecomposition%decomposition,err,error,*999)

    EXITS("cmfe_Field_DecompositionSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DecompositionSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DecompositionSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field identified by a user number.
  SUBROUTINE cmfe_Field_DataProjectionSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,err)
    !DLLEXPORT(cmfe_Field_DataProjectionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The field data projection user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_DataProjectionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL Field_DataProjectionSet(field,dataProjection,err,error,*999)

    EXITS("cmfe_Field_DataProjectionSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataProjectionSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataProjectionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field identified by an object.
  SUBROUTINE cmfe_Field_DataProjectionSetObj(field,dataProjection,err)
    !DLLEXPORT(cmfe_Field_DataProjectionSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DataProjectionSetObj",err,error,*999)

    CALL Field_DataProjectionSet(field%field,dataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_Field_DataProjectionSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataProjectionSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataProjectionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_NumberOfComponentsGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & numberOfComponents,err)
    !DLLEXPORT(cmfe_Field_NumberOfComponentsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of components for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_NumberOfComponentsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_NumberOfComponentsGet(field,variableType,numberOfComponents,err,error,*999)

    EXITS("cmfe_Field_NumberOfComponentsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfComponentsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfComponentsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of components for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_NumberOfComponentsGetObj(field,variableType,numberOfComponents,err)
    !DLLEXPORT(cmfe_Field_NumberOfComponentsGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of components for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_NumberOfComponentsGetObj",err,error,*999)

    CALL Field_NumberOfComponentsGet(field%field,variableType,numberOfComponents,err,error,*999)

    EXITS("cmfe_Field_NumberOfComponentsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfComponentsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfComponentsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_NumberOfComponentsSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & numberOfComponents,err)
    !DLLEXPORT(cmfe_Field_NumberOfComponentsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the number of components for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_NumberOfComponentsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_NumberOfComponentsSet(field,variableType,numberOfComponents,err,error,*999)

    EXITS("cmfe_Field_NumberOfComponentsSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfComponentsSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfComponentsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_NumberOfComponentsSetObj(field,variableType,numberOfComponents,err)
    !DLLEXPORT(cmfe_Field_NumberOfComponentsSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the number of components for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_NumberOfComponentsSetObj",err,error,*999)

    CALL Field_NumberOfComponentsSet(field%field,variableType,numberOfComponents,err,error,*999)

    EXITS("cmfe_Field_NumberOfComponentsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfComponentsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfComponentsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of variables for a field identified by a user number.
  SUBROUTINE cmfe_Field_NumberOfVariablesGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,numberOfVariables,err)
    !DLLEXPORT(cmfe_Field_NumberOfVariablesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of variables for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_NumberOfVariablesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_NumberOfVariablesGet(field,numberOfVariables,err,error,*999)

    EXITS("cmfe_Field_NumberOfVariablesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfVariablesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfVariablesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of variables for a field identified by an object.
  SUBROUTINE cmfe_Field_NumberOfVariablesGetObj(field,numberOfVariables,err)
    !DLLEXPORT(cmfe_Field_NumberOfVariablesGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_NumberOfVariablesGetObj",err,error,*999)

    CALL Field_NumberOfVariablesGet(field%field,numberOfVariables,err,error,*999)

    EXITS("cmfe_Field_NumberOfVariablesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfVariablesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfVariablesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/chnages the number of variables for a field identified by a user number.
  SUBROUTINE cmfe_Field_NumberOfVariablesSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,numberOfVariables,err)
    !DLLEXPORT(cmfe_Field_NumberOfVariablesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_NumberOfVariablesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_NumberOfVariablesSet(field,numberOfVariables,err,error,*999)

    EXITS("cmfe_Field_NumberOfVariablesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfVariablesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfVariablesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field identified by an object.
  SUBROUTINE cmfe_Field_NumberOfVariablesSetObj(field,numberOfVariables,err)
    !DLLEXPORT(cmfe_Field_NumberOfVariablesSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_NumberOfVariablesSetObj",err,error,*999)

    CALL Field_NumberOfVariablesSet(field%field,numberOfVariables,err,error,*999)

    EXITS("cmfe_Field_NumberOfVariablesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfVariablesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfVariablesSetObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddConstantIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddConstantIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddConstantIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetAddConstantIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetAddConstantIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddConstantIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the field parameter set.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddConstantIntgObj",err,error,*999)

    CALL Field_ParameterSetAddConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddConstantIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddConstantSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddConstantSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddConstantSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddConstantSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddConstantSPObj",err,error,*999)

    CALL Field_ParameterSetAddConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddConstantSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddConstantDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddConstantDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddConstantDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddConstantDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddConstantDPObj",err,error,*999)

    CALL Field_ParameterSetAddConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddConstantDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddConstantLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddConstantLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddConstantLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddConstantLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddConstantLObj",err,error,*999)

    CALL Field_ParameterSetAddConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddConstantLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantLObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddElementIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddElementIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddElementIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddElementIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddElementIntgObj",err,error,*999)

    CALL Field_ParameterSetAddElement(field%field,variableType,fieldSetType,UserElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddElementSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddElementSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddElementSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddElementSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddElementSPObj",err,error,*999)

    CALL Field_ParameterSetAddElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddElementDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddElementDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddElementDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddElementDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddElementDPObj",err,error,*999)

    CALL Field_ParameterSetAddElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddElementLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddElementLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddElementLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddElementLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddElementLObj",err,error,*999)

    CALL Field_ParameterSetAddElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementLObj

   !
  !================================================================================================================================
  !

  !>Adds the given integer value to a Gauss point of an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddGaussPointIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddGaussPointIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss Point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddGaussPointIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber,componentNumber, &
      & VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddGaussPointIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetAddGaussPointIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetAddGaussPointIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddGaussPointIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to a Gauss point in an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddGaussPointIntgObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddGaussPointIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddGaussPointIntgObj",err,error,*999)

    CALL Field_ParameterSetAddGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddGaussPointIntgObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetAddGaussPointIntgObj",err,error)
    EXITS("cmfe_Field_ParameterSetAddGaussPointIntgObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddGaussPointIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to a Gauss point in an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddGaussPointSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddGaussPointSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddGaussPointSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber,componentNumber, &
      & VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddGaussPointSPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetAddGaussPointSPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetAddGaussPointSPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddGaussPointSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to a Gauss point in an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddGaussPointSPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddGaussPointSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddGaussPointSPObj",err,error,*999)

    CALL Field_ParameterSetAddGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddGaussPointSPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetAddGaussPointSPObj",err,error)
    EXITS("cmfe_Field_ParameterSetAddGaussPointSPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddGaussPointSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to a Gauss point to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddGaussPointDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddGaussPointDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddGaussPointDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber,componentNumber, &
      & VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddGaussPointDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetAddGaussPointDPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetAddGaussPointDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddGaussPointDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to a Gauss point of an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddGaussPointDPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddGaussPointDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddGaussPointDPObj",err,error,*999)

    CALL Field_ParameterSetAddGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddGaussPointDPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetAddGaussPointDPObj",err,error)
    EXITS("cmfe_Field_ParameterSetAddGaussPointDPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddGaussPointDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to a Gauss point in an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddGaussPointLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddGaussPointLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddGaussPointLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddGaussPointLNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetAddGaussPointLNumber",err,error)
    EXITS("cmfe_Field_ParameterSetAddGaussPointLNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddGaussPointLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to a Gauss point in an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddGaussPointLObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddGaussPointLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddGaussPointLObj",err,error,*999)

    CALL Field_ParameterSetAddGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddGaussPointLObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetAddGaussPointLObj",err,error)
    EXITS("cmfe_Field_ParameterSetAddGaussPointLObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddGaussPointLObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddNodeIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddNodeIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddNodeIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddNodeIntgObj",err,error,*999)

    CALL Field_ParameterSetAddNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddNodeSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddNodeSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddNodeSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddNodeSPObj",err,error,*999)

    CALL Field_ParameterSetAddNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddNodeDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddNodeDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddNodeDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddNodeDPObj",err,error,*999)

    CALL Field_ParameterSetAddNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddNodeLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetAddNodeLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber, value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetAddNodeLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddNodeLObj",err,error,*999)

    CALL Field_ParameterSetAddNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeLObj

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetCreateNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)
    !DLLEXPORT(cmfe_Field_ParameterSetCreateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to create the parameter set on. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to create. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetCreateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetCreate(field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetCreateNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetCreateNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetCreateNumber

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetCreateObj(field,variableType,fieldSetType,err)
    !DLLEXPORT(cmfe_Field_ParameterSetCreateObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to create the field parameter set on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to create the parameter set on. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to create. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetCreateObj",err,error,*999)

    CALL Field_ParameterSetCreate(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetCreateObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetCreateObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetCreateObj

  !
  !================================================================================================================================
  !

  !>Destroys the specified parameter set type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetDestroyNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to destroy the parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to destroy. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDestroy(field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the specified parameter set type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetDestroyObj(field,variableType,fieldSetType,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDestroyObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to destroy the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to destroy the parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to destroy. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDestroyObj",err,error,*999)

    CALL Field_ParameterSetDestroy(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataGetIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetDataGetIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataGet(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetIntgObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataGetIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataGetIntgObj",err,error,*999)

    CALL Field_ParameterSetDataGet(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataGetSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetDataGetSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataGet(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetSPNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetSPObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataGetSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataGetSPObj",err,error,*999)

    CALL Field_ParameterSetDataGet(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetSPObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataGetDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetDataGetDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataGet(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetDPNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetDPObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataGetDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataGetDPObj",err,error,*999)

    CALL Field_ParameterSetDataGet(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetDPObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataGetLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetDataGetLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataGet(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetLNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetLObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataGetLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataGetLObj",err,error,*999)

    CALL Field_ParameterSetDataGet(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetLObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local integer array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataRestoreIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetDataRestoreIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataRestore(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetDataRestoreIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetDataRestoreIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreIntgNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local integer array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreIntgObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataRestoreIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataRestoreIntgObj",err,error,*999)

    CALL Field_ParameterSetDataRestore(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local single precision array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataRestoreSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetDataRestoreSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataRestore(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreSPNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local single precision array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreSPObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataRestoreSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataRestoreSPObj",err,error,*999)

    CALL Field_ParameterSetDataRestore(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local double precision array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataRestoreDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetDataRestoreDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataRestore(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreDPNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local double precision array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreDPObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataRestoreDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataRestoreDPObj",err,error,*999)

    CALL Field_ParameterSetDataRestore(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local logical array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataRestoreLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetDataRestoreLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataRestore(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreLNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local logical array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreLObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(cmfe_Field_ParameterSetDataRestoreLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataRestoreLObj",err,error,*999)

    CALL Field_ParameterSetDataRestore(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetConstantIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetConstantIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetConstantIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetGetConstantIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetConstantIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetConstantIntgObj",err,error,*999)

    CALL Field_ParameterSetGetConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetConstantSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetConstantSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetConstantSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetConstantSPObj",err,error,*999)

    CALL Field_ParameterSetGetConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetConstantDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetConstantDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetConstant(field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetConstantDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetConstantDPObj",err,error,*999)

    CALL Field_ParameterSetGetConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetConstantLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetConstantLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetConstantLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetConstantLObj",err,error,*999)

    CALL Field_ParameterSetGetConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointIntgNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetDataPointIntgNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_FieldGet(INTERFACE,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointIntgNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointIntgNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointIntgNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgNumberI

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointIntgNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetDataPointIntgNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointIntgNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointIntgNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointIntgNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetDataPointIntgObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointSPNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetDataPointSPNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointSPNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointSPNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointSPNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPNumberI

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointSPNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetDataPointSPNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointSPNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointSPNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointSPNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetDataPointSPObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointDPNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetDataPointDPNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointDPNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointDPNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointDPNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPNumberI

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointDPNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetDataPointDPNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointDPNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointDPNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointDPNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointLNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointLNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetDataPointLNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointLNumberI")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointLNumberI",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointLNumberI

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointLNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointLNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetDataPointLNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointLNumberR")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointLNumberR",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointLNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointLObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetDataPointLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetDataPointLObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetElementIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetElementIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetElementIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetElementIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetElementIntgObj",err,error,*999)

    CALL Field_ParameterSetGetElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetElementSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetElementSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetElementSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetElementSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetElementSPObj",err,error,*999)

    CALL Field_ParameterSetGetElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetElementDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetElementDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetElementDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetElementDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetElementDPObj",err,error,*999)

    CALL Field_ParameterSetGetElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetElementLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetElementLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetElementLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetElementLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetElementLObj",err,error,*999)

    CALL Field_ParameterSetGetElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetNodeIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetNodeIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetNodeIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetNodeIntgObj",err,error,*999)

    CALL Field_ParameterSetGetNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetNodeSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetNodeSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetNodeSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetNodeSPObj",err,error,*999)

    CALL Field_ParameterSetGetNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetNodeDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetNodeDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetNodeDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetNodeDPObj",err,error,*999)

    CALL Field_ParameterSetGetNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetNodeLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetGetNodeLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetNodeLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetNodeLObj",err,error,*999)

    CALL Field_ParameterSetGetNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetGaussPointDPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,VALUE,err)
    !DLLEXPORT(cmfe_Field_ParameterSetGetGaussPointDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetGaussPointDPObj",err,error,*999)

    CALL Field_ParameterSetGetGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetGaussPointDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetGaussPointDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetGaussPointDPObj
  !
  !================================================================================================================================
  !


  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateConstantIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateConstantIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateConstantIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateConstantIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateConstantIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateConstantIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantIntgObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateConstantIntgObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateConstantIntgObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateConstantSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateConstantSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantSPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateConstantSPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateConstantSPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateConstantSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateConstantSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateConstant(field%field,variableType,fieldSetType,componentNumber,Value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateConstantSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateConstantDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateConstantDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateConstantDPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateConstantDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateConstantDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateConstantDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateConstantDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateConstantLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateConstantLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantLNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateConstantLNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateConstantLNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateConstantLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateConstantLObj",err,error,*999)

    CALL Field_ParameterSetUpdateConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateConstantLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantLObj

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointIntgNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgNumberI

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointIntgNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointIntgObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgObj

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointSPNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointSPNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointSPNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointSPNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointSPNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPNumberI

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointSPNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointSPNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointSPNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointSPNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointSPNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateDataPointSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPObj

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointDPNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointDPNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_FieldGet(INTERFACE,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointDPNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointDPNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointDPNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPNumberI

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointDPNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointDPNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointDPNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointDPNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointDPNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateDataPointDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPObj

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointLNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointLNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointLNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointLNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointLNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLNumberI

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointLNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointLNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointLNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointLNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointLNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateDataPointLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointLObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateDataPointLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateElementIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateElementIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateElementIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateElementIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateElementIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateElementIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateElementIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateElementSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateElementSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementSPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateElementSPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateElementSPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateElementSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateElementSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateElementSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateElementDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateElementDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateElementDPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateElementDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateElementDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: VALUE !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateElementDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateElementDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateElementLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateElementLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateElementLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateElementLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateElementLObj",err,error,*999)

    CALL Field_ParameterSetUpdateElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateElementLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element data point of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementDataPointDPObj(field,variableType,fieldSetType,elementNumber,dataPointIndex, &
       & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateElementDataPointDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The user element number to update the data point for.
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point for the data points projected on this element.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateElementDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateElementDataPoint(field%field,variableType,fieldSetType,elementNumber,&
    & dataPointIndex,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementDataPointDPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateElementDataPointDPObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateElementDataPointDPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementDataPointDPObj

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateFinishNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to finish the parameter set update for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to finish the update for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateFinish(field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateFinishObj(field,variableType,fieldSetType,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateFinishObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to finishe the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to finish the parameter set update for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to finish the update for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateFinishObj",err,error,*999)

    CALL Field_ParameterSetUpdateFinish(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateFinishObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateNodeIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateNodeIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateNodeIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateNodeIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateNodeSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateNodeSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber, componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateNodeSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateNodeSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateNodeDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateNodeDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateNode(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateNodeDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateNodeDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateNodeLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateNodeLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateNode(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateNodeLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateNodeLObj",err,error,*999)

    CALL Field_ParameterSetUpdateNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateGaussPointIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointIntgObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber, value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateGaussPointIntgObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointIntgObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointIntgObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointIntgObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointIntgObj

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given single precision value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateGaussPointSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointSPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointSPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointSPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointSPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateGaussPointSPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointSPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointSPObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointSPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointSPObj

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given double precision value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateGaussPointDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointDPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointDPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber, value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateGaussPointDPObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointDPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointDPObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointDPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointDPObj

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given logical value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateGaussPointLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointLNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointLNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointLNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointLNumber

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given logical value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointLObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateGaussPointLObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointLObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateGaussPointLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointLObj

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateXiDPNumber0(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,partialDerivativeType,userElementNumber,xi,values,err)
    !DLLEXPORT(cmfe_Field_ParameterSetInterpolateXiDPNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetInterpolateXiDPNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetInterpolateXi(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & xi,values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetInterpolateXiDPNumber0")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateXiDPNumber0",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateXiDPNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateXiDPNumber0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateXiDPObj0(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
    & xi,values,err)
    !DLLEXPORT(cmfe_Field_ParameterSetInterpolateXiDPObj0)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetInterpolateXiDPObj0",err,error,*999)

    CALL Field_ParameterSetInterpolateXi(field%field,variableType,fieldSetType,partialDerivativeType,userElementNumber,xi, &
      & values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetInterpolateXiDPObj0")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateXiDPObj0",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateXiDPObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateXiDPObj0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateXiDPNumber1(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,partialDerivativeType,userElementNumber,xi,values,err)
    !DLLEXPORT(cmfe_Field_ParameterSetInterpolateXiDPNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:,:) !<xi(xiIdx,xiPointIdx). The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,xiPointIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetInterpolateXiDPNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetInterpolateXi(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & xi,values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetInterpolateXiDPNumber1")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateXiDPNumber1",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateXiDPNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateXiDPNumber1

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateXiDPObj1(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
    & xi,values,err)
    !DLLEXPORT(cmfe_Field_ParameterSetInterpolateXiDPObj1)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:,:) !<xi(xiIdx,xiPointIdx). The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,xiPointIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetInterpolateXiDPObj1",err,error,*999)

    CALL Field_ParameterSetInterpolateXi(field%field,variableType,fieldSetType,partialDerivativeType,userElementNumber,xi, &
      & values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetInterpolateXiDPObj1")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateXiDPObj1",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateXiDPObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateXiDPObj1

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values for a or a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateGaussDPNumber0(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,partialDerivativeType,userElementNumber,quadratureScheme,gaussPointNumber,values,err)
    !DLLEXPORT(cmfe_Field_ParameterSetInterpolateGaussDPNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for. \see OpenCMISS_BasisQuadratureSchemes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetInterpolateGaussDPNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetInterpolateGauss(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadratureScheme,gaussPointNumber,values,err,error,*999)
    
    EXITS("cmfe_Field_ParameterSetInterpolateGaussDPNumber0")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateGaussDPNumber0",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateGaussDPNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateGaussDPNumber0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateGaussDPObj0(field,variableType,fieldSetType,partialDerivativeType, &
    & userElementNumber,quadratureScheme,gaussPoint,values,err)
    !DLLEXPORT(cmfe_Field_ParameterSetInterpolateGaussDPObj0)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolte. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for. \see OpenCMISS_BasisQuadratureSchemes
    INTEGER(INTG), INTENT(IN) :: gaussPoint !<The Gauss point to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On return, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetInterpolateGaussDPObj",err,error,*999)

    CALL Field_ParameterSetInterpolateGauss(field%field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadratureScheme,GaussPoint,values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetInterpolateGaussDPObj0")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateGaussDPObj0",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateGaussDPObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateGaussDPObj0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values for a or a field identified by a user number. If no Gauss points are specified then all Gauss points are interpolated.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateGaussDPNumber1(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,partialDerivativeType,userElementNumber,quadratureScheme,gaussPoints,values,err)
    !DLLEXPORT(cmfe_Field_ParameterSetInterpolateGaussDPNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for. \see OpenCMISS_BasisQuadratureSchemes
    INTEGER(INTG), INTENT(IN) :: gaussPoints(:) !<gaussPoints(gaussPointIdx). The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,gaussPointIdx). On return, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetInterpolateGaussDPNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetInterpolateGauss(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadratureScheme,gaussPoints,values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetInterpolateGaussDPNumber1")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateGaussDPNumber1",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateGaussDPNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateGaussDPNumber1

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values for a field identified by an object. If no Gauss points are specified then all Gauss points are interpolated.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateGaussDPObj1(field,variableType,fieldSetType,partialDerivativeType, &
    & userElementNumber,quadratureScheme,gaussPoints,values,err)
    !DLLEXPORT(cmfe_Field_ParameterSetInterpolateGaussDPObj1)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate at.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for. \see OpenCMISS_BasisQuadratureSchemes
    INTEGER(INTG), INTENT(IN) :: gaussPoints(:) !<gaussPoints(gaussPointIdx). The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,gaussPointIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetInterpolateGaussDPObj1",err,error,*999)

    CALL Field_ParameterSetInterpolateGauss(field%field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadratureScheme,gaussPoints,values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetInterpolateGaussDPObj1")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateGaussDPObj1",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateGaussDPObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateGaussDPObj1

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateStartNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to start the parameter set update for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to start the update for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParameterSetUpdateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateStart(field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateStartObj(field,variableType,fieldSetType,err)
    !DLLEXPORT(cmfe_Field_ParameterSetUpdateStartObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to start the parameter set update for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to start the update for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateStartObj",err,error,*999)

    CALL Field_ParameterSetUpdateStart(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateStartObj

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are identified by user numbers.
  SUBROUTINE cmfe_Field_ParametersToFieldParametersComponentCopyNumber(contextUserNumber,fromRegionUserNumber, &
      & fromFieldUserNumber,fromVariableType,fromParameterSetType,fromComponentNumber,toRegionUserNumber, &
      & toFieldUserNumber,toVariableType,toParameterSetType,toComponentNumber,err)
    !DLLEXPORT(cmfe_Field_ParametersToFieldParametersComponentCopyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the regions.
    INTEGER(INTG), INTENT(IN) :: fromRegionUserNumber !<The user number of the region containing the field to copy from
    INTEGER(INTG), INTENT(IN) :: fromFieldUserNumber !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    INTEGER(INTG), INTENT(IN) :: toRegionUserNumber !<The user number of the region containing the field to copy to
    INTEGER(INTG), INTENT(IN) :: toFieldUserNumber !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: fromField,toField
    TYPE(RegionType), POINTER :: fromRegion,toRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ParametersToFieldParametersComponentCopyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(fromRegion)
    NULLIFY(toRegion)
    NULLIFY(fromField)
    NULLIFY(toField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,fromRegionUserNumber,fromRegion,err,error,*999)
    CALL Region_FieldGet(fromRegion,fromFieldUserNumber,fromField,err,error,*999)
    CALL Region_Get(regions,toRegionUserNumber,toRegion,err,error,*999)
    CALL Region_FieldGet(toRegion,toFieldUserNumber,toField,err,error,*999)
    CALL Field_ParametersToFieldParametersCopy(fromField,fromVariableType,fromParameterSetType, &
      & fromComponentNumber,toField,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)

    EXITS("cmfe_Field_ParametersToFieldParametersComponentCopyNumber")
    RETURN
999 ERRORS("cmfe_Field_ParametersToFieldParametersComponentCopyNumber",err,error)
    EXITS("cmfe_Field_ParametersToFieldParametersComponentCopyNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParametersToFieldParametersComponentCopyNumber

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are objects.
  SUBROUTINE cmfe_Field_ParametersToFieldParametersComponentCopyObj(fromField,fromVariableType,fromParameterSetType, &
    & fromComponentNumber,toField,toVariableType,toParameterSetType,toComponentNumber,err)
    !DLLEXPORT(cmfe_Field_ParametersToFieldParametersComponentCopyObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: fromField !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    TYPE(cmfe_FieldType), INTENT(IN) :: toField !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_Field_ParametersToFieldParametersComponentCopyObj",err,error,*999)

    CALL Field_ParametersToFieldParametersCopy(fromField%field,fromVariableType,fromParameterSetType, &
      & fromComponentNumber,toField%field,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)

    EXITS("cmfe_Field_ParametersToFieldParametersComponentCopyObj")
    RETURN
999 ERRORS("cmfe_Field_ParametersToFieldParametersComponentCopyObj",err,error)
    EXITS("cmfe_Field_ParametersToFieldParametersComponentCopyObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParametersToFieldParametersComponentCopyObj

  !
  !================================================================================================================================
  !

  !>Returns the scaling type for a field identified by a user number.
  SUBROUTINE cmfe_Field_ScalingTypeGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,scalingType,err)
    !DLLEXPORT(cmfe_Field_ScalingTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scaling type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: scalingType !<On return, the field scaling type. \see OpenCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ScalingTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ScalingTypeGet(field,scalingType,err,error,*999)

    EXITS("cmfe_Field_ScalingTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ScalingTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ScalingTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the scaling type for a field identified by an object.
  SUBROUTINE cmfe_Field_ScalingTypeGetObj(field,scalingType,err)
    !DLLEXPORT(cmfe_Field_ScalingTypeGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: scalingType !<On return, the field scaling type. \see OpenCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ScalingTypeGetObj",err,error,*999)

    CALL Field_ScalingTypeGet(field%field,scalingType,err,error,*999)

    EXITS("cmfe_Field_ScalingTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ScalingTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ScalingTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field identified by a user number.
  SUBROUTINE cmfe_Field_ScalingTypeSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,scalingType,err)
    !DLLEXPORT(cmfe_Field_ScalingTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: scalingType !<The field scaling type to set. \see OpenCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_ScalingTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ScalingTypeSet(field,scalingType,err,error,*999)

    EXITS("cmfe_Field_ScalingTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ScalingTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ScalingTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field identified by an object.
  SUBROUTINE cmfe_Field_ScalingTypeSetObj(field,scalingType,err)
    !DLLEXPORT(cmfe_Field_ScalingTypeSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: scalingType !<The field scaling type to set. \see OpenCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ScalingTypeSetObj",err,error,*999)

    CALL Field_ScalingTypeSet(field%field,scalingType,err,error,*999)

    EXITS("cmfe_Field_ScalingTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ScalingTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ScalingTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the field type for a field identified by a user number.
  SUBROUTINE cmfe_Field_TypeGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,fieldType_,err)
    !DLLEXPORT(cmfe_Field_TypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: fieldType_ !<On return, the field type. \see OpenCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_TypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_TypeGet(field,fieldType_,err,error,*999)

    EXITS("cmfe_Field_TypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_TypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type for a field identified by an object.
  SUBROUTINE cmfe_Field_TypeGetObj(field,fieldType_,err)
    !DLLEXPORT(cmfe_Field_TypeGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: fieldType_ !<On return, the field type. \see OpenCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_TypeGetObj",err,error,*999)

    CALL Field_TypeGet(field%field,fieldType_,err,error,*999)

    EXITS("cmfe_Field_TypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_TypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field identified by a user number.
  SUBROUTINE cmfe_Field_TypeSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,fieldType_,err)
    !DLLEXPORT(cmfe_Field_TypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldType_ !<The field type to set. \see OpenCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_TypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_TypeSet(field,fieldType_,err,error,*999)

    EXITS("cmfe_Field_TypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_TypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a field identified by an object.
  SUBROUTINE cmfe_Field_TypeSetObj(field,fieldType_,err)
    !DLLEXPORT(cmfe_Field_TypeSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldType_ !<The field type to set. \see OpenCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_TypeSetObj",err,error,*999)

    CALL Field_TypeSet(field%field,fieldType_,err,error,*999)

    EXITS("cmfe_Field_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableLabelGetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,label,err)
    !DLLEXPORT(cmfe_Field_VariableLabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OpenCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_Field_VariableLabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableLabelGet(field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableLabelGetCObj(field,variableType,label,err)
    !DLLEXPORT(cmfe_Field_VariableLabelGetCObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OpenCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableLabelGetCObj",err,error,*999)

    CALL Field_VariableLabelGet(field%field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableLabelGetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,label,err)
    !DLLEXPORT(cmfe_Field_VariableLabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OpenCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_VariableLabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableLabelGet(field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableLabelGetVSObj(field,variableType,label,err)
    !DLLEXPORT(cmfe_Field_VariableLabelGetVSObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OpenCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableLabelGetVSObj",err,error,*999)

    CALL Field_VariableLabelGet(field%field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableLabelSetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,label,err)
    !DLLEXPORT(cmfe_Field_VariableLabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OpenCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_VariableLabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableLabelSet(field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableLabelSetCObj(field,variableType,label,err)
    !DLLEXPORT(cmfe_Field_VariableLabelSetCObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OpenCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableLabelSetCObj",err,error,*999)

    CALL Field_VariableLabelSet(field%field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableLabelSetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,label,err)
    !DLLEXPORT(cmfe_Field_VariableLabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OpenCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_VariableLabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableLabelSet(field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableLabelSetVSObj(field,variableType,label,err)
    !DLLEXPORT(cmfe_Field_VariableLabelSetVSObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OpenCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableLabelSetVSObj",err,error,*999)

    CALL Field_VariableLabelSet(field%field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the field variable types for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableTypesGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableTypes,err)
    !DLLEXPORT(cmfe_Field_VariableTypesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the field variable types for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: variableTypes(:) !<variableTypes(variableIdx). On return, the field variable types for the variableIdx'th field variable. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_VariableTypesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableTypesGet(field,variableTypes,err,error,*999)

    EXITS("cmfe_Field_VariableTypesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableTypesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableTypesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the variable types for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableTypesGetObj(field,variableTypes,err)
    !DLLEXPORT(cmfe_Field_VariableTypesGetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: variableTypes(:) !<variableTypes(variableIdx). On return, the field variable types for the variableIdx'th field variable. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableTypesGetObj",err,error,*999)

    CALL Field_VariableTypesGet(field%field,variableTypes,err,error,*999)

    EXITS("cmfe_Field_VariableTypesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableTypesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableTypesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableTypesSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableTypes,err)
    !DLLEXPORT(cmfe_Field_VariableTypesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variableIdx). The field variable types for the variableIdx'th field variable to set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Field_VariableTypesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableTypesSet(field,variableTypes,err,error,*999)

    EXITS("cmfe_Field_VariableTypesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableTypesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableTypesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the variable types for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableTypesSetObj(field,variableTypes,err)
    !DLLEXPORT(cmfe_Field_VariableTypesSetObj)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variableIdx). The field variable types for the variableIdx'th field variable to set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableTypesSetObj",err,error,*999)

    CALL Field_VariableTypesSet(field%field,variableTypes,err,error,*999)

    EXITS("cmfe_Field_VariableTypesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableTypesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableTypesSetObj

!!==================================================================================================================================
!!
!! FIELD_IO_ROUTINES
!!
!!==================================================================================================================================

  !>Export element information for fields set identified by user number. 
  SUBROUTINE cmfe_Fields_ElementsExportCCNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_ElementsExportCCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: FileNameLength,MethodLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VFileName,VMethod

    ENTERS("cmfe_Fields_ElementsExportCCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(region%fields,VFileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportCCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Fields_ElementsExportCCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportCCNumber

  !
  !================================================================================================================================
  !

  !>Export element information for fields set identified by user number. 
  SUBROUTINE cmfe_Fields_ElementsExportVSCNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_ElementsExportVSCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: MethodLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VMethod

    ENTERS("cmfe_Fields_ElementsExportVSCNumber",err,error,*999)
    
    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(region%fields,fileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportVSCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Fields_ElementsExportVSCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportVSCNumber

  !
  !================================================================================================================================
  !

  !>Export element information for fields set identified by user number
  SUBROUTINE cmfe_Fields_ElementsExportCVSNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_ElementsExportCVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: FileNameLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VFileName

    ENTERS("cmfe_Fields_ElementsExportCVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(region%fields,VFileName,method,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportCVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Fields_ElementsExportCVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportCVSNumber

  !
  !================================================================================================================================
  !

  !>Export element information for fields set identified by user number.
  SUBROUTINE cmfe_Fields_ElementsExportVSVSNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_ElementsExportVSVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Fields_ElementsExportVSVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    
    CALL FIELD_IO_ELEMENTS_EXPORT(region%fields,fileName,method,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportVSVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Fields_ElementsExportVSVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportVSVSNumber
  
  !  
  !================================================================================================================================
  !

  !>Export element information for fields set identified by an object. 
  SUBROUTINE cmfe_Fields_ElementsExportCCObj(fields,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_ElementsExportCCObj)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: FileNameLength
    INTEGER(INTG) :: MethodLength

    ENTERS("cmfe_Fields_ElementsExportCCObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,VFileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportCCObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_ElementsExportCCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportCCObj

  !
  !================================================================================================================================
  !


  !>Export element information for fields set identified by an object.
  SUBROUTINE cmfe_Fields_ElementsExportVSCObj(fields,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_ElementsExportVSCObj)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: MethodLength

    ENTERS("cmfe_Fields_ElementsExportVSCObj",err,error,*999)

    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,fileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportVSCObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_ElementsExportVSCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportVSCObj

  !
  !================================================================================================================================
  !


  !>Export element information for fields set identified by an object.
  SUBROUTINE cmfe_Fields_ElementsExportCVSObj(fields,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_ElementsExportCVSObj)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    INTEGER(INTG) :: FileNameLength

    ENTERS("cmfe_Fields_ElementsExportCVSObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,VFileName,method,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportCVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_ElementsExportCVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportCVSObj

  !
  !================================================================================================================================
  !

  !>Export element information for fields set identified by an object.
  SUBROUTINE cmfe_Fields_ElementsExportVSVSObj(fields,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_ElementsExportVSVSObj)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_ElementsExportVSVSObj",err,error,*999)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,fileName,method,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportVSVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_ElementsExportVSVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportVSVSObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by user number
  SUBROUTINE cmfe_Fields_NodesExportCCNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_NodesExportCCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: FileNameLength,MethodLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VFileName,VMethod

    ENTERS("cmfe_Fields_NodesExportCCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(region%fields,VFileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_NodesExportCCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportCCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportCCNumber

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by user number
  SUBROUTINE cmfe_Fields_NodesExportVSCNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_NodesExportVSCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: MethodLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VMethod

    ENTERS("cmfe_Fields_NodesExportVSCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(region%fields,fileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_NodesExportVSCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportVSCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportVSCNumber

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by user number
  SUBROUTINE cmfe_Fields_NodesExportCVSNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_NodesExportCVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: FileNameLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VFileName

    ENTERS("cmfe_Fields_NodesExportCVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_NODES_EXPORT(region%fields,VFileName,method,err,error,*999)

    EXITS("cmfe_Fields_NodesExportCVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportCVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportCVSNumber

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by user number.
  SUBROUTINE cmfe_Fields_NodesExportVSVSNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_NodesExportVSVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Fields_NodesExportVSVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    
    CALL FIELD_IO_NODES_EXPORT(region%fields,fileName,method,err,error,*999)

    EXITS("cmfe_Fields_NodesExportVSVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportVSVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportVSVSNumber

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object.
  SUBROUTINE cmfe_Fields_NodesExportCCObj(fields,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_NodesExportCCObj)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: FileNameLength
    INTEGER(INTG) :: MethodLength

    ENTERS("cmfe_Fields_NodesExportCCObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,VFileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_NodesExportCCObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportCCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportCCObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object.
  SUBROUTINE cmfe_Fields_NodesExportVSCObj(fields,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_NodesExportVSCObj)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: MethodLength

    ENTERS("cmfe_Fields_NodesExportVSCObj",err,error,*999)

    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,fileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_NodesExportVSCObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportVSCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportVSCObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object.
  SUBROUTINE cmfe_Fields_NodesExportCVSObj(fields,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_NodesExportCVSObj)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    INTEGER(INTG) :: FileNameLength

    ENTERS("cmfe_Fields_NodesExportCVSObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,VFileName,method,err,error,*999)

    EXITS("cmfe_Fields_NodesExportCVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportCVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportCVSObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object.
  SUBROUTINE cmfe_Fields_NodesExportVSVSObj(fields,fileName,method,err)
    !DLLEXPORT(cmfe_Fields_NodesExportVSVSObj)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_NodesExportVSVSObj",err,error,*999)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,fileName,method,err,error,*999)

    EXITS("cmfe_Fields_NodesExportVSVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportVSVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportVSVSObj

!!==================================================================================================================================
!!
!! GeneratedMeshRoutines
!!
!!==================================================================================================================================

  !>Returns the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_BasisGetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,basisUserNumbers,err)
    !DLLEXPORT(cmfe_GeneratedMesh_BasisGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the basis for.
    INTEGER(INTG), INTENT(INOUT) :: basisUserNumbers(:) !<On return, the user numbers of the bases.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisPtrType), POINTER :: bases(:)
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    INTEGER(INTG) :: basisIdx,numberOfBases
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_BasisGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    NULLIFY(bases)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_BasisGet(generatedMesh,bases,err,error,*999)
    numberOfBases=SIZE(bases)
    IF(SIZE(basisUserNumbers)<numberOfBases) THEN
      localError="The basis user numbers array must have a size of at least "// &
        & TRIM(NumberToVString(numberOfBases,"*",err,error))// &
        & ". However, it has a size of " &
        & //TRIM(NumberToVString(SIZE(basisUserNumbers),"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END IF
    DO basisIdx=1,numberOfBases
      IF(ASSOCIATED(bases(basisIdx)%ptr)) THEN
        basisUserNumbers(basisIdx)=bases(basisIdx)%PTR%userNumber
      ELSE
        localError="The basis with index "//TRIM(NumberToVString(basisIdx,"*",err,error))// &
          & " is not associated for the generated mesh with a user number of "// &
          & TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ENDDO !basisIdx

    EXITS("cmfe_GeneratedMesh_BasisGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the basis for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_BasisGetObj(generatedMesh,bases,err)
    !DLLEXPORT(cmfe_GeneratedMesh_BasisGetObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the basis for.
    TYPE(cmfe_BasisType), INTENT(INOUT) :: bases(:) !<On return, the array of bases.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisPtrType), POINTER :: bases2(:)
    INTEGER(INTG) :: basisIdx,numberOfBases
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_BasisGetObj",err,error,*999)

    NULLIFY(bases2)
    CALL GeneratedMesh_BasisGet(generatedMesh%generatedMesh,bases2,err,error,*999)
    IF(ASSOCIATED(bases2)) THEN
      numberOfBases=SIZE(bases2)
      IF(SIZE(bases)<numberOfBases) THEN
        localError="The bases array must have a size of at least "// &
          & TRIM(NumberToVString(numberOfBases,"*",err,error))// &
          & ". However, it has a size of " &
          & //TRIM(NumberToVString(SIZE(bases),"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
      DO basisIdx=1,numberOfBases
        bases(basisIdx)%basis=>bases2(basisIdx)%ptr
      ENDDO !basisIdx
    ELSE
      localError="The bases are not associated for the generated mesh."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_BasisGetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_BasisSetNumber0(contextUserNumber,regionUserNumber,generatedMeshUserNumber,basisUserNumber,err)
    !DLLEXPORT(cmfe_GeneratedMesh_BasisSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_BasisSetNumber0",err,error,*999)

    CALL cmfe_GeneratedMesh_BasisSetNumber1(contextUserNumber,regionUserNumber,generatedMeshUserNumber,[basisUserNumber],err)

    EXITS("cmfe_GeneratedMesh_BasisSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_BasisSetNumber1(contextUserNumber,regionUserNumber,generatedMeshUserNumber,basisUserNumbers,err)
    !DLLEXPORT(cmfe_GeneratedMesh_BasisSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumbers(:) !<The user numbers of the bases to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisPtrType), POINTER :: bases(:)
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    INTEGER(INTG) :: basisIdx,numberOfBases

    ENTERS("cmfe_GeneratedMesh_BasisSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(basisFunctions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    NULLIFY(bases)
    numberOfBases=SIZE(basisUserNumbers)
    ALLOCATE(bases(numberOfBases),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate bases.",err,error,*999)

    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    DO basisIdx=1,numberOfBases
      NULLIFY(basis)
      CALL Basis_Get(basisFunctions,basisUserNumbers(basisIdx),basis,err,error,*999)
      bases(basisIdx)%ptr=>basis
    ENDDO !basisIdx
    CALL GeneratedMesh_BasisSet(generatedMesh,bases,err,error,*999)

    EXITS("cmfe_GeneratedMesh_BasisSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_BasisSetObj0(generatedMesh,basis,err)
    !DLLEXPORT(cmfe_GeneratedMesh_BasisSetObj0)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the basis for.
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_BasisSetObj0",err,error,*999)

    CALL cmfe_GeneratedMesh_BasisSetObj1(generatedMesh,[basis],err)

    EXITS("cmfe_GeneratedMesh_BasisSetObj0")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisSetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisSetObj0

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_BasisSetObj1(generatedMesh,bases,err)
    !DLLEXPORT(cmfe_GeneratedMesh_BasisSetObj1)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the basis for.
    TYPE(cmfe_BasisType), INTENT(IN) :: bases(:) !<The bases to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: basisIdx
    TYPE(BasisPtrType), ALLOCATABLE :: bases2(:)
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_BasisSetObj1",err,error,*999)

    ALLOCATE(bases2(SIZE(bases,1)),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate bases.",err,error,*999)
    DO basisIdx=1,SIZE(bases,1)
      IF(ASSOCIATED(bases(basisIdx)%basis)) THEN
        bases2(basisIdx)%ptr=>bases(basisIdx)%basis
      ELSE
        localError="The basis for index "//TRIM(NumberToVString(basisIdx,"*",err,error))//" is not associated."
        CALL FlagError(localError,err,error,*999)
      END IF
    ENDDO !basisIdx
    CALL GeneratedMesh_BasisSet(generatedMesh%generatedMesh,bases2,err,error,*999)

    EXITS("cmfe_GeneratedMesh_BasisSetObj1")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisSetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisSetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the base vectors for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_BaseVectorsSetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,baseVectors,err)
    !DLLEXPORT(cmfe_GeneratedMesh_BaseVectorsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the base vectors for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the base vectors for.
    REAL(DP), INTENT(IN) :: baseVectors(:,:) !<baseVectors(coordinate_idx,xi_idx). The base vectors to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_BaseVectorsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_BaseVectorsSet(generatedMesh,baseVectors,err,error,*999)

    EXITS("cmfe_GeneratedMesh_BaseVectorsSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BaseVectorsSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BaseVectorsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the base vectors for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_BaseVectorsSetObj(generatedMesh,baseVectors,err)
    !DLLEXPORT(cmfe_GeneratedMesh_BaseVectorsSetObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the base vectors for.
    REAL(DP), INTENT(IN) :: baseVectors(:,:) !<baseVectors(coordinate_idx,xi_idx). The base vectors to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_BaseVectorsSetObj",err,error,*999)

    CALL GeneratedMesh_BaseVectorsSet(generatedMesh%generatedMesh,baseVectors,err,error,*999)

    EXITS("cmfe_GeneratedMesh_BaseVectorsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BaseVectorsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BaseVectorsSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_CreateFinishNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,meshUserNumber,err)
    !DLLEXPORT(cmfe_GeneratedMesh_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_CreateFinish(generatedMesh,meshUserNumber,mesh,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated Mesh Create')
#endif

    EXITS("cmfe_GeneratedMesh_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_CreateFinishObj(generatedMesh,meshUserNumber,mesh,err)
    !DLLEXPORT(cmfe_GeneratedMesh_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to generate.
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !<On return, the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_CreateFinishObj",err,error,*999)

    CALL GeneratedMesh_CreateFinish(generatedMesh%generatedMesh,meshUserNumber,mesh%mesh,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated Mesh Create')
#endif

    EXITS("cmfe_GeneratedMesh_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_CreateStartNumber(generatedMeshUserNumber,contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(cmfe_GeneratedMesh_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to create the generated mesh in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL GeneratedMesh_CreateStart(generatedMeshUserNumber,region,generatedMesh,err,error,*999)

    EXITS("cmfe_GeneratedMesh_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on an interface identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_CreateStartInterfaceObj(generatedMeshUserNumber,interface,generatedMesh,err)
    !DLLEXPORT(cmfe_GeneratedMesh_CreateStartInterfaceObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    TYPE(cmfe_InterfaceType), INTENT(INOUT) :: interface !<The interface to created generated mesh in.
    TYPE(cmfe_GeneratedMeshType), INTENT(INOUT) :: generatedMesh !<On return, the created generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_CreateStartInterfaceObj",err,error,*999)

    CALL GeneratedMesh_CreateStart(generatedMeshUserNumber,interface%interface,generatedMesh%generatedMesh,err,error,*999)

    EXITS("cmfe_GeneratedMesh_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_CreateStartInterfaceObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on a region identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_CreateStartRegionObj(generatedMeshUserNumber,region,generatedMesh,err)
    !DLLEXPORT(cmfe_GeneratedMesh_CreateStartRegionObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    TYPE(cmfe_RegionType), INTENT(INOUT) :: region !<The region to created generated mesh in.
    TYPE(cmfe_GeneratedMeshType), INTENT(INOUT) :: generatedMesh !<On return, the created generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_CreateStartRegionObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif

    CALL GeneratedMesh_CreateStart(generatedMeshUserNumber,region%region,generatedMesh%generatedMesh,err,error,*999)

    EXITS("cmfe_GeneratedMesh_CreateStartRegionObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_CreateStartRegionObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_CreateStartRegionObj

  !
  !================================================================================================================================
  !

  !>Destroys a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_DestroyNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,err)
    !DLLEXPORT(cmfe_GeneratedMesh_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to destroy.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_Destroy(generatedMesh,err,error,*999)

    EXITS("cmfe_GeneratedMesh_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_DestroyObj(generatedMesh,err)
    !DLLEXPORT(cmfe_GeneratedMesh_DestroyObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(INOUT) :: generatedMesh !<The generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_DestroyObj",err,error,*999)

    CALL GeneratedMesh_Destroy(generatedMesh%generatedMesh,err,error,*999)

    EXITS("cmfe_GeneratedMesh_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_DestroyObj
  !
  !================================================================================================================================
  !

  !>Returns the extent for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_ExtentGetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,extent,err)
    !DLLEXPORT(cmfe_GeneratedMesh_ExtentGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the extent for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: extent(:) !<extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_ExtentGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_ExtentGet(generatedMesh,extent,err,error,*999)

    EXITS("cmfe_GeneratedMesh_ExtentGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_ExtentGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_ExtentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the extent for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_ExtentGetObj(generatedMesh,extent,err)
    !DLLEXPORT(cmfe_GeneratedMesh_ExtentGetObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: extent(:) !<extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_ExtentGetObj",err,error,*999)

    CALL GeneratedMesh_ExtentGet(generatedMesh%generatedMesh,extent,err,error,*999)

    EXITS("cmfe_GeneratedMesh_ExtentGetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_ExtentGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_ExtentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_ExtentSetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,extent,err)
    !DLLEXPORT(cmfe_GeneratedMesh_ExtentSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the extent for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent(:) !<extent(i). The extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_ExtentSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_ExtentSet(generatedMesh,extent,err,error,*999)

    EXITS("cmfe_GeneratedMesh_ExtentSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_ExtentSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_ExtentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_ExtentSetObj(generatedMesh,extent,err)
    !DLLEXPORT(cmfe_GeneratedMesh_ExtentSetObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent(:) !<extent(i). the extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_ExtentSetObj",err,error,*999)

    CALL GeneratedMesh_ExtentSet(generatedMesh%generatedMesh,extent,err,error,*999)

    EXITS("cmfe_GeneratedMesh_ExtentSetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_ExtentSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_ExtentSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of elements for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsGetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber, &
    & numberOfElements,err)
    !DLLEXPORT(cmfe_GeneratedMesh_NumberOfElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements(:) !<numberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_NumberOfElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_NumberOfElementsGet(generatedMesh,numberOfElements,err,error,*999)

    EXITS("cmfe_GeneratedMesh_NumberOfElementsGetNumber")
    RETURN
999 ERRORS("cmfe_GeneratedMesh_NumberOfElementsGetNumber",err,error)
    EXITS("cmfe_GeneratedMesh_NumberOfElementsGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of elements for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsGetObj(generatedMesh,numberOfElements,err)
    !DLLEXPORT(cmfe_GeneratedMesh_NumberOfElementsGetObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements(:) !<numberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_NumberOfElementsGetObj",err,error,*999)

    CALL GeneratedMesh_NumberOfElementsGet(generatedMesh%generatedMesh,numberOfElements,err,error,*999)

    EXITS("cmfe_GeneratedMesh_NumberOfElementsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_NumberOfElementsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsSetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber, &
    & numberOfElements,err)
    !DLLEXPORT(cmfe_GeneratedMesh_NumberOfElementsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements(:) !<numberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_NumberOfElementsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_NumberOfElementsSet(generatedMesh,numberOfElements,err,error,*999)

    EXITS("cmfe_GeneratedMesh_NumberOfElementsSetNumber")
    RETURN
999 ERRORS("cmfe_GeneratedMesh_NumberOfElementsSetNumber",err,error)
    EXITS("cmfe_GeneratedMesh_NumberOfElementsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsSetObj(generatedMesh,numberOfElements,err)
    !DLLEXPORT(cmfe_GeneratedMesh_NumberOfElementsSetObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements(:) !<numberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_NumberOfElementsSetObj",err,error,*999)

    CALL GeneratedMesh_NumberOfElementsSet(generatedMesh%generatedMesh,numberOfElements,err,error,*999)

    EXITS("cmfe_GeneratedMesh_NumberOfElementsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_NumberOfElementsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the origin of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_OriginGetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,origin,err)
    !DLLEXPORT(cmfe_GeneratedMesh_OriginGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the origin for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_OriginGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_OriginGet(generatedMesh,origin,err,error,*999)

    EXITS("cmfe_GeneratedMesh_OriginGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_OriginGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_OriginGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the origin of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_OriginGetObj(generatedMesh,origin,err)
    !DLLEXPORT(cmfe_GeneratedMesh_OriginGetObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_OriginGetObj",err,error,*999)

    CALL GeneratedMesh_OriginGet(generatedMesh%generatedMesh,origin,err,error,*999)

    EXITS("cmfe_GeneratedMesh_OriginGetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_OriginGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_OriginGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_OriginSetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,origin,err)
    !DLLEXPORT(cmfe_GeneratedMesh_OriginSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the origin for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_OriginSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_OriginSet(generatedMesh,origin,err,error,*999)

    EXITS("cmfe_GeneratedMesh_OriginSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_OriginSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_OriginSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_OriginSetObj(generatedMesh,origin,err)
    !DLLEXPORT(cmfe_GeneratedMesh_OriginSetObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_OriginSetObj",err,error,*999)

    CALL GeneratedMesh_OriginSet(generatedMesh%generatedMesh,origin,err,error,*999)

    EXITS("cmfe_GeneratedMesh_OriginSetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_OriginSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_OriginSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_TypeGetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,generatedMeshType_,err)
    !DLLEXPORT(cmfe_GeneratedMesh_TypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the type for.
    INTEGER(INTG), INTENT(OUT) :: generatedMeshType_ !<On return, the type of the generated mesh. \see OpenCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_TypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_TypeGet(generatedMesh,generatedMeshType_,err,error,*999)

    EXITS("cmfe_GeneratedMesh_TypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_TypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_TypeGetObj(generatedMesh,generatedMeshType_,err)
    !DLLEXPORT(cmfe_GeneratedMesh_TypeGetObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the generated mesh type for.
    INTEGER(INTG), INTENT(OUT) :: generatedMeshType_ !<On return, the type of the generated mesh. \see OpenCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_TypeGetObj",err,error,*999)

    CALL GeneratedMesh_TypeGet(generatedMesh%generatedMesh,generatedMeshType_,err,error,*999)

    EXITS("cmfe_GeneratedMesh_TypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_TypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_TypeSetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,generatedMeshType_,err)
    !DLLEXPORT(cmfe_GeneratedMesh_TypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshType_ !<The type of the generated mesh to set. \see OpenCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_TypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_TypeSet(generatedMesh,generatedMeshType_,err,error,*999)

    EXITS("cmfe_GeneratedMesh_TypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_TypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_TypeSetObj(generatedMesh,generatedMeshType_,err)
    !DLLEXPORT(cmfe_GeneratedMesh_TypeSetObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the generated mesh type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshType_ !<The type of the generated mesh to set. \see OpenCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_TypeSetObj",err,error,*999)

    CALL GeneratedMesh_TypeSet(generatedMesh%generatedMesh,generatedMeshType_,err,error,*999)

    EXITS("cmfe_GeneratedMesh_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Calculates and sets the geometric field parameters for a generated mesh identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_GeometricParametersCalculateNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber, &
      & fieldUserNumber,err)
    !DLLEXPORT(cmfe_GeneratedMesh_GeometricParametersCalculateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_GeometricParametersCalculateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_GeometricParametersCalculate(generatedMesh,field,err,error,*999)

    EXITS("cmfe_GeneratedMesh_GeometricParametersCalculateNumber")
    RETURN
999 ERRORS("cmfe_GeneratedMesh_GeometricParametersCalculateNumber",err,error)
    EXITS("cmfe_GeneratedMesh_GeometricParametersCalculateNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_GeometricParametersCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculates and sets the geometric field parameters for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_GeometricParametersCalculateObj(generatedMesh,field,err)
    !DLLEXPORT(cmfe_GeneratedMesh_GeometricParametersCalculateObj)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to calculate the geometric parameters for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<The field to calculate the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_GeometricParametersCalculateObj",err,error,*999)

    CALL GeneratedMesh_GeometricParametersCalculate(generatedMesh%generatedMesh,field%field,err,error,*999)

    EXITS("cmfe_GeneratedMesh_GeometricParametersCalculateObj")
    RETURN
999 ERRORS("cmfe_GeneratedMesh_GeometricParametersCalculateObj",err,error)
    EXITS("cmfe_GeneratedMesh_GeometricParametersCalculateObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_GeometricParametersCalculateObj

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_SurfaceGetNumber0(contextUserNumber,regionUserNumber,generatedMeshUserNumber,surfaceType, &
    & surfaceNodes,normalXi,err)
    !DLLEXPORT(cmfe_GeneratedMesh_SurfaceGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber  !<Guess what this is.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted.
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_SurfaceGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_SurfaceGet(generatedMesh,1,surfaceType,surfaceNodes,normalXi,err,error,*999)

    EXITS("cmfe_GeneratedMesh_SurfaceGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_SurfaceGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
  END SUBROUTINE cmfe_GeneratedMesh_SurfaceGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_SurfaceGetNumber1(contextUserNumber,regionUserNumber,meshComponent,generatedMeshUserNumber, &
      & surfaceType,surfaceNodes,normalXi,err)
    !DLLEXPORT(cmfe_GeneratedMesh_SurfaceGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component/basis number to use
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber  !<Guess what this is.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted.
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_GeneratedMesh_SurfaceGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_SurfaceGet(generatedMesh,meshComponent,surfaceType,surfaceNodes,normalXi,err,error,*999)

    EXITS("cmfe_GeneratedMesh_SurfaceGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_SurfaceGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
  END SUBROUTINE cmfe_GeneratedMesh_SurfaceGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_SurfaceGetObj0(generatedMesh,surfaceType,surfaceNodes,normalXi,err)
    !DLLEXPORT(cmfe_GeneratedMesh_SurfaceGetObj0)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh from which to extract surface nodes.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted .
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_GeneratedMesh_SurfaceGetObj0",err,error,*999)

    CALL GeneratedMesh_SurfaceGet(generatedMesh%generatedMesh,1,surfaceType,surfaceNodes,normalXi,err,error,*999)

    EXITS("cmfe_GeneratedMesh_SurfaceGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_SurfaceGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
  END SUBROUTINE cmfe_GeneratedMesh_SurfaceGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_SurfaceGetObj1(generatedMesh,meshComponent,surfaceType,surfaceNodes,normalXi,err)
    !DLLEXPORT(cmfe_GeneratedMesh_SurfaceGetObj1)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh from which to extract surface nodes.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component/basis number to use
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted .
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_GeneratedMesh_SurfaceGetObj1",err,error,*999)

    CALL GeneratedMesh_SurfaceGet(generatedMesh%generatedMesh,meshComponent,surfaceType,surfaceNodes,normalXi,err,error,*999)

    EXITS("cmfe_GeneratedMesh_SurfaceGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_SurfaceGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
  END SUBROUTINE cmfe_GeneratedMesh_SurfaceGetObj1


!!==================================================================================================================================
!!
!! MESH EMBEDDING ROUTINES
!!
!!==================================================================================================================================

  !>Initialises a EmbeddedMeshType object.
  SUBROUTINE cmfe_MeshEmbedding_Initialise(meshEmbedding,err)
    !DLLEXPORT(cmfe_MeshEmbedding_Initialise)
    !Argument variables
    TYPE(cmfe_MeshEmbeddingType), INTENT(OUT) ::  meshEmbedding !<The  MeshEmbeddingType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshEmbedding_Initialise",err,error,*999)

    NULLIFY(meshEmbedding%meshEmbedding)

    EXITS("cmfe_MeshEmbedding_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_MeshEmbedding_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshEmbedding_Initialise

  !
  !================================================================================================================================
  !
!>Creates a mesh embedding
  SUBROUTINE cmfe_MeshEmbedding_CreateNumber(contextUserNumber,regionOneUserNumber,regionTwoUserNumber,meshEmbedding, &
    & parentMeshUserNumber,childMeshUserNumber,err)
    !DLLEXPORT(cmfe_MeshEmbedding_CreateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionOneUserNumber, regionTwoUserNumber !<The user number of the region containing the mesh.
    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: parentMeshUserNumber, childMeshUserNumber  !<The user number of the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: PARENTMESH,CHILDMESH
    TYPE(RegionType), POINTER :: region1, REGION2
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshEmbedding_CreateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(REGION1)
    NULLIFY(REGION2)
    NULLIFY(PARENTMESH)
    NULLIFY(CHILDMESH)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionOneUserNumber,REGION1,err,error,*999)
    CALL Region_Get(regions,regionTwoUserNumber,REGION2,err,error,*999)
    CALL Region_MeshGet(region1,parentMeshUserNumber,PARENTMESH,err,error,*999)
    CALL Region_MeshGet(region2,childMeshUserNumber,CHILDMESH,err,error,*999)
    CALL MESH_EMBEDDING_CREATE(meshEmbedding%meshEmbedding,PARENTMESH,CHILDMESH,err,error,*999)

    EXITS("cmfe_MeshEmbedding_CreateNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshEmbedding_CreateNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshEmbedding_CreateNumber

  !
  !================================================================================================================================
  !

  !>Creates a mesh embedding
  SUBROUTINE cmfe_MeshEmbedding_CreateObj(meshEmbedding, parentMesh, childMesh, err)
    !DLLEXPORT(cmfe_MeshEmbedding_CreateObj)
    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(cmfe_MeshType), INTENT(IN) :: parentMesh, childMesh   !<The parent and child meshes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_MeshEmbedding_CreateObj",err,error,*999)

    CALL MESH_EMBEDDING_CREATE(meshEmbedding%meshEmbedding,parentMesh%mesh,childMesh%mesh,err,error,*999)

    EXITS("cmfe_MeshEmbedding_CreateObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshEmbedding_CreateObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshEmbedding_CreateObj

  !
  !================================================================================================================================
  !

  !>Sets the embedded nodes for one parent element
  SUBROUTINE cmfe_MeshEmbedding_SetChildNodePositionObj(meshEmbedding, elementNumber, nodeNumbers, xiCoords, err)
    !DLLEXPORT(cmfe_MeshEmbedding_SetChildNodePositionObj)
    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: elementNumber   !<Parent element number
    INTEGER(INTG), INTENT(IN) :: nodeNumbers(:)  !<Node numbers in child mesh
    REAL(DP), INTENT(IN)      :: xiCoords(:,:)   !<Xi coordinates of embedded nodes wrt parent element
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_MeshEmbedding_SetChildNodePositionObj",err,error,*999)

    CALL MESH_EMBEDDING_SET_CHILD_NODE_POSITION(meshEmbedding%meshEmbedding,elementNumber, nodeNumbers, xiCoords, err, error, *999)

    EXITS("cmfe_MeshEmbedding_SetChildNodePositionObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshEmbedding_SetChildNodePositionObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshEmbedding_SetChildNodePositionObj

  !
  !================================================================================================================================
  !

  !>Pushes data to embedded mesh. Will generally be used at library and not API level. /TODO: Parameter set etc, function name?
  SUBROUTINE cmfe_MeshEmbedding_PushDataObj(meshEmbedding, parentField, parentComponent, childField, childComponent, err)
    !DLLEXPORT(cmfe_MeshEmbedding_PushDataObj)
    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(cmfe_FieldType), INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from
!    TYPE(cmfe_FieldType), POINTER, INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from

    INTEGER(INTG), INTENT(IN) :: parentComponent, childComponent  !<Component numbers in respective fields
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_MeshEmbedding_PushDataObj",err,error,*999)

    CALL MeshEmbedding_PushData(meshEmbedding%meshEmbedding,parentField%field, parentComponent, childField%field, &
      & childComponent, err, error, *999)

    EXITS("cmfe_MeshEmbedding_PushDataObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshEmbedding_PushDataObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshEmbedding_PushDataObj

!
  !================================================================================================================================
  !
!   !>Sets the positions of a Gauss point of the parent mesh in terms of element/xi coordinated in the child mesh
    SUBROUTINE cmfe_MeshEmbedding_SetGaussPointDataObj(meshEmbedding, parentElementNumber,gaussPointNumber, &
       & parentXiCoords,childElementNumber,childXiCoords, err)
      !DLLEXPORT(cmfe_MeshEmbedding_SetGaussPointDataObj)
     TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
     INTEGER(INTG), INTENT(IN) :: parentElementNumber   !<Parent element number
     INTEGER(INTG), INTENT(IN) :: childElementNumber   !<Child element number
     INTEGER(INTG), INTENT(IN) :: gaussPointNumber  !<Gauss point number in this element
     REAL(DP), INTENT(IN)      :: parentXiCoords(:)   !<Xi coordinates of embedded nodes wrt parent element
     REAL(DP), INTENT(IN)      :: childXiCoords(:)   !<Xi coordinates of embedded nodes wrt Child element
     INTEGER(INTG), INTENT(OUT) :: err           !<The error code
     !
     ENTERS("cmfe_MeshEmbedding_SetGaussPointDataObj",err,error,*999)

     CALL MESH_EMBEDDING_SET_GAUSS_POINT_DATA(meshEmbedding%meshEmbedding, parentElementNumber, gaussPointNumber,&
       & parentXiCoords, childElementNumber, childXiCoords,err,error,*999)

     EXITS("cmfe_MeshEmbedding_SetGaussPointDataObj")
     RETURN
999  ERRORSEXITS("cmfe_MeshEmbedding_SetGaussPointDataObj",err,error)
     CALL cmfe_HandleError(err,error)
     RETURN

   END SUBROUTINE cmfe_MeshEmbedding_SetGaussPointDataObj
! !
  !================================================================================================================================
  !
!   !>Sets the positions of a Gauss point of the parent mesh in terms of element/xi coordinated in the child mesh
    SUBROUTINE cmfe_MeshEmbedding_PullGaussPointDataObj(meshEmbedding, parentField, parentComponent, childField, &
      & childComponent, err)
      !DLLEXPORT(cmfe_MeshEmbedding_PullGaussPointDataObj)
    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(cmfe_FieldType), INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from
    INTEGER(INTG), INTENT(IN) :: parentComponent, childComponent  !<Component numbers in respective fields
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_MeshEmbedding_PullGaussPointDataObj",err,error,*999)

     CALL MeshEmbedding_PullGaussPointData(meshEmbedding%meshEmbedding,parentField%field, parentComponent, &
      &  childField%field,childComponent, err, error, *999)

     EXITS("cmfe_MeshEmbedding_PullGaussPointDataObj")
     RETURN
999  ERRORSEXITS("cmfe_MeshEmbedding_PullGaussPointDataObj",err,error)
     CALL cmfe_HandleError(err,error)
     RETURN

    END SUBROUTINE cmfe_MeshEmbedding_PullGaussPointDataObj
! !
  !================================================================================================================================
  !
   SUBROUTINE cmfe_Field_ParameterSetGetGaussPointCoordObj(meshEmbedding,componentNumber,numberOfGaussPoints, &
     & coords,err)
     !DLLEXPORT(cmfe_Field_ParameterSetGetGaussPointCoordObj)

    !Argument variables
    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: componentNumber
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussPoints
    REAL(DP), INTENT(OUT)      :: coords(:)   !<Xi coordinates of embedded nodes wrt Child element
    INTEGER(INTG), INTENT(OUT) :: err           !<The error code
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetGaussPointCoordObj",err,error,*999)

    CALL Field_ParameterSetGetGaussPointCoord(meshEmbedding%meshEmbedding,componentNumber, &
      & NumberofGaussPoints,COORDS,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetGaussPointCoordObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetGaussPointCoordObj",err,error)
    EXITS("cmfe_Field_ParameterSetGetGaussPointCoordObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetGaussPointCoordObj

!!==================================================================================================================================
!!
!! InterfaceRoutines
!!
!!==================================================================================================================================

  !>Finishes the creation of an interface identified by a user number.
  SUBROUTINE cmfe_Interface_CreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(cmfe_Interface_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Interface_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_CreateFinish(interface,err,error,*999)

    EXITS("cmfe_Interface_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface identified by an object.
  SUBROUTINE cmfe_Interface_CreateFinishObj(interface,err)
    !DLLEXPORT(cmfe_Interface_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_CreateFinishObj",err,error,*999)

    CALL Interface_CreateFinish(interface%interface,err,error,*999)

    EXITS("cmfe_Interface_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface identified by a user number.
  SUBROUTINE cmfe_Interface_CreateStartNumber(interfaceUserNumber,contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(cmfe_Interface_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Interface_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Interface_CreateStart(interfaceUserNumber,region,interface,err,error,*999)

    EXITS("cmfe_Interface_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface identified by an object.
  SUBROUTINE cmfe_Interface_CreateStartObj(interfaceUserNumber,region,interface,err)
    !DLLEXPORT(cmfe_Interface_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the field to start the creation of.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to create the interface on.
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<On return, the created interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_CreateStartObj",err,error,*999)

    CALL Interface_CreateStart(interfaceUserNumber,region%region,interface%interface,err,error,*999)

    EXITS("cmfe_Interface_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_CoordinateSystemSetNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & coordinateSystemUserNumber,err)
    !DLLEXPORT(cmfe_Interface_CoordinateSystemSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region where interface was created.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Interface_CoordinateSystemSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(coordinateSystems)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL Interface_CoordinateSystemSet(interface,coordinateSystem,err,error,*999)

    EXITS("cmfe_Interface_CoordinateSystemSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CoordinateSystemSetNumber",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_CoordinateSystemSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for an interface identified by an object.
  SUBROUTINE cmfe_Interface_CoordinateSystemSetObj(interface,coordinateSystem,err)
    !DLLEXPORT(cmfe_Interface_CoordinateSystemSetObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to set the coordinate system for
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_CoordinateSystemSetObj",err,error,*999)

    CALL Interface_CoordinateSystemSet(interface%interface,coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_Interface_CoordinateSystemSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CoordinateSystemSetObj",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN
  END SUBROUTINE cmfe_Interface_CoordinateSystemSetObj

  !
  !================================================================================================================================
  !

  !>Returns the coordinate system for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_CoordinateSystemGetNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & coordinateSystemUserNumber,err)
    !DLLEXPORT(cmfe_Interface_CoordinateSystemGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the region to get the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the coordinate system for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemUserNumber !<On return, the coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Interface_CoordinateSystemGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_CoordinateSystemGet(interface,coordinateSystem,err,error,*999)
    coordinateSystemUserNumber = coordinateSystem%userNumber

    EXITS("cmfe_Interface_CoordinateSystemGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CoordinateSystemGetNumber",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_CoordinateSystemGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the coordinate system for an interface identified by an object.
  SUBROUTINE cmfe_Interface_CoordinateSystemGetObj(Interface,CoordinateSystem,err)
    !DLLEXPORT(cmfe_Interface_CoordinateSystemGetObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: Interface !<The interface to get the coordinate system for.
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: CoordinateSystem !<On return, the interface coordinate system.
   INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_CoordinateSystemGetObj",err,error,*999)

    CALL Interface_CoordinateSystemGet(Interface%interface,CoordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_Interface_CoordinateSystemGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CoordinateSystemGetObj",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_CoordinateSystemGetObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface identified by a user number.
  SUBROUTINE cmfe_Interface_DestroyNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(cmfe_Interface_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Interface_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_Destroy(interface,err,error,*999)

    EXITS("cmfe_Interface_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface identified by an object.
  SUBROUTINE cmfe_Interface_DestroyObj(interface,err)
    !DLLEXPORT(cmfe_Interface_DestroyObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_DestroyObj",err,error,*999)

    CALL Interface_Destroy(interface%interface,err,error,*999)

    EXITS("cmfe_Interface_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_LabelGetCNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber,label,err)
    !DLLEXPORT(cmfe_Interface_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Interface_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_LabelGet(interface,label,err,error,*999)

    EXITS("cmfe_Interface_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface identified by an object.
  SUBROUTINE cmfe_Interface_LabelGetCObj(interface,label,err)
    !DLLEXPORT(cmfe_Interface_LabelGetCObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_LabelGetCObj",err,error,*999)

    CALL Interface_LabelGet(interface%interface,label,err,error,*999)

    EXITS("cmfe_Interface_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_LabelGetVSNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber,label,err)
    !DLLEXPORT(cmfe_Interface_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Interface_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_LabelGet(interface,label,err,error,*999)

    EXITS("cmfe_Interface_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface identified by an object.
  SUBROUTINE cmfe_Interface_LabelGetVSObj(interface,label,err)
    !DLLEXPORT(cmfe_Interface_LabelGetVSObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: Interface !<The interface to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the interface label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_LabelGetVSObj",err,error,*999)

    CALL Interface_LabelGet(interface%interface,label,err,error,*999)

    EXITS("cmfe_Interface_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_LabelSetCNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber,label,err)
    !DLLEXPORT(cmfe_Interface_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Interface_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_LabelSet(interface,label,err,error,*999)

    EXITS("cmfe_Interface_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface identified by an object.
  SUBROUTINE cmfe_Interface_LabelSetCObj(interface,label,err)
    !DLLEXPORT(cmfe_Interface_LabelSetCObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: Interface !<The interface to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_LabelSetCObj",err,error,*999)

    CALL Interface_LabelSet(interface%interface,label,err,error,*999)

    EXITS("cmfe_Interface_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_LabelSetVSNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber,label,err)
    !DLLEXPORT(cmfe_Interface_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Interface_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_LabelSet(interface,CHAR(label),err,error,*999)

    EXITS("cmfe_Interface_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for an interface identified by an object.
  SUBROUTINE cmfe_Interface_LabelSetVSObj(interface,label,err)
    !DLLEXPORT(cmfe_Interface_LabelSetVSObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: Interface !<The interface to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_LabelSetVSObj",err,error,*999)

    CALL Interface_LabelSet(interface%interface,CHAR(label),err,error,*999)

    EXITS("cmfe_Interface_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the nodes for a interface identified by an object.
  SUBROUTINE cmfe_Interface_NodesGetObj(interface,nodes,err)
    !DLLEXPORT(cmfe_Interface_NodesGetObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to get the nodes for.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes !<On return, the interfaces nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_NodesGetObj",err,error,*999)

    CALL Interface_NodesGet(interface%interface,nodes%nodes,err,error,*999)

    EXITS("cmfe_Interface_NodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_NodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Adds a mesh to be coupled in an interface identified by a user number.
  SUBROUTINE cmfe_Interface_MeshAddNumber(contextUserNumber,interfaceRegionUserNumber,interfaceUserNumber,meshRegionUserNumber, &
    & meshUserNumber,meshIndex,err)
    !DLLEXPORT(cmfe_Interface_MeshAddNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the parent region containing the interface to add a coupled mesh to.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to add a coupled mesh to.
    INTEGER(INTG), INTENT(IN) :: meshRegionUserNumber !<The user number of the region containing the mesh to add to the interface.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to add to the interface.
    INTEGER(INTG), INTENT(OUT) :: meshIndex !<On return, the mesh index of the mesh in the list of coupled meshes in the interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: meshRegion,parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Interface_MeshAddNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(meshRegion)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,interfaceRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Region_Get(regions,meshRegionUserNumber,meshRegion,err,error,*999)
    CALL Region_MeshGet(meshRegion,meshUserNumber,mesh,err,error,*999)
    CALL Interface_MeshAdd(interface,mesh,meshIndex,err,error,*999)

    EXITS("cmfe_Interface_MeshAddNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_MeshAddNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_MeshAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a mesh to be coupled in an interface identified by an object.
  SUBROUTINE cmfe_Interface_MeshAddObj(interface,mesh,meshIndex,err)
    !DLLEXPORT(cmfe_Interface_MeshAddObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to finish creating.
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to add to the interface.
    INTEGER(INTG), INTENT(OUT) :: meshIndex !<On return, the mesh index of the mesh in the list of coupled meshes in the interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_MeshAddObj",err,error,*999)

    CALL Interface_MeshAdd(interface%interface,mesh%mesh,meshIndex,err,error,*999)

    EXITS("cmfe_Interface_MeshAddObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_MeshAddObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_MeshAddObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface coupled mesh connectivity identified by a user number.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating the meshes connectivity.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceMeshConnectivity_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfaceMeshConnectivity_CreateFinish(interface%meshConnectivity,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_CreateFinishNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_CreateFinishNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_CreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateFinishObj(interfaceMeshConnectivity,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface meshes connectivity to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_CreateFinishObj",err,error,*999)

    CALL InterfaceMeshConnectivity_CreateFinish(interfaceMeshConnectivity%meshConnectivity,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_CreateFinishObj")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_CreateFinishObj",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_CreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface meshes connectivity identified by a user number.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateStartNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & meshNumber,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: meshNumber !<The user number of the interface mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(MeshType), POINTER :: mesh
    TYPE(InterfaceMeshConnectivityType), POINTER :: interfaceMeshConnectivity
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceMeshConnectivity_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceMeshConnectivity)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_MeshGet(interface,meshNumber,mesh,err,error,*999)
    CALL InterfaceMeshConnectivity_CreateStart(interface,mesh,interfaceMeshConnectivity,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_CreateStartNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_CreateStartNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_CreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateStartObj(interface,interfaceMesh,interfaceMeshConnectivity,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_CreateStartObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of the meshes connectivity for
    TYPE(cmfe_MeshType), INTENT(IN) :: interfaceMesh
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(INOUT) :: interfaceMeshConnectivity !<On return, the created meshes connectivity
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_CreateStartObj",err,error,*999)

    CALL interfaceMeshConnectivity_CreateStart(interface%interface,interfaceMesh%mesh, &
      & interfaceMeshConnectivity%meshConnectivity,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_CreateStartObj")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_CreateStartObj",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_CreateStartObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateStartObj


  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
     &  interfaceElementNumber,coupledMeshIndexNumber,coupledElementNumber,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface meshe connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfaceMeshConnectivity_ElementNumberSet(interface%meshConnectivity,interfaceElementNumber, &
      & coupledMeshIndexNumber,coupledElementNumber,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementNumberSetObj(interfaceMeshConnectivity,interfaceElementNumber, &
     &  coupledMeshIndexNumber,coupledElementNumber,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_ElementNumberSetObj)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface mesh connectivity for the interface mesh
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber  !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_ElementNumberSetObj",err,error,*999)

    CALL InterfaceMeshConnectivity_ElementNumberSet(interfaceMeshConnectivity%meshConnectivity, &
      & interfaceElementNumber,coupledMeshIndexNumber,coupledElementNumber,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_ElementNumberSetObj")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_ElementNumberSetObj",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_ElementNumberSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementNumberSetObj


  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE cmfe_InterfaceMeshConnectivity_NodeNumberSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
     &  interfaceElementNumber,coupledMeshIndexNumber,coupledElementNumber,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_NodeNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface meshe connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_NodeNumberSetNumber",err,error,*999)

    CALL FlagError("Not implemented yet.",err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_NodeNumberSetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_NodeNumberSetNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_NodeNumberSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_NodeNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the connectivity between nodes in coupled meshes to nodes in the interface mesh
  SUBROUTINE cmfe_InterfaceMeshConnectivity_NodeNumberSetObj(interfaceMeshConnectivity,interfaceNodeNumbers, &
     &  firstCoupledMeshIndexNumber,firstCoupledMeshNodeNumbers,secondCoupledMeshIndexNumber,secondCoupledMeshNodeNumbers,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_NodeNumberSetObj)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface mesh connectivity for the interface mesh
    INTEGER(INTG), INTENT(IN) :: interfaceNodeNumbers(:)  !<The interface mesh node numbers to which the specified coupled mesh nodes would be connected
    INTEGER(INTG), INTENT(IN) :: firstCoupledMeshIndexNumber,secondCoupledMeshIndexNumber !<The index of the coupled meshes at the interface to set the node connectivity for
    INTEGER(INTG), INTENT(IN) :: firstCoupledMeshNodeNumbers(:),secondCoupledMeshNodeNumbers(:) !<The coupled meshes nodes to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_NodeNumberSetObj",err,error,*999)

    CALL InterfaceMeshConnectivity_NodeNumbersSet(interfaceMeshConnectivity%meshConnectivity, &
      & interfaceNodeNumbers,firstCoupledMeshIndexNumber,firstCoupledMeshNodeNumbers, &
      & secondCoupledMeshIndexNumber,secondCoupledMeshNodeNumbers,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_NodeNumberSetObj")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_NodeNumberSetObj",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_NodeNumberSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_NodeNumberSetObj

  !
  !================================================================================================================================
  !

  !>Sets the mapping from an xi position of a coupled mesh element to a node of an interface mesh element
  SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementXiSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    &  interfaceElementNumber,coupledMeshIndexNumber,coupledElementNumber,interfaceMeshLocalNodeNumber, &
    & interfaceMeshComponentNodeNumber,xi,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_ElementXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledElementNumber !<The coupled mesh element to define the element xi connectivity from
    INTEGER(INTG), INTENT(IN) :: interfaceMeshLocalNodeNumber !<The interface mesh node to assign the coupled mesh element xi to
    INTEGER(INTG), INTENT(IN) :: interfaceMeshComponentNodeNumber !<The interface mesh node's component to assign the coupled mesh element xi to
    REAL(DP), INTENT(IN) :: xi(:) !<The xi value for the xi_idx'th xi direction in the coupled mesh element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceMeshConnectivity_ElementXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfaceMeshConnectivity_ElementXiSet(interface%meshConnectivity,interfaceElementNumber, &
      & coupledMeshIndexNumber,coupledElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi, &
      & err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_ElementXiSetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_ElementXiSetNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_ElementXiSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the mapping from an xi position of a coupled mesh element to a node of an interface mesh element
  SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementXiSetObj(interfaceMeshConnectivity,interfaceElementNumber, &
     &  coupledMeshIndexNumber,coupledElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_ElementXiSetObj)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledElementNumber !<The coupled mesh element to define the element xi connectivity from
    INTEGER(INTG), INTENT(IN) :: interfaceMeshLocalNodeNumber !<The interface mesh node to assign the coupled mesh element xi to
    INTEGER(INTG), INTENT(IN) :: interfaceMeshComponentNodeNumber !<The interface mesh node's component to assign the coupled mesh element xi to
    REAL(DP), INTENT(IN) :: xi(:) !<The xi value for the xi_idx'th xi direction in the coupled mesh element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_ElementXiSetObj",err,error,*999)

    CALL InterfaceMeshConnectivity_ElementXiSet(interfaceMeshConnectivity%meshConnectivity,interfaceElementNumber, &
      & coupledMeshIndexNumber,coupledElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi, &
      & err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_ElementXiSetObj")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_ElementXiSetObj",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_ElementXiSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementXiSetObj

  !
  !================================================================================================================================
  !

  SUBROUTINE cmfe_InterfaceMeshConnectivity_BasisSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceBasisNumber,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_BasisSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceBasisNumber !<The user number of the basis to denote the interface mesh connectivity basis
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceMeshConnectivity_BasisSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(basisFunctions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Basis_Get(basisFunctions,interfaceBasisNumber,basis,err,error,*999)
    CALL InterfaceMeshConnectivity_BasisSet(interface%meshConnectivity,basis,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_BasisSetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_BasisSetNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_BasisSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_BasisSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the basis for the mesh connectivity
  SUBROUTINE cmfe_InterfaceMeshConnectivity_BasisSetObj(interfaceMeshConnectivity,interfaceMappingBasis,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_BasisSetObj)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface to start the creation of the meshes connectivity for
    TYPE(cmfe_BasisType), INTENT(INOUT) :: interfaceMappingBasis !<The interface mesh connectivity basis
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_BasisSetObj",err,error,*999)

    CALL InterfaceMeshConnectivity_BasisSet(interfaceMeshConnectivity%meshConnectivity,interfaceMappingBasis%basis, &
      & err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_BasisSetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceMeshConnectivity_BasisSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_BasisSetObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface meshes connectivity identified by a user number.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_DestroyNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceMeshConnectivity_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfaceMeshConnectivity_Destroy(interface%meshConnectivity,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_DestroyNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_DestroyNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_DestroyNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface meshes connectivity identified by an object.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_DestroyObj(interfaceMeshConnectivity,err)
    !DLLEXPORT(cmfe_InterfaceMeshConnectivity_DestroyObj)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface meshes connectivity to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_DestroyObj",err,error,*999)

    CALL InterfaceMeshConnectivity_Destroy(interfaceMeshConnectivity%meshConnectivity,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceMeshConnectivity_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface coupled mesh points connectivity identified by a user number.
  SUBROUTINE cmfe_InterfacePointsConnectivity_CreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface points connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating the points connectivity.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfacePointsConnectivity_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfacePointsConnectivity_CreateFinish(interface%pointsConnectivity,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_CreateFinishNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_CreateFinishNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_CreateFinishNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE cmfe_InterfacePointsConnectivity_CreateFinishObj(interfacePointsConnectivity,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfacePointsConnectivity_CreateFinishObj",err,error,*999)

    CALL InterfacePointsConnectivity_CreateFinish(interfacePointsConnectivity%pointsConnectivity,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_CreateFinishObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_CreateFinishObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_CreateFinishObj")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface points connectivity identified by a user number.
  SUBROUTINE cmfe_InterfacePointsConnectivity_CreateStartNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & meshUserNumber,dataPointsUserNumber,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the interface mesh
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfacePointsConnectivityType), POINTER :: interfacePointsConnectivity
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_InterfacePointsConnectivity_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfacePointsConnectivity)
    NULLIFY(mesh)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_MeshGet(interface,meshUserNumber,mesh,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL InterfacePointsConnectivity_CreateStart(interface,mesh,dataPoints,interfacePointsConnectivity,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_CreateStartNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_CreateStartNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_CreateStartNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface points connectivity identified by an object.
  SUBROUTINE cmfe_InterfacePointsConnectivity_CreateStartObj(INTERFACE,interfaceMesh,dataPoints,interfacePointsConnectivity,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_CreateStartObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of the meshes connectivity for
    TYPE(cmfe_MeshType), INTENT(IN) :: interfaceMesh
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(INOUT) :: interfacePointsConnectivity !<On return, the created meshes connectivity
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfacePointsConnectivity_CreateStartObj",err,error,*999)

    CALL InterfacePointsConnectivity_CreateStart(INTERFACE%INTERFACE,interfaceMesh%mesh,dataPoints%dataPoints, &
      & InterfacePointsConnectivity%pointsConnectivity,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_CreateStartObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_CreateStartObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_CreateStartObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface points connectivity identified by a user number.
  SUBROUTINE cmfe_InterfacePointsConnectivity_DestroyNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to destroy the points connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to destroy the points connectivity for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfacePointsConnectivity_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfacePointsConnectivity_Destroy(interface%pointsConnectivity,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_DestroyNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_DestroyNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_DestroyNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface points connectivity identified by an object.
  SUBROUTINE cmfe_InterfacePointsConnectivity_DestroyObj(interfacePointsConnectivity,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_DestroyObj)

    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfacePointsConnectivity_DestroyObj",err,error,*999)

    CALL InterfacePointsConnectivity_Destroy(interfacePointsConnectivity%pointsConnectivity,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfacePointsConnectivity_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_DestroyObj

  !
  !================================================================================================================================
  !

  !>Gets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    &  interfaceDataPointIndexNumber,coupledMeshIndexNumber,meshComponentNumber,coupledElementUserNumber,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_ElementNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the interface mesh that points connectivity is associated to
    INTEGER(INTG), INTENT(OUT) :: coupledElementUserNumber !<The element user number where the data point is connected to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: coupledElementGlobalNumber,dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
    TYPE(MeshType), POINTER :: coupledMesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfacePointsConnectivity_ElementNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(INTERFACE)
    NULLIFY(pointsConnectivity)
    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)    
    NULLIFY(coupledMesh)
    NULLIFY(meshTopology)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_PointsConnectivityGet(INTERFACE,pointsConnectivity,err,error,*999)
    CALL InterfacePointsConnectivity_DataPointsGet(pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(pointsConnectivity,dataPointGlobalNumber,coupledMeshIndexNumber, &
      & pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_CoupledElementNumberGet(pointConnectivity,coupledElementGlobalNumber,err,error,*999)
    CALL Interface_CoupledMeshGet(interface,coupledMeshIndexNumber,coupledMesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(coupledMesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)
    CALL MeshElements_ElementUserNumberGet(meshElements,coupledElementGlobalNumber,coupledElementUserNumber,err,error,*999)
    
    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberGetNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_ElementNumberGetNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberGetNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Gets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberGetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
      & coupledMeshIndexNumber,meshComponentNumber,coupledElementUserNumber,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_ElementNumberGetObj)

    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to set the element number for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the interface mesh that points connectivity is associated to
    INTEGER(INTG), INTENT(OUT) :: coupledElementUserNumber !<The element user number where the data point is projected to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: coupledElementGlobalNumber,dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(MeshType), POINTER :: coupledMesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology

    ENTERS("cmfe_InterfacePointsConnectivity_ElementNumberGetObj",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    NULLIFY(INTERFACE)
    NULLIFY(coupledMesh)
    NULLIFY(meshTopology)
    NULLIFY(meshElements)
    CALL InterfacePointsConnectivity_DataPointsGet(interfacePointsConnectivity%pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(interfacePointsConnectivity%pointsConnectivity, &
      & dataPointGlobalNumber,coupledMeshIndexNumber,pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_CoupledElementNumberGet(pointConnectivity,coupledElementGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_InterfaceGet(interfacePointsConnectivity%pointsConnectivity,INTERFACE,err,error,*999)
    CALL Interface_CoupledMeshGet(interface,coupledMeshIndexNumber,coupledMesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(coupledMesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)
    CALL MeshElements_ElementUserNumberGet(meshElements,coupledElementGlobalNumber,coupledElementUserNumber,err,error,*999)
    
    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberGetObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_ElementNumberGetObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberGetObj")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberGetObj

  !
  !================================================================================================================================
  !

!!TODO: why are the element number and mesh component number switched when compared to the get method?
  !>Sets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
     &  interfaceDataPointIndexNumber,coupledMeshIndexNumber,coupledElementUserNumber,meshComponentNumber,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_ElementNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: coupledElementUserNumber !<The element user number where the data point is projected to.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the points connectivity element number for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: coupledElementGlobalNumber,dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
    TYPE(MeshType), POINTER :: coupledMesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfacePointsConnectivity_ElementNumberSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(INTERFACE)
    NULLIFY(pointsConnectivity)
    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    NULLIFY(coupledMesh)
    NULLIFY(meshTopology)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_PointsConnectivityGet(INTERFACE,pointsConnectivity,err,error,*999)
    CALL InterfacePointsConnectivity_DataPointsGet(pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(pointsConnectivity,dataPointGlobalNumber,coupledMeshIndexNumber, &
      & pointConnectivity,err,error,*999)
    CALL Interface_CoupledMeshGet(interface,coupledMeshIndexNumber,coupledMesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(coupledMesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,coupledElementUserNumber,coupledElementGlobalNumber,err,error,*999)
    CALL InterfacePointConnectivity_CoupledElementNumberSet(pointConnectivity,coupledElementGlobalNumber,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberSetNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_ElementNumberSetNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberSetNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberSetNumber

  !
  !================================================================================================================================
  !

!!TODO: why are the element number and mesh component number switched when compared to the get method?
  !>Sets coupled mesh element user number that the data point in the interface is connected to
  SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberSetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
      & coupledMeshIndexNumber,coupledElementUserNumber,meshComponentNumber,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_ElementNumberSetObj)

    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to set the element number for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: coupledElementUserNumber !<The element user number where the data point is projected to.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the points connectivity element number for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: coupledElementGlobalNumber,dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(MeshType), POINTER :: coupledMesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology

    ENTERS("cmfe_InterfacePointsConnectivity_ElementNumberSetObj",err,error,*999)
    
    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    NULLIFY(INTERFACE)
    NULLIFY(coupledMesh)
    NULLIFY(meshTopology)
    NULLIFY(meshElements)
    CALL InterfacePointsConnectivity_DataPointsGet(interfacePointsConnectivity%pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(interfacePointsConnectivity%pointsConnectivity, &
      & dataPointGlobalNumber,coupledMeshIndexNumber,pointConnectivity,err,error,*999)
    CALL InterfacePointsConnectivity_InterfaceGet(interfacePointsConnectivity%pointsConnectivity,INTERFACE,err,error,*999)
    CALL Interface_CoupledMeshGet(interface,coupledMeshIndexNumber,coupledMesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(coupledMesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,coupledElementUserNumber,coupledElementGlobalNumber,err,error,*999)
    CALL InterfacePointConnectivity_CoupledElementNumberSet(pointConnectivity,coupledElementGlobalNumber,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberSetObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_ElementNumberSetObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberSetObj")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberSetObj

  !
  !================================================================================================================================
  !

  !>Gets the xi coordinate mapping between the data points in interface and xi coordinates in a coupled region mesh
  SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_PointXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(OUT) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOfXi
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfacePointsConnectivity_PointXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(INTERFACE)
    NULLIFY(pointsConnectivity)
    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_PointsConnectivityGet(INTERFACE,pointsConnectivity,err,error,*999)
    CALL InterfacePointsConnectivity_DataPointsGet(pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(pointsConnectivity,dataPointGlobalNumber,coupledMeshIndexNumber, &
      & pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_XiGet(pointConnectivity,numberOfXi,xi,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_PointXiGetNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_PointXiGetNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_PointXiGetNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the xi coordinate mapping between the interface data points and xi coordinates in a coupled region mesh
  SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiGetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
     &  coupledMeshIndexNumber,xi,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_PointXiGetObj)

    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(OUT) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOfXi
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity

    ENTERS("cmfe_InterfacePointsConnectivity_PointXiGetObj",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    CALL InterfacePointsConnectivity_DataPointsGet(interfacePointsConnectivity%pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(interfacePointsConnectivity%pointsConnectivity, &
      & dataPointGlobalNumber,coupledMeshIndexNumber,pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_XiGet(pointConnectivity,numberOfXi,xi,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_PointXiGetObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_PointXiGetObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_PointXiGetObj")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets the xi coordinate mapping between the data points in interface and xi coordinates in a coupled region mesh
  SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_PointXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_InterfacePointsConnectivity_PointXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(pointsConnectivity)
    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_PointsConnectivityGet(INTERFACE,pointsConnectivity,err,error,*999)
    CALL InterfacePointsConnectivity_DataPointsGet(pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(pointsConnectivity,dataPointGlobalNumber,coupledMeshIndexNumber, &
      & pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_XiSet(pointConnectivity,xi,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_PointXiSetNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_PointXiSetNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_PointXiSetNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the xi coordinate mapping between the interface data points and xi coordinates in a coupled region mesh
  SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiSetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
     &  coupledMeshIndexNumber,xi,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_PointXiSetObj)

    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: InterfacePointsConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity

    ENTERS("cmfe_InterfacePointsConnectivity_PointXiSetObj",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    CALL InterfacePointsConnectivity_DataPointsGet(interfacePointsConnectivity%pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(interfacePointsConnectivity%pointsConnectivity,dataPointGlobalNumber, &
      & coupledMeshIndexNumber,pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_XiSet(pointConnectivity,xi,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_PointXiSetObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_PointXiSetObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_PointXiSetObj")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiSetObj

  !
  !================================================================================================================================
  !

  !>Update points connectivity with projection results, data projection identified by region user number
  SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber(contextUserNumber,regionUserNumber, &
      & interfaceUserNumber,dataPointsRegionUserNumber,dataPointsUserNumber,dataProjectionUserNumber,coupledMeshIndex,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: dataPointsRegionUserNumber !<The region number of the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points .
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion,dataPointsRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(dataPointsRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,ParentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Region_Get(regions,dataPointsRegionUserNumber,dataPointsRegion,err,error,*999)
    CALL Region_DataPointsGet(dataPointsRegion,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL InterfacePointsConnectivity_UpdateFromProjection(interface%PointsConnectivity, &
      & dataProjection,coupledMeshIndex,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber

  !
  !================================================================================================================================
  !

  !>Update points connectivity with projection results, data projection identified by interface user number
  SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & dataPointsRegionUserNumber,dataPointsInterfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,coupledMeshIndex,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: dataPointsRegionUserNumber !<The parent region number of the interface for the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataPointsInterfaceUserNumber !<The interface number of the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface,dataPointsInterface
    TYPE(RegionType), POINTER :: parentRegion,dataPointsRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(dataPointsRegion)
    NULLIFY(interface)
    NULLIFY(dataPointsInterface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Region_Get(regions,dataPointsRegionUserNumber,dataPointsRegion,err,error,*999)
    CALL Region_InterfaceGet(dataPointsRegion,dataPointsInterfaceUserNumber,dataPointsInterface,err,error,*999)
    CALL Interface_DataPointsGet(dataPointsInterface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL InterfacePointsConnectivity_UpdateFromProjection(interface%PointsConnectivity, &
      & dataProjection,coupledMeshIndex,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber

  !
  !================================================================================================================================
  !

  !>Update points connectivity with projection results, data projection identified by object
  SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj(pointsConnectivity,dataProjection, &
      & coupledMeshIndex,err)
    !DLLEXPORT(cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj)

    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: pointsConnectivity !<A pointer to the interface points connectivity to finish creating
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The mesh index of the the points connectivity to be updated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj",err,error,*999)

    CALL InterfacePointsConnectivity_UpdateFromProjection(pointsConnectivity%pointsConnectivity, &
      & dataProjection%dataProjection,coupledMeshIndex,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj

!!==================================================================================================================================
!!
!! InterfaceConditionRoutines
!!
!!==================================================================================================================================

  !>Finishes the creation of an interface condition identified by an user number.
  SUBROUTINE cmfe_InterfaceCondition_CreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceCondition_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish creating for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_CreateFinish(interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_CreateFinishObj(interfaceCondition,err)
    !DLLEXPORT(cmfe_InterfaceCondition_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_CreateFinishObj",err,error,*999)

    CALL InterfaceCondition_CreateFinish(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_CreateStartNumber(interfaceConditionUserNumber,contextUserNumber,regionUserNumber, &
    & interfaceUserNumber,geometricFieldUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceCondition_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of.
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The user number of the geometric field on the interface for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: geometricField
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(geometricField)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,geometricFieldUserNumber,geometricField,err,error,*999)
    CALL InterfaceCondition_CreateStart(interfaceConditionUserNumber,interface,geometricField,interfaceCondition, &
      & err,error,*999)

    EXITS("cmfe_InterfaceCondition_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_CreateStartObj(interfaceConditionUserNumber,interface,geometricField,interfaceCondition,err)
    !DLLEXPORT(cmfe_InterfaceCondition_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface conditon to start the creation of.
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to create the interface on.
    TYPE(cmfe_FieldType), INTENT(IN) :: geometricField !<The geometric field for the interface condition.
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<On return, the created interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_CreateStartObj",err,error,*999)

    CALL InterfaceCondition_CreateStart(interfaceConditionUserNumber,interface%interface,geometricField%field, &
      & interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Adds a dependent variable to an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_DependentVariableAddNumber(contextUserNumber,interfaceRegionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,meshIndex,equationsSetRegionUserNumber,equationsSetUserNumber,variableType,err)
    !DLLEXPORT(cmfe_InterfaceCondition_DependentVariableAddNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface containing the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: meshIndex !<The mesh index of the interface condition interface for which the dependent variable is added.
    INTEGER(INTG), INTENT(IN) :: equationsSetRegionUserNumber !<The user number of the region containing the equations set containing the dependent field varible to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set containing the dependent field to add the variable for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent variable to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: equationsSetRegion,interfaceRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_DependentVariableAddNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(interfaceRegion)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(equationsSetRegion)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,interfaceRegionUserNumber,interfaceRegion,err,error,*999)
    CALL Region_InterfaceGet(interfaceRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL Region_Get(regions,EquationsSetRegionuserNumber,equationsSetRegion,err,error,*999)
    CALL Region_EquationsSetGet(equationsSetRegion,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL InterfaceCondition_DependentVariableAdd(interfaceCondition,meshIndex,equationsSet,variableType, &
      & err,error,*999)

    EXITS("cmfe_InterfaceCondition_DependentVariableAddNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_DependentVariableAddNumber",err,error)
    EXITS("cmfe_InterfaceCondition_DependentVariableAddNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_DependentVariableAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a dependent field variable to an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_DependentVariableAddObj(interfaceCondition,meshIndex,equationsSet,variableType,err)
    !DLLEXPORT(cmfe_InterfaceCondition_DependentVariableAddObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add the dependent variable to.
    INTEGER(INTG), INTENT(IN) :: meshIndex !<The mesh index of the interface condition interface for which the dependent variable is added.
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set containg the dependent variable to add.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent variable to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_DependentVariableAddObj",err,error,*999)

    CALL InterfaceCondition_DependentVariableAdd(interfaceCondition%interfaceCondition,meshIndex,equationsSet%equationsSet, &
      & variableType,err,error,*999)

    EXITS("cmfe_InterfaceCondition_DependentVariableAddObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_DependentVariableAddObj",err,error)
    EXITS("cmfe_InterfaceCondition_DependentVariableAddObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_DependentVariableAddObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_DestroyNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceCondition_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_Destroy(interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_DestroyObj(interfaceCondition,err)
    !DLLEXPORT(cmfe_InterfaceCondition_DestroyObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_DestroyObj",err,error,*999)

    CALL InterfaceCondition_Destroy(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of equations for an interface condition identified by an user number.
  SUBROUTINE cmfe_InterfaceCondition_EquationsCreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceCondition_EquationsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_EquationsCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_InterfaceConditionGet(INTERFACE,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_EquationsCreateFinish(interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_EquationsCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_EquationsCreateFinishNumber",err,error)
    EXITS("cmfe_InterfaceCondition_EquationsCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of interface equations for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_EquationsCreateFinishObj(interfaceCondition,err)
    !DLLEXPORT(cmfe_InterfaceCondition_EquationsCreateFinishObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_EquationsCreateFinishObj",err,error,*999)

    CALL InterfaceCondition_EquationsCreateFinish(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_EquationsCreateFinishObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_EquationsCreateFinishObj",err,error)
    EXITS("cmfe_InterfaceCondition_EquationsCreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of interface equations for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_EquationsCreateStartNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceCondition_EquationsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_EquationsCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_EquationsCreateStart(interfaceCondition,interfaceEquations,err,error,*999)

    EXITS("cmfe_InterfaceCondition_EquationsCreateStartNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_EquationsCreateStartNumber",err,error)
    EXITS("cmfe_InterfaceCondition_EquationsCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of interface equations for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_EquationsCreateStartObj(interfaceCondition,interfaceEquations,err)
    !DLLEXPORT(cmfe_InterfaceCondition_EquationsCreateStartObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of interface equations for
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<On return, the created interface equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_EquationsCreateStartObj",err,error,*999)

    CALL InterfaceCondition_EquationsCreateStart(interfaceCondition%interfaceCondition,interfaceEquations% &
      & interfaceEquations,err,error,*999)

    EXITS("cmfe_InterfaceCondition_EquationsCreateStartObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_EquationsCreateStartObj",err,error)
    EXITS("cmfe_InterfaceCondition_EquationsCreateStartObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys interface equations for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_EquationsDestroyNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceCondition_EquationsDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_EquationsDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_EquationsDestroy(interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_EquationsDestroyNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_EquationsDestroyNumber",err,error)
    EXITS("cmfe_InterfaceCondition_EquationsDestroyNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the interface equations for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_EquationsDestroyObj(interfaceCondition,err)
    !DLLEXPORT(cmfe_InterfaceCondition_EquationsDestroyObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_EquationsDestroyObj",err,error,*999)

    CALL InterfaceCondition_EquationsDestroy(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_EquationsDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_EquationsDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the integration type for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionIntegrationType,err)
    !DLLEXPORT(cmfe_InterfaceCondition_IntegrationTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_IntegrationTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_IntegrationTypeGet(interfaceCondition,interfaceConditionIntegrationType,err,error,*999)

    EXITS("cmfe_InterfaceCondition_IntegrationTypeGetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_IntegrationTypeGetNumber",err,error)
    EXITS("cmfe_InterfaceCondition_IntegrationTypeGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the integration type for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeGetObj(interfaceCondition,interfaceConditionIntegrationType,err)
    !DLLEXPORT(cmfe_InterfaceCondition_IntegrationTypeGetObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_IntegrationTypeGetObj",err,error,*999)

    CALL InterfaceCondition_IntegrationTypeGet(interfaceCondition%interfaceCondition,interfaceConditionIntegrationType, &
      & err,error,*999)

    EXITS("cmfe_InterfaceCondition_IntegrationTypeGetObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_IntegrationTypeGetObj",err,error)
    EXITS("cmfe_InterfaceCondition_IntegrationTypeGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the integration type for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionIntegrationType,err)
    !DLLEXPORT(cmfe_InterfaceCondition_IntegrationTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_IntegrationTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_IntegrationTypeSet(interfaceCondition,interfaceConditionIntegrationType,err,error,*999)

    EXITS("cmfe_InterfaceCondition_IntegrationTypeSetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_IntegrationTypeSetNumber",err,error)
    EXITS("cmfe_InterfaceCondition_IntegrationTypeSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the integration type for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeSetObj(interfaceCondition,interfaceConditionIntegrationType,err)
    !DLLEXPORT(cmfe_InterfaceCondition_IntegrationTypeSetObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_IntegrationTypeSetObj",err,error,*999)

    CALL InterfaceCondition_IntegrationTypeSet(interfaceCondition%interfaceCondition,interfaceConditionIntegrationType, &
      & err,error,*999)

    EXITS("cmfe_InterfaceCondition_IntegrationTypeSetObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_IntegrationTypeSetObj",err,error)
    EXITS("cmfe_InterfaceCondition_IntegrationTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a Lagrange Multiplier Field for an interface condition identified by an user number.
  SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to finish the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LagrangeFieldCreateFinish(interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber",err,error)
    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a Lagrange multiplier field for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj(interfaceCondition,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj",err,error,*999)

    CALL InterfaceCondition_LagrangeFieldCreateFinish(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj",err,error)
    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a Lagrange multiplier field for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,lagrangeFieldUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: lagrangeFieldUserNumber !<The user number of the Lagrange field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: lagrangeField
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(lagrangeField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LagrangeFieldCreateStart(interfaceCondition,lagrangeFieldUserNumber,lagrangeField, &
      & err,error,*999)

    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber",err,error)
    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a Lagrange multiplier field for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateStartObj(interfaceCondition,lagrangeFieldUserNumber,lagrangeField,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LagrangeFieldCreateStartObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: lagrangeFieldUserNumber !<The user number of the Lagrange field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: lagrangeField !<If associated on entry, the user created Lagrange field which has the same user number as the specified Lagrange field user number. If not associated on entry, on return, the created Lagrange field for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_LagrangeFieldCreateStartObj",err,error,*999)

    CALL InterfaceCondition_LagrangeFieldCreateStart(interfaceCondition%interfaceCondition,lagrangeFieldUserNumber, &
      & lagrangeField%field,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateStartObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_LagrangeFieldCreateStartObj",err,error)
    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateStartObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_LabelGetCNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,label,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the interface condition label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LabelGet(interfaceCondition,label,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_LabelGetCObj(interfaceCondition,label,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LabelGetCObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the interface condition label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_LabelGetCObj",err,error,*999)

    CALL InterfaceCondition_LabelGet(interfaceCondition%interfaceCondition,label,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_LabelGetVSNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,label,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface condition to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the interface condition label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LabelGet(interfaceCondition,label,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_LabelGetVSObj(interfaceCondition,label,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LabelGetVSObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the interface condition label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_LabelGetVSObj",err,error,*999)

    CALL InterfaceCondition_LabelGet(interfaceCondition%interfaceCondition,label,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_LabelSetCNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,label,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface condition label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LabelSet(interfaceCondition,label,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_LabelSetCObj(interfaceCondition,label,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LabelSetCObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface condition label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_LabelSetCObj",err,error,*999)

    CALL InterfaceCondition_LabelSet(interfaceCondition%interfaceCondition,label,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_LabelSetVSNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,label,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface condition label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LabelSet(interfaceCondition,label,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_LabelSetVSObj(interfaceCondition,label,err)
    !DLLEXPORT(cmfe_InterfaceCondition_LabelSetVSObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface condition label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_LabelSetVSObj",err,error,*999)

    CALL InterfaceCondition_LabelSet(interfaceCondition%interfaceCondition,label,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Gets the output type an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_OutputTypeGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,outputType,err)
    !DLLEXPORT(cmfe_InterfaceCondition_OutputTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to get the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the interface condition \see OpenCMISS_InterfaceConditionOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_OutputTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_OutputTypeGet(interfaceCondition,outputType,err,error,*999)

    EXITS("cmfe_InterfaceCondition_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OutputTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_OutputTypeGetObj(interfaceCondition,outputType,err)
    !DLLEXPORT(cmfe_InterfaceCondition_OutputTypeGetObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the interface condition \see OpenCMISS_InterfaceConditionOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_OutputTypeGetObj",err,error,*999)

    CALL InterfaceCondition_OutputTypeGet(interfaceCondition%interfaceCondition,outputType,err,error,*999)

    EXITS("cmfe_InterfaceCondition_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OutputTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_OutputTypeSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,outputType,err)
    !DLLEXPORT(cmfe_InterfaceCondition_OutputTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the interface to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the interface condition to set \see OpenCMISS_InterfaceConditionOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_OutputTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_OutputTypeSet(interfaceCondition,outputType,err,error,*999)

    EXITS("cmfe_InterfaceCondition_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OutputTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_OutputTypeSetObj(interfaceCondition,outputType,err)
    !DLLEXPORT(cmfe_InterfaceCondition_OutputTypeSetObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(INOUT) :: interfaceCondition !<The interface condition to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the interface condition to set \see OpenCMISS_InterfaceConditionOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_OutputTypeSetObj",err,error,*999)

    CALL InterfaceCondition_OutputTypeSet(interfaceCondition%interfaceCondition,outputType,err,error,*999)

    EXITS("cmfe_InterfaceCondition_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OutputTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a penalty Field for an interface condition identified by an user number.
  SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to finish the penalty field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the penalty  field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the penalty field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_PenaltyFieldCreateFinish(interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber",err,error)
    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a penalty field for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj(interfaceCondition,err)
    !DLLEXPORT(cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the penalty field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj",err,error,*999)

    CALL InterfaceCondition_PenaltyFieldCreateFinish(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj",err,error)
    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a penalty field for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,penaltyFieldUserNumber,err)
    !DLLEXPORT(cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: penaltyFieldUserNumber !<The user number of the penalty field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: penaltyField
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(penaltyField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_PenaltyFieldCreateStart(interfaceCondition,penaltyFieldUserNumber,penaltyField, &
      & Err,error,*999)

    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber",err,error)
    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a penalty field for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateStartObj(interfaceCondition,penaltyFieldUserNumber,penaltyField,err)
    !DLLEXPORT(cmfe_InterfaceCondition_PenaltyFieldCreateStartObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: penaltyFieldUserNumber !<The user number of the penalty field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: penaltyField !<If associated on entry, the user created penalty field which has the same user number as the specified penalty field user number. If not associated on entry, on return, the created penalty field for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_PenaltyFieldCreateStartObj",err,error,*999)

    CALL InterfaceCondition_PenaltyFieldCreateStart(interfaceCondition%interfaceCondition,penaltyFieldUserNumber, &
      & penaltyField%field,err,error,*999)

    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateStartObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_PenaltyFieldCreateStartObj",err,error)
    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateStartObj")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the method for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_MethodGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionMethod,err)
    !DLLEXPORT(cmfe_InterfaceCondition_MethodGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionMethod !<On return, the interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_MethodGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_MethodGet(interfaceCondition,interfaceConditionMethod,err,error,*999)

    EXITS("cmfe_InterfaceCondition_MethodGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_MethodGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_MethodGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the method for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_MethodGetObj(interfaceCondition,interfaceConditionMethod,err)
    !DLLEXPORT(cmfe_InterfaceCondition_MethodGetObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionMethod !<On return, the interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_MethodGetObj",err,error,*999)

    CALL InterfaceCondition_MethodGet(interfaceCondition%interfaceCondition,interfaceConditionMethod,err,error,*999)

    EXITS("cmfe_InterfaceCondition_MethodGetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_MethodGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_MethodGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the method for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_MethodSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionMethod,err)
    !DLLEXPORT(cmfe_InterfaceCondition_MethodSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionMethod !<The interface condition method to set. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_MethodSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_MethodSet(interfaceCondition,interfaceConditionMethod,err,error,*999)

    EXITS("cmfe_InterfaceCondition_MethodSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_MethodSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_MethodSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the method for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_MethodSetObj(interfaceCondition,interfaceConditionMethod,err)
    !DLLEXPORT(cmfe_InterfaceCondition_MethodSetObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionMethod !<The interface condition method to set. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_MethodSetObj",err,error,*999)

    CALL InterfaceCondition_MethodSet(interfaceCondition%interfaceCondition,interfaceConditionMethod,err,error,*999)

    EXITS("cmfe_InterfaceCondition_MethodSetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_MethodSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_MethodSetObj

  !
  !================================================================================================================================
  !

  !>Returns the operator for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_OperatorGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionOperator,err)
    !DLLEXPORT(cmfe_InterfaceCondition_OperatorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the operator for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionOperator !<On return, the interface condition operator. \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_OperatorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_OperatorGet(interfaceCondition,interfaceConditionOperator,err,error,*999)

    EXITS("cmfe_InterfaceCondition_OperatorGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OperatorGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OperatorGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the operator for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_OperatorGetObj(interfaceCondition,interfaceConditionOperator,err)
    !DLLEXPORT(cmfe_InterfaceCondition_OperatorGetObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the operator for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionOperator !<On return, the interface condition operator. \see OpenCMISS_InterfaceConditionOperator,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_OperatorGetObj",err,error,*999)

    CALL InterfaceCondition_OperatorGet(interfaceCondition%interfaceCondition,interfaceConditionOperator,err,error,*999)

    EXITS("cmfe_InterfaceCondition_OperatorGetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OperatorGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OperatorGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the operator for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_OperatorSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionOperator,err)
    !DLLEXPORT(cmfe_InterfaceCondition_OperatorSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionOperator !<The interface condition operator to set. \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceCondition_OperatorSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_OperatorSet(interfaceCondition,interfaceConditionOperator,err,error,*999)

    EXITS("cmfe_InterfaceCondition_OperatorSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OperatorSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OperatorSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the operator for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_OperatorSetObj(interfaceCondition,interfaceConditionOperator,err)
    !DLLEXPORT(cmfe_InterfaceCondition_OperatorSetObj)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionOperator !<The interface condition operator to set. \see OpenCMISS_InterfaceConditionOperator,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_OperatorSetObj",err,error,*999)

    CALL InterfaceCondition_OperatorSet(interfaceCondition%interfaceCondition,interfaceConditionOperator,err,error,*999)

    EXITS("cmfe_InterfaceCondition_OperatorSetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OperatorSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OperatorSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_LinearityTypeGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,linearityType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_LinearityTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the linearity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the ouput type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the interface equations linearity type. \see OpenCMISS_InterfaceEquationsLinearityType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceEquations_LinearityTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_LinearityTypeGet(interfaceEquations,linearityType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_LinearityTypeGetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceEquations_LinearityTypeGetNumber",err,error)
    EXITS("cmfe_InterfaceEquations_LinearityTypeGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_LinearityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_LinearityTypeGetObj(interfaceEquations,linearityType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_LinearityTypeGetObj)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the interface equations linearity type. \see OpenCMISS_InterfaceEquationsLinearityType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_LinearityTypeGetObj",err,error,*999)

    CALL InterfaceEquations_LinearityTypeGet(interfaceEquations%interfaceEquations,linearityType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_LinearityTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_LinearityTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_LinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Returns the matrix time dependence type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,timeDependenceType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the matrix time dependence type for type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to get the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the interface matrix time dependence type. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: timeDependenceTypes(1)

    ENTERS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0",err,error,*999)

    CALL cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1(contextUserNumber,regionUserNumber,interfaceUserNumber, &
      & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,timeDependenceTypes,err)
    timeDependenceType=timeDependenceTypes(1)

    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0")
    RETURN
999 ERRORS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0",err,error)
    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0
  !
  !================================================================================================================================
  !

  !>Returns the matrix time dependence type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,timeDependenceTypes,err)
    !DLLEXPORT(cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the matrix time dependence type for type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to get the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceTypes(:) !<timeDependenceTypes(transposeIdx). On return, the interface matrix time dependence type. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_MatrixTimeDependenceTypeGet(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & timeDependenceTypes,err,error,*999)

    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1")
    RETURN
999 ERRORS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1",err,error)
    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the matrix time dependence type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj0(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
    & timeDependenceType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj0)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to get the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the interface matrix time dependence type. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: timeDependenceTypes(1)

    ENTERS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj0",err,error,*999)

    CALL cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj1(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & timeDependenceTypes,err)
    timeDependenceType=timeDependenceTypes(1)

    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj0")
    RETURN
999 ERRORS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj0",err,error)
    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj0

  !
  !================================================================================================================================
  !

  !>Gets the matrix time dependence type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj1(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
    & timeDependenceTypes,err)
    !DLLEXPORT(cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj1)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to get the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceTypes(:) !<timeDependenceTypes(transposeIdx). On return, the interface matrix time dependence type. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj1",err,error,*999)

    CALL InterfaceEquations_MatrixTimeDependenceTypeGet(interfaceEquations%interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & timeDependenceTypes,err,error,*999)

    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj1")
    RETURN
999 ERRORS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj1",err,error)
    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeGetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the matrix time dependence type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,timeDependenceType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the matrix time dependence type for type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to set the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(IN) :: timeDependenceType !<The interface matrix time dependence type to set. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0",err,error,*999)

    CALL cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1(contextUserNumber,regionUserNumber,interfaceUserNumber, &
      & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,[timeDependenceType],err)

    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0",err,error)
    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0
  !
  !================================================================================================================================
  !

  !>Sets/changes the matrix time dependence type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,timeDependenceTypes,err)
    !DLLEXPORT(cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the matrix time dependence type for type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to set the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(IN) :: timeDependenceTypes(:) !<timeDependenceTypes(transposeIdx). The interface matrix time dependence type to set. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_MatrixTimeDependenceTypeSet(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & timeDependenceTypes,err,error,*999)

    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1",err,error)
    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the matrix time dependence type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj0(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
    & timeDependenceType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj0)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to set the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(IN) :: timeDependenceType !<The interface matrix time dependence type to set. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj0",err,error,*999)

    CALL cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj1(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & [timeDependenceType],err)

    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj0")
    RETURN
999 ERRORS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj0",err,error)
    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj0

  !
  !================================================================================================================================
  !

  !>Sets/changes the matrix time dependence type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj1(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
    & timeDependenceTypes,err)
    !DLLEXPORT(cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj1)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to set the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(IN) :: timeDependenceTypes(:) !<timeDependenceTypes(transposeIdx). The interface matrix time dependence type to set. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj1",err,error,*999)

    CALL InterfaceEquations_MatrixTimeDependenceTypeSet(interfaceEquations%interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & timeDependenceTypes,err,error,*999)

    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj1")
    RETURN
999 ERRORS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj1",err,error)
    EXITS("cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_MatrixTimeDependenceTypeSetObj1

  !
  !================================================================================================================================
  !

  !>Returns the output type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_OutputTypeGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,outputType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_OutputTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the ouput type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the interface equations output type. \see OpenCMISS_InterfaceEquationsOutputType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceEquations_OutputTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_OutputTypeGet(interfaceEquations,outputType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_OutputTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_OutputTypeGetObj(interfaceEquations,outputType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_OutputTypeGetObj)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the interface equations output type. \see OpenCMISS_EquationsOutputType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_OutputTypeGetObj",err,error,*999)

    CALL InterfaceEquations_OutputTypeGet(interfaceEquations%interfaceEquations,outputType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_OutputTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_OutputTypeSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,outputType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_OutputTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The interface equations output type to set. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceEquations_OutputTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_OutputTypeSet(interfaceEquations,outputType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_OutputTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_OutputTypeSetObj(interfaceEquations,outputType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_OutputTypeSetObj)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The interface equations output type to set. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_OutputTypeSetObj",err,error,*999)

    CALL InterfaceEquations_OutputTypeSet(interfaceEquations%interfaceEquations,outputType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_OutputTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the sparsity type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_SparsityGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,sparsityType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_SparsityGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the interface equations sparsity type. \see OpenCMISS_EquationsSparsityType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceEquations_SparsityGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_SparsityTypeGet(interfaceEquations,sparsityType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_SparsityGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_SparsityGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_SparsityGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_SparsityGetObj(interfaceEquations,sparsityType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_SparsityGetObj)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the interface equations sparsity type. \see OpenCMISS_EquationsSparsityType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_SparsityGetObj",err,error,*999)

    CALL InterfaceEquations_SparsityTypeGet(interfaceEquations%interfaceEquations,sparsityType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_SparsityGetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_SparsityGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_SparsityGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_SparsitySetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,sparsityType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_SparsitySetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The interface equations sparsity type to set. \see OpenCMISS_EquationsSparsityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceEquations_SparsitySetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_SparsityTypeSet(interfaceEquations,sparsityType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_SparsitySetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_SparsitySetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_SparsitySetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_SparsitySetObj(interfaceEquations,sparsityType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_SparsitySetObj)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The interface equations sparsity type to set. \see OpenCMISS_EquationsSparsityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_SparsitySetObj",err,error,*999)

    CALL InterfaceEquations_SparsityTypeSet(interfaceEquations%interfaceEquations,sparsityType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_SparsitySetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_SparsitySetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_SparsitySetObj

  !
  !================================================================================================================================
  !

  !>Returns the time dependence type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_TimeDependenceTypeGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,timeDependenceType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_TimeDependenceTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the interface equations time dependence type. \see OpenCMISS_InterfaceEquationsTimeDependenceType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_InterfaceEquations_TimeDependenceTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_TimeDependenceTypeGet(interfaceEquations,timeDependenceType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_TimeDependenceTypeGetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceEquations_TimeDependenceTypeGetNumber",err,error)
    EXITS("cmfe_InterfaceEquations_TimeDependenceTypeGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_TimeDependenceTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_TimeDependenceTypeGetObj(interfaceEquations,timeDependenceType,err)
    !DLLEXPORT(cmfe_InterfaceEquations_TimeDependenceTypeGetObj)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the interface equations time dependence type. \see OpenCMISS_InterfaceEquationsTimeDependenceType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_TimeDependenceTypeGetObj",err,error,*999)

    CALL InterfaceEquations_TimeDependenceTypeGet(interfaceEquations%interfaceEquations,timeDependenceType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_TimeDependenceTypeGetObj")
    RETURN
999 ERRORS("cmfe_InterfaceEquations_TimeDependenceTypeGetObj",err,error)
    EXITS("cmfe_InterfaceEquations_TimeDependenceTypeGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_TimeDependenceTypeGetObj

!!=================================================================================================================================
!!
!! DecompositionRoutines
!!
!!=================================================================================================================================

  !>Finishes the creation of a decomposer identified by a user number.
  SUBROUTINE cmfe_Decomposer_CreateFinishNumber(contextUserNumber,regionUserNumber,decomposerUserNumber,err)
    !DLLEXPORT(cmfe_Decomposer_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposer.
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposer_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(decomposer)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DecomposerGet(region,decomposerUserNumber,decomposer,err,error,*999)
    CALL Decomposer_CreateFinish(decomposer,err,error,*999)

    EXITS("cmfe_Decomposer_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a decomposer identified by an object.
  SUBROUTINE cmfe_Decomposer_CreateFinishObj(decomposer,err)
    !DLLEXPORT(cmfe_Decomposer_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_DecomposerType), INTENT(IN) :: decomposer !<The decomposer to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposer_CreateFinishObj",err,error,*999)

    CALL Decomposer_CreateFinish(decomposer%decomposer,err,error,*999)

    EXITS("cmfe_Decomposer_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a decomposer identified by a user number.
  SUBROUTINE cmfe_Decomposer_CreateStartNumber(decomposerUserNumber,contextUserNumber,regionUserNumber,workGroupUserNumber,err)
    !DLLEXPORT(cmfe_Decomposer_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to create.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to create the decomposer for.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to create the decomposer with.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(WorkGroupType), POINTER :: workGroup

    ENTERS("cmfe_Decomposer_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(workGroup)
    NULLIFY(decomposer)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL Decomposer_CreateStart(decomposerUserNumber,region,workGroup,decomposer,err,error,*999)

    EXITS("cmfe_Decomposer_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a decomposer identified by an object.
  SUBROUTINE cmfe_Decomposer_CreateStartObj(decomposerUserNumber,region,workGroup,decomposer,err)
    !DLLEXPORT(cmfe_Decomposer_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to create.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to create the decomposer for.
    TYPE(cmfe_WorkGroupType), INTENT(IN) :: workGroup !<The work group to create the decomposer with.
    TYPE(cmfe_DecomposerType), INTENT(INOUT) :: decomposer !<On return, the created decomposer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposer_CreateStartObj",err,error,*999)

    CALL Decomposer_CreateStart(decomposERUserNumber,region%region,workGroup%workGroup,decomposer%decomposer,err,error,*999)

    EXITS("cmfe_Decomposer_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Adds a decomposition to a decomposer identified by a user number.
  SUBROUTINE cmfe_Decomposer_DecompositionAddNumber(contextUserNumber,regionUserNumber,decomposerUserNumber,meshUserNumber, &
    & decompositionUserNumber,decompositionIndex,err)
    !DLLEXPORT(cmfe_Decomposer_DecompositionAddNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposer.
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to add the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh of the decomposition to add to the decomposer.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to add to the decomposer.
    INTEGER(INTG), INTENT(OUT) :: decompositionIndex !<On return, the index of the added decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposer_DecompositionAddNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(decomposer)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DecomposerGet(region,decomposerUserNumber,decomposer,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposer_DecompositionAdd(decomposer,decomposition,decompositionIndex,err,error,*999)

    EXITS("cmfe_Decomposer_DecompositionAddNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_DecompositionAddNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_DecompositionAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a decomposition to a decomposer identified by an object.
  SUBROUTINE cmfe_Decomposer_DecompositionAddObj(decomposer,decomposition,decompositionIndex,err)
    !DLLEXPORT(cmfe_Decomposer_DecompositionAddObj)

    !Argument variables
    TYPE(cmfe_DecomposerType), INTENT(IN) :: decomposer !<The decomposer to add the decomposition to.
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to add to the decomposer
    INTEGER(INTG), INTENT(OUT) :: decompositionIndex !<On return, the index of the added decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposer_DecompositionAddObj",err,error,*999)

    CALL Decomposer_DecompositionAdd(decomposer%decomposer,decomposition%decomposition,decompositionIndex,err,error,*999)

    EXITS("cmfe_Decomposer_DecompositionAddObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_DecompositionAddObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_DecompositionAddObj

  !
  !================================================================================================================================
  !

  !>Destroys a decomposer identified by a user number.
  SUBROUTINE cmfe_Decomposer_DestroyNumber(contextUserNumber,regionUserNumber,decomposerUserNumber,err)
    !DLLEXPORT(cmfe_Decomposer_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposer.
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposer_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(decomposer)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DecomposerGet(region,decomposerUserNumber,decomposer,err,error,*999)
    CALL Decomposer_Destroy(decomposer,err,error,*999)

    EXITS("cmfe_Decomposer_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a decomposer identified by an object.
  SUBROUTINE cmfe_Decomposer_DestroyObj(decomposer,err)
    !DLLEXPORT(cmfe_Decomposer_DestroyObj)

    !Argument variables
    TYPE(cmfe_DecomposerType), INTENT(IN) :: decomposer !<The decomposer to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposer_DestroyObj",err,error,*999)

    CALL Decomposer_Destroy(decomposer%decomposer,err,error,*999)

    EXITS("cmfe_Decomposer_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the output type for a decomposer identified by a user number.
  SUBROUTINE cmfe_Decomposer_OutputTypeGetNumber(contextUserNumber,regionUserNumber,decomposerUserNumber,outputType,err)
    !DLLEXPORT(cmfe_Decomposer_OutputTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposer.
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the specified decomposer \see OpenCMISS_DecomposerOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposer_OutputTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(decomposer)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DecomposerGet(region,decomposerUserNumber,decomposer,err,error,*999)
    CALL Decomposer_OutputTypeGet(decomposer,outputType,err,error,*999)

    EXITS("cmfe_Decomposer_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_OutputTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the output type for a decomposer identified by an object.
  SUBROUTINE cmfe_Decomposer_OutputTypeGetObj(decomposer,outputType,err)
    !DLLEXPORT(cmfe_Decomposer_OutputTypeGetObj)

    !Argument variables
    TYPE(cmfe_DecomposerType), INTENT(IN) :: decomposer !<The decomposer to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the specified decomposer \see OpenCMISS_DecomposerOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposer_OutputTypeGetObj",err,error,*999)

    CALL Decomposer_OutputTypeGet(decomposer%decomposer,outputTYpe,err,error,*999)

    EXITS("cmfe_Decomposer_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_OutputTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for a decomposer identified by a user number.
  SUBROUTINE cmfe_Decomposer_OutputTypeSetNumber(contextUserNumber,regionUserNumber,decomposerUserNumber,outputType,err)
    !DLLEXPORT(cmfe_Decomposer_OutputTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposer.
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !The output type to set \see OpenCMISS_DecomposerOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposer_OutputTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(decomposer)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DecomposerGet(region,decomposerUserNumber,decomposer,err,error,*999)
    CALL Decomposer_OutputTypeSet(decomposer,outputType,err,error,*999)

    EXITS("cmfe_Decomposer_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_OutputTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for a decomposer identified by an object.
  SUBROUTINE cmfe_Decomposer_OutputTypeSetObj(decomposer,outputType,err)
    !DLLEXPORT(cmfe_Decomposer_OutputTypeSetObj)

    !Argument variables
    TYPE(cmfe_DecomposerType), INTENT(IN) :: decomposer !<The decomposer to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !The output type to set \see OpenCMISS_DecomposerOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposer_OutputTypeSetObj",err,error,*999)

    CALL Decomposer_OutputTypeSet(decomposer%decomposer,outputTYpe,err,error,*999)

    EXITS("cmfe_Decomposer_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposer_OutputTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposer_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_CreateFinishNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber,err)
    !DLLEXPORT(cmfe_Decomposition_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposition_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_CreateFinish(decomposition,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Decomposition Create')
#endif

    EXITS("cmfe_Decomposition_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_CreateFinishObj(decomposition,err)
    !DLLEXPORT(cmfe_Decomposition_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_CreateFinishObj",err,error,*999)

    CALL Decomposition_CreateFinish(decomposition%decomposition,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('decomposition Create')
#endif

    EXITS("cmfe_Decomposition_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CreateFinishObj

  !
  !================================================================================================================================
  !

  !> Calculates the decomposition  for data points
  SUBROUTINE cmfe_Decomposition_DataProjectionCalculateObj(decomposition,err)
    !DLLEXPORT(cmfe_Decomposition_DataProjectionCalculateObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_DataProjectionCalculateObj",err,error,*999)

    CALL Decomposition_DataProjectionCalculate(decomposition%decomposition,err,error,*999)

    EXITS("cmfe_Decomposition_DataProjectionCalculateObj")
    RETURN
999 ERRORS("cmfe_Decomposition_DataProjectionCalculateObj",err,error)
    EXITS("cmfe_Decomposition_DataProjectionCalculateObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_DataProjectionCalculateObj

  !
  !================================================================================================================================
  !

  !>Gets the local data point number for data points projected on an element
  SUBROUTINE cmfe_Decomposition_ElementDataPointLocalNumberGetObj(decomposition,elementUserNumber,dataPointIndex, &
       & dataPointLocalNumber,err)
    !DLLEXPORT(cmfe_Decomposition_ElementDataPointLocalNumberGetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The data point index to get the number for
    INTEGER(INTG), INTENT(OUT) :: dataPointLocalNumber !<The data point local number to retu
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_ElementDataPointLocalNumberGetObj",err,error,*999)

    CALL Decomposition_ElementDataPointLocalNumberGet(decomposition%decomposition,elementUserNumber, &
      & dataPointIndex,dataPointLocalNumber,err,error,*999)

    EXITS("cmfe_Decomposition_ElementDataPointLocalNumberGetObj")
    RETURN
999 ERRORS("cmfe_Decomposition_ElementDataPointLocalNumberGetObj",err,error)
    EXITS("cmfe_Decomposition_ElementDataPointLocalNumberGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDataPointLocalNumberGetObj

  !
  !================================================================================================================================
  !

  !>Gets the user data point number for data points projected on an element
  SUBROUTINE cmfe_Decomposition_ElementDataPointUserNumberGetObj(decomposition,elementUserNumber,dataPointIndex, &
       & dataPointUserNumber,err)
    !DLLEXPORT(cmfe_Decomposition_ElementDataPointUserNumberGetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The data point index to get the number for
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<The data point user number to retu
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_ElementDataPointUserNumberGetObj",err,error,*999)

    CALL Decomposition_ElementDataPointUserNumberGet(decomposition%decomposition,elementUserNumber, &
     & dataPointIndex,dataPointUserNumber,err,error,*999)

    EXITS("cmfe_Decomposition_ElementDataPointUserNumberGetObj")
    RETURN
999 ERRORS("cmfe_Decomposition_ElementDataPointUserNumberGetObj",err,error)
    EXITS("cmfe_Decomposition_ElementDataPointUserNumberGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDataPointUserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Gets the number of data points projected on an element
  SUBROUTINE cmfe_Decomposition_NumberOfElementDataPointsGetObj(decomposition,elementUserNumber,numberOfDataPoints,err)
    !DLLEXPORT(cmfe_Decomposition_NumberOfElementDataPointsGetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<The data point local number to return
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_NumberOfElementDataPointsGetObj",err,error,*999)

    CALL Decomposition_NumberOfElementDataPointsGet(decomposition%decomposition,elementUserNumber, &
      & numberOfDataPoints,err,error,*999)

    EXITS("cmfe_Decomposition_NumberOfElementDataPointsGetObj")
    RETURN
999 ERRORS("cmfe_Decomposition_NumberOfElementDataPointsGetObj",err,error)
    EXITS("cmfe_Decomposition_NumberOfElementDataPointsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_NumberOfElementDataPointsGetObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_CreateStartNumber(decompositionUserNumber,contextUserNumber,regionUserNumber,meshUserNumber,err)
    !DLLEXPORT(cmfe_Decomposition_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to create.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposition_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Decomposition Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Decomposition_CreateStart(decompositionUserNumber,mesh,decomposition,err,error,*999)

    EXITS("cmfe_Decomposition_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_CreateStartObj(decompositionUserNumber,mesh,decomposition,err)
    !DLLEXPORT(cmfe_Decomposition_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to create.
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to create the decomposition for.
    TYPE(cmfe_DecompositionType), INTENT(INOUT) :: decomposition !<On return, the created decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('decomposition Create')
#endif

    CALL Decomposition_CreateStart(decompositionUserNumber,mesh%mesh,decomposition%decomposition,err,error,*999)

    EXITS("cmfe_Decomposition_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_DestroyNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber,err)
    !DLLEXPORT(cmfe_Decomposition_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposition_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL DECOMPOSITION_DESTROY(decomposition,err,error,*999)

    EXITS("cmfe_Decomposition_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_DestroyObj(decomposition,err)
    !DLLEXPORT(cmfe_Decomposition_DestroyObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_DestroyObj",err,error,*999)

    CALL DECOMPOSITION_DESTROY(decomposition%decomposition,err,error,*999)

    EXITS("cmfe_Decomposition_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_DestroyObj

  !
  !================================================================================================================================
  !

!   !>Calculates the element domains for a decomposition identified by a user number.
!   SUBROUTINE cmfe_Decomposition_ElementDomainCalculateNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
!     & decompositionUserNumber,err)
!     !DLLEXPORT(cmfe_Decomposition_ElementDomainCalculateNumber)

!     !Argument variables
!     INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
!     INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to calculate the element domains for.
!     INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to calculate the element domains for.
!     INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to calculate the element domains for.
!     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
!     !Local variables
!     TYPE(ContextType), POINTER :: context
!     TYPE(DecompositionType), POINTER :: decomposition
!     TYPE(MeshType), POINTER :: mesh
!     TYPE(RegionType), POINTER :: region
!     TYPE(RegionsType), POINTER :: regions

!     ENTERS("cmfe_Decomposition_ElementDomainCalculateNumber",err,error,*999)

!     NULLIFY(context)
!     NULLIFY(regions)
!     NULLIFY(region)
!     NULLIFY(mesh)
!     NULLIFY(decomposition)
!     CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
!     CALL Context_RegionsGet(context,regions,err,error,*999)
!     CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
!     CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
!     CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
!     CALL Decomposition_ElementDomainCalculate(decomposition,err,error,*999)

!     EXITS("cmfe_Decomposition_ElementDomainCalculateNumber")
!     RETURN
! 999 ERRORS("cmfe_Decomposition_ElementDomainCalculateNumber",err,error)
!     EXITS("cmfe_Decomposition_ElementDomainCalculateNumber")
!     CALL cmfe_HandleError(err,error)
!     RETURN

!   END SUBROUTINE cmfe_Decomposition_ElementDomainCalculateNumber

  !
  !================================================================================================================================
  !

!   !>Calculates the element domains for a decomposition identified by an object.
!   SUBROUTINE cmfe_Decomposition_ElementDomainCalculateObj(decomposition,err)
!     !DLLEXPORT(cmfe_Decomposition_ElementDomainCalculateObj)

!     !Argument variables
!     TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to calcualte the element domains for.
!     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
!     !Local variables

!     ENTERS("cmfe_Decomposition_ElementDomainCalculateObj",err,error,*999)

!     CALL Decomposition_ElementDomainCalculate(decomposition%decomposition,err,error,*999)

!     EXITS("cmfe_Decomposition_ElementDomainCalculateObj")
!     RETURN
! 999 ERRORS("cmfe_Decomposition_ElementDomainCalculateObj",err,error)
!     EXITS("cmfe_Decomposition_ElementDomainCalculateObj")
!     CALL cmfe_HandleError(err,error)
!     RETURN

!   END SUBROUTINE cmfe_Decomposition_ElementDomainCalculateObj

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_ElementDomainGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & elementUserNumber,domain,err)
    !DLLEXPORT(cmfe_Decomposition_ElementDomainGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computation domain of the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposition_ElementDomainGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_ElementDomainGet(decomposition,elementUserNumber,domain,err,error,*999)

    EXITS("cmfe_Decomposition_ElementDomainGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_ElementDomainGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given element in a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_ElementDomainGetObj(decomposition,elementUserNumber,domain,err)
    !DLLEXPORT(cmfe_Decomposition_ElementDomainGetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computation domain of the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_ElementDomainGetObj",err,error,*999)

    CALL Decomposition_ElementDomainGet(decomposition%decomposition,elementUserNumber,domain,err,error,*999)

    EXITS("cmfe_Decomposition_ElementDomainGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_ElementDomainGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDomainGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_ElementDomainSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & elementUserNumber,domain,err)
    !DLLEXPORT(cmfe_Decomposition_ElementDomainSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: domain !<The computation domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposition_ElementDomainSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_ElementDomainSet(decomposition,elementUserNumber,domain,err,error,*999)

    EXITS("cmfe_Decomposition_ElementDomainSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_ElementDomainSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDomainSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the domain for a given element in a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_ElementDomainSetObj(decomposition,elementUserNumber,domain,err)
    !DLLEXPORT(cmfe_Decomposition_ElementDomainSetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: domain !<The computation domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_ElementDomainSetObj",err,error,*999)

    CALL Decomposition_ElementDomainSet(decomposition%decomposition,elementUserNumber,domain,err,error,*999)

    EXITS("cmfe_Decomposition_ElementDomainSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_ElementDomainSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDomainSetObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_MeshComponentGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,err)
    !DLLEXPORT(cmfe_Decomposition_MeshComponentGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: meshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_Decomposition_MeshComponentGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_MeshComponentNumberGet(decomposition,meshComponentNumber,err,error,*999)

    EXITS("cmfe_Decomposition_MeshComponentGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_MeshComponentGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_MeshComponentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_MeshComponentGetObj(decomposition,meshComponentNumber,err)
    !DLLEXPORT(cmfe_Decomposition_MeshComponentGetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: meshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_MeshComponentGetObj",err,error,*999)

    CALL Decomposition_MeshComponentNumberGet(decomposition%decomposition,meshComponentNumber,err,error,*999)

    EXITS("cmfe_Decomposition_MeshComponentGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_MeshComponentGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_MeshComponentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_MeshComponentSetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,err)
    !DLLEXPORT(cmfe_Decomposition_MeshComponentSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposition_MeshComponentSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_MeshComponentNumberSet(decomposition,meshComponentNumber,err,error,*999)

    EXITS("cmfe_Decomposition_MeshComponentSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_MeshComponentSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_MeshComponentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_MeshComponentSetObj(decomposition,meshComponentNumber,err)
    !DLLEXPORT(cmfe_Decomposition_MeshComponentSetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to Set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_MeshComponentSetObj",err,error,*999)

    CALL Decomposition_MeshComponentNumberSet(decomposition%decomposition,meshComponentNumber,err,error,*999)

    EXITS("cmfe_Decomposition_MeshComponentSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_MeshComponentSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_MeshComponentSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_TypeGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & domainDecompositionType,err)
    !DLLEXPORT(cmfe_Decomposition_TypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the decomposition type for.
    INTEGER(INTG), INTENT(OUT) :: domainDecompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposition_TypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_TypeGet(decomposition,domainDecompositionType,err,error,*999)

    EXITS("cmfe_Decomposition_TypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_TypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_TypeGetObj(decomposition,domainDecompositionType,err)
    !DLLEXPORT(cmfe_Decomposition_TypeGetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the type for.
    INTEGER(INTG), INTENT(OUT) :: domainDecompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_TypeGetObj",err,error,*999)

    CALL Decomposition_TypeGet(decomposition%decomposition,domainDecompositionType,err,error,*999)

    EXITS("cmfe_Decomposition_TypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_TypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_TypeSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & domainDecompositionType,err)
    !DLLEXPORT(cmfe_Decomposition_TypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: domainDecompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposition_TypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_TypeSet(decomposition,domainDecompositionType,err,error,*999)

    EXITS("cmfe_Decomposition_TypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_TypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_TypeSetObj(decomposition,domainDecompositionType,err)
    !DLLEXPORT(cmfe_Decomposition_TypeSetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to Set the type for.
    INTEGER(INTG), INTENT(IN) :: domainDecompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_TypeSetObj",err,error,*999)

    CALL Decomposition_TypeSet(decomposition%decomposition,domainDecompositionType,err,error,*999)

    EXITS("cmfe_Decomposition_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the work group of a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_WorkGroupSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & workGroupUserNumber,err)
    !DLLEXPORT(cmfe_Decomposition_WorkGroupSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition work group for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the work group for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the work group for.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(WorkGroupType), POINTER :: workGroup

    ENTERS("cmfe_Decomposition_WorkGroupSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(computationEnvironment)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL Decomposition_WorkGroupSet(decomposition,workGroup,err,error,*999)
    
    EXITS("cmfe_Decomposition_WorkGroupSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_WorkGroupSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_WorkGroupSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the work group for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_WorkGroupSetObj(decomposition,workGroup,err)
    !DLLEXPORT(cmfe_Decomposition_WorkGroupSetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the work group for.
    TYPE(cmfe_WorkGroupType), INTENT(IN) :: workGroup !<The work group to set for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_WorkGroupSetObj",err,error,*999)

    CALL Decomposition_WorkGroupSet(decomposition%decomposition,workGroup%workGroup,err,error,*999)

    EXITS("cmfe_Decomposition_WorkGroupSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_WorkGroupSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_WorkGroupSetObj

  !
  !================================================================================================================================
  !

  !>Sets whether lines should be calculated
  SUBROUTINE cmfe_Decomposition_CalculateLinesSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,&
    & decompositionUserNumber,calculateLinesFlag,err)
    !DLLEXPORT(cmfe_Decomposition_CalculateLinesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the calculate lines flag for.
    LOGICAL, INTENT(IN) :: calculateLinesFlag !<Boolean to determine whether to set lines to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposition_CalculateLinesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_CalculateLinesSet(decomposition,calculateLinesFlag,err,error,*999)

    EXITS("cmfe_Decomposition_CalculateLinesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CalculateLinesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CalculateLinesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets whether lines should be calculated
  SUBROUTINE cmfe_Decomposition_CalculateLinesSetObj(decomposition,calculateLinesFlag,err)
    !DLLEXPORT(cmfe_Decomposition_CalculateLinesSetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the calculate lines flag for.
    LOGICAL, INTENT(IN) :: calculateLinesFlag !<Boolean to determine whether to set lines to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_CalculateLinesSetObj",err,error,*999)

    CALL Decomposition_CalculateLinesSet(decomposition%decomposition,calculateLinesFlag,err,error,*999)

    EXITS("cmfe_Decomposition_CalculateLinesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CalculateLinesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CalculateLinesSetObj

  !
  !================================================================================================================================
  !

  !>Sets whether faces should be calculated
  SUBROUTINE cmfe_Decomposition_CalculateFacesSetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,calculateFacesFlag,err)
    !DLLEXPORT(cmfe_Decomposition_CalculateFacesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the decomposition type for.
    LOGICAL, INTENT(IN) :: calculateFacesFlag !<Boolean to determine whether to set faces to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposition_CalculateFacesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_CalculateFacesSet(decomposition,calculateFacesFlag,err,error,*999)

    EXITS("cmfe_Decomposition_CalculateFacesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CalculateFacesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CalculateFacesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets whether faces should be calculated
  SUBROUTINE cmfe_Decomposition_CalculateFacesSetObj(decomposition,calculateFacesFlag,err)
    !DLLEXPORT(cmfe_Decomposition_CalculateFacesSetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the calculate faces flag for.
    LOGICAL, INTENT(IN) :: calculateFacesFlag !<Boolean to determine whether to set faces to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_CalculateFacesSetObj",err,error,*999)

    CALL Decomposition_CalculateFacesSet(decomposition%decomposition,calculateFacesFlag,err,error,*999)

    EXITS("cmfe_Decomposition_CalculateFacesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CalculateFacesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CalculateFacesSetObj

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given node in a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_NodeDomainGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & nodeUserNumber,meshComponentNumber,domain,err)
    !DLLEXPORT(cmfe_Decomposition_NodeDomainGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computation domain of the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Decomposition_NodeDomainGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_NodeDomainGet(decomposition,nodeUserNumber,meshComponentNumber,domain,err,error,*999)

    EXITS("cmfe_Decomposition_NodeDomainGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_NodeDomainGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_NodeDomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given node in a decomposition identified by an object. \todo Maybe swap Node and MeshComponent?
  SUBROUTINE cmfe_Decomposition_NodeDomainGetObj(decomposition,nodeUserNumber,meshComponentNumber,domain,err)
    !DLLEXPORT(cmfe_Decomposition_NodeDomainGetObj)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computation domain of the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_NodeDomainGetObj",err,error,*999)

    CALL Decomposition_NodeDomainGet(decomposition%decomposition,nodeUserNumber,meshComponentNumber,domain,err,error,*999)

    EXITS("cmfe_Decomposition_NodeDomainGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_NodeDomainGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_NodeDomainGetObj


!!==================================================================================================================================
!!
!! MESH_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_CreateFinishNumber(contextUserNumber,regionUserNumber,meshUserNumber,err)
    !DLLEXPORT(cmfe_Mesh_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_CreateFinish(mesh,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Mesh Create')
#endif

    EXITS("cmfe_Mesh_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a mesh for a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_CreateFinishObj(mesh,err)
    !DLLEXPORT(cmfe_Mesh_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_CreateFinishObj",err,error,*999)

    CALL Mesh_CreateFinish(mesh%mesh,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('mesh Create')
#endif

    EXITS("cmfe_Mesh_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_CreateStartNumber(meshUserNumber,contextUserNumber,regionUserNumber,numberOfDimensions,err)
    !DLLEXPORT(cmfe_Mesh_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Mesh Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Mesh_CreateStart(meshUserNumber,region,numberOfDimensions,mesh,err,error,*999)

    EXITS("cmfe_Mesh_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_CreateStartObj(meshUserNumber,region,numberOfDimensions,mesh,err)
    !DLLEXPORT(cmfe_Mesh_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !<On return, the created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('mesh Create')
#endif

    CALL Mesh_CreateStart(meshUserNumber,region%region,numberOfDimensions,mesh%mesh,err,error,*999)

    EXITS("cmfe_Mesh_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_CreateStartInterfaceObj(meshUserNumber,interface,numberOfDimensions,mesh,err)
    !DLLEXPORT(cmfe_Mesh_CreateStartInterfaceObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !<On return, the created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('mesh Create')
#endif

    CALL Mesh_CreateStart(meshUserNumber,interface%interface,numberOfDimensions,mesh%mesh,err,error,*999)

    EXITS("cmfe_Mesh_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_CreateStartInterfaceObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Destroys a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_DestroyNumber(contextUserNumber,regionUserNumber,meshUserNumber,err)
    !DLLEXPORT(cmfe_Mesh_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to destroy.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL MESH_DESTROY(mesh,err,error,*999)

    EXITS("cmfe_Mesh_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_DestroyObj(mesh,err)
    !DLLEXPORT(cmfe_Mesh_DestroyObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_DestroyObj",err,error,*999)

    CALL MESH_DESTROY(mesh%mesh,err,error,*999)

    EXITS("cmfe_Mesh_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of components in a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_NumberOfComponentsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,numberOfComponents,err)
    !DLLEXPORT(cmfe_Mesh_NumberOfComponentsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    
    ENTERS("cmfe_Mesh_NumberOfComponentsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_NumberOfComponentsGet(mesh,numberOfComponents,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfComponentsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfComponentsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfComponentsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of components in a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_NumberOfComponentsGetObj(mesh,numberOfComponents,err)
    !DLLEXPORT(cmfe_Mesh_NumberOfComponentsGetObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_NumberOfComponentsGetObj",err,error,*999)

    CALL Mesh_NumberOfComponentsGet(mesh%mesh,numberOfComponents,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfComponentsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfComponentsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfComponentsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components in a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_NumberOfComponentsSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,numberOfComponents,err)
    !DLLEXPORT(cmfe_Mesh_NumberOfComponentsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_NumberOfComponentsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_NumberOfComponentsSet(mesh,numberOfComponents,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfComponentsSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfComponentsSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfComponentsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components in a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_NumberOfComponentsSetObj(mesh,numberOfComponents,err)
    !DLLEXPORT(cmfe_Mesh_NumberOfComponentsSetObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_NumberOfComponentsSetObj",err,error,*999)

    CALL Mesh_NumberOfComponentsSet(mesh%mesh,numberOfComponents,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfComponentsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfComponentsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfComponentsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the surrounding elements calculate flag.
  SUBROUTINE cmfe_Mesh_SurroundingElementsCalculateSetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & surroundingElementsCalculateFlag,err)
    !DLLEXPORT(cmfe_Mesh_SurroundingElementsCalculateSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the surrounding elements calculate flag for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the surrounding elements calculate flag for.
    LOGICAL, INTENT(IN) :: surroundingElementsCalculateFlag !<Boolean flag to determine whether to calculate surrounding elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_SurroundingElementsCalculateSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_SurroundingElementsCalculateSet(mesh,surroundingElementsCalculateFlag,err,error,*999)

    EXITS("cmfe_Mesh_SurroundingElementsCalculateSetNumber")
    RETURN
999 ERRORS("cmfe_Mesh_SurroundingElementsCalculateSetNumber",err,error)
    EXITS("cmfe_Mesh_SurroundingElementsCalculateSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_SurroundingElementsCalculateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the surrounding elements calculate flag.
  SUBROUTINE cmfe_Mesh_SurroundingElementsCalculateSetObj(mesh,surroundingElementsCalculateFlag,err)
    !DLLEXPORT(cmfe_Mesh_SurroundingElementsCalculateSetObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to set the surrounding elements calculate flag for.
    LOGICAL, INTENT(IN) :: surroundingElementsCalculateFlag !<Boolean flag to determine whether to calculate surrounding elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_SurroundingElementsCalculateSetObj",err,error,*999)

    CALL Mesh_SurroundingElementsCalculateSet(mesh%mesh,surroundingElementsCalculateFlag,err,error,*999)

    EXITS("cmfe_Mesh_SurroundingElementsCalculateSetObj")
    RETURN
999 ERRORS("cmfe_Mesh_SurroundingElementsCalculateSetObj",err,error)
    EXITS("cmfe_Mesh_SurroundingElementsCalculateSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_SurroundingElementsCalculateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of elements in a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_NumberOfElementsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,numberOfElements,err)
    !DLLEXPORT(cmfe_Mesh_NumberOfElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_NumberOfElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_NumberOfElementsGet(mesh,numberOfElements,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfElementsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfElementsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of elements in a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_NumberOfElementsGetObj(mesh,numberOfElements,err)
    !DLLEXPORT(cmfe_Mesh_NumberOfElementsGetObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_NumberOfElementsGetObj",err,error,*999)

    CALL Mesh_NumberOfElementsGet(mesh%mesh,numberOfElements,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfElementsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfElementsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements in a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_NumberOfElementsSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,numberOfElements,err)
    !DLLEXPORT(cmfe_Mesh_NumberOfElementsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_NumberOfElementsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_NumberOfElementsSet(mesh,numberOfElements,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfElementsSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfElementsSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements in a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_NumberOfElementsSetObj(mesh,numberOfElements,err)
    !DLLEXPORT(cmfe_Mesh_NumberOfElementsSetObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_NumberOfElementsSetObj",err,error,*999)

    CALL Mesh_NumberOfElementsSet(mesh%mesh,numberOfElements,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfElementsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfElementsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfElementsSetObj

  !
  !================================================================================================================================
  !

  !>Calculate mesh data points topology in a region identified by a user number based on projection
  SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
      & dataProjection,err)
    !DLLEXPORT(cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL MeshTopology_DataPointsCalculateProjection(mesh,dataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber")
    RETURN
999 ERRORS("cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber",err,error)
    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber

  !
  !================================================================================================================================
  !

  !>Calculate mesh data points topology in an interface identified by a user number based on projection
  SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,meshUserNumber,dataProjection,err)
    !DLLEXPORT(cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: parentregionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentregionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_MeshGet(interface,meshUserNumber,mesh,err,error,*999)
    CALL MeshTopology_DataPointsCalculateProjection(mesh,dataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber")
    RETURN
999 ERRORS("cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber",err,error)
    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Calculate mesh data points topology identified by object based on projection
  SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionObj(mesh,dataProjection,err)
    !DLLEXPORT(cmfe_Mesh_TopologyDataPointsCalculateProjectionObj)

  !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to calculate data points topology for
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_TopologyDataPointsCalculateProjectionObj",err,error,*999)

    CALL MeshTopology_DataPointsCalculateProjection(mesh%mesh,dataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionObj")
    RETURN
999 ERRORS("cmfe_Mesh_TopologyDataPointsCalculateProjectionObj",err,error)
    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionObj")
    CALL cmfe_HandleError(Err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionObj

  !
  !================================================================================================================================
  !

  !>Finishes creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE cmfe_MeshElements_CreateFinishNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber,err)
    !DLLEXPORT(cmfe_MeshElements_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    
    ENTERS("cmfe_MeshElements_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_CreateFinish(meshElements,err,error,*999)

    EXITS("cmfe_MeshElements_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_CreateFinishObj(meshElements,err)
    !DLLEXPORT(cmfe_MeshElements_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_CreateFinishObj",err,error,*999)

    CALL MeshElements_CreateFinish(meshElements%meshElements,err,error,*999)

    EXITS("cmfe_MeshElements_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE cmfe_MeshElements_CreateStartNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & basisUserNumber,err)
    !DLLEXPORT(cmfe_MeshElements_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the default basis to use for the elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshElements_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(basisFunctions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(basis)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL MeshElements_CreateStart(mesh,meshComponentNumber,basis,meshElements,err,error,*999)

    EXITS("cmfe_MeshElements_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_CreateStartObj(mesh,meshComponentNumber,basis,meshElements,err)
    !DLLEXPORT(cmfe_MeshElements_CreateStartObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !<The mesh to start the creation of elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The default basis to use for the elements.
    TYPE(cmfe_MeshElementsType), INTENT(INOUT) :: meshElements !<On return, the created mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_CreateStartObj",err,error,*999)

    CALL MeshElements_CreateStart(mesh%mesh,meshComponentNumber,basis%basis,meshElements%meshElements,err,error,*999)

    EXITS("cmfe_MeshElements_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh elements for a mesh component on a mesh identified by an user number.
  SUBROUTINE cmfe_Mesh_ElementsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber,meshElements,err)
    !DLLEXPORT(cmfe_Mesh_ElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the elements for.
    TYPE(cmfe_MeshElementsType), INTENT(INOUT) :: meshElements !<The mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_ElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements%meshElements,err,error,*999)

    EXITS("cmfe_Mesh_ElementsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_ElementsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_ElementsGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the mesh elements for a mesh component on a mesh identified by an
  !user number.
  SUBROUTINE cmfe_Mesh_ElementsGetObj(mesh,meshComponentNumber,meshElements,err)
    !DLLEXPORT(cmfe_Mesh_ElementsGetObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the elements for.
    TYPE(cmfe_MeshElementsType), INTENT(INOUT) :: meshElements !<The mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables

    ENTERS("cmfe_Mesh_ElementsGetObj",err,error,*999)

    CALL Mesh_MeshElementsGet(mesh%mesh,meshComponentNumber,meshElements%meshElements,err,error,*999)

    EXITS("cmfe_Mesh_ElementsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_ElementsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_ElementsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the basis for an element in a mesh identified by an user number.
  SUBROUTINE cmfe_MeshElements_BasisGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,basisUserNumber,err)
    !DLLEXPORT(cmfe_MeshElements_BasisGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the basis for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the basis for.
    INTEGER(INTG), INTENT(OUT) :: basisUserNumber !<On return, the user number of the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber
    TYPE(BasisType), POINTER :: basis
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshElements_BasisGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementBasisGet(meshElements,globalElementNumber,basis,err,error,*999)
    CALL Basis_UserNumberGet(basis,basisUserNumber,err,error,*999)

    EXITS("cmfe_MeshElements_BasisGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_BasisGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_BasisGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the basis for an element in a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_BasisGetObj(meshElements,userElementNumber,basis,err)
    !DLLEXPORT(cmfe_MeshElements_BasisGetObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the basis for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the basis for.
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<On return, the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber

    ENTERS("cmfe_MeshElements_BasisGetObj",err,error,*999)

    CALL MeshElements_GlobalNumberGet(meshElements%meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementBasisGet(meshElements%meshElements,globalElementNumber,basis%basis,err,error,*999)

    EXITS("cmfe_MeshElements_BasisGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_BasisGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_BasisGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for an element in a mesh identified by an user number. 
  SUBROUTINE cmfe_MeshElements_BasisSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,basisUserNumber,err)
    !DLLEXPORT(cmfe_MeshElements_BasisSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The global element number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshElements_BasisSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(basisFunctions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL MeshElements_ElementBasisSet(meshElements,globalElementNumber,basis,err,error,*999)

    EXITS("cmfe_MeshElements_BasisSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_BasisSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_BasisSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for an element in a mesh identified by an object. 
  SUBROUTINE cmfe_MeshElements_BasisSetObj(meshElements,userElementNumber,basis,err)
    !DLLEXPORT(cmfe_MeshElements_BasisSetObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the basis for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the basis for.
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber

    ENTERS("cmfe_MeshElements_BasisSetObj",err,error,*999)

    CALL MeshElements_GlobalNumberGet(meshElements%meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementBasisSet(meshElements%meshElements,globalElementNumber,basis%basis,err,error,*999)

    EXITS("cmfe_MeshElements_BasisSetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_BasisSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_BasisSetObj

  !
  !================================================================================================================================
  !

  !>Returns the adjacent element number of a mesh identified by a user number
  SUBROUTINE cmfe_MeshElements_AdjacentElementGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,adjacentElementXi,adjacentUserElement,err)
    !DLLEXPORT(cmfe_MeshElements_AdjacentElementGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh from which to get the adjacent element from.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh from which to get the adjacent element from.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number from which to get adjacent element number from.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the adjacent element number for. !\todo this should be a user number
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for. Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
    INTEGER(INTG), INTENT(OUT) :: adjacentUserElement !<On return, the adjacent element user number in the specified xi coordinate direction. Return 0 if the specified element has no adjacent elements in the specified xi coordinate direction.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber,adjacentGlobalElement
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshElements_AdjacentElementGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementAdjacentElementGet(meshElements,globalElementNumber,adjacentElementXi,adjacentGlobalElement, &
      & err,error,*999)
    IF(adjacentGlobalElement==0) THEN
      adjacentUserElement=0
    ELSE
      CALL MeshElements_ElementUserNumberGet(meshElements,adjacentGlobalElement,adjacentUserElement,err,error,*999)
    ENDIF

    EXITS("cmfe_MeshElements_AdjacentElementGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_AdjacentElementGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_AdjacentElementGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the adjacent element number of a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_AdjacentElementGetObj(meshElements,userElementNumber,adjacentElementXi,adjacentUserElement,err)
    !DLLEXPORT(cmfe_MeshElements_AdjacentElementGetObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements from which to get the adjacent element for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the adjacent element for !\todo this should be a user number
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for  Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
    INTEGER(INTG), INTENT(OUT) :: adjacentUserElement !<On return, the adjacent element user number in the specified xi coordinate direction. Return 0 if the specified element has no adjacent elements in the specified xi coordinate direction.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber,adjacentGlobalElement

    ENTERS("cmfe_MeshElements_AdjacentElementGetObj",err,error,*999)

    CALL MeshElements_GlobalNumberGet(meshElements%meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementAdjacentElementGet(meshElements%meshElements,globalElementNumber,adjacentElementXi, &
      & adjacentGlobalElement,err,error,*999)
    IF(adjacentGlobalElement==0) THEN
      adjacentUserElement=0
    ELSE
      CALL MeshElements_ElementUserNumberGet(meshElements%meshElements,adjacentGlobalElement,adjacentUserElement,err,error,*999)
    ENDIF

    EXITS("cmfe_MeshElements_AdjacentElementGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_AdjacentElementGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_AdjacentElementGetObj

  !
  !================================================================================================================================
  !

  !>Gets the boundary type for an user element of a mesh identified by a user number
  SUBROUTINE cmfe_MeshElements_ElementOnBoundaryGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,onBoundary,err)
    !DLLEXPORT(cmfe_MeshElements_ElementOnBoundaryGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the boundary type for.
    INTEGER(INTG), INTENT(OUT) :: onBoundary !<On return, the boundary type for the specified user element. \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_MeshElements_ElementOnBoundaryGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementOnBoundaryGet(meshElements,globalElementNumber,onBoundary,err,error,*999)

    EXITS("cmfe_MeshElements_ElementOnBoundaryGetNumber")
    RETURN
999 ERRORS("cmfe_MeshElements_ElementOnBoundaryGetNumber",err,error)
    EXITS("cmfe_MeshElements_ElementOnBoundaryGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_ElementOnBoundaryGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the boundary type for an user element of a mesh identified by an object
  SUBROUTINE cmfe_MeshElements_ElementOnBoundaryGetObj(meshElements,userElementNumber,onBoundary,err)
    !DLLEXPORT(cmfe_MeshElements_ElementOnBoundaryGetObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements from which to get the boundary type for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the boundary type for.
    INTEGER(INTG), INTENT(OUT) :: onBoundary !<On return, the boundary type for the specified user element. \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber

    ENTERS("cmfe_MeshElements_ElementOnBoundaryGetObj",err,error,*999)

    CALL MeshElements_GlobalNumberGet(meshElements%meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementOnBoundaryGet(meshElements%meshElements,globalElementNumber,onBoundary,err,error,*999)

    EXITS("cmfe_MeshElements_ElementOnBoundaryGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_ElementOnBoundaryGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_ElementOnBoundaryGetObj

  !
  !================================================================================================================================
  !

  !>Returns the element nodes for an element in a mesh identified by an user number. 
  SUBROUTINE cmfe_MeshElements_NodesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,elementUserNodes,err)
    !DLLEXPORT(cmfe_MeshElements_NodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNodes(:) !<elementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshElements_NodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementNodesGet(meshElements,userElementNumber,elementUserNodes,err,error,*999)

    EXITS("cmfe_MeshElements_NodesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_NodesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_NodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element nodes for an element in a mesh identified by an object. 
  SUBROUTINE cmfe_MeshElements_NodesGetObj(meshElements,userElementNumber,elementUserNodes,err)
    !DLLEXPORT(cmfe_MeshElements_NodesGetObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNodes(:) !<elementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_NodesGetObj",err,error,*999)

    CALL MeshElements_ElementNodesGet(meshElements%meshElements,userElementNumber,elementUserNodes,err,error,*999)

    EXITS("cmfe_MeshElements_NodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_NodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. 
  SUBROUTINE cmfe_MeshElements_NodesSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,elementUserNodes,err)
    !DLLEXPORT(cmfe_MeshElements_NodesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementUserNodes(:) !<elementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshElements_NodesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementNodesSet(meshElements,userElementNumber,elementUserNodes,err,error,*999)

    EXITS("cmfe_MeshElements_NodesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_NodesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_NodesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. 
  SUBROUTINE cmfe_MeshElements_NodesSetObj(meshElements,userElementNumber,elementUserNodes,err)
    !DLLEXPORT(cmfe_MeshElements_NodesSetObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementUserNodes(:) !<elementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_NodesSetObj",err,error,*999)

    CALL MeshElements_ElementNodesSet(meshElements%meshElements,userElementNumber,elementUserNodes,err,error,*999)

    EXITS("cmfe_MeshElements_NodesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_NodesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_NodesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. 
  SUBROUTINE cmfe_MeshElements_UserNodeVersionSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,userElementNumber, &
    & versionNumber,derivativeNumber,userNodeNumber,meshComponentNumber,err)
    !DLLEXPORT(cmfe_MeshElements_UserNodeVersionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to set a version for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.

    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshElements_UserNodeVersionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_UserNodeVersionSet(meshElements,userElementNumber,versionNumber,derivativeNumber,userNodeNumber, &
      & err,error,*999)

    EXITS("cmfe_MeshElements_UserNodeVersionSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNodeVersionSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNodeVersionSetNumber

  !
  !================================================================================================================================
   !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. 
  SUBROUTINE cmfe_MeshElements_UserNodeVersionSetObj(meshElements,userElementNumber,versionNumber,derivativeNumber, &
    & userNodeNumber,err)
    !DLLEXPORT(cmfe_MeshElements_UserNodeVersionSetObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to set a version for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
 
    ENTERS("cmfe_MeshElements_UserNodeVersionSetObj",err,error,*999)

    CALL MeshElements_UserNodeVersionSet(meshElements%meshElements,userElementNumber,versionNumber, &
      & derivativeNumber,userNodeNumber,err,error,*999)

    EXITS("cmfe_MeshElements_UserNodeVersionSetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNodeVersionSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNodeVersionSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. 
  SUBROUTINE cmfe_MeshElements_LocalElementNodeVersionSetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & userElementNumber,versionNumber,derivativeNumber,localElementNodeNumber,meshComponentNumber,err)
    !DLLEXPORT(cmfe_MeshElements_LocalElementNodeVersionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: localElementNodeNumber !<The local element node to set a version for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.

    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshElements_LocalElementNodeVersionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementNodeVersionSet(meshElements,userElementNumber,versionNumber,derivativeNumber, &
      & localElementNodeNumber,err,error,*999)

    EXITS("cmfe_MeshElements_LocalElementNodeVersionSetNumber")
    RETURN
999 ERRORS("cmfe_MeshElements_LocalElementNodeVersionSetNumber",err,error)
    EXITS("cmfe_MeshElements_LocalElementNodeVersionSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_LocalElementNodeVersionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. 
  SUBROUTINE cmfe_MeshElements_LocalElementNodeVersionSetObj(meshElements,userElementNumber,versionNumber,derivativeNumber, &
    & localElementNodeNumber,err)
    !DLLEXPORT(cmfe_MeshElements_LocalElementNodeVersionSetObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: localElementNodeNumber !<The local element node to set a version for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_LocalElementNodeVersionSetObj",err,error,*999)

    CALL MeshElements_ElementNodeVersionSet(meshElements%meshElements,userElementNumber,versionNumber, &
      & derivativeNumber,localElementNodeNumber,err,error,*999)

    EXITS("cmfe_MeshElements_LocalElementNodeVersionSetObj")
    RETURN
999 ERRORS("cmfe_MeshElements_LocalElementNodeVersionSetObj",err,error)
    EXITS("cmfe_MeshElements_LocalElementNodeVersionSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_LocalElementNodeVersionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for an element in a mesh identified by an user number.
  SUBROUTINE cmfe_MeshElements_UserNumberGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & elementGlobalNumber,elementUserNumber,err)
    !DLLEXPORT(cmfe_MeshElements_UserNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshElements_UserNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementUserNumberGet(meshElements,elementGlobalNumber,elementUserNumber,err,error,*999)

    EXITS("cmfe_MeshElements_UserNumberGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNumberGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element user number for an element in a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_UserNumberGetObj(meshElements,elementGlobalNumber,elementUserNumber,err)
    !DLLEXPORT(cmfe_MeshElements_UserNumberGetObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_UserNumberGetObj",err,error,*999)

    CALL MeshElements_ElementUserNumberGet(meshElements%meshElements,elementGlobalNumber,elementUserNumber, &
      & err,error,*999)

    EXITS("cmfe_MeshElements_UserNumberGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNumberGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for an element in a mesh identified by an user number.
  SUBROUTINE cmfe_MeshElements_UserNumberSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & elementGlobalNumber,elementUserNumber,err)
    !DLLEXPORT(cmfe_MeshElements_UserNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshElements_UserNumberSetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementUserNumberSet(meshElements,elementGlobalNumber,elementUserNumber,err,error,*999)

    EXITS("cmfe_MeshElements_UserNumberSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNumberSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element user number for an element in a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_UserNumberSetObj(meshElements,elementGlobalNumber,elementUserNumber,err)
    !DLLEXPORT(cmfe_MeshElements_UserNumberSetObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_UserNumberSetObj",err,error,*999)

    CALL MeshElements_ElementUserNumberSet(meshElements%meshElements,elementGlobalNumber,elementUserNumber, &
      & err,error,*999)

    EXITS("cmfe_MeshElements_UserNumberSetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNumberSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumberSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for all elements in a mesh identified by an user number.
  SUBROUTINE cmfe_MeshElements_UserNumbersAllSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & elementUserNumbers,err)
    !DLLEXPORT(cmfe_MeshElements_UserNumbersAllSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumbers(:) !<The element user numbers to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshElements_UserNumbersAllSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementsUserNumbersAllSet(meshElements,elementUserNumbers,err,error,*999)

    EXITS("cmfe_MeshElements_UserNumbersAllSetNumber")
    RETURN
999 ERRORS("cmfe_MeshElements_UserNumbersAllSetNumber",err,error)
    EXITS("cmfe_MeshElements_UserNumbersAllSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumbersAllSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element user numbers for all elements in a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_UserNumbersAllSetObj(meshElements,elementUserNumbers,err)
    !DLLEXPORT(cmfe_MeshElements_UserNumbersAllSetObj)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element user numbers for
    INTEGER(INTG), INTENT(IN) :: elementUserNumbers(:) !<The element user numbers to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_UserNumbersAllSetObj",err,error,*999)

    CALL MeshElements_ElementsUserNumbersAllSet(meshElements%meshElements,elementUserNumbers,err,error,*999)

    EXITS("cmfe_MeshElements_UserNumbersAllSetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNumbersAllSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumbersAllSetObj

  !
  !================================================================================================================================
  !


  !>Checks if the given node exists on the given mesh component.
  SUBROUTINE cmfe_Mesh_NodeExistsNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber,nodeUserNumber, &
    & nodeExists,err)
    !DLLEXPORT(cmfe_Mesh_NodeExistsNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh tocheck the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to check.
    LOGICAL, INTENT(OUT) :: nodeExists !<True if the node exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalNodeNumber,meshNodeNumber
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(MeshTopologyType), POINTER :: meshTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_NodeExistsNumber",err,error,*999)

    nodeExists = .FALSE.

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshTopology)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(mesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshNodesGet(meshTopology,meshNodes,err,error,*999)
    CALL MeshNodes_NodeCheckExists(meshNodes,nodeUserNumber,nodeExists,globalNodeNumber,meshNodeNumber,err,error,*999)

    EXITS("cmfe_Mesh_NodeExistsNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NodeExistsNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NodeExistsNumber

  !
  !================================================================================================================================
  !

  !>Checks if the given node exists on the given mesh component.
  SUBROUTINE cmfe_Mesh_NodeExistsObj( mesh, meshComponentNumber, nodeUserNumber, nodeExists, err )
    !DLLEXPORT(cmfe_Mesh_NodeExistsObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to check.
    LOGICAL, INTENT(OUT) :: nodeExists !<True if the node exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalNodeNumber,meshNodeNumber
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(MeshTopologyType), POINTER :: meshTopology

    nodeExists = .FALSE.

    ENTERS("cmfe_Mesh_NodeExistsObj",err,error,*999)

    NULLIFY(meshTopology)
    NULLIFY(meshNodes)
    CALL Mesh_MeshTopologyGet(mesh%mesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshNodesGet(meshTopology,meshNodes,err,error,*999)
    CALL MeshNodes_NodeCheckExists(meshNodes,nodeUserNumber,nodeExists,globalNodeNumber,meshNodeNumber,err,error,*999)

    EXITS("cmfe_Mesh_NodeExistsObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NodeExistsObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NodeExistsObj

  !
  !================================================================================================================================
  !

  !>Checks if the given element exists on the given mesh component.
  SUBROUTINE cmfe_Mesh_ElementExistsNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & elementUserNumber,elementExists,err)
    !DLLEXPORT(cmfe_Mesh_ElementExistsNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to check the element for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to check the element for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the element for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to check.
    LOGICAL, INTENT(OUT) :: elementExists !<True if the element exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_ElementExistsNumber",err,error,*999)

    elementExists = .FALSE.

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshTopology)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(mesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)
    CALL MeshElements_ElementCheckExists(meshElements,elementUserNumber,elementExists,globalElementNumber,err,error,*999)

    EXITS("cmfe_Mesh_ElementExistsNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_ElementExistsNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_ElementExistsNumber

  !
  !================================================================================================================================
  !

  !>Checks if the given element exists on the given mesh component.
  SUBROUTINE cmfe_Mesh_ElementExistsObj( mesh, meshComponentNumber, elementUserNumber, elementExists, err )
    !DLLEXPORT(cmfe_Mesh_ElementExistsObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the element for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to check.
    LOGICAL, INTENT(OUT) :: elementExists !<True if the element exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    INTEGER(INTG) :: globalElementNumber
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology

    ENTERS("cmfe_Mesh_ElementExistsObj",err,error,*999)

    elementExists = .FALSE.
    NULLIFY(meshTopology)
    CALL Mesh_MeshTopologyGet(mesh%mesh,meshComponentNumber,meshTopology,err,error,*999)
    NULLIFY(meshElements)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)

    CALL MeshElements_ElementCheckExists(meshElements,elementUserNumber,elementExists,globalElementNumber,err,error,*999)

    EXITS("cmfe_Mesh_ElementExistsObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_ElementExistsObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_ElementExistsObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh nodes for a mesh component on a mesh identified by an user number.
  SUBROUTINE cmfe_Mesh_NodesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber,meshNodes,err)
    !DLLEXPORT(cmfe_Mesh_NodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the nodes for.
    TYPE(cmfe_MeshNodesType), INTENT(INOUT) :: meshNodes !<On return, the mesh nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Mesh_NodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes%meshNodes,err,error,*999)

    EXITS("cmfe_Mesh_NodesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NodesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NodesGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the mesh nodes for a mesh component on a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_NodesGetObj(mesh,meshComponentNumber,meshNodes,err)
    !DLLEXPORT(cmfe_Mesh_NodesGetObj)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the nodes for.
    TYPE(cmfe_MeshNodesType), INTENT(INOUT) :: meshNodes!<On return, the mesh nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_NodesGetObj",err,error,*999)

    CALL Mesh_MeshNodesGet(mesh%mesh,meshComponentNumber,meshNodes%meshNodes,err,error,*999)

    EXITS("cmfe_Mesh_NodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Gets the boundary type for an user node of a mesh identified by a user number
  SUBROUTINE cmfe_MeshNodes_NodeOnBoundaryGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userNodeNumber,onBoundary,err)
    !DLLEXPORT(cmfe_MeshNodes_NodeOnBoundaryGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the boundary type for.
    INTEGER(INTG), INTENT(OUT) :: onBoundary !<On return, the boundary type for the specified user node. \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_MeshNodes_NodeOnBoundaryGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
    CALL MeshNodes_NodeOnBoundaryGet(meshNodes,userNodeNumber,onBoundary,err,error,*999)

    EXITS("cmfe_MeshNodes_NodeOnBoundaryGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NodeOnBoundaryGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NodeOnBoundaryGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the boundary type for an user node of a mesh identified by an object
  SUBROUTINE cmfe_MeshNodes_NodeOnBoundaryGetObj(meshNodes,userNodeNumber,onBoundary,err)
    !DLLEXPORT(cmfe_MeshNodes_NodeOnBoundaryGetObj)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(IN) :: meshNodes !<The mesh nodes from which to get the boundary type for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the boundary type for.
    INTEGER(INTG), INTENT(OUT) :: onBoundary !<On return, the boundary type for the specified user node. \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_NodeOnBoundaryGetObj",err,error,*999)

    CALL MeshNodes_NodeOnBoundaryGet(meshNodes%meshNodes,userNodeNumber,onBoundary,err,error,*999)

    EXITS("cmfe_MeshNodes_NodeOnBoundaryGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NodeOnBoundaryGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NodeOnBoundaryGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes at a node in a mesh identified by an user number.
  SUBROUTINE cmfe_MeshNodes_NumberOfNodesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & numberOfNodes,err)
    !DLLEXPORT(cmfe_MeshNodes_NumberOfNodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of dervatives for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the number of nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the number of nodes in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshNodes_NumberOfNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
    CALL MeshNodes_NumberOfNodesGet(meshNodes,numberOfNodes,err,error,*999)

    EXITS("cmfe_MeshNodes_NumberOfNodesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfNodesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NumberOfNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of derivatives for a node in a mesh identified by an object.
  SUBROUTINE cmfe_MeshNodes_NumberOfNodesGetObj(meshNodes,numberOfNodes,err)
    !DLLEXPORT(cmfe_MeshNodes_NumberOfNodesGetObj)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(IN) :: meshNodes!<The mesh nodes to get the number of derivatives at a node for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes!<On return, the number of nodes in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_NumberOfNodesGetObj",err,error,*999)

    CALL MeshNodes_NumberOfNodesGet(meshNodes%meshNodes,numberOfNodes,err,error,*999)

    EXITS("cmfe_MeshNodes_NumberOfNodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfNodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NumberOfNodesGetObj

  !
  !================================================================================================================================
  !
  !>Returns the number of derivatives at a node in a mesh identified by an user number.
  SUBROUTINE cmfe_MeshNodes_NumberOfDerivativesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userNodeNumber,numberOfDerivatives,err)
    !DLLEXPORT(cmfe_MeshNodes_NumberOfDerivativesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of dervatives for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the number of derivatives for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of derivatives for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDerivatives !<On return, the number of derivatives in the mesh for the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshNodes_NumberOfDerivativesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
    CALL MeshNodes_NodeNumberOfDerivativesGet(meshNodes,userNodeNumber,numberOfDerivatives,err,error,*999)

    EXITS("cmfe_MeshNodes_NumberOfDerivativesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfDerivativesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NumberOfDerivativesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of derivatives for a node in a mesh identified by an object.
  SUBROUTINE cmfe_MeshNodes_NumberOfDerivativesGetObj(meshNodes,userNodeNumber,numberOfDerivatives,err)
    !DLLEXPORT(cmfe_MeshNodes_NumberOfDerivativesGetObj)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(IN) :: meshNodes!<The mesh nodes to get the number of derivatives at a node for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of derivatives at a node for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDerivatives!<On return, the number of derivatives at a node in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_NumberOfDerivativesGetObj",err,error,*999)

    CALL MeshNodes_NodeNumberOfDerivativesGet(meshNodes%meshNodes,userNodeNumber,numberOfDerivatives,err,error,*999)

    EXITS("cmfe_MeshNodes_NumberOfDerivativesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfDerivativesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NumberOfDerivativesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the derivatives at a node in a mesh identified by an user number.
  SUBROUTINE cmfe_MeshNodes_DerivativesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userNodeNumber,derivatives,err)
    !DLLEXPORT(cmfe_MeshNodes_DerivativesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the derivatives for.
    INTEGER(INTG), INTENT(OUT) :: derivatives(:) !<On return, the derivatives in the mesh for the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshNodes_DerivativesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
    CALL MeshNodes_NodeDerivativesGet(meshNodes,userNodeNumber,derivatives,err,error,*999)

    EXITS("cmfe_MeshNodes_DerivativesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_DerivativesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_DerivativesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the derivatives for a node in a mesh identified by an object.
  SUBROUTINE cmfe_MeshNodes_DerivativesGetObj(meshNodes,userNodeNumber,derivatives,err)
    !DLLEXPORT(cmfe_MeshNodes_DerivativesGetObj)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(IN) :: meshNodes!<The mesh nodes to get the derivatives at a node for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the derivatives at a node for.
    INTEGER(INTG), INTENT(OUT) :: derivatives(:) !<On return, the derivatives at a node in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_DerivativesGetObj",err,error,*999)

    CALL MeshNodes_NodeDerivativesGet(meshNodes%meshNodes,userNodeNumber,derivatives,err,error,*999)

    EXITS("cmfe_MeshNodes_DerivativesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_DerivativesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_DerivativesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of version at a derivative for a node in a mesh identified by an user number.
  SUBROUTINE cmfe_MeshNodes_NumberOfVersionsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & derivativeNumber,userNodeNumber,numberOfVersions,err)
    !DLLEXPORT(cmfe_MeshNodes_NumberOfVersionsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of versions.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the node to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of versions for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVersions !<On return, the number of versions in the mesh for the derivative index of the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_MeshNodes_NumberOfVersionsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
    CALL MeshNodes_NodeNumberOfVersionsGet(meshnodes,derivativeNumber,userNodeNumber,numberOfVersions,err,error,*999)

    EXITS("cmfe_MeshNodes_NumberOfVersionsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfVersionsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NumberOfVersionsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of versions for an node in a mesh identified by an object.
  SUBROUTINE cmfe_MeshNodes_NumberOfVersionsGetObj(meshNodes,derivativeNumber,userNodeNumber,numberOfVersions,err)
    !DLLEXPORT(cmfe_MeshNodes_NumberOfVersionsGetObj)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(IN) :: meshNodes !<The mesh nodes to get the number of versions at a node for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of a node to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of versions at a node for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVersions !<On return, the number of derivatives at the specified node and derivative in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_NumberOfVersionsGetObj",err,error,*999)

    CALL MeshNodes_NodeNumberOfVersionsGet(meshNodes%meshNodes,derivativeNumber,userNodeNumber, &
      & numberOfVersions,err,error,*999)

    EXITS("cmfe_MeshNodes_NumberOfVersionsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfVersionsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NumberOfVersionsGetObj

!!==================================================================================================================================
!!
!! DISTRIBUTED_MATRIX_VECTOR
!!
!!==================================================================================================================================

  !>Get the storage type for a distributed matrix
  SUBROUTINE cmfe_DistributedMatrix_StorageTypeGetObj(matrix,storageType,err)
    !DLLEXPORT(cmfe_DistributedMatrix_StorageTypeGetObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the storage type for
    INTEGER(INTG), INTENT(OUT) :: storageType !<On return, the matrix storage type. \see OpenCMISS_MatrixStorageTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_StorageTypeGetObj",err,error,*999)

    CALL DistributedMatrix_StorageTypeGet(matrix%distributedMatrix,storageType,err,error,*999)

    EXITS("cmfe_DistributedMatrix_StorageTypeGetObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_StorageTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_StorageTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the data type of a distributed matrix
  SUBROUTINE cmfe_DistributedMatrix_DataTypeGetObj(matrix,dataType,err)
    !DLLEXPORT(cmfe_DistributedMatrix_DataTypeGetObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data type for
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the matrix data type. \see OpenCMISS_MatrixVectorDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataTypeGetObj",err,error,*999)

    CALL DistributedMatrix_DataTypeGet(matrix%distributedMatrix,dataType,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataTypeGetObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the dimensions of a distributed matrix on this computation node
  SUBROUTINE cmfe_DistributedMatrix_DimensionsGetObj(matrix,m,n,err)
    !DLLEXPORT(cmfe_DistributedMatrix_DimensionsGetObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data type for
    INTEGER(INTG), INTENT(OUT) :: m !<On return, the number of rows for this computation node
    INTEGER(INTG), INTENT(OUT) :: n !<On return, the number of columns
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DimensionsGetObj",err,error,*999)

    CALL DistributedMatrix_DimensionsGet(matrix%distributedMatrix,m,n,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DimensionsGetObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DimensionsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DimensionsGetObj

  !
  !================================================================================================================================
  !

  !>Get the row indices and column indices for a sparse matrix
  SUBROUTINE cmfe_DistributedMatrix_StorageLocationsGetObj(matrix,rowIndices,columnIndices,err)
    !DLLEXPORT(cmfe_DistributedMatrix_StorageLocationsGetObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the storage locations for
    INTEGER(INTG), POINTER, INTENT(OUT) :: rowIndices(:) !<On return, the matrix storage row indices
    INTEGER(INTG), POINTER, INTENT(OUT) :: columnIndices(:) !<On return, the matrix storage column indices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_StorageLocationsGetObj",err,error,*999)

    CALL DistributedMatrix_StorageLocationsGet(matrix%distributedMatrix,rowIndices,columnIndices,err,error,*999)

    EXITS("cmfe_DistributedMatrix_StorageLocationsGetObj")

    RETURN
999 ERRORS("cmfe_DistributedMatrix_StorageLocationsGetObj",err,error)
    EXITS("cmfe_DistributedMatrix_StorageLocationsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_StorageLocationsGetObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computation node
  SUBROUTINE cmfe_DistributedMatrix_DataGetIntgObj(matrix,data,err)
    !DLLEXPORT(cmfe_DistributedMatrix_DataGetIntgObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    INTEGER(INTG), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataGetIntgObj",err,error,*999)

    CALL DistributedMatrix_DataGet(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataGetIntgObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataGetIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE cmfe_DistributedMatrix_DataRestoreIntgObj(matrix,data,err)
    !DLLEXPORT(cmfe_DistributedMatrix_DataRestoreIntgObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    INTEGER(INTG), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataRestoreIntgObj",err,error,*999)

    CALL DistributedMatrix_DataRestore(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataRestoreIntgObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataRestoreIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computation node
  SUBROUTINE cmfe_DistributedMatrix_DataGetDPObj(matrix,data,err)
    !DLLEXPORT(cmfe_DistributedMatrix_DataGetDPObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    REAL(DP), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataGetDPObj",err,error,*999)

    CALL DistributedMatrix_DataGet(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataGetDPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataGetDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataGetDPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE cmfe_DistributedMatrix_DataRestoreDPObj(matrix,data,err)
    !DLLEXPORT(cmfe_DistributedMatrix_DataRestoreDPObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    REAL(DP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataRestoreDPObj",err,error,*999)

    CALL DistributedMatrix_DataRestore(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataRestoreDPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataRestoreDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computation node
  SUBROUTINE cmfe_DistributedMatrix_DataGetSPObj(matrix,data,err)
    !DLLEXPORT(cmfe_DistributedMatrix_DataGetSPObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    REAL(SP), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataGetSPObj",err,error,*999)

    CALL DistributedMatrix_DataGet(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataGetSPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataGetSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataGetSPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE cmfe_DistributedMatrix_DataRestoreSPObj(matrix,data,err)
    !DLLEXPORT(cmfe_DistributedMatrix_DataRestoreSPObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    REAL(SP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataRestoreSPObj",err,error,*999)

    CALL DistributedMatrix_DataRestore(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataRestoreSPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataRestoreSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computation node
  SUBROUTINE cmfe_DistributedMatrix_DataGetLObj(matrix,data,err)
    !DLLEXPORT(cmfe_DistributedMatrix_DataGetLObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    LOGICAL, POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataGetLObj",err,error,*999)

    CALL DistributedMatrix_DataGet(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataGetLObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataGetLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataGetLObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE cmfe_DistributedMatrix_DataRestoreLObj(matrix,data,err)
    !DLLEXPORT(cmfe_DistributedMatrix_DataRestoreLObj)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    LOGICAL, POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataRestoreLObj",err,error,*999)

    CALL DistributedMatrix_DataRestore(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataRestoreLObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataRestoreLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataRestoreLObj

  !
  !================================================================================================================================
  !

  !>Get the data type of a distributed vector
  SUBROUTINE cmfe_DistributedVector_DataTypeGetObj(vector,dataType,err)
    !DLLEXPORT(cmfe_DistributedVector_DataTypeGetObj)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data type for
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the vector data type. \see OpenCMISS_MatrixVectorDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataTypeGetObj",err,error,*999)

    CALL DistributedVector_DataTypeGet(vector%distributedVector,dataType,err,error,*999)

    EXITS("cmfe_DistributedVector_DataTypeGetObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computation node
  SUBROUTINE cmfe_DistributedVector_DataGetIntgObj(vector,data,err)
    !DLLEXPORT(cmfe_DistributedVector_DataGetIntgObj)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    INTEGER(INTG), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataGetIntgObj",err,error,*999)

    CALL DistributedVector_DataGet(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataGetIntgObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataGetIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE cmfe_DistributedVector_DataRestoreIntgObj(vector,data,err)
    !DLLEXPORT(cmfe_DistributedVector_DataRestoreIntgObj)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    INTEGER(INTG), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataRestoreIntgObj",err,error,*999)

    CALL DistributedVector_DataRestore(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataRestoreIntgObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataRestoreIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computation node
  SUBROUTINE cmfe_DistributedVector_DataGetDPObj(vector,data,err)
    !DLLEXPORT(cmfe_DistributedVector_DataGetDPObj)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    REAL(DP), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataGetDPObj",err,error,*999)

    CALL DistributedVector_DataGet(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataGetDPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataGetDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataGetDPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE cmfe_DistributedVector_DataRestoreDPObj(vector,data,err)
    !DLLEXPORT(cmfe_DistributedVector_DataRestoreDPObj)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    REAL(DP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataRestoreDPObj",err,error,*999)

    CALL DistributedVector_DataRestore(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataRestoreDPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataRestoreDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computation node
  SUBROUTINE cmfe_DistributedVector_DataGetSPObj(vector,data,err)
    !DLLEXPORT(cmfe_DistributedVector_DataGetSPObj)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    REAL(SP), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataGetSPObj",err,error,*999)

    CALL DistributedVector_DataGet(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataGetSPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataGetSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataGetSPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE cmfe_DistributedVector_DataRestoreSPObj(vector,data,err)
    !DLLEXPORT(cmfe_DistributedVector_DataRestoreSPObj)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    REAL(SP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataRestoreSPObj",err,error,*999)

    CALL DistributedVector_DataRestore(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataRestoreSPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataRestoreSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computation node
  SUBROUTINE cmfe_DistributedVector_DataGetLObj(vector,data,err)
    !DLLEXPORT(cmfe_DistributedVector_DataGetLObj)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    LOGICAL, POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataGetLObj",err,error,*999)

    CALL DistributedVector_DataGet(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataGetLObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataGetLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataGetLObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE cmfe_DistributedVector_DataRestoreLObj(vector,data,err)
    !DLLEXPORT(cmfe_DistributedVector_DataRestoreLObj)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    LOGICAL, POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataRestoreLObj",err,error,*999)

    CALL DistributedVector_DataRestore(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataRestoreLObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataRestoreLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataRestoreLObj

!!==================================================================================================================================
!!
!! NodeRoutines
!!
!!==================================================================================================================================

  !>Finishes the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE cmfe_Nodes_CreateFinishNumber(contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(cmfe_Nodes_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_Nodes_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_CreateFinish(nodes,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Nodes Create')
#endif

    EXITS("cmfe_Nodes_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE cmfe_Nodes_CreateFinishObj(nodes,err)
    !DLLEXPORT(cmfe_Nodes_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_CreateFinishObj",err,error,*999)

    CALL Nodes_CreateFinish(nodes%nodes,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('nodes Create')
#endif

    EXITS("cmfe_Nodes_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE cmfe_Nodes_CreateStartNumber(contextUserNumber,regionUserNumber,numberOfNodes,err)
    !DLLEXPORT(cmfe_Nodes_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Nodes_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Nodes Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Nodes_CreateStart(region,numberOfNodes,nodes,err,error,*999)

    EXITS("cmfe_Nodes_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE cmfe_Nodes_CreateStartObj(region,numberOfNodes,nodes,err)
    !DLLEXPORT(cmfe_Nodes_CreateStartObj)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to start the creation of nodes on.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<On return, the created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('nodes Create')
#endif

    CALL Nodes_CreateStart(region%region,numberOfNodes,nodes%nodes,err,error,*999)

    EXITS("cmfe_Nodes_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE cmfe_Nodes_CreateStartInterfaceObj(interface,numberOfNodes,nodes,err)
    !DLLEXPORT(cmfe_Nodes_CreateStartInterfaceObj)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of nodes on.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<On return, the created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('nodes Create')
#endif

    CALL Nodes_CreateStart(interface%interface,numberOfNodes,nodes%nodes,err,error,*999)

    EXITS("cmfe_Nodes_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_CreateStartInterfaceObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Destroys the nodes in a region for nodes identified by user number.
  SUBROUTINE cmfe_Nodes_DestroyNumber(contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(cmfe_Nodes_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Nodes_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_Destroy(nodes,err,error,*999)

    EXITS("cmfe_Nodes_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the nodes in a region for nodes identified by an object.
  SUBROUTINE cmfe_Nodes_DestroyObj(nodes,err)
    !DLLEXPORT(cmfe_Nodes_DestroyObj)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_DestroyObj",err,error,*999)

    CALL Nodes_Destroy(nodes%nodes,err,error,*999)

    EXITS("cmfe_Nodes_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes
  SUBROUTINE cmfe_Nodes_NumberOfNodesGetNumber(contextUserNumber,regionUserNumber,numberOfNodes,err)
    !DLLEXPORT(cmfe_Nodes_NumberOfNodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get node count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the number of nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Nodes_NumberOfNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_NumberOfNodesGet(nodes,numberOfNodes,err,error,*999)

    EXITS("cmfe_Nodes_NumberOfNodesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_NumberOfNodesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_NumberOfNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes
  SUBROUTINE cmfe_Nodes_NumberOfNodesGetObj(nodes,numberOfNodes,err)
    !DLLEXPORT(cmfe_Nodes_NumberOfNodesGetObj)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes get node count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<The number of nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_NumberOfNodesGetObj",err,error,*999)

    CALL Nodes_NumberOfNodesGet(nodes%nodes,numberOfNodes,err,error,*999)

    EXITS("cmfe_Nodes_NumberOfNodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_NumberOfNodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_NumberOfNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelGetCNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,label,err)
    !DLLEXPORT(cmfe_Nodes_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_Nodes_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_LabelGet(nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelGetCObj(nodes,nodeGlobalNumber,label,err)
    !DLLEXPORT(cmfe_Nodes_LabelGetCObj)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_LabelGetCObj",err,error,*999)

    CALL Nodes_LabelGet(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelGetVSNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,label,err)
    !DLLEXPORT(cmfe_Nodes_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Nodes_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_LabelGet(nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelGetVSObj(nodes,nodeGlobalNumber,label,err)
    !DLLEXPORT(cmfe_Nodes_LabelGetVSObj)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_LabelGetVSObj",err,error,*999)

    CALL Nodes_LabelGet(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelSetCNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,label,err)
    !DLLEXPORT(cmfe_Nodes_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_Nodes_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_LabelSet(nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelSetCObj(nodes,nodeGlobalNumber,label,err)
    !DLLEXPORT(cmfe_Nodes_LabelSetCObj)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_LabelSetCObj",err,error,*999)

    CALL Nodes_LabelSet(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelSetVSNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,label,err)
    !DLLEXPORT(cmfe_Nodes_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_Nodes_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_LabelSet(nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelSetVSObj(nodes,nodeGlobalNumber,label,err)
    !DLLEXPORT(cmfe_Nodes_LabelSetVSObj)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_LabelSetVSObj",err,error,*999)

    CALL Nodes_LabelSet(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for a node in a set of nodes identified by user number.
  SUBROUTINE cmfe_Nodes_UserNumberGetNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,nodeUserNumber,err)
    !DLLEXPORT(cmfe_Nodes_UserNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Nodes_UserNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_UserNumberGet(nodes,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    EXITS("cmfe_Nodes_UserNumberGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumberGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_UserNumberGetObj(nodes,nodeGlobalNumber,nodeUserNumber,err)
    !DLLEXPORT(cmfe_Nodes_UserNumberGetObj)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_UserNumberGetObj",err,error,*999)

    CALL Nodes_UserNumberGet(nodes%nodes,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    EXITS("cmfe_Nodes_UserNumberGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumberGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a node in a set of nodes identified by user number.
  SUBROUTINE cmfe_Nodes_UserNumberSetNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,nodeUserNumber,err)
    !DLLEXPORT(cmfe_Nodes_UserNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_Nodes_UserNumberSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_UserNumberSet(nodes,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    EXITS("cmfe_Nodes_UserNumberSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumberSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_UserNumberSetObj(nodes,nodeGlobalNumber,nodeUserNumber,err)
    !DLLEXPORT(cmfe_Nodes_UserNumberSetObj)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_UserNumberSetObj",err,error,*999)

    CALL Nodes_UserNumberSet(nodes%nodes,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    EXITS("cmfe_Nodes_UserNumberSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumberSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumberSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for a set of nodes identified by user number.
  SUBROUTINE cmfe_Nodes_UserNumbersAllSetNumber(contextUserNumber,regionUserNumber,nodeUserNumbers,err)
    !DLLEXPORT(cmfe_Nodes_UserNumbersAllSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the node user numbers for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumbers(:) !<The user numbers for the nodes to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_Nodes_UserNumbersAllSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_UserNumbersAllSet(nodes,nodeUserNumbers,err,error,*999)

    EXITS("cmfe_Nodes_UserNumbersAllSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumbersAllSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumbersAllSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for a set of nodes identified by an object.
  SUBROUTINE cmfe_Nodes_UserNumbersAllSetObj(nodes,nodeUserNumbers,err)
    !DLLEXPORT(cmfe_Nodes_UserNumbersAllSetObj)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumbers(:) !<The user numbers for the nodes to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_UserNumbersAllSetObj",err,error,*999)

    CALL Nodes_UserNumbersAllSet(nodes%nodes,nodeUserNumbers,err,error,*999)

    EXITS("cmfe_Nodes_UserNumbersAllSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumbersAllSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumbersAllSetObj

!!==================================================================================================================================
!!
!! PROBLEM_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating CellML equations for a problem identified by user number.
  SUBROUTINE cmfe_Problem_CellMLEquationsCreateFinishNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_CellMLEquationsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_CellMLEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_CellMLEquationsCreateFinish(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CellML Equations Create')
#endif

    EXITS("cmfe_Problem_CellMLEquationsCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_Problem_CellMLEquationsCreateFinishNumber",err,error)
    EXITS("cmfe_Problem_CellMLEquationsCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML equations for problem identified by an object.
  SUBROUTINE cmfe_Problem_CellMLEquationsCreateFinishObj(problem,err)
    !DLLEXPORT(cmfe_Problem_CellMLEquationsCreateFinishObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_CellMLEquationsCreateFinishObj",err,error,*999)

    CALL Problem_CellMLEquationsCreateFinish(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CellML Equations Create')
#endif

    EXITS("cmfe_Problem_CellMLEquationsCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating CellML equations for a problem identified by user number.
  SUBROUTINE cmfe_Problem_CellMLEquationsCreateStartNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_CellMLEquationsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_CellMLEquationsCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Equations Create')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_CellMLEquationsCreateStart(problem,err,error,*999)

    EXITS("cmfe_Problem_CellMLEquationsCreateStartNumber")
    RETURN
999 ERRORS("cmfe_Problem_CellMLEquationsCreateStartNumber",err,error)
    EXITS("cmfe_Problem_CellMLEquationsCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML equations for problem identified by an object.
  SUBROUTINE cmfe_Problem_CellMLEquationsCreateStartObj(problem,err)
    !DLLEXPORT(cmfe_Problem_CellMLEquationsCreateStartObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to start creating the CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_CellMLEquationsCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Equations Create')
#endif

    CALL Problem_CellMLEquationsCreateStart(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_CellMLEquationsCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_CellMLEquationsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & cellMLEquations,err)
    !DLLEXPORT(cmfe_Problem_CellMLEquationsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_CellMLEquationsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_CellMLEquationsGet(problem,controlLoopIdentifier,solverIndex,cellMLEquations%cellmlEquations,err,error,*999)

    EXITS("cmfe_Problem_CellMLEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_CellMLEquationsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & cellMLEquations,err)
    !DLLEXPORT(cmfe_Problem_CellMLEquationsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_CellMLEquationsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_CellMLEquationsGet(problem,controlLoopIdentifiers,solverIndex,cellMLEquations%cellmlEquations,err,error,*999)

    EXITS("cmfe_Problem_CellMLEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an object.
  SUBROUTINE cmfe_Problem_CellMLEquationsGetObj0(problem,controlLoopIdentifier,solverIndex,cellMLEquations,err)
    !DLLEXPORT(cmfe_Problem_CellMLEquationsGetObj0)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_CellMLEquationsGetObj0",err,error,*999)

    CALL Problem_CellMLEquationsGet(problem%problem,controlLoopIdentifier,solverIndex,cellMLEquations%cellmlEquations, &
      & err,error,*999)

    EXITS("cmfe_Problem_CellMLEquationsGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an object.
  SUBROUTINE cmfe_Problem_CellMLEquationsGetObj1(problem,controlLoopIdentifiers,solverIndex,cellMLEquations,err)
    !DLLEXPORT(cmfe_Problem_CellMLEquationsGetObj1)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_CellMLEquationsGetObj1",err,error,*999)

    CALL Problem_CellMLEquationsGet(problem%problem,controlLoopIdentifiers,solverIndex,cellMLEquations%cellmlEquations, &
      & err,error,*999)

    EXITS("cmfe_Problem_CellMLEquationsGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsGetObj1

   !
  !================================================================================================================================
  !

  !>Finishes the process of a problem identified by user number.
  SUBROUTINE cmfe_Problem_CreateFinishNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_CreateFinish(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Create')
#endif

    EXITS("cmfe_Problem_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a problem identified by an object.
  SUBROUTINE cmfe_Problem_CreateFinishObj(problem,err)
    !DLLEXPORT(cmfe_Problem_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_CreateFinishObj",err,error,*999)

    CALL Problem_CreateFinish(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Create')
#endif

    EXITS("cmfe_Problem_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of a problem identified by user number.
  SUBROUTINE cmfe_Problem_CreateStartNumber(problemUserNumber,contextUserNumber,problemSpecification,err)
    !DLLEXPORT(cmfe_Problem_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemSpecification(:) !<The problem specification array, containt the problem class, type etc
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    
    ENTERS("cmfe_Problem_CreateStartNumber",err,error,*999)
    
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Create')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_CreateStart(problemUserNumber,problems,problemSpecification,problem,err,error,*999)

    EXITS("cmfe_Problem_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a problem identified by an object.
  SUBROUTINE cmfe_Problem_CreateStartObj(problemUserNumber,context,problemSpecification,problem,err)
    !DLLEXPORT(cmfe_Problem_CreateStartObj)

    !Argument variables
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The context in which to create the problem. 
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of.
    INTEGER(INTG), INTENT(IN) :: problemSpecification(:) !<The problem specification array, containt the problem class, type etc
    TYPE(cmfe_ProblemType), INTENT(INOUT) :: problem !<On return, the created problem.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Create')
#endif

    NULLIFY(problems)
    CALL Context_ProblemsGet(context%context,problems,err,error,*999)
    CALL Problem_CreateStart(problemUserNumber,problems,problemSpecification,problem%problem,err,error,*999)

    EXITS("cmfe_Problem_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a control loop for a problem identified by user number.
  SUBROUTINE cmfe_Problem_ControlLoopCreateFinishNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_ControlLoopCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_ControlLoopCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopCreateFinish(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Control Loop Create')
#endif

    EXITS("cmfe_Problem_ControlLoopCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a control loop on a problem identified by an object.
  SUBROUTINE cmfe_Problem_ControlLoopCreateFinishObj(problem,err)
    !DLLEXPORT(cmfe_Problem_ControlLoopCreateFinishObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_ControlLoopCreateFinishObj",err,error,*999)

    CALL Problem_ControlLoopCreateFinish(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Control Loop Create')
#endif

    EXITS("cmfe_Problem_ControlLoopCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating a control loop for a problem identified by user number.
  SUBROUTINE cmfe_Problem_ControlLoopCreateStartNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_ControlLoopCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_ControlLoopCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Control Loop Create')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopCreateStart(problem,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a control loop on a problem identified by an object.
  SUBROUTINE cmfe_Problem_ControlLoopCreateStartObj(problem,err)
    !DLLEXPORT(cmfe_Problem_ControlLoopCreateStartObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_ControlLoopCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Control Loop Create')
#endif

    CALL Problem_ControlLoopCreateStart(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the control loops for a problem identified by user number.
  SUBROUTINE cmfe_Problem_ControlLoopDestroyNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_ControlLoopDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_ControlLoopDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopDestroy(problem,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the control loops on a problem identified by an object.
  SUBROUTINE cmfe_Problem_ControlLoopDestroyObj(problem,err)
    !DLLEXPORT(cmfe_Problem_ControlLoopDestroyObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_ControlLoopDestroyObj",err,error,*999)

    CALL Problem_ControlLoopDestroy(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_ControlLoopGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,controlLoop,err)
    !DLLEXPORT(cmfe_Problem_ControlLoopGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_ControlLoopGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_ControlLoopGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,controlLoop,err)
    !DLLEXPORT(cmfe_Problem_ControlLoopGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_ControlLoopGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE cmfe_Problem_ControlLoopGetObj0(problem,controlLoopIdentifier,controlLoop,err)
    !DLLEXPORT(cmfe_Problem_ControlLoopGetObj0)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_ControlLoopGetObj0",err,error,*999)

    CALL Problem_ControlLoopGet(problem%problem,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE cmfe_Problem_ControlLoopGetObj1(problem,controlLoopIdentifiers,controlLoop,err)
    !DLLEXPORT(cmfe_Problem_ControlLoopGetObj1)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_ControlLoopGetObj1",err,error,*999)

    CALL Problem_ControlLoopGet(problem%problem,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopGetObj1

  !
  !================================================================================================================================
  !

  !>Destroys a problem identified by an user number.
  SUBROUTINE cmfe_Problem_DestroyNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_Destroy(problem,err,error,*999)

    EXITS("cmfe_Problem_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a problem identified by an object.
  SUBROUTINE cmfe_Problem_DestroyObj(problem,err)
    !DLLEXPORT(cmfe_Problem_DestroyObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_DestroyObj",err,error,*999)

    CALL Problem_Destroy(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_DestroyObj

  !
  !================================================================================================================================
  !

  !>Solves a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolveNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_SolveNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to solve.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SolveNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solve')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_Solve(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solve')
#endif

    EXITS("cmfe_Problem_SolveNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolveNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolveNumber

  !
  !================================================================================================================================
  !

  !>Solves a problem identified by an object.
  SUBROUTINE cmfe_Problem_SolveObj(problem,err)
    !DLLEXPORT(cmfe_Problem_SolveObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to solve.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolveObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Solve')
#endif

    CALL Problem_Solve(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Solve')
#endif

    EXITS("cmfe_Problem_SolveObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolveObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolveObj

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,solver,err)
    !DLLEXPORT(cmfe_Problem_SolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver%solver,err,error,*999)

    EXITS("cmfe_Problem_SolverGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,solver,err)
    !DLLEXPORT(cmfe_Problem_SolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver%solver,err,error,*999)

    EXITS("cmfe_Problem_SolverGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverGetObj0(problem,controlLoopIdentifier,solverIndex,solver,err)
    !DLLEXPORT(cmfe_Problem_SolverGetObj0)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverGetObj0",err,error,*999)

    CALL Problem_SolverGet(problem%problem,controlLoopIdentifier,solverIndex,solver%solver,err,error,*999)

    EXITS("cmfe_Problem_SolverGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverGetObj1(problem,controlLoopIdentifiers,solverIndex,solver,err)
    !DLLEXPORT(cmfe_Problem_SolverGetObj1)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverGetObj1",err,error,*999)

    CALL Problem_SolverGet(problem%problem,controlLoopIdentifiers,solverIndex,solver%solver,err,error,*999)

    EXITS("cmfe_Problem_SolverGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverGetObj1

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations for solver equations identified by user numbers.
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to calculate the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL Problem_SolverEquationsBoundaryConditionsAnalytic(solverEquations,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations for solver equations identified by user numbers.
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to calculate the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions

    ENTERS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL Problem_SolverEquationsBoundaryConditionsAnalytic(solverEquations,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations.
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticObj(solverEquations,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsAnalyticObj)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_SolverEquations_BoundaryConditionsAnalyticObj",err,error,*999)

    CALL Problem_SolverEquationsBoundaryConditionsAnalytic(solverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticObj")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsAnalyticObj",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating solver equations for a problem identified by user number.
  SUBROUTINE cmfe_Problem_SolverEquationsCreateFinishNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_SolverEquationsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SolverEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsCreateFinish(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    EXITS("cmfe_Problem_SolverEquationsCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_Problem_SolverEquationsCreateFinishNumber",err,error)
    EXITS("cmfe_Problem_SolverEquationsCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of solver equations for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverEquationsCreateFinishObj(problem,err)
    !DLLEXPORT(cmfe_Problem_SolverEquationsCreateFinishObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverEquationsCreateFinishObj",err,error,*999)

    CALL Problem_SolverEquationsCreateFinish(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    EXITS("cmfe_Problem_SolverEquationsCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating solver equations for a problem identified by user number.
  SUBROUTINE cmfe_Problem_SolverEquationsCreateStartNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_SolverEquationsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SolverEquationsCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsCreateStart(problem,err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsCreateStartNumber")
    RETURN
999 ERRORS("cmfe_Problem_SolverEquationsCreateStartNumber",err,error)
    EXITS("cmfe_Problem_SolverEquationsCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of solver equations for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverEquationsCreateStartObj(problem,err)
    !DLLEXPORT(cmfe_Problem_SolverEquationsCreateStartObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to start creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverEquationsCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    CALL Problem_SolverEquationsCreateStart(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the solver equations for a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolverEquationsDestroyNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_SolverEquationsDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SolverEquationsDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsDestroy(problem,err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the solver equations for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverEquationsDestroyObj(problem,err)
    !DLLEXPORT(cmfe_Problem_SolverEquationsDestroyObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to destroy the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverEquationsDestroyObj",err,error,*999)

    CALL Problem_SolverEquationsDestroy(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolverEquationsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & solverEquations,err)
    !DLLEXPORT(cmfe_Problem_SolverEquationsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SolverEquationsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolverEquationsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & solverEquations,err)
    !DLLEXPORT(cmfe_Problem_SolverEquationsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SolverEquationsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverEquationsGetObj0(problem,controlLoopIdentifier,solverIndex,solverEquations,err)
    !DLLEXPORT(cmfe_Problem_SolverEquationsGetObj0)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverEquationsGetObj0",err,error,*999)

    CALL Problem_SolverEquationsGet(problem%problem,controlLoopIdentifier,solverIndex,solverEquations%solverEquations, &
      & err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverEquationsGetObj1(problem,controlLoopIdentifiers,solverIndex,solverEquations,err)
    !DLLEXPORT(cmfe_Problem_SolverEquationsGetObj1)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverEquationsGetObj1",err,error,*999)

    CALL Problem_SolverEquationsGet(problem%problem,controlLoopIdentifiers,solverIndex,solverEquations%solverEquations, &
      & err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsGetObj1

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating solvers for a problem identified by user number.
  SUBROUTINE cmfe_Problem_SolversCreateFinishNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_SolversCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SolversCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolversCreateFinish(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solvers Create')
#endif

    EXITS("cmfe_Problem_SolversCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of solvers for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolversCreateFinishObj(problem,err)
    !DLLEXPORT(cmfe_Problem_SolversCreateFinishObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolversCreateFinishObj",err,error,*999)

    CALL Problem_SolversCreateFinish(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Solvers Create')
#endif

    EXITS("cmfe_Problem_SolversCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating solvers for a problem identified by user number.
  SUBROUTINE cmfe_Problem_SolversCreateStartNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_SolversCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SolversCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solvers Create')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolversCreateStart(problem,err,error,*999)

    EXITS("cmfe_Problem_SolversCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of solvers for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolversCreateStartObj(problem,err)
    !DLLEXPORT(cmfe_Problem_SolversCreateStartObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to start creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolversCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Solvers Create')
#endif

    CALL Problem_SolversCreateStart(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_SolversCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the solvers for a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolversDestroyNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(cmfe_Problem_SolversDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SolversDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolversDestroy(problem,err,error,*999)

    EXITS("cmfe_Problem_SolversDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the solvers for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolversDestroyObj(problem,err)
    !DLLEXPORT(cmfe_Problem_SolversDestroyObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolversDestroyObj",err,error,*999)

    CALL Problem_SolversDestroy(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_SolversDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the specification array for a problem identified by a user number.
  SUBROUTINE cmfe_Problem_SpecificationGetNumber(contextUserNumber,problemUserNumber,problemSpecification,err)
    !DLLEXPORT(cmfe_Problem_SpecificationGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: problemSpecification(:) !<On return, the problem specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SpecificationGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SpecificationGet(problem,SIZE(problemSpecification,1),problemSpecification,err,error,*999)

    EXITS("cmfe_Problem_SpecificationGetNumber")
    RETURN
999 ERRORS("cmfe_Problem_SpecificationGetNumber",err,error)
    EXITS("cmfe_Problem_SpecificationGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SpecificationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the specification array for a problem identified by an object.
  SUBROUTINE cmfe_Problem_SpecificationGetObj(problem,problemSpecification,err)
    !DLLEXPORT(cmfe_Problem_SpecificationGetObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: problemSpecification(:) !<On return, the problem specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SpecificationGetObj",err,error,*999)

    CALL Problem_SpecificationGet(problem%problem,SIZE(problemSpecification,1),problemSpecification,err,error,*999)

    EXITS("cmfe_Problem_SpecificationGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SpecificationGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SpecificationGetObj

  !
  !================================================================================================================================
  !

  !>Returns the size of the specification array for a problem identified by a user number.
  SUBROUTINE cmfe_Problem_SpecificationSizeGetNumber(contextUserNumber,problemUserNumber,specificationSize,err)
    !DLLEXPORT(cmfe_Problem_SpecificationSizeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the size of the specification for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the problem specification array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("cmfe_Problem_SpecificationSizeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SpecificationSizeGet(problem,specificationSize,err,error,*999)

    EXITS("cmfe_Problem_SpecificationSizeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SpecificationSizeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SpecificationSizeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the size of the specification array for a problem identified by an object.
  SUBROUTINE cmfe_Problem_SpecificationSizeGetObj(problem,specificationSize,err)
    !DLLEXPORT(cmfe_Problem_SpecificationSizeGetObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the size of the specification for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the problem specification array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SpecificationSizeGetObj",err,error,*999)

    CALL Problem_SpecificationSizeGet(problem%problem,specificationSize,err,error,*999)

    EXITS("cmfe_Problem_SpecificationSizeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SpecificationSizeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SpecificationSizeGetObj
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the work group of a problem identified by a user number.
  SUBROUTINE cmfe_Problem_WorkGroupSetNumber(contextUserNumber,problemUserNumber,workGroupUserNumber,err)
    !DLLEXPORT(cmfe_Problem_WorkGroupSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the work group for.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(WorkGroupType), POINTER :: workGroup

    ENTERS("cmfe_Problem_WorkGroupSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(computationEnvironment)
    NULLIFY(problem)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL Problem_WorkGroupSet(problem,workGroup,err,error,*999)
    
    EXITS("cmfe_Problem_WorkGroupSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_WorkGroupSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_WorkGroupSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the work group for a problem identified by an object.
  SUBROUTINE cmfe_Problem_WorkGroupSetObj(problem,workGroup,err)
    !DLLEXPORT(cmfe_Problem_WorkGroupSetObj)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(INOUT) :: problem !<The problem to set the work group for.
    TYPE(cmfe_WorkGroupType), INTENT(IN) :: workGroup !<The work group to set for the problem.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_WorkGroupSetObj",err,error,*999)

    CALL Problem_WorkGroupSet(problem%problem,workGroup%workGroup,err,error,*999)

    EXITS("cmfe_Problem_WorkGroupSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_WorkGroupSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_WorkGroupSetObj


!!==================================================================================================================================
!!
!! RegionRoutines
!!
!!==================================================================================================================================

  !>Returns the coordinate system for a region identified by an user number.
  SUBROUTINE cmfe_Region_CoordinateSystemGetNumber(contextUserNumber,regionUserNumber,coordinateSystemUserNumber,err)
    !DLLEXPORT(cmfe_Region_CoordinateSystemGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the coordinate system for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemUserNumber !<On return, the coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Region_CoordinateSystemGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(region)
    NULLIFY(regions)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CoordinateSystemGet(region,coordinateSystem,err,error,*999)
    coordinateSystemUserNumber = coordinateSystem%userNumber

    EXITS("cmfe_Region_CoordinateSystemGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_CoordinateSystemGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CoordinateSystemGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the coordinate system for a region identified by an object.
  SUBROUTINE cmfe_Region_CoordinateSystemGetObj(region,coordinateSystem,err)
    !DLLEXPORT(cmfe_Region_CoordinateSystemGetObj)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the coordinate system for.
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<On return, the regions coordinate system.
   INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_CoordinateSystemGetObj",err,error,*999)

    CALL Region_CoordinateSystemGet(region%region,coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_Region_CoordinateSystemGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_CoordinateSystemGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CoordinateSystemGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for a region identified by an user number.
  SUBROUTINE cmfe_Region_CoordinateSystemSetNumber(contextUserNumber,regionUserNumber,coordinateSystemUserNumber,err)
    !DLLEXPORT(cmfe_Region_CoordinateSystemSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to set the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Region_CoordinateSystemSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(coordinateSystems)
    NULLIFY(region)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL Region_CoordinateSystemSet(region,coordinateSystem,err,error,*999)

    EXITS("cmfe_Region_CoordinateSystemSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_CoordinateSystemSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CoordinateSystemSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for a region identified by an object.
  SUBROUTINE cmfe_Region_CoordinateSystemSetObj(region,coordinateSystem,err)
    !DLLEXPORT(cmfe_Region_CoordinateSystemSetObj)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to set the coordinate system for.
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_CoordinateSystemSetObj",err,error,*999)

    CALL Region_CoordinateSystemSet(region%region,coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_Region_CoordinateSystemSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_CoordinateSystemSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CoordinateSystemSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a region identified by user number.
  SUBROUTINE cmfe_Region_CreateFinishNumber(contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(cmfe_Region_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Region_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CreateFinish(region,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Region Create')
#endif

    EXITS("cmfe_Region_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a region identified by an object.
  SUBROUTINE cmfe_Region_CreateFinishObj(region,err)
    !DLLEXPORT(cmfe_Region_CreateFinishObj)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_CreateFinishObj",err,error,*999)

    CALL Region_CreateFinish(region%region,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('region Create')
#endif

    EXITS("cmfe_Region_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process creating a region identified by user number.
  SUBROUTINE cmfe_Region_CreateStartNumber(regionUserNumber,contextUserNumber,parentRegionUserNumber,err)
    !DLLEXPORT(cmfe_Region_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region to start the creation of the region in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: parentRegion,region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Region_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Region Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_CreateStart(regionUserNumber,parentRegion,region,err,error,*999)

    EXITS("cmfe_Region_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a region identified by an object.
  SUBROUTINE cmfe_Region_CreateStartObj(regionUserNumber,parentRegion,region,err)
    !DLLEXPORT(cmfe_Region_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of.
    TYPE(cmfe_RegionType), INTENT(IN) :: parentRegion !<The parent region to  to start the creation of the region in.
    TYPE(cmfe_RegionType), INTENT(INOUT) :: region !<On return, the created region.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('region Create')
#endif

    CALL Region_CreateStart(regionUserNumber,parentRegion%region,region%region,err,error,*999)

    EXITS("cmfe_Region_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the data points for a region identified by an object.
  SUBROUTINE cmfe_Region_DataPointsGetObj(region,dataPointsUserNumber,dataPoints,err)
    !DLLEXPORT(cmfe_Region_DataPointsGetObj)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the data points for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points to get.
    TYPE(cmfe_DataPointsType), INTENT(INOUT) :: dataPoints !<On return, the regions data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_DataPointsGetObj",err,error,*999)

    CALL Region_DataPointsGet(region%region,dataPointsUserNumber,dataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_Region_DataPointsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_DataPointsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_DataPointsGetObj

  !
  !================================================================================================================================
  !

  !>Destroys a region identified by an user number.
  SUBROUTINE cmfe_Region_DestroyNumber(contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(cmfe_Region_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Region_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_Destroy(region,err,error,*999)

    EXITS("cmfe_Region_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a region identified by an object.
  SUBROUTINE cmfe_Region_DestroyObj(region,err)
    !DLLEXPORT(cmfe_Region_DestroyObj)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(INOUT) :: region !<The region to destroy
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_DestroyObj",err,error,*999)

    CALL Region_Destroy(region%region,err,error,*999)

    EXITS("cmfe_Region_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a region identified by an user number.
  SUBROUTINE cmfe_Region_LabelGetCNumber(contextUserNumber,regionUserNumber,label,err)
    !DLLEXPORT(cmfe_Region_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Region_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_LabelGet(region,label,err,error,*999)

    EXITS("cmfe_Region_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a region identified by an object.
  SUBROUTINE cmfe_Region_LabelGetCObj(region,label,err)
    !DLLEXPORT(cmfe_Region_LabelGetCObj)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_LabelGetCObj",err,error,*999)

    CALL Region_LabelGet(region%region,label,err,error,*999)

    EXITS("cmfe_Region_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a region identified by an user number.
  SUBROUTINE cmfe_Region_LabelGetVSNumber(contextUserNumber,regionUserNumber,label,err)
    !DLLEXPORT(cmfe_Region_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Region_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_LabelGet(region,label,err,error,*999)

    EXITS("cmfe_Region_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a region identified by an object.
  SUBROUTINE cmfe_Region_LabelGetVSObj(region,label,err)
    !DLLEXPORT(cmfe_Region_LabelGetVSObj)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_LabelGetVSObj",err,error,*999)

    CALL Region_LabelGet(region%region,label,err,error,*999)

    EXITS("cmfe_Region_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a region identified by an user number.
  SUBROUTINE cmfe_Region_LabelSetCNumber(contextUserNumber,regionUserNumber,label,err)
    !DLLEXPORT(cmfe_Region_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Region_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_LabelSet(region,label,err,error,*999)

    EXITS("cmfe_Region_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a region identified by an object.
  SUBROUTINE cmfe_Region_LabelSetCObj(region,label,err)
    !DLLEXPORT(cmfe_Region_LabelSetCObj)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_LabelSetCObj",err,error,*999)

    CALL Region_LabelSet(region%region,label,err,error,*999)

    EXITS("cmfe_Region_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a region identified by an user number.
  SUBROUTINE cmfe_Region_LabelSetVSNumber(contextUserNumber,regionUserNumber,label,err)
    !DLLEXPORT(cmfe_Region_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_Region_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_LabelSet(region,CHAR(label),err,error,*999)

    EXITS("cmfe_Region_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a region identified by an object.
  SUBROUTINE cmfe_Region_LabelSetVSObj(region,label,err)
    !DLLEXPORT(cmfe_Region_LabelSetVSObj)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_LabelSetVSObj",err,error,*999)

    CALL Region_LabelSet(region%region,CHAR(label),err,error,*999)

    EXITS("cmfe_Region_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the nodes for a region identified by an object.
  SUBROUTINE cmfe_Region_NodesGetObj(region,nodes,err)
    !DLLEXPORT(cmfe_Region_NodesGetObj)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the nodes for.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes !<On return, the regions nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_NodesGetObj",err,error,*999)

    CALL Region_NodesGet(region%region,nodes%nodes,err,error,*999)

    EXITS("cmfe_Region_NodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_NodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_NodesGetObj

!!==================================================================================================================================
!!
!! SolverRoutines
!!
!!==================================================================================================================================

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an user number.
  SUBROUTINE cmfe_CellMLEquations_CellMLAddNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,cellMLUserNumber,cellMLIndex,err)
    !DLLEXPORT(cmfe_CellMLEquations_CellMLAddNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: cellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLType), POINTER :: cellml
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_CellMLEquations_CellMLAddNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellMLEquations_CellMLAdd(cellMLEquations,cellml,cellMLIndex,err,error,*999)

    EXITS("cmfe_CellMLEquations_CellMLAddNumber0")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_CellMLAddNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_CellMLAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an user number.
  SUBROUTINE cmfe_CellMLEquations_CellMLAddNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,cellMLUserNumber,cellMLIndex,err)
    !DLLEXPORT(cmfe_CellMLEquations_CellMLAddNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: cellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLType), POINTER :: cellml
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_CellMLEquations_CellMLAddNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellMLEquations_CellMLAdd(cellMLEquations,cellml,cellMLIndex,err,error,*999)

    EXITS("cmfe_CellMLEquations_CellMLAddNumber1")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_CellMLAddNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_CellMLAddNumber1

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an object.
  SUBROUTINE cmfe_CellMLEquations_CellMLAddObj(cellMLEquations,CellML,cellMLIndex,err)
    !DLLEXPORT(cmfe_CellMLEquations_CellMLAddObj)

    !Argument variables
    TYPE(cmfe_CellMLEquationsType), INTENT(IN) :: cellMLEquations !<The CellML equations to add the CellML environment for.
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: cellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellMLEquations_CellMLAddObj",err,error,*999)

    CALL CellMLEquations_CellMLAdd(cellMLEquations%cellmlEquations,CellML%cellML,cellMLIndex,err,error,*999)

    EXITS("cmfe_CellMLEquations_CellMLAddObj")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_CellMLAddObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_CellMLAddObj

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for CellML equations identified by an user number.
  SUBROUTINE cmfe_CellMLEquations_LinearityTypeGetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearityType,err)
    !DLLEXPORT(cmfe_CellMLEquations_LinearityTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to get the CellML equations linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the CellML equations linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get CellML equations linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On exit, the linearity type of the specified CellML equations. \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_CellMLEquations_LinearityTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL CellMLEquations_LinearityTypeGet(cellMLEquations,linearityType,err,error,*999)

    EXITS("cmfe_CellMLEquations_LinearityTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_LinearityTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_LinearityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for CellML equations identified by an object.
  SUBROUTINE cmfe_CellMLEquations_LinearityTypeGetObj(cellMLEquations,linearityType,err)
    !DLLEXPORT(cmfe_CellMLEquations_LinearityTypeGetObj)

    !Argument variables
    TYPE(cmfe_CellMLEquationsType), INTENT(IN) :: cellMLEquations !<The CellML equations to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On exit, the linearity type of the specified CellML equations. \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellMLEquations_LinearityTypeGetObj",err,error,*999)

    CALL CellMLEquations_LinearityTypeGet(cellMLEquations%cellMLEquations,linearityType,err,error,*999)

    EXITS("cmfe_CellMLEquations_LinearityTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_LinearityTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_LinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the linearity type for CellML equations identified by an user number.
  SUBROUTINE cmfe_CellMLEquations_LinearityTypeSetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearityType,err)
    !DLLEXPORT(cmfe_CellMLEquations_LinearityTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to set the CellML equations linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the CellML equations linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set CellML equations linearity type for.
    INTEGER(INTG), INTENT(IN) :: linearityType !<The linearity type of the specified CellML equations to set. \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_CellMLEquations_LinearityTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL CellMLEquations_LinearityTypeSet(cellMLEquations,linearityType,err,error,*999)

    EXITS("cmfe_CellMLEquations_LinearityTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_LinearityTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_LinearityTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the linearity type for CellML equations identified by an object.
  SUBROUTINE cmfe_CellMLEquations_LinearityTypeSetObj(cellMLEquations,linearityType,err)
    !DLLEXPORT(cmfe_CellMLEquations_LinearityTypeSetObj)

    !Argument variables
    TYPE(cmfe_CellMLEquationsType), INTENT(IN) :: cellMLEquations !<The CellML equations to set the linearity type for.
    INTEGER(INTG), INTENT(IN) :: linearityType !<The linearity type of the specified CellML equations to set. \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellMLEquations_LinearityTypeSetObj",err,error,*999)

    CALL CellMLEquations_LinearityTypeSet(cellMLEquations%cellMLEquations,linearityType,err,error,*999)

    EXITS("cmfe_CellMLEquations_LinearityTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_LinearityTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_LinearityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the time dependence type for CellML equations identified by an user number.
  SUBROUTINE cmfe_CellMLEquations_TimeDependenceTypeGetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,timeDependenceType,err)
    !DLLEXPORT(cmfe_CellMLEquations_TimeDependenceTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to get the CellML equations time dependence type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the CellML equations time dependence type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get CellML equations time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On exit, the time dependence type of the specified CellML equations. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_CellMLEquations_TimeDependenceTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL CellMLEquations_TimeDependenceTypeGet(cellMLEquations,timeDependenceType,err,error,*999)

    EXITS("cmfe_CellMLEquations_TimeDependenceTypeGetNumber")
    RETURN
999 ERRORS("cmfe_CellMLEquations_TimeDependenceTypeGetNumber",err,error)
    EXITS("cmfe_CellMLEquations_TimeDependenceTypeGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_TimeDependenceTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the time dependence type for CellML equations identified by an object.
  SUBROUTINE cmfe_CellMLEquations_TimeDependenceTypeGetObj(cellMLEquations,timeDependenceType,err)
    !DLLEXPORT(cmfe_CellMLEquations_TimeDependenceTypeGetObj)

    !Argument variables
    TYPE(cmfe_CellMLEquationsType), INTENT(IN) :: cellMLEquations !<The CellML equations to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On exit, the time dependence type of the specified CellML equations. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellMLEquations_TimeDependenceTypeGetObj",err,error,*999)

    CALL CellMLEquations_TimeDependenceTypeGet(cellMLEquations%cellMLEquations,timeDependenceType,err,error,*999)

    EXITS("cmfe_CellMLEquations_TimeDependenceTypeGetObj")
    RETURN
999 ERRORS("cmfe_CellMLEquations_TimeDependenceTypeGetObj",err,error)
    EXITS("cmfe_CellMLEquations_TimeDependenceTypeGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_TimeDependenceTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the time dependence type for CellML equations identified by an user number.
  SUBROUTINE cmfe_CellMLEquations_TimeDependenceTypeSetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,timeDependenceType,err)
    !DLLEXPORT(cmfe_CellMLEquations_TimeDependenceTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to set the CellML equations time dependence type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the CellML equations time dependence type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set CellML equations time dependence type for.
    INTEGER(INTG), INTENT(IN) :: timeDependenceType !<The time dependence type of the specified CellML equations to set. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_CellMLEquations_TimeDependenceTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL CellMLEquations_TimeDependenceTypeSet(cellMLEquations,timeDependenceType,err,error,*999)

    EXITS("cmfe_CellMLEquations_TimeDependenceTypeSetNumber")
    RETURN
999 ERRORS("cmfe_CellMLEquations_TimeDependenceTypeSetNumber",err,error)
    EXITS("cmfe_CellMLEquations_TimeDependenceTypeSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_TimeDependenceTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the time dependence type for CellML equations identified by an object.
  SUBROUTINE cmfe_CellMLEquations_TimeDependenceTypeSetObj(cellMLEquations,timeDependenceType,err)
    !DLLEXPORT(cmfe_CellMLEquations_TimeDependenceTypeSetObj)

    !Argument variables
    TYPE(cmfe_CellMLEquationsType), INTENT(IN) :: cellMLEquations !<The CellML equations to set the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: timeDependenceType !<The time dependence type of the specified CellML equations to set. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellMLEquations_TimeDependenceTypeSetObj",err,error,*999)

    CALL CellMLEquations_TimeDependenceTypeSet(cellMLEquations%cellMLEquations,timeDependenceType,err,error,*999)

    EXITS("cmfe_CellMLEquations_TimeDependenceTypeSetObj")
    RETURN
999 ERRORS("cmfe_CellMLEquations_TimeDependenceTypeSetObj",err,error)
    EXITS("cmfe_CellMLEquations_TimeDependenceTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_TimeDependenceTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_CellMLEquationsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & cellMLEquations,err)
    !DLLEXPORT(cmfe_Solver_CellMLEquationsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the CellML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_CellMLEquationsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations%cellmlEquations,err,error,*999)

    EXITS("cmfe_Solver_CellMLEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_CellMLEquationsGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_CellMLEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_CellMLEquationsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & cellMLEquations,err)
    !DLLEXPORT(cmfe_Solver_CellMLEquationsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the CelllML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_CellMLEquationsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations%cellmlEquations,err,error,*999)

    EXITS("cmfe_Solver_CellMLEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_CellMLEquationsGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_CellMLEquationsGetNumber1

  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an object.
  SUBROUTINE cmfe_Solver_CellMLEquationsGetObj(solver,cellMLEquations,err)
    !DLLEXPORT(cmfe_Solver_CellMLEquationsGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the CellML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_CellMLEquationsGetObj",err,error,*999)

    CALL Solver_CellMLEquationsGet(solver%solver,cellMLEquations%cellmlEquations,err,error,*999)

    EXITS("cmfe_Solver_CellMLEquationsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_CellMLEquationsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_CellMLEquationsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & DAEEulerSolverType,err)
    !DLLEXPORT(cmfe_Solver_DAEEulerSolverTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DAEEulerSolverTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAEEulerSolverTypeGet(solver,DAEEulerSolverType,err,error,*999)

    EXITS("cmfe_Solver_DAEEulerSolverTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & DAEEulerSolverType,err)
    !DLLEXPORT(cmfe_Solver_DAEEulerSolverTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
 
    ENTERS("cmfe_Solver_DAEEulerSolverTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAEEulerSolverTypeGet(solver,DAEEulerSolverType,err,error,*999)

    EXITS("cmfe_Solver_DAEEulerSolverTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetObj(solver,DAEEulerSolverType,err)
    !DLLEXPORT(cmfe_Solver_DAEEulerSolverTypeGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAEEulerSolverTypeGetObj",err,error,*999)

    CALL Solver_DAEEulerSolverTypeGet(solver%solver,DAEEulerSolverType,err,error,*999)

    EXITS("cmfe_Solver_DAEEulerSolverTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & DAEEulerSolverType,err)
    !DLLEXPORT(cmfe_Solver_DAEEulerSolverTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DAEEulerSolverTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAEEulerSolverTypeSet(solver,DAEEulerSolverType,err,error,*999)

    EXITS("cmfe_Solver_DAEEulerSolverTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & DAEEulerSolverType,err)
    !DLLEXPORT(cmfe_Solver_DAEEulerSolverTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DAEEulerSolverTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAEEulerSolverTypeSet(solver,DAEEulerSolverType,err,error,*999)

    EXITS("cmfe_Solver_DAEEulerSolverTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetObj(solver,DAEEulerSolverType,err)
    !DLLEXPORT(cmfe_Solver_DAEEulerSolverTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAEEulerSolverTypeSetObj",err,error,*999)

    CALL Solver_DAEEulerSolverTypeSet(solver%solver,DAEEulerSolverType,err,error,*999)

    EXITS("cmfe_Solver_DAEEulerSolverTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAESolverTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & DAESolverType,err)
    !DLLEXPORT(cmfe_Solver_DAESolverTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DAESolverTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAESolverTypeGet(solver,DAESolverType,err,error,*999)

    EXITS("cmfe_Solver_DAESolverTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAESolverTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & DAESolverType,err)
    !DLLEXPORT(cmfe_Solver_DAESolverTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
 
    ENTERS("cmfe_Solver_DAESolverTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAESolverTypeGet(solver,DAESolverType,err,error,*999)

    EXITS("cmfe_Solver_DAESolverTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAESolverTypeGetObj(solver,DAESolverType,err)
    !DLLEXPORT(cmfe_Solver_DAESolverTypeGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAESolverTypeGetObj",err,error,*999)

    CALL Solver_DAESolverTypeGet(solver%solver,DAESolverType,err,error,*999)

    EXITS("cmfe_Solver_DAESolverTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAESolverTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & DAESolverType,err)
    !DLLEXPORT(cmfe_Solver_DAESolverTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DAESolverTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAESolverTypeSet(solver,DAESolverType,err,error,*999)

    EXITS("cmfe_Solver_DAESolverTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAESolverTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & DAESolverType,err)
    !DLLEXPORT(cmfe_Solver_DAESolverTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DAESolverTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAESolverTypeSet(solver,DAESolverType,err,error,*999)

    EXITS("cmfe_Solver_DAESolverTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAESolverTypeSetObj(solver,DAESolverType,err)
    !DLLEXPORT(cmfe_Solver_DAESolverTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAESolverTypeSetObj",err,error,*999)

    CALL Solver_DAESolverTypeSet(solver%solver,DAESolverType,err,error,*999)

    EXITS("cmfe_Solver_DAESolverTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAETimesSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & startTime,endTime,err)
    !DLLEXPORT(cmfe_Solver_DAETimesSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
 
    ENTERS("cmfe_Solver_DAETimesSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAETimesSet(solver,startTime,endTime,err,error,*999)

    EXITS("cmfe_Solver_DAETimesSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimesSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAETimesSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & startTime,endTime,err)
    !DLLEXPORT(cmfe_Solver_DAETimesSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DAETimesSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAETimesSet(solver,startTime,endTime,err,error,*999)

    EXITS("cmfe_Solver_DAETimesSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimesSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimesSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAETimesSetObj(solver,startTime,endTime,err)
    !DLLEXPORT(cmfe_Solver_DAETimesSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAETimesSetObj",err,error,*999)

    CALL Solver_DAETimesSet(solver%solver,startTime,endTime,err,error,*999)

    EXITS("cmfe_Solver_DAETimesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAETimeStepSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & timeStep,err)
    !DLLEXPORT(cmfe_Solver_DAETimeStepSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DAETimeStepSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAETimeStepSet(solver,timeStep,err,error,*999)

    EXITS("cmfe_Solver_DAETimeStepSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimeStepSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimeStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAETimeStepSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & timeStep,err)
    !DLLEXPORT(cmfe_Solver_DAETimeStepSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DAETimeStepSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAETimeStepSet(solver,timeStep,err,error,*999)

    EXITS("cmfe_Solver_DAETimeStepSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimeStepSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimeStepSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAETimeStepSetObj(solver,timeStep,err)
    !DLLEXPORT(cmfe_Solver_DAETimeStepSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAETimeStepSetObj",err,error,*999)

    CALL Solver_DAETimeStepSet(solver%solver,timeStep,err,error,*999)

    EXITS("cmfe_Solver_DAETimeStepSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimeStepSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimeStepSetObj

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicDegreeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,degree,err)
    !DLLEXPORT(cmfe_Solver_DynamicDegreeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicDegreeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicDegreeGet(solver,degree,err,error,*999)

    EXITS("cmfe_Solver_DynamicDegreeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicDegreeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,degree,err)
    !DLLEXPORT(cmfe_Solver_DynamicDegreeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic degree for
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicDegreeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicDegreeGet(solver,degree,err,error,*999)

    EXITS("cmfe_Solver_DynamicDegreeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicDegreeGetObj(solver,degree,err)
    !DLLEXPORT(cmfe_Solver_DynamicDegreeGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicDegreeGetObj",err,error,*999)

    CALL Solver_DynamicDegreeGet(solver%solver,degree,err,error,*999)

    EXITS("cmfe_Solver_DynamicDegreeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicDegreeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,degree,err)
    !DLLEXPORT(cmfe_Solver_DynamicDegreeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicDegreeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicDegreeSet(solver,degree,err,error,*999)

    EXITS("cmfe_Solver_DynamicDegreeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicDegreeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,degree,err)
    !DLLEXPORT(cmfe_Solver_DynamicDegreeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the dynamic degree for
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicDegreeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicDegreeSet(solver,degree,err,error,*999)

    EXITS("cmfe_Solver_DynamicDegreeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicDegreeSetObj(solver,degree,err)
    !DLLEXPORT(cmfe_Solver_DynamicDegreeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicDegreeSetObj",err,error,*999)

    CALL Solver_DynamicDegreeSet(solver%solver,degree,err,error,*999)

    EXITS("cmfe_Solver_DynamicDegreeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearityType,err)
    !DLLEXPORT(cmfe_Solver_DynamicLinearityTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OpenCMISS_DynamicLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicLinearityTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinearityTypeGet(solver,linearityType,err,error,*999)

    EXITS("cmfe_Solver_DynamicLinearityTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearityTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & linearityType,err)
    !DLLEXPORT(cmfe_Solver_DynamicLinearityTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OpenCMISS_DynamicLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicLinearityTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinearityTypeGet(solver,linearityType,err,error,*999)

    EXITS("cmfe_Solver_DynamicLinearityTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearityTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetObj(solver,linearityType,err)
    !DLLEXPORT(cmfe_Solver_DynamicLinearityTypeGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OpenCMISS_DynamicLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicLinearityTypeGetObj",err,error,*999)

    CALL Solver_DynamicLinearityTypeGet(solver%solver,linearityType,err,error,*999)

    EXITS("cmfe_Solver_DynamicLinearityTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearityTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & nonlinearSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_DynamicNonlinearSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: nonlinearSolverIndex !<On return, the solver index of the nonlinear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,nonlinearSolver

    ENTERS("cmfe_Solver_DynamicNonlinearSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(nonlinearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinkedNonlinearSolverGet(solver,nonlinearSolver,err,error,*999)
    !todo: get the solver index from nonlinear solver
    nonlinearSolverIndex=nonlinearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_DynamicNonlinearSolverGetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_DynamicNonlinearSolverGetNumber0",err,error)
    EXITS("cmfe_Solver_DynamicNonlinearSolverGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & nonlinearSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_DynamicNonlinearSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: nonlinearSolverIndex !<On return, the dynamic nonlinear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,nonlinearSolver

    ENTERS("cmfe_Solver_DynamicNonlinearSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(nonlinearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinkedNonlinearSolverGet(solver,nonlinearSolver,err,error,*999)
    !todo: get the solver index from nonlinear solver
    nonlinearSolverIndex=nonlinearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_DynamicNonlinearSolverGetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_DynamicNonlinearSolverGetNumber1",err,error)
    EXITS("cmfe_Solver_DynamicNonlinearSolverGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetObj(solver,nonlinearSolver,err)
    !DLLEXPORT(cmfe_Solver_DynamicNonlinearSolverGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic nonlinear solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: nonlinearSolver  !<On return, the dynamic nonlinear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicNonlinearSolverGetObj",err,error,*999)

    CALL Solver_DynamicLinkedNonlinearSolverGet(solver%solver,nonlinearSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_DynamicNonlinearSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicNonlinearSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicLinearSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_DynamicLinearSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver

    ENTERS("cmfe_Solver_DynamicLinearSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_DynamicLinearSolverGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearSolverGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicLinearSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & linearSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_DynamicLinearSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the dynamic linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver

    ENTERS("cmfe_Solver_DynamicLinearSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_DynamicLinearSolverGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearSolverGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicLinearSolverGetObj(solver,linearSolver,err)
    !DLLEXPORT(cmfe_Solver_DynamicLinearSolverGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic linear solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: linearSolver !<On return, the dynamic linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicLinearSolverGetObj",err,error,*999)

    CALL Solver_DynamicLinkedLinearSolverGet(solver%solver,linearSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_DynamicLinearSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicSchemeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,scheme,err)
    !DLLEXPORT(cmfe_Solver_DynamicSchemeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OpenCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicSchemeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicSchemeSet(solver,scheme,err,error,*999)

    EXITS("cmfe_Solver_DynamicSchemeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicSchemeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicSchemeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicSchemeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,scheme,err)
    !DLLEXPORT(cmfe_Solver_DynamicSchemeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OpenCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicSchemeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicSchemeSet(solver,scheme,err,error,*999)

    EXITS("cmfe_Solver_DynamicSchemeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicSchemeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicSchemeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicSchemeSetObj(solver,scheme,err)
    !DLLEXPORT(cmfe_Solver_DynamicSchemeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OpenCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicSchemeSetObj",err,error,*999)

    CALL Solver_DynamicSchemeSet(solver%solver,scheme,err,error,*999)

    EXITS("cmfe_Solver_DynamicSchemeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicSchemeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicSchemeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicThetaSetNumber00(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,theta,err)
    !DLLEXPORT(cmfe_Solver_DynamicThetaSetNumber00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicThetaSetNumber00",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicThetaSet(solver,theta,err,error,*999)

    EXITS("cmfe_Solver_DynamicThetaSetNumber00")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetNumber00",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetNumber00

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicThetaSetNumber01(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,thetas,err)
    !DLLEXPORT(cmfe_Solver_DynamicThetaSetNumber01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicThetaSetNumber01",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicThetaSet(solver,thetas,err,error,*999)

    EXITS("cmfe_Solver_DynamicThetaSetNumber01")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetNumber01",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetNumber01

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicThetaSetNumber10(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,theta,err)
    !DLLEXPORT(cmfe_Solver_DynamicThetaSetNumber10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicThetaSetNumber10",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicThetaSet(solver,theta,err,error,*999)

    EXITS("cmfe_Solver_DynamicThetaSetNumber10")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetNumber10",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetNumber10

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicThetaSetNumber11(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,thetas,err)
    !DLLEXPORT(cmfe_Solver_DynamicThetaSetNumber11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicThetaSetNumber11",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicThetaSet(solver,thetas,err,error,*999)

    EXITS("cmfe_Solver_DynamicThetaSetNumber11")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetNumber11",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetNumber11

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicThetaSetObj0(solver,theta,err)
    !DLLEXPORT(cmfe_Solver_DynamicThetaSetObj0)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicThetaSetObj0",err,error,*999)

    CALL Solver_DynamicThetaSet(solver%solver,theta,err,error,*999)

    EXITS("cmfe_Solver_DynamicThetaSetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetObj0

   !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicThetaSetObj1(solver,thetas,err)
    !DLLEXPORT(cmfe_Solver_DynamicThetaSetObj1)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicThetaSetObj1",err,error,*999)

    CALL Solver_DynamicThetaSet(solver%solver,thetas,err,error,*999)

    EXITS("cmfe_Solver_DynamicThetaSetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicTimesSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & currentTime,timeIncrement,err)
    !DLLEXPORT(cmfe_Solver_DynamicTimesSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_DynamicTimesSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicTimesSet(solver,currentTime,timeIncrement,err,error,*999)

    EXITS("cmfe_Solver_DynamicTimesSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicTimesSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicTimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicTimesSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & currentTime,timeIncrement,err)
    !DLLEXPORT(cmfe_Solver_DynamicTimesSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
 
    ENTERS("cmfe_Solver_DynamicTimeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicTimesSet(solver,currentTime,timeIncrement,err,error,*999)

    EXITS("cmfe_Solver_DynamicTimesSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicTimesSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicTimesSetNumber1
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicTimesSetObj(solver,currentTime,timeIncrement,err)
    !DLLEXPORT(cmfe_Solver_DynamicTimesSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicTimesSetObj",err,error,*999)

    CALL Solver_DynamicTimesSet(solver%solver,currentTime,timeIncrement,err,error,*999)

    EXITS("cmfe_Solver_DynamicTimesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicTimesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicTimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationArbitraryPathSetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,arbitraryPath,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationArbitraryPathSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the arbitrary path for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the arbitrary path for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    LOGICAL, INTENT(IN) :: arbitraryPath !<.TRUE. if the the transformation has an arbitrary path, .FALSE. if the path is uni-directional
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_GeometricTransformationArbitraryPathSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationArbitraryPathSet(solver,arbitraryPath,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationArbitraryPathSetNumber")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationArbitraryPathSetNumber",err,error)
    EXITS("cmfe_Solver_GeometricTransformationArbitraryPathSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationArbitraryPathSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationArbitraryPathSetObj(solver,arbitraryPath,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationArbitraryPathSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the arbitrary path for.
    LOGICAL, INTENT(IN) :: arbitraryPath !<.TRUE. if the the transformation has an arbitrary path, .FALSE. if the path is uni-directional
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationArbitraryPathSetObj",err,error,*999)

    CALL Solver_GeometricTransformationArbitraryPathSet(solver%solver,arbitraryPath,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationArbitraryPathSetObj")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationArbitraryPathSetObj",err,error)
    EXITS("cmfe_Solver_GeometricTransformationArbitraryPathSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationArbitraryPathSetObj

  !
  !================================================================================================================================
  !

  !>Clear transformation a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationClearNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,err)    
    !DLLEXPORT(cmfe_Solver_GeometricTransformationClearNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to clear.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to clear.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_GeometricTransformationClearNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationClear(solver,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationClearNumber")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationClearNumber",err,error)
    EXITS("cmfe_Solver_GeometricTransformationClearNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationClearNumber

  !
  !================================================================================================================================
  !

  !>Clear transformation for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationClearObj(solver,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationClearObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to clear
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationClearObj",err,error,*999)

    CALL Solver_GeometricTransformationClear(solver%solver,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationClearObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_GeometricTransformationClearObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationClearObj

  !
  !================================================================================================================================
  !

  !>Sets the field for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationFieldSetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,regionUserNumber,fieldUserNumber,variableType,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationFieldSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number for the field
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the transformation for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_GeometricTransformationFieldSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(regions)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(field)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Solver_GeometricTransformationFieldSet(solver,field,variableType,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationFieldSetNumber")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationFieldSetNumber",err,error)
    EXITS("cmfe_Solver_GeometricTransformationFieldSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationFieldSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the field for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationFieldSetObj(solver,field,variableType,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationFieldSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the field for.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field for the solver to set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the transformation for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationFieldSetObj",err,error,*999)

    CALL Solver_GeometricTransformationFieldSet(solver%solver,field%field,variableType,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationFieldSetObj")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationFieldSetObj",err,error)
    EXITS("cmfe_Solver_GeometricTransformationFieldSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationFieldSetObj

  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,matrix,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationMatrixSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_GeometricTransformationMatrixSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationMatrixSet(solver,1,matrix,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationMatrixSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationMatrixSetNumber0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationMatrixSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetObj0(solver,matrix,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationMatrixSetObj0)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationMatrixSetObj0",err,error,*999)

    CALL Solver_GeometricTransformationMatrixSet(solver%solver,1,matrix,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationMatrixSetObj0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationMatrixSetObj0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationMatrixSetObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetObj0

  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,loadIncrementIdx,matrix,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationMatrixSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_GeometricTransformationMatrixSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationMatrixSet(solver,loadIncrementIdx,matrix,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationMatrixSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationMatrixSetNumber1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationMatrixSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix vector at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetObj1(solver,loadIncrementIdx,matrix,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationMatrixSetObj1)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationMatrixSetObj1",err,error,*999)

    CALL Solver_GeometricTransformationMatrixSet(solver%solver,loadIncrementIdx,matrix,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationMatrixSetObj1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationMatrixSetObj1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationMatrixSetObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetObj1

  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetNumber(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifier,solverIndex,numberOfIncrements,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationNoLoadIncrementsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(IN) :: numberOfIncrements !<The number of load increments to apply the transformation
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_GeometricTransformationNoLoadIncrementsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationNumberOfLoadIncrementsSet(solver,numberOfIncrements,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationNoLoadIncrementsSetNumber")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationNoLoadIncrementsSetNumber",err,error)
    EXITS("cmfe_Solver_GeometricTransformationNoLoadIncrementsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetObj(solver,numberOfIncrements,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationNoLoadIncrementsSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: numberOfIncrements !<The number of load increments to apply the transformation
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationNoLoadIncrementsSetObj",err,error,*999)

    CALL Solver_GeometricTransformationNumberOfLoadIncrementsSet(solver%solver,numberOfIncrements,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationNoLoadIncrementsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationNoLoadIncrementsSetObj",err,error)
    EXITS("cmfe_Solver_GeometricTransformationNoLoadIncrementsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetObj

  !
  !================================================================================================================================
  !

  !>Sets the rotation for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,pivotPoint,axis,angle,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationRotationSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_GeometricTransformationRotationSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationRotationSet(solver,1,pivotPoint,axis,angle,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationRotationSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationRotationSetNumber0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationRotationSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the rotation for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetObj0(solver,pivotPoint,axis,angle,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationRotationSetObj0)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationRotationSetObj0",err,error,*999)

    CALL Solver_GeometricTransformationRotationSet(solver%solver,1,pivotPoint,axis,angle,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationRotationSetObj0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationRotationSetObj0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationRotationSetObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetObj0

  !
  !================================================================================================================================
  !

  !>Sets the rotation at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,loadIncrementIdx,pivotPoint,axis,angle,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationRotationSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_GeometricTransformationRotationSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationRotationSet(solver,loadIncrementIdx,pivotPoint,axis,angle,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationRotationSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationRotationSetNumber1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationRotationSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the rotation at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetObj1(solver,loadIncrementIdx,pivotPoint,axis,angle,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationRotationSetObj1)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationRotationSetObj1",err,error,*999)

    CALL Solver_GeometricTransformationRotationSet(solver%solver,loadIncrementIdx,pivotPoint,axis,angle,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationRotationSetObj1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationRotationSetObj1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationRotationSetObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetObj1

  !
  !================================================================================================================================
  !

  !>Sets the scalings for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationScalingsSetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,scalings,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationScalingsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scalings for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the scalings for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scalings for.
    REAL(DP), INTENT(IN) :: scalings(:) !<The scalings to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_GeometricTransformationScalingsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationScalingsSet(solver,scalings,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationScalingsSetNumber")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationScalingsSetNumber",err,error)
    EXITS("cmfe_Solver_GeometricTransformationScalingsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationScalingsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the scalings for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationScalingsSetObj(solver,scalings,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationScalingsSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the scalings for.
    REAL(DP), INTENT(IN) :: scalings(:) !<The scalings to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationScalingsSetObj",err,error,*999)

    CALL Solver_GeometricTransformationScalingsSet(solver%solver,scalings,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationScalingsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationScalingsSetObj",err,error)
    EXITS("cmfe_Solver_GeometricTransformationScalingsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationScalingsSetObj

  !
  !================================================================================================================================
  !

  !>Sets the translation for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,translation,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationTranslationSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_GeometricTransformationTranslationSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationTranslationSet(solver,1,translation,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationTranslationSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationTranslationSetNumber0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationTranslationSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the translation vector for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetObj0(solver,translation,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationTranslationSetObj0)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationTranslationSetObj0",err,error,*999)

    CALL Solver_GeometricTransformationTranslationSet(solver%solver,1,translation,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationTranslationSetObj0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationTranslationSetObj0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationTranslationSetObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetObj0

  !
  !================================================================================================================================
  !

  !>Sets the translation at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,loadIncrementIdx,translation,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationTranslationSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the translation for.
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_GeometricTransformationTranslationSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationTranslationSet(solver,loadIncrementIdx,translation,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationTranslationSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationTranslationSetNumber1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationTranslationSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the translation vector at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetObj1(solver,loadIncrementIdx,translation,err)
    !DLLEXPORT(cmfe_Solver_GeometricTransformationTranslationSetObj1)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the translation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationTranslationSetObj1",err,error,*999)

    CALL Solver_GeometricTransformationTranslationSet(solver%solver,loadIncrementIdx,translation,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationTranslationSetObj1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationTranslationSetObj1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationTranslationSetObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetObj1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelGetCNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,label,err)
    !DLLEXPORT(cmfe_Solver_LabelGetCNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LabelGetCNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LabelGet(solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelGetCNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetCNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetCNumber0

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelGetCNumber1(contextUserNUmber,problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)
    !DLLEXPORT(cmfe_Solver_LabelGetCNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LabelGetCNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LabelGet(solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelGetCNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetCNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetCNumber1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LabelGetCObj(solver,label,err)
    !DLLEXPORT(cmfe_Solver_LabelGetCObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LabelGetCObj",err,error,*999)

    CALL Solver_LabelGet(solver%solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelGetVSNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,label,err)
    !DLLEXPORT(cmfe_Solver_LabelGetVSNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LabelGetVSNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LabelGet(solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelGetVSNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetVSNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetVSNumber0

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelGetVSNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)
    !DLLEXPORT(cmfe_Solver_LabelGetVSNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The solver identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LabelGetVSNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LabelGet(solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelGetVSNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetVSNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetVSNumber1

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LabelGetVSObj(solver,label,err)
    !DLLEXPORT(cmfe_Solver_LabelGetVSObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LabelGetVSObj",err,error,*999)

    CALL Solver_LabelGet(solver%solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelSetCNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,label,err)
    !DLLEXPORT(cmfe_Solver_LabelSetCNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LabelSetCNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LabelSet(solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelSetCNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetCNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetCNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelSetCNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)
    !DLLEXPORT(cmfe_Solver_LabelSetCNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The solver identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LabelSetCNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LabelSet(solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelSetCNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetCNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetCNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LabelSetCObj(solver,label,err)
    !DLLEXPORT(cmfe_Solver_LabelSetCObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LabelSetCObj",err,error,*999)

    CALL Solver_LabelSet(solver%solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelSetVSNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,label,err)
    !DLLEXPORT(cmfe_Solver_LabelSetVSNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The solver identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LabelSetVSNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LabelSet(solver,CHAR(label),err,error,*999)

    EXITS("cmfe_Solver_LabelSetVSNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetVSNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetVSNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelSetVSNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)
    !DLLEXPORT(cmfe_Solver_LabelSetVSNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LabelSetVSNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LabelSet(solver,CHAR(label),err,error,*999)

    EXITS("cmfe_Solver_LabelSetVSNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetVSNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetVSNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LabelSetVSObj(solver,label,err)
    !DLLEXPORT(cmfe_Solver_LabelSetVSObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LabelSetVSObj",err,error,*999)

    CALL Solver_LabelSet(solver%solver,CHAR(label),err,error,*999)

    EXITS("cmfe_Solver_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the type of library for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LibraryTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & libraryType,err)    
    !DLLEXPORT(cmfe_Solver_LibraryTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LibraryTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LibraryTypeGet(solver,libraryType,err,error,*999)

    EXITS("cmfe_Solver_LibraryTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the library type for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LibraryTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & libraryType,err)
    !DLLEXPORT(cmfe_Solver_LibraryTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LibraryTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LibraryTypeGet(solver,libraryType,err,error,*999)

    EXITS("cmfe_Solver_LibraryTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeGetNumber1

  !================================================================================================================================
  !

  !>Returns the library type for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LibraryTypeGetObj(solver,libraryType,err)
    !DLLEXPORT(cmfe_Solver_LibraryTypeGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LibraryTypeGetObj",err,error,*999)

    CALL Solver_LibraryTypeGet(solver%solver,libraryType,err,error,*999)

    EXITS("cmfe_Solver_LibraryTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LibraryTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & libraryType,err)
    !DLLEXPORT(cmfe_Solver_LibraryTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LibraryTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LibraryTypeSet(solver,libraryType,err,error,*999)

    EXITS("cmfe_Solver_LibraryTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the library type for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LibraryTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & libraryType,err)
    !DLLEXPORT(cmfe_Solver_LibraryTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LibraryTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LibraryTypeSet(solver,libraryType,err,error,*999)

    EXITS("cmfe_Solver_LibraryTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the library type for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LibraryTypeSetObj(solver,libraryType,err)
    !DLLEXPORT(cmfe_Solver_LibraryTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LibraryTypeSetObj",err,error,*999)

    CALL Solver_LibraryTypeSet(solver%solver,libraryType,err,error,*999)

    EXITS("cmfe_Solver_LibraryTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearDirectTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & directSolverType,err)
    !DLLEXPORT(cmfe_Solver_LinearDirectTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OpenCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearDirectTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearDirectTypeSet(solver,directSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearDirectTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearDirectTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearDirectTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearDirectTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & directSolverType,err)
    !DLLEXPORT(cmfe_Solver_LinearDirectTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OpenCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearDirectTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearDirectTypeSet(solver,directSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearDirectTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearDirectTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearDirectTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearDirectTypeSetObj(solver,directSolverType,err)
    !DLLEXPORT(cmfe_Solver_LinearDirectTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OpenCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearDirectTypeSetObj",err,error,*999)

    CALL Solver_LinearDirectTypeSet(solver%solver,directSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearDirectTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearDirectTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearDirectTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the MUMPS ICNTL(icntl)=ivalue integer control parameters through the PETSc-MUMPS interface. Must be called after the boundary conditions have been set up.
  SUBROUTINE cmfe_Solver_MumpsSetIcntl(solver,icntl,ivalue,err)
    !DLLEXPORT(cmfe_Solver_MumpsSetIcntl)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: icntl !<The MUMPS ICNTL integer control parameter
    INTEGER(INTG), INTENT(IN) :: ivalue !<The MUMPS ICNTL integer value to set: ICNTL(icntl)=ivalue
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_MumpsSetIcntl",err,error,*999)

    CALL Solver_MumpsSetIcntl(solver%solver,icntl,ivalue,err,error,*999)

    EXITS("cmfe_Solver_MumpsSetIcntl")
    RETURN
999 ERRORSEXITS("cmfe_Solver_MumpsSetIcntl",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_MumpsSetIcntl

  !
  !================================================================================================================================
  !

  !>Sets/changes the MUMPS CNTL(icntl)=val real/complex control parameters through the PETSc-MUMPS interface. Must be called after the boundary conditions have been set up.
  SUBROUTINE cmfe_Solver_MumpsSetCntl(solver,icntl,val,err)
    !DLLEXPORT(cmfe_Solver_MumpsSetCntl)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: icntl !<The MUMPS CNTL integer control parameter
    REAL(DP), INTENT(IN) :: val !<The MUMPS CNTL real value to set: CNTL(icntl)=val
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_MumpsSetCntl",err,error,*999)

    CALL Solver_MumpsSetCntl(solver%solver,icntl,val,err,error,*999)

    EXITS("cmfe_Solver_MumpsSetCntl")
    RETURN
999 ERRORSEXITS("cmfe_Solver_MumpsSetCntl",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_MumpsSetCntl

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,absoluteTolerance,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,absoluteTolerance,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
 
    ENTERS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj(solver,absoluteTolerance,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj",err,error,*999)

    CALL Solver_LinearIterativeAbsoluteToleranceSet(solver%solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,divergenceTolerance,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeDivergenceToleranceSet(solver,divergenceTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,divergenceTolerance,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
   
    ENTERS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeDivergenceToleranceSet(solver,divergenceTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetObj(solver,divergenceTolerance,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeDivergenceToleranceSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeDivergenceToleranceSetObj",err,error,*999)

    CALL Solver_LinearIterativeDivergenceToleranceSet(solver%solver,divergenceTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeDivergenceToleranceSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,GMRESRestart,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeGMRESRestartSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the GMRES restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeGMRESRestartSet(solver,GMRESRestart,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,GMRESRestart,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeGMRESRestartSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeGMRESRestartSet(solver,GMRESRestart,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetObj(solver,GMRESRestart,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeGMRESRestartSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeGMRESRestartSetObj",err,error,*999)

    CALL Solver_LinearIterativeGMRESRestartSet(solver%solver,GMRESRestart,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeGMRESRestartSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,maximumIterations,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeMaximumIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,maximumIterations,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeMaximumIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetObj(solver,maximumIterations,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeMaximumIterationsSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeMaximumIterationsSetObj",err,error,*999)

    CALL Solver_LinearIterativeMaximumIterationsSet(solver%solver,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeMaximumIterationsSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,preconditionerType,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OpenCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativePreconditionerTypeSet(solver,preconditionerType,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,preconditionerType,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OpenCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativePreconditionerTypeSet(solver,preconditionerType,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetObj(solver,preconditionerType,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativePreconditionerTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OpenCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativePreconditionerTypeSetObj",err,error,*999)

    CALL Solver_LinearIterativePreconditionerTypeSet(solver%solver,preconditionerType,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativePreconditionerTypeSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,relativeTolerance,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,relativeTolerance,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetObj(solver,relativeTolerance,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeRelativeToleranceSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeRelativeToleranceSetObj",err,error,*999)

    CALL Solver_LinearIterativeRelativeToleranceSet(solver%solver,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeRelativeToleranceSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & iterativeSolverType,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OpenCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativeTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeTypeSet(solver,iterativeSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearIterativeTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & iterativeSolverType,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OpenCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearIterativeTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeTypeSet(solver,iterativeSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearIterativeTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeTypeSetObj(solver,iterativeSolverType,err)
    !DLLEXPORT(cmfe_Solver_LinearIterativeTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OpenCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeTypeSetObj",err,error,*999)

    CALL Solver_LinearIterativeTypeSet(solver%solver,iterativeSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearIterativeTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearSolverType,err)
    !DLLEXPORT(cmfe_Solver_LinearTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OpenCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_LinearTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearTypeSet(solver,linearSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & linearSolverType,err)
    !DLLEXPORT(cmfe_Solver_LinearTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OpenCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
 
    ENTERS("cmfe_Solver_LinearTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearTypeSet(solver,linearSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearTypeSetObj(solver,linearSolverType,err)
    !DLLEXPORT(cmfe_Solver_LinearTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OpenCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearTypeSetObj",err,error,*999)

    CALL Solver_LinearTypeSet(solver%solver,linearSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & absoluteTolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonAbsoluteToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & absoluteTolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonAbsoluteToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetObj(solver,absoluteTolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonAbsoluteToleranceSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonAbsoluteToleranceSetObj",err,error,*999)

    CALL Solver_NewtonAbsoluteToleranceSet(solver%solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonAbsoluteToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonAbsoluteToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,monitorLinesearchFlag,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLineSearchMonitorOutputSet(solver,monitorLinesearchFlag,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,monitorLinesearchFlag,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLineSearchMonitorOutputSet(solver,monitorLinesearchFlag,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1

  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetObj(solver,monitorLinesearchFlag,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchMonitorOutputSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLineSearchMonitorOutputSetObj",err,error,*999)

    CALL Solver_NewtonLineSearchMonitorOutputSet(solver%solver,monitorLinesearchFlag,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetObj")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchMonitorOutputSetObj",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,jacobianCalculationType,err)
    !DLLEXPORT(cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonJacobianCalculationTypeSet(solver,jacobianCalculationType,err,error,*999)

    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,jacobianCalculationType,err)
    !DLLEXPORT(cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonJacobianCalculationTypeSet(solver,jacobianCalculationType,err,error,*999)

    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetObj(solver,jacobianCalculationType,err)
    !DLLEXPORT(cmfe_Solver_NewtonJacobianCalculationTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonJacobianCalculationTypeSetObj",err,error,*999)

    CALL Solver_NewtonJacobianCalculationTypeSet(solver%solver,jacobianCalculationType,err,error,*999)

    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetObj")
    RETURN
999 ERRORS("cmfe_Solver_NewtonJacobianCalculationTypeSetObj",err,error)
    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLinearSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_NewtonLinearSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver

    ENTERS("cmfe_Solver_NewtonLinearSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_NewtonLinearSolverGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLinearSolverGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLinearSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & linearSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_NewtonLinearSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the Newton linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver

    ENTERS("cmfe_Solver_NewtonLinearSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_NewtonLinearSolverGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLinearSolverGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLinearSolverGetObj(solver,linearSolver,err)
    !DLLEXPORT(cmfe_Solver_NewtonLinearSolverGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the Newton linear solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: linearSolver !<On return, the Newton linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLinearSolverGetObj",err,error,*999)

    CALL Solver_NewtonLinkedLinearSolverGet(solver%solver,linearSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_NewtonLinearSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLinearSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & cellMLSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_NewtonCellMLSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: cellMLSolverIndex !<On return, the solver index of the CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,cellMLSolver

    ENTERS("cmfe_Solver_NewtonCellMLSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
    !todo: get the solver index from CellML solver
    cellMLSolverIndex=cellMLSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_NewtonCellMLSolverGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonCellMLSolverGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & cellMLSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_NewtonCellMLSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: cellMLSolverIndex !<On return, the Newton CellML solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,cellMLSolver

    ENTERS("cmfe_Solver_NewtonCellMLSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
    !todo: get the solver index from CellML solver
    cellMLSolverIndex=cellMLSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_NewtonCellMLSolverGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonCellMLSolverGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetObj(solver,CellMLSolver,err)
    !DLLEXPORT(cmfe_Solver_NewtonCellMLSolverGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the Newton CellML solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: CellMLSolver !<On return, the Newton CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonCellMLSolverGetObj",err,error,*999)

    CALL Solver_NewtonLinkedCellMLSolverGet(solver%solver,CellMLSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_NewtonCellMLSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonCellMLSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for an Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, & 
    & solverIndex,convergenceTestType,err)
    !DLLEXPORT(cmfe_Solver_NewtonConvergenceTestTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)

    EXITS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,convergenceTestType,err)
    !DLLEXPORT(cmfe_Solver_NewtonConvergenceTestTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)

    EXITS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetObj(solver,convergenceTestType,err)
    !DLLEXPORT(cmfe_Solver_NewtonConvergenceTestTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonConvergenceTestTypeSetObj",err,error,*999)

    CALL Solver_NewtonConvergenceTestTypeSet(solver%solver,convergenceTestType,err,error,*999)

    EXITS("cmfe_Solver_NewtonConvergenceTestTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonConvergenceTestTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for an Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,alpha,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchAlphaSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonLineSearchAlphaSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchAlphaSet(solver,alpha,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchAlphaSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchAlphaSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for a Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & alpha,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchAlphaSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonLineSearchAlphaSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchAlphaSet(solver,alpha,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchAlphaSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchAlphaSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for a Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetObj(solver,alpha,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchAlphaSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLineSearchAlphaSetObj",err,error,*999)

    CALL Solver_NewtonLinesearchAlphaSet(solver%solver,alpha,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchAlphaSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchAlphaSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for an Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,maxStep,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchMaxStepSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchMaxStepSet(solver,maxStep,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,maxStep,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchMaxStepSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchMaxStepSet(solver,maxStep,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetObj(solver,maxStep,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchMaxStepSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLineSearchMaxStepSetObj",err,error,*999)

    CALL Solver_NewtonLinesearchMaxStepSet(solver%solver,maxStep,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchMaxStepSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchMaxStepSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for an Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,stepTol,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchStepTolSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
 
    ENTERS("cmfe_Solver_NewtonLineSearchStepTolSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchStepToleranceSet(solver,stepTol,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchStepTolSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchStepTolSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchStepTolSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,stepTol,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchStepTolSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonLineSearchStepTolSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchStepToleranceSet(solver,stepTol,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchStepTolSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchStepTolSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchStepTolSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetObj(solver,stepTol,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchStepTolSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLineSearchStepTolSetObj",err,error,*999)

    CALL Solver_NewtonLinesearchStepToleranceSet(solver%solver,stepTol,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchStepTolSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchStepTolSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search type for an Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetNumber0(contextUserNUmber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & lineSearchType,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OpenCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonLineSearchTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchTypeSet(solver,lineSearchType,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & lineSearchType,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OpenCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonLineSearchTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchTypeSet(solver,lineSearchType,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetObj(solver,lineSearchType,err)
    !DLLEXPORT(cmfe_Solver_NewtonLineSearchTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OpenCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLineSearchTypeSetObj",err,error,*999)

    CALL Solver_NewtonLinesearchTypeSet(solver%solver,lineSearchType,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,maximumFunctionEvaluations,err)
    !DLLEXPORT(cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonMaximumFunctionEvaluationsSet(solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,maximumFunctionEvaluations,err)
    !DLLEXPORT(cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonMaximumFunctionEvaluationsSet(solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj(solver,maximumFunctionEvaluations,err)
    !DLLEXPORT(cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the maximum number of function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj",err,error,*999)

    CALL Solver_NewtonMaximumFunctionEvaluationsSet(solver%solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj",err,error)
    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,maximumIterations,err)
    !DLLEXPORT(cmfe_Solver_NewtonMaximumIterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonMaxNumberOfIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_NewtonMaximumIterationsSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonMaximumIterationsSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonMaximumIterationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,maximumIterations,err)
    !DLLEXPORT(cmfe_Solver_NewtonMaximumIterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonMaxNumberOfIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_NewtonMaximumIterationsSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonMaximumIterationsSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonMaximumIterationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetObj(solver,maximumIterations,err)
    !DLLEXPORT(cmfe_Solver_NewtonMaximumIterationsSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonMaximumIterationsSetObj",err,error,*999)

    CALL Solver_NewtonMaxNumberOfIterationsSet(solver%solver,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_NewtonMaximumIterationsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonMaximumIterationsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,relativeTolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonRelativeToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonRelativeToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonRelativeToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonRelativeToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,relativeTolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonRelativeToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonRelativeToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonRelativeToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonRelativeToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetObj(solver,relativeTolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonRelativeToleranceSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonRelativeToleranceSetObj",err,error,*999)

    CALL Solver_NewtonRelativeToleranceSet(solver%solver,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonRelativeToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonRelativeToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
      & solutionTolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonSolutionToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonSolutionToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonSolutionToleranceSet(solver,solutionTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonSolutionToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonSolutionToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonSolutionToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetNumber1(contextUserNUmber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,solutionTolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonSolutionToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The absolulte tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonSolutionToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonSolutionToleranceSet(solver,solutionTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonSolutionToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonSolutionToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonSolutionToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetObj(solver,solutionTolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonSolutionToleranceSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonSolutionToleranceSetObj",err,error,*999)

    CALL Solver_NewtonSolutionToleranceSet(solver%solver,solutionTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonSolutionToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonSolutionToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,delta0,err)
    !DLLEXPORT(cmfe_Solver_NewtonTrustRegionDelta0SetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTrustregionDelta0Set(solver,delta0,err,error,*999)

    EXITS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,delta0,err)
    !DLLEXPORT(cmfe_Solver_NewtonTrustRegionDelta0SetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTrustregionDelta0Set(solver,delta0,err,error,*999)

    EXITS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetObj(solver,delta0,err)
    !DLLEXPORT(cmfe_Solver_NewtonTrustRegionDelta0SetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton trust region solver to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonTrustRegionDelta0SetObj",err,error,*999)

    CALL Solver_NewtonTrustregionDelta0Set(solver%solver,delta0,err,error,*999)

    EXITS("cmfe_Solver_NewtonTrustRegionDelta0SetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonTrustRegionDelta0SetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,tolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonTrustRegionToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTrustregionToleranceSet(solver,tolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,tolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonTrustRegionToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTrustregionToleranceSet(solver,tolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetObj(solver,tolerance,err)
    !DLLEXPORT(cmfe_Solver_NewtonTrustRegionToleranceSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton trust region solver to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonTrustRegionToleranceSetObj",err,error,*999)

    CALL Solver_NewtonTrustregionToleranceSet(solver%solver,tolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_NewtonTrustRegionToleranceSetObj",err,error)
    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & newtonSolveType,err)
    !DLLEXPORT(cmfe_Solver_NewtonTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OpenCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTypeSet(solver,newtonSolveType,err,error,*999)

    EXITS("cmfe_Solver_NewtonTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & newtonSolveType,err)
    !DLLEXPORT(cmfe_Solver_NewtonTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OpenCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NewtonTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTypeSet(solver,newtonSolveType,err,error,*999)

    EXITS("cmfe_Solver_NewtonTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonTypeSetObj(solver,newtonSolveType,err)
    !DLLEXPORT(cmfe_Solver_NewtonTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OpenCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonTypeSetObj",err,error,*999)

    CALL Solver_NewtonTypeSet(solver%solver,newtonSolveType,err,error,*999)

    EXITS("cmfe_Solver_NewtonTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTypeSetObj

  !
  !================================================================================================================================
  !
  !>Sets/changes the absolute tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,absoluteTolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,absoluteTolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj(solver,absoluteTolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj",err,error,*999)

    CALL Solver_QuasiNewtonAbsoluteToleranceSet(solver%solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0(contextUserNumber,problemUserNumber, &
      & controlLoopIdentifier,solverIndex,monitorLinesearchFlag,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(solver,monitorLinesearchFlag,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,monitorLinesearchFlag,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(solver,monitorLinesearchFlag,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1

  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj(solver,monitorLinesearchFlag,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj",err,error,*999)

    CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(solver%solver,monitorLinesearchFlag,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,jacobianCalculationType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonJacobianCalculationTypeSet(solver,jacobianCalculationType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifiers,solverIndex,jacobianCalculationType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonJacobianCalculationTypeSet(solver,jacobianCalculationType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj(solver,jacobianCalculationType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonJacobianCalculationTypeSet(solver%solver,jacobianCalculationType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,linearSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLinearSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver
 
    ENTERS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,linearSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLinearSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the Quasi-Newton linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver

    ENTERS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetObj(solver,linearSolver,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLinearSolverGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the Quasi-Newton linear solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: linearSolver !<On return, the Quasi-Newton linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonLinearSolverGetObj",err,error,*999)

    CALL Solver_QuasiNewtonLinkedLinearSolverGet(solver%solver,linearSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLinearSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonLinearSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,cellMLSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: cellMLSolverIndex !<On return, the solver index of the CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,cellMLSolver

    ENTERS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
    !todo: get the solver index from CellML solver
    cellMLSolverIndex=cellMLSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,cellMLSolverIndex,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: cellMLSolverIndex !<On return, the Quasi-Newton CellML solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,cellMLSolver

    ENTERS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
    !todo: get the solver index from CellML solver
    cellMLSolverIndex=cellMLSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetObj(solver,CellMLSolver,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonCellMLSolverGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the Quasi-Newton CellML solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: CellMLSolver !<On return, the Quasi-Newton CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonCellMLSolverGetObj",err,error,*999)

    CALL Solver_QuasiNewtonLinkedCellMLSolverGet(solver%solver,CellMLSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,convergenceTestType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,convergenceTestType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj(solver,convergenceTestType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver%solver,convergenceTestType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,maxStep,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchMaxStepSet(solver,maxStep,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,maxStep,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchMaxStepSet(solver,maxStep,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj(solver,maxStep,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj",err,error,*999)

    CALL Solver_QuasiNewtonLinesearchMaxStepSet(solver%solver,maxStep,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,stepTol,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchStepToleranceSet(solver,stepTol,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,stepTol,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchStepToleranceSet(solver,stepTol,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj(solver,stepTol,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj",err,error,*999)

    CALL Solver_QuasiNewtonLinesearchStepToleranceSet(solver%solver,stepTol,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search type for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,lineSearchType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OpenCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchTypeSet(solver,lineSearchType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,lineSearchType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OpenCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchTypeSet(solver,lineSearchType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetObj(solver,lineSearchType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonLineSearchTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OpenCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonLinesearchTypeSet(solver%solver,lineSearchType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifier,solverIndex,maximumFunctionEvaluations,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonMaximumFunctionEvaluationsSet(solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifiers,solverIndex,maximumFunctionEvaluations,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonMaximumFunctionEvaluationsSet(solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj(solver,maximumFunctionEvaluations,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the maximum number of function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj",err,error,*999)

    CALL Solver_QuasiNewtonMaximumFunctionEvaluationsSet(solver%solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,maximumIterations,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonMaxNumberOfIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,maximumIterations,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonMaxNumberOfIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetObj(solver,maximumIterations,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonMaximumIterationsSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonMaximumIterationsSetObj",err,error,*999)

    CALL Solver_QuasiNewtonMaxNumberOfIterationsSet(solver%solver,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumIterationsSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,relativeTolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,relativeTolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetObj(solver,relativeTolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonRelativeToleranceSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonRelativeToleranceSetObj",err,error,*999)

    CALL Solver_QuasiNewtonRelativeToleranceSet(solver%solver,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonRelativeToleranceSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,solutionTolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonSolutionToleranceSet(solver,solutionTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,solutionTolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The absolulte tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonSolutionToleranceSet(solver,solutionTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetObj(solver,solutionTolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonSolutionToleranceSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonSolutionToleranceSetObj",err,error,*999)

    CALL Solver_QuasiNewtonSolutionToleranceSet(solver%solver,solutionTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonSolutionToleranceSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,delta0,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTrustregionDelta0Set(solver,delta0,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,delta0,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTrustregionDelta0Set(solver,delta0,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj(solver,delta0,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton trust region solver to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj",err,error,*999)

    CALL Solver_QuasiNewtonTrustregionDelta0Set(solver%solver,delta0,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,tolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTrustRegionToleranceSet(solver,tolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,tolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTrustRegionToleranceSet(solver,tolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj(solver,tolerance,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton trust region solver to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj",err,error,*999)

    CALL Solver_QuasiNewtonTrustRegionToleranceSet(solver%solver,tolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonRestart,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonRestartSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonRestartSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRestartNumberSet(solver,quasiNewtonRestart,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRestartSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonRestartSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonRestart,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonRestartSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonRestartSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRestartNumberSet(solver,quasiNewtonRestart,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRestartSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonRestartSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetObj(solver,quasiNewtonRestart,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonRestartSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonRestartSetObj",err,error,*999)

    CALL Solver_QuasiNewtonRestartNumberSet(solver%solver,quasiNewtonRestart,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRestartSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonRestartSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonRestartType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonRestartTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRestartTypeSet(solver,quasiNewtonRestartType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonRestartType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonRestartTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRestartTypeSet(solver,quasiNewtonRestartType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetObj(solver,quasiNewtonRestartType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonRestartTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonRestartTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonRestartTypeSet(solver%solver,quasiNewtonRestartType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRestartTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonRestartTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonScaleType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonScaleTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonScaleTypeSet(solver,quasiNewtonScaleType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonScaleType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonScaleTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonScaleTypeSet(solver,quasiNewtonScaleType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetObj(solver,quasiNewtonScaleType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonScaleTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonScaleTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonScaleTypeSet(solver%solver,quasiNewtonScaleType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonScaleTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonScaleTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonSolveType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonSolveTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonSolveTypeSet(solver,quasiNewtonSolveType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonSolveType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonSolveTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonSolveTypeSet(solver,quasiNewtonSolveType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetObj(solver,quasiNewtonSolveType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonSolveTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonSolveTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonSolveTypeSet(solver%solver,quasiNewtonSolveType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonSolveTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonSolveTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OpenCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTypeSet(solver,quasiNewtonType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OpenCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_QuasiNewtonTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTypeSet(solver,quasiNewtonType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetObj(solver,quasiNewtonType,err)
    !DLLEXPORT(cmfe_Solver_QuasiNewtonTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OpenCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonTypeSet(solver%solver,quasiNewtonType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE cmfe_Solver_NonlinearTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & nonlinearSolveType,err)
    !DLLEXPORT(cmfe_Solver_NonlinearTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OpenCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NonlinearTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NonlinearTypeSet(solver,nonlinearSolveType,err,error,*999)

    EXITS("cmfe_Solver_NonlinearTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NonlinearTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NonlinearTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE cmfe_Solver_NonlinearTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & nonlinearSolveType,err)
    !DLLEXPORT(cmfe_Solver_NonlinearTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OpenCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_NonlinearTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NonlinearTypeSet(solver,nonlinearSolveType,err,error,*999)

    EXITS("cmfe_Solver_NonlinearTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NonlinearTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NonlinearTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an object.
  SUBROUTINE cmfe_Solver_NonlinearTypeSetObj(solver,nonlinearSolveType,err)
    !DLLEXPORT(cmfe_Solver_NonlinearTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OpenCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NonlinearTypeSetObj",err,error,*999)

    CALL Solver_NonlinearTypeSet(solver%solver,nonlinearSolveType,err,error,*999)

    EXITS("cmfe_Solver_NonlinearTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NonlinearTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NonlinearTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_OutputTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & outputType,err)
    !DLLEXPORT(cmfe_Solver_OutputTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OpenCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_OutputTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_OutputTypeSet(solver,outputType,err,error,*999)

    EXITS("cmfe_Solver_OutputTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_OutputTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_OutputTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of output for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_OutputTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & outputType,err)
    !DLLEXPORT(cmfe_Solver_OutputTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the output type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OpenCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_OutputTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_OutputTypeSet(solver,outputType,err,error,*999)

    EXITS("cmfe_Solver_OutputTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_OutputTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_OutputTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the output type for a solver identified by an object.
  SUBROUTINE cmfe_Solver_OutputTypeSetObj(solver,outputType,err)
    !DLLEXPORT(cmfe_Solver_OutputTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OpenCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_OutputTypeSetObj",err,error,*999)

    CALL Solver_OutputTypeSet(solver%solver,outputType,err,error,*999)

    EXITS("cmfe_Solver_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_OutputTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_SolverEquationsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & solverEquations,err)
    !DLLEXPORT(cmfe_Solver_SolverEquationsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_SolverEquationsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_Solver_SolverEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_SolverEquationsGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_SolverEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_SolverEquationsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & solverEquations,err)
    !DLLEXPORT(cmfe_Solver_SolverEquationsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("cmfe_Solver_SolverEquationsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_Solver_SolverEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_SolverEquationsGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_SolverEquationsGetNumber1

  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an object.
  SUBROUTINE cmfe_Solver_SolverEquationsGetObj(solver,solverEquations,err)
    !DLLEXPORT(cmfe_Solver_SolverEquationsGetObj)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_SolverEquationsGetObj",err,error,*999)

    CALL Solver_SolverEquationsGet(solver%solver,solverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_Solver_SolverEquationsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_SolverEquationsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_SolverEquationsGetObj

  !
  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_EquationsSetAddNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,equationsSetUserNumber,equationsSetIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_EquationsSetAddNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_EquationsSetAddNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(regions)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL SolverEquations_EquationsSetAdd(solverEquations,equationsSet,equationsSetIndex,err,error,*999)

    EXITS("cmfe_SolverEquations_EquationsSetAddNumber0")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_EquationsSetAddNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_EquationsSetAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_EquationsSetAddNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,equationsSetUserNumber,equationsSetIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_EquationsSetAddNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_EquationsSetAddNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(regions)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL SolverEquations_EquationsSetAdd(solverEquations,equationsSet,equationsSetIndex,err,error,*999)

    EXITS("cmfe_SolverEquations_EquationsSetAddNumber1")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_EquationsSetAddNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_EquationsSetAddNumber1

  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an object.
  SUBROUTINE cmfe_SolverEquations_EquationsSetAddObj(solverEquations,equationsSet,equationsSetIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_EquationsSetAddObj)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to add the equations set for.
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_EquationsSetAddObj",err,error,*999)

    CALL SolverEquations_EquationsSetAdd(solverEquations%solverEquations,equationsSet%equationsSet,equationsSetIndex, &
      & err,error,*999)

    EXITS("cmfe_SolverEquations_EquationsSetAddObj")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_EquationsSetAddObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_EquationsSetAddObj

  !
  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,interfaceRegionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,interfaceConditionIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_InterfaceConditionAddNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface and interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: interfaceRegion
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_InterfaceConditionAddNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(regions)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    NULLIFY(interfaceRegion)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL Region_Get(regions,interfaceRegionUserNumber,interfaceRegion,err,error,*999)
    CALL Region_InterfaceGet(interfaceRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL SolverEquations_InterfaceConditionAdd(solverEquations,interfaceCondition,interfaceConditionIndex,err,error,*999)

    EXITS("cmfe_SolverEquations_InterfaceConditionAddNumber0")
    RETURN
999 ERRORS("cmfe_SolverEquations_InterfaceConditionAddNumber0",err,error)
    EXITS("cmfe_SolverEquations_InterfaceConditionAddNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,interfaceRegionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,interfaceConditionIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_InterfaceConditionAddNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface and interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containting the interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface conditions to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: interfaceRegion
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_InterfaceConditionAddNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(regions)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    NULLIFY(interfaceRegion)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL Region_Get(regions,interfaceRegionUserNumber,interfaceRegion,err,error,*999)
    CALL Region_InterfaceGet(interfaceRegion,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_InterfaceConditionGet(INTERFACE,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL SolverEquations_InterfaceConditionAdd(solverEquations,interfaceCondition,interfaceConditionIndex,err,error,*999)

    EXITS("cmfe_SolverEquations_InterfaceConditionAddNumber1")
    RETURN
999 ERRORS("cmfe_SolverEquations_InterfaceConditionAddNumber1",err,error)
    EXITS("cmfe_SolverEquations_InterfaceConditionAddNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddNumber1

  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an object.
  SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddObj(solverEquations,interfaceCondition,interfaceConditionIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_InterfaceConditionAddObj)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to add the equations set for.
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_InterfaceConditionAddObj",err,error,*999)

    CALL SolverEquations_InterfaceConditionAdd(solverEquations%solverEquations,interfaceCondition%interfaceCondition, &
      & interfaceConditionIndex,err,error,*999)

    EXITS("cmfe_SolverEquations_InterfaceConditionAddObj")
    RETURN
999 ERRORS("cmfe_SolverEquations_InterfaceConditionAddObj",err,error)
    EXITS("cmfe_SolverEquations_InterfaceConditionAddObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddObj

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_SparsityTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & sparsityType,err)
    !DLLEXPORT(cmfe_SolverEquations_SparsityTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type for the solver equations. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_SparsityTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SparsityTypeGet(solverEquations,sparsityType,err,error,*999)

    EXITS("cmfe_SolverEquations_SparsityTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SparsityTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SparsityTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_SparsityTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & sparsityType,err)
    !DLLEXPORT(cmfe_SolverEquations_SparsityTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the solver equations. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_SparsityTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SparsityTypeGet(solverEquations,sparsityType,err,error,*999)

    EXITS("cmfe_SolverEquations_SparsityTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SparsityTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SparsityTypeGetNumber1
  
  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for solver equations identified by an object.
  SUBROUTINE cmfe_SolverEquations_SparsityTypeGetObj(solverEquations,sparsityType,err)
    !DLLEXPORT(cmfe_SolverEquations_SparsityTypeGetObj)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to set the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type for the solver equtaions. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_SparsityTypeGetObj",err,error,*999)

    CALL SolverEquations_SparsityTypeGet(solverEquations%solverEquations,sparsityType,err,error,*999)

    EXITS("cmfe_SolverEquations_SparsityTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SparsityTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SparsityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_SparsityTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & sparsityType,err)
    !DLLEXPORT(cmfe_SolverEquations_SparsityTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_SparsityTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SparsityTypeSet(solverEquations,sparsityType,err,error,*999)

    EXITS("cmfe_SolverEquations_SparsityTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SparsityTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SparsityTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_SparsityTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & sparsityType,err)
    !DLLEXPORT(cmfe_SolverEquations_SparsityTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_SparsityTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SparsityTypeSet(solverEquations,sparsityType,err,error,*999)

    EXITS("cmfe_SolverEquations_SparsityTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SparsityTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SparsityTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an object.
  SUBROUTINE cmfe_SolverEquations_SparsityTypeSetObj(solverEquations,sparsityType,err)
    !DLLEXPORT(cmfe_SolverEquations_SparsityTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_SparsityTypeSetObj",err,error,*999)

    CALL SolverEquations_SparsityTypeSet(solverEquations%solverEquations,sparsityType,err,error,*999)

    EXITS("cmfe_SolverEquations_SparsityTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SparsityTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Gets the symmetry type for solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_SymmetryTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & symmetryType,err)
    !DLLEXPORT(cmfe_SolverEquations_SymmetryTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the  type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the symmetry type for.
    INTEGER(INTG), INTENT(OUT) :: symmetryType !<On return, the solver equations symmetry type. \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_SymmetryTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SymmetryTypeGet(solverEquations,symmetryType,err,error,*999)

    EXITS("cmfe_SolverEquations_SymmetryTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SymmetryTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SymmetryTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the symmetry type for solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_SymmetryTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & symmetryType,err)
    !DLLEXPORT(cmfe_SolverEquations_SymmetryTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the symmetry type for.
    INTEGER(INTG), INTENT(OUT) :: symmetryType !<On return, the symmetry type for the solver equations. \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(SolverMatricesType), POINTER :: solverMatrices

    ENTERS("cmfe_SolverEquations_SymmetryTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    NULLIFY(solverMatrices)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SymmetryTypeGet(solverEquations,symmetryType,err,error,*999)

    EXITS("cmfe_SolverEquations_SymmetryTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SymmetryTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SymmetryTypeGetNumber1
  
  !
  !================================================================================================================================
  !

  !>Gets the symmetry type for solver equations identified by an object.
  SUBROUTINE cmfe_SolverEquations_SymmetryTypeGetObj(solverEquations,symmetryType,err)
    !DLLEXPORT(cmfe_SolverEquations_SymmetryTypeGetObj)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the symmetry type for.
    INTEGER(INTG), INTENT(OUT) :: symmetryType !<On return, the symmetry type for the solver equations. \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_SymmetryTypeGetObj",err,error,*999)

    CALL SolverEquations_SymmetryTypeGet(solverEquations%solverEquations,symmetryType,err,error,*999)

    EXITS("cmfe_SolverEquations_SymmetryTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SymmetryTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SymmetryTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the symmetry type for solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_SymmetryTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & symmetryType,err)
    !DLLEXPORT(cmfe_SolverEquations_SymmetryTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the  type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: symmetryType !<The symmetry type to set. \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_SymmetryTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SymmetryTypeSet(solverEquations,symmetryType,err,error,*999)

    EXITS("cmfe_SolverEquations_SymmetryTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SymmetryTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SymmetryTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the symmetry type for solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_SymmetryTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & symmetryType,err)
    !DLLEXPORT(cmfe_SolverEquations_SymmetryTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: symmetryType !<The symmetry type to set. \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_SymmetryTypesSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SymmetryTypeSet(solverEquations,symmetryType,err,error,*999)

    EXITS("cmfe_SolverEquations_SymmetryTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SymmetryTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SymmetryTypeSetNumber1
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the symmetry types for solver equations identified by an object.
  SUBROUTINE cmfe_SolverEquations_SymmetryTypeSetObj(solverEquations,symmetryType,err)
    !DLLEXPORT(cmfe_SolverEquations_SymmetryTypeSetObj)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: symmetryType !<The symmetry type to set for the solver equations \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_SymmetryTypeSetObj",err,error,*999)

    CALL SolverEquations_SymmetryTypeSet(solverEquations%solverEquations,symmetryType,err,error,*999)

    EXITS("cmfe_SolverEquations_SymmetryTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SymmetryTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SymmetryTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations identified by the user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifier,solverIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to finish the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsCreateFinish(solverEquations,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations identified by the user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifiers,solverIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to finish the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsCreateFinish(solverEquations,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishObj(solverEquations,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsCreateFinishObj)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations containing the boundary conditions to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateFinishObj",err,error,*999)

    CALL SolverEquations_BoundaryConditionsCreateFinish(solverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishObj")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateFinishObj",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishObj

   !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations identified by user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsCreateStart(solverEquations,boundaryConditions,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0

  !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations identified by user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifiers,solverIndex,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsCreateStart(solverEquations,boundaryConditions,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1

  !
  !================================================================================================================================
  !

   !>Start the creation of the boundary conditions for the solver equations
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartObj(solverEquations,boundaryConditions,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsCreateStartObj)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<The solver equations containing the boundary conditions to start.
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, the created boundary conditions.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateStartObj",err,error,*999)

    CALL SolverEquations_BoundaryConditionsCreateStart(solverEquations%solverEquations, &
        & boundaryConditions%boundaryConditions,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartObj")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateStartObj",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations identified by user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,boundaryConditions,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to get the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_BoundaryConditionsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions%boundaryConditions,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsGetNumber0")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsGetNumber0",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetNumber0

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations identified by user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,boundaryConditions,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("cmfe_SolverEquations_BoundaryConditionsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions%boundaryConditions,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsGetNumber1")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsGetNumber1",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetNumber1

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetObj(solverEquations,boundaryConditions,err)
    !DLLEXPORT(cmfe_SolverEquations_BoundaryConditionsGetObj)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the boundary conditions for.
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_SolverEquations_BoundaryConditionsGetObj",err,error,*999)

    CALL SolverEquations_BoundaryConditionsGet(solverEquations%solverEquations,boundaryConditions%boundaryConditions, &
      & err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsGetObj")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsGetObj",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of solver matrices for the solver equations
  SUBROUTINE cmfe_SolverEquations_NumberOfMatricesGet(solverEquations,numberOfMatrices,err)
    !DLLEXPORT(cmfe_SolverEquations_NumberOfMatricesGet)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the number of matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of matrices for the solver equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices

    ENTERS("cmfe_SolverEquations_NumberOfMatricesGet",err,error,*999)

    NULLIFY(solverMatrices)
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_NumberOfSolverMatricesGet(solverMatrices,numberOfMatrices,err,error,*999)

    EXITS("cmfe_SolverEquations_NumberOfMatricesGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_NumberOfMatricesGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_NumberOfMatricesGet

  !
  !================================================================================================================================
  !

  !>Get a solver distributed matrix from the solver equations matrices
  SUBROUTINE cmfe_SolverEquations_MatrixGet(solverEquations,matrixIndex,distributedMatrix,err)
    !DLLEXPORT(cmfe_SolverEquations_MatrixGet)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the distributed matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The solver matrix index to get
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: distributedMatrix !<On return, the requested solver distributed matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices
    TYPE(SolverMatrixType), POINTER :: solverMatrix

    ENTERS("cmfe_SolverEquations_MatrixGet",err,error,*999)

    NULLIFY(solverMatrices)
    NULLIFY(solverMatrix)
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_SolverMatrixGet(solverMatrices,matrixIndex,solverMatrix,err,error,*999)
    CALL SolverMatrix_SolverDistributedMatrixGet(solverMatrix,distributedMatrix%distributedMatrix,err,error,*999)

    EXITS("cmfe_SolverEquations_MatrixGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_MatrixGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_MatrixGet

  !
  !================================================================================================================================
  !

  !>Get the Jacobian distributed matrix from the solver equations matrices for nonlinear solver equations
  SUBROUTINE cmfe_SolverEquations_JacobianMatrixGet(solverEquations,distributedMatrix,err)
    !DLLEXPORT(cmfe_SolverEquations_JacobianMatrixGet)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the Jacobian matrix for
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: distributedMatrix !<On return, the solver equations Jacobian distributed matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices
    TYPE(SolverMatrixType), POINTER :: solverMatrix

    ENTERS("cmfe_SolverEquations_JacobianMatrixGet",err,error,*999)

    NULLIFY(solverMatrices)
    NULLIFY(solverMatrix)
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_SolverMatrixGet(solverMatrices,1,solverMatrix,err,error,*999)
    CALL SolverMatrix_SolverDistributedMatrixGet(solverMatrix,distributedMatrix%distributedMatrix,err,error,*999)

    EXITS("cmfe_SolverEquations_JacobianMatrixGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_JacobianMatrixGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_JacobianMatrixGet

  !
  !================================================================================================================================
  !

  !>Get the distributed vector assiciated with a solver matrix from the solver equations matrices
  SUBROUTINE cmfe_SolverEquations_VectorGet(solverEquations,matrixIndex,distributedVector,err)
    !DLLEXPORT(cmfe_SolverEquations_VectorGet)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the distributed vector for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The solver matrix index to get the vector for
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: distributedVector !<On return, the requested solver matrix distributed vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices
    TYPE(SolverMatrixType), POINTER :: solverMatrix

    ENTERS("cmfe_SolverEquations_VectorGet",err,error,*999)

    NULLIFY(solverMatrices)
    NULLIFY(solverMatrix)    
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_SolverMatrixGet(solverMatrices,matrixIndex,solverMatrix,err,error,*999)
    CALL SolverMatrix_SolverDistributedVectorGet(solverMatrix,distributedVector%distributedVector,err,error,*999)

    EXITS("cmfe_SolverEquations_VectorGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_VectorGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_VectorGet

  !
  !================================================================================================================================
  !

  !>Get the residual distributed vector from the solver equations for nonlinear problems
  SUBROUTINE cmfe_SolverEquations_ResidualVectorGet(solverEquations,residualVector,err)
    !DLLEXPORT(cmfe_SolverEquations_ResidualVectorGet)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the residual vector for
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: residualVector !<On return, the solver residual distributed vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices

    ENTERS("cmfe_SolverEquations_ResidualVectorGet",err,error,*999)

    NULLIFY(solverMatrices)
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_ResidualDistributedVectorGet(solverMatrices,residualVector%distributedVector,err,error,*999)

    EXITS("cmfe_SolverEquations_ResidualVectorGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_ResidualVectorGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_ResidualVectorGet

  !
  !================================================================================================================================
  !

  !>Get the right hand side distributed vector from the solver equations
  SUBROUTINE cmfe_SolverEquations_RHSVectorGet(solverEquations,rhsVector,err)
    !DLLEXPORT(cmfe_SolverEquations_RHSVectorGet)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the right hand side distributed vector for
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: rhsVector !<On return, the solver right hand side distributed vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices

    ENTERS("cmfe_SolverEquations_RHSVectorGet",err,error,*999)

    NULLIFY(solverMatrices)
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_RHSDistributedVectorGet(solverMatrices,rhsVector%distributedVector,err,error,*999)

    EXITS("cmfe_SolverEquations_RHSVectorGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_RHSVectorGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_RHSVectorGet

  !
  !================================================================================================================================
  !

  !>Get the user number of the given region.
  SUBROUTINE cmfe_Region_UserNumberGet(region,userNumber,err)
    !DLLEXPORT(cmfe_Region_UserNumberGet)
    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The region's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_Region_UserNumberGet",err,error,*999)

    CALL Region_UserNumberGet(region%region,userNumber,err,error,*999)

    EXITS("cmfe_Region_UserNumberGet")
    RETURN
999 ERRORS("cmfe_Region_UserNumberGet",err,error)
    EXITS("cmfe_Region_UserNumberGet")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_UserNumberGet

  !
  !================================================================================================================================
  !

  !>Get the user number of the given mesh.
  SUBROUTINE cmfe_Mesh_UserNumberGet(mesh,userNumber,err)
    !DLLEXPORT(cmfe_Mesh_UserNumberGet)
    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The mesh's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_Mesh_UserNumberGet",err,error,*999)

    CALL Mesh_UserNumberGet(mesh%mesh,userNumber,err,error,*999)

    EXITS("cmfe_Mesh_UserNumberGet")
    RETURN
999 ERRORS("cmfe_Mesh_UserNumberGet",err,error)
    EXITS("cmfe_Mesh_UserNumberGet")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_UserNumberGet

  !
  !================================================================================================================================
  !

  !>Get the user number of the given basis.
  SUBROUTINE cmfe_Basis_UserNumberGet(basis,userNumber,err)
    !DLLEXPORT(cmfe_Basis_UserNumberGet)
    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The basis's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local Variables

    ENTERS("cmfe_Basis_UserNumberGet",err,error,*999)

    CALL Basis_UserNumberGet(basis%basis,userNumber,err,error,*999)

    EXITS("cmfe_Basis_UserNumberGet")
    RETURN
999 ERRORS("cmfe_Basis_UserNumberGet",err,error)
    EXITS("cmfe_Basis_UserNumberGet")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_UserNumberGet

  !
  !================================================================================================================================
  !

  !>Update the bioelectrics geometric field by interpolating the finite elasticity geometric field
  SUBROUTINE cmfe_BioelectricsFiniteElasticity_UpdateGeometricField(controlLoop,calcClosestGaussPoint,err)
    !DLLEXPORT(cmfe_BioelectricsFiniteElasticity_UpdateGeometricField)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The bioelectrics control loop
    LOGICAL, INTENT(IN) :: calcClosestGaussPoint
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_BioelectricsFiniteElasticity_UpdateGeometricField",err,error,*999)

    CALL BioelectricFiniteElasticity_UpdateGeometricField(controlLoop%controlLoop,calcClosestGaussPoint,err,error,*999)

    EXITS("cmfe_BioelectricsFiniteElasticity_UpdateGeometricField")
    RETURN
999 ERRORS("cmfe_BioelectricsFiniteElasticity_UpdateGeometricField",err,error)
    EXITS("cmfe_BioelectricsFiniteElasticity_UpdateGeometricField")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BioelectricsFiniteElasticity_UpdateGeometricField

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given FieldML XML file.
  SUBROUTINE cmfe_FieldML_InputCreateFromFileVS( filename, fieldml, err )
    !DLLEXPORT(cmfe_FieldML_InputCreateFromFileVS)
    !Arguments
    TYPE(VARYING_STRING), INTENT(IN) :: filename !< The FieldML XML file to parse.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputCreateFromFileVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_INITIALISE_FROM_FILE( fieldml%fieldmlInfo, filename, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCreateFromFileVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputCreateFromFileVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateFromFileVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given FieldML XML file.
  SUBROUTINE cmfe_FieldML_InputCreateFromFileC( filename, fieldml, err )
    !DLLEXPORT(cmfe_FieldML_InputCreateFromFileC)
    !Arguments
    CHARACTER(LEN=*), INTENT(IN) :: filename !< The FieldML XML file to parse.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputCreateFromFileC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_INITIALISE_FROM_FILE( fieldml%fieldmlInfo, var_str(filename), err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCreateFromFileC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputCreateFromFileC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateFromFileC

  !
  !================================================================================================================================
  !

  !> Creates a mesh using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputMeshCreateStartObjVS( fieldml, meshArgumentName, mesh, meshNumber, region, err )
    !DLLEXPORT(cmfe_FieldML_InputMeshCreateStartObjVS)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: meshArgumentName !< The name of the argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The region in which to create the mesh.
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !< On return, the newly created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputMeshCreateStartObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, meshArgumentName, mesh%mesh, meshNumber, region%region, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputMeshCreateStartObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputMeshCreateStartObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputMeshCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Creates a mesh with the given user number using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputMeshCreateStartNumberVS( fieldml, meshArgumentName, meshNumber, contextUserNumber, &
    & regionNumber, err )
    !DLLEXPORT(cmfe_FieldML_InputMeshCreateStartNumberVS)
    
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: meshArgumentName !< The name of the mesh argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_FieldML_InputMeshCreateStartNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    NULLIFY( mesh )
    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, meshArgumentName, mesh, meshNumber, region, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputMeshCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputMeshCreateStartNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputMeshCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Creates a mesh using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputMeshCreateStartObjC( fieldml, meshArgumentName, mesh, meshNumber, region, err )
    !DLLEXPORT(cmfe_FieldML_InputMeshCreateStartObjC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: meshArgumentName !< The name of the argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The region in which to create the mesh.
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !< On return, the newly created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputMeshCreateStartObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, var_str(meshArgumentName), mesh%mesh, meshNumber, region%region, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputMeshCreateStartObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputMeshCreateStartObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputMeshCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Creates a mesh with the given user number using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputMeshCreateStartNumberC( fieldml, meshArgumentName, meshNumber, contextUserNumber, &
    & regionNumber, err )
    !DLLEXPORT(cmfe_FieldML_InputMeshCreateStartNumberC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: meshArgumentName !< The name of the mesh argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_FieldML_InputMeshCreateStartNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionNumber, region, err, error, *999 )
    NULLIFY( mesh )
    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, var_str(meshArgumentName), mesh, meshNumber, region, &
      & err, error, *999)

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputMeshCreateStartNumberC")
    RETURN
999 ERRORS("cmfe_FieldML_InputMeshCreateStartNumberC",err,error)
    EXITS("cmfe_FieldML_InputMeshCreateStartNumberC")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputMeshCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartObjVS( fieldml, evaluatorName, userNumber, context, coordinateSystem, &
    & err )
    !DLLEXPORT(cmfe_FieldML_InputCoordinateSystemCreateStartObjVS)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The context for the coordinate system.
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !< On return, the newly created coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_FieldML_InputCoordinateSystemCreateStartObjVS",err,error,*999)

#ifdef WITH_FIELDML
    
    NULLIFY(coordinateSystems)
    CALL Context_CoordinateSystemsGet(context%context,coordinateSystems,err,error,*999)

    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, evaluatorName, coordinateSystems, &
      & coordinateSystem%coordinateSystem,userNumber, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartObjVS")
    RETURN
999 ERRORS("cmfe_FieldML_InputCoordinateSystemCreateStartObjVS",err,error)
    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartObjVS")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS( fieldml, evaluatorName, userNumber, contextUserNumber, err )
    !DLLEXPORT(cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, evaluatorName, coordinateSystems, coordinateSystem, &
      & userNumber, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS")
    RETURN
999 ERRORS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS",err,error)
    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartObjC( fieldml, evaluatorName, userNumber, context, &
    & coordinateSystem, err )
    !DLLEXPORT(cmfe_FieldML_InputCoordinateSystemCreateStartObjC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    TYPE(cmfe_ContextType), INTENT(IN) :: context !<The context for the coordinate system.
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !< On return, the newly created coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_FieldML_InputCoordinateSystemCreateStartObjC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(coordinateSystems)
    CALL Context_CoordinateSystemsGet(context%context,coordinateSystems,err,error,*999)

    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, var_str(evaluatorName), coordinateSystems, &
      & coordinateSystem%coordinateSystem, userNumber, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartObjC")
    RETURN
999 ERRORS("cmfe_FieldML_InputCoordinateSystemCreateStartObjC",err,error)
    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartObjC")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartNumberC( fieldml, evaluatorName, userNumber, contextUserNumber, err )
    !DLLEXPORT(cmfe_FieldML_InputCoordinateSystemCreateStartNumberC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !< The user number of the context for the cordinate systems
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(coordinateSystems)    
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, var_str(evaluatorName), coordinateSystems, &
      & coordinateSystem, userNumber, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberC")
    RETURN
999 ERRORS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberC",err,error)
    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberC")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputBasisCreateStartNumberVS( fieldml, evaluatorName, userNumber, contextUserNumber, err )
    !DLLEXPORT(cmfe_FieldML_InputBasisCreateStartNumberVS)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !< The user number of the context to create the basis in.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context

    ENTERS("cmfe_FieldML_InputBasisCreateStartNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY( basis )
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, evaluatorName, userNumber, basisFunctions, &
      & basis, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputBasisCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputBasisCreateStartNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputBasisCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputBasisCreateStartObjVS( fieldml, evaluatorName, userNumber, context, basis, err )
    !DLLEXPORT(cmfe_FieldML_InputBasisCreateStartObjVS)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    TYPE(cmfe_ContextType), INTENT(IN) :: context !< The context to create the basis function on. 
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<On return, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_FieldML_InputBasisCreateStartObjVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(basisFunctions)
    CALL Context_BasisFunctionsGet(context%context,basisFunctions,err,error,*999)
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, evaluatorName, userNumber, basisFunctions,  &
      & basis%basis, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputBasisCreateStartObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputBasisCreateStartObjVS",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputBasisCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputBasisCreateStartNumberC( fieldml, evaluatorName, userNumber, contextUserNumber,err )
    !DLLEXPORT(cmfe_FieldML_InputBasisCreateStartNumberC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context on which to create the basis
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context

    ENTERS("cmfe_FieldML_InputBasisCreateStartNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY( basis )
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), userNumber, basisFunctions, &
      & basis, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputBasisCreateStartNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputBasisCreateStartNumberC",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputBasisCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputBasisCreateStartObjC( fieldml, evaluatorName, userNumber, context, basis, err )
    !DLLEXPORT(cmfe_FieldML_InputBasisCreateStartObjC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    TYPE(cmfe_ContextType), INTENT(IN) :: context !< The context to create the basis for. 
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<On return, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("cmfe_FieldML_InputBasisCreateStartObjC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(basisFunctions)
    CALL Context_BasisFunctionsGet(context%context,basisFunctions,err,error,*999)
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), userNumber, basisFunctions,  &
      & basis%basis, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputBasisCreateStartObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputBasisCreateStartObjC",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputBasisCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputNodesCreateStartNumberVS( fieldml, nodesArgumentName, contextUserNumber, regionNumber, nodes, err )
    !DLLEXPORT(cmfe_FieldML_InputNodesCreateStartNumberVS)
    
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the nodes from.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region to create to the nodes in.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_FieldML_InputNodesCreateStartNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, nodesArgumentName, region, nodes%nodes, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputNodesCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputNodesCreateStartNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputNodesCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputNodesCreateStartObjVS( fieldml, nodesArgumentName, region, nodes, err )
    !DLLEXPORT(cmfe_FieldML_InputNodesCreateStartObjVS)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the basis from.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The user number of the region to create to the nodes in.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes  !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputNodesCreateStartObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_NODES_CREATE_START(fieldml%fieldmlInfo, nodesArgumentName, region%region, nodes%nodes, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputNodesCreateStartObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputNodesCreateStartObjVS",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputNodesCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputNodesCreateStartNumberC( fieldml, nodesArgumentName, contextUserNumber, regionNumber, nodes, err )
    !DLLEXPORT(cmfe_FieldML_InputNodesCreateStartNumberC)
    
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the nodes from.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region to create to the nodes in.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_FieldML_InputNodesCreateStartNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, var_str(nodesArgumentName), region, nodes%nodes, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputNodesCreateStartNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputNodesCreateStartNumberC",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputNodesCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputNodesCreateStartObjC( fieldml, nodesArgumentName, region, nodes, err )
    !DLLEXPORT(cmfe_FieldML_InputNodesCreateStartObjC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the basis from.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The user number of the region to create to the nodes in.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes  !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputNodesCreateStartObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, var_str(nodesArgumentName), region%region, nodes%nodes, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputNodesCreateStartObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputNodesCreateStartObjC",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputNodesCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the given mesh.
  SUBROUTINE cmfe_FieldML_InputCreateMeshComponentObjVS( fieldml, mesh, componentNumber, evaluatorName, err )
    !DLLEXPORT(cmfe_FieldML_InputCreateMeshComponentObjVS)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !< The mesh for which to create the mesh component.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the mesh from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputCreateMeshComponentObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh%mesh, componentNumber, evaluatorName, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCreateMeshComponentObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputCreateMeshComponentObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateMeshComponentObjVS

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the mesh identified by the given user number.
  SUBROUTINE cmfe_FieldML_InputCreateMeshComponentNumberVS( fieldml, contextUserNumber, regionNumber, meshNumber, &
    & componentNumber, evaluatorName, err )
    !DLLEXPORT(cmfe_FieldML_InputCreateMeshComponentNumberVS)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh for which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("CMISSFieldML_InputCreateMeshComponentNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet(region, meshNumber, mesh, err, error, *999 )

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh, componentNumber, evaluatorName, err, error, *999 )

#else

    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)

#endif

    EXITS("cmfe_FieldML_InputCreateMeshComponentNumberVS")
    RETURN
999 ERRORS("cmfe_FieldML_InputCreateMeshComponentNumberVS",err,error)
    EXITS("cmfe_FieldML_InputCreateMeshComponentNumberVS")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateMeshComponentNumberVS

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the given mesh.
  SUBROUTINE cmfe_FieldML_InputCreateMeshComponentObjC( fieldml, mesh, componentNumber, evaluatorName, err )
    !DLLEXPORT(cmfe_FieldML_InputCreateMeshComponentObjC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !< The mesh for which to create the mesh component.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the mesh from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputCreateMeshComponentObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh%mesh, componentNumber, var_str(evaluatorName), &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCreateMeshComponentObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputCreateMeshComponentObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateMeshComponentObjC

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the mesh identified by the given user number.
  SUBROUTINE cmfe_FieldML_InputCreateMeshComponentNumberC( fieldml, contextUserNumber, regionNumber, meshNumber, &
    & componentNumber, evaluatorName, err )
    !DLLEXPORT(cmfe_FieldML_InputCreateMeshComponentNumberC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh for which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("CMISSFieldML_InputCreateMeshComponentNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet( region, meshNumber, mesh, err, error, *999 )

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh, componentNumber, var_str(evaluatorName), err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCreateMeshComponentNumberC")
    RETURN
999 ERRORS("cmfe_FieldML_InputCreateMeshComponentNumberC",err,error)
    EXITS("cmfe_FieldML_InputCreateMeshComponentNumberC")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateMeshComponentNumberC

  !
  !================================================================================================================================
  !

  !> Create a field using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldCreateStartObjVS( fieldml, region, decomposition, fieldNumber, field, variableType, &
    & evaluatorName, err )
    !DLLEXPORT(cmfe_FieldML_InputFieldCreateStartObjVS)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The region in which the field is to be created.
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !< The decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !< On return, the newly created field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputFieldCreateStartObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region%region, decomposition%decomposition, fieldNumber, &
      & field%field, variableType, evaluatorName, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldCreateStartObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputFieldCreateStartObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a field with the given user number using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldCreateStartNumberVS( fieldml, contextUserNumber, regionNumber, meshNumber, &
    & decompositionNumber, fieldNumber,variableType, evaluatorName, err )
    !DLLEXPORT(cmfe_FieldML_InputFieldCreateStartNumberVS)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the field.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: decompositionNumber !< The user number of the decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(MeshType), POINTER :: mesh
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field

    ENTERS("cmfe_FieldML_InputFieldCreateStartNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet( region, meshNumber, mesh, err, error, *999 )
    CALL Mesh_DecompositionGet( mesh, decompositionNumber, decomposition, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region, decomposition, fieldNumber, field, variableType, &
      & evaluatorName, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputFieldCreateStartNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a field using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldCreateStartObjC( fieldml, region, decomposition, fieldNumber, field, variableType, &
    & evaluatorName, err )
    !DLLEXPORT(cmfe_FieldML_InputFieldCreateStartObjC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The region in which the field is to be created.
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !< The decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !< On return, the newly created field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputFieldCreateStartObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region%region, decomposition%decomposition, fieldNumber, &
      & field%field, variableType, var_str(evaluatorName), err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldCreateStartObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputFieldCreateStartObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Create a field with the given user number using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldCreateStartNumberC( fieldml, contextUserNumber, regionNumber, meshNumber, decompositionNumber, &
    & fieldNumber,variableType, evaluatorName, err )
    !DLLEXPORT(cmfe_FieldML_InputFieldCreateStartNumberC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the field.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: decompositionNumber !< The user number of the decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_FieldML_InputFieldCreateStartNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet( region, meshNumber, mesh, err, error, *999 )
    CALL Mesh_DecompositionGet( mesh, decompositionNumber, decomposition, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region, decomposition, fieldNumber, field, variableType, &
      & var_str(evaluatorName), err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldCreateStartNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputFieldCreateStartNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of the given field, using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateObjVS( fieldml, field, evaluatorName, variableType, &
    & setType, err )
    !DLLEXPORT(cmfe_FieldML_InputFieldParametersUpdateObjVS)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !< On return, the field object.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputFieldParametersUpdateObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, evaluatorName, field%field, variableType, &
      &  setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldParametersUpdateObjVS")
    RETURN
999 ERRORS("cmfe_FieldML_InputFieldParametersUpdateObjVS",err,error)
    EXITS("cmfe_FieldML_InputFieldParametersUpdateObjVS")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateObjVS

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of field with the given user number, using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateNumberVS( fieldml, contextUserNumber, regionNumber, fieldNumber, &
    & evaluatorName, variableType, setType, err )
    !DLLEXPORT(cmfe_FieldML_InputFieldParametersUpdateNumberVS)
    
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region of the field for which parameters are to be updated.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field for which parameters are to be updated.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("cmfe_FieldML_InputFieldParametersUpdateNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet(region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, evaluatorName, field, variableType, setType, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldParametersUpdateNumberVS")
    RETURN
999 ERRORS("cmfe_FieldML_InputFieldParametersUpdateNumberVS",err,error)
    EXITS("cmfe_FieldML_InputFieldParametersUpdateNumberVS")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateNumberVS

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of the given field, using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateObjC( fieldml, field, evaluatorName, &
    & variableType, setType, err )
    !DLLEXPORT(cmfe_FieldML_InputFieldParametersUpdateObjC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !< On return, the field object.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputFieldParametersUpdateObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, var_str(evaluatorName), field%field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldParametersUpdateObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputFieldParametersUpdateObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateObjC

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of field with the given user number, using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateNumberC( fieldml, contextUserNumber, regionNumber, fieldNumber, &
    & evaluatorName, variableType, setType, err )
    !DLLEXPORT(cmfe_FieldML_InputFieldParametersUpdateNumberC)
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region of the field for which parameters are to be updated.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field for which parameters are to be updated.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_FieldML_InputFieldParametersUpdateNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet(region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, var_str(evaluatorName), field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldParametersUpdateNumberC")
    RETURN
999 ERRORS("cmfe_FieldML_InputFieldParametersUpdateNumberC",err,error)
    EXITS("cmfe_FieldML_InputFieldParametersUpdateNumberC")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateNumberC

  !
  !================================================================================================================================
  !

  !> Write the FieldML document managed by the given context to a file with the given name.
  SUBROUTINE cmfe_FieldML_OutputWriteVS( fieldml, filename, err )
    !DLLEXPORT(cmfe_FieldML_OutputWriteVS)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: filename !< The name of the file to write the FieldML document to.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputWriteVS",err,error,*999)

#ifdef WITH_FIELDML

    IF( .NOT. fieldml%fieldmlInfo%IS_OUT ) THEN
      CALL FlagError( "Inbound FieldML handle used four an output-only operation.", ERR, error, *999 )
    END IF

    CALL FIELDML_OUTPUT_WRITE( fieldml%fieldmlInfo, filename, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputWriteVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputWriteVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputWriteVS

  !
  !================================================================================================================================
  !

  !> Write the FieldML document managed by the given context to a file with the given name.
  SUBROUTINE cmfe_FieldML_OutputWriteC( fieldml, filename, err )
    !DLLEXPORT(cmfe_FieldML_OutputWriteC)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: filename !< The name of the file to write the FieldML document to.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputWriteC",err,error,*999)

#ifdef WITH_FIELDML

    IF( .NOT. fieldml%fieldmlInfo%IS_OUT ) THEN
      CALL FlagError( "Inbound FieldML handle used four an output-only operation.", ERR, error, *999 )
    END IF

    CALL FIELDML_OUTPUT_WRITE( fieldml%fieldmlInfo, var_str(filename), err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputWriteC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputWriteC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputWriteC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeObjVS( fieldml, baseName, dofFormat, field, variableType, setType, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldNoTypeObjVS)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldNoTypeObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field%field, variableType, setType, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldNoTypeObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldNoTypeObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeObjVS

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeNumberVS( fieldml, baseName, dofFormat, contextUserNumber, regionNumber, &
    & fieldNumber,variableType, setType, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldNoTypeNumberVS)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region containing the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("cmfe_FieldML_OutputAddFieldNoTypeNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldNoTypeNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldNoTypeNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeObjVS( fieldml, baseName, dofFormat, field, variableType, setType, typeHandle, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldWithTypeObjVS)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldWithTypeObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field%field, variableType, setType, typeHandle, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldWithTypeObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldWithTypeObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeObjVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeNumberVS( fieldml, baseName, dofFormat, contextUserNumber, regionNumber,  &
    & fieldNumber,variableType, setType, typeHandle, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldWithTypeNumberVS)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("cmfe_FieldML_OutputAddFieldWithTypeNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field, variableType, setType, typeHandle, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldWithTypeNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldWithTypeNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeObjC( fieldml, baseName, dofFormat, field, variableType, setType, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldNoTypeObjC)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldNoTypeObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field%field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldNoTypeObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldNoTypeObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeObjC

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeNumberC( fieldml, baseName, dofFormat, contextUserNumber, regionNumber, &
    & fieldNumber,variableType, setType, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldNoTypeNumberC)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region containing the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("cmfe_FieldML_OutputAddFieldNoTypeNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldNoTypeNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldNoTypeNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeNumberC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeObjC( fieldml, baseName, dofFormat, field, variableType, setType, typeHandle, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldWithTypeObjC)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldWithTypeObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field%field, variableType, &
      & typeHandle, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldWithTypeObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldWithTypeObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeObjC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeNumberC( fieldml, baseName, dofFormat, contextUserNumber, regionNumber, &
    & fieldNumber, variableType, setType, typeHandle, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldWithTypeNumberC)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_FieldML_OutputAddFieldWithTypeNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field, variableType, &
      & setType, typeHandle, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldWithTypeNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldWithTypeNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeNumberC

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given mesh.
  SUBROUTINE cmfe_FieldML_OutputCreateObjVS( mesh, location, baseName, connectivityFormat, fieldml, err )
    !DLLEXPORT(cmfe_FieldML_OutputCreateObjVS)
    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !< The mesh to use when initialising the FieldML context.
    TYPE(VARYING_STRING), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputCreateObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh%mesh, location, baseName, connectivityFormat, fieldml%fieldmlInfo, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputCreateObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputCreateObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputCreateObjVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the mesh with the given user number.
  SUBROUTINE cmfe_FieldML_OutputCreateNumberVS( contextUserNumber, regionNumber, meshNumber, location, baseName, &
    & connectivityFormat, fieldml, err )
    !DLLEXPORT(cmfe_FieldML_OutputCreateNumberVS)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the mesh to use when initialising the FieldML context.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when initialising the FieldML context.
    TYPE(VARYING_STRING), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("cmfe_FieldML_OutputCreateNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet( region, meshNumber, mesh, err, error, *999 )

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh, location, baseName, connectivityFormat, fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputCreateNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputCreateNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputCreateNumberVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given mesh.
  SUBROUTINE cmfe_FieldML_OutputCreateObjC( mesh, location, baseName, connectivityFormat, fieldml, err )
    !DLLEXPORT(cmfe_FieldML_OutputCreateObjC)
    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !< The mesh to use when initialising the FieldML context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputCreateObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh%mesh, var_str(location), var_str(baseName), var_str(connectivityFormat), &
      & fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputCreateObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputCreateObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputCreateObjC

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the mesh with the given user number.
  SUBROUTINE cmfe_FieldML_OutputCreateNumberC( contextUserNumber, regionNumber, meshNumber, location, baseName, &
    & connectivityFormat, fieldml, err )
    !DLLEXPORT(cmfe_FieldML_OutputCreateNumberC)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the mesh to use when initialising the FieldML context.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when initialising the FieldML context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
 
    ENTERS("cmfe_FieldML_OutputCreateNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet( region, meshNumber, mesh, err, error, *999 )

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh, var_str(location), var_str(baseName), var_str(connectivityFormat), &
      & fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputCreateNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputCreateNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputCreateNumberC

  !
  !================================================================================================================================
  !

  !> Add the given field to the current FieldML context, only including the given components.
  SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsObjVS( fieldml, typeHandle, baseName, dofFormat, field, fieldComponentNumbers, &
    & variableType, setType, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldComponentsObjVS)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:)
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldComponentsObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, baseName, dofFormat, field%field, &
      & fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldComponentsObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldComponentsObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsObjVS

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the current FieldML context, only including the given components.
  SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsNumberVS( fieldml, typeHandle, baseName, dofFormat, contextUserNumber,  &
    & regionNumber, fieldNumber, fieldComponentNumbers, variableType, setType, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldComponentsNumberVS)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:) !< The component numbers to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("cmfe_FieldML_OutputAddFieldComponentsNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, baseName, dofFormat, field, fieldComponentNumbers,&
      & variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldComponentsNumberVS")
    RETURN
999 ERRORS("cmfe_FieldML_OutputAddFieldComponentsNumberVS",err,error)
    EXITS("cmfe_FieldML_OutputAddFieldComponentsNumberVS")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the current FieldML context, only including the given components.
  SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsObjC( fieldml, typeHandle, baseName, dofFormat, field, fieldComponentNumbers, &
    & variableType, setType, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldComponentsObjC)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:)
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldComponentsObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, var_str(baseName), var_str(dofFormat), &
      & field%field, fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldComponentsObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldComponentsObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsObjC

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the current FieldML context, only including the given components.
  SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsNumberC( fieldml, typeHandle, baseName, dofFormat, contextUserNumber, &
    & regionNumber,fieldNumber, fieldComponentNumbers, variableType, setType, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddFieldComponentsNumberC)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:) !< The component numbers to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("cmfe_FieldML_OutputAddFieldComponentsNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)    
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, var_str(baseName), var_str(dofFormat), &
      & field, fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldComponentsNumberC")
    RETURN
999 ERRORS("cmfe_FieldML_OutputAddFieldComponentsNumberC",err,error)
    EXITS("cmfe_FieldML_OutputAddFieldComponentsNumberC")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsNumberC

  !
  !================================================================================================================================
  !

  !>Import a FieldML object from the library into the current session.
  SUBROUTINE cmfe_FieldML_OutputAddImport( fieldml, name, handle, err )
    !DLLEXPORT(cmfe_FieldML_OutputAddImport)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: name !< The name of the object to import.
    INTEGER(INTG), INTENT(OUT) :: handle !< A handle to the newly imported FieldML object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Locals
    TYPE(VARYING_STRING) :: stringName

    ENTERS("cmfe_FieldML_OutputAddImport",err,error,*999)

#ifdef WITH_FIELDML

    stringName = name

    handle = FIELDML_OUTPUT_ADD_IMPORT( fieldml%fieldmlInfo, stringName, err, error )
    IF(err/=0) GOTO 999

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddImport")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddImport",err,error)
    CALL cmfe_HandleError( err, error )
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddImport

  !
  !================================================================================================================================
  !

  !>Finalises a Fieldml context.
  SUBROUTINE cmfe_FieldMLIO_Finalise( fieldml, err )
    !DLLEXPORT(cmfe_FieldMLIO_Finalise)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(OUT) :: fieldml !< The FieldML context to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_FieldMLIO_Finalise", err, error, *999 )

#ifdef WITH_FIELDML

    CALL FIELDML_IO_FINALISE( fieldml%fieldmlInfo, err, error, *999  )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldMLIO_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_FieldMLIO_Finalise",err,error)
    CALL cmfe_HandleError( err, error )
    RETURN

  END SUBROUTINE cmfe_FieldMLIO_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a Fieldml context.
  SUBROUTINE cmfe_FieldMLIO_Initialise( fieldml, err )
    !DLLEXPORT(cmfe_FieldMLIO_Initialise)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(OUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_FieldMLIO_Initialise", err, error, *999 )

#ifdef WITH_FIELDML

    NULLIFY( fieldml%fieldmlInfo )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldMLIO_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_FieldMLIO_Initialise",err,error)
    CALL cmfe_HandleError( err, error )
    RETURN

  END SUBROUTINE cmfe_FieldMLIO_Initialise

  !
  !================================================================================================================================
  !

  !>Get the session handle from a Fieldml context.
  SUBROUTINE cmfe_FieldMLIO_GetSession( fieldml, sessionHandle, err )
    !DLLEXPORT(cmfe_FieldMLIO_GetSession)
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context whose session handle is to be returned.
    INTEGER(INTG), INTENT(OUT) :: sessionHandle !<The session handle.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_FieldMLIO_GetSession", err, error, *999 )

#ifdef WITH_FIELDML

    sessionHandle = fieldml%fieldmlInfo%FML_HANDLE

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldMLIO_GetSession")
    RETURN
999 ERRORSEXITS("cmfe_FieldMLIO_GetSession",err,error)
    CALL cmfe_HandleError( err, error )
    RETURN

  END SUBROUTINE cmfe_FieldMLIO_GetSession

  !
  !================================================================================================================================
  !


END MODULE OpenCMISS_Iron
