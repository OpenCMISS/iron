!> \file
!> \author Chris Bradley
!> \brief This module contains all interface conditions routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!>This module contains all interface conditions routines.
MODULE INTERFACE_CONDITIONS_ROUTINES

  USE BaseRoutines
  USE BasisRoutines
  USE CoordinateSystemAccessRoutines
  USE FIELD_ROUTINES
  USE FieldAccessRoutines
  USE INPUT_OUTPUT
  USE InterfaceAccessRoutines
  USE INTERFACE_CONDITIONS_CONSTANTS
  USE InterfaceConditionAccessRoutines
  USE INTERFACE_EQUATIONS_ROUTINES
  USE InterfaceEquationsAccessRoutines
  USE INTERFACE_MAPPING_ROUTINES
  USE InterfaceMatricesRoutines
  USE INTERFACE_OPERATORS_ROUTINES
  USE ISO_VARYING_STRING
  USE Kinds
  USE MatrixVector
  USE ProfilingRoutines
  USE Strings
  USE Timer
  USE Types

#include "macros.h"  

  IMPLICIT NONE

  !Module types

  !Module variables

  !Interfaces

  PUBLIC INTERFACE_CONDITION_ASSEMBLE

  PUBLIC INTERFACE_CONDITION_CREATE_FINISH,INTERFACE_CONDITION_CREATE_START

  PUBLIC INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD

  PUBLIC INTERFACE_CONDITION_DESTROY

  PUBLIC INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH,INTERFACE_CONDITION_EQUATIONS_CREATE_START

  PUBLIC INTERFACE_CONDITION_EQUATIONS_DESTROY
  
  PUBLIC InterfaceCondition_IntegrationTypeGet,InterfaceCondition_IntegrationTypeSet

  PUBLIC InterfaceCondition_LagrangeFieldCreateFinish,InterfaceCondition_LagrangeFieldCreateStart

  PUBLIC INTERFACE_CONDITION_METHOD_GET,INTERFACE_CONDITION_METHOD_SET

  PUBLIC INTERFACE_CONDITION_OPERATOR_GET,INTERFACE_CONDITION_OPERATOR_SET

  PUBLIC InterfaceCondition_OutputTypeGet,InterfaceCondition_OutputTypeSet
  
  PUBLIC InterfaceCondition_PenaltyFieldCreateFinish,InterfaceCondition_PenaltyFieldCreateStart

  PUBLIC INTERFACE_CONDITIONS_FINALISE,INTERFACE_CONDITIONS_INITIALISE

CONTAINS

  !
  !================================================================================================================================
  !

  !>Assembles the equations for an interface condition.
  SUBROUTINE INTERFACE_CONDITION_ASSEMBLE(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to assemble the equations for.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    ENTERS("INTERFACE_CONDITION_ASSEMBLE",err,error,*999)
    
    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(INTERFACE_CONDITION%outputType>=INTERFACE_CONDITION_PROGRESS_OUTPUT) THEN
        CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
        CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Interface condition assemble: ",INTERFACE_CONDITION%label,err,error,*999)
      ENDIF
      INTERFACE_EQUATIONS=>INTERFACE_CONDITION%interfaceEquations
      CALL InterfaceEquations_AssertIsFinished(INTERFACE_EQUATIONS,ERR,ERROR,*999)
      SELECT CASE(INTERFACE_CONDITION%METHOD)
      CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,INTERFACE_CONDITION_PENALTY_METHOD)
        CALL INTERFACE_CONDITION_ASSEMBLE_FEM(INTERFACE_CONDITION,err,error,*999)
      CASE(INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(INTERFACE_CONDITION_POINT_TO_POINT_METHOD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        LOCAL_ERROR="The interface condition method of "// &
          & TRIM(NumberToVString(INTERFACE_CONDITION%METHOD,"*",err,error))// &
          & " is invalid."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_ASSEMBLE")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_ASSEMBLE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_ASSEMBLE

  !
  !================================================================================================================================
  !
  
  !>Assembles the interface matricesand rhs for using the finite element method.
  SUBROUTINE INTERFACE_CONDITION_ASSEMBLE_FEM(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to assemble the equations for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: element_idx,ne,numberOfTimes
    REAL(SP) :: elementUserElapsed,elementSystemElapsed,userElapsed,userTime1(1),userTime2(1),userTime3(1),userTime4(1), &
      & userTime5(1),userTime6(1),systemElapsed,systemTime1(1),systemTime2(1),systemTime3(1),systemTime4(1), &
      & systemTime5(1),systemTime6(1)
    TYPE(DomainMappingType), POINTER :: ELEMENTS_MAPPING
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(InterfaceMatricesType), POINTER :: INTERFACE_MATRICES
    TYPE(FieldType), POINTER :: LAGRANGE_FIELD
    
!#ifdef TAUPROF
!    CHARACTER(28) :: CVAR
!    INTEGER :: PHASE(2) = (/ 0, 0 /)
!    SAVE PHASE
!#endif

    ENTERS("INTERFACE_CONDITION_ASSEMBLE_FEM",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(ASSOCIATED(INTERFACE_CONDITION%LAGRANGE)) THEN
        LAGRANGE_FIELD=>INTERFACE_CONDITION%lagrange%LAGRANGE_FIELD
        IF(ASSOCIATED(LAGRANGE_FIELD)) THEN
          INTERFACE_EQUATIONS=>INTERFACE_CONDITION%interfaceEquations
          IF(ASSOCIATED(INTERFACE_EQUATIONS)) THEN
            INTERFACE_MATRICES=>INTERFACE_EQUATIONS%interfaceMatrices
            IF(ASSOCIATED(INTERFACE_MATRICES)) THEN
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,userTime1,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,systemTime1,err,error,*999)
              ENDIF
              !Initialise the matrices and rhs vector
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_START("InterfaceMatrices_ValuesInitialise()")
#endif
              CALL InterfaceMatrices_ValueInitialise(INTERFACE_MATRICES,0.0_DP,err,error,*999)
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_STOP("InterfaceMatrices_ValuesInitialise()")
#endif
              !Assemble the elements
              !Allocate the element matrices 
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_START("InterfaceMatrices_ElementInitialise()")
#endif
              CALL InterfaceMatrices_ElementInitialise(INTERFACE_MATRICES,err,error,*999)
              ELEMENTS_MAPPING=>LAGRANGE_FIELD%DECOMPOSITION%DOMAIN(LAGRANGE_FIELD%decomposition%meshComponentNumber)%PTR% &
                & MAPPINGS%ELEMENTS
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_STOP("InterfaceMatrices_ElementInitialise()")
#endif
              !Output timing information if required
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,userTime2,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,systemTime2,err,error,*999)
                userElapsed=userTime2(1)-userTime1(1)
                systemElapsed=systemTime2(1)-systemTime1(1)
                CALL Profiling_TimingsOutput(0,"",userElapsed,systemElapsed,err,error,*999)
                CALL Profiling_TimingsOutput(1,"Setup and initialisation",userElapsed,systemElapsed,err,error,*999)
                elementUserElapsed=0.0_SP
                elementSystemElapsed=0.0_SP
              ENDIF
              numberOfTimes=0
              !Loop over the internal elements

#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_START("Internal Elements Loop")
#endif
              DO element_idx=ELEMENTS_MAPPING%internalStart,ELEMENTS_MAPPING%internalFinish
!#ifdef TAUPROF
!              WRITE (CVAR,'(a23,i3)') 'Internal Elements Loop ',element_idx
!              CALL TAU_PHASE_CREATE_DYNAMIC(PHASE,CVAR)
!              CALL TAU_PHASE_START(PHASE)
!#endif
                ne=ELEMENTS_MAPPING%domainList(element_idx)
                numberOfTimes=numberOfTimes+1
                CALL InterfaceMatrices_ElementCalculate(INTERFACE_MATRICES,ne,err,error,*999)
                CALL InterfaceCondition_FiniteElementCalculate(INTERFACE_CONDITION,ne,err,error,*999)
                CALL InterfaceMatrices_ElementAdd(INTERFACE_MATRICES,err,error,*999)
!#ifdef TAUPROF
!              CALL TAU_PHASE_STOP(PHASE)
!#endif
              ENDDO !element_idx
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_STOP("Internal Elements Loop")
#endif

              !Output timing information if required
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,userTime3,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,systemTime3,err,error,*999)
                userElapsed=userTime3(1)-userTime2(1)
                systemElapsed=systemTime3(1)-systemTime2(1)
                elementUserElapsed=userElapsed
                elementSystemElapsed=systemElapsed
                CALL Profiling_TimingsOutput(1,"Internal elements equations assembly",userElapsed,systemElapsed,err,error,*999)
              ENDIF
              !Loop over the boundary and ghost elements
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_START("Boundary and Ghost Elements Loop")
#endif
              DO element_idx=ELEMENTS_MAPPING%boundaryStart,ELEMENTS_MAPPING%ghostFinish
                ne=ELEMENTS_MAPPING%domainList(element_idx)
                numberOfTimes=numberOfTimes+1
                CALL InterfaceMatrices_ElementCalculate(INTERFACE_MATRICES,ne,err,error,*999)
                CALL InterfaceCondition_FiniteElementCalculate(INTERFACE_CONDITION,ne,err,error,*999)
                CALL InterfaceMatrices_ElementAdd(INTERFACE_MATRICES,err,error,*999)
              ENDDO !element_idx
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_STOP("Boundary and Ghost Elements Loop")
#endif
              !Output timing information if required
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,userTime5,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,systemTime5,err,error,*999)
                userElapsed=userTime5(1)-userTime3(1)
                systemElapsed=systemTime5(1)-systemTime3(1)
                elementUserElapsed=elementUserElapsed+userElapsed
                elementSystemElapsed=elementSystemElapsed+systemElapsed
                CALL Profiling_TimingsOutput(1,"Boundary+ghost elements equations assembly",userElapsed,systemElapsed, &
                  & err,error,*999)
                IF(numberOfTimes>0) CALL Profiling_TimingsOutput(1,"Average element equations assembly", &
                  & elementUserElapsed/numberOfTimes,elementSystemElapsed/numberOfTimes,err,error,*999)
              ENDIF
              !Finalise the element matrices
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_START("InterfaceMatrices_ElementFinalise()")
#endif
              CALL InterfaceMatrices_ElementFinalise(INTERFACE_MATRICES,err,error,*999)
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_STOP("InterfaceMatrices_ElementFinalise()")
#endif
              !Output timing information if required
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,userTime6,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,systemTime6,err,error,*999)
                userElapsed=userTime6(1)-userTime1(1)
                systemElapsed=systemTime6(1)-systemTime1(1)
                CALL Profiling_TimingsOutput(1,"Total equations assembly",userElapsed,systemElapsed,err,error,*999)
              ENDIF
              !Output equations matrices and vector if required
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_MATRIX_OUTPUT) THEN
                CALL InterfaceMatrices_Output(GENERAL_OUTPUT_TYPE,INTERFACE_MATRICES,err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Interface matrices is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Interface matrices is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Lagrange field is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Interface condition Lagrange is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated",err,error,*999)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_ASSEMBLE_FEM")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_ASSEMBLE_FEM",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_ASSEMBLE_FEM

  !
  !==================================================================================================================================
  !

  !>Finishes the process of creating an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_CreateFinish
  SUBROUTINE INTERFACE_CONDITION_CREATE_FINISH(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to finish creating
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: mesh_idx,mesh_idx_count,NUMBER_OF_COMPONENTS,variable_idx
    INTEGER(INTG), POINTER :: NEW_VARIABLE_MESH_INDICES(:)
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(FieldVariablePtrType), POINTER :: NEW_FIELD_VARIABLES(:)
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: INTERFACE_DEPENDENT
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    NULLIFY(NEW_FIELD_VARIABLES)
    NULLIFY(NEW_VARIABLE_MESH_INDICES)
    
    ENTERS("INTERFACE_CONDITION_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(INTERFACE_CONDITION%INTERFACE_CONDITION_FINISHED) THEN
        CALL FlagError("Interface condition has already been finished.",err,error,*999)
      ELSE
        INTERFACE=>INTERFACE_CONDITION%INTERFACE
        IF(ASSOCIATED(INTERFACE)) THEN
          !Test various inputs have been set up.
          SELECT CASE(INTERFACE_CONDITION%METHOD)
          CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,INTERFACE_CONDITION_PENALTY_METHOD)
            INTERFACE_DEPENDENT=>INTERFACE_CONDITION%DEPENDENT
            IF(ASSOCIATED(INTERFACE_DEPENDENT)) THEN
              !Check the dependent field variables have been set.
              IF(INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES<2) THEN
                LOCAL_ERROR="The number of added dependent variables of "// &
                  & TRIM(NumberToVString(INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES,"*",err,error))// &
                  & " is invalid. The number must be >= 2."
                CALL FlagError(LOCAL_ERROR,err,error,*999)
              ENDIF

              !\todo check if interface mesh connectivity basis has same number of gauss points as interface geometric field IF(INTERFACE_CONDITION%INTERFACE%meshConnectivity%BASIS%QUADRATURE%NUMBER_OF_GAUSS_XI/=)
 
              !Note There is no need to check that the dependent variables have the same number of components.
              !The user will need to set a fixed BC on the interface dof relating to the field components 
              !not present in each of the coupled bodies, eliminating this dof from the solver matrices
              SELECT CASE(INTERFACE_CONDITION%OPERATOR)
              CASE(INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR,INTERFACE_CONDITION_FLS_CONTACT_OPERATOR, &
                & INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR,INTERFACE_CONDITION_SOLID_FLUID_OPERATOR)
                !Check that the dependent variables have the same number of components
                FIELD_VARIABLE=>INTERFACE_DEPENDENT%fieldVariables(1)%PTR
                IF(ASSOCIATED(FIELD_VARIABLE)) THEN
                  NUMBER_OF_COMPONENTS=FIELD_VARIABLE%numberOfComponents
                  DO variable_idx=2,INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES
                    FIELD_VARIABLE=>INTERFACE_DEPENDENT%fieldVariables(variable_idx)%PTR
                    IF(ASSOCIATED(FIELD_VARIABLE)) THEN
                      !do nothing
                    ELSE
                      LOCAL_ERROR="The interface condition field variables is not associated for variable index "// &
                        & TRIM(NumberToVString(variable_idx,"*",err,error))
                      CALL FlagError(LOCAL_ERROR,err,error,*999)
                    ENDIF
                  ENDDO !variable_idx 
                ELSE
                  CALL FlagError("Interface field variable is not associated.",err,error,*999)
                ENDIF
              CASE(INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                LOCAL_ERROR="The interface condition operator of "// &
                  & TRIM(NumberToVString(INTERFACE_CONDITION%OPERATOR,"*",err,error))//" is invalid."
                CALL FlagError(LOCAL_ERROR,err,error,*999)
              END SELECT

              !Reorder the dependent variables based on mesh index order
              ALLOCATE(NEW_FIELD_VARIABLES(INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate new field variables.",err,error,*999)
              ALLOCATE(NEW_VARIABLE_MESH_INDICES(INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate new variable mesh indices.",err,error,*999)
              NEW_VARIABLE_MESH_INDICES=0
              mesh_idx_count=0
              DO mesh_idx=1,INTERFACE%numberOfCoupledMeshes
                DO variable_idx=1,INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES
                  IF(INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES(variable_idx)==mesh_idx) THEN
                    mesh_idx_count=mesh_idx_count+1
                    NEW_FIELD_VARIABLES(mesh_idx_count)%PTR=>INTERFACE_DEPENDENT%fieldVariables(variable_idx)%PTR
                    NEW_VARIABLE_MESH_INDICES(mesh_idx_count)=mesh_idx
                  ENDIF
                ENDDO !variable_idx
              ENDDO !mesh_idx
              IF(mesh_idx_count/=INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES) &
                & CALL FlagError("Invalid dependent variable mesh index setup.",err,error,*999)
              IF(ASSOCIATED(INTERFACE_DEPENDENT%fieldVariables)) DEALLOCATE(INTERFACE_DEPENDENT%fieldVariables)
              IF(ASSOCIATED(INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES)) DEALLOCATE(INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES)
              INTERFACE_DEPENDENT%fieldVariables=>NEW_FIELD_VARIABLES
              INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES=>NEW_VARIABLE_MESH_INDICES
            ELSE
              CALL FlagError("Interface condition dependent is not associated.",err,error,*999)
            ENDIF
          CASE(INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(INTERFACE_CONDITION_POINT_TO_POINT_METHOD)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            LOCAL_ERROR="The interface condition method of "//TRIM(NumberToVString(INTERFACE_CONDITION%METHOD,"*",err,error))// &
              & " is invalid."
            CALL FlagError(LOCAL_ERROR,err,error,*999)
          END SELECT
          !Finish the interface condition creation
          INTERFACE_CONDITION%INTERFACE_CONDITION_FINISHED=.TRUE.
        ELSE
          CALL FlagError("Interface condition interface is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_CREATE_FINISH")
    RETURN
999 IF(ASSOCIATED(NEW_FIELD_VARIABLES)) DEALLOCATE(NEW_FIELD_VARIABLES)
    IF(ASSOCIATED(NEW_VARIABLE_MESH_INDICES)) DEALLOCATE(NEW_VARIABLE_MESH_INDICES)
    ERRORSEXITS("INTERFACE_CONDITION_CREATE_FINISH",err,error)    
    RETURN 1
   
  END SUBROUTINE INTERFACE_CONDITION_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Starts the process of creating an interface condition on an interface. \see OpenCMISS::Iron::cmfe_InterfaceCondition_CreateStart
  SUBROUTINE INTERFACE_CONDITION_CREATE_START(USER_NUMBER,INTERFACE,GEOMETRIC_FIELD,INTERFACE_CONDITION,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number of the interface condition
    TYPE(InterfaceType), POINTER :: INTERFACE !<A pointer to the interface to create the interface condition on
    TYPE(FieldType), POINTER :: GEOMETRIC_FIELD !<A pointer to the geometric field for the interface condition.
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<On return, a pointer to the interface condition. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,interface_conditions_idx
    TYPE(InterfaceType), POINTER :: GEOMETRIC_INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NEW_INTERFACE_CONDITION
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NEW_INTERFACE_CONDITIONS(:)
    TYPE(RegionType), POINTER :: GEOMETRIC_REGION,GEOMETRIC_INTERFACE_PARENT_REGION,INTERFACE_PARENT_REGION
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR
 
    NULLIFY(NEW_INTERFACE_CONDITION)
    NULLIFY(NEW_INTERFACE_CONDITIONS)

    ENTERS("INTERFACE_CONDITION_CREATE_START",err,error,*997)

    IF(ASSOCIATED(INTERFACE)) THEN
      IF(ASSOCIATED(INTERFACE%interfaceConditions)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(USER_NUMBER,INTERFACE,NEW_INTERFACE_CONDITION,err,error,*997)
        IF(ASSOCIATED(NEW_INTERFACE_CONDITION)) THEN
          LOCAL_ERROR="Interface condition user number "//TRIM(NumberToVString(USER_NUMBER,"*",err,error))// &
            & " has already been created on interface number "//TRIM(NumberToVString(INTERFACE%userNumber,"*",err,error))//"."
          CALL FlagError(LOCAL_ERROR,err,error,*997)
        ELSE
          CALL Field_AssertIsFinished(GEOMETRIC_FIELD,err,error,*999)
          !Check the geometric field is defined on the interface
          GEOMETRIC_INTERFACE=>GEOMETRIC_FIELD%INTERFACE
          IF(ASSOCIATED(GEOMETRIC_INTERFACE)) THEN
            IF(ASSOCIATED(GEOMETRIC_INTERFACE,INTERFACE)) THEN
              NULLIFY(NEW_INTERFACE_CONDITION)
              !Initialise the new interface condition
              CALL INTERFACE_CONDITION_INITIALISE(NEW_INTERFACE_CONDITION,err,error,*999)
              !Set default interface condition values
              NEW_INTERFACE_CONDITION%userNumber=USER_NUMBER
              NEW_INTERFACE_CONDITION%globalNumber=INTERFACE%interfaceConditions%numberOfInterfaceConditions+1
              NEW_INTERFACE_CONDITION%interfaceConditions=>INTERFACE%interfaceConditions
              NEW_INTERFACE_CONDITION%label="Interface Condition "//TRIM(NumberToVString(USER_NUMBER,"*",err,error))
              NEW_INTERFACE_CONDITION%INTERFACE=>INTERFACE
              !Default attributes
              NEW_INTERFACE_CONDITION%GEOMETRY%geometricField=>GEOMETRIC_FIELD
              NEW_INTERFACE_CONDITION%METHOD=INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD
              NEW_INTERFACE_CONDITION%OPERATOR=INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR
              IF(ASSOCIATED(INTERFACE%pointsConnectivity)) THEN
                NEW_INTERFACE_CONDITION%integrationType=INTERFACE_CONDITION_DATA_POINTS_INTEGRATION
              ELSE
                NEW_INTERFACE_CONDITION%integrationType=INTERFACE_CONDITION_GAUSS_INTEGRATION
              ENDIF
              CALL INTERFACE_CONDITION_DEPENDENT_INITIALISE(NEW_INTERFACE_CONDITION,err,error,*999)
              !Add new interface condition into list of interface conditions in the interface
              ALLOCATE(NEW_INTERFACE_CONDITIONS(INTERFACE%interfaceConditions%numberOfInterfaceConditions+1),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate new interface conditions.",err,error,*999)
              DO interface_conditions_idx=1,INTERFACE%interfaceConditions%numberOfInterfaceConditions
                NEW_INTERFACE_CONDITIONS(interface_conditions_idx)%PTR=>INTERFACE%interfaceConditions% &
                  & interfaceConditions(interface_conditions_idx)%PTR
              ENDDO !interface_conditions_idx
              NEW_INTERFACE_CONDITIONS(INTERFACE%interfaceConditions%numberOfInterfaceConditions+1)%PTR=> &
                & NEW_INTERFACE_CONDITION
              IF(ASSOCIATED(INTERFACE%interfaceConditions%interfaceConditions)) DEALLOCATE(INTERFACE%interfaceConditions% &
                & interfaceConditions)
              INTERFACE%interfaceConditions%interfaceConditions=>NEW_INTERFACE_CONDITIONS
              INTERFACE%interfaceConditions%numberOfInterfaceConditions=INTERFACE%interfaceConditions% &
              numberOfInterfaceConditions+1
              !Return the pointer
              INTERFACE_CONDITION=>NEW_INTERFACE_CONDITION
            ELSE
              INTERFACE_PARENT_REGION=>INTERFACE%parentRegion
              IF(ASSOCIATED(INTERFACE_PARENT_REGION)) THEN
                GEOMETRIC_INTERFACE_PARENT_REGION=>GEOMETRIC_INTERFACE%parentRegion
                IF(ASSOCIATED(GEOMETRIC_INTERFACE_PARENT_REGION)) THEN
                  LOCAL_ERROR="Geometric field interface does not match specified interface. "// &
                    "The geometric field was created on interface number "// &
                    & TRIM(NumberToVString(GEOMETRIC_INTERFACE%userNumber,"*",err,error))// &
                    & " of parent region number "// &
                    & TRIM(NumberToVString(GEOMETRIC_INTERFACE_PARENT_REGION%userNumber,"*",err,error))// &
                    & " and the specified interface was created as number "// &
                    & TRIM(NumberToVString(INTERFACE%userNumber,"*",err,error))//" on parent region number "// &
                    & TRIM(NumberToVString(INTERFACE_PARENT_REGION%userNumber,"*",err,error))//"."
                  CALL FlagError(LOCAL_ERROR,err,error,*999)
                ELSE
                  CALL FlagError("Geometric interface parent region is not associated.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Interface parent region is not associated.",err,error,*999)
              ENDIF
            ENDIF
          ELSE
            GEOMETRIC_REGION=>GEOMETRIC_FIELD%REGION
            IF(ASSOCIATED(GEOMETRIC_REGION)) THEN
              LOCAL_ERROR="The geometric field was created on region number "// &
                & TRIM(NumberToVString(GEOMETRIC_REGION%userNumber,"*",err,error))// &
                & " and not on the specified interface."
              CALL FlagError(LOCAL_ERROR,err,error,*999)
            ELSE
              CALL FlagError("The geometric field does not have a region or interface created.",err,error,*999)
            ENDIF
          ENDIF
        ENDIF
      ELSE
        LOCAL_ERROR="The interface conditions on interface number "// &
          & TRIM(NumberToVString(INTERFACE%userNumber,"*",err,error))//" are not associated."
        CALL FlagError(LOCAL_ERROR,err,error,*997)
      ENDIF
    ELSE
      CALL FlagError("Interface is not associated.",err,error,*997)
    ENDIF
    
    EXITS("INTERFACE_CONDITION_CREATE_START")
    RETURN
999 IF(ASSOCIATED(NEW_INTERFACE_CONDITION)) CALL INTERFACE_CONDITION_FINALISE(NEW_INTERFACE_CONDITION,DUMMY_ERR,DUMMY_ERROR,*998)
998 IF(ASSOCIATED(NEW_INTERFACE_CONDITIONS)) DEALLOCATE(NEW_INTERFACE_CONDITIONS)
997 ERRORSEXITS("INTERFACE_CONDITION_CREATE_START",err,error)
    RETURN 1   
  END SUBROUTINE INTERFACE_CONDITION_CREATE_START
  
  !
  !================================================================================================================================
  !

  !>Finalise the interface condition dependent field information and deallocate all memory.
  SUBROUTINE INTERFACE_CONDITION_DEPENDENT_FINALISE(INTERFACE_DEPENDENT,err,error,*)

    !Argument variables
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: INTERFACE_DEPENDENT !<A pointer to the interface condition dependent field information to finalise.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("INTERFACE_CONDITION_DEPENDENT_FINALISE",err,error,*999)

    IF(ASSOCIATED(INTERFACE_DEPENDENT)) THEN
      IF(ASSOCIATED(INTERFACE_DEPENDENT%EQUATIONS_SETS)) DEALLOCATE(INTERFACE_DEPENDENT%EQUATIONS_SETS)
      IF(ASSOCIATED(INTERFACE_DEPENDENT%fieldVariables)) DEALLOCATE(INTERFACE_DEPENDENT%fieldVariables)
      IF(ASSOCIATED(INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES)) DEALLOCATE(INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES)
      DEALLOCATE(INTERFACE_DEPENDENT)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_DEPENDENT_FINALISE")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_DEPENDENT_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_DEPENDENT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises an interface condition dependent field information.
  SUBROUTINE INTERFACE_CONDITION_DEPENDENT_INITIALISE(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<The pointer to the interface condition to initialise to initialise the dependent field information for.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR
 
    ENTERS("INTERFACE_CONDITION_DEPENDENT_INITIALISE",err,error,*998)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(ASSOCIATED(INTERFACE_CONDITION%DEPENDENT)) THEN
        CALL FlagError("Interface condition dependent is already associated.",err,error,*999)
      ELSE
        ALLOCATE(INTERFACE_CONDITION%DEPENDENT,STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate interface condition dependent.",err,error,*999)
        INTERFACE_CONDITION%DEPENDENT%INTERFACE_CONDITION=>INTERFACE_CONDITION
        INTERFACE_CONDITION%DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES=0
        NULLIFY(INTERFACE_CONDITION%DEPENDENT%EQUATIONS_SETS)
        NULLIFY(INTERFACE_CONDITION%DEPENDENT%fieldVariables)
        NULLIFY(INTERFACE_CONDITION%DEPENDENT%VARIABLE_MESH_INDICES)
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_DEPENDENT_INITIALISE")
    RETURN
999 CALL INTERFACE_CONDITION_DEPENDENT_FINALISE(INTERFACE_CONDITION%DEPENDENT,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("INTERFACE_CONDITION_DEPENDENT_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_DEPENDENT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Adds an equations set to an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_EquationsSetAdd
  SUBROUTINE INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD(INTERFACE_CONDITION,MESH_INDEX,EQUATIONS_SET,VARIABLE_TYPE,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to add the dependent variable to
    INTEGER(INTG), INTENT(IN) :: MESH_INDEX !<The mesh index in the interface conditions interface that the dependent variable corresponds to
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET !<A pointer to the equations set containing the dependent field to add the variable from.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The variable type of the dependent field to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    INTEGER(INTG), POINTER :: NEW_VARIABLE_MESH_INDICES(:)
    LOGICAL :: FOUND_MESH_INDEX
    TYPE(DecompositionType), POINTER :: DECOMPOSITION
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NEW_EQUATIONS_SETS(:)
    TYPE(FieldType), POINTER :: DEPENDENT_FIELD
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE,INTERFACE_VARIABLE
    TYPE(FieldVariablePtrType), POINTER :: NEW_FIELD_VARIABLES(:)
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: INTERFACE_DEPENDENT
    TYPE(MeshType), POINTER :: DEPENDENT_MESH,INTERFACE_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      INTERFACE_DEPENDENT=>INTERFACE_CONDITION%DEPENDENT
      IF(ASSOCIATED(INTERFACE_DEPENDENT)) THEN
        INTERFACE=>INTERFACE_CONDITION%INTERFACE
        IF(ASSOCIATED(INTERFACE)) THEN
          IF(MESH_INDEX>0.AND.MESH_INDEX<=INTERFACE%numberOfCoupledMeshes) THEN
            IF(ASSOCIATED(EQUATIONS_SET)) THEN
              DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
              IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
                IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
                  FIELD_VARIABLE=>DEPENDENT_FIELD%variableTypeMap(VARIABLE_TYPE)%PTR
                  IF(ASSOCIATED(FIELD_VARIABLE)) THEN
                    !Check that the field variable hasn't already been added.
                    variable_idx=1
                    NULLIFY(INTERFACE_VARIABLE)
                    DO WHILE(variable_idx<=INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES.AND. &
                      & .NOT.ASSOCIATED(INTERFACE_VARIABLE))
                      IF(ASSOCIATED(FIELD_VARIABLE,INTERFACE_DEPENDENT%fieldVariables(variable_idx)%PTR)) THEN
                        INTERFACE_VARIABLE=>INTERFACE_DEPENDENT%fieldVariables(variable_idx)%PTR
                      ELSE
                        variable_idx=variable_idx+1
                      ENDIF
                    ENDDO
                    IF(ASSOCIATED(INTERFACE_VARIABLE)) THEN
                      !Check if we are dealing with the same mesh index.
                      IF(MESH_INDEX/=INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES(variable_idx)) THEN
                        LOCAL_ERROR="The dependent variable has already been added to the interface condition at "// &
                          & "position index "//TRIM(NumberToVString(variable_idx,"*",err,error))//"."
                        CALL FlagError(LOCAL_ERROR,err,error,*999)
                      ENDIF
                    ELSE
                      !Check the dependent variable and the mesh index match.
                      INTERFACE_MESH=>INTERFACE%coupledMeshes(MESH_INDEX)%PTR
                      IF(ASSOCIATED(INTERFACE_MESH)) THEN
                        DECOMPOSITION=>DEPENDENT_FIELD%DECOMPOSITION
                        IF(ASSOCIATED(DECOMPOSITION)) THEN
                          DEPENDENT_MESH=>DECOMPOSITION%MESH
                          IF(ASSOCIATED(DEPENDENT_MESH)) THEN
                            IF(ASSOCIATED(INTERFACE_MESH,DEPENDENT_MESH)) THEN
                              !The meshes match. Check if the dependent variable has already been added for the mesh index.
                              FOUND_MESH_INDEX=.FALSE.
                              DO variable_idx=1,INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES
                                IF(INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES(variable_idx)==MESH_INDEX) THEN
                                  FOUND_MESH_INDEX=.TRUE.
                                  EXIT
                                ENDIF
                              ENDDO !variable_idx
                              IF(FOUND_MESH_INDEX) THEN
                                !The mesh index has already been added to replace the dependent variable with the specified variable
                                INTERFACE_DEPENDENT%fieldVariables(variable_idx)%PTR=>DEPENDENT_FIELD% &
                                  & variableTypeMap(VARIABLE_TYPE)%PTR
                              ELSE
                                !The mesh index has not been found so add a new dependent variable.
                                ALLOCATE(NEW_EQUATIONS_SETS(INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES+1),STAT=ERR)
                                IF(ERR/=0) CALL FlagError("Could not allocate new equations sets.",err,error,*999)
                                ALLOCATE(NEW_FIELD_VARIABLES(INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES+1),STAT=ERR)
                                IF(ERR/=0) CALL FlagError("Could not allocate new field variables.",err,error,*999)
                                ALLOCATE(NEW_VARIABLE_MESH_INDICES(INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES+1),STAT=ERR)
                                IF(ERR/=0) CALL FlagError("Could not allocate new variable mesh indices.",err,error,*999)
                                DO variable_idx=1,INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES
                                  NEW_EQUATIONS_SETS(variable_idx)%PTR=>INTERFACE_DEPENDENT%EQUATIONS_SETS(variable_idx)%PTR
                                  NEW_FIELD_VARIABLES(variable_idx)%PTR=>INTERFACE_DEPENDENT%fieldVariables(variable_idx)%PTR
                                  NEW_VARIABLE_MESH_INDICES(variable_idx)=INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES(variable_idx)
                                ENDDO !variable_idx
                                NEW_EQUATIONS_SETS(INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES+1)%PTR=>EQUATIONS_SET
                                NEW_FIELD_VARIABLES(INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES+1)%PTR=>DEPENDENT_FIELD% &
                                  & variableTypeMap(VARIABLE_TYPE)%PTR
                                NEW_VARIABLE_MESH_INDICES(INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES+1)=MESH_INDEX
                                IF(ASSOCIATED(INTERFACE_DEPENDENT%EQUATIONS_SETS)) DEALLOCATE(INTERFACE_DEPENDENT%EQUATIONS_SETS)
                                IF(ASSOCIATED(INTERFACE_DEPENDENT%fieldVariables)) DEALLOCATE(INTERFACE_DEPENDENT%fieldVariables)
                                IF(ASSOCIATED(INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES)) &
                                  & DEALLOCATE(INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES)
                                INTERFACE_DEPENDENT%EQUATIONS_SETS=>NEW_EQUATIONS_SETS
                                INTERFACE_DEPENDENT%fieldVariables=>NEW_FIELD_VARIABLES
                                INTERFACE_DEPENDENT%VARIABLE_MESH_INDICES=>NEW_VARIABLE_MESH_INDICES
                                INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES= &
                                  & INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES+1
                              ENDIF
                            ELSE
                              CALL FlagError("The dependent field mesh does not match the interface mesh.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("The dependent field decomposition mesh is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("The dependent field decomposition is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="The interface mesh for mesh index "//TRIM(NumberToVString(MESH_INDEX,"*",err,error))// &
                          & " is not associated."
                        CALL FlagError(LOCAL_ERROR,err,error,*999)
                      ENDIF
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
                      & " has not been created on field number "// &
                      & TRIM(NumberToVString(DEPENDENT_FIELD%userNumber,"*",err,error))//"."
                    CALL FlagError(LOCAL_ERROR,err,error,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
                    & " is invalid. The variable type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
                  CALL FlagError(LOCAL_ERROR,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Equations set dependent field is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Equations set is not associated.",err,error,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specificed mesh index of "//TRIM(NumberToVString(MESH_INDEX,"*",err,error))// &
              & " is invalid. The mesh index must be > 0 and <= "// &
              & TRIM(NumberToVString(INTERFACE%numberOfCoupledMeshes,"*",err,error))//"."
            CALL FlagError(LOCAL_ERROR,err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Interface condition interface is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Interface condition dependent is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Interface conditions is not associated.",err,error,*999)
    ENDIF
    
    EXITS("INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD",err,error)
    RETURN 1   
  END SUBROUTINE INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD
  
  !
  !================================================================================================================================
  !

  !>Destroys an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_Destroy
  SUBROUTINE INTERFACE_CONDITION_DESTROY(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to destroy
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: interface_condition_idx,interface_condition_position
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NEW_INTERFACE_CONDITIONS(:)
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: INTERFACE_CONDITIONS

    NULLIFY(NEW_INTERFACE_CONDITIONS)

    ENTERS("INTERFACE_CONDITION_DESTROY",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      INTERFACE_CONDITIONS=>INTERFACE_CONDITION%interfaceConditions
      IF(ASSOCIATED(INTERFACE_CONDITIONS)) THEN
        interface_condition_position=INTERFACE_CONDITION%globalNumber

        !Destroy all the interface condition components
        CALL INTERFACE_CONDITION_FINALISE(INTERFACE_CONDITION,err,error,*999)
        
        !Remove the interface condition from the list of interface conditions
        IF(INTERFACE_CONDITIONS%numberOfInterfaceConditions>1) THEN
          ALLOCATE(NEW_INTERFACE_CONDITIONS(INTERFACE_CONDITIONS%numberOfInterfaceConditions-1),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate new interface conditions.",err,error,*999)
          DO interface_condition_idx=1,INTERFACE_CONDITIONS%numberOfInterfaceConditions
            IF(interface_condition_idx<interface_condition_position) THEN
              NEW_INTERFACE_CONDITIONS(interface_condition_idx)%PTR=>INTERFACE_CONDITIONS% &
                & interfaceConditions(interface_condition_idx)%PTR
            ELSE IF(interface_condition_idx>interface_condition_position) THEN
              INTERFACE_CONDITIONS%interfaceConditions(interface_condition_idx)%PTR%globalNumber=INTERFACE_CONDITIONS% &
                & interfaceConditions(interface_condition_idx)%PTR%globalNumber-1
              NEW_INTERFACE_CONDITIONS(interface_condition_idx-1)%PTR=>INTERFACE_CONDITIONS% &
                & interfaceConditions(interface_condition_idx)%PTR
            ENDIF
          ENDDO !interface_conditions_idx
          IF(ASSOCIATED(INTERFACE_CONDITIONS%interfaceConditions)) DEALLOCATE(INTERFACE_CONDITIONS%interfaceConditions)
          INTERFACE_CONDITIONS%interfaceConditions=>NEW_INTERFACE_CONDITIONS
          INTERFACE_CONDITIONS%numberOfInterfaceConditions=INTERFACE_CONDITIONS%numberOfInterfaceConditions-1
        ELSE
          DEALLOCATE(INTERFACE_CONDITIONS%interfaceConditions)
          INTERFACE_CONDITIONS%numberOfInterfaceConditions=0
        ENDIF
        
      ELSE
        CALL FlagError("Interface conditions interface conditions is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Interface conditions is not associated.",err,error,*998)
    ENDIF    

    EXITS("INTERFACE_CONDITION_DESTROY")
    RETURN
999 IF(ASSOCIATED(NEW_INTERFACE_CONDITIONS)) DEALLOCATE(NEW_INTERFACE_CONDITIONS)
998 ERRORSEXITS("INTERFACE_CONDITION_DESTROY",err,error)
    RETURN 1   
  END SUBROUTINE INTERFACE_CONDITION_DESTROY
  
  !
  !================================================================================================================================
  !

  !>Finish the creation of interface equations for the interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_EquationsCreateFinish
  SUBROUTINE INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to finish the creation of the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG), ALLOCATABLE :: STORAGE_TYPE(:),STRUCTURE_TYPE(:)
    LOGICAL, ALLOCATABLE :: MATRICES_TRANSPOSE(:)
    INTEGER(INTG) :: number_of_dependent_variables
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: INTERFACE_DEPENDENT
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(InterfaceMappingType), POINTER :: INTERFACE_MAPPING
    TYPE(InterfaceMatricesType), POINTER :: INTERFACE_MATRICES
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    ENTERS("INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      SELECT CASE(INTERFACE_CONDITION%METHOD)
      CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,INTERFACE_CONDITION_PENALTY_METHOD)
        !Finish the interface equations creation
        NULLIFY(INTERFACE_EQUATIONS)
        CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
        CALL InterfaceEquations_AssertNotFinished(INTERFACE_EQUATIONS,ERR,ERROR,*999)
        CALL INTERFACE_EQUATIONS_CREATE_FINISH(INTERFACE_EQUATIONS,err,error,*999)
        INTERFACE_DEPENDENT=>INTERFACE_CONDITION%DEPENDENT
        IF(ASSOCIATED(INTERFACE_DEPENDENT)) THEN
          !Create the interface mapping.
          NULLIFY(INTERFACE_MAPPING)
          CALL INTERFACE_MAPPING_CREATE_START(INTERFACE_EQUATIONS,INTERFACE_MAPPING,err,error,*999)
          CALL InterfaceMapping_LagrangeVariableSet(INTERFACE_MAPPING,FIELD_U_VARIABLE_TYPE,err,error,*999)
          SELECT CASE(INTERFACE_CONDITION%METHOD)
          CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD)
            number_of_dependent_variables=INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES
          CASE(INTERFACE_CONDITION_PENALTY_METHOD)
            number_of_dependent_variables=INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES+1
          ENDSELECT
          CALL INTERFACE_MAPPING_MATRICES_NUMBER_SET(INTERFACE_MAPPING,number_of_dependent_variables,err,error,*999)
          ALLOCATE(MATRICES_TRANSPOSE(number_of_dependent_variables),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate matrices transpose.",err,error,*999)
          MATRICES_TRANSPOSE=.TRUE.
          SELECT CASE(INTERFACE_CONDITION%METHOD)
          CASE(INTERFACE_CONDITION_PENALTY_METHOD)
            !Set the last interface matrix to have no transpose
            MATRICES_TRANSPOSE(number_of_dependent_variables)=.FALSE.
          ENDSELECT
          CALL INTERFACE_MAPPING_MATRICES_TRANSPOSE_SET(INTERFACE_MAPPING,MATRICES_TRANSPOSE,err,error,*999)
          IF(ALLOCATED(MATRICES_TRANSPOSE)) DEALLOCATE(MATRICES_TRANSPOSE)
          CALL INTERFACE_MAPPING_RHS_VARIABLE_TYPE_SET(INTERFACE_MAPPING,FIELD_DELUDELN_VARIABLE_TYPE,err,error,*999)
          CALL INTERFACE_MAPPING_CREATE_FINISH(INTERFACE_MAPPING,err,error,*999)
          !Create the interface matrices
          NULLIFY(INTERFACE_MATRICES)
          CALL InterfaceMatrices_CreateStart(INTERFACE_EQUATIONS,INTERFACE_MATRICES,err,error,*999)
          ALLOCATE(STORAGE_TYPE(INTERFACE_MATRICES%numberOfInterfaceMatrices),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate storage type.",err,error,*999)
          SELECT CASE(INTERFACE_EQUATIONS%sparsityType)
          CASE(INTERFACE_MATRICES_FULL_MATRICES) 
            STORAGE_TYPE=MATRIX_BLOCK_STORAGE_TYPE
            CALL InterfaceMatrices_StorageTypeSet(INTERFACE_MATRICES,STORAGE_TYPE,err,error,*999)
          CASE(INTERFACE_MATRICES_SPARSE_MATRICES) 
            ALLOCATE(STRUCTURE_TYPE(INTERFACE_MATRICES%numberOfInterfaceMatrices),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate structure type.",err,error,*999)
            STORAGE_TYPE=MATRIX_COMPRESSED_ROW_STORAGE_TYPE
            STRUCTURE_TYPE=INTERFACE_MATRIX_FEM_STRUCTURE
            CALL InterfaceMatrices_StorageTypeSet(INTERFACE_MATRICES,STORAGE_TYPE,err,error,*999)
            CALL InterfaceMatrices_StructureTypeSet(INTERFACE_MATRICES,STRUCTURE_TYPE,err,error,*999)
            IF(ALLOCATED(STRUCTURE_TYPE)) DEALLOCATE(STRUCTURE_TYPE)
          CASE DEFAULT
            LOCAL_ERROR="The interface equations sparsity type of "// &
              & TRIM(NumberToVString(INTERFACE_EQUATIONS%sparsityType,"*",err,error))//" is invalid."
            CALL FlagError(LOCAL_ERROR,err,error,*999)
          END SELECT
          IF(ALLOCATED(STORAGE_TYPE)) DEALLOCATE(STORAGE_TYPE)
          CALL InterfaceMatrices_CreateFinish(INTERFACE_MATRICES,err,error,*999)
        ELSE
          CALL FlagError("Interface condition dependent is not associated.",err,error,*999)
        ENDIF
      CASE(INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(INTERFACE_CONDITION_POINT_TO_POINT_METHOD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        LOCAL_ERROR="The interface condition method of "//TRIM(NumberToVString(INTERFACE_CONDITION%METHOD,"*",err,error))// &
          & " is invalid."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Interface conditions is not associated.",err,error,*999)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH")
    RETURN
999 IF(ALLOCATED(MATRICES_TRANSPOSE)) DEALLOCATE(MATRICES_TRANSPOSE)
    IF(ALLOCATED(STORAGE_TYPE)) DEALLOCATE(STORAGE_TYPE)
    IF(ALLOCATED(STRUCTURE_TYPE)) DEALLOCATE(STRUCTURE_TYPE)
    ERRORSEXITS("INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH",err,error)
    RETURN 1
    
  END SUBROUTINE INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH

  !
  !================================================================================================================================
  !

  !>Start the creation of interface equations for the interface condition. \see CMISSInterfaceConditionEquationsCreateStart
  !>Default values set for the INTERFACE_EQUATIONS's attributes are:
  !>- OUTPUT_TYPE: 0 (INTERFACE_EQUATIONS_NO_OUTPUT)
  !>- SPARSITY_TYPE: 1 (INTERFACE_EQUATIONS_SPARSE_MATRICES)
  SUBROUTINE INTERFACE_CONDITION_EQUATIONS_CREATE_START(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to create the interface equations for
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS !<On exit, a pointer to the created interface equations. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: INTERFACE_DEPENDENT
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("INTERFACE_CONDITION_EQUATIONS_CREATE_START",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(ASSOCIATED(INTERFACE_EQUATIONS)) THEN
        CALL FlagError("Interface equations is already associated.",err,error,*999)
      ELSE
        NULLIFY(INTERFACE_EQUATIONS)
        SELECT CASE(INTERFACE_CONDITION%METHOD)
        CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,INTERFACE_CONDITION_PENALTY_METHOD)
          IF(ASSOCIATED(INTERFACE_CONDITION%LAGRANGE)) THEN
            IF(INTERFACE_CONDITION%lagrange%LAGRANGE_FINISHED) THEN
              INTERFACE_DEPENDENT=>INTERFACE_CONDITION%DEPENDENT
              IF(ASSOCIATED(INTERFACE_DEPENDENT)) THEN
                !Initialise the setup
                CALL INTERFACE_EQUATIONS_CREATE_START(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
                !Set the number of interpolation sets
                CALL InterfaceEquations_InterfaceInterpSetsNumberSet(INTERFACE_EQUATIONS,1,1,1,err,error,*999)
                DO variable_idx=1,INTERFACE_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES
                  CALL InterfaceEquations_VariableInterpSetsNumberSet(INTERFACE_EQUATIONS,variable_idx,1,1,0, &
                    & err,error,*999)
                ENDDO !variable_idx
              ELSE
                CALL FlagError("Interface condition dependent is not associated.",err,error,*999)
              ENDIF
              !Return the pointer
              INTERFACE_EQUATIONS=>INTERFACE_CONDITION%interfaceEquations
            ELSE
              CALL FlagError("Interface condition Lagrange field has not been finished.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Interface condition Lagrange is not associated.",err,error,*999)
          ENDIF
        CASE(INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(INTERFACE_CONDITION_POINT_TO_POINT_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          LOCAL_ERROR="The interface condition method of "//TRIM(NumberToVString(INTERFACE_CONDITION%METHOD,"*",err,error))// &
            & " is invalid."
          CALL FlagError(LOCAL_ERROR,err,error,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_EQUATIONS_CREATE_START")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_EQUATIONS_CREATE_START",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_EQUATIONS_CREATE_START

  !
  !================================================================================================================================
  !

  !>Destroy the interface equations for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_EquationsDestroy
  SUBROUTINE INTERFACE_CONDITION_EQUATIONS_DESTROY(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface conditions to destroy the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("INTERFACE_CONDITION_EQUATIONS_DESTROY",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(ASSOCIATED(INTERFACE_CONDITION%interfaceEquations)) THEN
        CALL INTERFACE_EQUATIONS_DESTROY(INTERFACE_CONDITION%interfaceEquations,err,error,*999)
      ELSE
        CALL FlagError("Interface condition interface equations is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_EQUATIONS_DESTROY")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_EQUATIONS_DESTROY",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_EQUATIONS_DESTROY

  !
  !================================================================================================================================
  !

  !>Finalise the interface condition and deallocate all memory.
  SUBROUTINE INTERFACE_CONDITION_FINALISE(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to finalise.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("INTERFACE_CONDITION_FINALISE",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      CALL INTERFACE_CONDITION_GEOMETRY_FINALISE(INTERFACE_CONDITION%GEOMETRY,err,error,*999)
      CALL INTERFACE_CONDITION_LAGRANGE_FINALISE(INTERFACE_CONDITION%LAGRANGE,err,error,*999)
      CALL INTERFACE_CONDITION_PENALTY_FINALISE(INTERFACE_CONDITION%PENALTY,err,error,*999)
      CALL INTERFACE_CONDITION_DEPENDENT_FINALISE(INTERFACE_CONDITION%DEPENDENT,err,error,*999)
      IF(ASSOCIATED(INTERFACE_CONDITION%interfaceEquations)) &
        & CALL INTERFACE_EQUATIONS_DESTROY(INTERFACE_CONDITION%interfaceEquations,err,error,*999)
      DEALLOCATE(INTERFACE_CONDITION)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_FINALISE")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_FINALISE

!
  !================================================================================================================================
  !

  !>Returns the interface condition integration type 
  SUBROUTINE InterfaceCondition_IntegrationTypeGet(interfaceCondition,interfaceConditionIntegrationType,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition !<A pointer to the interface condition to get the operator for
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see INTERFACE_CONDITIONS_IntegrationType,INTERFACE_CONDITIONS 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("InterfaceCondition_IntegrationTypeGet",err,error,*999)

    IF(ASSOCIATED(interfaceCondition)) THEN
      IF(interfaceCondition%INTERFACE_CONDITION_FINISHED) THEN
        interfaceConditionIntegrationType=interfaceCondition%integrationType
      ELSE
        CALL FlagError("Interface condition has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
    
    EXITS("InterfaceCondition_IntegrationTypeGet")
    RETURN
999 ERRORSEXITS("InterfaceCondition_IntegrationTypeGet",err,ERROR)
    RETURN 1
  END SUBROUTINE InterfaceCondition_IntegrationTypeGet
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the interface condition integration type 
  SUBROUTINE InterfaceCondition_IntegrationTypeSet(interfaceCondition,interfaceConditionIntegrationType,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition !<A pointer to the interface condition to set the operator for
    INTEGER(INTG), INTENT(IN) :: interfaceConditionIntegrationType !<The interface condition integration type to set. \see INTERFACE_CONDITIONS_IntegrationType,INTERFACE_CONDITIONS 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("InterfaceCondition_IntegrationTypeSet",err,error,*999)

    IF(ASSOCIATED(interfaceCondition)) THEN
      IF(interfaceCondition%INTERFACE_CONDITION_FINISHED) THEN
        CALL FlagError("Interface condition has been finished.",err,error,*999)
      ELSE
        SELECT CASE(interfaceConditionIntegrationType)
        CASE(INTERFACE_CONDITION_GAUSS_INTEGRATION)
          interfaceCondition%integrationType=INTERFACE_CONDITION_GAUSS_INTEGRATION
        CASE(INTERFACE_CONDITION_DATA_POINTS_INTEGRATION)
          interfaceCondition%integrationType=INTERFACE_CONDITION_DATA_POINTS_INTEGRATION
        CASE DEFAULT
          localError="The specified interface condition operator of "// &
            & TRIM(NumberToVString(interfaceConditionIntegrationType,"*",err,ERROR))//" is not valid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
    
    EXITS("InterfaceCondition_IntegrationTypeSet")
    RETURN
999 ERRORSEXITS("InterfaceCondition_IntegrationTypeSet",err,ERROR)
    RETURN 1
  END SUBROUTINE InterfaceCondition_IntegrationTypeSet


  !
  !================================================================================================================================
  !

  !>Finalise the interface condition geometry information and deallocate all memory.
  SUBROUTINE INTERFACE_CONDITION_GEOMETRY_FINALISE(INTERFACE_GEOMETRY,err,error,*)

    !Argument variables
    TYPE(INTERFACE_GEOMETRY_TYPE) :: INTERFACE_GEOMETRY !<The interface condition geometry information to finalise.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("INTERFACE_CONDITION_GEOMETRY_FINALISE",err,error,*999)

    NULLIFY(INTERFACE_GEOMETRY%INTERFACE_CONDITION)
    NULLIFY(INTERFACE_GEOMETRY%geometricField)
       
    EXITS("INTERFACE_CONDITION_GEOMETRY_FINALISE")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_GEOMETRY_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_GEOMETRY_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises an interface condition geometry information.
  SUBROUTINE INTERFACE_CONDITION_GEOMETRY_INITIALISE(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<The pointer to the interface condition to initialise to initialise the geometry information for.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR
 
    ENTERS("INTERFACE_CONDITION_GEOMETRY_INITIALISE",err,error,*998)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      INTERFACE_CONDITION%GEOMETRY%INTERFACE_CONDITION=>INTERFACE_CONDITION
      NULLIFY(INTERFACE_CONDITION%GEOMETRY%geometricField)
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_GEOMETRY_INITIALISE")
    RETURN
999 CALL INTERFACE_CONDITION_GEOMETRY_FINALISE(INTERFACE_CONDITION%GEOMETRY,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("INTERFACE_CONDITION_GEOMETRY_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_GEOMETRY_INITIALISE

  !
  !================================================================================================================================
  !

  !>Initialises an interface condition.
  SUBROUTINE INTERFACE_CONDITION_INITIALISE(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<The pointer to the interface condition to initialise. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR
 
    ENTERS("INTERFACE_CONDITION_INITIALISE",err,error,*998)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      CALL FlagError("Interface condition is already associated.",err,error,*998)
    ELSE
      ALLOCATE(INTERFACE_CONDITION,STAT=ERR)
      IF(ERR/=0) CALL FlagError("Could not allocate interface condition.",err,error,*999)
      INTERFACE_CONDITION%userNumber=0
      INTERFACE_CONDITION%globalNumber=0
      INTERFACE_CONDITION%INTERFACE_CONDITION_FINISHED=.FALSE.
      NULLIFY(INTERFACE_CONDITION%interfaceConditions)
      INTERFACE_CONDITION%label=""
      NULLIFY(INTERFACE_CONDITION%INTERFACE)
      INTERFACE_CONDITION%outputType=INTERFACE_CONDITION_NO_OUTPUT
      INTERFACE_CONDITION%METHOD=0
      INTERFACE_CONDITION%OPERATOR=0
      NULLIFY(INTERFACE_CONDITION%LAGRANGE)
      NULLIFY(INTERFACE_CONDITION%PENALTY)
      NULLIFY(INTERFACE_CONDITION%DEPENDENT)
      NULLIFY(INTERFACE_CONDITION%interfaceEquations)
      CALL INTERFACE_CONDITION_GEOMETRY_INITIALISE(INTERFACE_CONDITION,err,error,*999)
      NULLIFY(INTERFACE_CONDITION%BOUNDARY_CONDITIONS)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_INITIALISE")
    RETURN
999 CALL INTERFACE_CONDITION_FINALISE(INTERFACE_CONDITION,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("INTERFACE_CONDITION_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating an interface condition's Lagrange multiplier field \see OpenCMISS::Iron::cmfe_InterfaceCondition_LagrangeFieldCreateFinish
  SUBROUTINE InterfaceCondition_LagrangeFieldCreateFinish(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to finish creating the Lagrange field for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: LagrangeFieldUVariableNumberOfComponents,LagrangeFieldDelUDelNVariableNumberOfComponents
    
    ENTERS("InterfaceCondition_LagrangeFieldCreateFinish",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(ASSOCIATED(INTERFACE_CONDITION%LAGRANGE)) THEN
        IF(INTERFACE_CONDITION%lagrange%LAGRANGE_FINISHED) THEN
          CALL FlagError("Interface condition Lagrange field has already been finished.",err,error,*999)
        ELSE
          !Finish the Lagrange field creation
          IF(INTERFACE_CONDITION%lagrange%LAGRANGE_FIELD_AUTO_CREATED) THEN
            CALL FIELD_CREATE_FINISH(INTERFACE_CONDITION%lagrange%LAGRANGE_FIELD,err,error,*999)
          ENDIF
          INTERFACE_CONDITION%lagrange%LAGRANGE_FINISHED=.TRUE.
          !\todo test following condition using some other method since FIELD_NUMBER_OF_COMPONENTS_GET requires the field to be finished which is what occurs above, but below condition needs to be checked before this.
          CALL FIELD_NUMBER_OF_COMPONENTS_GET(INTERFACE_CONDITION%lagrange%LAGRANGE_FIELD,FIELD_U_VARIABLE_TYPE, &
            & LagrangeFieldUVariableNumberOfComponents,err,error,*999)
          CALL FIELD_NUMBER_OF_COMPONENTS_GET(INTERFACE_CONDITION%lagrange%LAGRANGE_FIELD,FIELD_DELUDELN_VARIABLE_TYPE, &
            & LagrangeFieldDelUDelNVariableNumberOfComponents,err,error,*999)
          IF (LagrangeFieldUVariableNumberOfComponents /= LagrangeFieldDelUDelNVariableNumberOfComponents) THEN
            CALL FlagError("Interface Lagrange field U and DelUDelN variable components do not match.",err,error,*999)
          ENDIF
        ENDIF
      ELSE
        CALL FlagError("Interface condition Lagrange is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
       
    EXITS("InterfaceCondition_LagrangeFieldCreateFinish")
    RETURN
999 ERRORS("InterfaceCondition_LagrangeFieldCreateFinish",err,error)
    EXITS("InterfaceCondition_LagrangeFieldCreateFinish")
    RETURN 1
   
  END SUBROUTINE InterfaceCondition_LagrangeFieldCreateFinish
        
  !
  !================================================================================================================================
  !

  !>Starts the process of creating the Lagrange multiplyer field for interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_LagrangeFieldCreateStart
  SUBROUTINE InterfaceCondition_LagrangeFieldCreateStart(interfaceCondition,lagrangeFieldUserNumber,lagrangeField, &
    & err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition !<A pointer to the interface condition to create the Lagrange field on
    INTEGER(INTG), INTENT(IN) :: lagrangeFieldUserNumber !<The user specified Lagrange field number
    TYPE(FieldType), POINTER :: lagrangeField !<If associated on entry, a pointer to the user created Lagrange field which has the same user number as the specified Lagrange field user number. If not associated on entry, on exit, a pointer to the created Lagrange field for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,interpolationType,geometricScalingType,dependentVariableNumber,numberOfDimensions
    TYPE(CoordinateSystemType), POINTER :: interfaceCoordinateSystem
    TYPE(DecompositionType), POINTER :: geometricDecomposition
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: interfaceDependent
    TYPE(RegionType), POINTER :: interfaceRegion,lagrangeFieldRegion
    TYPE(VARYING_STRING) :: localError

    ENTERS("InterfaceCondition_LagrangeFieldCreateStart",err,error,*999)

    IF(.NOT.ASSOCIATED(interfaceCondition)) CALL FlagError("Interface condition is not associated.",err,error,*999)
    IF(ASSOCIATED(interfaceCondition%lagrange)) CALL FlagError("Interface condition Lagrange is already associated.", &
      & err,error,*999)
    NULLIFY(interfaceDependent)
    CALL InterfaceCondition_InterfaceDependentGet(interfaceCondition,interfaceDependent,err,error,*999)
    NULLIFY(interface)
    CALL InterfaceCondition_InterfaceGet(interfaceCondition,interface,err,error,*999)
    NULLIFY(interfaceRegion)
    CALL Interface_ParentRegionGet(INTERFACE,interfaceRegion,err,error,*999)
    NULLIFY(interfaceCoordinateSystem)
    CALL Interface_CoordinateSystemGet(INTERFACE,interfaceCoordinateSystem,err,error,*999)
    CALL CoordinateSystem_DimensionGet(interfaceCoordinateSystem,numberOfDimensions,err,error,*999)
    IF(ASSOCIATED(lagrangeField)) THEN
      !Check the Lagrange field has been finished
      CALL Field_AssertIsFinished(lagrangeField,err,error,*999)
      !Check the user numbers match
      IF(lagrangeFieldUserNumber/=lagrangeField%userNumber) THEN
        localError="The specified Lagrange field user number of "// &
          & TRIM(NumberToVString(lagrangeFieldUserNumber,"*",err,error))// &
          & " does not match the user number of the specified Lagrange field of "// &
          & TRIM(NumberToVString(lagrangeField%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      NULLIFY(lagrangeFieldRegion)
      CALL Field_RegionGet(lagrangeField,lagrangeFieldRegion,err,error,*999)
      !Check the field is defined on the same region as the interface
      IF(lagrangeFieldRegion%userNumber/=interfaceRegion%userNumber) THEN
        localError="Invalid region setup. The specified Lagrange field has been created on interface number "// &
          & TRIM(NumberToVString(INTERFACE%userNumber,"*",err,error))//" in parent region number "// &
          & TRIM(NumberToVString(lagrangeFieldRegion%userNumber,"*",err,error))// &
          & " and the specified interface has been created in parent region number "// &
          & TRIM(NumberToVString(interfaceRegion%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      !Check the user number has not already been used for a field in this region.
      NULLIFY(field)
      CALL Field_UserNumberFind(lagrangeFieldUserNumber,interface,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        localError="The specified Lagrange field user number of "// &
          & TRIM(NumberToVString(lagrangeFieldUserNumber,"*",err,error))// &
          & " has already been used to create a field on interface number "// &
          & TRIM(NumberToVString(interface%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ENDIF
    CALL INTERFACE_CONDITION_LAGRANGE_INITIALISE(interfaceCondition,err,error,*999)
    IF(.NOT.ASSOCIATED(lagrangeField)) THEN
      !Create the Lagrange field
      interfaceCondition%lagrange%LAGRANGE_FIELD_AUTO_CREATED=.TRUE.
      CALL Field_CreateStart(lagrangeFieldUserNumber,interfaceCondition%INTERFACE,interfaceCondition%lagrange%LAGRANGE_FIELD, &
        & err,error,*999)
      CALL Field_LabelSet(interfaceCondition%lagrange%LAGRANGE_FIELD,"Lagrange Multipliers Field",err,error,*999)
      CALL Field_TypeSetAndLock(interfaceCondition%lagrange%lagrange_FIELD,FIELD_GENERAL_TYPE,err,error,*999)
      CALL Field_DependentTypeSetAndLock(interfaceCondition%lagrange%LAGRANGE_FIELD,FIELD_DEPENDENT_TYPE,err,error,*999)
      NULLIFY(geometricDecomposition)
      CALL Field_DecompositionGet(interfaceCondition%geometry%geometricField,geometricDecomposition,err,error,*999)
      CALL Field_DecompositionSetAndLock(interfaceCondition%lagrange%LAGRANGE_FIELD,geometricDecomposition,err,error,*999)
      CALL Field_GeometricFieldSetAndLock(interfaceCondition%lagrange%LAGRANGE_FIELD,interfaceCondition%geometry%geometricField, &
        & err,error,*999)
      CALL Field_NumberOfVariablesSetAndLock(interfaceCondition%lagrange%LAGRANGE_FIELD,2,err,error,*999)
      CALL Field_VariableTypesSetAndLock(interfaceCondition%lagrange%LAGRANGE_FIELD,[FIELD_U_VARIABLE_TYPE, &
        & FIELD_DELUDELN_VARIABLE_TYPE],err,error,*999)
      CALL Field_VariableLabelSet(interfaceCondition%lagrange%LAGRANGE_FIELD,FIELD_U_VARIABLE_TYPE,"Lambda", &
        & err,error,*999)
      CALL Field_VariableLabelSet(interfaceCondition%lagrange%LAGRANGE_FIELD,FIELD_DELUDELN_VARIABLE_TYPE, &
        & "Lambda RHS",err,error,*999)
      CALL Field_DimensionSetAndLock(interfaceCondition%lagrange%LAGRANGE_FIELD,FIELD_U_VARIABLE_TYPE, &
        & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
      CALL Field_DimensionSetAndLock(interfaceCondition%lagrange%LAGRANGE_FIELD,FIELD_DELUDELN_VARIABLE_TYPE, &
        & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
      CALL Field_DataTypeSetAndLock(interfaceCondition%lagrange%LAGRANGE_FIELD,FIELD_U_VARIABLE_TYPE, &
        & FIELD_DP_TYPE,err,error,*999)
      CALL Field_DataTypeSetAndLock(interfaceCondition%lagrange%LAGRANGE_FIELD,FIELD_DELUDELN_VARIABLE_TYPE, &
        & FIELD_DP_TYPE,err,error,*999)
      IF (interfaceCondition%OPERATOR==INTERFACE_CONDITION_SOLID_FLUID_OPERATOR) THEN
        ! Remove pressure component from number of coupled components
        ! INTERFACE_CONDITION_SOLID_FLUID_OPERATOR might not be used as it is equivalent to
        ! INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR if set up correctly
        interfaceCondition%lagrange%numberOfComponents=numberOfDimensions
      ELSE
        !Note that only components present in both the coupled meshes interface dependent fields can be coupled
        !Default the number of component to be the minimum number of components across all the coupled dependent 
        !variables.
        !\todo Check ordering of variable components which are coupled and uncoupled are handled correctly to ensure that
        !coupled variable components don't have to always come before the uncoupled variable components
        interfaceCondition%lagrange%numberOfComponents=0
        DO dependentVariableNumber=1,interfaceDependent%NUMBER_OF_DEPENDENT_VARIABLES
          IF (interfaceDependent%fieldVariables(dependentVariableNumber)%ptr%numberOfComponents< &
            & interfaceCondition%lagrange%numberOfComponents) THEN
            interfaceCondition%lagrange%numberOfComponents= &
              & interfaceDependent%fieldVariables(dependentVariableNumber)%ptr%numberOfComponents
          ELSEIF (interfaceCondition%lagrange%numberOfComponents==0) THEN
            interfaceCondition%lagrange%numberOfComponents= &
              & interfaceDependent%fieldVariables(dependentVariableNumber)%ptr%numberOfComponents
          ENDIF
        ENDDO !dependentVariableNumber
      ENDIF
      CALL Field_NumberOfComponentsSet(interfaceCondition%lagrange%LAGRANGE_FIELD,FIELD_U_VARIABLE_TYPE, &
        & interfaceCondition%lagrange%numberOfComponents,err,error,*999)
      CALL Field_NumberOfComponentsSet(interfaceCondition%lagrange%LAGRANGE_FIELD,FIELD_DELUDELN_VARIABLE_TYPE, &
        & interfaceCondition%lagrange%numberOfComponents,err,error,*999)
      DO componentIdx=1,interfaceCondition%lagrange%numberOfComponents
        CALL Field_ComponentInterpolationGet(interfaceDependent%fieldVariables(1)%ptr%field,FIELD_U_VARIABLE_TYPE, &
          & componentIdx,interpolationType,err,error,*999)
        CALL Field_ComponentInterpolationSet(interfaceCondition%lagrange%LAGRANGE_FIELD, &
          & FIELD_U_VARIABLE_TYPE,componentIdx,interpolationType,err,error,*999)
        CALL Field_ComponentInterpolationSet(interfaceCondition%lagrange%LAGRANGE_FIELD, &
          & FIELD_DELUDELN_VARIABLE_TYPE,componentIdx,interpolationType,err,error,*999)
      ENDDO !componentIdx
      CALL Field_ScalingTypeGet(interfaceCondition%geometry%geometricField,geometricScalingType,err,error,*999)
      CALL Field_ScalingTypeSet(interfaceCondition%lagrange%LAGRANGE_FIELD,geometricScalingType,err,error,*999)
    ELSE
      !Check the Lagrange field
      CALL FlagError("Not implemented.",err,error,*999)
    ENDIF
    !Set pointers
    IF(interfaceCondition%lagrange%LAGRANGE_FIELD_AUTO_CREATED) THEN
      lagrangeField=>interfaceCondition%lagrange%LAGRANGE_FIELD
    ELSE
      interfaceCondition%lagrange%LAGRANGE_FIELD=>lagrangeField
    ENDIF
    
    EXITS("InterfaceCondition_LagrangeFieldCreateStart")
    RETURN
999 ERRORSEXITS("InterfaceCondition_LagrangeFieldCreateStart",err,error)
    RETURN 1
    
  END SUBROUTINE InterfaceCondition_LagrangeFieldCreateStart
  
  !
  !================================================================================================================================
  !

  !>Finalise the interface condition Lagrange information and deallocate all memory.
  SUBROUTINE INTERFACE_CONDITION_LAGRANGE_FINALISE(INTERFACE_LAGRANGE,err,error,*)

    !Argument variables
    TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: INTERFACE_LAGRANGE !<A pointer to the interface condition Lagrange information to finalise.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("INTERFACE_CONDITION_LAGRANGE_FINALISE",err,error,*999)

    IF(ASSOCIATED(INTERFACE_LAGRANGE)) THEN
      DEALLOCATE(INTERFACE_LAGRANGE)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_LAGRANGE_FINALISE")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_LAGRANGE_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_LAGRANGE_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises an interface condition Lagrange information.
  SUBROUTINE INTERFACE_CONDITION_LAGRANGE_INITIALISE(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<The pointer to the interface condition to initialise to initialise the Lagrange information for.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR
 
    ENTERS("INTERFACE_CONDITION_LAGRANGE_INITIALISE",err,error,*998)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(ASSOCIATED(INTERFACE_CONDITION%LAGRANGE)) THEN
        CALL FlagError("Interface condition Lagrange is already associated.",err,error,*999)
      ELSE
        ALLOCATE(INTERFACE_CONDITION%LAGRANGE,STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate interface condition Lagrange.",err,error,*999)
        INTERFACE_CONDITION%lagrange%INTERFACE_CONDITION=>INTERFACE_CONDITION
        INTERFACE_CONDITION%lagrange%LAGRANGE_FINISHED=.FALSE.
        INTERFACE_CONDITION%lagrange%LAGRANGE_FIELD_AUTO_CREATED=.FALSE.
        NULLIFY(INTERFACE_CONDITION%lagrange%LAGRANGE_FIELD)
        INTERFACE_CONDITION%lagrange%numberOfComponents=0
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_LAGRANGE_INITIALISE")
    RETURN
999 CALL INTERFACE_CONDITION_LAGRANGE_FINALISE(INTERFACE_CONDITION%LAGRANGE,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("INTERFACE_CONDITION_LAGRANGE_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_LAGRANGE_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating an interface condition's penalty field'. \see OpenCMISS::Iron::cmfe_InterfaceCondition_PenaltyConditionCreateFinish
  SUBROUTINE InterfaceCondition_PenaltyFieldCreateFinish(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to finish creating the penalty field for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    
    ENTERS("InterfaceCondition_PenaltyFieldCreateFinish",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(ASSOCIATED(INTERFACE_CONDITION%PENALTY)) THEN
        IF(INTERFACE_CONDITION%PENALTY%PENALTY_FINISHED) THEN
          CALL FlagError("Interface condition penalty field has already been finished.",err,error,*999)
        ELSE
          !Finish the penalty field creation
          IF(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD_AUTO_CREATED) THEN
            CALL FIELD_CREATE_FINISH(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,err,error,*999)
          ENDIF
          INTERFACE_CONDITION%PENALTY%PENALTY_FINISHED=.TRUE.
        ENDIF
      ELSE
        CALL FlagError("Interface condition penalty is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
       
    EXITS("InterfaceCondition_PenaltyFieldCreateFinish")
    RETURN
999 ERRORSEXITS("InterfaceCondition_PenaltyFieldCreateFinish",err,error)
    RETURN 1
   
  END SUBROUTINE InterfaceCondition_PenaltyFieldCreateFinish

  !
  !================================================================================================================================
  !

  !>Starts the process of creating the penalty field for interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_PenaltyFieldCreateStart
  SUBROUTINE InterfaceCondition_PenaltyFieldCreateStart(INTERFACE_CONDITION,PENALTY_FIELD_USER_NUMBER,PENALTY_FIELD, &
    & err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to create the penalty field on
    INTEGER(INTG), INTENT(IN) :: PENALTY_FIELD_USER_NUMBER !<The user specified penalty field number
    TYPE(FieldType), POINTER :: PENALTY_FIELD !<If associated on entry, a pointer to the user created penalty field which has the same user number as the specified penalty field user number. If not associated on entry, on exit, a pointer to the created penalty field for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,GEOMETRIC_SCALING_TYPE
    TYPE(DecompositionType), POINTER :: GEOMETRIC_DECOMPOSITION
    TYPE(FieldType), POINTER :: FIELD
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: INTERFACE_DEPENDENT
    TYPE(RegionType), POINTER :: INTERFACE_REGION,PENALTY_FIELD_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("InterfaceCondition_PenaltyFieldCreateStart",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(ASSOCIATED(INTERFACE_CONDITION%PENALTY)) THEN
        CALL FlagError("Interface condition penalty is already associated.",err,error,*999)
      ELSE
        INTERFACE_DEPENDENT=>INTERFACE_CONDITION%DEPENDENT
        IF(ASSOCIATED(INTERFACE_DEPENDENT)) THEN
          INTERFACE=>INTERFACE_CONDITION%INTERFACE
          IF(ASSOCIATED(INTERFACE)) THEN
            INTERFACE_REGION=>INTERFACE%parentRegion
            IF(ASSOCIATED(INTERFACE_REGION)) THEN
              IF(ASSOCIATED(PENALTY_FIELD)) THEN
                !Check the penalty field has been finished
                CALL Field_AssertIsFinished(PENALTY_FIELD,err,error,*999)
                !Check the user numbers match
                IF(PENALTY_FIELD_USER_NUMBER/=PENALTY_FIELD%userNumber) THEN
                  LOCAL_ERROR="The specified penalty field user number of "// &
                    & TRIM(NumberToVString(PENALTY_FIELD_USER_NUMBER,"*",err,error))// &
                    & " does not match the user number of the specified penalty field of "// &
                    & TRIM(NumberToVString(PENALTY_FIELD%userNumber,"*",err,error))//"."
                  CALL FlagError(LOCAL_ERROR,err,error,*999)
                ENDIF
                PENALTY_FIELD_REGION=>PENALTY_FIELD%REGION
                IF(ASSOCIATED(PENALTY_FIELD_REGION)) THEN
                  !Check the field is defined on the same region as the interface
                  IF(PENALTY_FIELD_REGION%userNumber/=INTERFACE_REGION%userNumber) THEN
                    LOCAL_ERROR="Invalid region setup. The specified penalty field has been created on interface number "// &
                      & TRIM(NumberToVString(INTERFACE%userNumber,"*",err,error))//" in parent region number "// &
                      & TRIM(NumberToVString(PENALTY_FIELD_REGION%userNumber,"*",err,error))// &
                      & " and the specified interface has been created in parent region number "// &
                      & TRIM(NumberToVString(INTERFACE_REGION%userNumber,"*",err,error))//"."
                    CALL FlagError(LOCAL_ERROR,err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The penalty field region is not associated.",err,error,*999)
                ENDIF
              ELSE
                !Check the user number has not already been used for a field in this region.
                NULLIFY(FIELD)
                CALL FIELD_USER_NUMBER_FIND(PENALTY_FIELD_USER_NUMBER,INTERFACE,FIELD,err,error,*999)
                IF(ASSOCIATED(FIELD)) THEN
                  LOCAL_ERROR="The specified penalty field user number of "// &
                    & TRIM(NumberToVString(PENALTY_FIELD_USER_NUMBER,"*",err,error))// &
                    & " has already been used to create a field on interface number "// &
                    & TRIM(NumberToVString(INTERFACE%userNumber,"*",err,error))//"."
                  CALL FlagError(LOCAL_ERROR,err,error,*999)
                ENDIF
              ENDIF
              CALL INTERFACE_CONDITION_PENALTY_INITIALISE(INTERFACE_CONDITION,err,error,*999)
              IF(.NOT.ASSOCIATED(PENALTY_FIELD)) THEN
                !Create the penalty field
                INTERFACE_CONDITION%PENALTY%PENALTY_FIELD_AUTO_CREATED=.TRUE.
                CALL Field_CreateStart(PENALTY_FIELD_USER_NUMBER,INTERFACE_CONDITION%INTERFACE,INTERFACE_CONDITION%PENALTY% &
                  & PENALTY_FIELD,err,error,*999)
                CALL Field_LabelSet(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,"Penalty Field",err,error,*999)
                CALL Field_TypeSetAndLock(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,FIELD_GENERAL_TYPE,err,error,*999)
                CALL Field_DependentTypeSetAndLock(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,FIELD_DEPENDENT_TYPE, &
                  & err,error,*999)
                NULLIFY(GEOMETRIC_DECOMPOSITION)
                CALL Field_DecompositionGet(INTERFACE_CONDITION%GEOMETRY%geometricField,GEOMETRIC_DECOMPOSITION, &
                  & err,error,*999)
                CALL Field_DecompositionSetAndLock(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,GEOMETRIC_DECOMPOSITION, &
                  & err,error,*999)
                CALL Field_GeometricFieldSetAndLock(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,INTERFACE_CONDITION%GEOMETRY% &
                  & geometricField,err,error,*999)
                CALL Field_NumberOfVariablesSetAndLock(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,1,err,error,*999)
                CALL Field_VariableTypesSetAndLock(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,[FIELD_U_VARIABLE_TYPE], &
                  & err,error,*999)
                CALL Field_VariableLabelSet(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,FIELD_U_VARIABLE_TYPE,"Alpha", &
                  & err,error,*999)
                CALL Field_DimensionSetAndLock(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,FIELD_U_VARIABLE_TYPE, &
                   & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_DataTypeSetAndLock(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,FIELD_U_VARIABLE_TYPE, &
                  & FIELD_DP_TYPE,err,error,*999)
                IF(INTERFACE_CONDITION%OPERATOR==INTERFACE_CONDITION_FLS_CONTACT_OPERATOR .OR. &
                    & INTERFACE_CONDITION%OPERATOR==INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR) THEN
                  !Default 1 component for the contact lagrange variable in a frictionless contact problem
                  CALL Field_NumberOfComponentsSet(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,FIELD_U_VARIABLE_TYPE, &
                    & 1,err,error,*999)
                  CALL Field_ComponentInterpolationSet(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD, &
                      & FIELD_U_VARIABLE_TYPE,1,FIELD_CONSTANT_INTERPOLATION,err,error,*999)
                ELSE
                  !Default the number of component to the first variable of the interface dependent field's number of components, 
                  CALL Field_NumberOfComponentsSet(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,FIELD_U_VARIABLE_TYPE, &
                    & INTERFACE_DEPENDENT%fieldVariables(1)%PTR%numberOfComponents,err,error,*999)
                  DO componentIdx=1,INTERFACE_DEPENDENT%fieldVariables(1)%PTR%numberOfComponents
                    CALL FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD, &
                      & FIELD_U_VARIABLE_TYPE,componentIdx,FIELD_CONSTANT_INTERPOLATION,err,error,*999)
                  ENDDO !componentIdx
                ENDIF
                CALL Field_ScalingTypeGet(INTERFACE_CONDITION%GEOMETRY%geometricField,GEOMETRIC_SCALING_TYPE, &
                  & err,error,*999)
                CALL Field_ScalingTypeSet(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD,GEOMETRIC_SCALING_TYPE, &
                  & err,error,*999)
              ELSE
                !Check the penalty field
                CALL FlagError("Not implemented.",err,error,*999)
              ENDIF
              !Set pointers
              IF(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD_AUTO_CREATED) THEN
                PENALTY_FIELD=>INTERFACE_CONDITION%PENALTY%PENALTY_FIELD
              ELSE
                INTERFACE_CONDITION%PENALTY%PENALTY_FIELD=>PENALTY_FIELD
              ENDIF
            ELSE
              CALL FlagError("The interface parent region is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The interface interface conditions is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Interface condition dependent is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Interface conditions is not associated.",err,error,*999)
    ENDIF
    
    EXITS("InterfaceCondition_PenaltyFieldCreateStart")
    RETURN
999 ERRORSEXITS("InterfaceCondition_PenaltyFieldCreateStart",err,error)
    RETURN 1
    
  END SUBROUTINE InterfaceCondition_PenaltyFieldCreateStart
  
  !
  !================================================================================================================================
  !

  !>Finalise the interface condition penalty information and deallocate all memory.
  SUBROUTINE INTERFACE_CONDITION_PENALTY_FINALISE(INTERFACE_PENALTY,err,error,*)

    !Argument variables
    TYPE(INTERFACE_PENALTY_TYPE), POINTER :: INTERFACE_PENALTY !<A pointer to the interface condition penalty information to finalise.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("INTERFACE_CONDITION_PENALTY_FINALISE",err,error,*999)

    IF(ASSOCIATED(INTERFACE_PENALTY)) THEN
      DEALLOCATE(INTERFACE_PENALTY)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_PENALTY_FINALISE")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_PENALTY_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_PENALTY_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises an interface condition penalty information.
  SUBROUTINE INTERFACE_CONDITION_PENALTY_INITIALISE(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<The pointer to the interface condition to initialise to initialise the penalty information for.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR
 
    ENTERS("INTERFACE_CONDITION_PENALTY_INITIALISE",err,error,*998)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(ASSOCIATED(INTERFACE_CONDITION%PENALTY)) THEN
        CALL FlagError("Interface condition penalty is already associated.",err,error,*999)
      ELSE
        ALLOCATE(INTERFACE_CONDITION%PENALTY,STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate interface condition penalty.",err,error,*999)
        INTERFACE_CONDITION%PENALTY%INTERFACE_CONDITION=>INTERFACE_CONDITION
        INTERFACE_CONDITION%PENALTY%PENALTY_FINISHED=.FALSE.
        INTERFACE_CONDITION%PENALTY%PENALTY_FIELD_AUTO_CREATED=.FALSE.
        NULLIFY(INTERFACE_CONDITION%PENALTY%PENALTY_FIELD)
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_PENALTY_INITIALISE")
    RETURN
999 CALL INTERFACE_CONDITION_PENALTY_FINALISE(INTERFACE_CONDITION%PENALTY,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("INTERFACE_CONDITION_PENALTY_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_PENALTY_INITIALISE

  !
  !================================================================================================================================
  !

  !>Returns the interface condition method \see OpenCMISS::Iron::cmfe_InterfaceCondition_MethodGet
  SUBROUTINE INTERFACE_CONDITION_METHOD_GET(INTERFACE_CONDITION,INTERFACE_CONDITION_METHOD,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to get the method for
    INTEGER(INTG), INTENT(OUT) :: INTERFACE_CONDITION_METHOD !<On return, the interface condition method. \see INTERFACE_CONDITIONS_Methods,INTERFACE_CONDITIONS
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("INTERFACE_CONDITION_METHOD_GET",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(INTERFACE_CONDITION%INTERFACE_CONDITION_FINISHED) THEN
        INTERFACE_CONDITION_METHOD=INTERFACE_CONDITION%METHOD
      ELSE
        CALL FlagError("Interface condition has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
    
    EXITS("INTERFACE_CONDITION_METHOD_GET")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_METHOD_GET",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_METHOD_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the interface condition method \see OpenCMISS::Iron::cmfe_InterfaceCondition_MethodSet
  SUBROUTINE INTERFACE_CONDITION_METHOD_SET(INTERFACE_CONDITION,INTERFACE_CONDITION_METHOD,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to set the method for
    INTEGER(INTG), INTENT(IN) :: INTERFACE_CONDITION_METHOD !<The interface condition method to set. \see INTERFACE_CONDITIONS_Methods,INTERFACE_CONDITIONS
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("INTERFACE_CONDITION_METHOD_SET",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(INTERFACE_CONDITION%INTERFACE_CONDITION_FINISHED) THEN
        CALL FlagError("Interface condition has been finished.",err,error,*999)
      ELSE
        SELECT CASE(INTERFACE_CONDITION_METHOD)
        CASE(INTERFACE_CONDITION_POINT_TO_POINT_METHOD)
          INTERFACE_CONDITION%METHOD=INTERFACE_CONDITION_POINT_TO_POINT_METHOD
        CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD)
          INTERFACE_CONDITION%METHOD=INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD
        CASE(INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD)
          INTERFACE_CONDITION%METHOD=INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD
         CASE(INTERFACE_CONDITION_PENALTY_METHOD)
          INTERFACE_CONDITION%METHOD=INTERFACE_CONDITION_PENALTY_METHOD
       CASE DEFAULT
          LOCAL_ERROR="The specified interface condition method of "// &
            & TRIM(NumberToVString(INTERFACE_CONDITION_METHOD,"*",err,error))//" is not valid."
          CALL FlagError(LOCAL_ERROR,err,error,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
    
    EXITS("INTERFACE_CONDITION_METHOD_SET")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_METHOD_SET",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_METHOD_SET
  
  !
  !================================================================================================================================
  !

  !>Returns the interface condition operator \see OpenCMISS::Iron::cmfe_InterfaceCondition_OperatorGet
  SUBROUTINE INTERFACE_CONDITION_OPERATOR_GET(INTERFACE_CONDITION,INTERFACE_CONDITION_OPERATOR,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to get the operator for
    INTEGER(INTG), INTENT(OUT) :: INTERFACE_CONDITION_OPERATOR !<On return, the interface condition operator. \see INTERFACE_CONDITIONS_Operators,INTERFACE_CONDITIONS 
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("INTERFACE_CONDITION_OPERATOR_GET",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(INTERFACE_CONDITION%INTERFACE_CONDITION_FINISHED) THEN
        INTERFACE_CONDITION_OPERATOR=INTERFACE_CONDITION%OPERATOR
      ELSE
        CALL FlagError("Interface condition has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
    
    EXITS("INTERFACE_CONDITION_OPERATOR_GET")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_OPERATOR_GET",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_OPERATOR_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the interface condition operator \see OpenCMISS::Iron::cmfe_InterfaceCondition_OperatorSet
  SUBROUTINE INTERFACE_CONDITION_OPERATOR_SET(INTERFACE_CONDITION,INTERFACE_CONDITION_OPERATOR,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to set the operator for
    INTEGER(INTG), INTENT(IN) :: INTERFACE_CONDITION_OPERATOR !<The interface condition operator to set. \see INTERFACE_CONDITIONS_Operators,INTERFACE_CONDITIONS 
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("INTERFACE_CONDITION_OPERATOR_SET",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      IF(INTERFACE_CONDITION%INTERFACE_CONDITION_FINISHED) THEN
        CALL FlagError("Interface condition has been finished.",err,error,*999)
      ELSE
        SELECT CASE(INTERFACE_CONDITION_OPERATOR)
        CASE(INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR)
          INTERFACE_CONDITION%OPERATOR=INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR
        CASE(INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR)
          INTERFACE_CONDITION%OPERATOR=INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR
        CASE(INTERFACE_CONDITION_FLS_CONTACT_OPERATOR)
          INTERFACE_CONDITION%OPERATOR=INTERFACE_CONDITION_FLS_CONTACT_OPERATOR
        CASE(INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR)
          INTERFACE_CONDITION%OPERATOR=INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR
        CASE(INTERFACE_CONDITION_SOLID_FLUID_OPERATOR)
          INTERFACE_CONDITION%OPERATOR=INTERFACE_CONDITION_SOLID_FLUID_OPERATOR
        CASE(INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR)
          INTERFACE_CONDITION%OPERATOR=INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR
        CASE DEFAULT
          LOCAL_ERROR="The specified interface condition operator of "// &
            & TRIM(NumberToVString(INTERFACE_CONDITION_OPERATOR,"*",err,error))//" is not valid."
          CALL FlagError(LOCAL_ERROR,err,error,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
    
    EXITS("INTERFACE_CONDITION_OPERATOR_SET")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_OPERATOR_SET",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITION_OPERATOR_SET
  
  !
  !================================================================================================================================
  !

  !>Gets the output type for an interface condition.
  SUBROUTINE InterfaceCondition_OutputTypeGet(interfaceCondition,outputType,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition !<A pointer to the interface condition to get the output type for
    INTEGER(INTG), INTENT(OUT) :: outputType !<On exit, the output type of the interface condition. \see INTERFACE_CONDITIONS_CONSTANTS_OutputTypes,INTERFACE_CONDITIONS_CONSTANTS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
 
    ENTERS("InterfaceCondition_OutputTypeGet",err,error,*999)

    IF(.NOT.ASSOCIATED(interfaceCondition)) CALL FlagError("Interface condition is not associated.",err,error,*999)
    IF(.NOT.interfaceCondition%INTERFACE_CONDITION_FINISHED) &
      & CALL FlagError("Interface condition has not been finished.",err,error,*999)
    
    outputType=interfaceCondition%outputType
       
    EXITS("InterfaceCondition_OutputTypeGet")
    RETURN
999 ERRORSEXITS("InterfaceCondition_OutputTypeGet",err,error)
    RETURN 1
    
  END SUBROUTINE InterfaceCondition_OutputTypeGet
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface condition.
  SUBROUTINE InterfaceCondition_OutputTypeSet(interfaceCondition,outputType,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition !<A pointer to the interface condition to set the output type for
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see INTERFACE_CONDITIONS_CONSTANTS_OutputTypes,INTERFACE_CONDITIONS_CONSTANTS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
 
    ENTERS("InterfaceCondition_OutputTypeSet",err,error,*999)

    IF(.NOT.ASSOCIATED(interfaceCondition)) CALL FlagError("Interface condition is not associated.",err,error,*999)
    IF(interfaceCondition%INTERFACE_CONDITION_FINISHED) &
      & CALL FlagError("Interface condition has already been finished.",err,error,*999)

    SELECT CASE(outputType)
    CASE(INTERFACE_CONDITION_NO_OUTPUT)
      interfaceCondition%outputType=INTERFACE_CONDITION_NO_OUTPUT
    CASE(INTERFACE_CONDITION_PROGRESS_OUTPUT)
      interfaceCondition%outputType=INTERFACE_CONDITION_PROGRESS_OUTPUT
    CASE DEFAULT
      localError="The specified output type of "//TRIM(NumberToVString(outputType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
       
    EXITS("InterfaceCondition_OutputTypeSet")
    RETURN
999 ERRORSEXITS("InterfaceCondition_OutputTypeSet",err,error)
    RETURN 1
    
  END SUBROUTINE InterfaceCondition_OutputTypeSet

  !
  !================================================================================================================================
  !

  !>Evaluates the residual for an interface condition.
  SUBROUTINE INTERFACE_CONDITION_RESIDUAL_EVALUATE(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to evaluate the residual for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("INTERFACE_CONDITION_RESIDUAL_EVALUATE",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      INTERFACE_EQUATIONS=>INTERFACE_CONDITION%interfaceEquations
      CALL InterfaceEquations_AssertIsFinished(INTERFACE_EQUATIONS,ERR,ERROR,*999)
      SELECT CASE(INTERFACE_CONDITION%METHOD)
      CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,INTERFACE_CONDITION_PENALTY_METHOD)
        CALL INTERFACE_CONDITION_RESIDUAL_EVALUATE_FEM(INTERFACE_CONDITION,err,error,*999)
      CASE(INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(INTERFACE_CONDITION_POINT_TO_POINT_METHOD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        LOCAL_ERROR="The interface condition method of "// &
          & TRIM(NumberToVString(INTERFACE_CONDITION%METHOD,"*",err,error))// &
          & " is invalid."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
    
    EXITS("INTERFACE_CONDITION_RESIDUAL_EVALUATE")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_RESIDUAL_EVALUATE",err,error)
    RETURN 1
    
  END SUBROUTINE INTERFACE_CONDITION_RESIDUAL_EVALUATE

  !
  !================================================================================================================================
  !

  !>Evaluates the residual for an interface condition using the finite element method
  SUBROUTINE INTERFACE_CONDITION_RESIDUAL_EVALUATE_FEM(INTERFACE_CONDITION,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to evaluate the residual for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: element_idx,ne,numberOfTimes
    REAL(SP) :: elementUserElapsed,elementSystemElapsed,userElapsed,userTime1(1),userTime2(1),userTime3(1),userTime4(1), &
      & userTime5(1),userTime6(1),systemElapsed,systemTime1(1),systemTime2(1),systemTime3(1),systemTime4(1), &
      & systemTime5(1),systemTime6(1)
    TYPE(DomainMappingType), POINTER :: ELEMENTS_MAPPING
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: LAGRANGE
    TYPE(InterfaceMatricesType), POINTER :: INTERFACE_MATRICES
    TYPE(FieldType), POINTER :: LAGRANGE_FIELD
 
    ENTERS("INTERFACE_CONDITION_RESIDUAL_EVALUATE_FEM",err,error,*999)

    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
      LAGRANGE=>INTERFACE_CONDITION%LAGRANGE
      IF(ASSOCIATED(LAGRANGE)) THEN
        LAGRANGE_FIELD=>INTERFACE_CONDITION%lagrange%LAGRANGE_FIELD
        IF(ASSOCIATED(LAGRANGE_FIELD)) THEN
          INTERFACE_EQUATIONS=>INTERFACE_CONDITION%interfaceEquations
          IF(ASSOCIATED(INTERFACE_EQUATIONS)) THEN
            INTERFACE_MATRICES=>INTERFACE_EQUATIONS%interfaceMatrices
            IF(ASSOCIATED(INTERFACE_MATRICES)) THEN
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,userTime1,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,systemTime1,err,error,*999)
              ENDIF
!!Do we need to transfer parameter sets???
              !Initialise the matrices and rhs vector
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_START("InterfaceMatrices_ValuesInitialise()")
#endif
              CALL InterfaceMatrices_ValueInitialise(INTERFACE_MATRICES,0.0_DP,err,error,*999)
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_STOP("InterfaceMatrices_ValuesInitialise()")
#endif
              !Assemble the elements
              !Allocate the element matrices 
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_START("InterfaceMatrices_ElementInitialise()")
#endif
              CALL InterfaceMatrices_ElementInitialise(INTERFACE_MATRICES,err,error,*999)
              ELEMENTS_MAPPING=>LAGRANGE_FIELD%DECOMPOSITION%DOMAIN(LAGRANGE_FIELD%decomposition%meshComponentNumber)%PTR% &
                & MAPPINGS%ELEMENTS
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_STOP("InterfaceMatrices_ElementInitialise()")
#endif
              !Output timing information if required
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,userTime2,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,systemTime2,err,error,*999)
                userElapsed=userTime2(1)-userTime1(1)
                systemElapsed=systemTime2(1)-systemTime1(1)
                CALL Profiling_TimingsOutput(0,"",userElapsed,systemElapsed,err,error,*999)
                CALL Profiling_TimingsOutput(1,"Setup and initialisation",userElapsed,systemElapsed,err,error,*999)
                elementUserElapsed=0.0_SP
                elementSystemElapsed=0.0_SP
              ENDIF
              numberOfTimes=0
              !Loop over the internal elements
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_START("Internal Elements Loop")
#endif
              DO element_idx=ELEMENTS_MAPPING%internalStart,ELEMENTS_MAPPING%internalFinish
                ne=ELEMENTS_MAPPING%domainList(element_idx)
                numberOfTimes=numberOfTimes+1
                CALL InterfaceMatrices_ElementCalculate(INTERFACE_MATRICES,ne,err,error,*999)
                CALL InterfaceCondition_FiniteElementCalculate(INTERFACE_CONDITION,ne,err,error,*999)
                CALL InterfaceMatrices_ElementAdd(INTERFACE_MATRICES,err,error,*999)
              ENDDO !element_idx                  
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_STOP("Internal Elements Loop")
#endif
              !Output timing information if required
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,userTime3,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,systemTime3,err,error,*999)
                userElapsed=userTime3(1)-userTime2(1)
                systemElapsed=systemTime3(1)-systemTime2(1)
                elementUserElapsed=userElapsed
                elementSystemElapsed=systemElapsed
                CALL Profiling_TimingsOutput(1,"Internal elements equations assembly",userElapsed,systemElapsed,err,error,*999)
              ENDIF
              !Loop over the boundary and ghost elements
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_START("Boundary and Ghost Elements Loop")
#endif
              DO element_idx=ELEMENTS_MAPPING%boundaryStart,ELEMENTS_MAPPING%ghostFinish
                ne=ELEMENTS_MAPPING%domainList(element_idx)
                numberOfTimes=numberOfTimes+1
                CALL InterfaceMatrices_ElementCalculate(INTERFACE_MATRICES,ne,err,error,*999)
                CALL InterfaceCondition_FiniteElementCalculate(INTERFACE_CONDITION,ne,err,error,*999)
                CALL InterfaceMatrices_ElementAdd(INTERFACE_MATRICES,err,error,*999)
              ENDDO !element_idx
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_STOP("Boundary and Ghost Elements Loop")
#endif
              !Output timing information if required
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,userTime5,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,systemTime5,err,error,*999)
                userElapsed=userTime5(1)-userTime3(1)
                systemElapsed=systemTime5(1)-systemTime3(1)
                elementUserElapsed=elementUserElapsed+userElapsed
                elementSystemElapsed=elementSystemElapsed+systemElapsed
                CALL Profiling_TimingsOutput(1,"Boundary+ghost elements equations assembly",userElapsed,systemElapsed, &
                  & err,error,*999)
                IF(numberOfTimes>0) CALL Profiling_TimingsOutput(1,"Average element equations assembly", &
                  & elementUserElapsed/numberOfTimes,elementSystemElapsed/numberOfTimes,err,error,*999)
              ENDIF
              !Finalise the element matrices
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_START("InterfaceMatrices_ElementFinalise()")
#endif
              CALL InterfaceMatrices_ElementFinalise(INTERFACE_MATRICES,err,error,*999)
#ifdef TAUPROF
              CALL TAU_STATIC_PHASE_STOP("InterfaceMatrices_ElementFinalise()")
#endif
              !Output timing information if required
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,userTime6,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,systemTime6,err,error,*999)
                userElapsed=userTime6(1)-userTime1(1)
                systemElapsed=systemTime6(1)-systemTime1(1)
                CALL Profiling_TimingsOutput(1,"Total equations assembly",userElapsed,systemElapsed,err,error,*999)
              ENDIF
              !Output equations matrices and RHS vector if required
              IF(INTERFACE_EQUATIONS%outputType>=INTERFACE_EQUATIONS_MATRIX_OUTPUT) THEN
                CALL InterfaceMatrices_Output(GENERAL_OUTPUT_TYPE,INTERFACE_MATRICES,err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Interface matrices is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Interface equations is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Interface condition Lagrange field is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Interface condition Lagrange is not associated",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF
       
    EXITS("INTERFACE_CONDITION_RESIDUAL_EVALUATE_FEM")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITION_RESIDUAL_EVALUATE_FEM",err,ERROR)
    RETURN 1
    
  END SUBROUTINE INTERFACE_CONDITION_RESIDUAL_EVALUATE_FEM
  
  !
  !================================================================================================================================
  !

  !>Calculates the element stiffness matries for the given element number for a finite element interface equations.
  SUBROUTINE InterfaceCondition_FiniteElementCalculate(interfaceCondition,interfaceElementNumber,err,error,*)

    !Argument variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition !<A pointer to the interface condition
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The element number to calcualte
    INTEGER(INTG), INTENT(OUT) :: err !<The error code 
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: interfaceEquations !<A pointer to the interface equations
    TYPE(InterfaceMatricesType), POINTER :: interfaceMatrices !<A pointer to the interface matrices
    TYPE(ElementMatrixType), POINTER :: elementMatrix !<A pointer to the interface element matrix
    INTEGER(INTG) :: interfaceMatrixIdx
    TYPE(VARYING_STRING) :: localError
    
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START("InterfaceCondition_FiniteElementCalculate")
#endif

    ENTERS("InterfaceCondition_FiniteElementCalculate",err,error,*999)
    
    IF(ASSOCIATED(interfaceCondition)) THEN
      interfaceEquations=>interfaceCondition%interfaceEquations
      IF(ASSOCIATED(interfaceEquations)) THEN
        SELECT CASE(interfaceCondition%OPERATOR)
        CASE(INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR)
          CALL FieldContinuity_FiniteElementCalculate(interfaceCondition,interfaceElementNumber,err,error,*999)
        CASE(INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR)
          CALL FlagError("Not implemented!",err,error,*999)
        CASE(INTERFACE_CONDITION_FLS_CONTACT_OPERATOR,INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR)
          CALL FrictionlessContact_FiniteElementCalculate(interfaceCondition,interfaceElementNumber,err,error,*999)
        CASE(INTERFACE_CONDITION_SOLID_FLUID_OPERATOR)
          CALL SolidFluidOperator_FiniteElementCalculate(interfaceCondition,interfaceElementNumber,err,error,*999)
          !CALL FlagError("Not implemented!",err,error,*999)
        CASE(INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR)
          CALL FlagError("Not implemented!",err,error,*999)
        CASE DEFAULT
          localError="The interface condition operator of "//TRIM(NumberToVString(interfaceCondition%OPERATOR,"*",err,error))// &
            & " is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
    
        IF(interfaceEquations%outputType>=INTERFACE_EQUATIONS_ELEMENT_MATRIX_OUTPUT) THEN
          interfaceMatrices=>interfaceEquations%interfaceMatrices
          IF(ASSOCIATED(interfaceMatrices)) THEN
            CALL WRITE_STRING(GENERAL_OUTPUT_TYPE,"Finite element interface matrices:",err,error,*999)          
            CALL WRITE_STRING_VALUE(GENERAL_OUTPUT_TYPE,"Element number = ",interfaceElementNumber,err,error,*999)
            CALL WRITE_STRING_VALUE(GENERAL_OUTPUT_TYPE,"Number of element matrices = ",interfaceMatrices% &
              & numberOfInterfaceMatrices,err,error,*999)
            DO interfaceMatrixIdx=1,interfaceMatrices%numberOfInterfaceMatrices
              CALL WRITE_STRING_VALUE(GENERAL_OUTPUT_TYPE,"Element matrix : ",interfaceMatrixIdx,err,error,*999)
              CALL WRITE_STRING_VALUE(GENERAL_OUTPUT_TYPE,"  Update matrix = ",interfaceMatrices%MATRICES(interfaceMatrixIdx)%PTR% &
                & updateMatrix,err,error,*999)
              IF(interfaceMatrices%MATRICES(interfaceMatrixIdx)%PTR%updateMatrix) THEN
                elementMatrix=>interfaceMatrices%MATRICES(interfaceMatrixIdx)%PTR%elementMatrix
                CALL WRITE_STRING_VALUE(GENERAL_OUTPUT_TYPE,"  Number of rows = ",elementMatrix%numberOfRows,err,error,*999)
                CALL WRITE_STRING_VALUE(GENERAL_OUTPUT_TYPE,"  Number of columns = ",elementMatrix%numberOfColumns, &
                  & ERR,error,*999)
                CALL WRITE_STRING_VALUE(GENERAL_OUTPUT_TYPE,"  Maximum number of rows = ",elementMatrix%maxNumberOfRows, &
                  & ERR,error,*999)
                CALL WRITE_STRING_VALUE(GENERAL_OUTPUT_TYPE,"  Maximum number of columns = ",elementMatrix% &
                  & maxNumberOfColumns,err,error,*999)
                CALL WRITE_STRING_VECTOR(GENERAL_OUTPUT_TYPE,1,1,elementMatrix%numberOfRows,8,8,elementMatrix%rowDOFS, &
                  & '("  Row dofs     :",8(X,I13))','(16X,8(X,I13))',err,error,*999)
                CALL WRITE_STRING_VECTOR(GENERAL_OUTPUT_TYPE,1,1,elementMatrix%numberOfColumns,8,8,elementMatrix% &
                  & columnDOFS,'("  Column dofs  :",8(X,I13))','(16X,8(X,I13))',err,error,*999)
                CALL WRITE_STRING_MATRIX(GENERAL_OUTPUT_TYPE,1,1,elementMatrix%numberOfRows,1,1,elementMatrix% &
                  & numberOfColumns,8,8,elementMatrix%matrix(1:elementMatrix%numberOfRows,1:elementMatrix% &
                  & numberOfColumns),WRITE_STRING_MATRIX_NAME_AND_INDICES,'("  Matrix','(",I2,",:)',' :",8(X,E13.6))', &
                  & '(16X,8(X,E13.6))',err,error,*999)
              ENDIF
            ENDDO !interfaceMatrixIdx
          ENDIF
        ENDIF
      ELSE
        CALL FlagError("Interface equations is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Interface condition is not associated.",err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP("InterfaceCondition_FiniteElementCalculate")
#endif
       
    EXITS("InterfaceCondition_FiniteElementCalculate")
    RETURN
999 ERRORSEXITS("InterfaceCondition_FiniteElementCalculate",err,error)
    RETURN 1
    
  END SUBROUTINE InterfaceCondition_FiniteElementCalculate

  !
  !================================================================================================================================
  !

  !>Finalises an interface conditions and deallocates all memory.
  SUBROUTINE INTERFACE_CONDITIONS_FINALISE(INTERFACE_CONDITIONS,err,error,*) 

    !Argument variables
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: INTERFACE_CONDITIONS !<A pointer to the interface conditions to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    
    ENTERS("INTERFACE_CONDITIONS_FINALISE",err,error,*999)
    
    IF(ASSOCIATED(INTERFACE_CONDITIONS)) THEN
      DO WHILE(INTERFACE_CONDITIONS%numberOfInterfaceConditions>0)
        INTERFACE_CONDITION=>INTERFACE_CONDITIONS%interfaceConditions(1)%PTR
        CALL INTERFACE_CONDITION_DESTROY(INTERFACE_CONDITION,err,error,*999)
      ENDDO
      IF(ASSOCIATED(INTERFACE_CONDITIONS%interfaceConditions)) DEALLOCATE(INTERFACE_CONDITIONS%interfaceConditions)
      DEALLOCATE(INTERFACE_CONDITIONS)
    ENDIF
    
    EXITS("INTERFACE_CONDITIONS_FINALISE")
    RETURN
999 ERRORSEXITS("INTERFACE_CONDITIONS_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITIONS_FINALISE

  !
  !================================================================================================================================
  !
  
  !>Initialises an interface conditions for an interface.
  SUBROUTINE INTERFACE_CONDITIONS_INITIALISE(INTERFACE,err,error,*) 

    !Argument variables
    TYPE(InterfaceType), POINTER :: INTERFACE !<A pointer to the interface to initialise the conditions for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR
     
    ENTERS("INTERFACE_CONDITIONS_INITIALISE",err,error,*998)

    IF(ASSOCIATED(INTERFACE)) THEN
      IF(ASSOCIATED(INTERFACE%interfaceConditions)) THEN
        LOCAL_ERROR="Interface conditions is already associated for interface number "// &
          & TRIM(NumberToVString(INTERFACE%userNumber,"*",err,error))//"."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      ELSE
        ALLOCATE(INTERFACE%interfaceConditions,STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate interface interface conditions.",err,error,*999)
        INTERFACE%interfaceConditions%INTERFACE=>INTERFACE
        INTERFACE%interfaceConditions%numberOfInterfaceConditions=0
        NULLIFY(INTERFACE%interfaceConditions%interfaceConditions)
      ENDIF
    ELSE
      CALL FlagError("Interface is not associated.",err,error,*998)
    ENDIF
    
    EXITS("INTERFACE_CONDITIONS_INITIALISE")
    RETURN
999 CALL INTERFACE_CONDITIONS_FINALISE(INTERFACE%interfaceConditions,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("INTERFACE_CONDITIONS_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE INTERFACE_CONDITIONS_INITIALISE

  !
  !================================================================================================================================
  !

END MODULE INTERFACE_CONDITIONS_ROUTINES
