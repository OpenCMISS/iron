!> \file
!> \author Chris Bradley
!> \brief This module handles all linear elasticity routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!>This module handles all linear elasticity routines.
MODULE LINEAR_ELASTICITY_ROUTINES

  USE BaseRoutines
  USE BasisRoutines
  USE BasisAccessRoutines
  USE BoundaryConditionsRoutines
  USE Constants
  USE ControlLoopRoutines
  USE ControlLoopAccessRoutines
  USE DistributedMatrixVector
  USE DomainMappings
  USE EquationsRoutines
  USE EquationsAccessRoutines
  USE EquationsMappingRoutines
  USE EquationsMatricesRoutines
  USE EquationsSetAccessRoutines
  USE FieldRoutines
  USE FieldAccessRoutines
  USE InputOutput
  USE ISO_VARYING_STRING
  USE Kinds
  USE Maths
  USE MatrixVector
  USE ProblemAccessRoutines
  USE Strings
  USE SolverRoutines
  USE SolverAccessRoutines
  USE Timer
  USE Types

#include "macros.h"  

  IMPLICIT NONE

  PRIVATE

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  PUBLIC LINEAR_ELASTICITY_FINITE_ELEMENT_CALCULATE

  PUBLIC LINEAR_ELASTICITY_EQUATIONS_SET_SETUP
  
  PUBLIC LinearElasticity_EquationsSetSolutionMethodSet
  
  PUBLIC LinearElasticity_BoundaryConditionsAnalyticCalculate
  
  PUBLIC LinearElasticity_EquationsSetSpecificationSet
  
  PUBLIC LinearElasticity_ProblemSpecificationSet
  
  PUBLIC LINEAR_ELASTICITY_PROBLEM_SETUP

CONTAINS

  !
  !================================================================================================================================
  !

  !>Calculates the analytic solution and sets the boundary conditions for an analytic problem.
  SUBROUTINE LinearElasticity_BoundaryConditionsAnalyticCalculate(EQUATIONS_SET,BOUNDARY_CONDITIONS,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: EQUATIONS_SET
    TYPE(BoundaryConditionsType), POINTER :: BOUNDARY_CONDITIONS
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,deriv_idx,dim_idx,local_ny,node_idx,numberOfDimensions,variable_idx,variable_type
    INTEGER(INTG) :: BC_X_FORCE_counter,BC_X_counter,BC_Y_counter,BC_X_Nodes,BC_Z_Nodes
    REAL(DP) :: ANALYTIC_VALUE,BC_VALUE,X(3),GEOMETRIC_TOL,FORCE_X,FORCE_Y,FORCE_Y_AREA,LENGTH,WIDTH,HEIGHT,E,v_X,FORCE_X_AREA
    REAL(DP) :: FORCE_Z,Iyy
    REAL(DP), POINTER :: GEOMETRIC_PARAMETERS(:)
    LOGICAL :: SET_BC
    TYPE(DomainType), POINTER :: DOMAIN
    TYPE(DomainNodesType), POINTER :: DOMAIN_NODES
    TYPE(FieldType), POINTER :: DEPENDENT_FIELD,geometricField
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE,GEOMETRIC_VARIABLE
    TYPE(VARYING_STRING) :: localError    
    
    ENTERS("LinearElasticity_BoundaryConditionsAnalyticCalculate",err,error,*999)
    GEOMETRIC_TOL=1.0E-6_DP
    !!TODO: Use Geometric/Material Field values to prescribe values in analytic solution, currently hardcodded geometry & material properties
    IF(ASSOCIATED(EQUATIONS_SET)) THEN
      IF(ASSOCIATED(EQUATIONS_SET%ANALYTIC)) THEN
        DEPENDENT_FIELD=>EQUATIONS_SET%dependent%dependentField
        IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
          geometricField=>EQUATIONS_SET%GEOMETRY%geometricField
          IF(ASSOCIATED(geometricField)) THEN
            CALL Field_NumberOfComponentsGet(geometricField,FIELD_U_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
            NULLIFY(GEOMETRIC_VARIABLE)
            CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,GEOMETRIC_VARIABLE,err,error,*999)
            NULLIFY(GEOMETRIC_PARAMETERS)
            CALL Field_ParameterSetDataGet(geometricField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,GEOMETRIC_PARAMETERS, &
              & err,error,*999)
            !
            ! IDENTIFY BOUNDARY CONDITION NODES
            !
            BC_X_Nodes = 0
            BC_Z_Nodes = 0
            BC_X_counter = 0
            BC_Y_counter = 0
            BC_X_FORCE_counter = 0
            DO variable_idx=1,DEPENDENT_FIELD%numberOfVariables
              variable_type=DEPENDENT_FIELD%VARIABLES(variable_idx)%variableType
              FIELD_VARIABLE=>DEPENDENT_FIELD%variableTypeMap(variable_type)%ptr
              IF(ASSOCIATED(FIELD_VARIABLE)) THEN
                DO component_idx=1,FIELD_VARIABLE%numberOfComponents
                  IF(FIELD_VARIABLE%COMPONENTS(component_idx)%interpolationType==FIELD_NODE_BASED_INTERPOLATION) THEN
                    DOMAIN=>FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN
                    IF(ASSOCIATED(DOMAIN)) THEN
                      IF(ASSOCIATED(DOMAIN%TOPOLOGY)) THEN
                        DOMAIN_NODES=>DOMAIN%TOPOLOGY%NODES
                        IF(ASSOCIATED(DOMAIN_NODES)) THEN
                          !Loop over the local nodes excluding the ghosts.
                          DO node_idx=1,DOMAIN_NODES%numberOfNodes
                            !!TODO \todo We should interpolate the geometric field here and the node position.
                            DO dim_idx=1,numberOfDimensions
                              !Default to version 1 of each node derivative
                              CALL FieldVariable_LocalNodeDOFGet(GEOMETRIC_VARIABLE,1,1,node_idx,dim_idx,local_ny, &
                                & err,error,*999)
                              X(dim_idx)=GEOMETRIC_PARAMETERS(local_ny)
                            ENDDO !dim_idx
                            !Loop over the derivatives
                            DO deriv_idx=1,DOMAIN_NODES%NODES(node_idx)%numberOfDerivatives
                              SET_BC = .FALSE.
                              SELECT CASE(EQUATIONS_SET%ANALYTIC%analyticFunctionType)
                              !
                              ! ONE DIMENSIONAL LINEAR ELASTICITY
                              !
                              CASE(EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1)
                                SELECT CASE(variable_type)
                                CASE(FIELD_U_VARIABLE_TYPE)
                                  SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                  CASE(NO_GLOBAL_DERIV)
                                    !pass
                                  END SELECT
                                CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                  SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                  CASE(NO_GLOBAL_DERIV)
                                    !pass
                                  END SELECT
                                END SELECT

                              !
                              ! TWO DIMENSIONAL LINEAR ELASTICITY
                              !
                              CASE(EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1)
                                SELECT CASE(component_idx)
                                CASE(1) !u component
                                  SELECT CASE(variable_type)
                                  CASE(FIELD_U_VARIABLE_TYPE)
                                    SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                    SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  END SELECT
                                CASE(2) !v component
                                  SELECT CASE(variable_type)
                                  CASE(FIELD_U_VARIABLE_TYPE)
                                    SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      IF (ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) THEN
                                        BC_X_counter = BC_X_counter + 1
                                      ENDIF
                                      IF (ABS(X(2)-0.0_DP) < GEOMETRIC_TOL) THEN
                                        BC_Y_counter = BC_Y_counter + 1
                                      ENDIF
                                    END SELECT
                                  CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                   SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  END SELECT
                                END SELECT

                              !
                              ! THREE DIMENSIONAL LINEAR ELASTICITY
                              !

                              CASE(EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1)
                                LENGTH = 20.0_DP
                                WIDTH=20.0_DP
                                HEIGHT=5.0_DP
                                SELECT CASE(component_idx)
                                CASE(1) !u component
                                  SELECT CASE(variable_type)
                                  CASE(FIELD_U_VARIABLE_TYPE)
                                    SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                   SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  END SELECT
                                CASE(2) !v component
                                  SELECT CASE(variable_type)
                                  CASE(FIELD_U_VARIABLE_TYPE)
                                    SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                   SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      IF (ABS(X(2)-WIDTH) < GEOMETRIC_TOL) THEN
                                        IF (ABS(X(1)-LENGTH) < GEOMETRIC_TOL) THEN
                                          BC_Z_Nodes = BC_Z_Nodes + 1
                                        ENDIF
                                        IF (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL) THEN
                                          BC_X_Nodes = BC_X_Nodes + 1 
                                        ENDIF
                                      ENDIF
                                    END SELECT
                                  END SELECT
                                CASE(3) !w component
                                  SELECT CASE(variable_type)
                                  CASE(FIELD_U_VARIABLE_TYPE)
                                    SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                   SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  END SELECT
                                END SELECT


                              !
                              ! THREE DIMENSIONAL LINEAR ELASTICITY FLEXURE
                              !

                              CASE(EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2)
                                !LENGTH = 1.0_DP
                                !WIDTH=2.0_DP
                                !HEIGHT=5.0_DP
                                SELECT CASE(component_idx)
                                CASE(1) !u component
                                  SELECT CASE(variable_type)
                                  CASE(FIELD_U_VARIABLE_TYPE)
                                    SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                   SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  END SELECT
                                CASE(2) !v component
                                  SELECT CASE(variable_type)
                                  CASE(FIELD_U_VARIABLE_TYPE)
                                    SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                   SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  END SELECT
                                CASE(3) !w component
                                  SELECT CASE(variable_type)
                                  CASE(FIELD_U_VARIABLE_TYPE)
                                    SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                   SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      !pass
                                    END SELECT
                                  END SELECT
                                END SELECT

                              CASE DEFAULT
                                localError="The analytic function type of "// &
                                  & TRIM(NumberToVString(EQUATIONS_SET%ANALYTIC%analyticFunctionType,"*",err,error))// &
                                  & " is invalid."
                                CALL FlagError(localError,err,error,*999)
                              END SELECT
                            ENDDO !deriv_idx
                          ENDDO !node_idx
                        ELSE
                          CALL FlagError("Domain topology nodes is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain topology is not associated.",err,error,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Domain is not associated.",err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Only node based interpolation is implemented.",err,error,*999)
                  ENDIF
                ENDDO !component_idx
              ELSE
                CALL FlagError("Field variable is not associated.",err,error,*999)
              ENDIF
            ENDDO !variable_idx

            !
            ! SET BOUNDARY CONDITIONS & ANALYTIC SOLUTION VALUES
            !
            IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
              DO variable_idx=1,DEPENDENT_FIELD%numberOfVariables
                variable_type=DEPENDENT_FIELD%VARIABLES(variable_idx)%variableType
                FIELD_VARIABLE=>DEPENDENT_FIELD%variableTypeMap(variable_type)%ptr
                IF(ASSOCIATED(FIELD_VARIABLE)) THEN
                  CALL Field_ParameterSetCreate(DEPENDENT_FIELD,variable_type,FIELD_ANALYTIC_VALUES_SET_TYPE,err,error,*999)
                  DO component_idx=1,FIELD_VARIABLE%numberOfComponents
                    IF(FIELD_VARIABLE%COMPONENTS(component_idx)%interpolationType==FIELD_NODE_BASED_INTERPOLATION) THEN
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        IF(ASSOCIATED(DOMAIN%TOPOLOGY)) THEN
                          DOMAIN_NODES=>DOMAIN%TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            !Loop over the local nodes excluding the ghosts.
                            DO node_idx=1,DOMAIN_NODES%numberOfNodes
                              !!TODO \todo We should interpolate the geometric field here and the node position.
                              DO dim_idx=1,numberOfDimensions
                                !Default to version 1 of each node derivative
                                CALL FieldVariable_LocalNodeDOFGet(GEOMETRIC_VARIABLE,1,1,node_idx,dim_idx,local_ny, &
                                  & err,error,*999)
                                X(dim_idx)=GEOMETRIC_PARAMETERS(local_ny)
                              ENDDO !dim_idx
                              !Loop over the derivatives
                              DO deriv_idx=1,DOMAIN_NODES%NODES(node_idx)%numberOfDerivatives
                                SET_BC = .FALSE.
                                SELECT CASE(EQUATIONS_SET%ANALYTIC%analyticFunctionType)
                                !
                                ! ONE DIMENSIONAL LINEAR ELASTICITY
                                !
                                CASE(EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1)
                                  FORCE_X=50.0_DP
                                  LENGTH = 20.0_DP
                                  WIDTH=20.0_DP
                                  HEIGHT=5.0_DP
                                  FORCE_X_AREA = WIDTH*HEIGHT
                                  E = 10E3_DP
                                  SELECT CASE(variable_type)
                                  !!TODO set material parameters from material field
                                  CASE(FIELD_U_VARIABLE_TYPE)
                                    SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      ANALYTIC_VALUE=(X(1)*(FORCE_X/FORCE_X_AREA))/E
                                      IF (ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) THEN
                                        SET_BC = .TRUE.
                                        BC_VALUE=0.0_DP
                                      ENDIF
                                    CASE(GLOBAL_DERIV_S1)
                                      ANALYTIC_VALUE=1.0_DP
                                    CASE DEFAULT
                                      localError="The global derivative index of "//TRIM(NumberToVString( &
                                        & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                        & err,error))//" is invalid."
                                      CALL FlagError(localError,err,error,*999)
                                    END SELECT
                                  CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                   SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                    CASE(NO_GLOBAL_DERIV)
                                      IF (ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) THEN
                                        ANALYTIC_VALUE=-FORCE_X
                                      ELSE
                                        ANALYTIC_VALUE=0.0_DP
                                      ENDIF
                                      IF (ABS(X(1)-LENGTH) < GEOMETRIC_TOL) THEN
                                        SET_BC = .TRUE.
                                        BC_VALUE=-FORCE_X
                                      ENDIF
                                    CASE(GLOBAL_DERIV_S1)
                                      ANALYTIC_VALUE=1.0_DP
                                    CASE DEFAULT
                                      localError="The global derivative index of "//TRIM(NumberToVString( &
                                        & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                        & err,error))//" is invalid."
                                      CALL FlagError(localError,err,error,*999)
                                    END SELECT
                                  CASE DEFAULT
                                    localError="The variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
                                      & " is invalid."
                                    CALL FlagError(localError,err,error,*999)
                                  END SELECT
                                !
                                ! TWO DIMENSIONAL LINEAR ELASTICITY
                                !
                                CASE(EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1)
                                  LENGTH = 20.0_DP
                                  WIDTH=20.0_DP
                                  HEIGHT=5.0_DP
                                  FORCE_Y=50.0_DP
                                  FORCE_Y_AREA=WIDTH*HEIGHT
                                  E = 10.0E3_DP
                                  v_X = 0.3_DP
                                  SELECT CASE(component_idx)
                                  CASE(1) !u component
                                  !u=Sigmax*x/E
                                    SELECT CASE(variable_type)
                                    !!TODO set material parameters from material field
                                    CASE(FIELD_U_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=(-v_X*X(1)*(FORCE_Y/FORCE_Y_AREA))/E
                                        IF (ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) THEN
                                          SET_BC = .TRUE.
                                          BC_VALUE=0.0_DP
                                        ENDIF
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=1.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=1.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=1.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                     SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=1.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=1.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=1.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE DEFAULT
                                      localError="The variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
                                        & " is invalid."
                                      CALL FlagError(localError,err,error,*999)
                                    END SELECT
                                  CASE(2) !v component
                                  !v=Sigmay*y/E
                                    SELECT CASE(variable_type)
                                    CASE(FIELD_U_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=(X(2)*(FORCE_Y/FORCE_Y_AREA))/E
                                        IF (ABS(X(2)-0.0_DP) < GEOMETRIC_TOL) THEN
                                          SET_BC = .TRUE.
                                          BC_VALUE=0.0_DP
                                        ENDIF
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                     SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=0.0_DP
                                        !If node located on a line edge of mesh
                                        IF (ABS(X(2)-WIDTH) < GEOMETRIC_TOL) THEN !Apply Force BC
                                          SET_BC = .TRUE.
                                          IF ((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .OR. (ABS(X(1)-LENGTH) < GEOMETRIC_TOL)) THEN !lies on a corner of the mesh
                                            BC_VALUE=-FORCE_Y/(BC_Y_counter-1.0_DP)*0.5_DP
                                          ELSE !does not lie on a corner of the mesh
                                            BC_VALUE=-FORCE_Y/(BC_Y_counter-1.0_DP)
                                          ENDIF
                                        ELSEIF (ABS(X(2)-0) < GEOMETRIC_TOL) THEN !Provide Analytic reaction force, node located on fixed displacment edge
                                          IF ((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .OR. (ABS(X(1)-LENGTH) < GEOMETRIC_TOL)) THEN !lies on a corner of the mesh
                                            ANALYTIC_VALUE=-FORCE_Y/(BC_Y_counter-1.0_DP)*0.5_DP
                                          ELSE !does not lie on a corner of the mesh
                                            ANALYTIC_VALUE=-FORCE_Y/(BC_Y_counter-1.0_DP)
                                          ENDIF
                                        ENDIF
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE DEFAULT
                                      localError="The variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
                                        & " is invalid."
                                      CALL FlagError(localError,err,error,*999)
                                    END SELECT
                                  CASE DEFAULT
                                    localError="The component index of "//TRIM(NumberToVString(component_idx,"*",err,error))// &
                                      & " is invalid."
                                    CALL FlagError(localError,err,error,*999)
                                  END SELECT

                                !
                                ! THREE DIMENSIONAL LINEAR ELASTICITY
                                !

                                CASE(EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1)
                                  LENGTH = 20.0_DP
                                  WIDTH=20.0_DP
                                  HEIGHT=5.0_DP
                                  FORCE_Y=50.0_DP
                                  FORCE_Y_AREA=WIDTH*HEIGHT
                                  E = 10.0E3_DP
                                  v_X = 0.3_DP
                                  SELECT CASE(component_idx)
                                  CASE(1) !u component
                                  !u=
                                    SELECT CASE(variable_type)
                                    CASE(FIELD_U_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=(-v_X*X(1)*(FORCE_Y/FORCE_Y_AREA))/E
                                        IF (ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) THEN
                                          SET_BC = .TRUE.
                                          BC_VALUE=0.0_DP
                                        ENDIF
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE DEFAULT
                                      localError="The variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
                                        & " is invalid."
                                      CALL FlagError(localError,err,error,*999)
                                    END SELECT
                                  CASE(2) !v component
                                  !v=
                                    SELECT CASE(variable_type)
                                    CASE(FIELD_U_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=(X(2)*(FORCE_Y/FORCE_Y_AREA))/E
                                        IF (ABS(X(2)-0.0_DP) < GEOMETRIC_TOL) THEN
                                          SET_BC = .TRUE.
                                          BC_VALUE=0.0_DP
                                        ENDIF
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=0.0_DP
                                        IF (ABS(X(2)-WIDTH) < GEOMETRIC_TOL) THEN !Apply Force BC
                                          SET_BC = .TRUE.
                                          IF (((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .AND. (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL)) .OR. &
                                            & ((ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .AND. (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL)) .OR. &
                                            & ((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .AND. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL)) .OR. &
                                            & ((ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .AND. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL))) THEN !lies on a corner of the mesh
                                              BC_VALUE=-FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))*0.25_DP
                                          ELSEIF ((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .OR. (ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .OR. &
                                            & (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL) .OR. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL)) THEN !lies on an edge of the mesh
                                            BC_VALUE=-FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))*0.5_DP
                                          ELSE !lies on xi2=1 face
                                            BC_VALUE=-FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))
                                          ENDIF
                                        ELSEIF (ABS(X(2)-0.0_DP) < GEOMETRIC_TOL) THEN !Provide Analytic reaction force, node located on fixed displacment edge
                                          IF (((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .AND. (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL)) .OR. &
                                            & ((ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .AND. (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL)) .OR. &
                                            & ((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .AND. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL)) .OR. &
                                            & ((ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .AND. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL))) THEN !lies on a corner of the mesh
                                              ANALYTIC_VALUE=-FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))*0.25_DP
                                          ELSEIF ((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .OR. (ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .OR. &
                                            & (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL) .OR. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL)) THEN !lies on an edge of the mesh
                                            ANALYTIC_VALUE=-FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))*0.5_DP
                                          ELSE !lies on xi2=1 face
                                            ANALYTIC_VALUE=-FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))
                                          ENDIF
                                        ENDIF
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE DEFAULT
                                      localError="The variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
                                        & " is invalid."
                                      CALL FlagError(localError,err,error,*999)
                                    END SELECT
                                  CASE(3) !w component
                                  !w=
                                    SELECT CASE(variable_type)
                                    CASE(FIELD_U_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=(-v_X*X(3)*(FORCE_Y/FORCE_Y_AREA))/E
                                        IF (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL) THEN
                                          SET_BC = .TRUE.
                                          BC_VALUE=0.0_DP
                                        ENDIF
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE DEFAULT
                                      localError="The variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
                                        & " is invalid."
                                      CALL FlagError(localError,err,error,*999)
                                    END SELECT
                                  CASE DEFAULT
                                    localError="The component index of "//TRIM(NumberToVString(component_idx,"*",err,error))// &
                                      & " is invalid."
                                    CALL FlagError(localError,err,error,*999)
                                  END SELECT



                                !
                                ! THREE DIMENSIONAL LINEAR ELASTICITY FLEXURE
                                !
                                CASE(EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2)
                                  LENGTH = 5.0_DP
                                  WIDTH=2.0_DP
                                  HEIGHT=2.0_DP
                                  FORCE_Z=-1.0_DP
                                  !FORCE_Z_AREA=WIDTH*HEIGHT
                                  E = 10.0E3_DP
                                  v_X = 0.3_DP
                                  Iyy = (HEIGHT*(WIDTH**3.0_DP))/12.0_DP
                                  SELECT CASE(component_idx)
                                  CASE(1) !u component
                                  !u=
                                    SELECT CASE(variable_type)
                                    CASE(FIELD_U_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        !ANALYTIC_VALUE=(-v_X*X(1)*(FORCE_Y/FORCE_Y_AREA))/E
                                        IF (ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) THEN
                                          SET_BC = .TRUE.
                                          BC_VALUE=0.0_DP
                                        ENDIF
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE DEFAULT
                                      localError="The variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
                                        & " is invalid."
                                      CALL FlagError(localError,err,error,*999)
                                    END SELECT
                                  CASE(2) !v component
                                  !v=
                                    SELECT CASE(variable_type)
                                    CASE(FIELD_U_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        !ANALYTIC_VALUE=(X(2)*(FORCE_Y/FORCE_Y_AREA))/E
                                        !IF (ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) THEN
                                        !  SET_BC = .TRUE.
                                        !  BC_VALUE=0.0_DP
                                        !ENDIF
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                          & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                          & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=0.0_DP
!                                      IF (ABS(X(2)-WIDTH) < GEOMETRIC_TOL) THEN !Apply Force BC
!                                        SET_BC = .TRUE.
!                                        IF (((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .AND. (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL)) .OR. &
!                                          & ((ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .AND. (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL)) .OR. &
!                                          & ((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .AND. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL)) .OR. &
!                                          & ((ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .AND. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL))) THEN !lies on a corner of the mesh
!                                            BC_VALUE=FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))*0.25_DP
!                                        ELSEIF ((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .OR. (ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .OR. &
!                                          & (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL) .OR. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL)) THEN !lies on an edge of the mesh
!                                          BC_VALUE=FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))*0.5_DP
!                                        ELSE !lies on xi2=1 face
!                                          BC_VALUE=FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))
!                                        ENDIF
!                                      ELSEIF (ABS(X(2)-0.0_DP) < GEOMETRIC_TOL) THEN !Provide Analytic reaction force, node located on fixed displacment edge
!                                        IF (((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .AND. (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL)) .OR. &
!                                          & ((ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .AND. (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL)) .OR. &
!                                          & ((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .AND. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL)) .OR. &
!                                          & ((ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .AND. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL))) THEN !lies on a corner of the mesh
!                                            ANALYTIC_VALUE=-FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))*0.25_DP
!                                        ELSEIF ((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .OR. (ABS(X(1)-LENGTH) < GEOMETRIC_TOL) .OR. &
!                                          & (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL) .OR. (ABS(X(3)-HEIGHT) < GEOMETRIC_TOL)) THEN !lies on an edge of the mesh
!                                          ANALYTIC_VALUE=-FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))*0.5_DP
!                                        ELSE !lies on xi2=1 face
!                                          ANALYTIC_VALUE=-FORCE_Y/((BC_X_Nodes-1.0_DP)*(BC_Z_Nodes-1.0_DP))
!                                        ENDIF
!                                      ENDIF
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                        & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                        & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE DEFAULT
                                      localError="The variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
                                        & " is invalid."
                                      CALL FlagError(localError,err,error,*999)
                                    END SELECT
                                  CASE(3) !w component
                                  !w=
                                    SELECT CASE(variable_type)
                                    CASE(FIELD_U_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        ANALYTIC_VALUE=0.0_DP
                                        IF ((ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) .AND. (ABS(X(2)-0.0_DP) < GEOMETRIC_TOL)) THEN
                                          ANALYTIC_VALUE=(FORCE_Z*(3.0_DP*LENGTH-X(3))*X(3)**2.0_DP)/(6.0_DP*Iyy*E)
                                        ENDIF
                                        IF (ABS(X(1)-0.0_DP) < GEOMETRIC_TOL) THEN
                                          SET_BC = .TRUE.
                                          BC_VALUE=0.0_DP
                                        ENDIF
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                        & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                        & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                                      SELECT CASE(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex)
                                      CASE(NO_GLOBAL_DERIV)
                                        IF ((ABS(X(1)-LENGTH) < GEOMETRIC_TOL)  .AND.  (ABS(X(2)-0.0_DP) < GEOMETRIC_TOL) .AND. &
                                          (ABS(X(3)-0.0_DP) < GEOMETRIC_TOL)) THEN
                                          SET_BC = .TRUE.
                                          BC_VALUE=-FORCE_Z
                                        ENDIF
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE(GLOBAL_DERIV_S1_S2_S3)
                                        ANALYTIC_VALUE=0.0_DP
                                      CASE DEFAULT
                                        localError="The global derivative index of "//TRIM(NumberToVString( &
                                        & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)%globalDerivativeIndex,"*", &
                                        & err,error))//" is invalid."
                                        CALL FlagError(localError,err,error,*999)
                                      END SELECT
                                    CASE DEFAULT
                                      localError="The variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
                                        & " is invalid."
                                      CALL FlagError(localError,err,error,*999)
                                    END SELECT
                                  CASE DEFAULT
                                    localError="The component index of "//TRIM(NumberToVString(component_idx,"*",err,error))// &
                                      & " is invalid."
                                    CALL FlagError(localError,err,error,*999)
                                  END SELECT






                                CASE DEFAULT
                                  localError="The analytic function type of "// &
                                    & TRIM(NumberToVString(EQUATIONS_SET%ANALYTIC%analyticFunctionType,"*",err,error))// &
                                    & " is invalid."
                                  CALL FlagError(localError,err,error,*999)
                                END SELECT
                                !Default to version 1 of each node derivative
                                CALL FieldVariable_LocalNodeDOFGet(FIELD_VARIABLE,1,deriv_idx,node_idx, &
                                  & component_idx,local_ny,err,error,*999)
                                CALL Field_ParameterSetUpdateLocalDOF(DEPENDENT_FIELD,variable_type, &
                                  & FIELD_ANALYTIC_VALUES_SET_TYPE,local_ny,ANALYTIC_VALUE,err,error,*999)
                                IF (SET_BC) THEN
                                  !Default to version 1 of each node derivative
                                  CALL FieldVariable_LocalNodeDOFGet(FIELD_VARIABLE,1,deriv_idx,node_idx, &
                                    & component_idx,local_ny,err,error,*999)
                                  CALL BoundaryConditions_SetLocalDOF(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variable_type, &
                                    & local_ny,BOUNDARY_CONDITION_FIXED,BC_VALUE,err,error,*999)
                                ENDIF
                              ENDDO !deriv_idx
                            ENDDO !node_idx
                          ELSE
                            CALL FlagError("Domain topology nodes is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",err,error,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Only node based interpolation is implemented.",err,error,*999)
                    ENDIF
                  ENDDO !component_idx
                  CALL Field_ParameterSetUpdateStart(DEPENDENT_FIELD,variable_type,FIELD_ANALYTIC_VALUES_SET_TYPE, &
                    & err,error,*999)
                  CALL Field_ParameterSetUpdateFinish(DEPENDENT_FIELD,variable_type,FIELD_ANALYTIC_VALUES_SET_TYPE, &
                    & err,error,*999)
                ELSE
                  CALL FlagError("Field variable is not associated.",err,error,*999)
                ENDIF
              ENDDO !variable_idx
              CALL Field_ParameterSetDataRestore(geometricField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & GEOMETRIC_PARAMETERS,err,error,*999)
            ELSE
              CALL FlagError("Boundary conditions is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Equations set geometric field is not associated.",err,error,*999)
          ENDIF            
        ELSE
          CALL FlagError("Equations set dependent field is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Equations set analytic is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Equations set is not associated.",err,error,*999)
    ENDIF
    
    EXITS("LinearElasticity_BoundaryConditionsAnalyticCalculate")
    RETURN
999 ERRORS("LinearElasticity_BoundaryConditionsAnalyticCalculate",err,error)
    EXITS("LinearElasticity_BoundaryConditionsAnalyticCalculate")
    RETURN 1
    
  END SUBROUTINE LinearElasticity_BoundaryConditionsAnalyticCalculate

  !
  !================================================================================================================================
  !

  !>Calculates the element stiffness matrices and RHS for a linear elasticity finite element equations set.
  SUBROUTINE LINEAR_ELASTICITY_FINITE_ELEMENT_CALCULATE(EQUATIONS_SET,ELEMENT_NUMBER,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: EQUATIONS_SET !<A pointer to the equations set to perform the finite element 
    !<calculations on
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER !<The element number to calculate
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string

    !Local Variables
    INTEGER(INTG) :: FIELD_VAR_TYPE,ng,ni,xi,mi,ns,nhs,ms,mhs,TOTAL_DEPENDENT_BASIS_EP,MESH_COMPONENT
    INTEGER(INTG) :: NUMBER_OF_DEPENDENT_COMPONENTS,NUMBER_OF_XI !,NUMBER_OF_GEOMETRIC_COMPONENTS
    INTEGER(INTG) :: OFF_DIAG_COMP(3),OFF_DIAG_DEP_VAR(2,2,3),DIAG_SUB_MAT_LOC(3),OFF_DIAG_SUB_MAT_LOC(2,3)
    INTEGER(INTG) :: DEPENDENT_BASES_EP(3) !,GEOMETRIC_BASES_EP(:)
    REAL(DP) :: JRWG,C(6,6),JRWG_DIAG_C(3,3),JRWG_OFF_DIAG_C(2,3)
    REAL(DP):: SF(64*3)

    !LOGICAL :: SAME_BASIS
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMappingLinearType), POINTER :: linearMapping
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatrixType), POINTER :: equationsMatrix
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: dependentField,geometricField
    TYPE(BasisPtrType) :: DEPENDENT_BASES(3) !,GEOMETRIC_BASES(:)
    TYPE(QuadratureSchemePtrType) :: QUADRATURE_SCHEMES(3)
    TYPE(EquationsMatricesRHSType), POINTER :: rhsVector
    TYPE(FieldInterpolationParametersType), POINTER :: GEOMETRIC_INTERPOLATION_PARAMETERS
    TYPE(FieldInterpolationParametersType), POINTER :: DEPENDENT_INTERPOLATION_PARAMETERS
    !TYPE(FieldInterpolationParametersType), POINTER :: FIBRE_INTERPOLATION_PARAMETERS
    TYPE(FieldInterpolationParametersType), POINTER :: MATERIALS_INTERPOLATION_PARAMETERS
    TYPE(FieldInterpolatedPointType), POINTER :: materialsInterpPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: geometricInterpPointMetrics
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError
    TYPE DPHI_DX_COMP_TYPE !A type to store DPHIDX for each mesh component
    REAL(DP) :: DPHIDX(64,3)
    END TYPE DPHI_DX_COMP_TYPE
    TYPE(DPHI_DX_COMP_TYPE) :: DPHIDX_COMP(3)

    ENTERS("LINEAR_ELASTICITY_FINITE_ELEMENT_CALCULATE",err,error,*999)
    !!Have a look at XPES40.f in the old CMISS code.
    !!Q - CPB: Need to think about anisotropic materials with fibre fields.
    !!Q - CPB: why store this DPHIDX(ns,xi) as opposed to just using it directly? A - to minimize operations - Otherwise it would be calculated many more times than
    !!         necessary within the loops below 
    !!Q - TPBG: Need to be able to use different Quadrature schemes with different bases? A - No use highest quadrature scheme for all directions
    !!TODO:: Check whether quadrature scheme being used is suffient to interpolate highest order basis function
    !!Q - TPBG: Need to be able to use different Interpolation for Geometric & Dependent field?
    IF(ASSOCIATED(EQUATIONS_SET)) THEN
      IF(.NOT.ALLOCATED(EQUATIONS_SET%SPECIFICATION)) THEN
        CALL FlagError("Equations set specification is not allocated.",err,error,*999)
      ELSE IF(SIZE(EQUATIONS_SET%SPECIFICATION,1)/=3) THEN
        CALL FlagError("Equations set specification must have three entries for a linear elasticity type equations set.", &
          & err,error,*999)
      END IF
      EQUATIONS=>EQUATIONS_SET%EQUATIONS
      IF(ASSOCIATED(EQUATIONS)) THEN
        NULLIFY(vectorEquations)
        CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
        dependentField=>equations%interpolation%dependentField
        geometricField=>equations%interpolation%geometricField
        !fibreField=>equations%interpolation%fibreField
        vectorMatrices=>vectorEquations%vectorMatrices
        equationsMatrix=>vectorMatrices%linearMatrices%matrices(1)%ptr
        rhsVector=>vectorMatrices%rhsVector
        vectorMapping=>vectorEquations%vectorMapping
        linearMapping=>vectorMapping%linearMapping
        FIELD_VARIABLE=>linearMapping%equationsMatrixToVarMaps(1)%variable
        FIELD_VAR_TYPE=FIELD_VARIABLE%variableType
        !Note that the dimension/number of components for FIELD_U_VARIABLE_TYPE has to be the same as the FIELD_DELUDELN_VARIABLE_TYPE
        !& Number of Geometric field components = number of dependent field component
        NUMBER_OF_DEPENDENT_COMPONENTS=geometricField%variableTypeMap(1)%ptr%numberOfComponents
        !NUMBER_OF_GEOMETRIC_COMPONENTS=dependentField%variableTypeMap(1)%ptr%numberOfComponents
        !!TODO:: Use highest interpolation scheme's guass points. Warn if Gauss Points insufficient
        !Create an array of Bases with each component 
        DO ns=1,NUMBER_OF_DEPENDENT_COMPONENTS
          MESH_COMPONENT=dependentField%variableTypeMap(1)%ptr%COMPONENTS(ns)%meshComponentNumber
          DEPENDENT_BASES(ns)%ptr=>dependentField%DECOMPOSITION%DOMAIN(MESH_COMPONENT)%ptr% &
            & TOPOLOGY%ELEMENTS%ELEMENTS(ELEMENT_NUMBER)%BASIS
          DEPENDENT_BASES_EP(ns)=DEPENDENT_BASES(ns)%ptr%numberOfElementParameters
          QUADRATURE_SCHEMES(ns)%ptr=>DEPENDENT_BASES(ns)%ptr%QUADRATURE%quadratureSchemeMap(BASIS_DEFAULT_QUADRATURE_SCHEME)%ptr
        ENDDO
        NUMBER_OF_XI = DEPENDENT_BASES(1)%ptr%numberOfXi
        TOTAL_DEPENDENT_BASIS_EP = SUM(DEPENDENT_BASES_EP(1:NUMBER_OF_XI))
        !DO ns=1,NUMBER_OF_GEOMETRIC_COMPONENTS
        !  MESH_COMPONENT=dependentField%variableTypeMap(1)%ptr%COMPONENTS(ns)%meshComponentNumber
        !  GEOMETRIC_BASES(ns)%ptr=>geometricField%DECOMPOSITION%DOMAIN(MESH_COMPONENT)%ptr% &
        !    & TOPOLOGY%ELEMENTS%ELEMENTS(ELEMENT_NUMBER)%BASIS
        !  GEOMETRIC_BASES_EP(ns)=GEOMETRIC_BASES(ns)%ptr%numberOfElementParameters
        !ENDDO
        SELECT CASE(EQUATIONS_SET%SPECIFICATION(3))
        !
        !ONE, TWO & THREE DIMENSIONAL LINEAR ELASTICITY
        !
        CASE(EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE,EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE, &
          & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE,EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE)
          !//
          !Parameters for number of off diagonal stress/strain terms for a given number of xi directions and order of calculation for shear terms
          !These parameters do not change for 1D,2D,3D Linear Elasticity
          OFF_DIAG_COMP = [0,1,3]
          OFF_DIAG_DEP_VAR(1,1,:) = [1,1,2]
          OFF_DIAG_DEP_VAR(1,2,:) = [2,3,3]
          OFF_DIAG_DEP_VAR(2,1,:) = OFF_DIAG_DEP_VAR(1,2,:)
          OFF_DIAG_DEP_VAR(2,2,:) = OFF_DIAG_DEP_VAR(1,1,:)
          !//
          DIAG_SUB_MAT_LOC(:) = [0,DEPENDENT_BASES_EP(1),SUM(DEPENDENT_BASES_EP(1:2))]
          OFF_DIAG_SUB_MAT_LOC(1,:) = [0,0,DEPENDENT_BASES_EP(1)]
          OFF_DIAG_SUB_MAT_LOC(2,:) = [DEPENDENT_BASES_EP(1),DIAG_SUB_MAT_LOC(3),DIAG_SUB_MAT_LOC(3)]

          IF(equationsMatrix%updateMatrix) THEN
            !Get the geometric, fibre & material field interpolation parameters
            GEOMETRIC_INTERPOLATION_PARAMETERS=>equations%interpolation%geometricInterpParameters(FIELD_U_VARIABLE_TYPE)%ptr
            !FIBRE_INTERPOLATION_PARAMETERS=>equations%interpolation%FIBRE_INTERP_PARAMETERS
            MATERIALS_INTERPOLATION_PARAMETERS=>equations%interpolation%materialsInterpParameters(FIELD_U_VARIABLE_TYPE)%ptr
            CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,ELEMENT_NUMBER, &
              & GEOMETRIC_INTERPOLATION_PARAMETERS,err,error,*999)
            !CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,ELEMENT_NUMBER, &
            !  & FIBRE_INTERPOLATION_PARAMETERS,err,error,*999)
            CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,ELEMENT_NUMBER, &
              & MATERIALS_INTERPOLATION_PARAMETERS,err,error,*999)
            geometricInterpPointMetrics=>equations%interpolation%geometricInterpPointMetrics(FIELD_U_VARIABLE_TYPE)%ptr
            materialsInterpPoint=>equations%interpolation%materialsInterpPoint(FIELD_U_VARIABLE_TYPE)%ptr
            !Loop over gauss points & integrate upper triangular portion of Stiffness matrix
            DO ng=1,QUADRATURE_SCHEMES(1)%ptr%numberOfGauss !Gauss point index
              !Interpolate geometric, fibre and material fields at gauss points & calculate geometric field metrics
              CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,ng,equations%interpolation% &
                & geometricInterpPoint(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
              !CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,ng,equations%interpolation% &
              !  & FIBRE_INTERP_POINT,err,error,*999)
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,ng,materialsInterpPoint,err,error,*999)
              !!TODO:: Add option to only evaluate required metrics
              CALL Field_InterpolatedPointMetricsCalculate(NUMBER_OF_XI,geometricInterpPointMetrics,err,error,*999)
              !Calculate JRWG.
              JRWG=QUADRATURE_SCHEMES(1)%ptr%gaussWeights(ng)*geometricInterpPointMetrics%jacobian
              DO xi=1,NUMBER_OF_XI
                DPHIDX_COMP(xi)%DPHIDX = 0.0_DP
                DO ns=1,DEPENDENT_BASES_EP(xi)
                  DO mi=1,NUMBER_OF_XI
                    DO ni=1,NUMBER_OF_XI
                      DPHIDX_COMP(xi)%DPHIDX(ns,mi) = DPHIDX_COMP(xi)%DPHIDX(ns,mi)+geometricInterpPointMetrics%dXidX(mi,ni)* &
                        & QUADRATURE_SCHEMES(xi)%ptr%gaussBasisFunctions(ns,PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni),ng)
                    ENDDO !ni
                  ENDDO !mi
                ENDDO !ns
              ENDDO !xi
              !CALL COORDINATE_MATERIAL_COORDINATE_SYSTEM_CALCULATE(equations%interpolation%geometricInterpPoint, &
              !  equations%interpolation%FIBRE_INTERP_POINT,DXDNU,err,error,*999)
              !Create Linear Elasticity Tensor C
              CALL LINEAR_ELASTICITY_TENSOR(EQUATIONS_SET%SPECIFICATION(3),materialsInterpPoint,C,err,error,*999)
              !Store Elasticity Tensor diagonal & off diagonal stress coefficients
              JRWG_DIAG_C(3,:) = [JRWG*C(4,4),JRWG*C(5,5),JRWG*C(3,3)]
              JRWG_DIAG_C(2,:) = [JRWG*C(6,6),JRWG*C(2,2),JRWG_DIAG_C(3,2)]
              JRWG_DIAG_C(1,:) = [JRWG*C(1,1),JRWG_DIAG_C(2,1),JRWG_DIAG_C(3,1)]
              JRWG_OFF_DIAG_C(1,:) = [JRWG*C(1,2),JRWG*C(1,3),JRWG*C(2,3)]
              JRWG_OFF_DIAG_C(2,:) = [JRWG*C(6,6),JRWG*C(4,4),JRWG*C(5,5)]
              !Construct Element Matrix Diagonal Terms
              DO xi=1,NUMBER_OF_XI
                DO ns=1,DEPENDENT_BASES_EP(xi)
                  DO ms=ns,DEPENDENT_BASES_EP(xi)
                    equationsMatrix%elementMatrix%matrix(DIAG_SUB_MAT_LOC(xi)+ns,DIAG_SUB_MAT_LOC(xi)+ms) = &
                      & equationsMatrix%elementMatrix%matrix(DIAG_SUB_MAT_LOC(xi)+ns,DIAG_SUB_MAT_LOC(xi)+ms) + &
                      & DOT_PRODUCT(DPHIDX_COMP(xi)%DPHIDX(ns,1:NUMBER_OF_XI)*DPHIDX_COMP(xi)%DPHIDX(ms,1:NUMBER_OF_XI), &
                      & JRWG_DIAG_C(xi,1:NUMBER_OF_XI))
                  ENDDO !ms
                ENDDO !ns
              ENDDO !xi
              !Construct Element Matrix Off-Diagonal Terms
              DO xi=1,OFF_DIAG_COMP(NUMBER_OF_XI)
                DO ns=1,DEPENDENT_BASES_EP(OFF_DIAG_DEP_VAR(1,1,xi))
                  DO ms=1,DEPENDENT_BASES_EP(OFF_DIAG_DEP_VAR(1,2,xi))
                    equationsMatrix%elementMatrix%matrix(OFF_DIAG_SUB_MAT_LOC(1,xi)+ns,OFF_DIAG_SUB_MAT_LOC(2,xi)+ms) = &
                      & equationsMatrix%elementMatrix%matrix(OFF_DIAG_SUB_MAT_LOC(1,xi)+ns,OFF_DIAG_SUB_MAT_LOC(2,xi)+ms)+ &
                      & DOT_PRODUCT(DPHIDX_COMP(OFF_DIAG_DEP_VAR(1,1,xi))%DPHIDX(ns,OFF_DIAG_DEP_VAR(1,:,xi))* &
                      &  DPHIDX_COMP(OFF_DIAG_DEP_VAR(1,2,xi))%DPHIDX(ms,OFF_DIAG_DEP_VAR(2,:,xi)),JRWG_OFF_DIAG_C(:,xi))
                  ENDDO !ms
                ENDDO !ns
              ENDDO !xi

             !Below is the full form of constructing the off-Diagonal terms. This will be documented in the linear elasticity equation set page on doxygen for clarity

             !Expanding the DOT_PRODUCT terms

             !OFF_DIAG_DEP_VAR(1,:) = [1,1,2]
             !OFF_DIAG_DEP_VAR(2,:) = [2,3,3]
             ! DO xi=1,OFF_DIAG_COMP(NUMBER_OF_XI)
             !   DO ns=1,DEPENDENT_BASES_EP(OFF_DIAG_DEP_VAR(1,1,xi))
             !     DO ms=1,DEPENDENT_BASES_EP(OFF_DIAG_DEP_VAR(1,2,xi))
             !       equationsMatrix%elementMatrix%matrix(OFF_DIAG_SUB_MAT_LOC(1,xi)+ns,OFF_DIAG_SUB_MAT_LOC(2,xi)+ms) = &
             !         & equationsMatrix%elementMatrix%matrix(OFF_DIAG_SUB_MAT_LOC(1,xi)+ns,OFF_DIAG_SUB_MAT_LOC(2,xi)+ms)+ &
             !         & JRWG_OFF_DIAG_C(1,xi)*DPHIDX_COMP(OFF_DIAG_DEP_VAR(1,xi))%DPHIDX(ns,OFF_DIAG_DEP_VAR(1,xi))* &
             !         & DPHIDX_COMP(OFF_DIAG_DEP_VAR(2,xi))%DPHIDX(ms,OFF_DIAG_DEP_VAR(2,xi)) + &
             !         & JRWG_OFF_DIAG_C(2,xi)*DPHIDX_COMP(OFF_DIAG_DEP_VAR(1,xi))%DPHIDX(ns,OFF_DIAG_DEP_VAR(2,xi))* &
             !         & DPHIDX_COMP(OFF_DIAG_DEP_VAR(2,xi))%DPHIDX(ms,OFF_DIAG_DEP_VAR(1,xi))
             !     ENDDO !ms
             !   ENDDO !ns
             ! ENDDO !xi

             ! Expanding the xi loop above

!             DO ns=1,DEPENDENT_BASES_EP(1)
!               DO ms=1,DEPENDENT_BASES_EP(2)
!                 equationsMatrix%elementMatrix%matrix(ns,ms+DEPENDENT_BASES_EP(1)) = &
!                   & equationsMatrix%elementMatrix%matrix(ns,ms+DEPENDENT_BASES_EP(1)) + &
!                   & JRWG*C(1,2)*DPHIDX_COMP(1)%DPHIDX(ns,1)*DPHIDX_COMP(2)%DPHIDX(ms,2) + &
!                   & JRWG*C(6,6)*DPHIDX_COMP(1)%DPHIDX(ns,2)*DPHIDX_COMP(2)%DPHIDX(ms,1)
!               ENDDO !ns
!             ENDDO !ms
!             DO ns=1,DEPENDENT_BASES_EP(1)
!               DO ms=1,DEPENDENT_BASES_EP(3)
!                 equationsMatrix%elementMatrix%matrix(ns,ms+DEPENDENT_BASES_EP(1)+DEPENDENT_BASES_EP(2)) = &
!                   & equationsMatrix%elementMatrix%matrix(ns,ms+DEPENDENT_BASES_EP(1)+DEPENDENT_BASES_EP(2)) + &
!                   & JRWG*C(1,3)*DPHIDX_COMP(1)%DPHIDX(ns,1)*DPHIDX_COMP(3)%DPHIDX(ms,3) + &
!                   & JRWG*C(4,4)*DPHIDX_COMP(1)%DPHIDX(ns,3)*DPHIDX_COMP(3)%DPHIDX(ms,1)
!               ENDDO !ns
!             ENDDO !ms
!             DO ns=1,DEPENDENT_BASES_EP(2)
!               DO ms=1,DEPENDENT_BASES_EP(3)
!                 equationsMatrix%elementMatrix%matrix(ns+DEPENDENT_BASES_EP(1),ms+DEPENDENT_BASES_EP(1)+DEPENDENT_BASES_EP(2)) = &
!                   & equationsMatrix%elementMatrix%matrix(ns+DEPENDENT_BASES_EP(1),ms+DEPENDENT_BASES_EP(1)+DEPENDENT_BASES_EP(2)) + &
!                   & JRWG*C(2,3)*DPHIDX_COMP(2)%DPHIDX(ns,2)*DPHIDX_COMP(3)%DPHIDX(ms,3) + &
!                   & JRWG*C(5,5)*DPHIDX_COMP(2)%DPHIDX(ns,3)*DPHIDX_COMP(3)%DPHIDX(ms,2)
!               ENDDO !ns
!             ENDDO !ms
            ENDDO !ng
            !If Plane Stress/Strain problem multiply equation matrix by thickness
            IF(EQUATIONS_SET%SPECIFICATION(3) == EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE .OR. &
              & EQUATIONS_SET%SPECIFICATION(3) == EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE .OR. & 
              & EQUATIONS_SET%SPECIFICATION(3) == EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE) THEN
              DO mhs=1,TOTAL_DEPENDENT_BASIS_EP
                DO nhs=mhs,TOTAL_DEPENDENT_BASIS_EP
                  !!TODO::Bring 2D plane stress/strain element thickness in through a field - element constant when it can be exported by field i/o. Currently brought in through material field (Temporary)
                  equationsMatrix%elementMatrix%matrix(mhs,nhs)=equationsMatrix%elementMatrix%matrix(mhs,nhs)* &
                    & materialsInterpPoint%values(1,1)
                ENDDO !nhs
              ENDDO !mhs
            ENDIF
          ENDIF

          !!TODO:: Is this RHS Vector update required? find out/check - RHS not used - BC are prescribed during assembling eg update RHS only when BC change - stiffness matrix should be the same
          IF(rhsVector%updateVector) THEN
            rhsVector%elementVector%vector=0.0_DP
          ENDIF

          !Scale factor adjustment, Application of Scale factors is symmetric
          IF(dependentField%SCALINGS%scalingType/=FIELD_NO_SCALING) THEN
            DEPENDENT_INTERPOLATION_PARAMETERS=>equations%interpolation%dependentInterpParameters(FIELD_VAR_TYPE)%ptr
            CALL Field_InterpolationParametersScaleFactorsElementGet(ELEMENT_NUMBER,DEPENDENT_INTERPOLATION_PARAMETERS, &
              & err,error,*999)
            DO xi=1,NUMBER_OF_XI
              SF(DIAG_SUB_MAT_LOC(xi)+1:SUM(DEPENDENT_BASES_EP(1:xi)))=DEPENDENT_INTERPOLATION_PARAMETERS%scaleFactors(:,xi)
            ENDDO !xi
            DO mhs=1,TOTAL_DEPENDENT_BASIS_EP
              IF(equationsMatrix%updateMatrix) THEN
                DO nhs=mhs,TOTAL_DEPENDENT_BASIS_EP
                  equationsMatrix%elementMatrix%matrix(mhs,nhs)=equationsMatrix%elementMatrix%matrix(mhs,nhs)*SF(mhs)*SF(nhs)
                ENDDO !nhs
              ENDIF
              !!TODO:: Check if RHS update required for Linear Elasticity ie is the RHS the force terms but they are set during assembling and not here?
              IF(rhsVector%updateVector) rhsVector%elementVector%vector(mhs)=rhsVector%elementVector%vector(mhs)*SF(mhs)
            ENDDO !mhs
          ENDIF

          IF(equationsMatrix%updateMatrix) THEN
            !Transpose upper triangular portion of Stiffness matrix to give lower triangular portion. Has to be done after scale factors are applied
            !!TODO:: Use symmetric linear equation solver or alternatively traspose to give full matrix when asemmbling or when creating solver matrices
            !!TODO:: Better to use SIZE(equationsMatrix%elementMatrix%matrix,1) as apposed to TOTAL_DEPENDENT_BASIS_EP? Is the size re-calculated at end of every loop?
            DO mhs=2,TOTAL_DEPENDENT_BASIS_EP
              DO nhs=1,mhs-1
                equationsMatrix%elementMatrix%matrix(mhs,nhs) = equationsMatrix%elementMatrix%matrix(nhs,mhs)
              ENDDO !nhs
            ENDDO !mhs
          ENDIF

        CASE(EQUATIONS_SET_PLATE_SUBTYPE)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_SHELL_SUBTYPE)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="Equations set subtype "//TRIM(NumberToVString(EQUATIONS_SET%SPECIFICATION(3),"*",err,error))// &
            & " is not valid for a Linear Elasticity equation type of a Elasticty equations set class."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE
        CALL FlagError("Equations set equations is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Equations set is not associated.",err,error,*999)
    ENDIF

    EXITS("LINEAR_ELASTICITY_FINITE_ELEMENT_CALCULATE")
    RETURN
999 ERRORSEXITS("LINEAR_ELASTICITY_FINITE_ELEMENT_CALCULATE",err,error)
    RETURN 1
  END SUBROUTINE LINEAR_ELASTICITY_FINITE_ELEMENT_CALCULATE

  !
  !================================================================================================================================
  !

  !>Evaluates the linear elasticity tensor
  SUBROUTINE LINEAR_ELASTICITY_TENSOR(EQUATIONS_SET_SUBTYPE,MATERIALS_INTERPOLATED_POINT,ELASTICITY_TENSOR,err,error,*)

    !Argument variables    
    INTEGER(INTG), INTENT(IN) :: EQUATIONS_SET_SUBTYPE !<The subtype of the particular equation set being used
    TYPE(FieldInterpolatedPointType), POINTER :: MATERIALS_INTERPOLATED_POINT
    REAL(DP), INTENT(OUT) :: ELASTICITY_TENSOR(:,:) !<The Linear Elasticity Tensor C
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string

    !Local Variables
    REAL(DP) :: E1,E2,E3,v13,v23,v12,v31,v32,v21,gama
    REAL(DP) :: C11,C22,C33,C12,C13,C23,C21,C31,C32,C44,C55,C66
    TYPE(VARYING_STRING) :: localError

    ENTERS("LINEAR_ELASTICITY_TENSOR",err,error,*999)
    ELASTICITY_TENSOR=0.0_DP
    SELECT CASE(EQUATIONS_SET_SUBTYPE)
    !Note: Fortran uses column major format for arrays.
    CASE(EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE)
      !General Orthotropic 3D Linear Elasticity Tensor
      E1 = MATERIALS_INTERPOLATED_POINT%values(1,1)
      E2 = MATERIALS_INTERPOLATED_POINT%values(2,1)
      E3 = MATERIALS_INTERPOLATED_POINT%values(3,1)
      v13 = MATERIALS_INTERPOLATED_POINT%values(4,1)
      v23 = MATERIALS_INTERPOLATED_POINT%values(5,1)
      v12 = MATERIALS_INTERPOLATED_POINT%values(6,1)
      v31 = v13
      v32 = v23
      v21 = v12
      gama = 1.0_DP/(1.0_DP-v12*v21-v23*v32-v31*v13-2.0_DP*v21*v32*v13)
      C11 = E1*(1.0_DP-v23*v32)*gama
      C22 = E2*(1.0_DP-v13*v31)*gama
      C33 = E3*(1.0_DP-v12*v21)*gama
      C12 = E1*(v21+v31*v23)*gama ! = E2*(v12+v32*v13)*gama
      C13 = E1*(v31+v21*v32)*gama ! = E3*(v13+v12*v23)*gama
      C23 = E2*(v32+v12*v31)*gama ! = E3*(v23+v21*v13)*gama
      C21 = C12
      C31 = C13
      C32 = C23
      C44 = E2/(2.0_DP*(1.0_DP+v23)) != G23
      C55 = E1/(2.0_DP*(1.0_DP+v13)) != G13
      C66 = E3/(2.0_DP*(1.0_DP+v12)) != G12
      ELASTICITY_TENSOR(1:6,1)=[C11,C21,C31,0.0_DP,0.0_DP,0.0_DP]
      ELASTICITY_TENSOR(1:6,2)=[C12,C22,C32,0.0_DP,0.0_DP,0.0_DP]
      ELASTICITY_TENSOR(1:6,3)=[C13,C23,C33,0.0_DP,0.0_DP,0.0_DP]
      ELASTICITY_TENSOR(4,4)=C44
      ELASTICITY_TENSOR(5,5)=C55
      ELASTICITY_TENSOR(6,6)=C66
    CASE(EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE)
      !Plane Stress Isotropic Elasticity Tensor
      E1 = MATERIALS_INTERPOLATED_POINT%values(2,1)
      v12 = MATERIALS_INTERPOLATED_POINT%values(3,1)
      v21 = v12
      gama = 1.0_DP/(1.0_DP-v12*v21)
      C11 = E1*gama
      C22 = C11
      C12 = C11*v21
      C21 = C12
      C66 = E1/(2.0_DP*(1.0_DP+v12)) != G12
      ELASTICITY_TENSOR(1,1)=C11
      ELASTICITY_TENSOR(1,2)=C21
      ELASTICITY_TENSOR(2,1)=C21
      ELASTICITY_TENSOR(2,2)=C22
      ELASTICITY_TENSOR(6,6)=C66
    CASE(EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE)
      !Plane Strain Isotropic Linear Elasticity Tensor
      E1 = MATERIALS_INTERPOLATED_POINT%values(2,1)
      E2 = E1
      v12 = MATERIALS_INTERPOLATED_POINT%values(3,1)
      v21 = v12
      gama = 1.0_DP/(1.0_DP-v12-v21)
      C11 = E1*gama*(1.0_DP-v12)/(1.0_DP+v12)
      C22 = E2*gama*(1.0_DP-v21)/(1.0_DP+v21)
      C12 = C22*v12
      C21 = C12
      C66 = E1/(2.0_DP*(1.0_DP+v12)) != G12
      ELASTICITY_TENSOR(1,1)=C11
      ELASTICITY_TENSOR(1,2)=C21
      ELASTICITY_TENSOR(2,1)=C21
      ELASTICITY_TENSOR(2,2)=C22
      ELASTICITY_TENSOR(6,6)=C66
    CASE(EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE)
      !Plane Strain Isotropic Linear Elasticity Tensor
      E1 = MATERIALS_INTERPOLATED_POINT%values(2,1)
      C11 = E1
      ELASTICITY_TENSOR(1,1)=C11
    CASE(EQUATIONS_SET_PLATE_SUBTYPE)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(EQUATIONS_SET_SHELL_SUBTYPE)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="Equations set subtype "//TRIM(NumberToVString(EQUATIONS_SET_SUBTYPE,"*",err,error))// &
            & " is not valid for a Linear Elasticity equation type of a Elasticty equations set class."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("LINEAR_ELASTICITY_TENSOR")
    RETURN
999 ERRORSEXITS("LINEAR_ELASTICITY_TENSOR",err,error)
    RETURN 1
  END SUBROUTINE LINEAR_ELASTICITY_TENSOR

  !
  !================================================================================================================================
  !

  !>Sets up the Linear elasticity equation type of an elasticity equations set class.
  SUBROUTINE LINEAR_ELASTICITY_EQUATIONS_SET_SETUP(EQUATIONS_SET,EQUATIONS_SET_SETUP,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: EQUATIONS_SET !<A pointer to the equations set to setup a linear elasticity equation on.
    TYPE(EquationsSetSetupType), INTENT(INOUT) :: EQUATIONS_SET_SETUP !<The equations set setup information
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,GEOMETRIC_COMPONENT_NUMBER,GEOMETRIC_MESH_COMPONENT,GEOMETRIC_SCALING_TYPE, &
      & NUMBER_OF_COMPONENTS,numberOfDimensions
    TYPE(DecompositionType), POINTER :: GEOMETRIC_DECOMPOSITION
    TYPE(FieldType), POINTER :: ANALYTIC_FIELD,dependentField,geometricField
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsSetMaterialsType), POINTER :: EQUATIONS_MATERIALS
    TYPE(VARYING_STRING) :: localError

    ENTERS("LINEAR_ELASTICITY_EQUATIONS_SET_SETUP",err,error,*999)

    NULLIFY(EQUATIONS)
    NULLIFY(vectorMapping)
    NULLIFY(vectorMatrices)
    NULLIFY(GEOMETRIC_DECOMPOSITION)

    IF(ASSOCIATED(EQUATIONS_SET)) THEN
      IF(.NOT.ALLOCATED(EQUATIONS_SET%SPECIFICATION)) THEN
        CALL FlagError("Equations set specification is not allocated.",err,error,*999)
      ELSE IF(SIZE(EQUATIONS_SET%SPECIFICATION,1)/=3) THEN
        CALL FlagError("Equations set specification must have three entries for a linear elasticity type equations set.", &
          & err,error,*999)
      END IF

      !!TODO:: Update all these so there is a default setup that is valid for 1D,2D & 3D Linear Elasticity
      SELECT CASE(EQUATIONS_SET%SPECIFICATION(3))
      !
      ! THREE DIMENSIONAL ELASTICITY
      !
      CASE(EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE)
        SELECT CASE(EQUATIONS_SET_SETUP%setupType)
        CASE(EQUATIONS_SET_SETUP_INITIAL_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            !Default to FEM solution
            CALL LinearElasticity_EquationsSetSolutionMethodSet(EQUATIONS_SET,EQUATIONS_SET_FEM_SOLUTION_METHOD, &
              & err,error,*999)
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
!!TODO: Check valid setup
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_GEOMETRY_TYPE)
          !Do nothing???
        CASE(EQUATIONS_SET_SETUP_DEPENDENT_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            IF(EQUATIONS_SET%DEPENDENT%dependentFieldAutoCreated) THEN
              !Create the auto created dependent field
              CALL Field_CreateStart(EQUATIONS_SET_SETUP%fieldUserNumber,EQUATIONS_SET%REGION,EQUATIONS_SET%DEPENDENT% &
                & dependentField,err,error,*999)
              CALL Field_TypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_GENERAL_TYPE,err,error,*999)
              CALL Field_DependentTypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DEPENDENT_TYPE,err,error,*999)
              CALL Field_DecompositionGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_DECOMPOSITION,err,error,*999)
              CALL Field_DecompositionSetAndLock(EQUATIONS_SET%dependent%dependentField,GEOMETRIC_DECOMPOSITION, &
                & err,error,*999)
              CALL Field_GeometricFieldSetAndLock(EQUATIONS_SET%dependent%dependentField,EQUATIONS_SET%GEOMETRY% &
                & geometricField,err,error,*999)
              CALL Field_NumberOfVariablesSetAndLock(EQUATIONS_SET%dependent%dependentField,2,err,error,*999)
              CALL Field_VariableTypesSetAndLock(EQUATIONS_SET%dependent%dependentField,[FIELD_U_VARIABLE_TYPE, &
                & FIELD_DELUDELN_VARIABLE_TYPE],err,error,*999)
              CALL Field_DimensionSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DimensionSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_DP_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_DP_TYPE,err,error,*999)
              CALL Field_NumberOfComponentsGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                & numberOfDimensions,err,error,*999)
              NUMBER_OF_COMPONENTS=numberOfDimensions
              CALL Field_NumberOfComponentsSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & NUMBER_OF_COMPONENTS,err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & NUMBER_OF_COMPONENTS,err,error,*999)
              !Default to the geometric interpolation setup
              DO component_idx=1,numberOfDimensions
                CALL Field_ComponentMeshComponentGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                  & component_idx,GEOMETRIC_MESH_COMPONENT,err,error,*999)
                CALL Field_ComponentMeshComponentSet(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & component_idx,GEOMETRIC_MESH_COMPONENT,err,error,*999)
                CALL Field_ComponentMeshComponentSet(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                  & component_idx,GEOMETRIC_MESH_COMPONENT,err,error,*999)
              ENDDO !component_idx
              SELECT CASE(EQUATIONS_SET%solutionMethod)
              CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
                DO component_idx=1,NUMBER_OF_COMPONENTS
                  CALL Field_ComponentInterpolationSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                    & component_idx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                  CALL Field_ComponentInterpolationSetAndLock(EQUATIONS_SET%dependent%dependentField, &
                    & FIELD_DELUDELN_VARIABLE_TYPE,component_idx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                ENDDO !component_idx
                !Default the scaling to the geometric field scaling
                CALL Field_ScalingTypeGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_SCALING_TYPE,err,error,*999)
                CALL Field_ScalingTypeSet(EQUATIONS_SET%dependent%dependentField,GEOMETRIC_SCALING_TYPE,err,error,*999)
              CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The solution method of "//TRIM(NumberToVString(EQUATIONS_SET%solutionMethod,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              !Check the user specified field
              CALL Field_TypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_GENERAL_TYPE,err,error,*999)
              CALL Field_DependentTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DEPENDENT_TYPE,err,error,*999)
              CALL Field_NumberOfVariablesCheck(EQUATIONS_SET_SETUP%FIELD,2,err,error,*999)
              CALL Field_VariableTypesCheck(EQUATIONS_SET_SETUP%FIELD,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE], &
                & err,error,*999)
              CALL Field_DimensionCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
                & err,error,*999)
              CALL Field_DimensionCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
                & err,error,*999)
              CALL Field_DataTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_NumberOfComponentsGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                & numberOfDimensions,err,error,*999)
              NUMBER_OF_COMPONENTS=numberOfDimensions
              CALL Field_NumberOfComponentsCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,NUMBER_OF_COMPONENTS, &
                & err,error,*999)
              CALL Field_NumberOfComponentsCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,NUMBER_OF_COMPONENTS, &
                & err,error,*999)
              SELECT CASE(EQUATIONS_SET%solutionMethod)
              CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
                CALL Field_ComponentInterpolationCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,1, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,1, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The solution method of "//TRIM(NumberToVString(EQUATIONS_SET%solutionMethod,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            IF(EQUATIONS_SET%DEPENDENT%dependentFieldAutoCreated) THEN
              CALL Field_CreateFinish(EQUATIONS_SET%dependent%dependentField,err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation"
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_MATERIALS_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            EQUATIONS_MATERIALS=>EQUATIONS_SET%MATERIALS
            IF(ASSOCIATED(EQUATIONS_MATERIALS)) THEN
              IF(EQUATIONS_MATERIALS%materialsFieldAutoCreated) THEN
                !Default to the general 3D orthotropic material
                !Create the auto created materials field
                CALL Field_CreateStart(EQUATIONS_SET_SETUP%fieldUserNumber,EQUATIONS_SET%REGION,EQUATIONS_MATERIALS% &
                  & materialsField,err,error,*999)
                CALL Field_TypeSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_MATERIAL_TYPE,err,error,*999)
                CALL Field_DependentTypeSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_INDEPENDENT_TYPE,err,error,*999)
                CALL Field_DecompositionGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_DECOMPOSITION,err,error,*999)
                CALL Field_DecompositionSetAndLock(EQUATIONS_MATERIALS%materialsField,GEOMETRIC_DECOMPOSITION, &
                  & err,error,*999)
                CALL Field_GeometricFieldSetAndLock(EQUATIONS_MATERIALS%materialsField,EQUATIONS_SET%GEOMETRY% &
                  & geometricField,err,error,*999)
                CALL Field_NumberOfVariablesSetAndLock(EQUATIONS_MATERIALS%materialsField,1,err,error,*999)
                CALL Field_VariableTypesSetAndLock(EQUATIONS_MATERIALS%materialsField,[FIELD_U_VARIABLE_TYPE], &
                  & err,error,*999)
                CALL Field_DimensionSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                  & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_DataTypeSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                  & FIELD_DP_TYPE,err,error,*999)
                CALL Field_NumberOfComponentsSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                  & 6,err,error,*999)
                CALL Field_ComponentMeshComponentGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                  & 1,GEOMETRIC_COMPONENT_NUMBER,err,error,*999)                
                DO component_idx=1,6
                  !Default to to the first geometric component with constant interpolation
                  CALL Field_ComponentMeshComponentSet(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                    & component_idx,GEOMETRIC_COMPONENT_NUMBER,err,error,*999)
                  CALL Field_ComponentInterpolationSet(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                    & component_idx,FIELD_CONSTANT_INTERPOLATION,err,error,*999)
                ENDDO !component_idx
                !Default the field scaling to that of the geometric field
                CALL Field_ScalingTypeGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_SCALING_TYPE,err,error,*999)
                CALL Field_ScalingTypeSet(EQUATIONS_MATERIALS%materialsField,GEOMETRIC_SCALING_TYPE,err,error,*999)
              ELSE
                !Check the user specified field
                CALL Field_TypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_MATERIAL_TYPE,err,error,*999)
                CALL Field_DependentTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_INDEPENDENT_TYPE,err,error,*999)
                CALL Field_NumberOfVariablesCheck(EQUATIONS_SET_SETUP%FIELD,1,err,error,*999)
                CALL Field_VariableTypesCheck(EQUATIONS_SET_SETUP%FIELD,[FIELD_U_VARIABLE_TYPE],err,error,*999)
                CALL Field_DimensionCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
                  & err,error,*999)
                CALL Field_DataTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
                CALL Field_NumberOfComponentsCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,6,err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Equations materials is not associated.",err,error,*999)
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            EQUATIONS_MATERIALS=>EQUATIONS_SET%MATERIALS
            IF(ASSOCIATED(EQUATIONS_MATERIALS)) THEN
              IF(EQUATIONS_MATERIALS%materialsFieldAutoCreated) THEN
                !Finish creating the materials field
                CALL Field_CreateFinish(EQUATIONS_MATERIALS%materialsField,err,error,*999)
                !Set the default values for the materials field
                DO component_idx=1,3
                  CALL Field_ComponentValuesInitialise(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                    & FIELD_VALUES_SET_TYPE,component_idx,30.0E6_DP,err,error,*999)
                ENDDO !component_idx
                DO component_idx=4,6
                  CALL Field_ComponentValuesInitialise(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                    & FIELD_VALUES_SET_TYPE,component_idx,0.25_DP,err,error,*999)
                ENDDO !component_idx
              ENDIF
            ELSE
              CALL FlagError("Equations set materials is not associated.",err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_SOURCE_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            !Do nothing
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            !Do nothing
            !? Maybe set finished flag????
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT

        CASE(EQUATIONS_SET_SETUP_ANALYTIC_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            CALL EquationsSet_AssertDependentIsFinished(EQUATIONS_SET,err,error,*999)
            dependentField=>EQUATIONS_SET%dependent%dependentField
            IF(ASSOCIATED(dependentField)) THEN
              geometricField=>EQUATIONS_SET%GEOMETRY%geometricField
              IF(ASSOCIATED(geometricField)) THEN
                CALL Field_NumberOfComponentsGet(geometricField,FIELD_U_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
                !List 3 Dimensional Analytic function types currently implemented
                SELECT CASE(EQUATIONS_SET_SETUP%analyticFunctionType)
                CASE(EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1)
                  !Check that we are in 3D
                  IF(numberOfDimensions/=3) THEN
                    localError="The number of geometric dimensions of "// &
                      & TRIM(NumberToVString(numberOfDimensions,"*",err,error))// &
                      & " is invalid. The analytic function type of "// &
                      & TRIM(NumberToVString(EQUATIONS_SET_SETUP%analyticFunctionType,"*",err,error))// &
                      & " requires that there be 3 geometric dimensions."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                  !Create analytic field if required
                  !Set analtyic function type
                  EQUATIONS_SET%ANALYTIC%analyticFunctionType=EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1
                CASE(EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2)
                  !Check that we are in 3D
                  IF(numberOfDimensions/=3) THEN
                    localError="The number of geometric dimensions of "// &
                      & TRIM(NumberToVString(numberOfDimensions,"*",err,error))// &
                      & " is invalid. The analytic function type of "// &
                      & TRIM(NumberToVString(EQUATIONS_SET_SETUP%analyticFunctionType,"*",err,error))// &
                      & " requires that there be 3 geometric dimensions."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                  !Create analytic field if required
                  !Set analtyic function type
                  EQUATIONS_SET%ANALYTIC%analyticFunctionType=EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2
                CASE DEFAULT
                  localError="The specified analytic function type of "// &
                    & TRIM(NumberToVString(EQUATIONS_SET_SETUP%analyticFunctionType,"*",err,error))// &
                    & " is invalid for a standard Linear Elasticity equation."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ELSE
                CALL FlagError("Equations set geometric field is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Equations set dependent field is not associated.",err,error,*999)
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            IF(ASSOCIATED(EQUATIONS_SET%ANALYTIC)) THEN
              ANALYTIC_FIELD=>EQUATIONS_SET%ANALYTIC%analyticField
              IF(ASSOCIATED(ANALYTIC_FIELD)) THEN
                IF(EQUATIONS_SET%ANALYTIC%analyticFieldAutoCreated) THEN
                  CALL Field_CreateFinish(EQUATIONS_SET%dependent%dependentField,err,error,*999)
                ENDIF
              ENDIF
            ELSE
              CALL FlagError("Equations set analytic is not associated.",err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a standard Linear Elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT

        CASE(EQUATIONS_SET_SETUP_EQUATIONS_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            CALL EquationsSet_AssertDependentIsFinished(EQUATIONS_SET,err,error,*999)
            !Create the equations
            CALL Equations_CreateStart(EQUATIONS_SET,equations,err,error,*999)
            CALL Equations_LinearityTypeSet(equations,EQUATIONS_LINEAR,err,error,*999)
            CALL Equations_TimeDependenceTypeSet(equations,EQUATIONS_STATIC,err,error,*999)
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            SELECT CASE(EQUATIONS_SET%solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Finish the equations creation
              CALL EquationsSet_EquationsGet(EQUATIONS_SET,equations,err,error,*999)
              CALL Equations_CreateFinish(equations,err,error,*999)
              NULLIFY(vectorEquations)
              CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
              !Create the equations mapping.
              CALL EquationsMapping_VectorCreateStart(vectorEquations,FIELD_DELUDELN_VARIABLE_TYPE,vectorMapping,err,error,*999)
              CALL EquationsMappingVector_NumberOfLinearMatricesSet(vectorMapping,1,err,error,*999)
              CALL EquationsMappingVector_LinearMatricesVariableTypesSet(vectorMapping,[FIELD_U_VARIABLE_TYPE], &
                & err,error,*999)
              CALL EquationsMappingVector_RHSVariableTypeSet(vectorMapping,FIELD_DELUDELN_VARIABLE_TYPE,err,error,*999)
              CALL EquationsMapping_VectorCreateFinish(vectorMapping,err,error,*999)
              !Create the equations matrices
              CALL EquationsMatrices_VectorCreateStart(vectorEquations,vectorMatrices,err,error,*999)
              SELECT CASE(equations%sparsityType)
              CASE(EQUATIONS_MATRICES_FULL_MATRICES)
                CALL EquationsMatricesVector_LinearStorageTypeSet(vectorMatrices,[MATRIX_BLOCK_STORAGE_TYPE],err,error,*999)
              CASE(EQUATIONS_MATRICES_SPARSE_MATRICES)
                CALL EquationsMatricesVector_LinearStorageTypeSet(vectorMatrices,[MATRIX_COMPRESSED_ROW_STORAGE_TYPE],err,error,*999)
                CALL EquationsMatricesVector_LinearStructureTypeSet(vectorMatrices,[EQUATIONS_MATRIX_FEM_STRUCTURE],err,error,*999)
              CASE DEFAULT
                localError="The equations matrices sparsity type of "// &
                  & TRIM(NumberToVString(equations%sparsityType,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
              CALL EquationsMatrices_VectorCreateFinish(vectorMatrices,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(EQUATIONS_SET%solutionMethod,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE DEFAULT
          localError="The setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
            & " is invalid for a linear elasticity equation."
          CALL FlagError(localError,err,error,*999)
        END SELECT

      !
      ! TWO DIMENSIONAL PLANE STRESS & PLANE STRAIN ELASTICITY
      !
      CASE(EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE,EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE)
        SELECT CASE(EQUATIONS_SET_SETUP%setupType)
        CASE(EQUATIONS_SET_SETUP_INITIAL_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            !Default to FEM solution
            CALL LinearElasticity_EquationsSetSolutionMethodSet(EQUATIONS_SET,EQUATIONS_SET_FEM_SOLUTION_METHOD, &
              & err,error,*999)
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
!!TODO: Check valid setup
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_GEOMETRY_TYPE)
          !Do nothing???
        CASE(EQUATIONS_SET_SETUP_DEPENDENT_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            IF(EQUATIONS_SET%DEPENDENT%dependentFieldAutoCreated) THEN
              !Create the auto created dependent field
              CALL Field_CreateStart(EQUATIONS_SET_SETUP%fieldUserNumber,EQUATIONS_SET%REGION,EQUATIONS_SET%DEPENDENT% &
                & dependentField,err,error,*999)
              CALL Field_TypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_GENERAL_TYPE,err,error,*999)
              CALL Field_DependentTypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DEPENDENT_TYPE,err,error,*999)
              CALL Field_DecompositionGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_DECOMPOSITION,err,error,*999)
              CALL Field_DecompositionSetAndLock(EQUATIONS_SET%dependent%dependentField,GEOMETRIC_DECOMPOSITION, &
                & err,error,*999)
              CALL Field_GeometricFieldSetAndLock(EQUATIONS_SET%dependent%dependentField,EQUATIONS_SET%GEOMETRY% &
                & geometricField,err,error,*999)
              CALL Field_NumberOfVariablesSetAndLock(EQUATIONS_SET%dependent%dependentField,2,err,error,*999)
              CALL Field_VariableTypesSetAndLock(EQUATIONS_SET%dependent%dependentField,[FIELD_U_VARIABLE_TYPE, &
                & FIELD_DELUDELN_VARIABLE_TYPE],err,error,*999)
              CALL Field_DimensionSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DimensionSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_DP_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_DP_TYPE,err,error,*999)
              CALL Field_NumberOfComponentsGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                & numberOfDimensions,err,error,*999)
              NUMBER_OF_COMPONENTS=numberOfDimensions
              CALL Field_NumberOfComponentsSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & NUMBER_OF_COMPONENTS,err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & NUMBER_OF_COMPONENTS,err,error,*999)
              !Default to the geometric interpolation setup
              DO component_idx=1,numberOfDimensions
                CALL Field_ComponentMeshComponentGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                  & component_idx,GEOMETRIC_MESH_COMPONENT,err,error,*999)
                CALL Field_ComponentMeshComponentSet(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & component_idx,GEOMETRIC_MESH_COMPONENT,err,error,*999)
                CALL Field_ComponentMeshComponentSet(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                  & component_idx,GEOMETRIC_MESH_COMPONENT,err,error,*999)
              ENDDO !component_idx
              SELECT CASE(EQUATIONS_SET%solutionMethod)
              CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
                DO component_idx=1,NUMBER_OF_COMPONENTS
                  CALL Field_ComponentInterpolationSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                    & component_idx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                  CALL Field_ComponentInterpolationSetAndLock(EQUATIONS_SET%dependent%dependentField, &
                    & FIELD_DELUDELN_VARIABLE_TYPE,component_idx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                ENDDO !component_idx
                !Default the scaling to the geometric field scaling
                CALL Field_ScalingTypeGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_SCALING_TYPE,err,error,*999)
                CALL Field_ScalingTypeSet(EQUATIONS_SET%dependent%dependentField,GEOMETRIC_SCALING_TYPE,err,error,*999)
              CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The solution method of "//TRIM(NumberToVString(EQUATIONS_SET%solutionMethod,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              !Check the user specified field
              CALL Field_TypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_GENERAL_TYPE,err,error,*999)
              CALL Field_DependentTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DEPENDENT_TYPE,err,error,*999)
              CALL Field_NumberOfVariablesCheck(EQUATIONS_SET_SETUP%FIELD,2,err,error,*999)
              CALL Field_VariableTypesCheck(EQUATIONS_SET_SETUP%FIELD,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE], &
                & err,error,*999)
              CALL Field_DimensionCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
                & err,error,*999)
              CALL Field_DimensionCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
                & err,error,*999)
              CALL Field_DataTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_NumberOfComponentsGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                & numberOfDimensions,err,error,*999)
              NUMBER_OF_COMPONENTS=numberOfDimensions
              CALL Field_NumberOfComponentsCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,NUMBER_OF_COMPONENTS, &
                & err,error,*999)
              CALL Field_NumberOfComponentsCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,NUMBER_OF_COMPONENTS, &
                & err,error,*999)
              SELECT CASE(EQUATIONS_SET%solutionMethod)
              CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
                CALL Field_ComponentInterpolationCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,1, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,1, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The solution method of "//TRIM(NumberToVString(EQUATIONS_SET%solutionMethod,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            IF(EQUATIONS_SET%DEPENDENT%dependentFieldAutoCreated) THEN
              CALL Field_CreateFinish(EQUATIONS_SET%dependent%dependentField,err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation"
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_MATERIALS_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            EQUATIONS_MATERIALS=>EQUATIONS_SET%MATERIALS
            IF(ASSOCIATED(EQUATIONS_MATERIALS)) THEN
              IF(EQUATIONS_MATERIALS%materialsFieldAutoCreated) THEN
                !Default to the general 3D orthotropic material
                !Create the auto created materials field
                CALL Field_CreateStart(EQUATIONS_SET_SETUP%fieldUserNumber,EQUATIONS_SET%REGION,EQUATIONS_MATERIALS% &
                  & materialsField,err,error,*999)
                CALL Field_TypeSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_MATERIAL_TYPE,err,error,*999)
                CALL Field_DependentTypeSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_INDEPENDENT_TYPE,err,error,*999)
                CALL Field_DecompositionGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_DECOMPOSITION,err,error,*999)
                CALL Field_DecompositionSetAndLock(EQUATIONS_MATERIALS%materialsField,GEOMETRIC_DECOMPOSITION, &
                  & err,error,*999)
                CALL Field_GeometricFieldSetAndLock(EQUATIONS_MATERIALS%materialsField,EQUATIONS_SET%GEOMETRY% &
                  & geometricField,err,error,*999)
                CALL Field_NumberOfVariablesSetAndLock(EQUATIONS_MATERIALS%materialsField,1,err,error,*999)
                CALL Field_VariableTypesSetAndLock(EQUATIONS_MATERIALS%materialsField,[FIELD_U_VARIABLE_TYPE], &
                  & err,error,*999)
                CALL Field_DimensionSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                  & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_DataTypeSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                  & FIELD_DP_TYPE,err,error,*999)
                CALL Field_NumberOfComponentsSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                  & 6,err,error,*999)
                CALL Field_ComponentMeshComponentGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                  & 1,GEOMETRIC_COMPONENT_NUMBER,err,error,*999)                
                DO component_idx=1,6
                  !Default to to the first geometric component with constant interpolation
                  CALL Field_ComponentMeshComponentSet(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                    & component_idx,GEOMETRIC_COMPONENT_NUMBER,err,error,*999)
                  CALL Field_ComponentInterpolationSet(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                    & component_idx,FIELD_CONSTANT_INTERPOLATION,err,error,*999)
                ENDDO !component_idx
                !Default the field scaling to that of the geometric field
                CALL Field_ScalingTypeGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_SCALING_TYPE,err,error,*999)
                CALL Field_ScalingTypeSet(EQUATIONS_MATERIALS%materialsField,GEOMETRIC_SCALING_TYPE,err,error,*999)
              ELSE
                !Check the user specified field
                CALL Field_TypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_MATERIAL_TYPE,err,error,*999)
                CALL Field_DependentTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_INDEPENDENT_TYPE,err,error,*999)
                CALL Field_NumberOfVariablesCheck(EQUATIONS_SET_SETUP%FIELD,1,err,error,*999)
                CALL Field_VariableTypesCheck(EQUATIONS_SET_SETUP%FIELD,[FIELD_U_VARIABLE_TYPE],err,error,*999)
                CALL Field_DimensionCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
                  & err,error,*999)
                CALL Field_DataTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
                !2 Components for 2D Isotropic Linear Elasticity
                !TODO:: Temporarily set to 3 to allow thickness to passed in. Remove once a thickness, element constant field is defined and can be exported/viewed by cmgui
                CALL Field_NumberOfComponentsCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,3,err,error,*999) 
              ENDIF
            ELSE
              CALL FlagError("Equations materials is not associated.",err,error,*999)
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            EQUATIONS_MATERIALS=>EQUATIONS_SET%MATERIALS
            IF(ASSOCIATED(EQUATIONS_MATERIALS)) THEN
              IF(EQUATIONS_MATERIALS%materialsFieldAutoCreated) THEN
                !Finish creating the materials field
                CALL Field_CreateFinish(EQUATIONS_MATERIALS%materialsField,err,error,*999)
                !Set the default values for the materials field
                CALL Field_ComponentValuesInitialise(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_VALUES_SET_TYPE,1,30.0E6_DP,err,error,*999) !Young's Modulus
                CALL Field_ComponentValuesInitialise(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_VALUES_SET_TYPE,2,0.25_DP,err,error,*999) !Poisson's Ratio
              ENDIF
            ELSE
              CALL FlagError("Equations set materials is not associated.",err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_SOURCE_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            !Do nothing
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            !Do nothing
            !? Maybe set finished flag????
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT

        CASE(EQUATIONS_SET_SETUP_ANALYTIC_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            CALL EquationsSet_AssertDependentIsFinished(EQUATIONS_SET,err,error,*999)
            dependentField=>EQUATIONS_SET%dependent%dependentField
            IF(ASSOCIATED(dependentField)) THEN
              geometricField=>EQUATIONS_SET%GEOMETRY%geometricField
              IF(ASSOCIATED(geometricField)) THEN
                CALL Field_NumberOfComponentsGet(geometricField,FIELD_U_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
                !List 3 Dimensional Analytic function types currently implemented
                SELECT CASE(EQUATIONS_SET_SETUP%analyticFunctionType)
                CASE(EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1)
                  !Check that we are in 2D
!!TODO:: This check may have been done before
                  IF(numberOfDimensions/=2) THEN
                    localError="The number of geometric dimensions of "// &
                      & TRIM(NumberToVString(numberOfDimensions,"*",err,error))// &
                      & " is invalid. The analytic function type of "// &
                      & TRIM(NumberToVString(EQUATIONS_SET_SETUP%analyticFunctionType,"*",err,error))// &
                      & " requires that there be 2 geometric dimensions."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                  !Create analytic field if required
                  !Set analtyic function type
                  EQUATIONS_SET%ANALYTIC%analyticFunctionType=EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1
                CASE DEFAULT
                  localError="The specified analytic function type of "// &
                    & TRIM(NumberToVString(EQUATIONS_SET_SETUP%analyticFunctionType,"*",err,error))// &
                    & " is invalid for a standard Linear Elasticity equation."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ELSE
                CALL FlagError("Equations set geometric field is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Equations set dependent field is not associated.",err,error,*999)
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            IF(ASSOCIATED(EQUATIONS_SET%ANALYTIC)) THEN
              ANALYTIC_FIELD=>EQUATIONS_SET%ANALYTIC%analyticField
              IF(ASSOCIATED(ANALYTIC_FIELD)) THEN
                IF(EQUATIONS_SET%ANALYTIC%analyticFieldAutoCreated) THEN
                  CALL Field_CreateFinish(EQUATIONS_SET%dependent%dependentField,err,error,*999)
                ENDIF
              ENDIF
            ELSE
              CALL FlagError("Equations set analytic is not associated.",err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a standard Linear Elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT


        CASE(EQUATIONS_SET_SETUP_EQUATIONS_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            CALL EquationsSet_AssertDependentIsFinished(EQUATIONS_SET,err,error,*999)
            !Create the equations
            CALL Equations_CreateStart(EQUATIONS_SET,equations,err,error,*999)
            CALL Equations_LinearityTypeSet(equations,EQUATIONS_LINEAR,err,error,*999)
            CALL Equations_TimeDependenceTypeSet(equations,EQUATIONS_STATIC,err,error,*999)
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            SELECT CASE(EQUATIONS_SET%solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Finish the equations creation
              CALL EquationsSet_EquationsGet(EQUATIONS_SET,equations,err,error,*999)
              CALL Equations_CreateFinish(equations,err,error,*999)
              NULLIFY(vectorEquations)
              CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
              !Create the equations mapping.
              CALL EquationsMapping_VectorCreateStart(vectorEquations,FIELD_DELUDELN_VARIABLE_TYPE,vectorMapping,err,error,*999)
              CALL EquationsMappingVector_NumberOfLinearMatricesSet(vectorMapping,1,err,error,*999)
              CALL EquationsMappingVector_LinearMatricesVariableTypesSet(vectorMapping,[FIELD_U_VARIABLE_TYPE], &
                & err,error,*999)
              CALL EquationsMappingVector_RHSVariableTypeSet(vectorMapping,FIELD_DELUDELN_VARIABLE_TYPE,err,error,*999)
              CALL EquationsMapping_VectorCreateFinish(vectorMapping,err,error,*999)
              !Create the equations matrices
              CALL EquationsMatrices_VectorCreateStart(vectorEquations,vectorMatrices,err,error,*999)
              SELECT CASE(equations%sparsityType)
              CASE(EQUATIONS_MATRICES_FULL_MATRICES)
                CALL EquationsMatricesVector_LinearStorageTypeSet(vectorMatrices,[MATRIX_BLOCK_STORAGE_TYPE],err,error,*999)
              CASE(EQUATIONS_MATRICES_SPARSE_MATRICES)
                CALL EquationsMatricesVector_LinearStorageTypeSet(vectorMatrices,[MATRIX_COMPRESSED_ROW_STORAGE_TYPE],err,error,*999)
                CALL EquationsMatricesVector_LinearStructureTypeSet(vectorMatrices,[EQUATIONS_MATRIX_FEM_STRUCTURE],err,error,*999)
              CASE DEFAULT
                localError="The equations matrices sparsity type of "// &
                  & TRIM(NumberToVString(equations%sparsityType,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
              CALL EquationsMatrices_VectorCreateFinish(vectorMatrices,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(EQUATIONS_SET%solutionMethod,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE DEFAULT
          localError="The setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
            & " is invalid for a linear elasticity equation."
          CALL FlagError(localError,err,error,*999)
        END SELECT

      !
      ! ONE DIMENSIONAL ELASTICITY
      !
      CASE(EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE)
        SELECT CASE(EQUATIONS_SET_SETUP%setupType)
        CASE(EQUATIONS_SET_SETUP_INITIAL_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            !Default to FEM solution
            CALL LinearElasticity_EquationsSetSolutionMethodSet(EQUATIONS_SET,EQUATIONS_SET_FEM_SOLUTION_METHOD, &
              & err,error,*999)
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
!!TODO: Check valid setup
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_GEOMETRY_TYPE)
          !Do nothing???
        CASE(EQUATIONS_SET_SETUP_DEPENDENT_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            IF(EQUATIONS_SET%DEPENDENT%dependentFieldAutoCreated) THEN
              !Create the auto created dependent field
              CALL Field_CreateStart(EQUATIONS_SET_SETUP%fieldUserNumber,EQUATIONS_SET%REGION,EQUATIONS_SET%DEPENDENT% &
                & dependentField,err,error,*999)
              CALL Field_TypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_GENERAL_TYPE,err,error,*999)
              CALL Field_DependentTypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DEPENDENT_TYPE,err,error,*999)
              CALL Field_DecompositionGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_DECOMPOSITION,err,error,*999)
              CALL Field_DecompositionSetAndLock(EQUATIONS_SET%dependent%dependentField,GEOMETRIC_DECOMPOSITION, &
                & err,error,*999)
              CALL Field_GeometricFieldSetAndLock(EQUATIONS_SET%dependent%dependentField,EQUATIONS_SET%GEOMETRY% &
                & geometricField,err,error,*999)
              CALL Field_NumberOfVariablesSetAndLock(EQUATIONS_SET%dependent%dependentField,2,err,error,*999)
              CALL Field_VariableTypesSetAndLock(EQUATIONS_SET%dependent%dependentField,[FIELD_U_VARIABLE_TYPE, &
                & FIELD_DELUDELN_VARIABLE_TYPE],err,error,*999)
              CALL Field_DimensionSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DimensionSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_DP_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_DP_TYPE,err,error,*999)
              CALL Field_NumberOfComponentsGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                & numberOfDimensions,err,error,*999)
              NUMBER_OF_COMPONENTS=numberOfDimensions
              CALL Field_NumberOfComponentsSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & NUMBER_OF_COMPONENTS,err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & NUMBER_OF_COMPONENTS,err,error,*999)
              !Default to the geometric interpolation setup
              DO component_idx=1,numberOfDimensions
                CALL Field_ComponentMeshComponentGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                  & component_idx,GEOMETRIC_MESH_COMPONENT,err,error,*999)
                CALL Field_ComponentMeshComponentSet(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & component_idx,GEOMETRIC_MESH_COMPONENT,err,error,*999)
                CALL Field_ComponentMeshComponentSet(EQUATIONS_SET%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                  & component_idx,GEOMETRIC_MESH_COMPONENT,err,error,*999)
              ENDDO !component_idx
              SELECT CASE(EQUATIONS_SET%solutionMethod)
              CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
                DO component_idx=1,NUMBER_OF_COMPONENTS
                  CALL Field_ComponentInterpolationSetAndLock(EQUATIONS_SET%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                    & component_idx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                  CALL Field_ComponentInterpolationSetAndLock(EQUATIONS_SET%dependent%dependentField, &
                    & FIELD_DELUDELN_VARIABLE_TYPE,component_idx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                ENDDO !component_idx
                !Default the scaling to the geometric field scaling
                CALL Field_ScalingTypeGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_SCALING_TYPE,err,error,*999)
                CALL Field_ScalingTypeSet(EQUATIONS_SET%dependent%dependentField,GEOMETRIC_SCALING_TYPE,err,error,*999)
              CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The solution method of "//TRIM(NumberToVString(EQUATIONS_SET%solutionMethod,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              !Check the user specified field
              CALL Field_TypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_GENERAL_TYPE,err,error,*999)
              CALL Field_DependentTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DEPENDENT_TYPE,err,error,*999)
              CALL Field_NumberOfVariablesCheck(EQUATIONS_SET_SETUP%FIELD,2,err,error,*999)
              CALL Field_VariableTypesCheck(EQUATIONS_SET_SETUP%FIELD,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE], &
                & err,error,*999)
              CALL Field_DimensionCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
                & err,error,*999)
              CALL Field_DimensionCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
                & err,error,*999)
              CALL Field_DataTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_NumberOfComponentsGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                & numberOfDimensions,err,error,*999)
              NUMBER_OF_COMPONENTS=numberOfDimensions
              CALL Field_NumberOfComponentsCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,NUMBER_OF_COMPONENTS, &
                & err,error,*999)
              CALL Field_NumberOfComponentsCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,NUMBER_OF_COMPONENTS, &
                & err,error,*999)
              SELECT CASE(EQUATIONS_SET%solutionMethod)
              CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
                CALL Field_ComponentInterpolationCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,1, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_DELUDELN_VARIABLE_TYPE,1, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The solution method of "//TRIM(NumberToVString(EQUATIONS_SET%solutionMethod,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            IF(EQUATIONS_SET%DEPENDENT%dependentFieldAutoCreated) THEN
              CALL Field_CreateFinish(EQUATIONS_SET%dependent%dependentField,err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation"
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_MATERIALS_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            EQUATIONS_MATERIALS=>EQUATIONS_SET%MATERIALS
            IF(ASSOCIATED(EQUATIONS_MATERIALS)) THEN
              IF(EQUATIONS_MATERIALS%materialsFieldAutoCreated) THEN
                !Default to the general 3D orthotropic material
                !Create the auto created materials field
                CALL Field_CreateStart(EQUATIONS_SET_SETUP%fieldUserNumber,EQUATIONS_SET%REGION,EQUATIONS_MATERIALS% &
                  & materialsField,err,error,*999)
                CALL Field_TypeSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_MATERIAL_TYPE,err,error,*999)
                CALL Field_DependentTypeSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_INDEPENDENT_TYPE,err,error,*999)
                CALL Field_DecompositionGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_DECOMPOSITION,err,error,*999)
                CALL Field_DecompositionSetAndLock(EQUATIONS_MATERIALS%materialsField,GEOMETRIC_DECOMPOSITION, &
                  & err,error,*999)
                CALL Field_GeometricFieldSetAndLock(EQUATIONS_MATERIALS%materialsField,EQUATIONS_SET%GEOMETRY% &
                  & geometricField,err,error,*999)
                CALL Field_NumberOfVariablesSetAndLock(EQUATIONS_MATERIALS%materialsField,1,err,error,*999)
                CALL Field_VariableTypesSetAndLock(EQUATIONS_MATERIALS%materialsField,[FIELD_U_VARIABLE_TYPE], &
                  & err,error,*999)
                CALL Field_DimensionSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                  & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_DataTypeSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                  & FIELD_DP_TYPE,err,error,*999)
                CALL Field_NumberOfComponentsSetAndLock(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                  & 6,err,error,*999)
                CALL Field_ComponentMeshComponentGet(EQUATIONS_SET%GEOMETRY%geometricField,FIELD_U_VARIABLE_TYPE, &
                  & 1,GEOMETRIC_COMPONENT_NUMBER,err,error,*999)                
                DO component_idx=1,6
                  !Default to to the first geometric component with constant interpolation
                  CALL Field_ComponentMeshComponentSet(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                    & component_idx,GEOMETRIC_COMPONENT_NUMBER,err,error,*999)
                  CALL Field_ComponentInterpolationSet(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                    & component_idx,FIELD_CONSTANT_INTERPOLATION,err,error,*999)
                ENDDO !component_idx
                !Default the field scaling to that of the geometric field
                CALL Field_ScalingTypeGet(EQUATIONS_SET%GEOMETRY%geometricField,GEOMETRIC_SCALING_TYPE,err,error,*999)
                CALL Field_ScalingTypeSet(EQUATIONS_MATERIALS%materialsField,GEOMETRIC_SCALING_TYPE,err,error,*999)
              ELSE
                !Check the user specified field
                CALL Field_TypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_MATERIAL_TYPE,err,error,*999)
                CALL Field_DependentTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_INDEPENDENT_TYPE,err,error,*999)
                CALL Field_NumberOfVariablesCheck(EQUATIONS_SET_SETUP%FIELD,1,err,error,*999)
                CALL Field_VariableTypesCheck(EQUATIONS_SET_SETUP%FIELD,[FIELD_U_VARIABLE_TYPE],err,error,*999)
                CALL Field_DimensionCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
                  & err,error,*999)
                CALL Field_DataTypeCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
                !2 Components for 2D Isotropic Linear Elasticity
                CALL Field_NumberOfComponentsCheck(EQUATIONS_SET_SETUP%FIELD,FIELD_U_VARIABLE_TYPE,2,err,error,*999) 
              ENDIF
            ELSE
              CALL FlagError("Equations materials is not associated.",err,error,*999)
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            EQUATIONS_MATERIALS=>EQUATIONS_SET%MATERIALS
            IF(ASSOCIATED(EQUATIONS_MATERIALS)) THEN
              IF(EQUATIONS_MATERIALS%materialsFieldAutoCreated) THEN
                !Finish creating the materials field
                CALL Field_CreateFinish(EQUATIONS_MATERIALS%materialsField,err,error,*999)
                !Set the default values for the materials field
                CALL Field_ComponentValuesInitialise(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_VALUES_SET_TYPE,1,30.0E6_DP,err,error,*999) !Young's Modulus
                CALL Field_ComponentValuesInitialise(EQUATIONS_MATERIALS%materialsField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_VALUES_SET_TYPE,2,0.25_DP,err,error,*999) !Poisson's Ratio
              ENDIF
            ELSE
              CALL FlagError("Equations set materials is not associated.",err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_SOURCE_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            !Do nothing
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            !Do nothing
            !? Maybe set finished flag????
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT

        CASE(EQUATIONS_SET_SETUP_ANALYTIC_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            CALL EquationsSet_AssertDependentIsFinished(EQUATIONS_SET,err,error,*999)
            dependentField=>EQUATIONS_SET%dependent%dependentField
            IF(ASSOCIATED(dependentField)) THEN
              geometricField=>EQUATIONS_SET%GEOMETRY%geometricField
              IF(ASSOCIATED(geometricField)) THEN
                CALL Field_NumberOfComponentsGet(geometricField,FIELD_U_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
                !List 3 Dimensional Analytic function types currently implemented
                SELECT CASE(EQUATIONS_SET_SETUP%analyticFunctionType)
                CASE(EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1)
                  !Check that we are in 1D
                  IF(numberOfDimensions/=1) THEN
                    localError="The number of geometric dimensions of "// &
                      & TRIM(NumberToVString(numberOfDimensions,"*",err,error))// &
                      & " is invalid. The analytic function type of "// &
                      & TRIM(NumberToVString(EQUATIONS_SET_SETUP%analyticFunctionType,"*",err,error))// &
                      & " requires that there be 1 geometric dimension."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                  !Create analytic field if required
                  !Set analtyic function type
                  EQUATIONS_SET%ANALYTIC%analyticFunctionType=EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1
                CASE DEFAULT
                  localError="The specified analytic function type of "// &
                    & TRIM(NumberToVString(EQUATIONS_SET_SETUP%analyticFunctionType,"*",err,error))// &
                    & " is invalid for a standard Linear Elasticity equation."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ELSE
                CALL FlagError("Equations set geometric field is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Equations set dependent field is not associated.",err,error,*999)
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            IF(ASSOCIATED(EQUATIONS_SET%ANALYTIC)) THEN
              ANALYTIC_FIELD=>EQUATIONS_SET%ANALYTIC%analyticField
              IF(ASSOCIATED(ANALYTIC_FIELD)) THEN
                IF(EQUATIONS_SET%ANALYTIC%analyticFieldAutoCreated) THEN
                  CALL Field_CreateFinish(EQUATIONS_SET%dependent%dependentField,err,error,*999)
                ENDIF
              ENDIF
            ELSE
              CALL FlagError("Equations set analytic is not associated.",err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a standard Linear Elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT

        CASE(EQUATIONS_SET_SETUP_EQUATIONS_TYPE)
          SELECT CASE(EQUATIONS_SET_SETUP%actionType)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            CALL EquationsSet_AssertDependentIsFinished(EQUATIONS_SET,err,error,*999)
            !Create the equations
            CALL Equations_CreateStart(EQUATIONS_SET,equations,err,error,*999)
            CALL Equations_LinearityTypeSet(equations,EQUATIONS_LINEAR,err,error,*999)
            CALL Equations_TimeDependenceTypeSet(equations,EQUATIONS_STATIC,err,error,*999)
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            SELECT CASE(EQUATIONS_SET%solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Finish the equations creation
              CALL EquationsSet_EquationsGet(EQUATIONS_SET,equations,err,error,*999)
              CALL Equations_CreateFinish(equations,err,error,*999)
              NULLIFY(vectorEquations)
              CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
              !Create the equations mapping.
              CALL EquationsMapping_VectorCreateStart(vectorEquations,FIELD_DELUDELN_VARIABLE_TYPE,vectorMapping,err,error,*999)
              CALL EquationsMappingVector_NumberOfLinearMatricesSet(vectorMapping,1,err,error,*999)
              CALL EquationsMappingVector_LinearMatricesVariableTypesSet(vectorMapping,[FIELD_U_VARIABLE_TYPE], &
                & err,error,*999)
              CALL EquationsMappingVector_RHSVariableTypeSet(vectorMapping,FIELD_DELUDELN_VARIABLE_TYPE,err,error,*999)
              CALL EquationsMapping_VectorCreateFinish(vectorMapping,err,error,*999)
              !Create the equations matrices
              CALL EquationsMatrices_VectorCreateStart(vectorEquations,vectorMatrices,err,error,*999)
              SELECT CASE(equations%sparsityType)
              CASE(EQUATIONS_MATRICES_FULL_MATRICES)
                CALL EquationsMatricesVector_LinearStorageTypeSet(vectorMatrices,[MATRIX_BLOCK_STORAGE_TYPE],err,error,*999)
              CASE(EQUATIONS_MATRICES_SPARSE_MATRICES)
                CALL EquationsMatricesVector_LinearStorageTypeSet(vectorMatrices,[MATRIX_COMPRESSED_ROW_STORAGE_TYPE], &
                  & err,error,*999)
                CALL EquationsMatricesVector_LinearStructureTypeSet(vectorMatrices,[EQUATIONS_MATRIX_FEM_STRUCTURE],err,error,*999)
              CASE DEFAULT
                localError="The equations matrices sparsity type of "// &
                  & TRIM(NumberToVString(equations%sparsityType,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
              CALL EquationsMatrices_VectorCreateFinish(vectorMatrices,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(EQUATIONS_SET%solutionMethod,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity equation."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE DEFAULT
          localError="The setup type of "//TRIM(NumberToVString(EQUATIONS_SET_SETUP%setupType,"*",err,error))// &
            & " is invalid for a linear elasticity equation."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(EQUATIONS_SET_PLATE_SUBTYPE)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(EQUATIONS_SET_SHELL_SUBTYPE)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="Equations set subtype "//TRIM(NumberToVString(EQUATIONS_SET%SPECIFICATION(3),"*",err,error))// &
          & " is not valid for a linear elasticity equation type of an elasticity equation set class."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Equations set is not associated.",err,error,*999)
    ENDIF

    EXITS("LINEAR_ELASTICITY_EQUATIONS_SET_SETUP")
    RETURN
999 ERRORSEXITS("LINEAR_ELASTICITY_EQUATIONS_SET_SETUP",err,error)
    RETURN 1
  END SUBROUTINE LINEAR_ELASTICITY_EQUATIONS_SET_SETUP

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for a linear elasticity equation type of an elasticity equations set class.
  SUBROUTINE LinearElasticity_EquationsSetSolutionMethodSet(EQUATIONS_SET,SOLUTION_METHOD,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: EQUATIONS_SET !<A pointer to the equations set to set the solution method for
    INTEGER(INTG), INTENT(IN) :: SOLUTION_METHOD !<The solution method to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("LinearElasticity_EquationsSetSolutionMethodSet",err,error,*999)

    IF(ASSOCIATED(EQUATIONS_SET)) THEN
      IF(.NOT.ALLOCATED(EQUATIONS_SET%SPECIFICATION)) THEN
        CALL FlagError("Equations set specification is not allocated.",err,error,*999)
      ELSE IF(SIZE(EQUATIONS_SET%SPECIFICATION,1)/=3) THEN
        CALL FlagError("Equations set specification must have three entries for a linear elasticity type equations set.", &
          & err,error,*999)
      END IF
      SELECT CASE(EQUATIONS_SET%SPECIFICATION(3))
      CASE(EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE)
        SELECT CASE(SOLUTION_METHOD)
        CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
          EQUATIONS_SET%solutionMethod=EQUATIONS_SET_FEM_SOLUTION_METHOD
        CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The specified solution method of "//TRIM(NumberToVString(SOLUTION_METHOD,"*",err,error))//" is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE)
        SELECT CASE(SOLUTION_METHOD)
        CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
          EQUATIONS_SET%solutionMethod=EQUATIONS_SET_FEM_SOLUTION_METHOD
        CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The specified solution method of "//TRIM(NumberToVString(SOLUTION_METHOD,"*",err,error))//" is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE)
        SELECT CASE(SOLUTION_METHOD)
        CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
          EQUATIONS_SET%solutionMethod=EQUATIONS_SET_FEM_SOLUTION_METHOD
        CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The specified solution method of "//TRIM(NumberToVString(SOLUTION_METHOD,"*",err,error))//" is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE)
        SELECT CASE(SOLUTION_METHOD)
        CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
          EQUATIONS_SET%solutionMethod=EQUATIONS_SET_FEM_SOLUTION_METHOD
        CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The specified solution method of "//TRIM(NumberToVString(SOLUTION_METHOD,"*",err,error))//" is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(EQUATIONS_SET_PLATE_SUBTYPE)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(EQUATIONS_SET_SHELL_SUBTYPE)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="Equations set subtype of "//TRIM(NumberToVString(EQUATIONS_SET%SPECIFICATION(3),"*",err,error))// &
          & " is not valid for a linear elasticity equation type of an elasticity equations set class."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Equations set is not associated.",err,error,*999)
    ENDIF
    
    EXITS("LinearElasticity_EquationsSetSolutionMethodSet")
    RETURN
999 ERRORS("LinearElasticity_EquationsSetSolutionMethodSet",err,error)
    EXITS("LinearElasticity_EquationsSetSolutionMethodSet")
    RETURN 1
    
  END SUBROUTINE LinearElasticity_EquationsSetSolutionMethodSet

  !
  !================================================================================================================================
  !

  !>Sets the equation specification for a linear elasticity equation type of an elasticity equations set class.
  SUBROUTINE LinearElasticity_EquationsSetSpecificationSet(equationsSet,specification,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set to set the specification for
    INTEGER(INTG), INTENT(IN) :: specification(:) !<The equations set specification to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("LinearElasticity_EquationsSetSpecificationSet",err,error,*999)

    IF(ASSOCIATED(equationsSet)) THEN
      IF(SIZE(specification,1)/=3) THEN
        CALL FlagError("Equations set specification must have three entries for a linear elasticity type equations set.", &
          & err,error,*999)
      END IF
      SELECT CASE(specification(3))
      CASE(EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE, &
          & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE, &
          & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE, &
          & EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE)
        !ok
      CASE(EQUATIONS_SET_PLATE_SUBTYPE)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(EQUATIONS_SET_SHELL_SUBTYPE)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="The third equations set specification of "//TRIM(NumberToVstring(specification(3),"*",err,error))// &
          & " is not valid for a linear elasticity equations set."
        CALL FlagError(localError,err,error,*999)
      END SELECT
      !Set full specification
      IF(ALLOCATED(equationsSet%specification)) THEN
        CALL FlagError("Equations set specification is already allocated.",err,error,*999)
      ELSE
        ALLOCATE(equationsSet%specification(3),stat=err)
        IF(err/=0) CALL FlagError("Could not allocate equations set specification.",err,error,*999)
      END IF
      equationsSet%specification(1:3)=[EQUATIONS_SET_ELASTICITY_CLASS,EQUATIONS_SET_LINEAR_ELASTICITY_TYPE,specification(3)]
    ELSE
      CALL FlagError("Equations set is not associated.",err,error,*999)
    END IF

    EXITS("LinearElasticity_EquationsSetSpecificationSet")
    RETURN
999 ERRORS("LinearElasticity_EquationsSetSpecificationSet",err,error)
    EXITS("LinearElasticity_EquationsSetSpecificationSet")
    RETURN 1
    
  END SUBROUTINE LinearElasticity_EquationsSetSpecificationSet

  !
  !================================================================================================================================
  !

  !>Sets up the linear elasticity problem.
  SUBROUTINE LINEAR_ELASTICITY_PROBLEM_SETUP(PROBLEM,PROBLEM_SETUP,err,error,*)

    !Argument variables
    TYPE(ProblemType), POINTER :: PROBLEM !<A pointer to the problem set to setup a linear elasticity equation on.
    TYPE(ProblemSetupType), INTENT(INOUT) :: PROBLEM_SETUP !<The problem setup information
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(ControlLoopType), POINTER :: CONTROL_LOOP,CONTROL_LOOP_ROOT
    TYPE(SolverType), POINTER :: SOLVER
    TYPE(SolverEquationsType), POINTER :: SOLVER_EQUATIONS
    TYPE(SolversType), POINTER :: SOLVERS
    TYPE(VARYING_STRING) :: localError

    ENTERS("LINEAR_ELASTICITY_PROBLEM_SETUP",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(SOLVERS)
    IF(ASSOCIATED(PROBLEM)) THEN
      IF(.NOT.ALLOCATED(PROBLEM%SPECIFICATION)) THEN
        CALL FlagError("Problem specification is not allocated.",err,error,*999)
      ELSE IF(SIZE(PROBLEM%SPECIFICATION,1)<3) THEN
        CALL FlagError("Problem specification must have three entries for a linear elasticity problem.",err,error,*999)
      END IF
      SELECT CASE(PROBLEM%SPECIFICATION(3))
      CASE(PROBLEM_NO_SUBTYPE)
        SELECT CASE(PROBLEM_SETUP%setupType)
        CASE(PROBLEM_SETUP_INITIAL_TYPE)
          SELECT CASE(PROBLEM_SETUP%actionType)
          CASE(PROBLEM_SETUP_START_ACTION)
            !Do nothing????
          CASE(PROBLEM_SETUP_FINISH_ACTION)
            !Do nothing????
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(PROBLEM_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(PROBLEM_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity problem."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(PROBLEM_SETUP_CONTROL_TYPE)
          SELECT CASE(PROBLEM_SETUP%actionType)
          CASE(PROBLEM_SETUP_START_ACTION)
            !Set up a simple control loop
            CALL CONTROL_LOOP_CREATE_START(PROBLEM,CONTROL_LOOP,err,error,*999)
          CASE(PROBLEM_SETUP_FINISH_ACTION)
            !Finish the control loops
            CONTROL_LOOP_ROOT=>PROBLEM%controlLoop
            CALL CONTROL_LOOP_GET(CONTROL_LOOP_ROOT,CONTROL_LOOP_NODE,CONTROL_LOOP,err,error,*999)
            CALL CONTROL_LOOP_CREATE_FINISH(CONTROL_LOOP,err,error,*999)            
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(PROBLEM_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(PROBLEM_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity problem."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(PROBLEM_SETUP_SOLVERS_TYPE)
          !Get the control loop
          CONTROL_LOOP_ROOT=>PROBLEM%controlLoop
          CALL CONTROL_LOOP_GET(CONTROL_LOOP_ROOT,CONTROL_LOOP_NODE,CONTROL_LOOP,err,error,*999)
          SELECT CASE(PROBLEM_SETUP%actionType)
          CASE(PROBLEM_SETUP_START_ACTION)
            !Start the solvers creation
            CALL SOLVERS_CREATE_START(CONTROL_LOOP,SOLVERS,err,error,*999)
            CALL Solvers_NumberOfSolversSet(SOLVERS,1,err,error,*999)
            !Set the solver to be a linear solver
            CALL SOLVERS_SOLVER_GET(SOLVERS,1,SOLVER,err,error,*999)
            CALL SOLVER_TYPE_SET(SOLVER,SOLVER_LINEAR_TYPE,err,error,*999)
            !Set solver defaults
            CALL SOLVER_LIBRARY_TYPE_SET(SOLVER,SOLVER_PETSC_LIBRARY,err,error,*999)
          CASE(PROBLEM_SETUP_FINISH_ACTION)
            !Get the solvers
            CALL CONTROL_LOOP_SOLVERS_GET(CONTROL_LOOP,SOLVERS,err,error,*999)
            !Finish the solvers creation
            CALL SOLVERS_CREATE_FINISH(SOLVERS,err,error,*999)
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(PROBLEM_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(PROBLEM_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity problem."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(PROBLEM_SETUP_SOLVER_EQUATIONS_TYPE)
          SELECT CASE(PROBLEM_SETUP%actionType)
          CASE(PROBLEM_SETUP_START_ACTION)
            !Get the control loop
            CONTROL_LOOP_ROOT=>PROBLEM%controlLoop
            CALL CONTROL_LOOP_GET(CONTROL_LOOP_ROOT,CONTROL_LOOP_NODE,CONTROL_LOOP,err,error,*999)
            !Get the solver
            CALL CONTROL_LOOP_SOLVERS_GET(CONTROL_LOOP,SOLVERS,err,error,*999)
            CALL SOLVERS_SOLVER_GET(SOLVERS,1,SOLVER,err,error,*999)
            !Create the solver equations
            CALL SOLVER_EQUATIONS_CREATE_START(SOLVER,SOLVER_EQUATIONS,err,error,*999)
            CALL SOLVER_EQUATIONS_LINEARITY_TYPE_SET(SOLVER_EQUATIONS,SOLVER_EQUATIONS_LINEAR,err,error,*999)
            CALL SOLVER_EQUATIONS_TIME_DEPENDENCE_TYPE_SET(SOLVER_EQUATIONS,SOLVER_EQUATIONS_STATIC,err,error,*999)
            CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(SOLVER_EQUATIONS,SOLVER_SPARSE_MATRICES,err,error,*999)
          CASE(PROBLEM_SETUP_FINISH_ACTION)
            !Get the control loop
            CONTROL_LOOP_ROOT=>PROBLEM%controlLoop
            CALL CONTROL_LOOP_GET(CONTROL_LOOP_ROOT,CONTROL_LOOP_NODE,CONTROL_LOOP,err,error,*999)
            !Get the solver equations
            CALL CONTROL_LOOP_SOLVERS_GET(CONTROL_LOOP,SOLVERS,err,error,*999)
            CALL SOLVERS_SOLVER_GET(SOLVERS,1,SOLVER,err,error,*999)
            CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
            !Finish the solver equations creation
            CALL SOLVER_EQUATIONS_CREATE_FINISH(SOLVER_EQUATIONS,err,error,*999)             
          CASE DEFAULT
            localError="The action type of "//TRIM(NumberToVString(PROBLEM_SETUP%actionType,"*",err,error))// &
              & " for a setup type of "//TRIM(NumberToVString(PROBLEM_SETUP%setupType,"*",err,error))// &
              & " is invalid for a linear elasticity problem."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE DEFAULT
          localError="The setup type of "//TRIM(NumberToVString(PROBLEM_SETUP%setupType,"*",err,error))// &
            & " is invalid for a linear elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE DEFAULT
        localError="Problem subtype "//TRIM(NumberToVString(PROBLEM%SPECIFICATION(3),"*",err,error))// &
          & " is not valid for a linear elasticity type of an elasticity problem class."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Problem is not associated.",err,error,*999)
    ENDIF

    EXITS("LINEAR_ELASTICITY_PROBLEM_SETUP")
    RETURN
999 ERRORSEXITS("LINEAR_ELASTICITY_PROBLEM_SETUP",err,error)
    RETURN 1
  END SUBROUTINE LINEAR_ELASTICITY_PROBLEM_SETUP

  !
  !================================================================================================================================
  !

  !>Sets the problem specification for a linear elasticity type problem.
  SUBROUTINE LinearElasticity_ProblemSpecificationSet(problem,problemSpecification,err,error,*)

    !Argument variables
    TYPE(ProblemType), POINTER :: problem !<A pointer to the problem to set the problem specification for
    INTEGER(INTG), INTENT(IN) :: problemSpecification(:) !<The problem specifiation to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: problemSubtype

    ENTERS("LinearElasticity_ProblemSpecificationSet",err,error,*999)

    IF(ASSOCIATED(problem)) THEN
      IF(SIZE(problemSpecification,1)==3) THEN
        problemSubtype=problemSpecification(3)
        SELECT CASE(problemSubtype)
        CASE(PROBLEM_NO_SUBTYPE)
          !ok
        CASE DEFAULT
          localError="The third problem specification of "//TRIM(NumberToVstring(problemSubtype,"*",err,error))// &
            & " is not valid for a linear elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE IF(SIZE(problemSpecification,1)<3) THEN
        !Linear elasticity problem doesn't require a subtype, set it to no type
        problemSubtype=PROBLEM_NO_SUBTYPE
      ELSE
        CALL FlagError("Linear elasticity problem specification may only have 3 entries.",err,error,*999)
      END IF
      !Set full specification
      IF(ALLOCATED(problem%specification)) THEN
        CALL FlagError("Problem specification is already allocated.",err,error,*999)
      ELSE
        ALLOCATE(problem%specification(3),stat=err)
        IF(err/=0) CALL FlagError("Could not allocate problem specification.",err,error,*999)
      END IF
      problem%specification(1:3)=[PROBLEM_ELASTICITY_CLASS, PROBLEM_LINEAR_ELASTICITY_TYPE, problemSubtype]
    ELSE
      CALL FlagError("Problem is not associated.",err,error,*999)
    END IF

    EXITS("LinearElasticity_ProblemSpecificationSet")
    RETURN
999 ERRORS("LinearElasticity_ProblemSpecificationSet",err,error)
    EXITS("LinearElasticity_ProblemSpecificationSet")
    RETURN 1
    
  END SUBROUTINE LinearElasticity_ProblemSpecificationSet

  !
  !================================================================================================================================
  !

END MODULE LINEAR_ELASTICITY_ROUTINES
