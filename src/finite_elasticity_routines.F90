!> \file
!> \author Chris Bradley
!> \brief This module handles all finite elasticity routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s): Chris Bradley, Kumar Mithraratne, Jack Lee, Alice Hung, Sander Arens, Jenny Wang
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!>This module handles all finite elasticity routines.
MODULE FiniteElasticityRoutines

  USE BaseRoutines
  USE BasisRoutines
  USE BasisAccessRoutines
  USE BoundaryConditionsRoutines
  USE BoundaryConditionAccessRoutines
  USE ComputationRoutines
  USE ComputationAccessRoutines
  USE Constants
  USE ControlLoopRoutines
  USE ControlLoopAccessRoutines
  USE CoordinateSystemRoutines  
  USE CoordinateSystemAccessRoutines
  USE DataProjectionAccessRoutines
  USE DecompositionRoutines
  USE DecompositionAccessRoutines
  USE DistributedMatrixVector
  USE DistributedMatrixVectorAccessRoutines
  USE DomainMappings
  USE EquationsRoutines
  USE EquationsAccessRoutines
  USE EquationsMappingRoutines
  USE EquationsMappingAccessRoutines
  USE EquationsMatricesRoutines
  USE EquationsMatricesAccessRoutines
  USE EquationsSetAccessRoutines
  USE FieldRoutines
  USE FieldAccessRoutines
  USE FIELD_IO_ROUTINES
  USE FiniteElasticityUtilityRoutines
  USE FLUID_MECHANICS_IO_ROUTINES
  USE GeneratedMeshRoutines
  USE InputOutput
  USE ISO_VARYING_STRING
  USE Kinds
  USE Lapack
  USE Maths 
  USE MatrixVector
  USE MeshRoutines
  USE MeshAccessRoutines
#ifndef NOMPIMOD
  USE MPI
#endif
  USE ProblemAccessRoutines
  USE ProfilingRoutines
  USE RegionAccessRoutines
  USE SolverRoutines
  USE SolverAccessRoutines
  USE SolverMappingAccessRoutines
  USE SolverMatricesAccessRoutines
  USE Strings
  USE Timer
  USE Types

#include "macros.h"

  IMPLICIT NONE

#ifdef NOMPIMOD
#include "mpif.h"
#endif

  PRIVATE

  !Module parameters

  !> \addtogroup FiniteElasticityRoutines_AnalyticParamIndices FiniteElasticityRoutines::AnalyticParamIndices
  !> \brief Indices for EquationsSetAnalyticType%analyticUserParams
  !> \see FiniteElasticityRoutines,OpenCMISS_AnalyticParamIndices
  !>@{
  INTEGER(INTG), PARAMETER :: FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX=1 !<Inner pressure parameter index \see FiniteElasticityRoutines_AnalyticParamIndices, FiniteElasticityRoutines
  INTEGER(INTG), PARAMETER :: FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX=2 !<Outer pressure parameter index \see FiniteElasticityRoutines_AnalyticParamIndices, FiniteElasticityRoutines
  INTEGER(INTG), PARAMETER :: FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX=3 !<Lambda parameter index \see FiniteElasticityRoutines_AnalyticParamIndices, FiniteElasticityRoutines
  INTEGER(INTG), PARAMETER :: FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX=4 !<Tsi parameter index \see FiniteElasticityRoutines_AnalyticParamIndices, FiniteElasticityRoutines
  INTEGER(INTG), PARAMETER :: FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX=5 !<Inner radius parameter index \see FiniteElasticityRoutines_AnalyticParamIndices, FiniteElasticityRoutines
  INTEGER(INTG), PARAMETER :: FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX=6 !<Outer radius parameter index \see FiniteElasticityRoutines_AnalyticParamIndices, FiniteElasticityRoutines
  INTEGER(INTG), PARAMETER :: FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX=7 !<c1 parameter index \see FiniteElasticityRoutines_AnalyticParamIndices, FiniteElasticityRoutines
  INTEGER(INTG), PARAMETER :: FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX=8 !<c2 parameter index \see FiniteElasticityRoutines_AnalyticParamIndices, FiniteElasticityRoutines
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX,FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX, &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX, FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX, &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX, FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX, &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX, FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX

  PUBLIC FiniteElasticity_BoundaryConditionsAnalyticCalculate
  
  PUBLIC FiniteElasticity_FiniteElementResidualEvaluate

  PUBLIC FiniteElasticity_FiniteElementPreResidualEvaluate

  PUBLIC FiniteElasticity_FiniteElementPostResidualEvaluate

  PUBLIC FiniteElasticity_FiniteElementJacobianEvaluate
  
  PUBLIC FiniteElasticity_EquationsSetSetup

  PUBLIC FiniteElasticity_EquationsSetSolutionMethodSet
  
  PUBLIC FiniteElasticity_EquationsSetSpecificationSet

  PUBLIC FiniteElasticity_ProblemSpecificationSet

  PUBLIC FiniteElasticity_ProblemSetup

  PUBLIC FiniteElasticity_ContactProblemSpecificationSet

  PUBLIC FiniteElasticity_ContactProblemSetup
  
  PUBLIC FiniteElasticity_PostSolve

  PUBLIC FiniteElasticity_PostSolveOutputData

  PUBLIC FiniteElasticity_PreSolve

  PUBLIC FiniteElasticity_PreLoop

  PUBLIC FiniteElasticity_ControlLoadIncrementLoopPostLoop

  PUBLIC FiniteElasticity_EvaluateChapelleFunction

  PUBLIC FiniteElasticity_GetDarcyParameters

  PUBLIC FiniteElasticity_LoadIncrementApply

  PUBLIC FiniteElasticity_StressStrainCalculate
    
  PUBLIC FiniteElasticityEquationsSet_DerivedVariableCalculate

  PUBLIC FiniteElasticity_PostLoop
  
  PUBLIC FiniteElasticity_TensorInterpolateGaussPoint
  
  PUBLIC FiniteElasticity_TensorInterpolateXi

CONTAINS

  !
  !================================================================================================================================
  !

  !>Calculates the analytic solution and sets the boundary conditions for an analytic problem
  SUBROUTINE FiniteElasticity_BoundaryConditionsAnalyticCalculate(equationsSet,boundaryConditions,err,error,*)
    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    INTEGER(INTG) :: analyticFunctionType,bottomNormalXi,nodeIdx,componentIdx,derivativeIdx,dimensionIdx,domainNumber, &
      & globalNodeNumber,globalDerivativeIndex,groupCommuicator,innerNormalXi,localDOFIdx,localNodeNumber,meshComponent, &
      & meshNodeNumber,mpiIError,myGroupComputationNodeNumber,numberOfDimensions,numberOfNodes,numberOfNodeDerivatives, &
      & numberOfVariables,outerNormalXi,pressureComponentIdx,pressureMeshComponent,topNormalXi,userNodeNumber,variableIdx, &
      & variableType
    INTEGER(INTG),ALLOCATABLE :: bottomSurfaceNodes(:),innerSurfaceNodes(:),outerSurfaceNodes(:),topSurfaceNodes(:)
    REAL(DP) :: deformedZ,lambda,P,pIn,pOut,X(3),deformedX(3)
    REAL(DP), POINTER :: geometricParameters(:)
    LOGICAL :: ghostDOF,nodeExists,xFixed,xOkay,yFixed,yOkay
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain,pressureDomain
    TYPE(DomainMappingType), POINTER :: nodesMapping
    TYPE(DomainMappingsType), POINTER :: domainMappings
    TYPE(DomainNodesType), POINTER :: domainNodes,pressureDomainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(EquationsSetAnalyticType), POINTER :: equationsAnalytic
    TYPE(FieldType), POINTER :: dependentField,geometricField
    TYPE(FieldVariableType), POINTER :: dependentVariable,geometricVariable
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(MeshTopologyType), POINTER :: meshTopology
    TYPE(VARYING_STRING) :: localError
    TYPE(WorkGroupType), POINTER :: workGroup

    ENTERS("FiniteElasticity_BoundaryConditionsAnalyticCalculate",err,error,*999)

    IF(.NOT.ASSOCIATED(boundaryConditions)) CALL FlagError("Boundary conditions is not associated.",err,error,*999)
    NULLIFY(equationsAnalytic)
    CALL EquationsSet_AnalyticGet(equationsSet,equationsAnalytic,err,error,*999)
    CALL EquationsSet_AnalyticFunctionTypeGet(equationsSet,analyticFunctionType,err,error,*999)
    NULLIFY(geometricField)
    CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
    NULLIFY(geometricVariable)
    CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
    CALL FieldVariable_NumberOfComponentsGet(geometricVariable,numberOfDimensions,err,error,*999)
    NULLIFY(geometricParameters)
    CALL FieldVariable_ParameterSetDataGet(geometricVariable,FIELD_VALUES_SET_TYPE,geometricParameters,err,error,*999)
    CALL FieldVariable_ComponentMeshComponentGet(geometricVariable,1,meshComponent,err,error,*999)
    NULLIFY(dependentField)
    CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
    CALL Field_NumberOfVariablesGet(dependentField,numberOfVariables,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(dependentField,decomposition,err,error,*999)
    NULLIFY(workGroup)
    CALL Decomposition_WorkGroupGet(decomposition,workGroup,err,error,*999)          
    CALL WorkGroup_GroupNodeNumberGet(workGroup,myGroupComputationNodeNumber,err,error,*999)
    CALL WorkGroup_GroupCommunicatorGet(workGroup,groupCommuicator,err,error,*999)

    !Assign BC here - it's complicated so separate from analytic calculations
    NULLIFY(mesh)
    CALL Decomposition_MeshGet(decomposition,mesh,err,error,*999)
    NULLIFY(meshTopology)
    CALL Mesh_MeshTopologyGet(mesh,meshComponent,meshTopology,err,error,*999)
    NULLIFY(meshNodes)
    CALL MeshTopology_MeshNodesGet(meshTopology,meshNodes,err,error,*999)
    NULLIFY(generatedMesh)
    CALL Mesh_GeneratedMeshGet(mesh,generatedMesh,err,error,*999)
    NULLIFY(domain)
    CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
    NULLIFY(domainMappings)
    CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)
    NULLIFY(nodesMapping)
    CALL DomainMappings_NodesMappingGet(domainMappings,nodesMapping,err,error,*999)
    !Get surfaces (hardcoded): fix two nodes on the bottom face, pressure conditions inside & outside
    CALL GeneratedMesh_SurfaceGet(generatedMesh,meshComponent,1_INTG,innerSurfaceNodes,innerNormalXi,err,error,*999) !Inner
    CALL GeneratedMesh_SurfaceGet(generatedMesh,meshComponent,2_INTG,outerSurfaceNodes,outerNormalXi,err,error,*999) !Outer
    CALL GeneratedMesh_SurfaceGet(generatedMesh,meshComponent,3_INTG,topSurfaceNodes,topNormalXi,err,error,*999) !Top
    CALL GeneratedMesh_SurfaceGet(generatedMesh,meshComponent,4_INTG,bottomSurfaceNodes,bottomNormalXi,err,error,*999) !Bottom
    !Set all inner surface nodes to inner pressure (- sign is to make positive P into a compressive force) ?
!!TODO: remove analytic user parameters
    pIn=equationsAnalytic%analyticUserParams(FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX)
    DO nodeIdx=1,SIZE(innerSurfaceNodes,1)
      userNodeNumber=innerSurfaceNodes(nodeIdx)
      !Need to test if this node is in current decomposition
      CALL Decomposition_NodeDomainGet(decomposition,userNodeNumber,1,domainNumber,err,error,*999)
      IF(domainNumber==myGroupComputationNodeNumber) THEN
        !Default to version 1 of each node derivative
        CALL BoundaryConditions_SetNode(boundaryConditions,dependentField,FIELD_DELUDELN_VARIABLE_TYPE,1,1, &
          & userNodeNumber,ABS(innerNormalXi),BOUNDARY_CONDITION_PRESSURE_INCREMENTED,pIn,err,error,*999)
      ENDIF
    ENDDO !nodeIdx
    !Set all outer surface nodes to outer pressure
    pOut=equationsAnalytic%analyticUserParams(FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX)
    DO nodeIdx=1,SIZE(outerSurfaceNodes,1)
      userNodeNumber=outerSurfaceNodes(nodeIdx)
      !Need to test if this node is in current decomposition
      CALL Decomposition_NodeDomainGet(decomposition,userNodeNumber,1,domainNumber,err,error,*999)
      IF(domainNumber==myGroupComputationNodeNumber) THEN
        !Default to version 1 of each node derivative
        CALL BoundaryConditions_SetNode(boundaryConditions,dependentField,FIELD_DELUDELN_VARIABLE_TYPE,1,1, &
          & userNodeNumber,ABS(outerNormalXi),BOUNDARY_CONDITION_PRESSURE_INCREMENTED,pOut,err,error,*999)
      ENDIF
    ENDDO !nodeIdx
    !Set all top nodes fixed in z plane at lambda*height
    lambda=equationsAnalytic%analyticUserParams(FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX)
    DO nodeIdx=1,SIZE(topSurfaceNodes,1)
      userNodeNumber=topSurfaceNodes(nodeIdx)
      !Need to test if this node is in current decomposition
      CALL Decomposition_NodeDomainGet(decomposition,userNodeNumber,1,domainNumber,err,error,*999)
      IF(domainNumber==myGroupComputationNodeNumber) THEN
        CALL FieldVariable_UserNodeDOFGet(geometricVariable,1,1,userNodeNumber,3,localDOFIdx,ghostDOF,err,error,*999)
        deformedZ=geometricParameters(localDOFIdx)*lambda
        !Default to version 1 of each node derivative
        CALL BoundaryConditions_SetNode(boundaryConditions,dependentField,FIELD_U_VARIABLE_TYPE,1,1, &
          & userNodeNumber,ABS(topNormalXi),BOUNDARY_CONDITION_FIXED,deformedZ,err,error,*999)
      ENDIF
    ENDDO !nodeIdx
    !Set all bottom nodes fixed in z plane
    DO nodeIdx=1,SIZE(bottomSurfaceNodes,1)
      userNodeNumber=bottomSurfaceNodes(nodeIdx)
      !Need to check this node exists in the current domain
      CALL Decomposition_NodeDomainGet(decomposition,userNodeNumber,1,domainNumber,err,error,*999)
      IF(domainNumber==myGroupComputationNodeNumber) THEN
        !Default to version 1 of each node derivative
        CALL BoundaryConditions_SetNode(boundaryConditions,dependentField,FIELD_U_VARIABLE_TYPE,1,1, &
          & userNodeNumber,ABS(bottomNormalXi),BOUNDARY_CONDITION_FIXED,0.0_DP,err,error,*999)
      ENDIF
    ENDDO !nodeIdx
    !Set two nodes on the bottom surface to axial displacement only:
    !Easier for parallel: Fix everything that can be fixed !!!
    xFixed=.FALSE.
    yFixed=.FALSE.
    DO nodeIdx=1,SIZE(bottomSurfaceNodes,1)
      userNodeNumber=bottomSurfaceNodes(nodeIdx)
      CALL Decomposition_NodeDomainGet(decomposition,userNodeNumber,1,domainNumber,err,error,*999)
      IF(domainNumber==myGroupComputationNodeNumber) THEN
        CALL FieldVariable_UserNodeDOFGet(geometricVariable,1,1,userNodeNumber,1,localDOFIdx,ghostDOF,err,error,*999)
        X(1)=geometricParameters(localDOFIdx)
        CALL FieldVariable_UserNodeDOFGet(geometricVariable,1,1,userNodeNumber,2,localDOFIdx,ghostDOF,err,error,*999)
        X(2)=geometricParameters(localDOFIdx)
        IF(ABS(X(1))<1E-7_DP) THEN
          !Default to version 1 of each node derivative
          CALL BoundaryConditions_SetNode(boundaryConditions,dependentField,FIELD_U_VARIABLE_TYPE,1,1, &
            & userNodeNumber,1,BOUNDARY_CONDITION_FIXED,0.0_DP,err,error,*999)          
          xFixed=.TRUE.
        ENDIF
        IF(ABS(X(2))<1E-7_DP) THEN
          !Default to version 1 of each node derivative
          CALL BoundaryConditions_SetNode(boundaryConditions,dependentField,FIELD_U_VARIABLE_TYPE,1,1, &
            & userNodeNumber,2,BOUNDARY_CONDITION_FIXED,0.0_DP,err,error,*999)          
          yFixed=.TRUE.
        ENDIF
      ENDIF
    ENDDO !nodeIdx
    !Check it went well
    CALL MPI_REDUCE(xFixed,xOkay,1,MPI_LOGICAL,MPI_LOR,0,groupCommuicator,mpiIError)
    CALL MPI_REDUCE(yFixed,yOkay,1,MPI_LOGICAL,MPI_LOR,0,groupCommuicator,mpiIError)
    IF(myGroupComputationNodeNumber==0) THEN
      IF(.NOT.(xOkay.AND.yOkay)) THEN
        CALL FlagError("Could not fix nodes to prevent rigid body motion",err,error,*999)
      ENDIF
    ENDIF
    !Now calculate analytic solution
    DO variableIdx=1,numberOfVariables
      NULLIFY(dependentVariable)
      CALL Field_VariableIndexGet(dependentField,variableidx,dependentVariable,variableType,err,error,*999)
      CALL FieldVariable_ParameterSetEnsureCreated(dependentVariable,FIELD_ANALYTIC_VALUES_SET_TYPE,err,error,*999)
      componentIdx=1 !Assuming components 1..3 use a common mesh component and 4 uses a different one
      CALL FieldVariable_ComponentInterpolationCheck(dependentVariable,componentIdx,FIELD_NODE_BASED_INTERPOLATION, &
        & err,error,*999)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(dependentVariable,componentIdx,domain,err,error,*999)
      CALL Domain_MeshComponentNumberGet(domain,meshComponent,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainNodes)
      CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
      !Also grab the equivalent pointer for pressure component
      pressureComponentIdx=numberOfDimensions+1
      CALL FieldVariable_ComponentInterpolationCheck(dependentVariable,pressureComponentIdx,FIELD_NODE_BASED_INTERPOLATION, &
        & err,error,*999)
      NULLIFY(pressureDomain)
      CALL FieldVariable_ComponentDomainGet(dependentVariable,pressureComponentIdx,pressureDomain,err,error,*999)
      CALL Domain_MeshComponentNumberGet(pressureDomain,pressureMeshComponent,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(pressureDomain,domainTopology,err,error,*999)
      NULLIFY(pressureDomainNodes)
      CALL DomainTopology_DomainNodesGet(domainTopology,pressureDomainNodes,err,error,*999)
      
      NULLIFY(meshTopology)
      CALL Mesh_MeshTopologyGet(mesh,meshComponent,meshTopology,err,error,*999)
      NULLIFY(meshNodes)
      CALL MeshTopology_MeshNodesGet(meshTopology,meshNodes,err,error,*999)
      !Loop over the local nodes excluding the ghosts.
      CALL DomainNodes_NumberOfNodesGet(domainNodes,numberOfNodes,err,error,*999)
      DO nodeIdx=1,numberOfNodes
!!TODO \todo We should interpolate the geometric field here and the node position.
        DO dimensionIdx=1,numberOfDimensions
          !Default to version 1 of each node derivative
          CALL FieldVariable_LocalNodeDOFGet(geometricVariable,1,1,nodeIdx,dimensionIdx,localDOFIdx,err,error,*999)
          X(dimensionIdx)=geometricParameters(localDOFIdx)
        ENDDO !dimensionIdx
        !Loop over the derivatives
        CALL DomainNodes_NodeNumberOfDerivativesGet(domainNodes,nodeIdx,numberOfNodeDerivatives,err,error,*999)
        DO derivativeIdx=1,numberOfNodeDerivatives
          CALL DomainNodes_DerivativeGlobalIndexGet(domainNodes,derivativeIdx,nodeIdx,globalDerivativeIndex,err,error,*999)
          SELECT CASE(analyticFunctionType)
          CASE(EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER)
            !Cylinder inflation, extension, torsion
            SELECT CASE(variableType)
            CASE(FIELD_U_VARIABLE_TYPE)
              SELECT CASE(globalDerivativeIndex)
              CASE(NO_GLOBAL_DERIV)
                !Do all components at the same time (r,theta,z)->(x,y,z) & p
                CALL FiniteElasticity_CylinderAnalyticCalculate(X,equationsAnalytic%analyticUserParams,deformedX,P,err,error,*999)
              CASE(GLOBAL_DERIV_S1)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(GLOBAL_DERIV_S2)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(GLOBAL_DERIV_S1_S2)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The global derivative index of "//TRIM(NumberToVString(globalDerivativeIndex,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            CASE(FIELD_DELUDELN_VARIABLE_TYPE)
              SELECT CASE(globalDerivativeIndex)
              CASE(NO_GLOBAL_DERIV)
                !Not implemented, but don't want to cause an error so do nothing
              CASE(GLOBAL_DERIV_S1)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(GLOBAL_DERIV_S2)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(GLOBAL_DERIV_S1_S2)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The global derivative index of "//TRIM(NumberToVString(globalDerivativeIndex,"*", err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            CASE DEFAULT
              localError="The variable type "//TRIM(NumberToVString(variableType,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          CASE DEFAULT
            localError="The analytic function type of "//TRIM(NumberToVString(analyticFunctionType,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          !Set the analytic solution to parameter set
          DO componentIdx=1,numberOfDimensions
            !Default to version 1 of each node derivative
            CALL FieldVariable_LocalNodeDOFGet(dependentVariable,1,derivativeIdx,nodeIdx,componentIdx,localDOFIdx,err,error,*999)
            CALL FieldVariable_ParameterSetUpdateLocalDOF(dependentVariable,FIELD_ANALYTIC_VALUES_SET_TYPE,localDOFIdx, &
              & deformedX(componentIdx),err,error,*999)
          ENDDO !componentIdx
          !Don't forget the pressure component
          CALL DomainNodes_NodeUserNumberGet(domainNodes,nodeIdx,userNodeNumber,err,error,*999)
          CALL MeshNodes_NodeCheckExists(meshNodes,userNodeNumber,nodeExists,globalNodeNumber,meshNodeNumber,err,error,*999)
          IF(nodeExists) THEN
            CALL Decomposition_NodeDomainGet(decomposition,userNodeNumber,pressureMeshComponent,domainNumber,err,error,*999)
            IF(domainNumber==myGroupComputationNodeNumber) THEN
              !\todo: test the domain node mappings pointer properly
!!TODO: remove global to local
              localNodeNumber=pressureDomain%mappings%nodes%globalToLocalMap(globalNodeNumber)%localNumber(1)
              !Default to version 1 of each node derivative
              CALL FieldVariable_LocalNodeDOFGet(dependentVariable,1,derivativeIdx,localNodeNumber,4,localDOFIdx,err,error,*999)
              !Because p=2.lambda in this particular constitutive law, we'll assign half the
              !hydrostatic pressure to the analytic array
              CALL FieldVariable_ParameterSetUpdateLocalDOF(dependentVariable,FIELD_ANALYTIC_VALUES_SET_TYPE,localDOFIdx, &
                & P/2.0_dp,err,error,*999)
            ENDIF
          ENDIF
        ENDDO !derivativeIdx
      ENDDO !nodeIdx
      CALL FieldVariable_ParameterSetUpdateStart(dependentVariable,FIELD_ANALYTIC_VALUES_SET_TYPE,err,error,*999)
      CALL FieldVariable_ParameterSetUpdateFinish(dependentVariable,FIELD_ANALYTIC_VALUES_SET_TYPE, err,error,*999)
    ENDDO !variableIdx
    CALL FieldVariable_ParameterSetDataRestore(geometricVariable,FIELD_VALUES_SET_TYPE,geometricParameters,err,error,*999)

    EXITS("FiniteElasticity_BoundaryConditionsAnalyticCalculate")
    RETURN
999 ERRORS("FiniteElasticity_BoundaryConditionsAnalyticCalculate",err,error)
    EXITS("FiniteElasticity_BoundaryConditionsAnalyticCalculate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_BoundaryConditionsAnalyticCalculate

  !
  !================================================================================================================================
  !

  !>Calcualates the analytic solution (deformed coordinates and hydrostatic pressure) for cylinder inflation+extension+torsion problem
  SUBROUTINE FiniteElasticity_CylinderAnalyticCalculate(X,analyticUserParameters,deformedX,P,err,error,*)
    !Argument variables
    REAL(DP), INTENT(IN) :: X(:)                !<Undeformed coordinates
    REAL(DP), INTENT(IN) :: analyticUserParameters(:) !<Array containing the problem parameters
    REAL(DP), INTENT(OUT) :: deformedX(3)      !<Deformed coordinates
    REAL(DP), INTENT(OUT) :: P                  !<Hydrostatic pressure at the given material coordintae
    INTEGER(INTG), INTENT(OUT) :: err           !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error  !<The error string
    !Local variables
    REAL(DP) :: pIn,pOut,lambda,tsi,A1,A2,C1,C2 !A1=external radius, A2=internal radius
    REAL(DP) :: mu1,mu2,mu,K
    REAL(DP) :: F,F2,DF
    REAL(DP) :: R,theta ! Undeformed coordinates in radial coordinates
    REAL(DP) :: deformedR,deformedTheta
    REAL(DP) :: delta,residual
    REAL(DP), PARAMETER :: STEP=1E-5_DP, RELTOL=1E-12_DP

    ENTERS("FiniteElasticity_CylinderAnalyticCalculate",err,error,*999)

    !Grab problem parameters
    pIn=analyticUserParameters(FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX)
    pOut=analyticUserParameters(FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX)
    lambda=analyticUserParameters(FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX)
    tsi=analyticUserParameters(FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX)
    A1=analyticUserParameters(FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX) ! external radius
    A2=analyticUserParameters(FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX) ! internal radius
    C1=analyticUserParameters(FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX)
    C2=analyticUserParameters(FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX)

    !Solve for mu1 - Newton's method (\todo: Implement here, or separate out for general use?)
    mu1=1.0_DP  !Initial guess - need a better way!
    DO
      !Calculate f(mu1)
      F=FiniteElasticity_CylinderAnalyticFuncEvaluate(mu1,pIn,pOut,lambda,tsi,A1,A2,C1,C2,err,error)
      IF(ERR/=0) GOTO 999

      !Calculate f'(mu1) by finite differencing
      F2=FiniteElasticity_CylinderAnalyticFuncEvaluate(mu1+STEP,pIn,pOut,lambda,tsi,A1,A2,C1,C2,err,error)
      IF(ERR/=0) GOTO 999
      DF=(F2-F)/STEP

      !Next increment for mu1
      delta=-F/DF

      !Ensure that the step actually reduces residual
      F2=FiniteElasticity_CylinderAnalyticFuncEvaluate(mu1+delta,pIn,pOut,lambda,tsi,A1,A2,C1,C2,err,error)
      IF(ERR/=0) GOTO 999
      DO
        IF (ABS(F2)<ABS(F).OR.ABS(F2)<ZERO_TOLERANCE) THEN    ! PASS
          mu1=mu1+delta
          EXIT
        ELSEIF (delta<1E-3_DP) THEN ! FAIL: It's likely that the initial guess is too far away
          CALL FlagError("FiniteElasticity_CylinderAnalyticCalculate failed to converge.",err,error,*999)
        ELSE                        ! KEEP GOING
          delta=delta/2.0_DP
          F2=FiniteElasticity_CylinderAnalyticFuncEvaluate(mu1+delta,pIn,pOut,lambda,tsi,A1,A2,C1,C2,err,error)
          IF(ERR/=0) GOTO 999
        ENDIF
      ENDDO

      !Test for convergence: relative residual
      residual=delta/(1.0_DP+mu1)
      IF (residual<RELTOL) EXIT
    ENDDO

    !Calculate mu2
    mu2=SQRT(((A1/A2)**2*(lambda*mu1**2-1.0_DP)+1.0_DP)/lambda)

    !Calculate radius and angle from undeformed coordinates
    R=SQRT(X(1)**2+X(2)**2)
    theta=ATAN2(X(2),X(1)) ! in radians

    !Calculate deformed coordinates
    K=A1**2*(lambda*mu1**2-1.0_DP)
    mu=SQRT(1.0_DP/lambda*(1.0_DP+K/R**2))
    deformedR=mu*R
    deformedTheta=theta+tsi*lambda*X(3)
    deformedX(1)=deformedR*COS(deformedTheta)
    deformedX(2)=deformedR*SIN(deformedTheta)
    deformedX(3)=lambda*X(3)

    !Calculate pressure
    P=pOut-(C1/lambda+C2*lambda)*(1.0_DP/lambda/mu1**2-R**2/(R**2+K)+LOG(mu**2/mu1**2))+C1*tsi**2*lambda*(R**2-A1**2) &
      & -2.0_DP*(C1/lambda**2/mu**2+C2*(1.0_DP/lambda**2+1.0_DP/mu**2+tsi**2*R**2))

    EXITS("FiniteElasticity_CylinderAnalyticCalculate")
    RETURN
999 ERRORSEXITS("FiniteElasticity_CylinderAnalyticCalculate",err,error)
    RETURN 1

  END SUBROUTINE FiniteElasticity_CylinderAnalyticCalculate

  !
  !================================================================================================================================
  !

  !>Evaluates the residual function required to solve for mu1, in the cylinder analytic example
  FUNCTION FiniteElasticity_CylinderAnalyticFuncEvaluate(mu1,pIn,pOut,lambda,tsi,A1,A2,C1,C2,err,error)
    !Argument variables
    REAL(DP) :: FiniteElasticity_CylinderAnalyticFuncEvaluate
    REAL(DP) :: mu1,pIn,pOut,lambda,tsi,A1,A2,C1,C2
    INTEGER(INTG) :: err
    TYPE(VARYING_STRING) :: error
    !Local variables
    REAL(DP) :: mu,K

    ENTERS("FiniteElasticity_CylinderAnalyticFuncEvaluate",err,error,*999)

    K=A1**2*(lambda*mu1**2-1.0_DP)
    mu=SQRT(1.0_DP/lambda*(1.0_DP+K/A2**2))

    FiniteElasticity_CylinderAnalyticFuncEvaluate= &
      &  2.0_DP*(C1/lambda**2/mu**2 + C2*(1.0_DP/lambda**2+1.0_DP/mu**2+tsi**2*A2**2))+ &
      & pOut-(C1/lambda+C2*lambda)*(1.0_DP/lambda/mu1**2-A2**2/(A2**2+K)+2*LOG(mu/mu1))+ &
      & C1*tsi**2*lambda*(A2**2-A1**2)-2.0_DP*(C1/lambda**2/mu**2+C2*(1.0_DP/lambda**2+ &
      & 1.0_DP/mu**2+tsi**2*A2**2))+pIn
  
    EXITS("FiniteElasticity_CylinderAnalyticFuncEvaluate")
    RETURN
999 ERRORS("FiniteElasticity_CylinderAnalyticFuncEvaluate",err,error)
    EXITS("FiniteElasticity_CylinderAnalyticFuncEvaluate")
    RETURN
    
  END FUNCTION FiniteElasticity_CylinderAnalyticFuncEvaluate

  !
  !================================================================================================================================
  !

  !>Evaluates the modified second material elasticity tensor.
  SUBROUTINE FiniteElasticity_MaterialElasticityTensorCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
    & F,J,Fbar,Cbar,Bbar,EbarV,SbarV,materialCbarV,err,error,*)
    
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    TYPE(FieldInterpolatedPointType), POINTER :: materialInterpolatedPoint !<A pointer to the materials parameters
    REAL(DP), INTENT(IN) :: F(:,:) !<The deformation gradient tensor
    REAL(DP), INTENT(IN) :: J !<The jacobian of deformation
    REAL(DP), INTENT(IN) :: Fbar(:,:) !<The modified deformation gradient tensor
    REAL(DP), INTENT(IN) :: Cbar(:,:) !<The modified right Cauchy-Green deformation tensor
    REAL(DP), INTENT(IN) :: Bbar(:,:) !<The modified Piola deformation tensor
    REAL(DP), INTENT(IN) :: EbarV(:) !<The modified Green-Lagrange strain tensor in Voigt form
    REAL(DP), INTENT(IN) :: SbarV(:) !<The second Piola-Kirchoff stress tensor in Voigt form
    REAL(DP), INTENT(OUT) :: materialCbarV(:,:) !<On return, the modified second material elasticity tensor in Voigt form
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: columnIdx,esSpecification(3),rowIdx
    REAL(DP) :: dQdEbarV(6),I1bar,I3bar,tempTerm1,tempTerm2,materialsB(6)
    REAL(DP), POINTER :: materialParameters(:)
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_MaterialElasticityTensorCalculate",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)

    materialParameters=>materialInterpolatedPoint%values(:,NO_PART_DERIV)

    materialCBarV=0.0_DP

    SELECT CASE(numberOfDimensions)
    CASE(1)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(2)
      SELECT CASE(esSpecification(3))
      CASE(EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
        & EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
        !Form of constitutive model is:
        ! Wbar=c1*(I1bar-2)+c2*(I2bar-2) where I1bar and I2bar are the first and second invariants of Cbar
        
        materialCbarV(1,2)=4.0_DP*materialParameters(2)
        materialCbarV(2,1)=4.0_DP*materialParameters(2)
        materialCbarV(3,3)=-4.0_DP*materialParameters(2)
        
      CASE(EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE, &
        & EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
        !Form of constitutive model is:
        ! Wbar = lambda/2.[tr(Ebar)]^2 + mu.tr(Ebar^2)
        
        materialCbarV(1,1)=materialParameters(1)+2.0_DP*materialParameters(2)      
        materialCbarV(1,2)=materialParameters(1)
        materialCbarV(2,1)=materialParameters(1)
        materialCbarV(2,2)=materialParameters(1)+2.0_DP*materialParameters(2)
        materialCbarV(3,3)=materialParameters(2)
            
       
      CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE, &
        & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
        !Form of constitutive model is:
        ! Wbar = lambda/2.[tr(Ebar)]^2 + mu.tr(Ebar^2)
        
        materialCbarV(1,1)=materialParameters(2)+2.0_DP*materialParameters(3)      
        materialCbarV(1,2)=materialParameters(2)
        materialCbarV(2,1)=materialParameters(2)
        materialCbarV(2,2)=materialParameters(2)+2.0_DP*materialParameters(3)
        materialCbarV(3,3)=materialParameters(3)
            
      CASE(EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE)
        !Form of constitutive model is:
        ! Wbar=c1*(I1bar-2)+c2*(I2bar-2) where I1bar and I2bar are the first and second invariants of Cbar
        
        materialCbarV(1,2)=4.0_DP*materialParameters(3)
        materialCbarV(2,1)=4.0_DP*materialParameters(3)
        materialCbarV(3,3)=-4.0_DP*materialParameters(3)
        
      CASE DEFAULT
        localError="The equation set third specification of "//TRIM(NumberToVString(esSpecification(3),"*",err,error))// &
          & " is invalid or not implemented."
        CALL FlagError(localError,err,error,*999)
      END SELECT
      
    CASE(3)
    
      !Form modified second material elasticity tensor, Cbar
      
      SELECT CASE(esSpecification(3))
      CASE(EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
        & EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
        !Form of constitutive model is:
        ! Wbar=c1*(I1bar-3)+c2*(I2bar-3) where I1bar and I2bar are the first and second invariants of Cbar
        
        materialCbarV(1,2)=4.0_DP*materialParameters(2)
        materialCbarV(1,3)=4.0_DP*materialParameters(2)
        materialCbarV(2,1)=4.0_DP*materialParameters(2)
        materialCbarV(2,3)=4.0_DP*materialParameters(2)
        materialCbarV(3,1)=4.0_DP*materialParameters(2)
        materialCbarV(3,2)=4.0_DP*materialParameters(2)
        materialCbarV(4,4)=-4.0_DP*materialParameters(2)
        materialCbarV(5,5)=-4.0_DP*materialParameters(2)
        materialCbarV(6,6)=-4.0_DP*materialParameters(2)
        
      CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE,EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, &
        & EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE)
        
        materialsB=[2.0_DP*materialParameters(2),2.0_DP*materialParameters(3),2.0_DP*materialParameters(3), &
          & materialParameters(4),materialParameters(4),materialParameters(3)] ![2*b_f,2*b_t,2*b_t,b_ft,b_ft,b_t]
        dQdEbarV=materialsB*EbarV
        tempTerm1=0.5_DP*materialParameters(1)*EXP(0.5_DP*DOT_PRODUCT(EbarV,dQdEbarV))
        
        !\todo blas has routines specifically for symmetric matrices, so it would be worth to check if these could give some
        ! speedup.
        
        ! Calculate material elasticity tensor Cbar (in Voigt form).
        ! First calculate lower part of 6X6 matrix
        DO columnIdx=1,6
          DO rowIdx=columnIdx,6
            materialCbarV(rowIdx,columnIdx)=tempTerm1*dQdEbarV(rowIdx)*dQdEbarV(columnIdx)
          ENDDO !rowIdx
        ENDDO !columnIdx
        DO rowIdx=1,6
          materialCbarV(rowIdx,rowIdx)=materialCbarV(rowIdx,rowIdx)+tempTerm1*materialsB(rowIdx)
        ENDDO !rowIdx
        ! Then calculate upper part.
        DO columnIdx=2,6
          DO rowIdx=1,columnIdx-1
            materialCbarV(rowIdx,columnIdx)=materialCbarV(columnIdx,rowIdx)
          ENDDO !rowIdx
        ENDDO !columnIdx
        
      CASE(EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE, &
        & EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
        !Form of constitutive model is:
        ! Wbar = lambda/2.[tr(Ebar)]^2 + mu.tr(Ebar^2)
        
        materialCbarV(1,1)=materialParameters(1)+2.0_DP*materialParameters(2)      
        materialCbarV(1,2)=materialParameters(1)
        materialCbarV(1,3)=materialParameters(1)
        materialCbarV(2,1)=materialParameters(1)
        materialCbarV(2,2)=materialParameters(1)+2.0_DP*materialParameters(2)
        materialCbarV(2,3)=materialParameters(1)
        materialCbarV(3,1)=materialParameters(1)
        materialCbarV(3,2)=materialParameters(1)
        materialCbarV(3,3)=materialParameters(1)+2.0_DP*materialParameters(2)
        materialCbarV(4,4)=materialParameters(2)
        materialCbarV(5,5)=materialParameters(2)
        materialCbarV(6,6)=materialParameters(2)
            
      CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE, &
        & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
        !Form of constitutive model is:
        ! Wbar = lambda/2.[tr(Ebar)]^2 + mu.tr(Ebar^2)
        
        materialCbarV(1,1)=materialParameters(2)+2.0_DP*materialParameters(3)      
        materialCbarV(1,2)=materialParameters(2)
        materialCbarV(1,3)=materialParameters(2)
        materialCbarV(2,1)=materialParameters(2)
        materialCbarV(2,2)=materialParameters(2)+2.0_DP*materialParameters(3)
        materialCbarV(2,3)=materialParameters(2)
        materialCbarV(3,1)=materialParameters(2)
        materialCbarV(3,2)=materialParameters(2)
        materialCbarV(3,3)=materialParameters(2)+2.0_DP*materialParameters(3)
        materialCbarV(4,4)=materialParameters(3)
        materialCbarV(5,5)=materialParameters(3)
        materialCbarV(6,6)=materialParameters(3)
            
      CASE(EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE)
        !Form of constitutive model is:
        ! Wbar=c1*(I1bar-3)+c2*(I2bar-3) where I1bar and I2bar are the first and second invariants of Cbar
        
        materialCbarV(1,2)=4.0_DP*materialParameters(3)
        materialCbarV(1,3)=4.0_DP*materialParameters(3)
        materialCbarV(2,1)=4.0_DP*materialParameters(3)
        materialCbarV(2,3)=4.0_DP*materialParameters(3)
        materialCbarV(3,1)=4.0_DP*materialParameters(3)
        materialCbarV(3,2)=4.0_DP*materialParameters(3)
        materialCbarV(4,4)=-4.0_DP*materialParameters(3)
        materialCbarV(5,5)=-4.0_DP*materialParameters(3)
        materialCbarV(6,6)=-4.0_DP*materialParameters(3)
        
      CASE DEFAULT
        localError="The equation set third specification of "//TRIM(NumberToVString(esSpecification(3),"*",err,error))// &
          & " is invalid or not implemented."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE DEFAULT
      localError="The number of dimensions of "//TRIM(NumberToVstring(numberOfDimensions,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Modified material elasticity tensor:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Jacobian = ",J,err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),1,1, &
        & NUMBER_OF_VOIGT(numberOfDimensions),8,8,materialCBarV(1:NUMBER_OF_VOIGT(numberOfDimensions), &
        & 1:NUMBER_OF_VOIGT(numberOfDimensions)),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("  CbarV','(",I1,",:)',':",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)
    ENDIF

    EXITS("FiniteElasticity_MaterialElasticityTensorCalculate")
    RETURN
999 ERRORS("FiniteElasticity_MaterialElasticityTensorCalculate",err,error)
    EXITS("FiniteElasticity_MaterialElasticityTensorCalculate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_MaterialElasticityTensorCalculate
  
  !
  !================================================================================================================================
  !

  !>Evaluates the material deformation tensors.
  SUBROUTINE FiniteElasticity_MaterialDeformationTensorsCalculate(equationsSet,numberOfDimensions,F,J,haveHydrostaticPressure, &
    & Fbar,C,Cbar,B,Bbar,EV,EbarV,err,error,*)
    
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    REAL(DP), INTENT(IN) :: F(:,:) !<The deformation gradient tensor7
    REAL(DP), INTENT(IN) :: J !<The jacobian of deformation
    LOGICAL, INTENT(IN) :: haveHydrostaticPressure !<.TRUE. if hydrostatic pressure is used, .FALSE. if not. 
    REAL(DP), INTENT(OUT) :: FBar(:,:) !<On return, the modified deformation gradient tensor
    REAL(DP), INTENT(OUT) :: C(:,:) !<On return, the right Cauchy-Green deformation tensor
    REAL(DP), INTENT(OUT) :: CBar(:,:) !<On return, the modified right Cauchy-Green deformation tensor
    REAL(DP), INTENT(OUT) :: B(:,:) !<On return, the Piola deformation tensor
    REAL(DP), INTENT(OUT) :: BBar(:,:) !<On return, the modified Piola deformation tensor
    REAL(DP), INTENT(OUT) :: EV(:) !<On return, the Green-Lagrange strain tensor in Voigt form
    REAL(DP), INTENT(OUT) :: EbarV(:) !<On return, the modified Green-Lagrange strain tensor in Voigt form
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    REAL(DP) :: FBarT(3,3),FT(3,3),I3,I3Bar
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_MaterialDeformationTensorsCalculate",err,error,*999)

    !Form modified deformation gradient, Fbar
    IF(haveHydrostaticPressure) THEN
      FBar(1:numberOfDimensions,1:numberOfDimensions)=J**(-1.0_DP/REAL(numberOfDimensions,DP))* &
        & F(1:numberOfDimensions,1:numberOfDimensions)
    ELSE
      FBar(1:numberOfDimensions,1:numberOfDimensions)=F(1:numberOfDimensions,1:numberOfDimensions)
    ENDIF

    !Evaluate the modified right Cauchy-Green strain tensor Cbar.
    CALL MatrixTranspose(FBar(1:numberOfDimensions,1:numberOfDimensions),FBarT(1:numberOfDimensions,1:numberOfDimensions), &
      & err,error,*999)
    CALL MatrixProduct(FBarT(1:numberOfDimensions,1:numberOfDimensions),FBar(1:numberOfDimensions,1:numberOfDimensions), &
      & CBar(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)

    !!TODO : do we really need Bbar?
    !Evaluate the modified Piola deformation tensor Bbar.
    CALL Invert(CBar(1:numberOfDimensions,1:numberOfDimensions),BBar(1:numberOfDimensions,1:numberOfDimensions),I3Bar, &
      & err,error,*999)

    IF(haveHydrostaticPressure) THEN
      !Evaluate the right Cauchy-Green strain tensor Cbar.
      CALL MatrixTranspose(F(1:numberOfDimensions,1:numberOfDimensions),FT(1:numberOfDimensions,1:numberOfDimensions), &
        & err,error,*999)
      CALL MatrixProduct(FT(1:numberOfDimensions,1:numberOfDimensions),F(1:numberOfDimensions,1:numberOfDimensions), &
        & C(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
      !Evaluate the Piola deformation tensor Bbar.
      CALL Invert(C(1:numberOfDimensions,1:numberOfDimensions),B(1:numberOfDimensions,1:numberOfDimensions),I3, &
        & err,error,*999)
    ELSE
      C(1:numberOfDimensions,1:numberOfDimensions)=CBar(1:numberOfDimensions,1:numberOfDimensions)
      B(1:numberOfDimensions,1:numberOfDimensions)=BBar(1:numberOfDimensions,1:numberOfDimensions)
    ENDIF
    
    SELECT CASE(numberOfDimensions)
    CASE(1)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(2)      
      !Evaluate modified Green-Lagrange strain tensor
      EBarV(TENSOR_TO_VOIGT2(1,1))=0.5_DP*(CBar(1,1)-1.0_DP)
      EBarV(TENSOR_TO_VOIGT2(2,2))=0.5_DP*(CBar(2,2)-1.0_DP)
      EBarV(TENSOR_TO_VOIGT2(1,2))=0.5_DP*CBar(1,2)
      !Evaluate Green-Lagrange strain tensor
      IF(haveHydrostaticPressure) THEN
        EV(TENSOR_TO_VOIGT2(1,1))=0.5_DP*(C(1,1)-1.0_DP)
        EV(TENSOR_TO_VOIGT2(2,2))=0.5_DP*(C(2,2)-1.0_DP)
        EV(TENSOR_TO_VOIGT2(1,2))=0.5_DP*C(1,2)
      ELSE
        EV(1:NUMBER_OF_VOIGT(2))=EBarV(1:NUMBER_OF_VOIGT(2))
      ENDIF
    CASE(3)
      !Evaluate modified Green-Lagrange strain tensor
      EBarV(TENSOR_TO_VOIGT3(1,1))=0.5_DP*(CBar(1,1)-1.0_DP)
      EBarV(TENSOR_TO_VOIGT3(2,2))=0.5_DP*(CBar(2,2)-1.0_DP)
      EBarV(TENSOR_TO_VOIGT3(3,3))=0.5_DP*(CBar(3,3)-1.0_DP)   
      EBarV(TENSOR_TO_VOIGT3(1,2))=0.5_DP*CBar(1,2)
      EBarV(TENSOR_TO_VOIGT3(1,3))=0.5_DP*CBar(1,3)
      EBarV(TENSOR_TO_VOIGT3(2,3))=0.5_DP*CBar(2,3)
      !Evaluate Green-Lagrange strain tensor
      IF(haveHydrostaticPressure) THEN
        EV(TENSOR_TO_VOIGT3(1,1))=0.5_DP*(C(1,1)-1.0_DP)
        EV(TENSOR_TO_VOIGT3(2,2))=0.5_DP*(C(2,2)-1.0_DP)
        EV(TENSOR_TO_VOIGT3(3,3))=0.5_DP*(C(3,3)-1.0_DP)   
        EV(TENSOR_TO_VOIGT3(1,2))=0.5_DP*C(1,2)
        EV(TENSOR_TO_VOIGT3(1,3))=0.5_DP*C(1,3)
        EV(TENSOR_TO_VOIGT3(2,3))=0.5_DP*C(2,3)
      ELSE
        EV(1:NUMBER_OF_VOIGT(3))=EBarV(1:NUMBER_OF_VOIGT(3))
      ENDIF
    CASE DEFAULT
      localError="The number of dimensions of "//TRIM(NumberToVstring(numberOfDimensions,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Material Deformation:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Jacobian = ",J,err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,8,8, &
        & F(1:numberOfDimensions,1:numberOfDimensions),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("     F','(",I1,",:)',' :",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)    
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Modified material tensors:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,8,8, &
        & Fbar(1:numberOfDimensions,1:numberOfDimensions),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("  FBar','(",I1,",:)',' :",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)    
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,8,8, &
        & C(1:numberOfDimensions,1:numberOfDimensions),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("     C','(",I1,",:)',' :",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)    
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,8,8, &
        & Cbar(1:numberOfDimensions,1:numberOfDimensions),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("  CBar','(",I1,",:)',' :",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)    
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,8,8, &
        & B(1:numberOfDimensions,1:numberOfDimensions),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("     B','(",I1,",:)',' :",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)    
       CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,8,8, &
        & Bbar(1:numberOfDimensions,1:numberOfDimensions),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("  BBar','(",I1,",:)',' :",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)    
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),8,8, &
        & EV(1:NUMBER_OF_VOIGT(numberOfDimensions)),'("  EV        :",8(X,E13.6))','(13X,8(X,E13.6))', &
        & err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),8,8, &
        & EbarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),'("  EBarV     :",8(X,E13.6))','(13X,8(X,E13.6))', &
        & err,error,*999)
    ENDIF

    EXITS("FiniteElasticity_MaterialDeformationTensorsCalculate")
    RETURN
999 ERRORS("FiniteElasticity_MaterialDeformationTensorsCalculate",err,error)
    EXITS("FiniteElasticity_MaterialDeformationTensorsCalculate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_MaterialDeformationTensorsCalculate
  
  !
  !================================================================================================================================
  !

  !>Evaluates the deviatoric material stress tensors.
  SUBROUTINE FiniteElasticity_MaterialStressDevTensorsCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
    & F,J,haveHydrostaticPressure,FBar,C,CBar,B,BBar,EV,EBarV,SBarV,SDevV,err,error,*)
    
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    TYPE(FieldInterpolatedPointType), POINTER :: materialInterpolatedPoint !<A pointer to the materials parameters
    REAL(DP), INTENT(IN) :: F(:,:) !<The deformation gradient tensor
    REAL(DP), INTENT(IN) :: J !<The jacobian of deformation
    LOGICAL, INTENT(IN) :: haveHydrostaticPressure !<.TRUE. if hydrostatic pressure is used, .FALSE. if not. 
    REAL(DP), INTENT(OUT) :: FBar(:,:) !<On return, the modified deformation gradient tensor
    REAL(DP), INTENT(OUT) :: C(:,:) !<On return, the right Cauchy-Green deformation tensor
    REAL(DP), INTENT(OUT) :: CBar(:,:) !<On return, the modified right Cauchy-Green deformation tensor
    REAL(DP), INTENT(OUT) :: B(:,:) !<On return, the Piola deformation tensor
    REAL(DP), INTENT(OUT) :: BBar(:,:) !<On return, the modified Piola deformation tensor
    REAL(DP), INTENT(OUT) :: EV(:) !<On return, the Green-Lagrange strain tensor
    REAL(DP), INTENT(OUT) :: EBarV(:) !<On return, the modified Green-Lagrange strain tensor
    REAL(DP), INTENT(OUT) :: SBarV(:) !<On return, the modified (pseudo) second Piola-Kirchoff stress tensor in Voigt form
    REAL(DP), INTENT(OUT) :: SDevV(:) !<On return, the deviatoric second Piola-Kirchoff stress tensor in Voigt form
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: esSpecification(3)
    REAL(DP) :: FBarT(3,3),I1Bar,I3Bar,tempTerm1,tempTerm2
    REAL(DP), POINTER :: materialParameters(:)
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_MaterialStressDevTensorsCalculate",err,error,*999)

    !>Evaluates the material deformation tensors.
    CALL FiniteElasticity_MaterialDeformationTensorsCalculate(equationsSet,numberOfDimensions,F,J,haveHydrostaticPressure, &
      & FBar(1:numberOfDimensions,1:numberOfDimensions),C(1:numberOfDimensions,1:numberOfDimensions), &
      & CBar(1:numberOfDimensions,1:numberOfDimensions),B(1:numberOfDimensions,1:numberOfDimensions), &
      & BBar(1:numberOfDimensions,1:numberOfDimensions),EV(1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & EBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)
      
    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)
    
    SBarV=0.0_DP
    SDevV=0.0_DP
    
    materialParameters=>materialInterpolatedPoint%values(:,NO_PART_DERIV)

    SELECT CASE(numberOfDimensions)
    CASE(1)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(2)
            
      !Form modified (psuedo) second Piola-Kirchoff stress tensor, SBar
      
      SELECT CASE(esSpecification(3))
      CASE(EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
        & EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
        !Form of constitutive model is:
        ! WBar=c1*(I1Bar-2)+c2*(I2Bar-2) where I1Bar and I2Bar are the first and second invariants of CBar

        I1Bar=CBar(1,1)+CBar(2,2)
        tempTerm1=-2.0_DP*materialParameters(2)
        tempTerm2=2.0_DP*(materialParameters(1)+I1Bar*materialParameters(2))
        SBarV(TENSOR_TO_VOIGT2(1,1))=tempTerm1*CBar(1,1)+tempTerm2
        SBarV(TENSOR_TO_VOIGT2(2,2))=tempTerm1*CBar(2,2)+tempTerm2
        SBarV(TENSOR_TO_VOIGT2(1,2))=tempTerm1*CBar(1,2)
        
       CASE(EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE, &
         & EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
        !Form of constitutive model is:
        ! WBar = lambda/2.[tr(EBar)]^2 + mu.tr(EBar^2)
        ! SBar = lambda.tr(EBar).I + 2.mu.EBar
        
        I1Bar=EBarV(TENSOR_TO_VOIGT2(1,1))+EBarV(TENSOR_TO_VOIGT2(2,2))
        tempTerm1=materialParameters(1)*I1Bar
        tempTerm2=2.0_DP*materialParameters(2)
        SBarV(TENSOR_TO_VOIGT2(1,1))=tempTerm1+tempTerm2*EBarV(TENSOR_TO_VOIGT2(1,1))      
        SBarV(TENSOR_TO_VOIGT2(2,2))=tempTerm1+tempTerm2*EBarV(TENSOR_TO_VOIGT2(2,2))
        SBarV(TENSOR_TO_VOIGT2(1,2))=tempTerm2*EBarV(TENSOR_TO_VOIGT2(1,2))
               
      CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE, &
        & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
        !Form of constitutive model is:
        ! WBar = lambda/2.[tr(EBar)]^2 + mu.tr(EBar^2)
        ! SBar = lambda.tr(EBar).I + 2.mu.EBar
        
        I1Bar=EBarV(TENSOR_TO_VOIGT2(1,1))+EBarV(TENSOR_TO_VOIGT2(2,2))
        tempTerm1=materialParameters(2)*I1Bar
        tempTerm2=2.0_DP*materialParameters(3)
        SBarV(TENSOR_TO_VOIGT2(1,1))=tempTerm1+tempTerm2*EBarV(TENSOR_TO_VOIGT2(1,1))      
        SBarV(TENSOR_TO_VOIGT2(2,2))=tempTerm1+tempTerm2*EBarV(TENSOR_TO_VOIGT2(2,2))
        SBarV(TENSOR_TO_VOIGT2(1,2))=tempTerm2*EBarV(TENSOR_TO_VOIGT2(1,2))
      
      CASE(EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE)
        !Form of constitutive model is:
        ! WBar=c1*(I1Bar-3)+c2*(I2Bar-3) where I1Bar and I2Bar are the first and second invariants of CBar
        
        I1Bar=CBar(1,1)+CBar(2,2)
        tempTerm1=-2.0_DP*materialParameters(3)
        tempTerm2=2.0_DP*(materialParameters(2)+I1Bar*materialParameters(3))
        SBarV(TENSOR_TO_VOIGT2(1,1))=tempTerm1*CBar(1,1)+tempTerm2
        SBarV(TENSOR_TO_VOIGT2(2,2))=tempTerm1*CBar(2,2)+tempTerm2
        SBarV(TENSOR_TO_VOIGT2(1,2))=tempTerm1*CBar(1,2)
        
      CASE DEFAULT
        localError="The equation set third specification of "//TRIM(NumberToVString(esSpecification(3),"*",err,error))// &
          & " is invalid or not implemented."
        CALL FlagError(localError,err,error,*999)
      END SELECT
      
    CASE(3)

      !Form modified (psuedo) second Piola-Kirchoff stress tensor, SBar
      
      SELECT CASE(esSpecification(3))
      CASE(EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
        & EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
        !Form of constitutive model is:
        ! WBar=c1*(I1Bar-3)+c2*(I2Bar-3) where I1Bar and I2Bar are the first and second invariants of CBar

        I1Bar=CBar(1,1)+CBar(2,2)+CBar(3,3)
        tempTerm1=-2.0_DP*materialParameters(2)
        tempTerm2=2.0_DP*(materialParameters(1)+I1Bar*materialParameters(2))
        SBarV(TENSOR_TO_VOIGT3(1,1))=tempTerm1*CBar(1,1)+tempTerm2
        SBarV(TENSOR_TO_VOIGT3(2,2))=tempTerm1*CBar(2,2)+tempTerm2
        SBarV(TENSOR_TO_VOIGT3(3,3))=tempTerm1*CBar(3,3)+tempTerm2
        SBarV(TENSOR_TO_VOIGT3(1,2))=tempTerm1*CBar(1,2)
        SBarV(TENSOR_TO_VOIGT3(1,3))=tempTerm1*CBar(1,3)
        SBarV(TENSOR_TO_VOIGT3(2,3))=tempTerm1*CBar(2,3)        
        
      CASE(EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE, &
        & EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
        !Form of constitutive model is:
        ! WBar = lambda/2.[tr(EBar)]^2 + mu.tr(EBar^2)
        ! SBar = lambda.tr(EBar).I + 2.mu.EBar
        
        I1Bar=EBarV(TENSOR_TO_VOIGT3(1,1))+EBarV(TENSOR_TO_VOIGT3(2,2))+EBarV(TENSOR_TO_VOIGT3(3,3))
        tempTerm1=materialParameters(1)*I1Bar
        tempTerm2=2.0_DP*materialParameters(2)
        SBarV(TENSOR_TO_VOIGT3(1,1))=tempTerm1+tempTerm2*EBarV(TENSOR_TO_VOIGT3(1,1))      
        SBarV(TENSOR_TO_VOIGT3(2,2))=tempTerm1+tempTerm2*EBarV(TENSOR_TO_VOIGT3(2,2))
        SBarV(TENSOR_TO_VOIGT3(3,3))=tempTerm1+tempTerm2*EBarV(TENSOR_TO_VOIGT3(3,3))
        SBarV(TENSOR_TO_VOIGT3(1,2))=tempTerm2*EBarV(TENSOR_TO_VOIGT3(1,2))
        SBarV(TENSOR_TO_VOIGT3(1,3))=tempTerm2*EBarV(TENSOR_TO_VOIGT3(1,3))
        SBarV(TENSOR_TO_VOIGT3(2,3))=tempTerm2*EBarV(TENSOR_TO_VOIGT3(2,3))
       
      CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE, &
        & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
        !Form of constitutive model is:
        ! WBar = lambda/2.[tr(EBar)]^2 + mu.tr(EBar^2)
        ! SBar = lambda.tr(EBar).I + 2.mu.EBar
        
        I1Bar=EBarV(TENSOR_TO_VOIGT3(1,1))+EBarV(TENSOR_TO_VOIGT3(2,2))+EBarV(TENSOR_TO_VOIGT3(3,3))
        tempTerm1=materialParameters(2)*I1Bar
        tempTerm2=2.0_DP*materialParameters(3)
        SBarV(TENSOR_TO_VOIGT3(1,1))=tempTerm1+tempTerm2*EBarV(TENSOR_TO_VOIGT3(1,1))      
        SBarV(TENSOR_TO_VOIGT3(2,2))=tempTerm1+tempTerm2*EBarV(TENSOR_TO_VOIGT3(2,2))
        SBarV(TENSOR_TO_VOIGT3(3,3))=tempTerm1+tempTerm2*EBarV(TENSOR_TO_VOIGT3(3,3))
        SBarV(TENSOR_TO_VOIGT3(1,2))=tempTerm2*EBarV(TENSOR_TO_VOIGT3(1,2))
        SBarV(TENSOR_TO_VOIGT3(1,3))=tempTerm2*EBarV(TENSOR_TO_VOIGT3(1,3))
        SBarV(TENSOR_TO_VOIGT3(2,3))=tempTerm2*EBarV(TENSOR_TO_VOIGT3(2,3))
      
      CASE(EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE)
        !Form of constitutive model is:
        ! WBar=c1*(I1Bar-3)+c2*(I2Bar-3) where I1Bar and I2Bar are the first and second invariants of CBar
        
        I1Bar=CBar(1,1)+CBar(2,2)+CBar(3,3)
        tempTerm1=-2.0_DP*materialParameters(3)
        tempTerm2=2.0_DP*(materialParameters(2)+I1Bar*materialParameters(3))
        SBarV(TENSOR_TO_VOIGT3(1,1))=tempTerm1*CBar(1,1)+tempTerm2
        SBarV(TENSOR_TO_VOIGT3(2,2))=tempTerm1*CBar(2,2)+tempTerm2
        SBarV(TENSOR_TO_VOIGT3(3,3))=tempTerm1*CBar(3,3)+tempTerm2
        SBarV(TENSOR_TO_VOIGT3(1,2))=tempTerm1*CBar(1,2)
        SBarV(TENSOR_TO_VOIGT3(1,3))=tempTerm1*CBar(1,3)
        SBarV(TENSOR_TO_VOIGT3(2,3))=tempTerm1*CBar(2,3)
        
      CASE DEFAULT
        localError="The equation set third specification of "//TRIM(NumberToVString(esSpecification(3),"*",err,error))// &
          & " is invalid or not implemented."
        CALL FlagError(localError,err,error,*999)
      END SELECT
      
    CASE DEFAULT
      localError="The number of dimensions of "//TRIM(NumberToVstring(numberOfDimensions,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Material stress tensors:",err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),8,8, &
        & SBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),'("      SBarV :",8(X,E13.6))','(13X,8(X,E13.6))', &
        & err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),8,8, &
        & SDevV(1:NUMBER_OF_VOIGT(numberOfDimensions)),'("      SDevV :",8(X,E13.6))','(13X,8(X,E13.6))', &
        & err,error,*999)
    ENDIF

    EXITS("FiniteElasticity_MaterialStressDevTensorsCalculate")
    RETURN
999 ERRORSEXITS("FiniteElasticity_MaterialStressDevTensorsCalculate",err,error)
    RETURN 1

  END SUBROUTINE FiniteElasticity_MaterialStressDevTensorsCalculate
  
  !
  !================================================================================================================================
  !

  !>Evaluates the material stress spherical tensors.
  SUBROUTINE FiniteElasticity_MaterialStressSphTensorsCalculate(equationsSet,numberOfDimensions,J,p,haveHydrostaticPressure,&
    & FBar,C,CBar,B,BBar,EV,EBarV,SSphV,err,error,*)
    
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    REAL(DP), INTENT(IN) :: J !<The Jacobian of the deformation
    REAL(DP), INTENT(IN) :: p !<The value of hydrostatic pressure
    LOGICAL, INTENT(IN) :: haveHydrostaticPressure !<.TRUE. if hydrostatic pressure is used, .FALSE. if not. 
    REAL(DP), INTENT(IN) :: FBar(:,:) !The modified deformation gradient tensor
    REAL(DP), INTENT(IN) :: C(:,:) !<The right Cauchy-Green deformation tensor
    REAL(DP), INTENT(IN) :: CBar(:,:) !<The modified right Cauchy-Green deformation tensor
    REAL(DP), INTENT(IN) :: B(:,:) !The Piola deformation tensor
    REAL(DP), INTENT(IN) :: BBar(:,:) !The modified Piola deformation tensor
    REAL(DP), INTENT(IN) :: EV(:) !<The Green-Lagrange strain tensor in Voigt form
    REAL(DP), INTENT(IN) :: EBarV(:) !<The modified Green-Lagrange strain tensor in Voigt form
    REAL(DP), INTENT(OUT) :: SSphV(:) !<On return, the spherical second Piola-Kirchoff stress tensor in Voigt form
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_MaterialStressSphTensorsCalculate",err,error,*999)

    !Calculate the spherical part of the 2PK stress tensor
    IF(haveHydrostaticPressure) THEN
      SELECT CASE(numberOfDimensions)
      CASE(1)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(2)
        SSphV(TENSOR_TO_VOIGT2(1,1))=-p*J*B(1,1)
        SSphV(TENSOR_TO_VOIGT2(2,2))=-p*J*B(2,2)
        SSphV(TENSOR_TO_VOIGT2(1,2))=-p*J*B(1,2)
      CASE(3)
        SSphV(TENSOR_TO_VOIGT3(1,1))=-p*J*B(1,1)
        SSphV(TENSOR_TO_VOIGT3(2,2))=-p*J*B(2,2)
        SSphV(TENSOR_TO_VOIGT3(3,3))=-p*J*B(3,3)
        SSphV(TENSOR_TO_VOIGT3(1,2))=-p*J*B(1,2)
        SSphV(TENSOR_TO_VOIGT3(1,3))=-p*J*B(1,3)
        SSphV(TENSOR_TO_VOIGT3(2,3))=-p*J*B(2,3)
      CASE DEFAULT
        localError="The number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      SSphV(1:NUMBER_OF_VOIGT(numberOfDimensions))=0.0_DP
    ENDIF
   
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Material pressure tensor:",err,error,*999)
      IF(haveHydrostaticPressure) CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          p = ",p,err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),8,8, &
        & SSphV(1:NUMBER_OF_VOIGT(numberOfDimensions)),'("      SSphV :",8(X,E13.6))','(13X,8(X,E13.6))', &
        & err,error,*999)
    ENDIF
    
    EXITS("FiniteElasticity_MaterialStressSphTensorsCalculate")    
    RETURN
999 ERRORS("FiniteElasticity_MaterialStressSphTensorsCalculate",err,error)
    EXITS("FiniteElasticity_MaterialStressSphTensorsCalculate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_MaterialStressSphTensorsCalculate
  
  !
  !================================================================================================================================
  !

  !>Evaluates the modified (psuedo) second Piola-Kirchoff stress tensor.
  SUBROUTINE FiniteElasticity_MaterialStressTensorsCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
    & F,J,p,haveHydrostaticPressure,SV,err,error,*)
    
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    TYPE(FieldInterpolatedPointType), POINTER :: materialInterpolatedPoint !<A pointer to the materials parameters
    REAL(DP), INTENT(IN) :: F(:,:) !<The deformation gradient tensor
    REAL(DP), INTENT(IN) :: J !<The jacobian of deformation
    REAL(DP), INTENT(IN) :: p !<The hydrostatic pressure
    LOGICAL, INTENT(IN) :: haveHydrostaticPressure !<.TRUE. if hydrostatic pressure is used, .FALSE. if not. 
    REAL(DP), INTENT(OUT) :: SV(:) !<On return, the second Piola-Kirchoff stress tensor in Voigt form
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    REAL(DP) :: B(3,3),BBar(3,3),C(3,3),CBar(3,3),EV(6),EBarV(6),FBar(3,3),FBarT(3,3),I1Bar,I3Bar,SBarV(6),SDevV(6),SSphV(6), &
      & tempTerm1,tempTerm2

    ENTERS("FiniteElasticity_MaterialStressTensorsCalculate",err,error,*999)

    !Calculate the deviatoric material stress tensors
    CALL FiniteElasticity_MaterialStressDevTensorsCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
      & F(1:numberOfDimensions,1:numberOfDimensions),J,haveHydrostaticPressure,FBar(1:numberOfDimensions,1:numberOfDimensions), &
      & C(1:numberOfDimensions,1:numberOfDimensions),CBar(1:numberOfDimensions,1:numberOfDimensions), &
      & B(1:numberOfDimensions,1:numberOfDimensions),BBar(1:numberOfDimensions,1:numberOfDimensions), &
      & EV(1:NUMBER_OF_VOIGT(numberOfDimensions)),EBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & SBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),SDevV(1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)
    
    !Calculate the spherical material stress tensors
    CALL FiniteElasticity_MaterialStressSphTensorsCalculate(equationsSet,numberOfDimensions,J,p, &
      & haveHydrostaticPressure,FBar(1:numberOfDimensions,1:numberOfDimensions), &
      & C(1:numberOfDimensions,1:numberOfDimensions),CBar(1:numberOfDimensions,1:numberOfDimensions), &
      & B(1:numberOfDimensions,1:numberOfDimensions),BBar(1:numberOfDimensions,1:numberOfDimensions), &
      & EV(1:NUMBER_OF_VOIGT(numberOfDimensions)),EBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & SSphV(1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)

    !Calculate the 2nd Piola Kirchoff stress tensor
    SV(1:NUMBER_OF_VOIGT(numberOfDimensions))=SDevV(1:NUMBER_OF_VOIGT(numberOfDimensions))+ &
      & SSphV(1:NUMBER_OF_VOIGT(numberOfDimensions))
    
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Matrial 2nd Piola-Kirchoff stress tensor:",err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),8,8, &
        & SV(1:NUMBER_OF_VOIGT(numberOfDimensions)),'("          SV :",8(X,E13.6))','(13X,8(X,E13.6))', &
        & err,error,*999)
    ENDIF

    EXITS("FiniteElasticity_MaterialStressTensorsCalculate")
    RETURN
999 ERRORSEXITS("FiniteElasticity_MaterialStressTensorsCalculate",err,error)
    RETURN 1

  END SUBROUTINE FiniteElasticity_MaterialStressTensorsCalculate
  
  !
  !================================================================================================================================
  !

  !>Evaluates the deviatoric Cauchy stress tensor.
  SUBROUTINE FiniteElasticity_SpatialStressDevTensorsCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
    & F,J,haveHydrostaticPressure,FBar,C,CBar,B,BBar,EV,EBarV,SBarV,SDevV,sigmaBarV,sigmaDevV,err,error,*)
    
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    TYPE(FieldInterpolatedPointType), POINTER :: materialInterpolatedPoint !<A pointer to the materials parameters
    REAL(DP), INTENT(IN) :: F(:,:) !<The deformation gradient tensor
    REAL(DP), INTENT(IN) :: J !<The jacobian of deformation
    LOGICAL, INTENT(IN) :: haveHydrostaticPressure !<.TRUE. if hydrostatic pressure is used, .FALSE. if not.
    REAL(DP), INTENT(OUT) :: FBar(:,:) !<On return, the modified deformation gradient tensor
    REAL(DP), INTENT(OUT) :: C(:,:) !<On return, the right Cauchy Green deformation tensor
    REAL(DP), INTENT(OUT) :: CBar(:,:) !<On return, the modified right Cauchy Green deformation tensor
    REAL(DP), INTENT(OUT) :: B(:,:) !<On return, the left Cauchy Green deformation tensor
    REAL(DP), INTENT(OUT) :: BBar(:,:) !<On return, the modified left Cauchy Green deformation tensor
    REAL(DP), INTENT(OUT) :: EV(:) !<On return, the Cauchy Green strain tensor in Voigt form.
    REAL(DP), INTENT(OUT) :: EBarV(:) !<On return, the modified Cauchy Green strain tensor in Voigt form.
    REAL(DP), INTENT(OUT) :: SBarV(:) !<On return, the modified (pseudo) second Piola-Kirchoff stress tensor in Voigt form.
    REAL(DP), INTENT(OUT) :: SDevV(:) !<On return, the deviatoric second Piola-Kirchoff stress tensor in Voigt form.
    REAL(DP), INTENT(OUT) :: sigmaBarV(:) !<On return, the modified (pseudo) Cauchy stress tensor in Voigt form
    REAL(DP), INTENT(OUT) :: sigmaDevV(:) !<On return, the deviatoric Cauchy stress tensor in Voight form
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    REAL(DP) :: traceSigmaBar

    ENTERS("FiniteElasticity_SpatialStressDevTensorsCalculate",err,error,*999)

    sigmaBarV=0.0_DP
    sigmaDevV=0.0_DP

    !Calculate the modified (pseudo) second Piola-Kirchoff stress tensor
    CALL FiniteElasticity_MaterialStressDevTensorsCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
      & F(1:numberOfDimensions,1:numberOfDimensions),J,haveHydrostaticPressure,FBar(1:numberOfDimensions,1:numberOfDimensions), &
      & C(1:numberOfDimensions,1:numberOfDimensions),CBar(1:numberOfDimensions,1:numberOfDimensions), &
      & B(1:numberOfDimensions,1:numberOfDimensions), BBar(1:numberOfDimensions,1:numberOfDimensions), &
      & EV(1:NUMBER_OF_VOIGT(numberOfDimensions)),EBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & SBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),SDevV(1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)

    !Push the modified (pseudo) second Piola-Kirchoff stress tensor forward to give the modified (pseudo) Cauchy stress tensor
    CALL FiniteElasticity_PushStressTensorForward(numberOfDimensions,FBar(1:numberOfDimensions,1:numberOfDimensions),J, &
      & SBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),sigmaBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)

    !Calculate the deviatoric Cauchy stress tensor
    IF(haveHydrostaticPressure) THEN
      traceSigmaBar=SUM(sigmaBarV(1:numberOfDimensions))
      sigmaDevV(1:numberOfDimensions)=-traceSigmaBar/REAL(numberOfDimensions,DP)
      sigmaDevV(1:NUMBER_OF_VOIGT(numberOfDimensions))=J**(-2.0_DP/REAL(numberOfDimensions,DP))* &
        & (sigmaDevV(1:NUMBER_OF_VOIGT(numberOfDimensions))+sigmaBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)))
    ELSE
      sigmaDevV(1:NUMBER_OF_VOIGT(numberOfDimensions))=sigmaBarV(1:NUMBER_OF_VOIGT(numberOfDimensions))
    ENDIF
     
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Spatial stress tensors:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  tr sigmaBar = ",traceSigmaBar,err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),8,8, &
        & sigmaBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),'("  sigmaBarV :",8(X,E13.6))','(13X,8(X,E13.6))', &
        & err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),8,8, &
        & sigmaDevV(1:NUMBER_OF_VOIGT(numberOfDimensions)),'("  sigmaDevV :",8(X,E13.6))','(13X,8(X,E13.6))', &
        & err,error,*999)
    ENDIF
    
    EXITS("FiniteElasticity_SpatialStressDevTensorsCalculate")    
    RETURN
999 ERRORS("FiniteElasticity_SpatialStressDevTensorsCalculate",err,error)
    EXITS("FiniteElasticity_SpatialStressDevTensorsCalculate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_SpatialStressDevTensorsCalculate
  
  !
  !================================================================================================================================
  !

  !>Evaluates the spherical Cauchy stress tensor.
  SUBROUTINE FiniteElasticity_SpatialStressSphTensorsCalculate(equationsSet,numberOfDimensions,J,p,haveHydrostaticPressure,&
    & sigmaSphV,err,error,*)
    
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    REAL(DP), INTENT(IN) :: J !<The Jacobian of the deformation
    REAL(DP), INTENT(IN) :: p !<The value of hydrostatic pressure
    LOGICAL, INTENT(IN) :: haveHydrostaticPressure !<.TRUE. if hydrostatic pressure is used, .FALSE. if not. 
    REAL(DP), INTENT(OUT) :: sigmaSphV(:) !<On return, the spherical Cauchy stress tensor in Voigt form
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FiniteElasticity_SpatialStressSphTensorsCalculate",err,error,*999)

    !Calculate the spherical part of the Cauchy stress tensor
    IF(haveHydrostaticPressure) THEN
      sigmaSphV(1:numberOfDimensions)=-p
      sigmaSphV(numberOfDimensions+1:NUMBER_OF_VOIGT(numberOfDimensions))=0.0_DP
    ELSE
      sigmaSphV(1:NUMBER_OF_VOIGT(numberOfDimensions))=0.0_DP
    ENDIF
   
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Spatial pressure tensor:",err,error,*999)
      IF(haveHydrostaticPressure) CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          p = ",p,err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),8,8, &
        & sigmaSphV(1:NUMBER_OF_VOIGT(numberOfDimensions)),'("  sigmaSphV :",8(X,E13.6))','(13X,8(X,E13.6))', &
        & err,error,*999)
    ENDIF
    
    EXITS("FiniteElasticity_SpatialStressSphTensorsCalculate")    
    RETURN
999 ERRORS("FiniteElasticity_SpatialStressSphTensorsCalculate",err,error)
    EXITS("FiniteElasticity_SpatialStressSphTensorsCalculate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_SpatialStressSphTensorsCalculate
  
  !
  !================================================================================================================================
  !

  !>Evaluates the Cauchy stress tensor.
  SUBROUTINE FiniteElasticity_SpatialStressTensorsCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
    & F,J,p,haveHydrostaticPressure,sigmaV,err,error,*)
    
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    TYPE(FieldInterpolatedPointType), POINTER :: materialInterpolatedPoint !<A pointer to the materials parameters
    REAL(DP), INTENT(IN) :: F(:,:) !<The deformation gradient tensor
    REAL(DP), INTENT(IN) :: J !<The jacobian of deformation
    REAL(DP), INTENT(IN) :: p !<The hydrostatic pressure
    LOGICAL, INTENT(IN) :: haveHydrostaticPressure !<.TRUE. if hydrostatic pressure is used, .FALSE. if not. 
    REAL(DP), INTENT(OUT) :: sigmaV(:) !<On return, the Cauchy stress tensor in Voight form
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    REAL(DP) :: B(3,3),BBar(3,3),C(3,3),CBar(3,3),EV(6),EBarV(6),FBar(3,3),SBarV(6),SDevV(6),sigmaBarV(6),sigmaDevV(6),sigmaSphV(6)

    ENTERS("FiniteElasticity_SpatialStressTensorsCalculate",err,error,*999)

    !Calculate the deviatoric Cauchy stress tensor    
    CALL FiniteElasticity_SpatialStressDevTensorsCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
      & F(1:numberOfDimensions,1:numberOfDimensions),J,haveHydrostaticPressure,FBar(1:numberOfDimensions,1:numberOfDimensions), &
      & C(1:numberOfDimensions,1:numberOfDimensions),CBar(1:numberOfDimensions,1:numberOfDimensions), &
      & B(1:numberOfDimensions,1:numberOfDimensions),BBar(1:numberOfDimensions,1:numberOfDimensions), &
      & EV(1:NUMBER_OF_VOIGT(numberOfDimensions)),EBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & SBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),SDevV(1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & sigmaBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),sigmaDevV(1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)
    
    !Calculate the spherical Cauchy stress tensor
    CALL FiniteElasticity_SpatialStressSphTensorsCalculate(equationsSet,numberOfDimensions,J,p, &
      & haveHydrostaticPressure,sigmaSphV(1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)

    !Calculate the Cauchy stress tensor
    sigmaV(1:NUMBER_OF_VOIGT(numberOfDimensions))=sigmaDevV(1:NUMBER_OF_VOIGT(numberOfDimensions))+ &
      & sigmaSphV(1:NUMBER_OF_VOIGT(numberOfDimensions))
    
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Cauchy stress tensor:",err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),8,8, &
        & sigmaV(1:NUMBER_OF_VOIGT(numberOfDimensions)),'("     sigmaV :",8(X,E13.6))','(13X,8(X,E13.6))', &
        & err,error,*999)
    ENDIF
    
    EXITS("FiniteElasticity_SpatialStressTensorsCalculate")    
    RETURN
999 ERRORS("FiniteElasticity_SpatialStressTensorsCalculate",err,error)
    EXITS("FiniteElasticity_SpatialStressTensorsCalculate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_SpatialStressTensorsCalculate
  
  !
  !================================================================================================================================
  !

  !>Push an elasticity tensor forward from material/reference to spatial/current coordinates
  SUBROUTINE FiniteElasticity_PushElasticityTensorForward(numberOfDimensions,F,J,materialElasticityTensorV, &
    & spatialElasticityTensorV,err,error,*)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    REAL(DP), INTENT(IN) :: F(:,:) !<The deformation gradient tensor
    REAL(DP), INTENT(IN) :: J !<The Jacobian of the deformation
    REAL(DP), INTENT(IN) :: materialElasticityTensorV(:,:) !<The elasticity tensor in material/reference coordinates in Voigt form to push forward
    REAL(DP), INTENT(OUT) :: spatialElasticityTensorV(:,:) !<On return, the elasticity tensor in spatial/current coordinates in Voigt form.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: columnIdx,rowIdx
    REAL(DP) :: temp(6,6),tempTranspose(6,6)
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_PushElasticityTensorForward",err,error,*999)

    DO columnIdx=1,numberOfDimensions
      DO rowIdx=1,NUMBER_OF_VOIGT(numberOfDimensions)
        temp(rowIdx,columnIdx)= &
          & F(VOIGT_TO_TENSOR(1,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(1,columnIdx,numberOfDimensions))* &
          & F(VOIGT_TO_TENSOR(2,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(2,columnIdx,numberOfDimensions))
      ENDDO !rowIdx
    ENDDO !columnIdx
    DO columnIdx=numberOfDimensions+1,NUMBER_OF_VOIGT(numberOfDimensions)
      DO rowIdx=1,NUMBER_OF_VOIGT(numberOfDimensions)
        temp(rowIdx,columnIdx)= &
          & F(VOIGT_TO_TENSOR(1,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(1,columnIdx,numberOfDimensions))* &
          & F(VOIGT_TO_TENSOR(2,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(2,columnIdx,numberOfDimensions))+ &
          & F(VOIGT_TO_TENSOR(1,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(2,columnIdx,numberOfDimensions))* &
          & F(VOIGT_TO_TENSOR(2,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(1,columnIdx,numberOfDimensions))
      ENDDO !rowIdx
    ENDDO !columnIdx

    CALL MatrixTranspose(temp(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & tempTranspose(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)
    
    spatialElasticityTensorV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions))= &
      & (1.0_DP/J)*MATMUL(MATMUL(temp(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & materialElasticityTensorV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions))), &
      & tempTranspose(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions)))
    
    EXITS("FiniteElasticity_PushElasticityTensorForward")    
    RETURN
999 ERRORS("FiniteElasticity_PushElasticityTensorForward",err,error)
    EXITS("FiniteElasticity_PushElasticityTensorForward")
    RETURN 1

  END SUBROUTINE FiniteElasticity_PushElasticityTensorForward
  
  !
  !================================================================================================================================
  !

  !>Push a stress tensor forward from material/reference to spatial/current coordinates
  SUBROUTINE FiniteElasticity_PushStressTensorForward(numberOfDimensions,F,J,materialStressTensorV,spatialStressTensorV, &
    & err,error,*)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    REAL(DP), INTENT(IN) :: F(:,:) !<The deformation gradient tensor
    REAL(DP), INTENT(IN) :: J !<The Jacobian of the deformation
    REAL(DP), INTENT(IN) :: materialStressTensorV(:) !<The stress tensor in material/reference coordinates in Voigt form to push forward
    REAL(DP), INTENT(OUT) :: spatialStressTensorV(:) !<On return, the stress tensor in spatial/current coordinates in Voigt form.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: columnIdx,rowIdx
    REAL(DP) :: temp(6,6)
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_PushStressTensorForward",err,error,*999)

    DO columnIdx=1,numberOfDimensions
      DO rowIdx=1,NUMBER_OF_VOIGT(numberOfDimensions)
        temp(rowIdx,columnIdx)= &
          & F(VOIGT_TO_TENSOR(1,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(1,columnIdx,numberOfDimensions))* &
          & F(VOIGT_TO_TENSOR(2,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(2,columnIdx,numberOfDimensions))
      ENDDO !rowIdx
    ENDDO !columnIdx
    DO columnIdx=numberOfDimensions+1,NUMBER_OF_VOIGT(numberOfDimensions)
      DO rowIdx=1,NUMBER_OF_VOIGT(numberOfDimensions)
        temp(rowIdx,columnIdx)= &
          & F(VOIGT_TO_TENSOR(1,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(1,columnIdx,numberOfDimensions))* &
          & F(VOIGT_TO_TENSOR(2,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(2,columnIdx,numberOfDimensions))+ &
          & F(VOIGT_TO_TENSOR(1,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(2,columnIdx,numberOfDimensions))* &
          & F(VOIGT_TO_TENSOR(2,rowIdx,numberOfDimensions),VOIGT_TO_TENSOR(1,columnIdx,numberOfDimensions))
      ENDDO !rowIdx
    ENDDO !columnIdx

    spatialStressTensorV(1:NUMBER_OF_VOIGT(numberOfDimensions))= &
      & MATMUL(temp(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & materialStressTensorV(1:NUMBER_OF_VOIGT(numberOfDimensions)))/J
    
    EXITS("FiniteElasticity_PushStressTensorForward")    
    RETURN
999 ERRORSEXITS("FiniteElasticity_PushStressTensorForward",err,error)
    RETURN 1

  END SUBROUTINE FiniteElasticity_PushStressTensorForward
  
  !
  !================================================================================================================================
  !

  !>Evaluates the spatial elasticity and stress tensor in Voigt form at a given Gauss point.
  SUBROUTINE FiniteElasticity_SpatialElasticityDevTensorCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
    & F,J,haveHydrostaticPressure,sigmaDevV,spatialCDevV,err,error,*)
    
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    TYPE(FieldInterpolatedPointType), POINTER :: materialInterpolatedPoint !<A pointer to the materials parameters
    REAL(DP), INTENT(IN) :: F(:,:) !<The deformation gradient tensor
    REAL(DP), INTENT(IN) :: J !<The jacobian of deformation
    LOGICAL, INTENT(IN) :: haveHydrostaticPressure !<.TRUE. if hydrostatic pressure is used, .FALSE. if not. 
    REAL(DP), INTENT(OUT) :: sigmaDevV(:) !<On return, the devaiatoric Cauchy stress tensor
    REAL(DP), INTENT(OUT) :: spatialCDevV(:,:) !<On return, the deviatoric part of the spatial elasticity tensor in Voigt form.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    REAL(DP) :: B(3,3),BBar(3,3),C(3,3),CBar(3,3),ce1V(6,6),ce2V(6,6),EV(6),EBarV(6),FBar(3,3),m(6,6),materialCBarV(6,6),SBarV(6), &
      & SDevV(6),sigmaBarV(6),spatialCBarV(6,6),traceSigmaBar
    REAL(DP), POINTER :: materialParameters(:) !Parameters for constitutive laws
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_SpatialElasticityDevTensorCalculate",err,error,*999)

    spatialCDevV=0.0_DP
    ce1V=0.0_DP
    ce2V=0.0_DP

    materialParameters=>materialInterpolatedPoint%values(:,NO_PART_DERIV)

    CALL FiniteElasticity_SpatialStressDevTensorsCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
      & F(1:numberOfDimensions,1:numberOfDimensions),J,haveHydrostaticPressure,FBar(1:numberOfDimensions,1:numberOfDimensions), &
      & C(1:numberOfDimensions,1:numberOfDimensions),CBar(1:numberOfDimensions,1:numberOfDimensions), &
      & B(1:numberOfDimensions,1:numberOfDimensions),BBar(1:numberOfDimensions,1:numberOfDimensions), &
      & EV(1:NUMBER_OF_VOIGT(numberOfDimensions)),EBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & SBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),SDevV(1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & sigmaBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),sigmaDevV(1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)

    traceSigmaBar=SUM(sigmaBarV(1:numberOfDimensions))

    CALL FiniteElasticity_MaterialElasticityTensorCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
      & F(1:numberOfDimensions,1:numberOfDimensions),J,FBar(1:numberOfDimensions,1:numberOfDimensions), &
      & CBar(1:numberOfDimensions,1:numberOfDimensions),BBar(1:numberOfDimensions,1:numberOfDimensions), &
      & EBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)),SBarV(1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & materialCBarV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)

    CALL FiniteElasticity_PushElasticityTensorForward(numberOfDimensions,FBar(1:numberOfDimensions,1:numberOfDimensions), &
      & J,materialCBarV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & spatialCBarV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)

    IF(haveHydrostaticPressure) THEN
      SELECT CASE(numberOfDimensions)
      CASE(1)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(2)
        
        ce1V(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(1,1))= &
          &  0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(1,1)) &
          & -0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(2,2)) &
          & -0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(1,1)) &
          & +0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(2,2))      
        ce1V(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(2,2))= &
          & -0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(1,1)) &
          & +0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(2,2)) &
          & +0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(1,1)) &
          & -0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(2,2))      
        ce1V(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(1,2))= &
          & +0.50_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(1,2)) &
          & -0.50_DP*spatialCBarV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(1,2))
        
        ce1V(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(1,1))= &
          & -0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(1,1)) &
          & +0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(2,2)) &
          & +0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(1,1)) &
          & -0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(2,2))      
        ce1V(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(2,2))= &
          &  0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(1,1)) &
          & -0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(2,2)) &
          & -0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(1,1)) &
          & +0.25_DP*spatialCBarV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(2,2))      
        ce1V(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(1,2))= &
          & -0.50_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(1,2)) &
          & +0.50_DP*spatialCBarV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(1,2))
        
        ce1V(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(1,1))= &
          &  0.50_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(1,1)) &
          & -0.50_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(2,2))
        ce1V(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(2,2))= &
          & -0.50_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(1,1)) &
          & +0.50_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(2,2))
        ce1V(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(1,2))= &
          & 0.50_DP*spatialCBarV(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(1,2)) 
        
        ce1V(1:NUMBER_OF_VOIGT(2),1:NUMBER_OF_VOIGT(2))=J**(-2.0_DP)*ce1V(1:NUMBER_OF_VOIGT(2),1:NUMBER_OF_VOIGT(2))
        
        ce2V(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(1,1))=-2.0_DP*sigmaBarV(TENSOR_TO_VOIGT2(1,1))+1.5_DP*traceSigmaBar
        ce2V(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(2,2))=-0.5_DP*traceSigmaBar
        ce2V(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(1,2))=-sigmaBarV(TENSOR_TO_VOIGT2(1,2))
        ce2V(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(1,1))=-0.5_DP*traceSigmaBar
        ce2V(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(2,2))=-2.0_DP*sigmaBarV(TENSOR_TO_VOIGT2(2,2))+1.5_DP*traceSigmaBar
        ce2V(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(1,2))=-sigmaBarV(TENSOR_TO_VOIGT2(1,2))
        ce2V(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(1,1))=-sigmaBarV(TENSOR_TO_VOIGT2(1,2))
        ce2V(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(2,2))=-sigmaBarV(TENSOR_TO_VOIGT2(1,2))
        ce2V(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(1,2))=0.5_DP*traceSigmaBar
        
        ce2V(1:NUMBER_OF_VOIGT(2),1:NUMBER_OF_VOIGT(2))=(1.0_DP/2.0_DP)*J**(-1.0_DP)* &
          & ce2V(1:NUMBER_OF_VOIGT(2),1:NUMBER_OF_VOIGT(2))
        
      CASE(3)
        
        ce1V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1))= &
          & +(4.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2))= &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,1)) &
          & +(4.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3))= &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2)) &
          & +(4.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,3))= &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,3)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,3)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,3)) 
        ce1V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,3))= &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,3)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,3)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3)) 
        ce1V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,2))= &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,2)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,2)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,2)) 
        
        ce1V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1))= &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1)) &
          & +(4.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2))= &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2)) &
          & +(4.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3))= &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,1)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3)) &
          & +(4.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,3))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,3)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,3)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,3)) 
        ce1V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,3))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,3)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,3)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,3)) 
        ce1V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,2))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,2)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,2)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,2)) 
        
        ce1V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,1))= &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1)) &
          & +(4.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,1)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2))= &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2)) &
          & +(4.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))= &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,1)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2)) &
          & +(1.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3)) &
          & -(2.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3)) &
          & +(4.0_DP/9.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,3))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,3)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,3)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,3)) 
        ce1V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,3))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,3)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,3)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,3)) 
        ce1V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,2))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,2)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,2)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,2)) 
        
        ce1V(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(1,1))= &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(1,1)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(2,2)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(2,2))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(1,1)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(2,2)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(3,3))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(1,1)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(2,2)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(2,3))= &
          & spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(2,3))
        ce1V(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(1,3))= &
          & spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(1,3))
        ce1V(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(1,2))= &
          & spatialCBarV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(1,2))
        
        ce1V(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(1,1))= &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(1,1)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(2,2)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(2,2))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(1,1)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(2,2)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(3,3))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(1,1)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(2,2)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(2,3))= &
          & spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(2,3))
        ce1V(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(1,3))= &
          & spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(1,3))
        ce1V(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(1,2))= &
          & spatialCBarV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(1,2))
        
        ce1V(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(1,1))= &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(1,1)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(2,2)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(2,2))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(1,1)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(2,2)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(3,3))= &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1)) &
          & -(1.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(2,2)) &
          & +(2.0_DP/3.0_DP)*spatialCBarV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(3,3))
        ce1V(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(2,3))= &
          & spatialCBarV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(2,3))
        ce1V(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(1,3))= &
          & spatialCBarV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(2,3))
        ce1V(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(1,2))= &
          & spatialCBarV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(2,3))              
        
        ce1V(1:NUMBER_OF_VOIGT(3),1:NUMBER_OF_VOIGT(3))=J**(-4.0_DP/3.0_DP)*ce1V(1:NUMBER_OF_VOIGT(3),1:NUMBER_OF_VOIGT(3))
        
        ce2V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1))=(4.0_DP/3.0_DP)*traceSigmaBar-2.0_DP*sigmaBarV(TENSOR_TO_VOIGT3(1,1))
        ce2V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2))=(1.0_DP/3.0_DP)*traceSigmaBar- &
          & sigmaBarV(TENSOR_TO_VOIGT3(1,1))-sigmaBarV(TENSOR_TO_VOIGT3(2,2))
        ce2V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3))=(1.0_DP/3.0_DP)*traceSigmaBar- &
          & sigmaBarV(TENSOR_TO_VOIGT3(1,1))-sigmaBarV(TENSOR_TO_VOIGT3(3,3))
        ce2V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,3))=-sigmaBarV(TENSOR_TO_VOIGT3(2,3))
        ce2V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,3))=-sigmaBarV(TENSOR_TO_VOIGT3(1,3))
        ce2V(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,2))=-sigmaBarV(TENSOR_TO_VOIGT3(1,2))
        ce2V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1))=(1.0_DP/3.0_DP)*traceSigmaBar- &
          & sigmaBarV(TENSOR_TO_VOIGT3(1,1))-sigmaBarV(TENSOR_TO_VOIGT3(2,2))
        ce2V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2))=(4.0_DP/3.0_DP)*traceSigmaBar-2.0_DP*sigmaBarV(TENSOR_TO_VOIGT3(2,2))
        ce2V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3))=(1.0_DP/3.0_DP)*traceSigmaBar- &
          & sigmaDevV(TENSOR_TO_VOIGT3(2,2))-sigmaBarV(TENSOR_TO_VOIGT3(3,3))
        ce2V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,3))=-sigmaBarV(TENSOR_TO_VOIGT3(2,3))
        ce2V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,3))=-sigmaBarV(TENSOR_TO_VOIGT3(1,3))
        ce2V(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,2))=-sigmaBarV(TENSOR_TO_VOIGT3(1,2))
        ce2V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,1))=(1.0_DP/3.0_DP)*traceSigmaBar- &
          & sigmaBarV(TENSOR_TO_VOIGT3(1,1))-sigmaBarV(TENSOR_TO_VOIGT3(3,3))
        ce2V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2))=(1.0_DP/3.0_DP)*traceSigmaBar- &
          & sigmaBarV(TENSOR_TO_VOIGT3(2,2))-sigmaBarV(TENSOR_TO_VOIGT3(3,3))
        ce2V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))=(4.0_DP/3.0_DP)*traceSigmaBar-2.0_DP*sigmaBarV(TENSOR_TO_VOIGT3(3,3))
        ce2V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,3))=-sigmaBarV(TENSOR_TO_VOIGT3(2,3))
        ce2V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,3))=-sigmaBarV(TENSOR_TO_VOIGT3(1,3))
        ce2V(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,2))=-sigmaBarV(TENSOR_TO_VOIGT3(1,2))
        ce2V(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(1,1))=-sigmaBarV(TENSOR_TO_VOIGT3(2,3))
        ce2V(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(2,2))=-sigmaBarV(TENSOR_TO_VOIGT3(2,3))
        ce2V(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(3,3))=-sigmaBarV(TENSOR_TO_VOIGT3(2,3))
        ce2V(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(2,3))=0.5_DP*traceSigmaBar
        ce2V(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(1,1))=-sigmaBarV(TENSOR_TO_VOIGT3(1,3))
        ce2V(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(2,2))=-sigmaBarV(TENSOR_TO_VOIGT3(1,3))
        ce2V(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(3,3))=-sigmaBarV(TENSOR_TO_VOIGT3(1,3))
        ce2V(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(1,3))=0.5_DP*traceSigmaBar
        ce2V(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(1,1))=-sigmaBarV(TENSOR_TO_VOIGT3(1,2))
        ce2V(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(2,2))=-sigmaBarV(TENSOR_TO_VOIGT3(1,2))
        ce2V(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(3,3))=-sigmaBarV(TENSOR_TO_VOIGT3(1,2))
        ce2V(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(1,2))=0.5_DP*traceSigmaBar
        
        ce2V(1:NUMBER_OF_VOIGT(3),1:NUMBER_OF_VOIGT(3))=(2.0_DP/3.0_DP)*J**(-2.0_DP/3.0_DP)* &
          & ce2V(1:NUMBER_OF_VOIGT(3),1:NUMBER_OF_VOIGT(3))      
        
      CASE DEFAULT
        localError="The number of dimensions of "//TRIM(NumberToVstring(numberOfDimensions,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
      
      spatialCDevV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions))= &
        & ce1V(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions)) + &
        & ce2V(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions))
    ELSE
      spatialCDevV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions))= &
        & spatialCBarV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions))
    ENDIF
    
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Spatial deviatoric elasticity tensors:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Jacobian = ",J,err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),1,1, &
        & NUMBER_OF_VOIGT(numberOfDimensions),8,8,spatialCBarV(1:NUMBER_OF_VOIGT(numberOfDimensions), &
        & 1:NUMBER_OF_VOIGT(numberOfDimensions)),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("  cBarV','(",I1,",:)',':",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),1,1, &
        & NUMBER_OF_VOIGT(numberOfDimensions),8,8,ce1V(1:NUMBER_OF_VOIGT(numberOfDimensions), &
        & 1:NUMBER_OF_VOIGT(numberOfDimensions)),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("  ce1V','(",I1,",:)',' :",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),1,1, &
        & NUMBER_OF_VOIGT(numberOfDimensions),8,8,ce2V(1:NUMBER_OF_VOIGT(numberOfDimensions), &
        & 1:NUMBER_OF_VOIGT(numberOfDimensions)),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("  ce2V','(",I1,",:)',' :",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),1,1, &
        & NUMBER_OF_VOIGT(numberOfDimensions),8,8,spatialCDevV(1:NUMBER_OF_VOIGT(numberOfDimensions), &
        & 1:NUMBER_OF_VOIGT(numberOfDimensions)),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("   ceV','(",I1,",:)',' :",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)      
    ENDIF
 
    EXITS("FiniteElasticity_SpatialElasticityDevTensorCalculate")
    RETURN
999 ERRORS("FiniteElasticity_SpatialElasticityDevTensorCalculate",err,error)
    EXITS("FiniteElasticity_SpatialElasticityDevTensorCalculate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_SpatialElasticityDevTensorCalculate

  !
  !================================================================================================================================
  !

  !>Evaluates the spherical part of the spatial elasticity and stress tensor in Voigt form.
  SUBROUTINE FiniteElasticity_SpatialElasticitySphTensorCalculate(equationsSet,numberOfDimensions,J,p,haveHydrostaticPressure, &
    & sigmaSphV,spatialCSphV,err,error,*)
    
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    REAL(DP), INTENT(IN) :: J !<The jacobian of deformation
    REAL(DP), INTENT(IN) :: p !<The hydrostatic pressure
    LOGICAL, INTENT(IN) :: haveHydrostaticPressure !<.TRUE. if hydrostatic pressure is used, .FALSE. if not. 
    REAL(DP), INTENT(OUT) :: sigmaSphV(:) !<On return, the spherical Cauchy stress tensor in Voigt form
    REAL(DP), INTENT(OUT) :: spatialCSphV(:,:) !<On return, the spherical part of the spatial elasticity tensor in Voigt form.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("FiniteElasticity_SpatialElasticitySphTensorCalculate",err,error,*999)

    sigmaSphV=0.0_DP
    spatialCSphV=0.0_DP

    IF(haveHydrostaticPressure) THEN
    
      CALL FiniteElasticity_SpatialStressSphTensorsCalculate(equationsSet,numberOfDimensions,J,p, &
        & haveHydrostaticPressure,sigmaSphV(1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)
      
      SELECT CASE(numberOfDimensions)
      CASE(1)
        
        spatialCSphV(TENSOR_TO_VOIGT1(1,1),TENSOR_TO_VOIGT1(1,1))=p
        
      CASE(2)
        
        spatialCSphV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(1,1))=p
        spatialCSphV(TENSOR_TO_VOIGT2(1,1),TENSOR_TO_VOIGT2(2,2))=-p
        spatialCSphV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(1,1))=-p
        spatialCSphV(TENSOR_TO_VOIGT2(2,2),TENSOR_TO_VOIGT2(2,2))=p
        spatialCSphV(TENSOR_TO_VOIGT2(1,2),TENSOR_TO_VOIGT2(1,2))=p
        
      CASE(3)
        
        spatialCSphV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(1,1))=p
        spatialCSphV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(2,2))=-p
        spatialCSphV(TENSOR_TO_VOIGT3(1,1),TENSOR_TO_VOIGT3(3,3))=-p
        spatialCSphV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(1,1))=-p
        spatialCSphV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(2,2))=p
        spatialCSphV(TENSOR_TO_VOIGT3(2,2),TENSOR_TO_VOIGT3(3,3))=-p
        spatialCSphV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(1,1))=-p
        spatialCSphV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(2,2))=-p
        spatialCSphV(TENSOR_TO_VOIGT3(3,3),TENSOR_TO_VOIGT3(3,3))=p
        spatialCSphV(TENSOR_TO_VOIGT3(1,2),TENSOR_TO_VOIGT3(1,2))=p
        spatialCSphV(TENSOR_TO_VOIGT3(1,3),TENSOR_TO_VOIGT3(1,3))=p
        spatialCSphV(TENSOR_TO_VOIGT3(2,3),TENSOR_TO_VOIGT3(2,3))=p
      
      CASE DEFAULT
        localError="The number of dimensions of "//TRIM(NumberToVstring(numberOfDimensions,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT

    ENDIF

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Spatial pressure elasticity tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),1,1, &
        & NUMBER_OF_VOIGT(numberOfDimensions),8,8,spatialCSphV(1:NUMBER_OF_VOIGT(numberOfDimensions), &
        & 1:NUMBER_OF_VOIGT(numberOfDimensions)),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("   cpV','(",I1,",:)',' :",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)      
    ENDIF
    
    EXITS("FiniteElasticity_SpatialElasticitySphTensorCalculate")
    RETURN
999 ERRORS("FiniteElasticity_SpatialElasticitySphTensorCalculate",err,error)
    EXITS("FiniteElasticity_SpatialElasticitySphTensorCalculate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_SpatialElasticitySphTensorCalculate
  
  !
  !================================================================================================================================
  !

  !>Evaluates the spatial elasticity and stress tensor in Voigt form.
  SUBROUTINE FiniteElasticity_SpatialElasticityTensorCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
    & F,J,p,haveHydrostaticPressure,sigmaV,spatialCV,err,error,*)
    
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    TYPE(FieldInterpolatedPointType), POINTER :: materialInterpolatedPoint !<A pointer to the materials parameters
    REAL(DP), INTENT(IN) :: F(:,:) !<The deformation gradient tensor
    REAL(DP), INTENT(IN) :: J !<The jacobian of deformation
    REAL(DP), INTENT(IN) :: p !<The hydrostatic pressure
    LOGICAL, INTENT(IN) :: haveHydrostaticPressure !<.TRUE. if hydrostatic pressure is used, .FALSE. if not. 
    REAL(DP), INTENT(OUT) :: sigmaV(:) !<On return, the Cauchy stress tensor in Voigt form
    REAL(DP), INTENT(OUT) :: spatialCV(:,:) !<On return, the spatial elasticity tensor in Voigt form.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    REAL(DP) :: sigmaDevV(6),sigmaSphV(6),spatialCDevV(6,6),spatialCSphV(6,6)
    
    ENTERS("FiniteElasticity_SpatialElasticityTensorCalculate",err,error,*999)

    sigmaV=0.0_DP
    spatialCV=0.0_DP
    
    CALL FiniteElasticity_SpatialElasticityDevTensorCalculate(equationsSet,numberOfDimensions,materialInterpolatedPoint, &
      & F(1:numberOfDimensions,1:numberOfDimensions),J,haveHydrostaticPressure,sigmaDevV(1:NUMBER_OF_VOIGT(numberOfDimensions)), &
      & spatialCDevV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)
    
    CALL FiniteElasticity_SpatialElasticitySphTensorCalculate(equationsSet,numberOfDimensions,J,p,haveHydrostaticPressure, &
      & sigmaSphV(1:NUMBER_OF_VOIGT(numberOfDimensions)),spatialCSphV(1:NUMBER_OF_VOIGT(numberOfDimensions), &
      & 1:NUMBER_OF_VOIGT(numberOfDimensions)),err,error,*999)

    sigmaV(1:NUMBER_OF_VOIGT(numberOfDimensions))=sigmaDevV(1:NUMBER_OF_VOIGT(numberOfDimensions))+ &
      & sigmaSphV(1:NUMBER_OF_VOIGT(numberOfDimensions))

    spatialCV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions))= &
      & spatialCDevV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions))+ &
      & spatialCSphV(1:NUMBER_OF_VOIGT(numberOfDimensions),1:NUMBER_OF_VOIGT(numberOfDimensions))
    
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Spatial stress and elasticity tensors:",err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),8,8, &
        & sigmaV(1:NUMBER_OF_VOIGT(numberOfDimensions)),'("  sigmaV    :",8(X,E13.6))','(13X,8(X,E13.6))', &
        & err,error,*999)
     CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_VOIGT(numberOfDimensions),1,1, &
        & NUMBER_OF_VOIGT(numberOfDimensions),8,8,spatialCV(1:NUMBER_OF_VOIGT(numberOfDimensions), &
        & 1:NUMBER_OF_VOIGT(numberOfDimensions)),WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("   cV','(",I1,",:)','  :",8(X,E13.6))','(13X,8(X,E13.6))',err,error,*999)      
    ENDIF
    
    EXITS("FiniteElasticity_SpatialElasticityTensorCalculate")
    RETURN
999 ERRORS("FiniteElasticity_SpatialElasticityTensorCalculate",err,error)
    EXITS("FiniteElasticity_SpatialElasticityTensorCalculate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_SpatialElasticityTensorCalculate
  
  !
  !================================================================================================================================
  !

  !>Evaluates the spatial elasticity and stress tensor in Voigt form at a given Gauss point.
  SUBROUTINE FiniteElasticity_GaussElasticityTensor(equationsSet,numberOfDimensions,dependentInterpPoint,materialsInterpPoint, &
    & independentInterpPoint,elasticityTensor,hydroElasticityV,stressTensor,dZdNu,Jznu,elementNumber, &
    & gaussPointNumber,err,error,*)
    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    TYPE(FieldInterpolatedPointType), POINTER :: dependentInterpPoint,materialsInterpPoint,independentInterpPoint
    REAL(DP), INTENT(OUT) :: elasticityTensor(:,:) !< Rank 4 elasticity tensor in Voigt notation
    REAL(DP), INTENT(OUT) :: hydroElasticityV(:) !<Rank 2 hydrostatic portion of the elasticity tensor in Voigt notation
    REAL(DP), INTENT(OUT) :: stressTensor(:) !< Rank 2 stress tensor in Voigt notation
    REAL(DP), INTENT(IN) :: dZdNu(:,:)!< The deformation gradient
    REAL(DP), INTENT(IN) :: Jznu !< The Jacobian
    INTEGER(INTG), INTENT(IN) :: elementNumber,gaussPointNumber !<Element/Gauss point number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,dofIdx,esSpecification(3),i,interpolationType,j,numberOfComponents,pressureComponent
    REAL(DP) :: P, I1, I3, lambda(3)
    REAL(DP) :: dZdNuT(3,3),rightCauchyGreen(3,3),piolaDeformation(3,3),temp(3,3)
    REAL(DP) :: rightCauchyGreenV(6), piolaDeformationV(6) !<Voigt forms of the C and C^-1 tensors.
    REAL(DP) :: tempTerm1,tempTerm2,value
    REAL(DP) :: B(6),E(6),dQdE(6),Q
    REAL(DP) :: d2I3dE2(6,6) !<Derivative of I3 wrt E
    REAL(DP) :: ADJCC(6,6) !<Derivative of adj(C) wrt C
    REAL(DP) :: dBdE(6,6) !<Derivative of C^-1 wrt E
    REAL(DP) :: dBdC(6,6)
    REAL(DP), POINTER :: C(:) !Parameters for constitutive laws
    TYPE(FieldType), POINTER :: independentField
    TYPE(FieldVariableType), POINTER :: dependentVariable,independentVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_GaussElasticityTensor",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)

    !rightCauchyGreen = F'*F (deformed covariant or right cauchy deformation tensor, C)
    !piolaDeformation - deformed contravariant tensor; I3 = det(C)
    !E = Green-Lagrange strain tensor = 0.5*(C-I)
    !P is the hydrostatic pressure

    !Evaluate the Cauchy strain tensor C.
    CALL MatrixTranspose(dZdNu,dZdNuT,err,error,*999)
    CALL MatrixProduct(dZdNuT,dZdNu,rightCauchyGreen,err,error,*999)
    CALL Invert(rightCauchyGreen,piolaDeformation,I3,err,error,*999)

    !Evaluate the derivative of piolaDeformation wrt to E (dBdE) for the hydrostatic term. Formulation from Nam-Ho Kim book, pg.198.
    rightCauchyGreenV(1) = rightCauchyGreen(1,1)
    rightCauchyGreenV(2) = rightCauchyGreen(2,2)
    rightCauchyGreenV(3) = rightCauchyGreen(3,3)
    rightCauchyGreenV(4) = rightCauchyGreen(1,2)
    rightCauchyGreenV(5) = rightCauchyGreen(1,3)
    rightCauchyGreenV(6) = rightCauchyGreen(2,3)
    piolaDeformationV(1) = piolaDeformation(1,1)
    piolaDeformationV(2) = piolaDeformation(2,2)
    piolaDeformationV(3) = piolaDeformation(3,3)
    piolaDeformationV(4) = piolaDeformation(1,2)
    piolaDeformationV(5) = piolaDeformation(1,3)
    piolaDeformationV(6) = piolaDeformation(2,3)
    d2I3dE2 = RESHAPE([0.0_DP,4.0_DP*rightCauchyGreenV(3),4.0_DP*rightCauchyGreenV(2),0.0_DP,0.0_DP,-4.0_DP*rightCauchyGreenV(6), &
      & 4.0_DP*rightCauchyGreenV(3),0.0_DP,4.0_DP*rightCauchyGreenV(1),0.0_DP,-4.0_DP*rightCauchyGreenV(5),0.0_DP,  &
      & 4.0_DP*rightCauchyGreenV(2),4.0_DP*rightCauchyGreenV(1),0.0_DP,-2.0_DP*rightCauchyGreenV(4),0.0_DP,0.0_DP, &
      & 0.0_DP,0.0_DP,-4.0_DP*rightCauchyGreenV(4),-2.0_DP*rightCauchyGreenV(3),2.0_DP*rightCauchyGreenV(6), &
      & 2.0_DP*rightCauchyGreenV(5),0.0_DP,-4.0_DP*rightCauchyGreenV(5),0.0_DP,2.0_DP*rightCauchyGreenV(6), &
      & -2.0_DP*rightCauchyGreenV(2),2.0_DP*rightCauchyGreenV(4),-4.0_DP*rightCauchyGreenV(6),0.0_DP,0.0_DP, &
      & 2.0_DP*rightCauchyGreenV(5),2.0_DP*rightCauchyGreenV(4),-2.0_DP*rightCauchyGreenV(1)],[6,6])
    ADJCC = RESHAPE([0.0_DP,rightCauchyGreenV(3),rightCauchyGreenV(2),0.0_DP,0.0_DP,-rightCauchyGreenV(6), &
      & rightCauchyGreenV(3),0.0_DP,rightCauchyGreenV(1),0.0_DP,-rightCauchyGreenV(5),0.0_DP,  &
      & rightCauchyGreenV(2),rightCauchyGreenV(1),0.0_DP,-rightCauchyGreenV(4),0.0_DP,0.0_DP, &
      & 0.0_DP,0.0_DP,-rightCauchyGreenV(4),-0.5_DP*rightCauchyGreenV(3),0.5_DP*rightCauchyGreenV(6),0.5_DP*rightCauchyGreenV(5), &
      & 0.0_DP,-rightCauchyGreenV(5),0.0_DP,0.5_DP*rightCauchyGreenV(6),-0.5_DP*rightCauchyGreenV(2),0.5_DP*rightCauchyGreenV(4), &
      & -rightCauchyGreenV(6),0.0_DP,0.0_DP,0.5_DP*rightCauchyGreenV(5),0.5_DP*rightCauchyGreenV(4),-0.5_DP*rightCauchyGreenV(1)], &
      & [6,6])
    !DO i=1,6
    !  DO j=1,6
    !    dBdE(i,j) = -2.0_DP*piolaDeformationV(i)*piolaDeformationV(j) + 2.0_DP*ADJCC(i,j)/I3
    !  ENDDO !j
    !ENDDO !i

    DO i=1,6
      DO j=1,6
        dBdE(i,j) = -2.0_DP*piolaDeformationV(i)*piolaDeformationV(j) + 0.5_DP*d2I3dE2(i,j)/I3
        dBdC(i,j) = piolaDeformationV(i)*piolaDeformationV(j)
      ENDDO
      dBdC(i,i) = dBdC(i,i)-2.0_DP
    ENDDO

    C=>materialsInterpPoint%values(:,NO_PART_DERIV)

    elasticityTensor=0.0_DP
    stressTensor=0.0_DP
    hydroElasticityV=0.0_DP

    SELECT CASE(esSpecification(3))
    CASE(EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
      pressureComponent=numberOfDimensions+1
      P=dependentInterpPoint%values(pressureComponent,NO_PART_DERIV)
      !Form of constitutive model is:
      ! W=c1*(I1-3)+c2*(I2-3)+p/2*(I3-1)

      ! Calculate isochoric fictitious 2nd Piola tensor (in Voigt form)
      I1=rightCauchyGreen(1,1)+rightCauchyGreen(2,2)+rightCauchyGreen(3,3)
      tempTerm1=-2.0_DP*C(2)
      tempTerm2=2.0_DP*(C(1)+I1*C(2))
      !stressTensor(1)=tempTerm1*rightCauchyGreen(1,1)+tempTerm2
      !stressTensor(2)=tempTerm1*rightCauchyGreen(2,2)+tempTerm2
      !stressTensor(3)=tempTerm1*rightCauchyGreen(3,3)+tempTerm2
      !stressTensor(4)=tempTerm1*rightCauchyGreen(2,1)
      !stressTensor(5)=tempTerm1*rightCauchyGreen(3,1)
      !stressTensor(6)=tempTerm1*rightCauchyGreen(3,2)
      stressTensor(1)=tempTerm1*rightCauchyGreen(1,1)+tempTerm2+P*piolaDeformationV(1)*Jznu
      stressTensor(2)=tempTerm1*rightCauchyGreen(2,2)+tempTerm2+P*piolaDeformationV(2)*Jznu
      stressTensor(3)=tempTerm1*rightCauchyGreen(3,3)+tempTerm2+P*piolaDeformationV(3)*Jznu
      stressTensor(4)=tempTerm1*rightCauchyGreen(2,1)+P*piolaDeformationV(4)*Jznu
      stressTensor(5)=tempTerm1*rightCauchyGreen(3,1)+P*piolaDeformationV(5)*Jznu
      stressTensor(6)=tempTerm1*rightCauchyGreen(3,2)+P*piolaDeformationV(6)*Jznu
      IF(esSpecification(3)==EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE) THEN        
        !add active contraction stress values
        !Be aware for modified dZdNu, should active contraction be added here? Normally should be okay as modified dZdNu and dZdNu
        !converge during the Newton iteration.
        NULLIFY(independentField)
        CALL EquationsSet_IndependentFieldGet(equationsSet,independentField,err,error,*999)
        NULLIFY(independentVariable)
        CALL Field_VariableGet(independentField,FIELD_U_VARIABLE_TYPE,independentVariable,err,error,*999)
        CALL FieldVariable_NumberOfComponentsGet(independentVariable,numberOfComponents,err,error,*999)
        DO componentIdx=1,numberOfComponents
          CALL FieldVariable_LocalGaussDOFGet(independentVariable,gaussPointNumber,elementNumber,componentIdx,dofIdx, &
            & err,error,*999)
          CALL FieldVariable_ParameterSetGetLocalDOF(independentVariable,FIELD_VALUES_SET_TYPE,dofIdx,VALUE,err,error,*999)
          stressTensor(componentIdx)=stressTensor(componentIdx)+VALUE
        ENDDO !componentIdx
      ENDIF

      ! Calculate material elasticity tensor (in Voigt form) as
      ! this will be compensated for in the push-forward with the modified deformation gradient.
      tempTerm1=4.0_DP*C(2)
      tempTerm2=-4.0_DP*C(2)
      elasticityTensor(2,1)=tempTerm1
      elasticityTensor(3,1)=tempTerm1
      elasticityTensor(1,2)=tempTerm1
      elasticityTensor(3,2)=tempTerm1
      elasticityTensor(1,3)=tempTerm1
      elasticityTensor(2,3)=tempTerm1
      elasticityTensor(4,4)=tempTerm2
      elasticityTensor(5,5)=tempTerm2
      elasticityTensor(6,6)=tempTerm2
      !Add volumetric part of elasticity tensor - p*d(C^-1)/dC.
      elasticityTensor=elasticityTensor + P*Jznu*dBdC

      !Hydrostatic portion of the elasticity tensor (dS/dp)
      hydroElasticityV = piolaDeformationV

      ! Do push-forward of 2nd Piola tensor and the material elasticity tensor.
      CALL FiniteElasticity_PushStressTensor(stressTensor,dZdNu,Jznu,err,error,*999)
      CALL FiniteElasticity_PushStressTensor(hydroElasticityV,dZdNu,Jznu,err,error,*999)
      CALL FiniteElasticity_PushElasticityTensor(elasticityTensor,dZdNu,Jznu,err,error,*999)

      ! Add volumetric parts.
      !stressTensor(1:3)=stressTensor(1:3)+P

    CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE,EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_NOLENDEP_SUBTYPE,EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_2NDPIOLA_SUBTYPE, &
      & EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE)
      pressureComponent=numberOfDimensions+1
      P=dependentInterpPoint%values(pressureComponent,NO_PART_DERIV)
      B=[2.0_DP*C(2),2.0_DP*C(3),2.0_DP*C(3),C(4),C(4),C(3)] ![2*b_f,2*b_t,2*b_t,b_ft,b_ft,b_t]
      E=[0.5_DP*(rightCauchyGreen(1,1)-1.0_DP),0.5_DP*(rightCauchyGreen(2,2)-1.0_DP),0.5_DP*(rightCauchyGreen(3,3)-1.0_DP), &
        & rightCauchyGreen(2,1),rightCauchyGreen(3,1),rightCauchyGreen(3,2)] !(Modified) strain tensor in Voigt form.
      dQdE=B*E
      tempTerm1=0.5_DP*C(1)*EXP(0.5_DP*DOT_PRODUCT(E,dQdE))
      !Calculate 2nd Piola tensor (in Voigt form)
      stressTensor=tempTerm1*dQdE + P*piolaDeformationV
      !lambda = 1.0_DP
      !lambda(1) = SQRT(rightCauchyGreen(1,1))
      IF(esSpecification(3)==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE) THEN
        !add active contraction stress values
        NULLIFY(independentField)
        CALL EquationsSet_IndependentFieldGet(equationsSet,independentField,err,error,*999)
        NULLIFY(independentVariable)
        CALL Field_VariableGet(independentField,FIELD_U_VARIABLE_TYPE,independentVariable,err,error,*999)
        CALL FieldVariable_NumberOfComponentsGet(independentVariable,numberOfComponents,err,error,*999)
        DO componentIdx=1,numberOfComponents
          CALL FieldVariable_ComponentInterpolationGet(independentVariable,componentIdx,interpolationType,err,error,*999)
          SELECT CASE(interpolationType)
          CASE(FIELD_CONSTANT_INTERPOLATION)
            VALUE=0.1_DP
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            CALL FieldVariable_LocalGaussDOFGet(independentVariable,gaussPointNumber,elementNumber,componentIdx,dofIdx, &
              & err,error,*999)
            CALL FieldVariable_ParameterSetGetLocalDOF(independentVariable,FIELD_VALUES_SET_TYPE,dofIdx,VALUE,err,error,*999)
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            VALUE=independentInterpPoint%values(componentIdx,NO_PART_DERIV)
          CASE DEFAULT
            localError="This independent field variable interpolation type is not supported."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          stressTensor(componentIdx)=stressTensor(componentIdx)+VALUE
          !stressTensor(componentIdx)=stressTensor(componentIdx)+VALUE*(1.0_DP+1.45_DP*(lambda(componentIdx)-1.0_DP))
        ENDDO
      ENDIF

      !\todo blas has routines specifically for symmetric matrices, so it would be worth to check if these could give some speedup.

      ! Calculate material elasticity tensor c (in Voigt form).
      ! First calculate lower part of 6X6 matrix
      DO j=1,6
        DO i=j,6
          elasticityTensor(i,j)=tempTerm1*dQdE(i)*dQdE(j)
        ENDDO
      ENDDO
      DO i=1,6
        elasticityTensor(i,i)=elasticityTensor(i,i)+tempTerm1*B(i)
      ENDDO
      ! Then calculate upper part.
      DO j=2,6
        DO i=1,j-1
          elasticityTensor(i,j)=elasticityTensor(j,i)
        ENDDO
      ENDDO

      !Add volumetric part of elasticity tensor - p*d(C^-1)/dE.
      elasticityTensor=elasticityTensor + P*dBdE

      !Hydrostatic portion of the elasticity tensor (dS/dp)
      hydroElasticityV = piolaDeformationV

      !Do push-forward of 2nd Piola tensor and the material elasticity tensor.
      CALL FiniteElasticity_PushStressTensor(stressTensor,dZdNu,Jznu,err,error,*999)
      CALL FiniteElasticity_PushStressTensor(hydroElasticityV,dZdNu,Jznu,err,error,*999)
      CALL FiniteElasticity_PushElasticityTensor(elasticityTensor,dZdNu,Jznu,err,error,*999)
      
    CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE)

      !W = lambda/2.[tr(E)]^2+mu.tr(E^2)+p/2*(I3-1)^2
      !S = lambda.tr(E).I + 2.mu.E + p*J*C^(-1)
      
      E=[0.5_DP*(rightCauchyGreen(1,1)-1.0_DP),0.5_DP*(rightCauchyGreen(2,2)-1.0_DP),0.5_DP*(rightCauchyGreen(3,3)-1.0_DP), &
        & rightCauchyGreen(2,1),rightCauchyGreen(3,1),rightCauchyGreen(3,2)] !(Modified) strain tensor in Voigt form.
      pressureComponent=numberOfDimensions+1
      P=dependentInterpPoint%VALUES(pressureComponent,NO_PART_DERIV)
      
       !Calculate isochoric fictitious 2nd Piola tensor (in Voigt form)
      I1=E(1)+E(2)+E(3)
      tempTerm1=C(2)*I1
      tempTerm2=2.0_DP*C(3)
      stressTensor(1)=tempTerm1+tempTerm2*E(1)+P*piolaDeformation(1,1)
      stressTensor(4)=tempTerm2*E(4)+P*piolaDeformation(1,2)
      stressTensor(5)=tempTerm2*E(5)+P*piolaDeformation(1,3)
      stressTensor(2)=tempTerm1+tempTerm2*E(2)+P*piolaDeformation(2,2)
      stressTensor(6)=tempTerm2*E(6)+P*piolaDeformation(2,3)
      stressTensor(3)=tempTerm1+tempTerm2*E(3)+P*piolaDeformation(3,3)
           
      elasticityTensor(1,1)=C(2)+2.0_DP*C(3)      
      elasticityTensor(1,2)=C(2)
      elasticityTensor(1,3)=C(2)
      elasticityTensor(2,1)=C(2)
      elasticityTensor(2,2)=C(2)+2.0_DP*C(3)
      elasticityTensor(2,3)=C(2)
      elasticityTensor(3,1)=C(2)
      elasticityTensor(3,2)=C(2)
      elasticityTensor(3,3)=C(2)+2.0_DP*C(3)
      elasticityTensor(4,4)=C(3)
      elasticityTensor(5,5)=C(3)
      elasticityTensor(6,6)=C(3)
      
      !Add volumetric part of elasticity tensor - p*d(C^-1)/dE.
      elasticityTensor=elasticityTensor + P*dBdE

      !Hydrostatic portion of the elasticity tensor (dS/dp)
      hydroElasticityV = piolaDeformationV

      !Do push-forward of 2nd Piola tensor and the material elasticity tensor.
      CALL FiniteElasticity_PushStressTensor(stressTensor,dZdNu,Jznu,err,error,*999)
      CALL FiniteElasticity_PushStressTensor(hydroElasticityV,dZdNu,Jznu,err,error,*999)
      CALL FiniteElasticity_PushElasticityTensor(elasticityTensor,dZdNu,Jznu,err,error,*999)
     
    CASE(EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE)
      !Form of constitutive model is:
      ! W=c1*(I1-3)+c2*(I2-3)+p/2*(I3-1)

      pressureComponent=numberOfDimensions+1
      P=dependentInterpPoint%values(pressureComponent,NO_PART_DERIV)
      
      ! Calculate isochoric fictitious 2nd Piola tensor (in Voigt form)
      I1=rightCauchyGreen(1,1)+rightCauchyGreen(2,2)+rightCauchyGreen(3,3)
      tempTerm1=-2.0_DP*C(3)
      tempTerm2=2.0_DP*(C(2)+I1*C(3))
      stressTensor(1)=tempTerm1*rightCauchyGreen(1,1)+tempTerm2+P*Jznu*piolaDeformationV(1)
      stressTensor(2)=tempTerm1*rightCauchyGreen(2,2)+tempTerm2+P*Jznu*piolaDeformationV(2)
      stressTensor(3)=tempTerm1*rightCauchyGreen(3,3)+tempTerm2+P*Jznu*piolaDeformationV(3)
      stressTensor(4)=tempTerm1*rightCauchyGreen(2,1)+P*Jznu*piolaDeformationV(4)
      stressTensor(5)=tempTerm1*rightCauchyGreen(3,1)+P*Jznu*piolaDeformationV(5)
      stressTensor(6)=tempTerm1*rightCauchyGreen(3,2)+P*Jznu*piolaDeformationV(6)
      ! Calculate material elasticity tensor (in Voigt form) as
      ! this will be compensated for in the push-forward with the modified deformation gradient.
      tempTerm1=4.0_DP*C(3)
      tempTerm2=-4.0_DP*C(3)
      elasticityTensor(2,1)=tempTerm1
      elasticityTensor(3,1)=tempTerm1
      elasticityTensor(1,2)=tempTerm1
      elasticityTensor(3,2)=tempTerm1
      elasticityTensor(1,3)=tempTerm1
      elasticityTensor(2,3)=tempTerm1
      elasticityTensor(4,4)=tempTerm2
      elasticityTensor(5,5)=tempTerm2
      elasticityTensor(6,6)=tempTerm2
      !Add volumetric part of elasticity tensor - p*d(C^-1)/dE.
      elasticityTensor=elasticityTensor + P*Jznu*dBdC

      !Hydrostatic portion of the elasticity tensor (dS/dp)
      hydroElasticityV = piolaDeformationV

      ! Do push-forward of 2nd Piola tensor and the material elasticity tensor.
      CALL FiniteElasticity_PushStressTensor(stressTensor,dZdNu,Jznu,err,error,*999)
      CALL FiniteElasticity_PushStressTensor(hydroElasticityV,dZdNu,Jznu,err,error,*999)
      CALL FiniteElasticity_PushElasticityTensor(elasticityTensor,dZdNu,Jznu,err,error,*999)
 
    CASE DEFAULT
      localError="Analytic Jacobian has not been implemented for the third equations set specification of "// &
        & TRIM(NumberToVString(esSpecification(3),"*",err,error))
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FiniteElasticity_GaussElasticityTensor")
    RETURN
999 ERRORSEXITS("FiniteElasticity_GaussElasticityTensor",err,error)
    RETURN 1

  END SUBROUTINE FiniteElasticity_GaussElasticityTensor

  !
  !================================================================================================================================
  !

  !>Evaluates the element Jacobian matrix for the given element number for a finite elasticity class finite element equation set.
  SUBROUTINE FiniteElasticity_FiniteElementJacobianEvaluateNew(equationsSet,elementNumber,err,error,*)
    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to evaluate the Jacobian for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: colsElementBaseDOFIndex(4),colsInterpolationType,colsVariableType,columnComponentIdx,columnElementDOFIdx, &
      & columnElementParameterIdx,componentIdx,dependentScalingType,elementBaseDOFIndex(4),equationsSetSubtype, &
      & esSpecification(3),gaussPointIdx, &
      & meshComponentNumber,numberOfColsComponents,numberOfColsElementParameters(4),numberOfComponents,numberOfDimensions, &
      & numberOfElementParameters(4),numberOfGauss,numberOfRowsComponents,numberOfRowsElementParameters(4),numberOfXi, &
      & offDiagComponentIdx,pressureComponent,pressureInterpolationType,rowComponentIdx,rowElementDOFIdx,rowElementParameterIdx, &
      & rowsElementBaseDOFIndex(4),rowsInterpolationType,rowsVariableType,totalNumberOfColsElementDOFs, &
      & totalNumberOfRowsElementDOFS,totalNumberOfRowsElementParameters,totalNumberOfSurfacePressureConditions,xiIdx    
    INTEGER(INTG), PARAMETER :: NUMBER_OF_OFF_DIAGONAL_COMPONENTS(3)=[0,1,3],OFF_DIAG_COLUMN_COMPONENT(3)=[1,1,2], &
      & OFF_DIAG_ROW_COMPONENT(3)=[2,3,3]
    REAL(DP) :: cauchyTensor(3,3),colsdPhi,dNudXi(3,3),dPhidZ(3,64,3),dXidNu(3,3),F(3,3),Fe(3,3),Fg(3,3),FNu(3,3), &
      & fibreVectors(3,3),gaussWeight,growthValues(3),J,jacobianGaussWeight,Je,Jg,Jgw,jgwSubMatrix(3,3),jgwdPhiColdZ, &
      & JNu,Jxxi,Jzxi,p,phiRow,sigma(6),spatialC(6,6),sum1,tempVec(3)
    LOGICAL :: boundaryElement,haveDensity,haveHydrostaticPressure,haveSurfacePressure,updateJacobian
    TYPE(BasisType), POINTER :: colsBasis,dependentBasis,rowsBasis
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(BoundaryConditionsVariableType), POINTER :: boundaryConditionsVariable
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: decomposition,dependentDecomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements,dependentDecompElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology,dependentDecompTopology
    TYPE(DomainType), POINTER :: colsDomain,domain,rowsDomain
    TYPE(DomainElementsType), POINTER :: colsDomainElements,domainElements,rowsDomainElements
    TYPE(DomainTopologyType), POINTER :: colsDomainTopology,domainTopology,rowsDomainTopology
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsInterpolationType), POINTER :: equationsInterpolation
    TYPE(EquationsMappingLHSType), POINTER :: lhsMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingRHSType), POINTER :: rhsMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: dependentField,fibreField,geometricField,independentField,materialsField
    TYPE(FieldInterpolationParametersType), POINTER :: colsInterpParameters,densityInterpParameters,dependentInterpParameters, &
      & fibreInterpParameters,geometricInterpParameters,independentInterpParameters,materialsInterpParameters,rowsInterpParameters
    TYPE(FieldInterpolatedPointType), POINTER :: densityInterpPoint,dependentInterpPoint,fibreInterpPoint, &
      & geometricInterpPoint,independentInterpPoint,materialsInterpPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: dependentInterpPointMetrics,geometricInterpPointMetrics
    TYPE(FieldVariableType), POINTER :: colsVariable,materialsVariable,residualVariable,rhsVariable,rowsVariable
    TYPE(JacobianMatrixType), POINTER :: jacobianMatrix
    TYPE(QuadratureSchemeType), POINTER :: columnQuadratureScheme,dependentQuadratureScheme,rowQuadratureScheme
    TYPE(QuadratureSchemePtrType) :: columnQuadratureSchemes(4),rowQuadratureSchemes(4)
    TYPE(RegionType), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_FiniteElementJacobianEvaluateNew",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)

    equationsSetSubtype=esSpecification(3)

    haveDensity=.FALSE.

    haveHydrostaticPressure=equationsSetSubtype/=EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE.AND. &
      & equationsSetSubtype/=EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE.AND. &
      & equationsSetSubtype/=EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE.AND. &
      & equationsSetSubtype/=EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE
    
    NULLIFY(equations)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    NULLIFY(vectorEquations)
    CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)       
    NULLIFY(vectorMatrices)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    NULLIFY(nonlinearMatrices)
    CALL EquationsMatricesVector_NonlinearMatricesGet(vectorMatrices,nonlinearMatrices,err,error,*999)
    NULLIFY(residualVector)
    CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,1,residualVector,err,error,*999)
    NULLIFY(jacobianMatrix)
    CALL EquationsMatricesResidual_JacobianMatrixGet(residualVector,1,jacobianMatrix,err,error,*999)

    updateJacobian=jacobianMatrix%updateJacobian
    
    IF(updateJacobian) THEN
      NULLIFY(region)
      CALL EquationsSet_RegionGet(equationsSet,region,err,error,*999)
      NULLIFY(coordinateSystem)
      CALL Region_CoordinateSystemGet(region,coordinateSystem,err,error,*999)
      CALL CoordinateSystem_DimensionGet(coordinateSystem,numberOfDimensions,err,error,*999)
      NULLIFY(vectorMapping)
      CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
      NULLIFY(lhsMapping)
      CALL EquationsMappingVector_LHSMappingGet(vectorMapping,lhsMapping,err,error,*999)
      NULLIFY(equationsInterpolation)
      CALL Equations_InterpolationGet(equations,equationsInterpolation,err,error,*999)
      NULLIFY(nonlinearMapping)
      CALL EquationsMappingVector_NonlinearMappingGet(vectorMapping,nonlinearMapping,err,error,*999)
      NULLIFY(residualMapping)
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,1,residualMapping,err,error,*999)
      NULLIFY(rhsMapping)
      CALL EquationsMappingVector_RHSMappingGet(vectorMapping,rhsMapping,err,error,*999)
      NULLIFY(rhsVariable)
      CALL EquationsMappingRHS_RHSVariableGet(rhsMapping,rhsVariable,err,error,*999)
      NULLIFY(geometricField)
      NULLIFY(dependentField)
      IF(equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE .OR. &
        & equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE) THEN
        CALL EquationsSet_GeometricFieldGet(equationsSet,dependentField,err,error,*999)
        CALL EquationsSet_DependentFieldGet(equationsSet,geometricField,err,error,*999)
      ELSE
        CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
        CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
      ENDIF
      NULLIFY(fibreField)
      CALL EquationsSet_FibreFieldExists(equationsSet,fibreField,err,error,*999)
      NULLIFY(materialsField)
      CALL EquationsSet_MaterialsFieldExists(equationsSet,materialsField,err,error,*999)
      NULLIFY(independentField)
      CALL EquationsSet_IndependentFieldExists(equationsSet,independentField,err,error,*999)

      NULLIFY(dependentDecomposition)
      CALL Field_DecompositionGet(dependentField,dependentDecomposition,err,error,*999)
      NULLIFY(dependentDecompTopology)
      CALL Decomposition_DecompositionTopologyGet(dependentDecomposition,dependentDecompTopology,err,error,*999)
      NULLIFY(dependentDecompElements)
      CALL DecompositionTopology_DecompositionElementsGet(dependentDecompTopology,dependentDecompElements,err,error,*999)
      NULLIFY(colsDomain)
      CALL Decomposition_DomainGet(dependentDecomposition,0,colsDomain,err,error,*999)
      NULLIFY(colsDomainTopology)
      CALL Domain_DomainTopologyGet(colsDomain,colsDomainTopology,err,error,*999)
      NULLIFY(colsDomainElements)
      CALL DomainTopology_DomainElementsGet(colsDomainTopology,colsDomainElements,err,error,*999)
      NULLIFY(colsBasis)
      CALL DomainElements_ElementBasisGet(colsDomainElements,elementNumber,colsBasis,err,error,*999)

      NULLIFY(rowsVariable)
      CALL EquationsMappingLHS_LHSVariableGet(lhsMapping,rowsVariable,err,error,*999)
      CALL FieldVariable_VariableTypeGet(rowsVariable,rowsVariableType,err,error,*999)
      CALL FieldVariable_NumberOfComponentsGet(rowsVariable,numberOfRowsComponents,err,error,*999)
      
      NULLIFY(colsVariable)
      CALL EquationsMappingResidual_VariableGet(residualMapping,1,colsVariable,err,error,*999)
      CALL FieldVariable_VariableTypeGet(colsVariable,colsVariableType,err,error,*999)
      CALL FieldVariable_NumberOfComponentsGet(colsVariable,numberOfColsComponents,err,error,*999)
      
      NULLIFY(columnQuadratureScheme)
      CALL Basis_QuadratureSchemeGet(colsBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureScheme,err,error,*999)
      CALL BasisQuadratureScheme_NumberOfGaussGet(columnQuadratureScheme,numberOfGauss,err,error,*999)
      CALL Basis_NumberOfXiGet(colsBasis,numberOfXi,err,error,*999)
      
      IF(haveHydrostaticPressure) pressureComponent=numberOfColsComponents

!!TODO: Need to fix this as equations sets shouldn't know about boundary conditions.      
      boundaryConditions=>equationsSet%boundaryConditions
      NULLIFY(boundaryConditionsVariable)
      CALL BoundaryConditions_VariableGet(boundaryConditions,rhsVariable,boundaryConditionsVariable,err,error,*999)
      totalNumberOfSurfacePressureConditions=boundaryConditionsVariable%dofCounts(BOUNDARY_CONDITION_PRESSURE)+ &
        & boundaryConditionsVariable%dofCounts(BOUNDARY_CONDITION_PRESSURE_INCREMENTED)

      CALL DecompositionElements_ElementBoundaryElementGet(dependentDecompElements,elementNumber,boundaryElement,err,error,*999)
      haveSurfacePressure=boundaryElement.AND.totalNumberofSurfacePressureConditions>0
      
      !Grab interpolation parameters, points and metrics.
      NULLIFY(geometricInterpParameters)
      NULLIFY(geometricInterpPoint)
      NULLIFY(geometricInterpPointMetrics)
      NULLIFY(dependentInterpParameters)
      NULLIFY(dependentInterpPoint)
      NULLIFY(dependentInterpPointMetrics)
      IF(equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE .OR. &
        & equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE) THEN
        CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & dependentInterpParameters,err,error,*999)
        CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & dependentInterpPoint,err,error,*999)
        CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & dependentInterpPointMetrics,err,error,*999)
        CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,colsVariableType, &
          & geometricInterpParameters,err,error,*999)
        CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,colsVariableType, &
          & geometricInterpPoint,err,error,*999)
        CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,colsVariableType, &
          & geometricInterpPointMetrics,err,error,*999)
      ELSE
        CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & geometricInterpParameters,err,error,*999)
        CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & geometricInterpPoint,err,error,*999)
        CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & geometricInterpPointMetrics,err,error,*999)
        CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,colsVariableType, &
          & dependentInterpParameters,err,error,*999)
        CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,colsVariableType, &
          & dependentInterpPoint,err,error,*999)
        CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,colsVariableType, &
          & dependentInterpPointMetrics,err,error,*999)
      ENDIF
      CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,geometricInterpParameters,err,error,*999)
      CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,dependentInterpParameters,err,error,*999)
      NULLIFY(fibreInterpParameters)
      NULLIFY(fibreInterpPoint)
      IF(ASSOCIATED(fibreField)) THEN
        CALL EquationsInterpolation_FibreParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,fibreInterpParameters, &
          & err,error,*999)
        CALL EquationsInterpolation_FibrePointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,fibreInterpPoint,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,fibreInterpParameters,err,error,*999)
      ENDIF
      NULLIFY(materialsInterpParameters)
      NULLIFY(materialsInterpPoint)
      NULLIFY(densityInterpParameters)
      NULLIFY(densityInterpPoint)
      NULLIFY(materialsVariable)
      IF(ASSOCIATED(materialsField)) THEN
        CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & materialsInterpParameters,err,error,*999)
        CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & materialsInterpPoint,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,materialsInterpParameters,err,error,*999)
        CALL Field_VariableGet(materialsField,FIELD_U_VARIABLE_TYPE,materialsVariable,err,error,*999)      
        IF(haveDensity) THEN
          CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_V_VARIABLE_TYPE, &
            & densityInterpParameters,err,error,*999)
          CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_V_VARIABLE_TYPE, &
            & densityInterpPoint,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,densityInterpParameters,err,error,*999)
        ENDIF
      ENDIF
      NULLIFY(independentInterpParameters)
      NULLIFY(independentInterpPoint)
      IF(ASSOCIATED(independentField)) THEN
        CALL EquationsInterpolation_IndependentParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & independentInterpParameters,err,error,*999)
        CALL EquationsInterpolation_IndependentPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & independentInterpPoint,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,independentInterpParameters, &
          & err,error,*999)
      ENDIF
      
      IF(diagnostics1) THEN
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"Element : ",elementNumber,err,error,*999)
      ENDIF
      
      totalNumberOfRowsElementDOFS=0
      !Loop over geometric dependent basis functions.
      DO rowComponentIdx=1,numberOfRowsComponents
        NULLIFY(rowsDomain)
        CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowsDomain,err,error,*999)
        NULLIFY(rowsDomainTopology)
        CALL Domain_DomainTopologyGet(rowsDomain,rowsDomainTopology,err,error,*999)
        NULLIFY(rowsDomainElements)
        CALL DomainTopology_DomainElementsGet(rowsDomainTopology,rowsDomainElements,err,error,*999)
        NULLIFY(rowsBasis)
        CALL DomainElements_ElementBasisGet(rowsDomainElements,elementNumber,rowsBasis,err,error,*999)
        NULLIFY(rowQuadratureSchemes(rowComponentIdx)%ptr)
        CALL Basis_QuadratureSchemeGet(rowsBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowQuadratureSchemes(rowComponentIdx)%ptr, &
          & err,error,*999)
        CALL FieldVariable_ComponentInterpolationGet(rowsVariable,rowComponentIdx,rowsInterpolationType,err,error,*999)
        SELECT CASE(rowsInterpolationType)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          numberOfRowsElementParameters(rowComponentIdx)=1
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          CALL Basis_NumberOfElementParametersGet(rowsBasis,numberOfRowsElementParameters(rowComponentIdx),err,error,*999)
        CASE DEFAULT
          localError="The interpolation type of "//TRIM(NumberToVString(rowsInterpolationType,"*",err,error))// &
            & " for row component number "//TRIM(NumberToVString(rowComponentIdx,"*",err,error))//" is not implemented."
          CALL FlagError(localError,err,error,*999)
        END SELECT
        rowsElementBaseDOFIndex(rowComponentIdx)=totalNumberOfRowsElementDOFS
        totalNumberOfRowsElementDOFS=totalNumberOfRowsElementDOFS+numberOfRowsElementParameters(rowComponentIdx)
      ENDDO !rowComponentIdx

      totalNumberOfColsElementDOFS=0
      !Loop over geometric dependent basis functions.
      DO columnComponentIdx=1,numberOfColsComponents
        NULLIFY(colsDomain)
        CALL FieldVariable_ComponentDomainGet(colsVariable,columnComponentIdx,colsDomain,err,error,*999)
        NULLIFY(colsDomainTopology)
        CALL Domain_DomainTopologyGet(colsDomain,colsDomainTopology,err,error,*999)
        NULLIFY(colsDomainElements)
        CALL DomainTopology_DomainElementsGet(colsDomainTopology,colsDomainElements,err,error,*999)
        NULLIFY(colsBasis)
        CALL DomainElements_ElementBasisGet(colsDomainElements,elementNumber,colsBasis,err,error,*999)
        NULLIFY(columnQuadratureSchemes(columnComponentIdx)%ptr)
        CALL Basis_QuadratureSchemeGet(colsBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureSchemes(columnComponentIdx)%ptr, &
          & err,error,*999)
        CALL FieldVariable_ComponentInterpolationGet(colsVariable,columnComponentIdx,colsInterpolationType,err,error,*999)
        SELECT CASE(colsInterpolationType)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          numberOfColsElementParameters(columnComponentIdx)=1
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          CALL Basis_NumberOfElementParametersGet(colsBasis,numberOfColsElementParameters(columnComponentIdx),err,error,*999)
        CASE DEFAULT
          localError="The interpolation type of "//TRIM(NumberToVString(colsInterpolationType,"*",err,error))// &
            & " for col component number "//TRIM(NumberToVString(columnComponentIdx,"*",err,error))//" is not implemented."
          CALL FlagError(localError,err,error,*999)
        END SELECT
        colsElementBaseDOFIndex(columnComponentIdx)=totalNumberOfColsElementDOFS
        totalNumberOfColsElementDOFS=totalNumberOfColsElementDOFS+numberOfColsElementParameters(columnComponentIdx)
      ENDDO !columnComponentIdx

      growthValues=[1.0_DP,1.0_DP,1.0_DP]

      IF(haveHydrostaticPressure) &
        & CALL FieldVariable_ComponentInterpolationGet(colsVariable,pressureComponent,pressureInterpolationType, &
        & err,error,*999)

      !Loop over all Gauss points
      DO gaussPointIdx=1,numberOfGauss
        
        IF(diagnostics1) THEN
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Gauss point : ",gaussPointIdx,err,error,*999)
        ENDIF
        
        !Interpolate dependent, geometric, fibre and materials fields
        CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
          & err,error,*999)
        CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
        CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
          & err,error,*999)
        CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
        IF(ASSOCIATED(fibreField)) &
          & CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
          & err,error,*999)
        IF(ASSOCIATED(materialsField)) & 
          & CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
          & err,error,*999)
        
        CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)
        CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,Jzxi,err,error,*999)
        
        IF(equationsSetSubtype==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
          !!TODO: interpolate the growth field at a Gauss point.
          CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
            & gaussPointIdx,elementNumber,1,growthValues(1),err,error,*999)
          IF(numberofDimensions>1) THEN
            CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
              & gaussPointIdx,elementNumber,2,growthValues(2),err,error,*999)
            IF(numberOfDimensions>2) THEN
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,3,growthValues(3),err,error,*999)
            ENDIF
          ENDIF
        ENDIF
              
        IF(haveHydrostaticPressure) p=dependentInterpPoint%values(pressureComponent,NO_PART_DERIV)
        
        !Loop over dependent basis functions for the displacement variables
        DO columnComponentIdx=1,numberOfDimensions
          CALL BasisQuadratureScheme_GaussWeightGet(columnQuadratureSchemes(columnComponentIdx)%ptr,gaussPointIdx,gaussWeight, &
            & err,error,*999)
          jacobianGaussWeight=Jzxi*gaussWeight
          DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
            !Loop over derivative directions.
            DO rowComponentIdx=1,numberOfDimensions
              sum1=0.0_DP
              DO xiIdx=1,numberOfXi
                CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureSchemes(columnComponentIdx)%ptr, &
                  & columnElementParameterIdx,PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx),gaussPointIdx, &
                  & colsdPhi,err,error,*999)
                sum1=sum1+colsdPhi*dependentInterpPointMetrics%dXidX(xiIdx,rowComponentIdx)
              ENDDO !xiIdx
              dPhidZ(rowComponentIdx,columnElementParameterIdx,columnComponentIdx)=sum1
            ENDDO !rowComponentIdx
          ENDDO !columnElementParameterIdx
        ENDDO !columnComponentIdx

        !Calculate material fibre coordinate system
        CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
          & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
          & fibreVectors(1:numberOfDimensions,1:numberOfXi),err,error,*999)
        !Calculate the deformation gradient tensor
        CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
          & dXidNu(1:numberOfXi,1:numberOfDimensions),F,J,FNu,JNu,err,error,*999)
        
        !Calculate any growth.
        CALL FiniteElasticity_GrowthTensorCalculate(equationsSet,numberOfDimensions,FNu,growthValues,Fg,Fe,Jg,Je,err,error,*999)

        !Calculate the Cauchy stress tensor and the spatial elasticity tensor
        CALL FiniteElasticity_SpatialElasticityTensorCalculate(equationsSet,numberOfDimensions,materialsInterpPoint, &
          & Fe,Je,p,haveHydrostaticPressure,sigma,spatialC,err,error,*999)

        !Convert the Cauchy tensor from Voigt form to tensor form.
        CALL VoigtToTensor(numberOfDimensions,[TENSOR_CONTRAVARIANT_INDEX],sigma,cauchyTensor,err,error,*999)

        !1) loop over rowComponentIdx=columnComponentIdx
        !Loop over element columns belonging to geometric dependent variables
        columnElementDOFIdx=0
        DO columnComponentIdx=1,numberOfDimensions
          jgwSubMatrix(1:numberOfDimensions,1:numberOfDimensions)=jacobianGaussWeight* &
            & (spatialC(TENSOR_TO_VOIGT(1:numberOfDimensions,columnComponentIdx,numberOfDimensions), &
            & TENSOR_TO_VOIGT(1:numberOfDimensions,columnComponentIdx,numberOfDimensions))+ &
            & cauchyTensor(1:numberOfDimensions,1:numberOfDimensions))
          DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
            tempVec(1:numberOfDimensions)=MATMUL(jgwSubMatrix(1:numberOfDimensions,1:numberOfDimensions), &
              & dPhidZ(1:numberOfDimensions,columnElementParameterIdx,columnComponentIdx))
            columnElementDOFIdx=columnElementDOFIdx+1
            rowElementDOFIdx=columnElementDOFIdx-1
            !Loop over element rows belonging to geometric dependent variables
            DO rowElementParameterIdx=columnElementParameterIdx,numberOfColsElementParameters(columnComponentIdx)
              rowElementDOFIdx=rowElementDOFIdx+1
              jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)+ &
                & DOT_PRODUCT(dPhiDZ(1:numberOfDimensions,rowElementParameterIdx,columnComponentIdx), &
                & tempVec(1:numberOfDimensions))
            ENDDO !rowElementParameterIdx
          ENDDO !columnElementParameterIdx
        ENDDO !columnComponentIdx
        
        !2) loop over rowComponentIdx>columnComponentIdx
        !Loop over element columns belonging to geometric dependent variables
        DO offDiagComponentIdx=1,NUMBER_OF_OFF_DIAGONAL_COMPONENTS(numberOfDimensions)
          columnComponentIdx=OFF_DIAG_COLUMN_COMPONENT(offDiagComponentIdx)
          rowComponentIdx=OFF_DIAG_ROW_COMPONENT(offDiagComponentIdx)
          columnElementDOFIdx=colsElementBaseDOFIndex(columnComponentIdx)
          jgwSubMatrix(1:numberOfDimensions,1:numberOfDimensions)=jacobianGaussWeight* &
            & spatialC(TENSOR_TO_VOIGT(1:numberOfDimensions,rowComponentIdx,numberOfDimensions), &
            & TENSOR_TO_VOIGT(1:numberOfDimensions,columnComponentIdx,numberOfDimensions))
          DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
            !Loop over element rows belonging to geometric dependent variables
            tempVec(1:numberOfDimensions)=MATMUL(jgwSubMatrix(1:numberOfDimensions,1:numberOfDimensions), &
              & dPhidZ(1:numberOfDimensions,columnElementParameterIdx,columnComponentIdx))
            columnElementDOFIdx=columnElementDOFIdx+1
            rowElementDOFIdx=rowsElementBaseDOFIndex(rowComponentIdx)
            DO rowElementParameterIdx=1,numberOfRowsElementParameters(rowComponentIdx)
              rowElementDOFIdx=rowElementDOFIdx+1
              jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)+ &
                & DOT_PRODUCT(dPhidZ(1:numberOfDimensions,rowElementParameterIdx,rowComponentIdx),tempVec(1:numberOfDimensions))
            ENDDO !rowElementParameterIdx
          ENDDO !columnElementParameterIdx
        ENDDO !offDiagonalComponentIdx
        
        IF(haveHydrostaticPressure) THEN
          !3) loop over all nh and pressure component
        
          columnElementDOFIdx=0
          SELECT CASE(pressureInterpolationType)
          CASE(FIELD_NODE_BASED_INTERPOLATION) 
            !node based
            !Loop over element rows belonging to geometric dependent variables
            DO columnComponentIdx=1,numberOfDimensions
              CALL BasisQuadratureScheme_GaussWeightGet(columnQuadratureSchemes(columnComponentIdx)%ptr,gaussPointIdx,gaussWeight, &
                & err,error,*999)
              jacobianGaussWeight=Jzxi*gaussWeight
              DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
                jgwdPhiColdZ=jacobianGaussWeight*dPhidZ(columnComponentIdx,columnElementParameterIdx,columnComponentIdx)
                columnElementDOFIdx=columnElementDOFIdx+1
                !Loop over element rows belonging to hydrostatic pressure
                rowElementDOFIdx=rowsElementBaseDOFIndex(pressureComponent)
                DO rowElementParameterIdx=1,numberOfRowsElementParameters(pressureComponent)
                  rowElementDOFIdx=rowElementDOFIdx+1
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowQuadratureSchemes(pressureComponent)%ptr, &
                    & rowElementParameterIdx,NO_PART_DERIV,gaussPointIdx,phiRow,err,error,*999)
                  jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                    &  jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)-jgwdPhiColdZ*phiRow
                ENDDO !rowElementParameterIdx
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            !element based
            !Loop over element rows belonging to geometric dependent variables
            DO columnComponentIdx=1,numberOfDimensions
              CALL BasisQuadratureScheme_GaussWeightGet(columnQuadratureSchemes(columnComponentIdx)%ptr,gaussPointIdx,gaussWeight, &
                & err,error,*999)
              jacobianGaussWeight=Jzxi*gaussWeight
              DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
                jgwdPhiColdZ=JacobianGaussWeight*dPhidZ(columnComponentIdx,columnElementParameterIdx,columnComponentIdx)
                columnElementDOFIdx=columnElementDOFIdx+1
                !Loop over element rows belonging to hydrostatic pressure
                rowElementDOFIdx=rowsElementBaseDOFIndex(pressureComponent)+1
                jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                  & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)-jgwdPhiColdZ
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx
          CASE DEFAULT
            localError="The interpolation type of "//TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
              & " for component "//TRIM(NumberToVString(pressureComponent,"*",err,error))//" is not implemented."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          
          !No loop over element columns and rows belonging both to hydrostatic pressure because it is zero.

        ENDIF
        
      ENDDO !gaussPointIdx
      
      !Scale factor adjustment
      CALL Field_ScalingTypeGet(dependentField,dependentScalingType,err,error,*999)
      IF(dependentScalingType/=FIELD_NO_SCALING) THEN
        !Following call is necessary, otherwise wrong face scale factors from function call to surface pressure jacobian are
        !used.
        NULLIFY(rowsInterpParameters)
        CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,rowsVariableType,rowsInterpParameters, &
          & err,error,*999)
        NULLIFY(colsInterpParameters)
        CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,colsVariableType,colsInterpParameters, &
          & err,error,*999)
        CALL Field_InterpolationParametersScaleFactorsElementGet(elementNumber,rowsInterpParameters,err,error,*999)
        CALL Field_InterpolationParametersScaleFactorsElementGet(elementNumber,colsInterpParameters,err,error,*999)
        columnElementDOFIdx=0          
        ! Loop over element columns
        DO columnComponentIdx=1,numberOfDimensions
          DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
            columnElementDOFIdx=columnElementDOFIdx+1
            rowElementDOFIdx=columnElementDOFIdx-1
            ! Loop over element rows
            DO rowElementParameterIdx=columnElementParameterIdx,numberOfRowsElementParameters(columnComponentIdx)
              rowElementDOFIdx=rowElementDOFIdx+1
              jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)* &
                & rowsInterpParameters%scaleFactors(rowElementParameterIdx,columnComponentIdx)* &
                & colsInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
            ENDDO !rowElementParameterIdx
          ENDDO !columnElementParameterIdx
        ENDDO !columnComponentIdx
        DO offDiagComponentIdx=1,NUMBER_OF_OFF_DIAGONAL_COMPONENTS(numberOfDimensions)
          columnComponentIdx=OFF_DIAG_COLUMN_COMPONENT(offDiagComponentIdx)
          rowComponentIdx=OFF_DIAG_ROW_COMPONENT(offDiagComponentIdx)
          columnElementDOFIdx=colsElementBaseDOFIndex(columnComponentIdx)
          DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
            columnElementDOFIdx=columnElementDOFIdx+1
            rowElementDOFIdx=rowsElementBaseDOFIndex(rowComponentIdx)
            !Loop over element rows belonging to geometric dependent variables
            DO rowElementParameterIdx=1,numberOfRowsElementParameters(rowComponentIdx)
              rowElementDOFIdx=rowElementDOFIdx+1
              jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)=&
                & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)* &
                & rowsInterpParameters%scaleFactors(rowElementParameterIdx,rowComponentIdx)* &
                & colsInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
            ENDDO !rowElementParameterIdx
          ENDDO !columnElementParameterIdx
        ENDDO !offDiagonalComponentIdx

        IF(haveHydrostaticPressure) THEN
       
          columnElementDOFIdx=0
          SELECT CASE(pressureInterpolationType)
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            !node based
            !Loop over element rows belonging to geometric dependent variables
            DO columnComponentIdx=1,numberOfDimensions
              DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
                columnElementDOFIdx=columnElementDOFIdx+1
                !Loop over element rows belonging to hydrostatic pressure
                rowElementDOFIdx=rowsElementBaseDOFIndex(pressureComponent)
                DO rowElementParameterIdx=1,numberOfRowsElementParameters(pressureComponent)
                  rowElementDOFIdx=rowElementDOFIdx+1                  
                  jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                    & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)* &
                    & rowsInterpParameters%scaleFactors(rowElementParameterIdx,pressureComponent)* &
                    & colsInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
                ENDDO !rowElementParameterIdx
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            !element based
            !Loop over element rows belonging to geometric dependent variables
            DO columnComponentIdx=1,numberOfDimensions
              DO columnElementParameteridx=1,numberOfColsElementParameters(columnComponentIdx)
                columnElementDOFIdx=columnElementDOFIdx+1
                !Loop over element rows belonging to hydrostatic pressure
                rowElementDOFIdx=rowsElementBaseDOFIndex(pressureComponent)+1
                jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                  & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)* &
                  & colsInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx
          CASE DEFAULT
            localError="The interpolation type of "//TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
              & " for component "//TRIM(NumberToVString(pressureComponent,"*",err,error))//" is not implemented."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ENDIF
      ENDIF

!!!TODO: Construct lower triangular matrix and mirror that so that the outer loop is rows?
      
      !Mirror the Jacobian matrix.
      DO columnElementDOFIdx=2,totalNumberOfColsElementDOFs
        DO rowElementDOFIdx=1,columnElementDOFIdx-1
          jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
            & jacobianMatrix%elementJacobian%matrix(columnElementDOFIdx,rowElementDOFIdx)
        ENDDO !rowElementDOFIdx
      ENDDO !columnElementDOFIdx

      !Call surface pressure term here: should only be executed if THIS element has surface pressure on it (direct or incremented)
      IF(haveSurfacePressure) CALL FiniteElasticity_SurfacePressureJacobianEvaluate(equationsSet,elementNumber,err,error,*999)
      
    ENDIF !Update Jacobian

    EXITS("FiniteElasticity_FiniteElementJacobianEvaluateNew")
    RETURN
999 ERRORS("FiniteElasticity_FiniteElementJacobianEvaluateNew",err,error)
    EXITS("FiniteElasticity_FiniteElementJacobianEvaluateNew")
    RETURN 1

  END SUBROUTINE FiniteElasticity_FiniteElementJacobianEvaluateNew

  !
  !================================================================================================================================
  !

  !>Evaluates the element Jacobian matrix for the given element number for a finite elasticity class finite element equation set.
  SUBROUTINE FiniteElasticity_FiniteElementJacobianEvaluate(equationsSet,elementNumber,err,error,*)
    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to evaluate the Jacobian for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: colsElementBaseDOFIndex(4),colsVariableType,columnComponentIdx,columnElementParameterIdx, &
      & columnElementDOFIdx,columnInterpolationType,componentIdx,componentIdx2,dependentScalingType,elementBaseDOFIndex(4), &
      & equationsSetSubtype,esSpecification(3),gaussPointIdx,numberOfColsComponents,numberOfColsElementParameters(4), &
      & numberOfDimensions,numberOfElementParameters(4),numberOfGauss,numberOfRowsComponents,numberOfRowsElementParameters(4), &
      & numberOfXi,oh,pressureComponent,pressureInterpolationType,rowComponentIdx,rowsElementBaseDOFIndex(4),rowElementDOFIdx, &
      & rowElementParameterIdx,rowsInterpolationType,rowsVariableType,sumElementParameters,totalNumberOfColsElementDOFs, &
      & totalNumberOfRowsElementDOFs,totalNumSurfacePressureConditions,xiIdx,variableType
    INTEGER(INTG), PARAMETER :: OFF_DIAG_COMP(3)=[0,1,3],OFF_DIAG_DEP_VAR1(3)=[1,1,2],OFF_DIAG_DEP_VAR2(3)=[2,3,3]
    REAL(DP) :: cauchyTensor(3,3),columnPhi,columndPhi,dJdZ(64,3),dNudXi(3,3),dPhidZ(3,64,3),dXidNu(3,3),dZdNu(3,3), &
      & dZdX(3,3),elasticityTensor(6,6),fibreVectors(3,3),FNu(3,3),gaussWeight, &
      & hydroElasticityV(6),hydroElasticityTensor(3,3),jacGaussWeight,jacGaussWeightColumndPhidZ,jacGaussWeightRowdPhidZ, &
      & jacGaussWeightSubMatrix(3,3),JXXi,JZ,JZNu,JZXi,rowPhi,rowdPhi,stressTensor(6),sum1,sum2,tempTerm,tempvec(3)
    LOGICAL :: boundaryElement,haveSurfacePressure,updateJacobian
    TYPE(BasisType), POINTER :: colsBasis,dependentBasis,rowsBasis
    TYPE(BoundaryConditionsVariableType), POINTER :: boundaryConditionsVariable
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: dependentDecomposition
    TYPE(DecompositionElementsType), POINTER :: dependentDecompElements
    TYPE(DecompositionTopologyType), POINTER :: dependentDecompTopology
    TYPE(DomainType), POINTER :: colsDomain,rowsDomain
    TYPE(DomainElementsType), POINTER :: colsDomainElements,rowsDomainElements
    TYPE(DomainTopologyType), POINTER :: colsDomainTopology,rowsDomainTopology
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsInterpolationType), POINTER :: equationsInterpolation
    TYPE(EquationsMappingLHSType), POINTER :: lhsMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingRHSType), POINTER :: rhsMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: dependentField,geometricField,materialsField,fibreField,independentField
    TYPE(FieldInterpolatedPointType), POINTER :: geometricInterpPoint,fibreInterpPoint,materialsInterpPoint, &
      & dependentInterpPoint,independentInterpPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: geometricInterpPointMetrics,dependentInterpPointMetrics
    TYPE(FieldInterpolationParametersType), POINTER :: colsInterpParameters,dependentInterpParameters,fibreInterpParameters, &
      & geometricInterpParameters,independentInterpParameters,materialsInterpParameters,rowsInterpParameters
    TYPE(FieldVariableType), POINTER :: colsVariable,fieldVariable,materialsVariable,rhsVariable,rowsVariable
    TYPE(JacobianMatrixType), POINTER :: jacobianMatrix
    TYPE(QuadratureSchemeType), POINTER :: columnQuadratureScheme,dependentQuadratureScheme
    TYPE(QuadratureSchemePtrType) :: columnQuadratureSchemes(4),quadratureSchemes(4),rowQuadratureSchemes(4)
    TYPE(RegionType), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_FiniteElementJacobianEvaluate",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)
    equationsSetSubtype = esSpecification(3)

    SELECT CASE(equationsSetSubtype)
    CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE, &
      & EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE, &
      & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE)
      
      CALL FiniteElasticity_FiniteElementJacobianEvaluateNew(equationsSet,elementNumber,err,error,*999)
      
    CASE DEFAULT

      NULLIFY(equations)
      CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
      NULLIFY(vectorEquations)
      CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
      NULLIFY(vectorMatrices)
      CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
      NULLIFY(nonlinearMatrices)
      CALL EquationsMatricesVector_NonlinearMatricesGet(vectorMatrices,nonlinearMatrices,err,error,*999)
      NULLIFY(residualVector)
      CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,1,residualVector,err,error,*999)
      NULLIFY(jacobianMatrix)
      CALL EquationsMatricesResidual_JacobianMatrixGet(residualVector,1,jacobianMatrix,err,error,*999)
      updateJacobian=jacobianMatrix%updateJacobian
      
      IF(updateJacobian) THEN

        NULLIFY(region)
        CALL EquationsSet_RegionGet(equationsSet,region,err,error,*999)
        NULLIFY(coordinateSystem)
        CALL Region_CoordinateSystemGet(region,coordinateSystem,err,error,*999)
        CALL CoordinateSystem_DimensionGet(coordinateSystem,numberOfDimensions,err,error,*999)
        
        NULLIFY(lhsMapping)
        CALL EquationsMappingVector_LHSMappingGet(vectorMapping,lhsMapping,err,error,*999)
        NULLIFY(vectorMapping)
        CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
        NULLIFY(nonlinearMapping)
        CALL EquationsMappingVector_NonlinearMappingGet(vectorMapping,nonlinearMapping,err,error,*999)
        NULLIFY(residualMapping)
        CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,1,residualMapping,err,error,*999)
        NULLIFY(rhsMapping)
        CALL EquationsMappingVector_RHSMappingGet(vectorMapping,rhsMapping,err,error,*999)
        NULLIFY(rhsVariable)
        CALL EquationsMappingRHS_RHSVariableGet(rhsMapping,rhsVariable,err,error,*999)
        NULLIFY(equationsInterpolation)
        CALL Equations_InterpolationGet(equations,equationsInterpolation,err,error,*999)
        
        NULLIFY(geometricField)
        NULLIFY(dependentField)
        IF(equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE) THEN
          CALL EquationsSet_GeometricFieldGet(equationsSet,dependentField,err,error,*999)
          CALL EquationsSet_DependentFieldGet(equationsSet,geometricField,err,error,*999)
        ELSE
          CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
          CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
        ENDIF
        NULLIFY(materialsField)
        CALL EquationsSet_MaterialsFieldExists(equationsSet,materialsField,err,error,*999)
        NULLIFY(fibreField)
        CALL EquationsSet_FibreFieldExists(equationsSet,fibreField,err,error,*999)
        NULLIFY(independentField)
        CALL EquationsSet_IndependentFieldExists(equationsSet,independentField,err,error,*999)
 
        NULLIFY(dependentDecomposition)
        CALL Field_DecompositionGet(dependentField,dependentDecomposition,err,error,*999)
        NULLIFY(dependentDecompTopology)
        CALL Decomposition_DecompositionTopologyGet(dependentDecomposition,dependentDecompTopology,err,error,*999)
        NULLIFY(dependentDecompElements)
        CALL DecompositionTopology_DecompositionElementsGet(dependentDecompTopology,dependentDecompElements,err,error,*999)
        NULLIFY(colsDomain)
        CALL Decomposition_DomainGet(dependentDecomposition,0,colsDomain,err,error,*999)
        NULLIFY(colsDomainTopology)
        CALL Domain_DomainTopologyGet(colsDomain,colsDomainTopology,err,error,*999)
        NULLIFY(colsDomainElements)
        CALL DomainTopology_DomainElementsGet(colsDomainTopology,colsDomainElements,err,error,*999)
        NULLIFY(colsBasis)
        CALL DomainElements_ElementBasisGet(colsDomainElements,elementNumber,colsBasis,err,error,*999)
        
        NULLIFY(rowsVariable)
        CALL EquationsMappingLHS_LHSVariableGet(lhsMapping,rowsVariable,err,error,*999)
        CALL FieldVariable_NumberOfComponentsGet(rowsVariable,numberOfRowsComponents,err,error,*999)
        
        NULLIFY(colsVariable)
        CALL EquationsMappingResidual_VariableGet(residualMapping,1,colsVariable,err,error,*999)
        CALL FieldVariable_VariableTypeGet(colsVariable,colsVariableType,err,error,*999)
        CALL FieldVariable_NumberOfComponentsGet(colsVariable,numberOfColsComponents,err,error,*999)
        
        NULLIFY(columnQuadratureScheme)
        CALL Basis_QuadratureSchemeGet(colsBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureScheme,err,error,*999)
        CALL BasisQuadratureScheme_NumberOfGaussGet(columnQuadratureScheme,numberOfGauss,err,error,*999)
        CALL Basis_NumberOfXiGet(colsBasis,numberOfXi,err,error,*999)
        
!!TODO: Need to fix this as equations sets shouldn't know about boundary conditions.      
        boundaryConditions=>equationsSet%boundaryConditions
        NULLIFY(boundaryConditionsVariable)
        CALL BoundaryConditions_VariableGet(boundaryConditions,rhsVariable,boundaryConditionsVariable,err,error,*999)
        totalNumSurfacePressureConditions=boundaryConditionsVariable%dofCounts(BOUNDARY_CONDITION_PRESSURE)+ &
          & boundaryConditionsVariable%dofCounts(BOUNDARY_CONDITION_PRESSURE_INCREMENTED)
        
        CALL DecompositionElements_ElementBoundaryElementGet(dependentDecompElements,elementNumber,boundaryElement,err,error,*999)
        haveSurfacePressure=boundaryElement.AND.totalNumSurfacePressureConditions>0      
           
        !Grab interpolation parameters, points and metrics.
        NULLIFY(geometricInterpParameters)
        NULLIFY(geometricInterpPoint)
        NULLIFY(geometricInterpPointMetrics)
        NULLIFY(dependentInterpParameters)
        NULLIFY(dependentInterpPoint)
        NULLIFY(dependentInterpPointMetrics)
        IF(equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE) THEN
          CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & dependentInterpParameters,err,error,*999)
          CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & dependentInterpPoint,err,error,*999)
          CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & dependentInterpPointMetrics,err,error,*999)
          CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,colsVariableType, &
            & geometricInterpParameters,err,error,*999)
          CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,colsVariableType, &
            & geometricInterpPoint,err,error,*999)
          CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,colsVariableType, &
            & geometricInterpPointMetrics,err,error,*999)
        ELSE
          CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & geometricInterpParameters,err,error,*999)
          CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & geometricInterpPoint,err,error,*999)
          CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & geometricInterpPointMetrics,err,error,*999)
          CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,colsVariableType, &
            & dependentInterpParameters,err,error,*999)
          CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,colsVariableType, &
            & dependentInterpPoint,err,error,*999)
          CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,colsVariableType, &
            & dependentInterpPointMetrics,err,error,*999)
        ENDIF
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,geometricInterpParameters,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,dependentInterpParameters,err,error,*999)
        NULLIFY(fibreInterpParameters)
        NULLIFY(fibreInterpPoint)
        IF(ASSOCIATED(fibreField)) THEN
          CALL EquationsInterpolation_FibreParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,fibreInterpParameters, &
            & err,error,*999)
          CALL EquationsInterpolation_FibrePointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,fibreInterpPoint,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,fibreInterpParameters,err,error,*999)
        ENDIF
        NULLIFY(materialsInterpParameters)
        NULLIFY(materialsInterpPoint)
        NULLIFY(materialsVariable)
        IF(ASSOCIATED(materialsField)) THEN
          CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & materialsInterpParameters,err,error,*999)
          CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & materialsInterpPoint,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,materialsInterpParameters,err,error,*999)
          CALL Field_VariableGet(materialsField,FIELD_U_VARIABLE_TYPE,materialsVariable,err,error,*999)      
        ENDIF
        NULLIFY(independentInterpParameters)
        NULLIFY(independentInterpPoint)
        IF(ASSOCIATED(independentField)) THEN
          CALL EquationsInterpolation_IndependentParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & independentInterpParameters,err,error,*999)
          CALL EquationsInterpolation_IndependentPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & independentInterpPoint,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,independentInterpParameters, &
            & err,error,*999)
        ENDIF
                    
        totalNumberOfRowsElementDOFS=0        
        !Loop over geometric dependent basis functions.
        DO rowComponentIdx=1,numberOfRowsComponents
          NULLIFY(rowsDomain)
          CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowsDomain,err,error,*999)
          NULLIFY(rowsDomainTopology)
          CALL Domain_DomainTopologyGet(rowsDomain,rowsDomainTopology,err,error,*999)
          NULLIFY(rowsDomainElements)
          CALL DomainTopology_DomainElementsGet(rowsDomainTopology,rowsDomainElements,err,error,*999)
          NULLIFY(rowsBasis)
          CALL DomainElements_ElementBasisGet(rowsDomainElements,elementNumber,rowsBasis,err,error,*999)
          NULLIFY(rowQuadratureSchemes(rowComponentIdx)%ptr)
          CALL Basis_QuadratureSchemeGet(rowsBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowQuadratureSchemes(rowComponentIdx)%ptr, &
            & err,error,*999)
          CALL FieldVariable_ComponentInterpolationGet(rowsVariable,rowComponentIdx,rowsInterpolationType,err,error,*999)
          SELECT CASE(rowsInterpolationType)
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            numberOfRowsElementParameters(rowComponentIdx)=1
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            CALL Basis_NumberOfElementParametersGet(rowsBasis,numberOfRowsElementParameters(rowComponentIdx),err,error,*999)
          CASE DEFAULT
            localError="The interpolation type of "//TRIM(NumberToVString(rowsInterpolationType,"*",err,error))// &
              & " for row component number "//TRIM(NumberToVString(rowComponentIdx,"*",err,error))//" is not implemented."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          rowsElementBaseDOFIndex(rowComponentIdx)=totalNumberOfRowsElementDOFS
          totalNumberOfRowsElementDOFS=totalNumberOfRowsElementDOFS+numberOfRowsElementParameters(rowComponentIdx)
        ENDDO !rowComponentIdx
        
        totalNumberOfColsElementDOFS=0
        !Loop over geometric dependent basis functions.
        DO columnComponentIdx=1,numberOfColsComponents
          NULLIFY(colsDomain)
          CALL FieldVariable_ComponentDomainGet(colsVariable,columnComponentIdx,colsDomain,err,error,*999)
          NULLIFY(colsDomainTopology)
          CALL Domain_DomainTopologyGet(colsDomain,colsDomainTopology,err,error,*999)
          NULLIFY(colsDomainElements)
          CALL DomainTopology_DomainElementsGet(colsDomainTopology,colsDomainElements,err,error,*999)
          NULLIFY(colsBasis)
          CALL DomainElements_ElementBasisGet(colsDomainElements,elementNumber,colsBasis,err,error,*999)
          NULLIFY(columnQuadratureSchemes(columnComponentIdx)%ptr)
          CALL Basis_QuadratureSchemeGet(colsBasis,BASIS_DEFAULT_QUADRATURE_SCHEME, &
            & columnQuadratureSchemes(columnComponentIdx)%ptr,err,error,*999)
          CALL FieldVariable_ComponentInterpolationGet(colsVariable,columnComponentIdx,columnInterpolationType,err,error,*999)
          SELECT CASE(columnInterpolationType)
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            numberOfColsElementParameters(columnComponentIdx)=1
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            CALL Basis_NumberOfElementParametersGet(colsBasis,numberOfColsElementParameters(columnComponentIdx),err,error,*999)
          CASE DEFAULT
            localError="The interpolation type of "//TRIM(NumberToVString(columnInterpolationType,"*",err,error))// &
              & " for col component number "//TRIM(NumberToVString(columnComponentIdx,"*",err,error))//" is not implemented."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          colsElementBaseDOFIndex(columnComponentIdx)=totalNumberOfColsElementDOFS
          totalNumberOfColsElementDOFS=totalNumberOfColsElementDOFS+numberOfColsElementParameters(columnComponentIdx)
        ENDDO !columnComponentIdx
       
        pressureComponent=numberOfColsComponents
        CALL FieldVariable_ComponentInterpolationGet(colsVariable,pressureComponent,pressureInterpolationType,err,error,*999)

        !Loop over all Gauss points
        DO gaussPointIdx=1,numberOfGauss
          
          CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
            & err,error,*999)
          CALL Field_InterpolatedPointMetricsCalculate(COORDINATE_JACOBIAN_VOLUME_TYPE,geometricInterpPointMetrics,err,error,*999)
          CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
            & err,error,*999)
          CALL Field_InterpolatedPointMetricsCalculate(COORDINATE_JACOBIAN_VOLUME_TYPE,dependentInterpPointMetrics,err,error,*999)
          IF(ASSOCIATED(materialsField)) & 
            & CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
            & err,error,*999)
          IF(ASSOCIATED(fibreField)) THEN
            CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint,err,error,*999)
          ENDIF

          CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)
          CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,Jzxi,err,error,*999)
          Jznu=Jzxi/Jxxi

!!TODO: Loop over Rows as the outer loop then columns.
          
          !Loop over geometric dependent basis functions.
          DO columnComponentIdx=1,numberOfDimensions
            CALL BasisQuadratureScheme_GaussWeightGet(columnQuadratureSchemes(columnComponentIdx)%ptr,gaussPointIdx, &
              & gaussWeight,err,error,*999)
            jacGaussWeight=Jzxi*gaussWeight
            DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
              !Loop over derivative directions.
              sum2=0.0_DP
              DO rowComponentIdx=1,numberOfDimensions
                sum1=0.0_DP
                DO xiIdx=1,numberOfXi
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureSchemes(columnComponentIdx)%ptr, &
                    & columnElementParameterIdx,PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx),gaussPointIdx, &
                    & columndPhi,err,error,*999)
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowQuadratureSchemes(rowComponentIdx)%ptr, &
                    & rowElementParameterIdx,PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx),gaussPointIdx, &
                    & rowdPhi,err,error,*999)
                  sum1=sum1+columndPhi*dependentInterpPointMetrics%dXidX(xiIdx,rowComponentIdx)
                  sum2=sum2+rowdPhi*dependentInterpPointMetrics%dXidX(xiIdx,rowComponentIdx)* &
                    & dependentInterpPointMetrics%gu(xiIdx,rowComponentIdx)
                ENDDO !xiIdx
                dPhidZ(rowComponentIdx,columnElementParameterIdx,columnComponentIdx)=sum1
              ENDDO !rowComponentIdx
              dJdZ(columnElementParameterIdx,columnComponentIdx)=sum2*Jzxi
            ENDDO !columnElementParameterIdx
          ENDDO !columnComponentIdx
          
          !Calculate material fibre coordinate system
          CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
            & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
            & fibreVectors(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
          !Calculate the deformation gradient tensor
          CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
            & dXidNu(1:numberOfXi,1:numberOfDimensions),dZdX,JZ,FNu,JZNu,err,error,*999)
          
          CALL FiniteElasticity_GaussElasticityTensor(equationsSet,numberOfDimensions,dependentInterpPoint, &
            & materialsInterpPoint,independentInterpPoint,elasticityTensor,hydroElasticityV,stressTensor, &
            & dZdNu,Jznu,elementNumber,gaussPointIdx,err,error,*999)
          
          !Convert from Voigt form to tensor form.
          DO columnComponentIdx=1,numberOfDimensions
            DO rowComponentIdx=1,numberOfDimensions
              cauchyTensor(rowComponentIdx,columnComponentIdx)=stressTensor(TENSOR_TO_VOIGT3(rowComponentIdx,columnComponentIdx))
              hydroElasticityTensor(rowComponentIdx,columnComponentIdx)= &
                & hydroElasticityV(TENSOR_TO_VOIGT3(rowComponentIdx,columnComponentIdx))
            ENDDO !rowComponentIdx
          ENDDO !columnComponentIdx

          !1) loop over rowComponentIdx=columnComponentIdx
          !Loop over element columns belonging to geometric dependent variables
          columnElementDOFIdx=0
          DO columnComponentIdx=1,numberOfDimensions
            CALL BasisQuadratureScheme_GaussWeightGet(columnQuadratureSchemes(columnComponentIdx)%ptr,gaussPointIdx, &
              & gaussWeight,err,error,*999)
            jacGaussWeight=Jzxi*gaussWeight
            jacGaussWeightSubMatrix(1:numberOfDimensions,1:numberOfDimensions)=jacGaussWeight* &
              & (elasticityTensor(TENSOR_TO_VOIGT(1:numberOfDimensions,columnComponentIdx,numberOfDimensions), &
              & TENSOR_TO_VOIGT(1:numberOfDimensions,columnComponentIdx,numberOfDimensions))+ &
              & cauchyTensor(1:numberOfDimensions,1:numberOfDimensions))              
            DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
              tempvec(1:numberOfDimensions)=MATMUL(jacGaussWeightSubMatrix(1:numberOfDimensions,1:numberOfDimensions), &
                & dPhidZ(1:numberOfDimensions,columnElementParameterIdx,columnComponentIdx))
              columnElementDOFIdx=columnElementDOFIdx+1
              rowElementDOFIdx=columnElementDOFIdx-1
              !Loop over element rows belonging to geometric dependent variables
              DO rowElementParameterIdx=columnElementParameterIdx,numberOfRowsElementParameters(columnComponentIdx)
                rowElementDOFIdx=rowElementDOFIdx+1
                jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                  & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)+ &
                  & DOT_PRODUCT(dPhiDZ(1:numberOfDimensions,rowElementParameterIdx,columnComponentIdx), &
                  & tempvec(1:numberOfDimensions))
                DO componentIdx=1,numberOfDimensions
                  DO componentIdx2=1,numberOfDimensions
                    tempTerm=cauchyTensor(componentIdx,componentIdx2)* &
                      & dPhidZ(componentIdx2,rowElementParameterIdx,componentIdx)
                  ENDDO !componentIdx2
                ENDDO !componentIdzxx1
              ENDDO !rowElementParameterIdx
            ENDDO !columnElementParameterIdx
          ENDDO !columnComponentIdx
          
          !2) loop over rowComponentIdx>columnComponentIdx
          !Loop over element columcolumnElementParameterIdx belonging to geometric dependent variables
          DO oh=1,OFF_DIAG_COMP(numberOfDimensions)
            columnComponentIdx=OFF_DIAG_DEP_VAR1(oh)
            rowComponentIdx=OFF_DIAG_DEP_VAR2(oh)
            columnElementDOFIdx=colsElementBaseDOFIndex(columnComponentIdx)
            CALL BasisQuadratureScheme_GaussWeightGet(columnQuadratureSchemes(columnComponentIdx)%ptr,gaussPointIdx, &
              & gaussWeight,err,error,*999)
            jacGaussWeight=Jzxi*gaussWeight
            jacGaussWeightSubMatrix=jacGaussWeight*(elasticityTensor(TENSOR_TO_VOIGT3(1:numberOfDimensions,rowComponentIdx), &
              & TENSOR_TO_VOIGT3(1:numberOfDimensions,columnComponentIdx)))
            
            DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
              !Loop over element rows belonging to geometric dependent variables
              tempvec(1:numberOfDimensions)=MATMUL(jacGaussWeightSubMatrix(1:numberOfDimensions,1:numberOfDimensions), &
                & dPhidZ(1:numberOfDimensions,columnElementParameterIdx,columnComponentIdx))
              columnElementDOFIdx=columnElementDOFIdx+1
              rowElementDOFIdx=rowsElementBaseDOFIndex(rowComponentIdx)
              DO rowElementParameterIdx=1,numberOfRowsElementParameters(rowComponentIdx)
                rowElementDOFIdx=rowElementDOFIdx+1
                jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                  & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)+ &
                  & DOT_PRODUCT(dPhidZ(1:numberOfDimensions,rowElementParameterIdx,rowComponentIdx),tempvec(1:numberOfDimensions))
                DO componentIdx=1,numberOfDimensions
                  DO componentIdx2=1,numberOfDimensions
                    tempTerm=cauchyTensor(componentIdx,componentIdx2)* &
                      & dPhidZ(componentIdx2,rowElementParameterIdx,componentIdx)
                  ENDDO
                ENDDO
                !jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                !  & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)+ &
                !  & tempTerm*dJdZ(rowElementParameterIdx,columnComponentIdx)*dependentQuadratureScheme%gaussWeights(gaussPointIdx)
              ENDDO !rowElementParameterIdx
            ENDDO !columnElementParameterIdx
          ENDDO !oh
          
          !3) loop over all columnComponentIdx and pressure component
          columnElementDOFIdx=0
          SELECT CASE(pressureInterpolationType)
          CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
            !Loop over element rows belonging to geometric dependent variables
            DO columnComponentIdx=1,numberOfDimensions
              CALL BasisQuadratureScheme_GaussWeightGet(columnQuadratureSchemes(columnComponentIdx)%ptr,gaussPointIdx, &
                & gaussWeight,err,error,*999)
              jacGaussWeight=Jzxi*gaussWeight
              DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
                jacGaussWeightColumndPhidZ=jacGaussWeight*dPhidZ(columnComponentIdx,columnElementParameterIdx,columnComponentIdx)
                columnElementDOFIdx=columnElementDOFIdx+1
                !Loop over element rows belonging to hydrostatic pressure
                rowElementDOFIdx=rowsElementBaseDOFIndex(pressureComponent)
                DO rowElementParameterIdx=1,numberOfRowsElementParameters(pressureComponent)
                  rowElementDOFIdx=rowElementDOFIdx+1
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowQuadratureSchemes(columnComponentIdx)%ptr, &
                    & rowElementParameterIdx,NO_PART_DERIV,gaussPointIdx,rowPhi,err,error,*999)
                  jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                    & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)+jacGaussWeightColumndPhidZ*rowPhi
                ENDDO !rowElementParameterIdx
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION) !element based
            !Loop over element rows belonging to geometric dependent variables
            DO columnComponentIdx=1,numberOfDimensions
              CALL BasisQuadratureScheme_GaussWeightGet(columnQuadratureSchemes(columnComponentIdx)%ptr,gaussPointIdx, &
                & gaussWeight,err,error,*999)
              jacGaussWeight=Jzxi*gaussWeight
              DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
                jacGaussWeightColumndPhidZ=jacGaussWeight*dPhidZ(columnComponentIdx,columnElementParameterIdx,columnComponentIdx)
                columnElementDOFIdx=columnElementDOFIdx+1
                !Loop over element rows belonging to hydrostatic pressure
                rowElementDOFIdx=rowsElementBaseDOFIndex(pressureComponent)+1
                jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                  & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)+jacGaussWeightColumndPhidZ
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx
          CASE DEFAULT
            localError="The interpolation type of "//TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
              & " for pressure component number "//TRIM(NumberToVString(pressureComponent,"*",err,error))//" is not implemented."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          
          !4) Loop over all rowComponentIdx pressure component
          rowElementDOFIdx=0
          SELECT CASE(pressureInterpolationType)
          CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
            !Loop over element columns belonging to geometric dependent variables.
            DO rowComponentIdx=1,numberOfDimensions
              DO rowElementParameterIdx=1,numberOfRowsElementParameters(rowComponentIdx)
                !tempvec=MATMUL(hydroElasticityTensor,dPhidZ(:,rowElementParameterIdx,rowComponentIdx))
                !jacGaussWeightRowdPhidZ=jacGaussWeight*tempvec(rowComponentIdx)
                jacGaussWeightRowdPhidZ=jacGaussWeight*dPhidZ(rowComponentIdx,rowElementParameterIdx,rowComponentIdx)
                rowElementDOFIdx=rowElementDOFIdx+1
                !Loop over element columns belonging to hydrostatic pressure
                columnElementDOFIdx=colsElementBaseDOFIndex(pressureComponent)
                DO columnElementParameterIdx=1,numberOfColsElementParameters(pressureComponent)
                  columnElementDOFIdx=columnElementDOFIdx+1
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureSchemes(pressureComponent)%ptr, &
                    & columnElementParameterIdx,NO_PART_DERIV,gaussPointIdx,columnPhi,err,error,*999)
                  jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                    & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)+jacGaussWeightRowdPhidZ*columnPhi
                ENDDO !columnElementParameterIdx
              ENDDO !rowElementParameterIdx
            ENDDO !rowComponentIdx
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION) !element based
            !Loop over element columns belonging to geometric dependent variables.
            DO rowComponentIdx=1,numberOfDimensions
              CALL BasisQuadratureScheme_GaussWeightGet(rowQuadratureSchemes(rowComponentIdx)%ptr,gaussPointIdx, &
                & gaussWeight,err,error,*999)
              jacGaussWeight=Jzxi*gaussWeight
              DO rowElementParameterIdx=1,numberOfRowsElementParameters(rowComponentIdx)
                !tempvec=MATMUL(hydroElasticityTensor,dPhidZ(:,rowElementParameterIdx,rowComponentIdx))
                !jacGaussWeightRowdPhidZ=jacGaussWeight*tempvec(rowComponentIdx)
                jacGaussWeightRowdPhidZ=jacGaussWeight*dPhidZ(rowComponentIdx,rowElementParameterIdx,rowComponentIdx)
                rowElementDOFIdx=rowElementDOFIdx+1
                !Loop over element columns belonging to hydrostatic pressure.
                columnElementDOFIdx=colsElementBaseDOFIndex(pressureComponent)+1
                jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                  & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)+jacGaussWeightRowdPhidZ
              ENDDO !rowElementParameterIdx
            ENDDO !rowComponentIdx
          CASE DEFAULT
            localError="The interpolation type of "//TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
              & " for pressure component number "//TRIM(NumberToVString(pressureComponent,"*",err,error))//" is not implemented."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          ! No loop over element columns and rows belonging both to hydrostatic pressure because it is zero.
        ENDDO !gaussPointIdx
        
        !Scale factor adjustment
        CALL Field_ScalingTypeGet(dependentField,dependentScalingType,err,error,*999)
        IF(dependentScalingType/=FIELD_NO_SCALING) THEN
          !Following call is necessary, otherwise wrong face scale factors from function call to surface pressure jacobian are
          !used.
          NULLIFY(rowsInterpParameters)
          CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,rowsVariableType,rowsInterpParameters, &
            & err,error,*999)
          NULLIFY(colsInterpParameters)
          CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,colsVariableType,colsInterpParameters, &
            & err,error,*999)
          CALL Field_InterpolationParametersScaleFactorsElementGet(elementNumber,rowsInterpParameters,err,error,*999)
          CALL Field_InterpolationParametersScaleFactorsElementGet(elementNumber,colsInterpParameters,err,error,*999)
          columnElementDOFIdx=0          
          ! Loop over element columns
          DO columnComponentIdx=1,numberOfDimensions
            DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
              columnElementDOFIdx=columnElementDOFIdx+1
              rowElementDOFIdx=columnElementDOFIdx-1
              ! Loop over element rows
              DO rowElementParameterIdx=columnElementParameterIdx,numberOfRowsElementParameters(columnComponentIdx)
                rowElementDOFIdx=rowElementDOFIdx+1
                jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                  & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)* &
                  & rowsInterpParameters%scaleFactors(rowElementParameterIdx,columnComponentIdx)* &
                  & colsInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
              ENDDO !rowElementParameterIdx
            ENDDO !columnElementParameterIdx
          ENDDO !columnComponentIdx
          DO oh=1,OFF_DIAG_COMP(numberOfDimensions)
            columnComponentIdx=OFF_DIAG_DEP_VAR1(oh)
            rowComponentIdx=OFF_DIAG_DEP_VAR2(oh)
            columnElementDOFIdx=colsElementBaseDOFIndex(columnComponentIdx)
            DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
              columnElementDOFIdx=columnElementDOFIdx+1
              rowElementDOFIdx=rowsElementBaseDOFIndex(rowComponentIdx)
              !Loop over element rows belonging to geometric dependent variables
              DO rowElementParameterIdx=1,numberOfRowsElementParameters(rowComponentIdx)
                rowElementDOFIdx=rowElementDOFIdx+1
                jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                  & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)* &
                  & rowsInterpParameters%scaleFactors(rowElementParameterIdx,rowComponentIdx)* &
                  & colsInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
              ENDDO !rowElementParameterIdx    
            ENDDO !columnElementParameterIdx
          ENDDO !oh
          
          columnElementDOFIdx=0
          SELECT CASE(pressureInterpolationType)
          CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
            !Loop over element rows belonging to geometric dependent variables
            DO columnComponentIdx=1,numberOfDimensions
              DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
                columnElementDOFIdx=columnElementDOFIdx+1
                !Loop over element rows belonging to hydrostatic pressure
                rowElementDOFIdx=rowsElementBaseDOFIndex(pressureComponent)
                DO rowElementParameterIdx=1,numberOfRowsElementParameters(pressureComponent)
                  rowElementDOFIdx=rowElementDOFIdx+1
                  jacobianMatrix%elementJacobian%matrix(columnElementDOFIdx,rowElementDOFIdx)= &
                    & jacobianMatrix%elementJacobian%matrix(columnElementDOFIdx,rowElementDOFIdx)* &
                    & rowsInterpParameters%scaleFactors(rowElementParameterIdx,pressureComponent)* &
                    & colsInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
                  jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                    & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)* &
                    & rowsInterpParameters%scaleFactors(rowElementParameterIdx,pressureComponent)* &
                    & colsInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
                ENDDO !rowElementParameterIdx    
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION) !element based
            !Loop over element rows belonging to geometric dependent variables
            DO columnComponentIdx=1,numberOfDimensions
              DO columnElementParameterIdx=1,numberOfColsElementParameters(columnComponentIdx)
                columnElementDOFIdx=columnElementDOFIdx+1
                !Loop over element rows belonging to hydrostatic pressure
                rowElementDOFIdx=rowsElementBaseDOFIndex(pressureComponent)+1
                jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                  & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)* &
                  & colsInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx
          CASE DEFAULT
            localError="The interpolation type of "//TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
              & " for pressure component number "//TRIM(NumberToVString(pressureComponent,"*",err,error))//" is not implemented."
            CALL FlagError(localError,err,error,*999)              
          END SELECT
        ENDIF

        !Mirror the Jacobian matrix except for the hydrostatic rows and columns, which are not necessarily symmetric.
        DO columnElementDOFIdx=2,elementBaseDOFIndex(pressureComponent)
          DO rowElementDOFIdx=1,columnElementDOFIdx-1
            jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
              & jacobianMatrix%elementJacobian%matrix(columnElementDOFIdx,rowElementDOFIdx)
          ENDDO !rowElementDOFIdx
        ENDDO !columnElementDOFIdx
        
        !If unsymmetric pressure Jacobian uncomment this.
        !Call surface pressure term here: should only be executed if THIS element has surface pressure on it (direct or incremented)
        IF(haveSurfacePressure) CALL FiniteElasticity_SurfacePressureJacobianEvaluate(equationsSet,elementNumber,err,error,*999)
      ENDIF
      
    END SELECT

    EXITS("FiniteElasticity_FiniteElementJacobianEvaluate")
    RETURN
999 ERRORS("FiniteElasticity_FiniteElementJacobianEvaluate",err,error)
    EXITS("FiniteElasticity_FiniteElementJacobianEvaluate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_FiniteElementJacobianEvaluate

  !
  !================================================================================================================================
  !

  !>Push-forward the rank 4 elasticity tensor.
  SUBROUTINE FiniteElasticity_PushElasticityTensor(elasticityTensor,F,J,err,error,*)
    
    !Argument variables
    REAL(DP), INTENT(INOUT) :: elasticityTensor(6,6) !<The elasticity tensor to push forward in Voigt form
    REAL(DP), INTENT(IN) :: F(3,3) !<The deformation gradient tensor
    REAL(DP), INTENT(IN) :: J !<The Jacobian of the deformation i.e., J = det F.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: rowIdx,columnIdx
    REAL(DP) :: t(6,6),ttrans(6,6) 

    ENTERS("FiniteElasticity_PushElasticityTensor",err,error,*999)

    DO columnIdx=1,3
      DO rowIdx=1,6
        t(rowIdx,columnIdx)=F(VOIGT_TO_TENSOR3(1,rowIdx),VOIGT_TO_TENSOR3(1,columnIdx))* &
          & F(VOIGT_TO_TENSOR3(2,rowIdx),VOIGT_TO_TENSOR3(2,columnIdx))
      ENDDO !rowIdx
    ENDDO !columnIdx
    DO columnIdx=4,6
      DO rowIdx=1,6
        t(rowIdx,columnIdx)=F(VOIGT_TO_TENSOR3(1,rowIdx),VOIGT_TO_TENSOR3(1,columnIdx))* &
          & F(VOIGT_TO_TENSOR3(2,rowIdx),VOIGT_TO_TENSOR3(2,columnIdx))+ &
          & F(VOIGT_TO_TENSOR3(1,rowIdx),VOIGT_TO_TENSOR3(2,columnIdx))* &
          & F(VOIGT_TO_TENSOR3(2,rowIdx),VOIGT_TO_TENSOR3(1,columnIdx))
      ENDDO !rowIdx
    ENDDO !columnIdx

    CALL MatrixTranspose(t,ttrans,err,error,*999)
    elasticityTensor=MATMUL(MATMUL(t,elasticityTensor),ttrans)/J

    EXITS("FiniteElasticity_PushElasticityTensor")
    RETURN
999 ERRORSEXITS("FiniteElasticity_PushElasticityTensor",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_PushElasticityTensor

  !
  !================================================================================================================================
  !

  !>Push-forward the rank 2 Piola stress tensor.
  SUBROUTINE FiniteElasticity_PushStressTensor(stressTensor,F,J,err,error,*)
    
    !Argument variables
    REAL(DP), INTENT(INOUT) :: stressTensor(6) !<The stress tensor in Voigt form to push forward
    REAL(DP), INTENT(IN) :: F(3,3) !<The deformation gradient tensor
    REAL(DP), INTENT(IN) :: J !<The Jacobian of the deformation i.e., J = det F
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: rowIdx,columnIdx
    REAL(DP) :: t(6,6)

    ENTERS("FiniteElasticity_PushStressTensor",err,error,*999)

    DO columnIdx=1,3
      DO rowIdx=1,6
        t(rowIdx,columnIdx)=F(VOIGT_TO_TENSOR3(1,rowIdx),VOIGT_TO_TENSOR3(1,columnIdx))* &
          & F(VOIGT_TO_TENSOR3(2,rowIdx),VOIGT_TO_TENSOR3(2,columnIdx))
      ENDDO !rowIdx
    ENDDO !columnIdx
    DO columnIdx=4,6
      DO rowIdx=1,6
        t(rowIdx,columnIdx)=F(VOIGT_TO_TENSOR3(1,rowIdx),VOIGT_TO_TENSOR3(1,columnIdx))* &
          & F(VOIGT_TO_TENSOR3(2,rowIdx),VOIGT_TO_TENSOR3(2,columnIdx))+ &
          & F(VOIGT_TO_TENSOR3(1,rowIdx),VOIGT_TO_TENSOR3(2,columnIdx))* &
          & F(VOIGT_TO_TENSOR3(2,rowIdx),VOIGT_TO_TENSOR3(1,columnIdx))
      ENDDO !rowIdx
    ENDDO !columnIdx

    stressTensor=MATMUL(t,stressTensor)/J

    EXITS("FiniteElasticity_PushStressTensor")
    RETURN
999 ERRORSEXITS("FiniteElasticity_PushStressTensor",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_PushStressTensor

  !
  !================================================================================================================================
  !

  !>Evaluates the residual and RHS vectors for a finite elasticity finite element equations set.
  SUBROUTINE FiniteElasticity_FiniteElementResidualEvaluateNew(equationsSet,elementNumber,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to calculate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: columnComponentIdx,columnElementDOFIdx,columnElementParameterIdx,dependentComponentInterpolationType, &
      & dependentVariableType,equationsSetSubtype,esSpecification(3),gaussPointIdx,massMatrixNumber, &
      & meshComponentNumber,numberOfColElementParameters,numberOfDependentComponents,numberOfDimensions,numberOfGauss, &
      & numberOfMaterialsComponents,numberOfRowsComponents,numberOfRowElementParameters,numberOfXi,pressureComponent, &
      & pressureInterpolationType,rhsVariableType,rowComponentIdx,rowElementDOFIdx,rowElementParameterIdx,rowInterpolationType, &
      & rowsVariableType,scalingType,timeDependence,totalNumberOfSurfacePressureConditions,xiIdx
    REAL(DP) :: bfact,cauchyTensor(3,3),cauchyTensorFibre(3,3),columndPhidXi,columnPhi,darcyMassIncrease,darcyRho0F, &
      & darcyVolIncrease,density,dFdZ(3,64,3),dNudXi(3,3),dPhidZ(3,64,3),dXidNu(3,3),F(3,3),Fe(3,3),Fg(3,3),FNu(3,3), &
      & fibreVectors(3,3),gaussWeight,growthValues(3),J,Je,Jg,JNu,jacobianGaussWeight,Jxxi,Jzxi,Mfact,p,p0fact,rowPhi, &
      & sigmaV(6),spatialDensity,sum1,tempTerm1,thickness
    LOGICAL :: boundaryElement,darcyDependent,darcyDensity,haveDensity,haveHydrostaticPressure,haveSurfacePressure,incompressible, &
      & updateResidual,updateMass,updateRHS
    TYPE(BasisType), POINTER :: columnComponentBasis,dependentBasis,rowComponentBasis
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(BoundaryConditionsVariableType), POINTER :: boundaryConditionsVariable
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: columnComponentDomain,domain,rowComponentDomain
    TYPE(DomainElementsType), POINTER :: columnComponentElements,domainElements,rowComponentElements
    TYPE(DomainTopologyType), POINTER :: columnComponentTopology,domainTopology,rowComponentTopology
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsInterpolationType), POINTER :: equationsInterpolation
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingLHSType), POINTER :: lhsMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingRHSType), POINTER :: rhsMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesDynamicType), POINTER :: dynamicMatrices
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesRHSType), POINTER :: rhsVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatrixType), POINTER :: massMatrix
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: dependentField,fibreField,geometricField,independentField,materialsField,sourceField
    TYPE(FieldInterpolationParametersType), POINTER :: darcyDensityInterpParameters,darcyDependentInterpParameters, &
      & densityInterpParameters,dependentInterpParameters,fibreInterpParameters,geometricInterpParameters, &
      & independentInterpParameters,materialsInterpParameters,prevDependentInterpParameters,rowsInterpParameters, &
      & sourceInterpParameters
    TYPE(FieldInterpolatedPointType), POINTER :: darcyDependentInterpPoint,darcyDensityInterpPoint,densityInterpPoint, &
      & dependentInterpPoint,fibreInterpPoint,geometricInterpPoint,independentInterpPoint,materialsInterpPoint, &
      & prevDependentInterpPoint,sourceInterpPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: dependentInterpPointMetrics,geometricInterpPointMetrics, &
      & prevDependentInterpPointMetrics
    TYPE(FieldVariableType), POINTER :: dependentVariable,materialsVariable,residualVariable,rhsVariable,rowsVariable
    TYPE(QuadratureSchemeType), POINTER :: columnComponentQuadratureScheme,dependentQuadratureScheme,rowComponentQuadratureScheme
    TYPE(QuadratureSchemePtrType) :: quadratureSchemes(4)
    TYPE(RegionType), POINTER :: region
    TYPE(VARYING_STRING) :: localError,localWarning

    ENTERS("FiniteElasticity_FiniteElementResidualEvaluateNew",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)

    NULLIFY(equations)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    NULLIFY(vectorEquations)
    CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)       
    NULLIFY(vectorMatrices)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    NULLIFY(nonlinearMatrices)
    CALL EquationsMatricesVector_NonlinearMatricesGet(vectorMatrices,nonlinearMatrices,err,error,*999)
    NULLIFY(residualVector)
    CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,1,residualVector,err,error,*999)
    NULLIFY(dynamicMatrices)
    NULLIFY(dynamicMapping)
    NULLIFY(massMatrix)
    IF(equationsSetSubtype == EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE) THEN
      CALL EquationsMatricesVector_DynamicMatricesGet(vectorMatrices,dynamicMatrices,err,error,*999)
      CALL EquationsMappingVector_DynamicMappingGet(vectorMapping,dynamicMapping,err,error,*999)
      CALL EquationsMappingDynamic_MassMatrixNumberGet(dynamicMapping,massMatrixNumber,err,error,*999)
      IF(massMatrixNumber==0) CALL FlagError("The mass matrix number is zero for the dynamic mapping.",err,error,*999)
      CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,massMatrixNumber,massMatrix,err,error,*999)
    ENDIF 
    NULLIFY(rhsVector)
    CALL EquationsMatricesVector_RHSVectorGet(vectorMatrices,rhsVector,err,error,*999)
    
    CALL EquationsMatricesResidual_UpdateVectorGet(residualVector,updateResidual,err,error,*999)
    updateMass=.FALSE.
    IF(equationsSetSubtype == EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE) THEN
      CALL EquationsMatrix_UpdateMatrixGet(massMatrix,updateMass,err,error,*999)
    ENDIF
    CALL EquationsMatricesRHS_UpdateVectorGet(rhsVector,updateRHS,err,error,*999)

    IF(updateResidual.OR.updateMass.OR.updateRHS) THEN

      equationsSetSubtype=esSpecification(3)
      NULLIFY(region)
      CALL EquationsSet_RegionGet(equationsSet,region,err,error,*999)
      NULLIFY(coordinateSystem)
      CALL Region_CoordinateSystemGet(region,coordinateSystem,err,error,*999)
      CALL CoordinateSystem_DimensionGet(coordinateSystem,numberOfDimensions,err,error,*999)
      NULLIFY(equationsInterpolation)
      CALL Equations_InterpolationGet(equations,equationsInterpolation,err,error,*999)
      NULLIFY(vectorMapping)
      CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
      NULLIFY(lhsMapping)
      CALL EquationsMappingVector_LHSMappingGet(vectorMapping,lhsMapping,err,error,*999)
      NULLIFY(rowsVariable)
      CALL EquationsMappingLHS_LHSVariableGet(lhsMapping,rowsVariable,err,error,*999)
      CALL FieldVariable_NumberOfComponentsGet(rowsVariable,numberOfRowsComponents,err,error,*999)
      CALL FieldVariable_VariableTypeGet(rowsVariable,rowsVariableType,err,error,*999)
      NULLIFY(nonlinearMapping)
      CALL EquationsMappingVector_NonlinearMappingGet(vectorMapping,nonlinearMapping,err,error,*999)
!!TODO: Loop over the residuals and the residual variables.
      NULLIFY(residualMapping)
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,1,residualMapping,err,error,*999)
      NULLIFY(dependentVariable)
      CALL EquationsMappingResidual_VariableGet(residualMapping,1,dependentVariable,err,error,*999)
      CALL FieldVariable_NumberOfComponentsGet(dependentVariable,numberOfDependentComponents,err,error,*999)
      CALL FieldVariable_VariableTypeGet(dependentVariable,dependentVariableType,err,error,*999)
      NULLIFY(rhsMapping)
      CALL EquationsMappingVector_RHSMappingGet(vectorMapping,rhsMapping,err,error,*999)
      NULLIFY(rhsVariable)
      CALL EquationsMappingRHS_RHSVariableGet(rhsMapping,rhsVariable,err,error,*999)
      CALL FieldVariable_VariableTypeGet(rhsVariable,rhsVariableType,err,error,*999)
      NULLIFY(geometricField)
      NULLIFY(dependentField)
      IF(equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE .OR. &
        & equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE) THEN
        CALL EquationsSet_GeometricFieldGet(equationsSet,dependentField,err,error,*999)
        CALL EquationsSet_DependentFieldGet(equationsSet,geometricField,err,error,*999)
      ELSE
        CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
        CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
      ENDIF
      NULLIFY(fibreField)
      CALL EquationsSet_FibreFieldExists(equationsSet,fibreField,err,error,*999)
      NULLIFY(materialsField)
      CALL EquationsSet_MaterialsFieldExists(equationsSet,materialsField,err,error,*999)
      NULLIFY(independentField)
      IF(equationsSetSubtype==EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_NOLENDEP_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_2NDPIOLA_SUBTYPE) THEN
        CALL EquationsSet_IndependentFieldGet(equationsSet,independentField,err,error,*999)
      ELSE
        CALL EquationsSet_IndependentFieldExists(equationsSet,independentField,err,error,*999)
      ENDIF
      NULLIFY(sourceField)
      CALL EquationsSet_SourceFieldExists(equationsSet,sourceField,err,error,*999)
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(dependentField,decomposition,err,error,*999)
      NULLIFY(decompositionTopology)
      CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
      NULLIFY(decompositionElements)
      CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
      NULLIFY(domain)
      CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      NULLIFY(dependentBasis)
      CALL DomainElements_ElementBasisGet(domainElements,elementNumber,dependentBasis,err,error,*999)
      NULLIFY(dependentQuadratureScheme)
      CALL Basis_QuadratureSchemeGet(dependentBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,dependentQuadratureScheme,err,error,*999)
      CALL BasisQuadratureScheme_NumberOfGaussGet(dependentQuadratureScheme,numberOfGauss,err,error,*999)
      CALL Basis_NumberOfXiGet(dependentBasis,numberOfXi,err,error,*999)

      haveHydrostaticPressure=equationsSetSubtype/=EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE.AND. &
        & equationsSetSubtype/=EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE.AND. &
        & equationsSetSubtype/=EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE.AND. &
        & equationsSetSubtype/=EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE
      
!!TODO: SHOULDN'T HAVE TO GET BOUNDARY CONDITIONS FOR AN EQUATIONS SET        
      boundaryConditions=>equationsSet%boundaryConditions
      NULLIFY(boundaryConditionsVariable)
      CALL BoundaryConditions_VariableGet(boundaryConditions,rhsVariable,boundaryConditionsVariable,err,error,*999)
      totalNumberOfSurfacePressureConditions=boundaryConditionsVariable%dofCounts(BOUNDARY_CONDITION_PRESSURE)+ &
        & boundaryConditionsVariable%dofCounts(BOUNDARY_CONDITION_PRESSURE_INCREMENTED)

      CALL DecompositionElements_ElementBoundaryElementGet(decompositionElements,elementNumber,boundaryElement,err,error,*999)
      haveSurfacePressure=boundaryElement.AND.totalNumberofSurfacePressureConditions>0

      !Set flags for coupled finite elasticity and Darcy problems
      !Check if we need Darcy materials field for Density
      IF(equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE) THEN
        darcyDensity=.TRUE.
      ELSE
        darcyDensity=.FALSE.
      ENDIF
      !Check if we need Darcy dependent field
      IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE) THEN
        darcyDependent=.TRUE.
      ELSE
        darcyDependent=.FALSE.
      ENDIF

      haveDensity=.FALSE.

      updateRHS=updateRHS.AND.haveDensity.AND.ASSOCIATED(sourceField)
      
      IF(haveHydrostaticPressure) THEN
        pressureComponent=numberOfDependentComponents
        CALL FieldVariable_ComponentInterpolationGet(dependentVariable,pressureComponent,pressureInterpolationType,err,error,*999)
      ENDIF

      !Grab interpolation parameters, points and metrics.
      NULLIFY(rowsInterpParameters)
      CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,rowsVariableType, &
        & rowsInterpParameters,err,error,*999)
      
      NULLIFY(geometricInterpParameters)
      NULLIFY(geometricInterpPoint)
      NULLIFY(geometricInterpPointMetrics)
      NULLIFY(dependentInterpParameters)
      NULLIFY(dependentInterpPoint)
      NULLIFY(dependentInterpPointMetrics)
      IF(equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE .OR. &
        & equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE) THEN
        CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & dependentInterpParameters,err,error,*999)
        CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & dependentInterpPoint,err,error,*999)
        CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & dependentInterpPointMetrics,err,error,*999)
        CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,dependentVariableType, &
          & geometricInterpParameters,err,error,*999)
        CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,dependentVariableType, &
          & geometricInterpPoint,err,error,*999)
        CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,dependentVariableType, &
          & geometricInterpPointMetrics,err,error,*999)
      ELSE
        CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & geometricInterpParameters,err,error,*999)
        CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & geometricInterpPoint,err,error,*999)
        CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & geometricInterpPointMetrics,err,error,*999)
        CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,dependentVariableType, &
          & dependentInterpParameters,err,error,*999)
        CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,dependentVariableType, &
          & dependentInterpPoint,err,error,*999)
        CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,dependentVariableType, &
          & dependentInterpPointMetrics,err,error,*999)
      ENDIF
      CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,geometricInterpParameters,err,error,*999)
      CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,dependentInterpParameters,err,error,*999)
      NULLIFY(prevDependentInterpParameters)
      NULLIFY(prevDependentInterpPoint)
      NULLIFY(prevDependentInterpPointMetrics)
      CALL Equations_TimeDependenceTypeGet(equations,timeDependence,err,error,*999)
      IF(timeDependence/=EQUATIONS_STATIC) THEN
        CALL EquationsInterpolation_PreviousDependentParametersGet(equationsInterpolation,dependentVariableType, &
          & prevDependentInterpParameters,err,error,*999)
        CALL EquationsInterpolation_PreviousDependentPointGet(equationsInterpolation,dependentVariableType, &
          & prevDependentInterpPoint,err,error,*999)
        CALL EquationsInterpolation_PreviousDependentPointMetricsGet(equationsInterpolation,dependentVariableType, &
          & prevDependentInterpPointMetrics,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_PREVIOUS_VALUES_SET_TYPE,elementNumber, &
          & prevDependentInterpParameters,err,error,*999)
      ENDIF !static
      NULLIFY(fibreInterpParameters)
      NULLIFY(fibreInterpPoint)
      IF(ASSOCIATED(fibreField)) THEN
        CALL EquationsInterpolation_FibreParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & fibreInterpParameters,err,error,*999)
        CALL EquationsInterpolation_FibrePointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & fibreInterpPoint,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,fibreInterpParameters,err,error,*999)
      ENDIF !fibre
      NULLIFY(materialsInterpParameters)
      NULLIFY(materialsInterpPoint)
      NULLIFY(densityInterpParameters)
      NULLIFY(densityInterpPoint)
      NULLIFY(materialsVariable)
      NULLIFY(darcyDensityInterpParameters)
      NULLIFY(darcyDensityInterpPoint)
      IF(ASSOCIATED(materialsField)) THEN
        CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & materialsInterpParameters,err,error,*999)
        CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & materialsInterpPoint,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,materialsInterpParameters,err,error,*999)
        CALL Field_VariableGet(materialsField,FIELD_U_VARIABLE_TYPE,materialsVariable,err,error,*999)
        CALL FieldVariable_NumberOfComponentsGet(materialsVariable,numberOfMaterialsComponents,err,error,*999)
        IF(haveDensity) THEN
          CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_V_VARIABLE_TYPE, &
            & densityInterpParameters,err,error,*999)
          CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_V_VARIABLE_TYPE, &
            & densityInterpPoint,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,densityInterpParameters,err,error,*999)
        ENDIF !have density
        IF(darcyDensity) THEN
          CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_U1_VARIABLE_TYPE, &
            & darcyDensityInterpParameters,err,error,*999)
          CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_U1_VARIABLE_TYPE, &
            & darcyDensityInterpPoint,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,darcyDensityInterpParameters, &
            & err,error,*999)
        ENDIF !darcy density
      ENDIF !materials
      NULLIFY(darcyDependentInterpParameters)
      NULLIFY(darcyDependentInterpPoint)
      IF(darcyDependent) THEN
        CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,FIELD_V_VARIABLE_TYPE, &
          & darcyDependentInterpParameters,err,error,*999)
        CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,FIELD_V_VARIABLE_TYPE, &
          & darcyDependentInterpPoint,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,darcyDependentInterpParameters, &
          & err,error,*999)
      ENDIF !darcy dependent
      NULLIFY(independentInterpParameters)
      NULLIFY(independentInterpPoint)
      IF(ASSOCIATED(independentField)) THEN
        CALL EquationsInterpolation_IndependentParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & independentInterpParameters,err,error,*999)
        CALL EquationsInterpolation_IndependentPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & independentInterpPoint,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,independentInterpParameters,err,error,*999)
      ENDIF !independent field
      NULLIFY(sourceInterpParameters)
      NULLIFY(sourceInterpPoint)
      IF(ASSOCIATED(sourceField)) THEN
        CALL EquationsInterpolation_SourceParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & sourceInterpParameters,err,error,*999)
        CALL EquationsInterpolation_SourcePointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & sourceInterpPoint,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,sourceInterpParameters,err,error,*999)
      ENDIF !source field

      !Initialise tensors and matrices
      CALL IdentityMatrix(F,err,error,*999)
      dFdZ=0.0_DP ! (parameterIdx,componentIdx)
      growthValues=[1.0_DP,1.0_DP,1.0_DP]

      IF(diagnostics1) THEN
        CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"Element : ",elementNumber,err,error,*999)
      ENDIF

      IF(updateResidual.OR.updateMass) THEN
        !Evaluate residual or mass matrix

        SELECT CASE(equationsSetSubtype)
        CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE, &
          & EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
          & EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
          & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE, &
          & EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE, &
          & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
          & EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE, &
          & EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)

          !Loop over gauss points and add residuals
          DO gaussPointIdx=1,numberOfGauss

            IF(diagnostics1) THEN
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Gauss point : ",gaussPointIdx,err,error,*999)
            ENDIF

            CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)

            !Interpolate dependent, geometric, fibre and materials fields
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) &
              & CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
              & err,error,*999)
            IF(ASSOCIATED(materialsField)) & 
              & CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
              & err,error,*999)

            CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,Jzxi,err,error,*999)
            CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)

            jacobianGaussWeight=Jzxi*gaussWeight
            
            IF(haveHydrostaticPressure) p=dependentInterpPoint%values(pressureComponent,NO_PART_DERIV)

            !Calculate material fibre coordinate system
            CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
              & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
              & fibreVectors(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
            !Calculate the deformation gradient tensor
            CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
              & dXidNu(1:numberOfXi,1:numberOfDimensions),F,J,FNu,JNu,err,error,*999)

            IF(JNu<0.0_DP) THEN
              localWarning="Volume is negative for gauss point "//TRIM(NumberToVString(gaussPointIdx,"*",err,error))//&
                & " of element "//TRIM(NumberToVString(elementNumber,"*",err,error))//". det(F) = "// &
                & TRIM(NumberToVString(JNu,"*",err,error))//"."
              CALL FlagWarning(localWarning,err,error,*999) 
            ENDIF

            !Calculate any growth.
            IF(equationsSetSubtype==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,1,growthValues(1),err,error,*999)
              IF(numberofDimensions>1) THEN
                CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                  & gaussPointIdx,elementNumber,2,growthValues(2),err,error,*999)
                IF(numberOfDimensions>2) THEN
                  CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                    & gaussPointIdx,elementNumber,3,growthValues(3),err,error,*999)
                ENDIF
              ENDIF
            ENDIF

            CALL FiniteElasticity_GrowthTensorCalculate(equationsSet,numberOfDimensions,FNu,growthValues,Fg,Fe,Jg,Je,err,error,*999)

            IF(updateResidual) THEN
              !Calculate Cauchy stress
              CALL FiniteElasticity_SpatialStressTensorsCalculate(equationsSet,numberOfDimensions,materialsInterpPoint, &
                & Fe,Je,p,haveHydrostaticPressure,sigmaV,err,error,*999)

              IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE) THEN
                !Parameters settings for coupled elasticity Darcy INRIA model:
                CALL FiniteElasticity_GetDarcyParameters(darcyRho0F,Mfact,bfact,p0fact,err,error,*999)
                darcyMassIncrease=darcyDependentInterpPoint%values(4,NO_PART_DERIV)
                darcyVolIncrease=darcyMassIncrease/darcyRho0F
              ENDIF

              !For membrane theory in 3D space, the final equation is multiplied by thickness.
              !Default to unit thickness if equation set subtype is not membrane
              thickness=1.0_DP
              IF(equationsSetSubtype==EQUATIONS_SET_MEMBRANE_SUBTYPE.AND.numberOfDimensions==3) & 
                & thickness=materialsInterpPoint%values(numberOfMaterialsComponents,NO_PART_DERIV)         

              !Loop over geometric dependent basis functions and evaluate dPhidZ.
              DO columnComponentIdx=1,numberOfDimensions
                NULLIFY(columnComponentDomain)
                CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnComponentDomain,err,error,*999)
                NULLIFY(columnComponentTopology)
                CALL Domain_DomainTopologyGet(columnComponentDomain,columnComponentTopology,err,error,*999)
                NULLIFY(columnComponentElements)
                CALL DomainTopology_DomainElementsGet(columnComponentTopology,columnComponentElements,err,error,*999)
                NULLIFY(columnComponentBasis)
                CALL DomainElements_ElementBasisGet(columnComponentElements,elementNumber,columnComponentBasis,err,error,*999)
                NULLIFY(columnComponentQuadratureScheme)
                CALL Basis_QuadratureSchemeGet(columnComponentBasis,BASIS_DEFAULT_QUADRATURE_SCHEME, &
                  & columnComponentQuadratureScheme,err,error,*999)
                CALL Basis_NumberOfElementParametersGet(columnComponentBasis,numberOfColElementParameters,err,error,*999)
                DO columnElementParameterIdx=1,numberOfColElementParameters
                  DO rowComponentIdx=1,numberOfDimensions
                    sum1=0.0_DP
                    DO xiIdx=1,numberOfXi
                      CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnComponentQuadratureScheme, &
                        & columnElementParameterIdx,PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx),gaussPointIdx, &
                        & columndPhidXi,err,error,*999)
                      sum1=sum1+dependentInterpPointMetrics%dXidX(xiIdx,rowComponentIdx)*columndPhidXi      
                    ENDDO !xiIdx
                    dPhidZ(rowComponentIdx,columnElementParameterIdx,columnComponentIdx)=sum1
                  ENDDO !rowComponentIdx
                ENDDO !columnElementParameterIdx
                !Convert the Cauchy stress tensor from Voigt form to tensor form.
                DO rowComponentIdx=1,numberOfDimensions
                  cauchyTensor(rowComponentIdx,columnComponentIdx)= &
                    & sigmaV(TENSOR_TO_VOIGT(rowComponentIdx,columnComponentIdx,numberOfDimensions))
                ENDDO !rowComponentIdx
              ENDDO !columnComponentIdx

              !Now add up the residual terms
              rowElementDOFIdx=0
              DO rowComponentIdx=1,numberOfDimensions
                CALL FieldVariable_ComponentInterpolationGet(rowsVariable,rowComponentIdx,rowInterpolationType,err,error,*999)
                SELECT CASE(rowInterpolationType)
                CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
                  NULLIFY(rowComponentDomain)
                  CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowComponentDomain,err,error,*999)
                  NULLIFY(rowComponentTopology)
                  CALL Domain_DomainTopologyGet(rowComponentDomain,rowComponentTopology,err,error,*999)
                  NULLIFY(rowComponentElements)
                  CALL DomainTopology_DomainElementsGet(rowComponentTopology,rowComponentElements,err,error,*999)
                  NULLIFY(rowComponentBasis)
                  CALL DomainElements_ElementBasisGet(rowComponentElements,elementNumber,rowComponentBasis,err,error,*999)
                  NULLIFY(rowComponentQuadratureScheme)
                  CALL Basis_QuadratureSchemeGet(rowComponentBasis,BASIS_DEFAULT_QUADRATURE_SCHEME, &
                    & rowComponentQuadratureScheme,err,error,*999)
                  CALL Basis_NumberOfElementParametersGet(rowComponentBasis,numberOfRowElementParameters,err,error,*999)
                  DO rowElementParameterIdx=1,numberOfRowElementParameters
                    rowElementDOFIdx=rowElementDOFIdx+1
                    residualVector%elementResidual%vector(rowElementDOFIdx)= &
                      & residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                      & jacobianGaussWeight*DOT_PRODUCT(dPhidZ(1:numberOfDimensions,rowElementParameterIdx,rowComponentIdx), &
                      & cauchyTensor(1:numberOfDimensions,rowComponentIdx))
                  ENDDO !rowElementParameterIdx 
                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                  !Will probably never be used
                  CALL FlagError("Finite elasticity with element based interpolation is not implemented.",err,error,*999)
                CASE DEFAULT
                  localError="The interpolation type of "//TRIM(NumberToVString(rowInterpolationType,"*",err,error))// &
                    & " for row component index "//TRIM(NumberToVString(rowComponentIdx,"*",err,error))// &
                    & " is invalid or not implemented."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ENDDO !rowComponentIdx

              !Hydrostatic pressure component
              IF(haveHydrostaticPressure) THEN
                !skip for membrane problems
                IF(equationsSetSubtype /= EQUATIONS_SET_MEMBRANE_SUBTYPE) THEN
                  IF(equationsSetSubtype == EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE) THEN
                    tempTerm1=gaussWeight*(Jzxi-(Jg-darcyVolIncrease)*Jxxi)
                  ELSE
                    tempTerm1=-gaussWeight*(1.0_DP - 1.0_DP/Je)*Jzxi
                  ENDIF
                  SELECT CASE(pressureInterpolationType)
                  CASE(FIELD_NODE_BASED_INTERPOLATION)
                    !node based
                    NULLIFY(rowComponentDomain)
                    CALL FieldVariable_ComponentDomainGet(rowsVariable,pressureComponent,rowComponentDomain,err,error,*999)
                    NULLIFY(rowComponentTopology)
                    CALL Domain_DomainTopologyGet(rowComponentDomain,rowComponentTopology,err,error,*999)
                    NULLIFY(rowComponentElements)
                    CALL DomainTopology_DomainElementsGet(rowComponentTopology,rowComponentElements,err,error,*999)
                    NULLIFY(rowComponentBasis)
                    CALL DomainElements_ElementBasisGet(rowComponentElements,elementNumber,rowComponentBasis,err,error,*999)
                    NULLIFY(rowComponentQuadratureScheme)
                    CALL Basis_QuadratureSchemeGet(rowComponentBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowComponentQuadratureScheme, &
                      & err,error,*999)
                    CALL Basis_NumberOfElementParametersGet(rowComponentBasis,numberOfRowElementParameters,err,error,*999)
                    DO rowElementParameterIdx=1,numberOfRowElementParameters
                      rowElementDOFIdx=rowElementDOFIdx+1 
                      CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowComponentQuadratureScheme, &
                        & rowElementParameterIdx,NO_PART_DERIV,gaussPointIdx,rowPhi,err,error,*999)
                      residualVector%elementResidual%vector(rowElementDOFIdx)= &
                        & residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                        & rowPhi*tempTerm1
                    ENDDO
                  CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                    !element based
                    rowElementDOFIdx=rowElementDOFIdx+1                
                    residualVector%elementResidual%vector(rowElementDOFIdx)= &
                      & residualVector%elementResidual%vector(rowElementDOFIdx)+tempTerm1
                  CASE DEFAULT
                    localError="The interpolation type of "//TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
                      & " for row component index "//TRIM(NumberToVString(pressureComponent,"*",err,error))// &
                      & " is invalid or not implemented."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                ENDIF
              ENDIF
            ENDIF !update residual

            IF(updateMass) THEN
              !Compute mass matrix
              spatialDensity=materialsInterpPoint%values(1,1)/Je
              !Loop over field components
              rowElementDOFIdx=0          
              DO rowComponentIdx=1,numberOfDimensions
                NULLIFY(rowComponentDomain)
                CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowComponentDomain,err,error,*999)
                NULLIFY(rowComponentTopology)
                CALL Domain_DomainTopologyGet(rowComponentDomain,rowComponentTopology,err,error,*999)
                NULLIFY(rowComponentElements)
                CALL DomainTopology_DomainElementsGet(rowComponentTopology,rowComponentElements,err,error,*999)
                NULLIFY(rowComponentBasis)
                CALL DomainElements_ElementBasisGet(rowComponentElements,elementNumber,rowComponentBasis,err,error,*999)
                NULLIFY(rowComponentQuadratureScheme)
                CALL Basis_QuadratureSchemeGet(rowComponentBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowComponentQuadratureScheme, &
                  & err,error,*999)
                !Loop over element rows
                CALL Basis_NumberOfElementParametersGet(rowComponentBasis,numberOfRowElementParameters,err,error,*999)
                DO rowElementParameterIdx=1,numberOfRowElementParameters
                  rowElementDOFIdx=rowElementDOFIdx+1
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowComponentQuadratureScheme, &
                    & rowElementParameterIdx,NO_PART_DERIV,gaussPointIdx,rowPhi,err,error,*999)
                  columnElementDOFIdx=0
                  !Loop over element columns
                  DO columnComponentIdx=1,numberOfDimensions
                    NULLIFY(columnComponentDomain)
                    CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnComponentDomain,err,error,*999)
                    NULLIFY(columnComponentTopology)
                    CALL Domain_DomainTopologyGet(columnComponentDomain,columnComponentTopology,err,error,*999)
                    NULLIFY(columnComponentElements)
                    CALL DomainTopology_DomainElementsGet(columnComponentTopology,columnComponentElements,err,error,*999)
                    NULLIFY(columnComponentBasis)
                    CALL DomainElements_ElementBasisGet(columnComponentElements,elementNumber,columnComponentBasis,err,error,*999)
                    NULLIFY(columnComponentQuadratureScheme)
                    CALL Basis_QuadratureSchemeGet(columnComponentBasis,BASIS_DEFAULT_QUADRATURE_SCHEME, &
                      & columnComponentQuadratureScheme,err,error,*999)
                    CALL Basis_NumberOfElementParametersGet(columnComponentBasis,numberOfColElementParameters,err,error,*999)
                    DO columnElementParameterIdx=1,numberOfColElementParameters
                      columnElementDOFIdx=columnElementDOFIdx+1
                      CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnComponentQuadratureScheme, &
                        & columnElementParameterIdx,NO_PART_DERIV,gaussPointIdx,columnPhi,err,error,*999)
                      massMatrix%elementMatrix%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                        & massMatrix%elementMatrix%matrix(rowElementDOFIdx,columnElementDOFIdx)+ &                    
                        & rowPhi*columnPhi*JacobianGaussWeight*spatialDensity
                    ENDDO !columnElementParameterIdx
                  ENDDO !columnComponentIdx
                ENDDO !rowElementParameterIdx
              ENDDO !rowComponentIdx
            ENDIF !update mass matrix

          ENDDO !gaussPointIdx

          !Call surface pressure term here: should only be executed if THIS element has surface pressure on it
          !(direct or incremented)
          IF(updateResidual.AND.haveSurfacePressure) &
            & CALL FiniteElasticity_SurfacePressureResidualEvaluate(equationsSet,elementNumber,dependentVariableType, &
            & rhsVariableType,err,error,*999)

        CASE DEFAULT
          CALL FlagError("Not implemented.",err,error,*999)
        END SELECT

      ENDIF !update residual or mass

      !Gravity loading term
      IF(updateRHS) THEN
        IF(ASSOCIATED(sourceField)) THEN
          DO gaussPointIdx=1,numberOfGauss
            CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,sourceInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            IF(haveDensity) &
              & CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,densityInterpPoint, &
              & err,error,*999)
            IF(darcyDensity) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,darcyDensityInterpPoint, &
                & err,error,*999)
              !Account for separate fluid and solid proportions and densities
              !Total lagrangian density = m_s + m_f = rho^0_s * (1 - phi^0) + rho_f * phi
              !By assuming solid incompressibility, phi = (J - 1 + phi^0)
              !\todo: Think about how this fits in with the constitutive relation, and what happens when the solid
              !isn't incompressible. Can we assume the solid is incompressible if we aren't enforcing that in the
              !constitutive relation?
!!TODO: What is Je here???? We should calculate F and J then Fe and Je?????
              density=densityInterpPoint%values(1,NO_PART_DERIV)*(1.0_DP-darcyDensityInterpPoint%values(8,NO_PART_DERIV)) + &
                & darcyDensityInterpPoint%values(7,NO_PART_DERIV)*(Je-1.0_DP+darcyDensityInterpPoint%values(8,NO_PART_DERIV))
            ELSE
              density=densityInterpPoint%values(1,NO_PART_DERIV)
            ENDIF
            rowElementDOFIdx=0
            DO rowComponentIdx=1,numberOfDimensions
              NULLIFY(rowComponentDomain)
              CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowComponentDomain,err,error,*999)
              NULLIFY(rowComponentTopology)
              CALL Domain_DomainTopologyGet(rowComponentDomain,rowComponentTopology,err,error,*999)
              NULLIFY(rowComponentElements)
              CALL DomainTopology_DomainElementsGet(rowComponentTopology,rowComponentElements,err,error,*999)
              NULLIFY(rowComponentBasis)
              CALL DomainElements_ElementBasisGet(rowComponentElements,elementNumber,rowComponentBasis,err,error,*999)
              NULLIFY(rowComponentQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(rowComponentBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowComponentQuadratureScheme, &
                & err,error,*999)
              CALL BasisQuadratureScheme_GaussWeightGet(rowComponentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)
              CALL Basis_NumberOfElementParametersGet(rowComponentBasis,numberOfRowElementParameters,err,error,*999)
              DO rowElementParameterIdx=1,numberOfRowElementParameters
                CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowComponentQuadratureScheme,rowElementParameterIdx, &
                  & NO_PART_DERIV,gaussPointIdx,rowPhi,err,error,*999)
                rowElementDOFIdx=rowElementDOFIdx+1
!!TODO: If we are integrating over the deformed coordinates (as given by using the dependent interpolated point Jacobian) or
!!we have the deformation Jacobian involved (darcy Density) then this should be part of the residual and not the RHS??? 
                rhsVector%elementVector%vector(rowElementDOFIdx)=rhsVector%elementVector%vector(rowElementDOFIdx) + &
                  & density*sourceInterpPoint%values(rowComponentIdx,NO_PART_DERIV)* &
                  & rowPhi*gaussWeight*dependentInterpPointMetrics%jacobian
              ENDDO !rowElementParameterIdx
            ENDDO !rowComponentIdx
          ENDDO !gaussPointIdx
        ENDIF !source field
      ENDIF !update RHS

      !Scale factor adjustment
      CALL Field_ScalingTypeGet(dependentField,scalingType,err,error,*999)
      IF(scalingType/=FIELD_NO_SCALING) THEN
        NULLIFY(rowsInterpParameters)
        CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,rowsVariableType,rowsInterpParameters, &
          & err,error,*999)
        NULLIFY(dependentInterpParameters)
        CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,dependentVariableType,dependentInterpParameters, &
          & err,error,*999)
        CALL Field_InterpolationParametersScaleFactorsElementGet(elementNumber,rowsInterpParameters,err,error,*999)
        CALL Field_InterpolationParametersScaleFactorsElementGet(elementNumber,dependentInterpParameters,err,error,*999)
        rowElementDofIdx=0          
        DO rowComponentIdx=1,numberOfDimensions
          NULLIFY(rowComponentDomain)
          CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowComponentDomain,err,error,*999)
          NULLIFY(rowComponentTopology)
          CALL Domain_DomainTopologyGet(rowComponentDomain,rowComponentTopology,err,error,*999)
          NULLIFY(rowComponentElements)
          CALL DomainTopology_DomainElementsGet(rowComponentTopology,rowComponentElements,err,error,*999)
          NULLIFY(rowComponentBasis)
          CALL DomainElements_ElementBasisGet(rowComponentElements,elementNumber,rowComponentBasis,err,error,*999)
          !Loop over residual vector
          CALL Basis_NumberOfElementParametersGet(rowComponentBasis,numberOfRowElementParameters,err,error,*999)
          DO rowElementParameterIdx=1,numberOfRowElementParameters
            rowElementDofIdx=rowElementDofIdx+1
            IF(updateResidual) THEN
              residualVector%elementResidual%vector(rowElementDOFIdx)= &
                & residualVector%elementResidual%vector(rowElementDOFIdx)* &
                & rowsInterpParameters%scaleFactors(rowElementParameterIdx,rowComponentIdx)
            ENDIF
            IF(equationsSetSubtype == EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
              & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE.OR. &
              & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
              & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE) THEN
              IF(updateMass) THEN
                columnElementDofIdx=0
                !Loop over element columns
                DO columnComponentIdx=1,numberOfDimensions
                  NULLIFY(columnComponentDomain)
                  CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnComponentDomain,err,error,*999)
                  NULLIFY(columnComponentTopology)
                  CALL Domain_DomainTopologyGet(columnComponentDomain,columnComponentTopology,err,error,*999)
                  NULLIFY(columnComponentElements)
                  CALL DomainTopology_DomainElementsGet(columnComponentTopology,columnComponentElements,err,error,*999)
                  NULLIFY(columnComponentBasis)
                  CALL DomainElements_ElementBasisGet(columnComponentElements,elementNumber,columnComponentBasis,err,error,*999)
                  CALL Basis_NumberOfElementParametersGet(columnComponentBasis,numberOfColElementParameters,err,error,*999)
                  DO columnElementParameterIdx=1,numberOfColElementParameters
                    columnElementDofIdx=columnElementDofIdx+1
                    massMatrix%elementMatrix%matrix(rowElementDofIdx,columnElementDofIdx)= &
                      & massMatrix%elementMatrix%matrix(rowElementDofIdx,columnElementDofIdx)* &
                      & rowsInterpParameters%scaleFactors(rowElementParameterIdx,rowComponentIdx)* &
                      & dependentInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
                  ENDDO !columnElementParameterIdx
                ENDDO !columnComponentIdx              
              ENDIF !update mass
            ENDIF
            IF(ASSOCIATED(rhsVector)) THEN
              IF(ASSOCIATED(sourceField)) THEN
                IF(updateRHS) rhsVector%elementVector%vector(rowElementDOFIdx)= &
                  & rhsVector%elementVector%vector(rowElementDOFIdx)* &
                  & dependentInterpParameters%scaleFactors(rowElementParameterIdx,rowComponentIdx)
              ENDIF !source field
            ENDIF !rhs vector
          ENDDO !rowElementParameterIdx
        ENDDO !rowComponentIdx
        IF(haveHydrostaticPressure) THEN
          SELECT CASE(pressureInterpolationType)
          CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
            NULLIFY(rowComponentDomain)
            CALL FieldVariable_ComponentDomainGet(rowsVariable,pressureComponent,rowComponentDomain,err,error,*999)
            NULLIFY(rowComponentTopology)
            CALL Domain_DomainTopologyGet(rowComponentDomain,rowComponentTopology,err,error,*999)
            NULLIFY(rowComponentElements)
            CALL DomainTopology_DomainElementsGet(rowComponentTopology,rowComponentElements,err,error,*999)
            NULLIFY(rowComponentBasis)
            CALL DomainElements_ElementBasisGet(rowComponentElements,elementNumber,rowComponentBasis,err,error,*999)
            DO rowElementParameterIdx=1,rowComponentBasis%numberOfElementParameters
              rowElementDOFIdx=rowElementDOFIdx+1 
              residualVector%elementResidual%vector(rowElementDOFIdx)=residualVector%elementResidual% &
                & vector(rowElementDOFIdx)*rowsInterpParameters%scaleFactors(rowElementParameterIdx,pressureComponent)
            ENDDO !rowElementParameterIdx
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            !Do nothing
          CASE DEFAULT
            localError="The interpolation type of "//TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
              & " for row component index "//TRIM(NumberToVString(pressureComponent,"*",err,error))// &
              & " is invalid or not implemented."
            CALL FlagError(localError,err,error,*999)
          END SELECT !node pressure
        ENDIF !have hydrostatic pressure
      ENDIF !scaling
    ENDIF !update
      
    EXITS("FiniteElasticity_FiniteElementResidualEvaluateNew")
    RETURN
999 ERRORS("FiniteElasticity_FiniteElementResidualEvaluateNew",err,error)
    EXITS("FiniteElasticity_FiniteElementResidualEvaluateNew")
    RETURN 1

  END SUBROUTINE FiniteElasticity_FiniteElementResidualEvaluateNew

  !
  !================================================================================================================================
  !

  !>Evaluates the residual and RHS vectors for a finite elasticity finite element equations set.
  SUBROUTINE FiniteElasticity_FiniteElementResidualEvaluate(equationsSet,elementNumber,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to calculate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: columnIdx,columnComponentIdx,columnElementDOFIdx,columnElementParameterIdx,componentIdx,componentIdx2, &
      & darcyVariableType,dependentComponentInterpolationType,dependentNumberOfComponents,dependentVariableType,elementDOFIdx, &
      & equationsSetSubtype, &
      & esSpecification(3),gaussPointIdx,hydrostaticPressureComponent,imatrix,massMatrixNumber,maxNumIterations,meshComponent1, &
      & meshComponentNumber,Ncompartments,numIterations,numberOfColElementParameters,numberOfComponentInterpolationParameters, &
      & numberOfDependentComponents,numberOfDimensions,numberOfDOFs, &
      & numberOfGauss,numberOfMaterialsComponents,numberOfPressureElementParameters,numberOfRowComponents &
      & ,numberOfRowElementParameters,numberOfXDimensions, &
      & numberOfXi, &
      & numberOfXiDimensions,pressureComponent, &
      & pressureInterpolationType,rhsVariableType,rowIdx, &
      & rowComponentIdx, &
      & rowElementDOFIdx,rowElementParameterIdx,rowInterpolationType, &
      & rowsVariableType,scalingType,timeDependence,totalNumberOfSurfacePressureConditions, &
      & variableType,rowXiIdx
    INTEGER(INTG), POINTER :: equationsSetFieldData(:)
    REAL(DP) ::  bfact,C(3,3),cauchyTensor(3,3),columnPhi,darcyMassIncrease,darcyVolIncrease,darcyRho0F,dColumnPhidXi, &
      & deformationGradientTensor(3,3),density,dFdZ(64,3,3),dNudXi(3,3),dPhidZ(3,64,3),dXidNu(3,3),dZdNu(3,3),dZdNuT(3,3), &
      & dZdX(3,3),E(3,3),f(3,3),Fe(3,3),FeT(3,3),fibreGrowth,fibreVector(3),fibreVectors(3,3),Fg(3,3),gaussWeight, &
      & growthTensor(3,3),growthTensorInverse(3,3),growthTensorInverseTranspose(3,3),growthValues(3),I3,invPrevdZdNu(3,3), &
      & J,jacobianGaussWeight,Je,Jg,jgwCauchyTensor(3,3),JXXi,JZ,JZNu,JZXi,kirchoffTensor(3,3),Mfact,normalGrowth, &
      & normalVector(3),P,p0fact,piolaTensor(3,3),piolaDeformation(3,3),prevJ,prevJZ,prevJZxi,prevJZNu,prevdZdX(3,3), &
      & prevdZdNu(3,3),rightCauchyGreen(3,3),rowPhi,sheetGrowth,sheetVector(3),stressTensor(6),sum1,temp(3,3),tempTerm1,thickness
    REAL(DP) :: dt,K,mu,a0,a1,b0,b1,m,Jr,kappa1,kappan,kappas,prevJF
    REAL(DP) :: alpha1,BePrime(3,3),BePrime1(3,3),BePrimeStar(3,3),Br(3,3),c0,c1,c2,Dbar(3,3),deltaEps,detdevBePrimePrime, &
      & devBePrimePrime(3,3),BePrimePrimeStar(3,3),devDbar(3,3),gePrimePrime(3,3),gePrimePrimeStar(3,3),devT(3,3),dtGamma, &
      & dtGamma0,dtGamma1,factor1,factor2,Fr(3,3),FrPrime(3,3),gammaEStar,gamma,hydBePrimeStar(3,3),hydDbar(3,3),ITens(3,3), &
      & kappa,tempTensor(3,3)
    REAL(DP) :: mu0,q,kt,kc,k1,k2,k3,k12,ka,Je1,Je2,Jh,GammaM,deltaAlphaNorm,deltaAlphaNormTolerance,detBePrime, &
      & detBePrimePrime,BeDDotH,BeDDotBe,detBe,ktJe,kcJe,macEe11,macEe22,macEe33,QQ,detInvFrT,hstep,hStepAlpha,detJacobian, &
      & H11,H22,H33,H12,H13,H23
    REAL(DP) :: alpha(2),perturbedAlpha(2),deltaAlpha(2),resid(2),perturbedResid(2),H(3,3),HPrimePrime(3,3), &
      & S1(3,3),S2(3,3),S(3,3,3,3),Be(3,3),uniBePrime1(3,3),invBePrime(3,3),Jacobian(2,2),lame(4),Ee(4,4),invBe(3,3), &
      & invBeS33(3,3),S33invBe(3,3),T0(3,3),T1(3,3),T2(3,3),T3(3,3),T4(3,3),T5(3,3),invFrT(3,3),BePrimePrime(3,3), &
      & invJacobian(2,2)
    REAL(DP) :: devH(3,3),HH(3,3),malpha1,B,Bepr(3,3),lame1,lame2,lame3,lamea,Ee11,Ee22,Ee33,Ee12,Eea,TT(3,3)
    REAL(DP) :: statev(13),ddsdde(3,3,3,3),props(8)
    REAL(DP) :: k4,b2,b3,b4,b5,b6,rho0,bigQ,delWdelQ,delQdelJe,delQdelAlpha,delWdelJe,delWdelAlpha
    REAL(DP) :: A1g,B0g,B1g,B2g,alphag,chi1g,chi2g,phig,R1g,R2g,Lg,x,y,z,r,theta,Dg22,time,FgInv(3,3)
    LOGICAL :: boundaryElement,darcyDensity,darcyDependent,haveSurfacePressure,updateMass,updateResidual,updateRHS
    TYPE(BasisType), POINTER :: columnBasis,componentBasis,dependentBasis,geometricBasis,pressureBasis,rowBasis
    TYPE(BoundaryConditionsVariableType), POINTER :: boundaryConditionsVariable
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: dependentDecomposition,geometricDecomposition
    TYPE(DecompositionElementsType), POINTER :: dependentDecompositionElements,geometricDecompositionElements
    TYPE(DecompositionTopologyType), POINTER :: dependentDecompositionTopology,geometricDecompositionTopology
    TYPE(DomainType), POINTER :: columnDomain,dependentDomain,geometricDomain,pressureDomain,rowDomain
    TYPE(DomainElementsType), POINTER :: columnDomainElements,dependentDomainElements,geometricDomainElements, &
      & pressureDomainElements,rowDomainElements
    TYPE(DomainMappingType), POINTER :: elementsMapping
    TYPE(DomainTopologyType), POINTER :: columnDomainTopology,dependentDomainTopology,geometricDomainTopology, &
      & pressureDomainTopology,rowDomainTopology
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsInterpolationType), POINTER :: equationsInterpolation
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingLHSType), POINTER :: lhsMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingRHSType), POINTER :: rhsMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesDynamicType), POINTER :: dynamicMatrices
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesRHSType), POINTER :: rhsVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatrixType), POINTER :: massMatrix
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: dependentField,equationsSetField,fibreField,geometricField,independentField,materialsField, &
      & sourceField
    TYPE(FieldInterpolationParametersType), POINTER :: darcyDensityInterpParameters,darcyDependentInterpParameters, &
      & darcyMaterialsInterpParameters,densityInterpParameters,dependentInterpParameters,fibreInterpParameters, &
      & geometricInterpParameters,independentInterpParameters,materialsInterpParameters,materialsDensityInterpParameters, &
      & prevDependentInterpParameters,rowsInterpParameters,sourceInterpParameters
    TYPE(FieldInterpolatedPointType), POINTER :: darcyDensityInterpPoint,darcyDependentInterpPoint,darcyMaterialsInterpPoint, &
      & densityInterpPoint,dependentInterpPoint,fibreInterpPoint,geometricInterpPoint,independentInterpPoint,materialsInterpPoint, &
      & materialsDensityInterpPoint,prevDependentInterpPoint,sourceInterpPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: dependentInterpPointMetrics,geometricInterpPointMetrics, &
      & prevDependentInterpPointMetrics
    TYPE(FieldVariableType), POINTER :: dependentVariable,geometricVariable,materialsVariable,materialsDensityVariable, &
      & rhsVariable,rowsVariable
    TYPE(QuadratureSchemeType), POINTER :: columnQuadratureScheme,dependentQuadratureScheme,componentQuadratureScheme, &
      & geometricQuadratureScheme,pressureQuadratureScheme,rowQuadratureScheme
    TYPE(RegionType), POINTER :: region
    TYPE(VARYING_STRING) :: localError,localWarning

    ENTERS("FiniteElasticity_FiniteElementResidualEvaluate",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)
    equationsSetSubtype = esSpecification(3)

    IF(equationsSetSubtype == EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
      & equationsSetSubtype == EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE) THEN
      CALL FiniteElasticity_FiniteElementResidualEvaluateNew(equationsSet,elementNumber,err,error,*999)
    ELSE
      NULLIFY(equations)
      CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
      NULLIFY(vectorEquations)
      CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
      NULLIFY(vectorMatrices)
      CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
      NULLIFY(nonlinearMatrices)
      CALL EquationsMatricesVector_NonlinearMatricesGet(vectorMatrices,nonlinearMatrices,err,error,*999)
      NULLIFY(residualVector)
      CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,1,residualVector,err,error,*999)
      CALL EquationsMatricesResidual_UpdateVectorGet(residualVector,updateResidual,err,error,*999)
      updateMass=.FALSE.
      IF(equationsSetSubType==EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
        & equationsSetSubType==EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE) THEN
        NULLIFY(dynamicMatrices)
        CALL EquationsMatricesVector_DynamicMatricesGet(vectorMatrices,dynamicMatrices,err,error,*999)
        CALL EquationsMappingVector_DynamicMappingGet(vectorMapping,dynamicMapping,err,error,*999)
        CALL EquationsMappingDynamic_MassMatrixNumberGet(dynamicMapping,massMatrixNumber,err,error,*999)
        IF(massMatrixNumber==0) CALL FlagError("The mass matrix number is zero for the dynamic mapping.",err,error,*999)
        CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,massMatrixNumber,massMatrix,err,error,*999)
        CALL EquationsMatrix_UpdateMatrixGet(massMatrix,updateMass,err,error,*999)
      ENDIF
      NULLIFY(rhsVector)
      CALL EquationsMatricesVector_RHSVectorGet(vectorMatrices,rhsVector,err,error,*999)
      CALL EquationsMatricesRHS_UpdateVectorGet(rhsVector,updateRHS,err,error,*999)

      IF(updateResidual.OR.updateMass.OR.updateRHS) THEN

        NULLIFY(region)
        CALL EquationsSet_RegionGet(equationsSet,region,err,error,*999)
        NULLIFY(coordinateSystem)
        CALL Region_CoordinateSystemGet(region,coordinateSystem,err,error,*999)
        CALL CoordinateSystem_DimensionGet(coordinateSystem,numberOfDimensions,err,error,*999)
        NULLIFY(equationsInterpolation)
        CALL Equations_InterpolationGet(equations,equationsInterpolation,err,error,*999)
        NULLIFY(vectorMapping)
        CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
        NULLIFY(lhsMapping)
        CALL EquationsMappingVector_LHSMappingGet(vectorMapping,lhsMapping,err,error,*999)
        NULLIFY(rowsVariable)
        CALL EquationsMappingLHS_LHSVariableGet(lhsMapping,rowsVariable,err,error,*999)
        CALL FieldVariable_NumberOfComponentsGet(rowsVariable,numberOfRowComponents,err,error,*999)
        CALL FieldVariable_VariableTypeGet(rowsVariable,rowsVariableType,err,error,*999)
        NULLIFY(nonlinearMapping)
        CALL EquationsMappingVector_NonlinearMappingGet(vectorMapping,nonlinearMapping,err,error,*999)
!!TODO: Loop over the residuals and the residual variables.
        NULLIFY(residualMapping)
        CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,1,residualMapping,err,error,*999)
        NULLIFY(dependentVariable)
        CALL EquationsMappingResidual_VariableGet(residualMapping,1,dependentVariable,err,error,*999)
        CALL FieldVariable_VariableTypeGet(dependentVariable,dependentVariableType,err,error,*999)
        NULLIFY(rhsMapping)
        CALL EquationsMappingVector_RHSMappingGet(vectorMapping,rhsMapping,err,error,*999)
        NULLIFY(rhsVariable)
        CALL EquationsMappingRHS_RHSVariableGet(rhsMapping,rhsVariable,err,error,*999)
        CALL FieldVariable_VariableTypeGet(rhsVariable,rhsVariableType,err,error,*999)
        NULLIFY(geometricField)
        NULLIFY(geometricVariable)
        NULLIFY(dependentField)
        IF(equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE .OR. &
          & equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE) THEN
          CALL EquationsSet_GeometricFieldGet(equationsSet,dependentField,err,error,*999)
          geometricVariable=>dependentVariable
          CALL EquationsSet_DependentFieldGet(equationsSet,geometricField,err,error,*999)
          NULLIFY(dependentVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,dependentVariable,err,error,*999)
        ELSE
          CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
        ENDIF
        CALL FieldVariable_NumberOfComponentsGet(dependentVariable,numberOfDependentComponents,err,error,*999)
        NULLIFY(fibreField)
        CALL EquationsSet_FibreFieldExists(equationsSet,fibreField,err,error,*999)
        NULLIFY(materialsField)
        CALL EquationsSet_MaterialsFieldExists(equationsSet,materialsField,err,error,*999)
        NULLIFY(independentField)
        IF(equationsSetSubtype==EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_NOLENDEP_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_2NDPIOLA_SUBTYPE) THEN
          CALL EquationsSet_IndependentFieldGet(equationsSet,independentField,err,error,*999)
        ELSE
          CALL EquationsSet_IndependentFieldExists(equationsSet,independentField,err,error,*999)
        ENDIF
        NULLIFY(sourceField)
        CALL EquationsSet_SourceFieldExists(equationsSet,sourceField,err,error,*999)

        NULLIFY(dependentDecomposition)
        CALL Field_DecompositionGet(dependentField,dependentDecomposition,err,error,*999)
        NULLIFY(dependentDecompositionTopology)
        CALL Decomposition_DecompositionTopologyGet(dependentDecomposition,dependentDecompositionTopology,err,error,*999)
        NULLIFY(dependentDecompositionElements)
        CALL DecompositionTopology_DecompositionElementsGet(dependentDecompositionTopology,dependentDecompositionElements, &
          & err,error,*999)
        NULLIFY(dependentDomain)
        CALL Decomposition_DomainGet(dependentDecomposition,0,dependentDomain,err,error,*999)
        NULLIFY(dependentDomainTopology)
        CALL Domain_DomainTopologyGet(dependentDomain,dependentDomainTopology,err,error,*999)
        NULLIFY(dependentDomainElements)
        CALL DomainTopology_DomainElementsGet(dependentDomainTopology,dependentDomainElements,err,error,*999)
        NULLIFY(dependentBasis)
        CALL DomainElements_ElementBasisGet(dependentDomainElements,elementNumber,dependentBasis,err,error,*999)
        NULLIFY(dependentQuadratureScheme)
        CALL Basis_QuadratureSchemeGet(dependentBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,dependentQuadratureScheme,err,error,*999)
        CALL BasisQuadratureScheme_NumberOfGaussGet(dependentQuadratureScheme,numberOfGauss,err,error,*999)
        CALL Basis_NumberOfXiGet(dependentBasis,numberOfXi,err,error,*999)

        NULLIFY(geometricDecomposition)
        CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
        NULLIFY(geometricDecompositionTopology)
        CALL Decomposition_DecompositionTopologyGet(geometricDecomposition,geometricDecompositionTopology,err,error,*999)
        NULLIFY(geometricDecompositionElements)
        CALL DecompositionTopology_DecompositionElementsGet(geometricDecompositionTopology,geometricDecompositionElements, &
          & err,error,*999)
        NULLIFY(geometricDomain)
        CALL Decomposition_DomainGet(geometricDecomposition,0,geometricDomain,err,error,*999)
        NULLIFY(geometricDomainTopology)
        CALL Domain_DomainTopologyGet(geometricDomain,geometricDomainTopology,err,error,*999)
        NULLIFY(geometricDomainElements)
        CALL DomainTopology_DomainElementsGet(geometricDomainTopology,geometricDomainElements,err,error,*999)
        NULLIFY(geometricBasis)
        CALL DomainElements_ElementBasisGet(geometricDomainElements,elementNumber,geometricBasis,err,error,*999)
        NULLIFY(geometricQuadratureScheme)
        CALL Basis_QuadratureSchemeGet(geometricBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,geometricQuadratureScheme,err,error,*999)

        pressureComponent=numberOfDependentComponents
        NULLIFY(pressureDomain)
        CALL FieldVariable_ComponentDomainGet(dependentVariable,pressureComponent,pressureDomain,err,error,*999)
        CALL FieldVariable_ComponentInterpolationGet(dependentVariable,pressureComponent,pressureInterpolationType, &
          & err,error,*999)
        NULLIFY(pressureDomainTopology)
        CALL Domain_DomainTopologyGet(pressureDomain,pressureDomainTopology,err,error,*999)
        NULLIFY(pressureDomainElements)
        CALL DomainTopology_DomainElementsGet(pressureDomainTopology,pressureDomainElements,err,error,*999)
        NULLIFY(pressureBasis)
        CALL DomainElements_ElementBasisGet(pressureDomainElements,elementNumber,pressureBasis,err,error,*999)
        CALL Basis_NumberOfElementParametersGet(pressureBasis,numberOfPressureElementParameters,err,error,*999)
        NULLIFY(pressureQuadratureScheme)
        CALL Basis_QuadratureSchemeGet(pressureBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,pressureQuadratureScheme,err,error,*999)

        !Set flags for coupled finite elasticity and Darcy problems
        !Check if we need Darcy materials field for Density
        IF(equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE) THEN
          darcyDensity=.TRUE.
        ELSE
          darcyDensity=.FALSE.
        ENDIF
        !Check if we need Darcy dependent field
        IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE) THEN
          darcyDependent=.TRUE.
        ELSE
          darcyDependent=.FALSE.
        ENDIF

!!TODO: SHOULDN'T HAVE TO GET BOUNDARY CONDITIONS FOR AN EQUATIONS SET        
        boundaryConditions=>equationsSet%boundaryConditions
        NULLIFY(boundaryConditionsVariable)
        CALL BoundaryConditions_VariableGet(boundaryConditions,rhsVariable,boundaryConditionsVariable,err,error,*999)
        totalNumberOfSurfacePressureConditions=boundaryConditionsVariable%dofCounts(BOUNDARY_CONDITION_PRESSURE)+ &
          & boundaryConditionsVariable%dofCounts(BOUNDARY_CONDITION_PRESSURE_INCREMENTED)

        CALL DecompositionElements_ElementBoundaryElementGet(dependentDecompositionElements,elementNumber,boundaryElement, &
          & err,error,*999)
        haveSurfacePressure=boundaryElement.AND.totalNumberOfSurfacePressureConditions>0      

        !Grab pointers: matrices, fields, decomposition, basis
        NULLIFY(rowsInterpParameters)
        CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,rowsVariableType, &
          & rowsInterpParameters,err,error,*999)

        NULLIFY(geometricInterpParameters)
        NULLIFY(geometricInterpPoint)
        NULLIFY(geometricInterpPointMetrics)
        NULLIFY(dependentInterpParameters)
        NULLIFY(dependentInterpPoint)
        NULLIFY(dependentInterpPointMetrics)
        IF(equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE .OR. &
          & equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE) THEN
          CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & dependentInterpParameters,err,error,*999)
          CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & dependentInterpPoint,err,error,*999)
          CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & dependentInterpPointMetrics,err,error,*999)
          CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,dependentVariableType, &
            & geometricInterpParameters,err,error,*999)
          CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,dependentVariableType, &
            & geometricInterpPoint,err,error,*999)
          CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,dependentVariableType, &
            & geometricInterpPointMetrics,err,error,*999)
        ELSE
          CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & geometricInterpParameters,err,error,*999)
          CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & geometricInterpPoint,err,error,*999)
          CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & geometricInterpPointMetrics,err,error,*999)
          CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,dependentVariableType, &
            & dependentInterpParameters,err,error,*999)
          CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,dependentVariableType, &
            & dependentInterpPoint,err,error,*999)
          CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,dependentVariableType, &
            & dependentInterpPointMetrics,err,error,*999)
        ENDIF
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,geometricInterpParameters,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,dependentInterpParameters,err,error,*999)
        NULLIFY(prevDependentInterpParameters)
        NULLIFY(prevDependentInterpPoint)
        NULLIFY(prevDependentInterpPointMetrics)
        CALL Equations_TimeDependenceTypeGet(equations,timeDependence,err,error,*999)
        IF(timeDependence/=EQUATIONS_STATIC) THEN
          CALL EquationsInterpolation_PreviousDependentParametersGet(equationsInterpolation,dependentVariableType, &
            & prevDependentInterpParameters,err,error,*999)
          CALL EquationsInterpolation_PreviousDependentPointGet(equationsInterpolation,dependentVariableType, &
            & prevDependentInterpPoint,err,error,*999)
          CALL EquationsInterpolation_PreviousDependentPointMetricsGet(equationsInterpolation,dependentVariableType, &
            & prevDependentInterpPointMetrics,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_PREVIOUS_VALUES_SET_TYPE,elementNumber, &
            & prevDependentInterpParameters,err,error,*999)
        ENDIF !static
        NULLIFY(fibreInterpParameters)
        NULLIFY(fibreInterpPoint)
        IF(ASSOCIATED(fibreField)) THEN
          CALL EquationsInterpolation_FibreParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & fibreInterpParameters,err,error,*999)
          CALL EquationsInterpolation_FibrePointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & fibreInterpPoint,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,fibreInterpParameters,err,error,*999)
        ENDIF !fibre
        NULLIFY(materialsVariable)
        NULLIFY(materialsInterpParameters)
        NULLIFY(materialsInterpPoint)
        NULLIFY(materialsDensityVariable)
        NULLIFY(materialsDensityInterpParameters)
        NULLIFY(materialsDensityInterpPoint)
        NULLIFY(densityInterpParameters)
        NULLIFY(densityInterpPoint)
        NULLIFY(darcyDensityInterpParameters)
        NULLIFY(darcyDensityInterpPoint)
        IF(ASSOCIATED(materialsField)) THEN
          CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & materialsInterpParameters,err,error,*999)
          CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & materialsInterpPoint,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,materialsInterpParameters, &
            & err,error,*999)
          CALL Field_VariableGet(materialsField,FIELD_U_VARIABLE_TYPE,materialsVariable,err,error,*999)
          CALL FieldVariable_NumberOfComponentsGet(materialsVariable,numberOfMaterialsComponents,err,error,*999)
          CALL Field_VariableExists(materialsField,FIELD_V_VARIABLE_TYPE,materialsDensityVariable,err,error,*999)
          IF(ASSOCIATED(materialsDensityVariable)) THEN
            CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_V_VARIABLE_TYPE, &
              & materialsDensityInterpParameters,err,error,*999)
            CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_V_VARIABLE_TYPE, &
              & materialsDensityInterpPoint,err,error,*999)
            CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber, &
              & materialsDensityInterpParameters,err,error,*999)
          ENDIF
          IF(darcyDensity) THEN
            CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_U1_VARIABLE_TYPE, &
              & darcyDensityInterpParameters,err,error,*999)
            CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_U1_VARIABLE_TYPE, &
              & darcyDensityInterpPoint,err,error,*999)
            CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,darcyDensityInterpParameters, &
              & err,error,*999)
          ENDIF !darcy density
        ENDIF !materials
        NULLIFY(darcyDependentInterpParameters)
        NULLIFY(darcyDependentInterpPoint)
        IF(darcyDependent) THEN
          CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,FIELD_V_VARIABLE_TYPE, &
            & darcyDependentInterpParameters,err,error,*999)
          CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,FIELD_V_VARIABLE_TYPE, &
            & darcyDependentInterpPoint,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,darcyDependentInterpParameters, &
            & err,error,*999)
        ENDIF !darcy dependent
        NULLIFY(independentInterpParameters)
        NULLIFY(independentInterpPoint)
        IF(ASSOCIATED(independentField)) THEN
          CALL EquationsInterpolation_IndependentParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & independentInterpParameters,err,error,*999)
          CALL EquationsInterpolation_IndependentPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & independentInterpPoint,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,independentInterpParameters, &
            & err,error,*999)
        ENDIF !independent field
        NULLIFY(sourceInterpParameters)
        NULLIFY(sourceInterpPoint)
        IF(ASSOCIATED(sourceField)) THEN
          CALL EquationsInterpolation_SourceParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & sourceInterpParameters,err,error,*999)
          CALL EquationsInterpolation_SourcePointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
            & sourceInterpPoint,err,error,*999)
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,sourceInterpParameters,err,error,*999)
        ENDIF !source field

        !Initialise tensors and matrices
        CALL IdentityMatrix(dZdNu,err,error,*999)
        CALL IdentityMatrix(piolaTensor,err,error,*999)
        CALL IdentityMatrix(cauchyTensor,err,error,*999)
        dFdZ=0.0_DP ! (parameterIdx,componentIdx)

        !SELECT: Compressible or incompressible cases, or poro multicompartment
        SELECT CASE(equationsSetSubtype)
          ! ---------------------------------------------------------------
        CASE(EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE)

          !Loop over gauss points and add residuals
          DO gaussPointIdx=1,numberOfGauss

            CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)

            !Interpolate dependent, geometric, fibre and materials fields
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx, &
              & dependentInterpPoint,err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx, &
              & geometricInterpPoint,err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
                & err,error,*999)
            ENDIF
            CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
              & err,error,*999)

            !Loop over geometric dependent basis functions.
            DO columnComponentIdx=1,numberOfDimensions
              NULLIFY(columnDomain)
              CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnDomain,err,error,*999)
              NULLIFY(columnDomainTopology)
              CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
              NULLIFY(columnDomainElements)
              CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
              NULLIFY(columnBasis)
              CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,columnBasis,err,error,*999)
              NULLIFY(columnQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(columnBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureScheme, &
                & err,error,*999)
              CALL Basis_NumberOfElementParametersGet(columnBasis,numberOfColElementParameters,err,error,*999)
              DO columnElementParameterIdx=1,numberOfColElementParameters
                !Loop over derivative directions.
                DO rowComponentIdx=1,numberOfDimensions
                  sum1=0.0_DP
                  DO rowXiIdx=1,numberOfXi
                    CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureScheme,columnElementParameterIdx, &
                      & PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(rowXiIdx),gaussPointIdx,dColumnPhidXi,err,error,*999)
                    sum1=sum1+dependentInterpPointMetrics%dXidX(rowXiIdx,rowComponentIdx)*dColumnPhidXi
                  ENDDO !rowXiIdx
                  dPhidZ(rowComponentIdx,columnElementParameterIdx,columnComponentIdx)=sum1
                ENDDO !rowComponentIdx
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx

            !Calculate material fibre coordinate system
            CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
              & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
              & fibreVectors(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
            !Calculate the deformation gradient tensor
            CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
              & dXidNu(1:numberOfXi,1:numberOfDimensions),F,J,dZdNu,JZNu,err,error,*999)

            CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)
            CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,Jzxi,err,error,*999)
            Jznu=Jzxi/Jxxi

            jacobianGaussWeight=Jzxi*gaussWeight

            !Calculate the Cauchy stress tensor (in Voigt form) at the gauss point.
            CALL FiniteElasticity_GaussStressTensor(equationsSet,numberOfDimensions,dependentInterpPoint, &
              & materialsInterpPoint,geometricInterpPoint,stressTensor,dZdNu,Jznu,elementNumber,gaussPointIdx, &
              & err,error,*999)

            !Convert from Voigt form to tensor form and multiply with Jacobian and Gauss weight.
            CALL VoigtToTensor(numberOfDimensions,[TENSOR_CONTRAVARIANT_INDEX],stressTensor,jgwCauchyTensor,err,error,*999)
            jgwCauchyTensor=jgwCauchyTensor*jacobianGaussWeight

            !Now add up the residual terms
            rowElementDOFIdx=0
            DO rowComponentIdx=1,numberOfDimensions
              NULLIFY(rowDomain)
              CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
              NULLIFY(rowDomainTopology)
              CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
              NULLIFY(rowDomainElements)
              CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
              NULLIFY(rowBasis)
              CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
              CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
              DO rowElementParameterIdx=1,numberOfRowElementParameters
                rowElementDOFIdx=rowElementDOFIdx+1
                residualVector%elementResidual%vector(rowElementDOFIdx)=residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                  & DOT_PRODUCT(dPhidZ(1:numberOfDimensions,rowElementParameterIdx,rowComponentIdx), &
                  & jgwCauchyTensor(1:numberOfDimensions,rowComponentIdx))
              ENDDO !rowElementParameterIdx
            ENDDO !rowComponentIdx

            !Hydrostatic pressure component
            !tempTerm1=jacobianGaussWeight*(Jznu-1.0_DP)
            tempTerm1=jacobianGaussWeight*(1.0_DP-1.0_DP/Jznu)
            SELECT CASE(pressureInterpolationType)
            CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
              DO rowElementParameterIdx=1,numberOfPressureElementParameters
                rowElementDOFIdx=rowElementDOFIdx+1
                CALL BasisQuadratureScheme_GaussBasisFunctionGet(pressureQuadratureScheme,rowElementParameterIdx, &
                  & NO_PART_DERIV,gaussPointIdx,rowPhi,err,error,*999)
                residualVector%elementResidual%vector(rowElementDOFIdx)=residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                  & tempTerm1*rowPhi
              ENDDO
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION) !element based
              rowElementDOFIdx=rowElementDOFIdx+1
              residualVector%elementResidual%vector(rowElementDOFIdx)=residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                & tempTerm1
            CASE DEFAULT
              localError="The pressure interpolation type of "// &
                & TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
                & " for component "//TRIM(NumberToVString(pressureComponent,"*",err,error))// &
                & " of the dependent variable is invalid or not implemented."
              CALL FlagError(localError,err,error,*999)
            END SELECT

!!Gravity loading term
            !IF(rhsVector%updateVector) THEN
            !  IF(ASSOCIATED(sourceField)) THEN
            !    CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx, &
            !      & sourceInterpPoint,err,error,*999)
            !    IF(ASSOCIATED(densityInterpPoint)) THEN
            !      CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx, &
            !        & densityInterpPoint,err,error,*999)
            !       density=densityInterpPoint%values(1,NO_PART_DERIV)
            !       rowElementDOFIdx=0
            !       DO rowComponentIdx=1,numberOfDimensions
            !         meshComponentNumber=dependentVariable%COMPONENTS(rowComponentIdx)%meshComponentNumber
            !         columnBasis=>dependentField%decomposition%DOMAIN(meshComponentNumber)%ptr% &
            !           & TOPOLOGY%ELEMENTS%ELEMENTS(elementNumber)%BASIS
            !         componentQuadratureScheme=>columnBasis%QUADRATURE%quadratureSchemeMap( &
            !           & BASIS_DEFAULT_QUADRATURE_SCHEME)%ptr
            !         G_DENSITY_JGW=sourceInterpPoint%values(rowComponentIdx,NO_PART_DERIV)*DENSITY*JGW
            !         DO rowElementParameterIdx=1,columnBasis%numberOfElementParameters
            !           rowElementDOFIdx=rowElementDOFIdx+1
            !           rhsVector%elementVector%vector(rowElementDOFIdx)=rhsVector%elementVector%vector(rowElementDOFIdx)+ &
            !             & G_DENSITY_JGW*componentQuadratureScheme%gaussBasisFunctions(rowElementParameterIdx,NO_PART_DERIV, &
            !             gaussPointIdx)
            !         ENDDO
            !      ENDDO
            !    ENDIF
            !  ENDIF
            !ENDIF

          ENDDO !gaussPointIdx

          !Call surface pressure term here: should only be executed if THIS element has surface pressure on it
          ! (direct or incremented)
          IF(haveSurfacePressure) THEN   
            CALL FiniteElasticity_SurfacePressureResidualEvaluate(equationsSet,elementNumber,dependentVariableType, &
              & rhsVariableType,err,error,*999)
          ENDIF

        CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE)

          growthValues=[1.0_DP,1.0_DP,1.0_DP]

          !Loop over gauss points and add residuals
          DO gaussPointIdx=1,numberOfGauss

            CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)

            !Interpolate dependent, geometric, fibre and materials fields
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx, &
              & dependentInterpPoint,err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx, &
              & geometricInterpPoint,err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(geometricBasis%numberOfXi,geometricInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
                & err,error,*999)
            ENDIF
            CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
              & err,error,*999)

            !Calculate material fibre coordinate system
            CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
              & dNudXi(1:numberOfXDimensions,1:numberOfXiDimensions),dXidNu(1:numberOfXiDimensions,1:numberOfXDimensions), &
              & fibreVectors(1:numberOfXDimensions,1:numberOfXiDimensions),err,error,*999)
            !Calculate the deformation gradient tensor
            CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
              & dXidNu(1:numberOfXiDimensions,1:numberOfXDimensions),F,J,dZdNu,JZNu,err,error,*999)
            IF(JZnu<0.0_DP) THEN
              localWarning="Volume is negative for gauss point "//TRIM(NumberToVString(gaussPointIdx,"*",err,error))//&
                & " of element "//TRIM(NumberToVString(elementNumber,"*",err,error))//". det(F) = "// &
                & TRIM(NumberToVString(JZNu,"*",err,error))//"."
              CALL FlagWarning(localWarning,err,error,*999) 
            ENDIF

            CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)
            CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,Jzxi,err,error,*999)

            IF(diagnostics1) THEN
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element Number = ",elementNumber,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Gauss Point index = ",gaussPointIdx,err,error,*999)
            ENDIF

            !Calculate Jacobian of deformation.
            CALL FiniteElasticity_GrowthTensorCalculate(equationsSet,numberOfDimensions,dZdNu,growthValues,Fg,Fe,Jg,Je, &
              & err,error,*999)

            !Calculate strain tensors
            CALL FiniteElasticity_ReferenceStrainTensors(numberOfDimensions,Fe,JZNu,C,I3,f,E,err,error,*999)

            !Calculate Sigma=1/Jznu.FTF', the Cauchy stress tensor at the gauss point
            CALL FiniteElasticity_GaussCauchyTensor(equationsSet,numberOfDimensions,dependentInterpPoint, &
              & materialsInterpPoint,geometricInterpPoint,darcyDependentInterpPoint, &
              & independentInterpPoint,elementNumber,gaussPointIdx,dZdNu,JZNu,cauchyTensor,err,error,*999)

            IF(diagnostics1) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Stress tensors:",err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Hydrostatic pressure = ",P,err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Second Piola-Kirchoff stress tensor:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,piolaTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    T','(",I1,",:)','     :",3(X,E13.6))', &
                & '(12X,3(X,E13.6))',err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Cauchy stress tensor:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,cauchyTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    sigma','(",I1,",:)',' :",3(X,E13.6))', &
                & '(12X,3(X,E13.6))',err,error,*999)
            ENDIF

            !Calculate the combined Jacobian
            jacobianGaussWeight=Jzxi*gaussWeight

            !Loop over geometric dependent basis functions and evaluate dPhidZ.
            DO columnComponentIdx=1,numberOfDimensions
              NULLIFY(columnDomain)
              CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnDomain,err,error,*999)
              NULLIFY(columnDomainTopology)
              CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
              NULLIFY(columnDomainElements)
              CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
              NULLIFY(columnBasis)
              CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,columnBasis,err,error,*999)
              NULLIFY(columnQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(columnBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureScheme,err,error,*999)
              CALL Basis_NumberOfElementParametersGet(columnBasis,numberOfColElementParameters,err,error,*999)
              DO columnElementParameterIdx=1,numberOfColElementParameters
                !Loop over derivative directions.
                DO rowComponentIdx=1,numberOfDimensions
                  sum1=0.0_DP
                  DO rowXiIdx=1,numberOfXi
                    CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureScheme,columnElementParameterIdx, &
                      & PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(rowXiIdx),gaussPointIdx,dColumnPhidXi,err,error,*999)
                    sum1=sum1+dependentInterpPointMetrics%dXidX(rowXiIdx,rowComponentIdx)*dColumnPhidXi
                  ENDDO !rowXiIdx
                  dPhidZ(rowComponentIdx,columnElementParameterIdx,columnComponentIdx)=sum1
                ENDDO !rowComponentIdx
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx

            !Now add up the residual terms
            rowElementDOFIdx=0
            DO rowComponentIdx=1,numberOfDimensions
              CALL FieldVariable_ComponentInterpolationGet(rowsVariable,rowComponentIdx,rowInterpolationType,err,error,*999)
              SELECT CASE(rowInterpolationType)
              CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
                NULLIFY(rowDomain)
                CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
                NULLIFY(rowDomainTopology)
                CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
                NULLIFY(rowDomainElements)
                CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
                NULLIFY(rowBasis)
                CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
                CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
                DO rowElementParameterIdx=1,numberOfRowElementParameters
                  rowElementDOFIdx=rowElementDOFIdx+1
                  residualVector%elementResidual%vector(rowElementDOFIdx)= &
                    & residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                    & jacobianGaussWeight*DOT_PRODUCT(DPhiDZ(1:numberOfDimensions,rowElementParameterIdx,rowComponentIdx), &
                    & cauchyTensor(1:numberOfDimensions,rowComponentIdx))
                ENDDO ! rowElementParameterIdx (residual vector loop)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Will probably never be used
                CALL FlagError("Finite elasticity with element based interpolation is not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The row interpolation type of "//TRIM(NumberToVString(rowInterpolationType,"*",err,error))// &
                  & " for row component "//TRIM(NumberToVString(rowComponentIdx,"*",err,error))// &
                  & " is invalid or not implemented."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDDO !rowComponentIdx

            !Hydrostatic pressure component (skip for membrane problems)
            tempTerm1=gaussWeight*Jzxi*(1.0_DP - 1.0_DP/Jznu)
            SELECT CASE(pressureInterpolationType)
            CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
              DO rowElementParameterIdx=1,numberOfPressureElementParameters
                CALL BasisQuadratureScheme_GaussBasisFunctionGet(pressureQuadratureScheme,rowElementParameterIdx,NO_PART_DERIV, &
                  & gaussPointIdx,rowPhi,err,error,*999)
                rowElementDOFIdx=rowElementDOFIdx+1 
                residualVector%elementResidual%vector(rowElementDOFIdx)= &
                  & residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                  & rowPhi*tempTerm1
              ENDDO !rowElementParameterIdx
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION) !element based
              rowElementDOFIdx=rowElementDOFIdx+1                
              residualVector%elementResidual%vector(rowElementDOFIdx)= &
                & residualVector%elementResidual%vector(rowElementDOFIdx)+tempTerm1              
            CASE DEFAULT
              localError="The pressure interpolation type of "// &
                & TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
                & " for component "//TRIM(NumberToVString(pressureComponent,"*",err,error))// &
                & " of the dependent variable is invalid or not implemented."
              CALL FlagError(localError,err,error,*999)
            END SELECT

            IF(updateMass) THEN
              !Compute mass matrix
              density=materialsInterpPoint%values(1,1)/Jznu
              !Loop over field components
              rowElementDofIdx=0          
              DO rowComponentIdx=1,numberOfDimensions
                NULLIFY(rowDomain)
                CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
                NULLIFY(rowDomainTopology)
                CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
                NULLIFY(rowDomainElements)
                CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
                NULLIFY(rowBasis)
                CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
                NULLIFY(rowQuadratureScheme)
                CALL Basis_QuadratureSchemeGet(rowBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowQuadratureScheme,err,error,*999)
                CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
                !Loop over element rows
                DO rowElementParameterIdx=1,numberOfRowElementParameters
                  rowElementDofIdx=rowElementDofIdx+1
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowQuadratureScheme,rowElementParameterIdx,NO_PART_DERIV, &
                    & gaussPointIdx,rowPhi,err,error,*999)                
                  columnElementDofIdx=0
                  !Loop over element columns
                  DO columnComponentIdx=1,numberOfDimensions
                    NULLIFY(columnDomain)
                    CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnDomain,err,error,*999)
                    NULLIFY(columnDomainTopology)
                    CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
                    NULLIFY(columnDomainElements)
                    CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
                    NULLIFY(columnBasis)
                    CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,columnBasis,err,error,*999)
                    NULLIFY(columnQuadratureScheme)
                    CALL Basis_QuadratureSchemeGet(columnBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureScheme, &
                      & err,error,*999)
                    CALL Basis_NumberOfElementParametersGet(columnBasis,numberOfColElementParameters,err,error,*999)
                    DO columnElementParameterIdx=1,numberOfColElementParameters
                      columnElementDofIdx=columnElementDofIdx+1
                      CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureScheme,columnElementParameterIdx, &
                        & NO_PART_DERIV,gaussPointIdx,columnPhi,err,error,*999)                
                      massMatrix%elementMatrix%matrix(rowElementDofIdx,columnElementDofIdx)= &
                        & massMatrix%elementMatrix%matrix(rowElementDofIdx,columnElementDofIdx)+ &                    
                        & rowPhi*columnPhi*jacobianGaussWeight*density
                    ENDDO !columnElementParameterIdx
                  ENDDO !columnComponentIdx
                ENDDO !rowElementParameterIdx
              ENDDO !rowComponentIdx
            ENDIF !update mass matrix

          ENDDO !gaussPointIdx

          !Call surface pressure term: should only be executed if THIS element has surface pressure on it (direct or incremented)
          IF(haveSurfacePressure) THEN    ! 
            CALL FiniteElasticity_SurfacePressureResidualEvaluate(equationsSet,elementNumber,dependentVariableType, &
              & rhsVariableType,err,error,*999)
          ENDIF

          ! ---------------------------------------------------------------
        CASE(EQUATIONS_SET_NO_SUBTYPE,EQUATIONS_SET_MEMBRANE_SUBTYPE, &
          & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE, &
          & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE, &
          & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE,EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_NOLENDEP_SUBTYPE, &
          & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_2NDPIOLA_SUBTYPE, &
          & EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE, &
          & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE, EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE,EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE, &
          & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE,EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE, &
          & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE,EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
          & EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE,EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE, &
          & EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE, &
          & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE, &
          & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE, &
          & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE,EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE, &
          & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE, &
          & EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE) ! 4 dependent components

          growthValues=[1.0_DP,1.0_DP,1.0_DP]

          !Loop over gauss points and add residuals
          DO gaussPointIdx=1,numberOfGauss

            CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)

            !Interpolate dependent, geometric, fibre and materials fields
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
                & err,error,*999)
            END IF
            CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
              & err,error,*999)
            IF(darcyDependent) THEN
              CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,darcyDependentInterpParameters, &
                & err,error,*999)
            ELSE IF(equationsSetSubtype==EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE .OR. &
              & equationsSetSubtype==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE.OR. &
              & equationsSetSubtype==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_NOLENDEP_SUBTYPE .OR. &
              & equationsSetSubtype==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_2NDPIOLA_SUBTYPE) THEN
              CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,independentInterpParameters, &
                & err,error,*999)
            ENDIF

            !Calculate material fibre coordinate system
            CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
              & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
              & fibreVectors(1:numberOfDimensions,1:numberOfXi),err,error,*999)
            !Calculate F=dZ/dNU, the deformation gradient tensor at the gauss point
            CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
              & dXidNu(1:numberOfXi,1:numberOfDimensions),dZdX,JZ,dZdNu,Jznu,err,error,*999)
            IF(JZNu<0.0_DP) THEN
              localWarning="Volume is negative for gauss point "//TRIM(NumberToVString(gaussPointIdx,"*",err,error))//&
                & " of element "//TRIM(NumberToVString(elementNumber,"*",err,error))//". det(F) = "// &
                & TRIM(NumberToVString(JZNu,"*",err,error))//"."
              CALL FlagWarning(localWarning,err,error,*999) 
            ENDIF

            CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)
            CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,Jzxi,err,error,*999)

            IF(diagnostics1) THEN
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",elementNumber,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Gauss point index = ",gaussPointIdx,err,error,*999)
            ENDIF

            !Calculate Jacobian of deformation.
            CALL FiniteElasticity_GrowthTensorCalculate(equationsSet,numberOfDimensions,dZdNu,growthValues,Fg,Fe,Jg,Je, &
              & err,error,*999)

            !Calculate strain tensors
            CALL FiniteElasticity_ReferenceStrainTensors(numberOfDimensions,Fe,Jznu,C,I3,f,E,err,error,*999)

            !Calculate Sigma=1/Jznu.FTF', the Cauchy stress tensor at the gauss point
            CALL FiniteElasticity_GaussCauchyTensor(equationsSet,numberOfDimensions,dependentInterpPoint, &
              & materialsInterpPoint,geometricInterpPoint,darcyDependentInterpPoint,independentInterpPoint, &
              & elementNumber,gaussPointIdx,dZdNu,Jznu,cauchyTensor,err,error,*999)

            IF(diagnostics1) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Stress tensors:",err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Hydrostatic pressure = ",P,err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Second Piola-Kirchoff stress tensor:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,piolaTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    T','(",I1,",:)','     :",3(X,E13.6))', &
                & '(12X,3(X,E13.6))',err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Cauchy stress tensor:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,cauchyTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    sigma','(",I1,",:)',' :",3(X,E13.6))', &
                & '(12X,3(X,E13.6))',err,error,*999)
            ENDIF

            IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE) THEN
              !Parameters settings for coupled elasticity Darcy INRIA model:
              CALL FiniteElasticity_GetDarcyParameters(darcyRho0F,Mfact,bfact,p0fact,err,error,*999)
              darcyMassIncrease = darcyDependentInterpPoint%values(4,NO_PART_DERIV) 
              darcyVolIncrease = darcyMassIncrease / darcyRho0F
            ENDIF

            !For membrane theory in 3D space, the final equation is multiplied by thickness. Default to unit thickness if
            !equation set subtype is not membrane
            thickness = 1.0_DP
            IF(equationsSetSubtype == EQUATIONS_SET_MEMBRANE_SUBTYPE) THEN
              IF(numberOfDimensions == 3) thickness = materialsInterpPoint%values(numberOfMaterialsComponents,1)
            ENDIF

            !Calculate the combined Jacobian
            jacobianGaussWeight=Jzxi*gaussWeight

            !Loop over geometric dependent basis functions and evaluate dPhidZ.
            DO columnComponentIdx=1,numberOfDimensions
              NULLIFY(columnDomain)
              CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnDomain,err,error,*999)
              NULLIFY(columnDomainTopology)
              CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
              NULLIFY(columnDomainElements)
              CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
              NULLIFY(columnBasis)
              CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,columnBasis,err,error,*999)
              NULLIFY(columnQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(columnBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureScheme, &
                & err,error,*999)
              CALL Basis_NumberOfElementParametersGet(columnBasis,numberOfColElementParameters,err,error,*999)
              DO columnElementParameterIdx=1,numberOfColElementParameters
                !Loop over derivative directions.
                DO rowComponentIdx=1,numberOfDimensions
                  sum1=0.0_DP
                  DO rowXiIdx=1,numberOfXi
                    CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureScheme,columnElementParameterIdx, &
                      & PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(rowXiIdx),gaussPointIdx,dcolumnPhidXi,err,error,*999)                
                    sum1=sum1+dependentInterpPointMetrics%dXidX(rowXiIdx,rowComponentIdx)*dcolumnPhidXi
                  ENDDO !rowXiIdx
                  dPhidZ(rowComponentIdx,columnElementParameterIdx,columnComponentIdx)=sum1
                ENDDO !rowComponentIdx
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx

            !Now add up the residual terms
            rowElementDOFIdx=0
            DO rowComponentIdx=1,numberOfDimensions
              CALL FieldVariable_ComponentInterpolationGet(rowsVariable,rowComponentIdx,rowInterpolationType,err,error,*999)
              SELECT CASE(rowInterpolationType)
              CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
                NULLIFY(rowDomain)
                CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
                NULLIFY(rowDomainTopology)
                CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
                NULLIFY(rowDomainElements)
                CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
                NULLIFY(rowBasis)
                CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
                CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
                DO rowElementParameterIdx=1,numberOfRowElementParameters
                  rowElementDOFIdx=rowElementDOFIdx+1
                  residualVector%elementResidual%vector(rowElementDOFIdx)= &
                    & residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                    & jacobianGaussWeight*DOT_PRODUCT(DPhiDZ(1:numberOfDimensions,rowElementParameterIdx,rowComponentIdx), &
                    & cauchyTensor(1:numberOfDimensions,rowComponentIdx))
                ENDDO ! rowElementParameterIdx (residual vector loop)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Will probably never be used
                CALL FlagError("Finite elasticity with element based interpolation is not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The row interpolation type of "//TRIM(NumberToVString(rowInterpolationType,"*",err,error))// &
                  & " for row component "//TRIM(NumberToVString(rowComponentIdx,"*",err,error))// &
                  & " is invalid or not implemented."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDDO ! rowComponentIdx

            !Hydrostatic pressure component (skip for membrane problems)
            IF(equationsSetSubtype /= EQUATIONS_SET_MEMBRANE_SUBTYPE) THEN
              IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE) THEN
                tempTerm1=gaussWeight*(Jzxi-(Jg-darcyVolIncrease)*Jxxi)
              ELSE
                tempTerm1=gaussWeight*(Jzxi/Jxxi - 1.0_DP)*Jxxi
              ENDIF
              SELECT CASE(pressureInterpolationType)
              CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
                DO rowElementParameterIdx=1,numberOfPressureElementParameters
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(pressureQuadratureScheme,rowElementParameterIdx,NO_PART_DERIV, &
                    & gaussPointIdx,rowPhi,err,error,*999)
                  rowElementDOFIdx=rowElementDOFIdx+1 
                  residualVector%elementResidual%vector(rowElementDOFIdx)= &
                    & residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                    & rowPhi*tempTerm1
                ENDDO !rowElementParameterIdx
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION) !element based
                rowElementDOFIdx=rowElementDOFIdx+1                
                residualVector%elementResidual%vector(rowElementDOFIdx)= &
                  & residualVector%elementResidual%vector(rowElementDOFIdx)+tempTerm1              
              CASE DEFAULT
                localError="The pressure interpolation type of "// &
                  & TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
                  & " for component "//TRIM(NumberToVString(pressureComponent,"*",err,error))// &
                  & " of the dependent variable is invalid or not implemented."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF !not membrane


            IF(equationsSetSubtype == EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
              & equationsSetSubtype == EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE) THEN
              IF(updateMass) THEN
                !Compute mass matrix
                density=materialsInterpPoint%values(1,1)/Jznu
                !Loop over field components
                rowElementDofIdx=0          
                DO rowComponentIdx=1,numberOfDimensions
                  NULLIFY(rowDomain)
                  CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
                  NULLIFY(rowDomainTopology)
                  CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
                  NULLIFY(rowDomainElements)
                  CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
                  NULLIFY(rowBasis)
                  CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
                  NULLIFY(rowQuadratureScheme)
                  CALL Basis_QuadratureSchemeGet(rowBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowQuadratureScheme,err,error,*999)
                  CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
                  !Loop over element rows
                  DO rowElementParameterIdx=1,numberOfRowElementParameters
                    rowElementDofIdx=rowElementDofIdx+1
                    CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowQuadratureScheme,rowElementParameterIdx,NO_PART_DERIV, &
                      & gaussPointIdx,rowPhi,err,error,*999)                
                    columnElementDofIdx=0
                    !Loop over element columns
                    DO columnComponentIdx=1,numberOfDimensions
                      NULLIFY(columnDomain)
                      CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnDomain,err,error,*999)
                      NULLIFY(columnDomainTopology)
                      CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
                      NULLIFY(columnDomainElements)
                      CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
                      NULLIFY(columnBasis)
                      CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,columnBasis,err,error,*999)
                      NULLIFY(columnQuadratureScheme)
                      CALL Basis_QuadratureSchemeGet(columnBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureScheme, &
                        & err,error,*999)
                      CALL Basis_NumberOfElementParametersGet(columnBasis,numberOfColElementParameters,err,error,*999)
                      DO columnElementParameterIdx=1,columnBasis%numberOfElementParameters
                        columnElementDofIdx=columnElementDofIdx+1
                        CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureScheme,columnElementParameterIdx, &
                          & NO_PART_DERIV,gaussPointIdx,columnPhi,err,error,*999)                
                        massMatrix%elementMatrix%matrix(rowElementDofIdx,columnElementDofIdx)= &
                          & massMatrix%elementMatrix%matrix(rowElementDofIdx,columnElementDofIdx)+ &                    
                          & rowPhi*columnPhi*jacobianGaussWeight*density
                      ENDDO !columnElementParameterIdx
                    ENDDO !columnComponentIdx
                  ENDDO !rowElementParameterIdx
                ENDDO !rowComponentIdx
              ENDIF !update mass matrix
            ENDIF

          ENDDO !gaussPointIdx

          !Call surface pressure term: should only be executed if THIS element has surface pressure on it (direct or incremented)
          IF(haveSurfacePressure) THEN    ! 
            CALL FiniteElasticity_SurfacePressureResidualEvaluate(equationsSet,elementNumber,dependentVariableType, &
              & rhsVariableType,err,error,*999)
          ENDIF

          ! ---------------------------------------------------------------
        CASE(EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)

          !Loop over gauss points and add residuals
          DO gaussPointIdx=1,numberOfGauss

            IF(diagnostics1) THEN
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",elementNumber,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Gauss Point index = ",gaussPointIdx,err,error,*999)
            ENDIF

            CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)

            !Interpolate dependent, geometric, fibre and materials fields
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
                & err,error,*999)
            ENDIF
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
              & err,error,*999)
            CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
              & gaussPointIdx,elementNumber,1,growthValues(1),err,error,*999)
            IF(numberofDimensions>1) THEN
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,2,growthValues(2),err,error,*999)
              IF(numberOfDimensions>2) THEN
                CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                  & gaussPointIdx,elementNumber,3,growthValues(3),err,error,*999)
              ENDIF
            ENDIF

            !Calculate material fibre coordinate system
            CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
              & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
              & fibreVectors(1:numberOfDimensions,1:numberOfXi),err,error,*999)
            !Calculate F=dZ/dNU, the deformation gradient tensor at the gauss point
            CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
              & dXidNu(1:numberOfXi,1:numberOfDimensions),dZdX,JZ,dZdNu,JZNu,err,error,*999)

            CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)
            CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,Jzxi,err,error,*999)

            P=dependentInterpPoint%values(pressureComponent,1)

            CALL FiniteElasticity_GrowthTensorCalculate(equationsSet,numberOfDimensions,dZdNu,growthValues,Fg,Fe,Jg,Je, &
              & err,error,*999)

            CALL FiniteElasticity_ReferenceStrainTensors(numberOfDimensions,Fe,Jznu,C,I3,f,E,err,error,*999)

            !Calculate the Cauchy stress tensor (in Voigt form) at the gauss point.
            CALL FiniteElasticity_GaussStressTensor(equationsSet,numberOfDimensions,dependentInterpPoint, &
              & materialsInterpPoint,geometricInterpPoint,stressTensor,Fe,Jznu,elementNumber,gaussPointIdx,err,error,*999)

            !Convert from Voigt form to tensor form and multiply with Jacobian and Gauss weight.
            jacobianGaussWeight=Jzxi*gaussWeight
            CALL VoigtToTensor(numberOfDimensions,[TENSOR_CONTRAVARIANT_INDEX],stressTensor,jgwCauchyTensor,err,error,*999)
            jgwCauchyTensor=jgwCauchyTensor*jacobianGaussWeight

            IF(diagnostics1) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Stress tensors:",err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Hydrostatic pressure = ",P,err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Second Piola-Kirchoff stress tensor:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,piolaTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    T','(",I1,",:)','     :",3(X,E13.6))', &
                & '(12X,3(X,E13.6))',err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Cauchy stress tensor:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,cauchyTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    sigma','(",I1,",:)',' :",3(X,E13.6))', &
                & '(12X,3(X,E13.6))',err,error,*999)
            ENDIF

            !For membrane theory in 3D space, the final equation is multiplied by thickness. Default to unit thickness if
            !equation set subtype is not membrane.
!!TODO Maybe have the thickness as a component in the equations set field. Yes, as we don't need a materials field for
!!CellML constituative laws.
            thickness = 1.0_DP
            IF(equationsSetSubtype == EQUATIONS_SET_MEMBRANE_SUBTYPE) THEN
              IF(numberOfDimensions == 3) THEN
                IF(ASSOCIATED(materialsField)) THEN
                  CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx, &
                    & materialsInterpPoint,err,error,*999)
                  thickness = materialsInterpPoint%values(numberOfMaterialsComponents,1)
                ENDIF
              ENDIF
            ENDIF

!!Now add up the residual terms

            !Loop over geometric dependent basis functions.
            DO columnComponentIdx=1,numberOfDimensions
              NULLIFY(columnDomain)
              CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnDomain,err,error,*999)
              NULLIFY(columnDomainTopology)
              CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
              NULLIFY(columnDomainElements)
              CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
              NULLIFY(columnBasis)
              CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,columnBasis,err,error,*999)
              NULLIFY(columnQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(columnBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureScheme, &
                & err,error,*999)
              CALL Basis_NumberOfElementParametersGet(columnBasis,numberOfColElementParameters,err,error,*999)
              DO columnElementParameterIdx=1,numberOfColElementParameters
                !Loop over derivative directions.
                DO rowComponentIdx=1,numberOfDimensions
                  sum1=0.0_DP
                  DO rowXiIdx=1,numberOfXi
                    CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureScheme,columnElementParameterIdx, &
                      & PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(rowXiIdx),gaussPointIdx,dColumnPhidXi,err,error,*999)                
                    sum1=sum1+dependentInterpPointMetrics%dXidX(rowXiIdx,rowComponentIdx)*dColumnPhidXi
                  ENDDO !rowXiIdx
                  dPhidZ(rowComponentIdx,columnElementParameterIdx,columnComponentIdx)=sum1
                ENDDO !rowComponentIdx
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx

            !Now add up the residual terms
            rowElementDOFIdx=0
            DO rowComponentIdx=1,numberOfDimensions
              NULLIFY(rowDomain)
              CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
              NULLIFY(rowDomainTopology)
              CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
              NULLIFY(rowDomainElements)
              CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
              NULLIFY(rowBasis)
              CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
              NULLIFY(rowQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(rowBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowQuadratureScheme,err,error,*999)
              CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
              DO rowElementParameterIdx=1,numberOfRowElementParameters
                rowElementDOFIdx=rowElementDOFIdx+1
                residualVector%elementResidual%vector(rowElementDOFIdx)=residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                  & DOT_PRODUCT(dPhidZ(1:numberOfDimensions,rowElementParameterIdx,rowComponentIdx), &
                  & jgwCauchyTensor(1:numberOfDimensions,rowComponentIdx))
              ENDDO !rowElementParameterIdx
            ENDDO !rowComponentIdx

            !Hydrostatic pressure component (skip for membrane problems)
            IF (equationsSetSubtype /= EQUATIONS_SET_MEMBRANE_SUBTYPE) THEN
              IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE) THEN
                tempTerm1=gaussWeight*Jxxi*(Jznu-(Jg-darcyVolIncrease))
              ELSE
                tempTerm1=gaussWeight*Jxxi*(Jznu-Jg)
              ENDIF
              SELECT CASE(pressureInterpolationType)
              CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
                DO rowElementParameterIdx=1,numberOfPressureElementParameters
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(pressureQuadratureScheme,rowElementParameterIdx,NO_PART_DERIV, &
                    & gaussPointIdx,rowPhi,err,error,*999)
                  rowElementDOFIdx=rowElementDOFIdx+1 
                  residualVector%elementResidual%vector(rowElementDOFIdx)= &
                    & residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                    & rowPhi*tempTerm1                  
                ENDDO !rowElementParameterIdx
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION) !element based
                rowElementDOFIdx=rowElementDOFIdx+1
                residualVector%elementResidual%vector(rowElementDOFIdx)= &
                  & residualVector%elementResidual%vector(rowElementDOFIdx)+tempTerm1
              CASE DEFAULT
                localError="The pressure interpolation type of "// &
                  & TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
                  & " for component "//TRIM(NumberToVString(pressureComponent,"*",err,error))// &
                  & " of the dependent variable is invalid or not implemented."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          ENDDO !gaussPointIdx

          !Call surface pressure term: should only be executed if THIS element has surface pressure on it (direct or incremented
          IF(haveSurfacePressure) THEN    ! 
            CALL FiniteElasticity_SurfacePressureResidualEvaluate(equationsSet,elementNumber,dependentVariableType, &
              & rhsVariableType,err,error,*999)
          ENDIF

        CASE(EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE)

          CALL IdentityMatrix(ITens,err,error,*999)
          CALL EquationsSet_CurrentTimeGet(equationsSet,time,err,error,*999)

          !Loop over gauss points and add residuals
          DO gaussPointIdx=1,numberOfGauss

            IF(diagnostics1) THEN
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",elementNumber,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Gauss point index  = ",gaussPointIdx,err,error,*999)
            ENDIF

            CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)

            !Interpolate dependent, geometric, fibre and materials fields
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(columnBasis%numberOfXi,dependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(geometricBasis%numberOfXi,geometricInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
                & err,error,*999)
            ENDIF
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
              & err,error,*999)

            q=materialsInterpPoint%values(1,NO_PART_DERIV)
            k1=materialsInterpPoint%values(2,NO_PART_DERIV)
            k2=materialsInterpPoint%values(3,NO_PART_DERIV)
            k3=materialsInterpPoint%values(4,NO_PART_DERIV)
            k4=materialsInterpPoint%values(5,NO_PART_DERIV)
            b1=materialsInterpPoint%values(6,NO_PART_DERIV)
            b2=materialsInterpPoint%values(7,NO_PART_DERIV)
            b3=materialsInterpPoint%values(8,NO_PART_DERIV)
            b4=materialsInterpPoint%values(9,NO_PART_DERIV)
            b5=materialsInterpPoint%values(10,NO_PART_DERIV)
            b6=materialsInterpPoint%values(11,NO_PART_DERIV)
            mu0=materialsInterpPoint%values(12,NO_PART_DERIV)
            rho0=materialsInterpPoint%values(13,NO_PART_DERIV)

            A1g=materialsInterpPoint%values(14,NO_PART_DERIV)
            B0g=materialsInterpPoint%values(15,NO_PART_DERIV)
            B1g=materialsInterpPoint%values(16,NO_PART_DERIV)
            B2g=materialsInterpPoint%values(17,NO_PART_DERIV)
            alphag=materialsInterpPoint%values(18,NO_PART_DERIV)
            chi1g=materialsInterpPoint%values(19,NO_PART_DERIV)
            chi2g=materialsInterpPoint%values(20,NO_PART_DERIV)
            phig=materialsInterpPoint%values(21,NO_PART_DERIV)
            R1g=materialsInterpPoint%values(22,NO_PART_DERIV)
            R2g=materialsInterpPoint%values(23,NO_PART_DERIV)
            Lg=materialsInterpPoint%values(24,NO_PART_DERIV)

            x=geometricInterpPoint%values(1,NO_PART_DERIV)
            y=geometricInterpPoint%values(2,NO_PART_DERIV)
            z=geometricInterpPoint%values(3,NO_PART_DERIV)

            r=SQRT(x*x+y*y)
            theta=ATAN2(x,y)

            !Calculate F=dZ/dNU, the deformation gradient tensor at the gauss point
            CALL MatrixProduct(dependentInterpPointMetrics%dXdXi(1:3,1:3),geometricInterpPointMetrics%dXidX(1:3,1:3), &
              & dZdNu(1:3,1:3),err,error,*999)

            CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)
            CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,Jzxi,err,error,*999)

            jacobianGaussWeight=Jzxi*gaussWeight

            Dg22=A1g*(1.0_DP-EXP(-1.0_DP*alphag*MacaulayBracket(z/lg-chi1g)**2.0_DP)- &
              & EXP(-1.0_DP*alphag*MacaulayBracket(chi2g-z/lg)**2.0_DP))+ &
              & (B0g+(B1g-B0g)*(1.0_DP-EXP(-1.0_DP*alphag*MacaulayBracket(z/lg-chi1g)**2.0_DP))+ &
              & (B2g-B1g)*EXP(-1.0_DP*alphag*MacaulayBracket(chi2g-z/lg)**2.0_DP))*r*SIN(theta-phig)/R2g

            CALL IdentityMatrix(Fg,err,error,*999)
            Fg(3,3)=EXP(Dg22*time)

            !Calculate inverse growth deformation tensor, Fg^-1, Jg 
            CALL Invert(Fg,FgInv,Jg,err,error,*999)
            !Calculate elastic deformation tensor, Fe=F.(Fg)^-1.       
            CALL MatrixProduct(dZdNu,FgInv,Fe,err,error,*999)
            CALL Determinant(Fe,Je,err,error,*999)

            !Compute the distortional tensor
            CALL MatrixProductTranspose(Fe,Fe,Beprime,err,error,*999)
            Beprime=Beprime*Je**(2.0_DP/3.0_DP)
            CALL DoubleDotProduct(Beprime,Itens,alpha1,err,error,*999)
            bigQ=0.5_DP*(k1*(0.5_DP*(Je*Je-1.0_DP)-LOG(Je))+k2*(alpha1-3.0_DP))
            delWdelQ=mu0*bigQ*EXP(q*bigQ)
            delQdelJe=k1*(Je*Je-1)/(2.0_DP*Je)
            delQdelAlpha=k2
            delWdelJe=delWdelQ*delQdelJe
            delWdelAlpha=delWdelQ*delQdelAlpha

            cauchyTensor=delWdelJe*Itens+(2.0_DP/Je)*delWdelAlpha*(Beprime-(alpha1/3.0_DP)*Itens)

            IF(diagnostics1) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Stress tensors:",err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Cauchy stress tensor:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,cauchyTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    sigma','(",I1,",:)',' :",3(X,E13.6))', &
                & '(12X,3(X,E13.6))',err,error,*999)
            ENDIF

            !Loop over geometric dependent basis functions.
            DO columnComponentIdx=1,numberOfDimensions
              NULLIFY(columnDomain)
              CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnDomain,err,error,*999)
              NULLIFY(columnDomainTopology)
              CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
              NULLIFY(columnDomainElements)
              CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
              NULLIFY(columnBasis)
              CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,columnBasis,err,error,*999)
              NULLIFY(columnQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(columnBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureScheme, &
                & err,error,*999)
              CALL Basis_NumberOfElementParametersGet(columnBasis,numberOfColElementParameters,err,error,*999)
              DO columnElementParameterIdx=1,numberOfColElementParameters
                !Loop over derivative directions.
                DO rowComponentIdx=1,numberOfDimensions
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureScheme,columnElementParameterIdx, &
                    & PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(rowXiIdx),gaussPointIdx,dColumnPhidXi,err,error,*999)                
                  sum1=0.0_DP
                  DO rowXiIdx=1,numberOfXi
                    sum1=sum1+dependentInterpPointMetrics%dXidX(rowXiIdx,rowComponentIdx)*dColumnPhidXi
                  ENDDO !mi
                  dPhidZ(rowComponentIdx,columnElementParameterIdx,columnComponentIdx)=sum1
                ENDDO !rowComponentIdx
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx

            !Now add up the residual terms
            rowElementDOFIdx=0
            DO rowComponentIdx=1,numberOfDimensions
              NULLIFY(rowDomain)
              CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
              NULLIFY(rowDomainTopology)
              CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
              NULLIFY(rowDomainElements)
              CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
              NULLIFY(rowBasis)
              CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
              NULLIFY(rowQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(rowBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowQuadratureScheme,err,error,*999)
              CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
              DO rowElementParameterIdx=1,columnBasis%numberOfElementParameters
                rowElementDOFIdx=rowElementDOFIdx+1
                residualVector%elementResidual%vector(rowElementDOFIdx)=residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                  & jacobianGaussWeight*DOT_PRODUCT(dPhidZ(1:numberOfDimensions,rowElementParameterIdx,rowComponentIdx), &
                  & cauchyTensor(1:numberOfDimensions,rowComponentIdx))
              ENDDO !rowElementParameterIdx
            ENDDO !rowComponentIdx

          ENDDO !gaussPointIdx

          !Call surface pressure term: should only be executed if THIS element has surface pressure on it (direct or incremented)
          IF(haveSurfacePressure) THEN    ! 
            CALL FiniteElasticity_SurfacePressureResidualEvaluate(equationsSet,elementNumber,dependentVariableType, &
              & rhsVariableType,err,error,*999)
          ENDIF

        CASE(EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
          & EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)

          !Loop over gauss points and add residuals
          DO gaussPointIdx=1,numberOfGauss

            IF(diagnostics1) THEN
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",elementNumber,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Gauss point index  = ",gaussPointIdx,err,error,*999)
            ENDIF

            CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)

            !Interpolate dependent, geometric, fibre and materials fields
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
                & err,error,*999)
            ENDIF
            IF(equationsSetSubtype==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,1,growthValues(1),err,error,*999)
              IF(numberofDimensions>1) THEN
                CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                  & gaussPointIdx,elementNumber,2,growthValues(2),err,error,*999)
                IF(numberOfDimensions>2) THEN
                  CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                    & gaussPointIdx,elementNumber,3,growthValues(3),err,error,*999)
                ENDIF
              ENDIF
            ELSE
              growthValues=[1.0_DP,1.0_DP,1.0_DP]
            ENDIF

            !Calculate material fibre coordinate system
            CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
              & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
              & fibreVectors(1:numberOfDimensions,1:numberOfXi),err,error,*999)
            !Calculate F=dZ/dNU, the deformation gradient tensor at the gauss point
            CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
              & dXidNu(1:numberOfXi,1:numberOfDimensions),dZdX,JZ,dZdNu,JZNu,err,error,*999)

            CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)
            CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,Jzxi,err,error,*999)

            jacobianGaussWeight=Jzxi*gaussWeight

            P=dependentInterpPoint%values(pressureComponent,1)

            CALL FiniteElasticity_GrowthTensorCalculate(equationsSet,numberOfDimensions,dZdNu,growthValues,Fg,Fe,Jg,Je, &
              & err,error,*999)

            CALL FiniteElasticity_ReferenceStrainTensors(numberOfDimensions,Fe,JZNu,C,I3,f,E,err,error,*999)

            !Get the stress field!!!
            IF(numberOfDimensions==3) THEN
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,1,piolaTensor(1,1),err,error,*999)
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,2,piolaTensor(1,2),err,error,*999)
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,3,piolaTensor(1,3),err,error,*999)
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,4,piolaTensor(2,2),err,error,*999)
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,5,piolaTensor(2,3),err,error,*999)
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,6,piolaTensor(3,3),err,error,*999)
              !CellML computes the deviatoric stress. Add the volumetric component!
              piolaTensor(1,1)=piolaTensor(1,1)+P*f(1,1)
              piolaTensor(2,2)=piolaTensor(2,2)+P*f(2,2)
              piolaTensor(3,3)=piolaTensor(3,3)+P*f(3,3)
              piolaTensor(1,2)=piolaTensor(1,2)+P*f(1,2)
              piolaTensor(1,3)=piolaTensor(1,3)+P*f(1,3)
              piolaTensor(2,3)=piolaTensor(2,3)+P*f(2,3)
              piolaTensor(2,1)=piolaTensor(1,2)
              piolaTensor(3,1)=piolaTensor(1,3)
              piolaTensor(3,2)=piolaTensor(2,3)
            ELSE IF(numberOfDimensions==2) THEN
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,1,piolaTensor(1,1),err,error,*999)
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,2,piolaTensor(1,2),err,error,*999)
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,3,piolaTensor(2,2),err,error,*999)
              !CellML computes the deviatoric stress. Add the volumetric component!
              piolaTensor(1,1)=piolaTensor(1,1)+P*f(1,1)
              piolaTensor(2,2)=piolaTensor(2,2)+P*f(2,2)
              piolaTensor(1,2)=piolaTensor(1,2)+P*f(1,2)
              piolaTensor(2,1)=piolaTensor(1,2)
            ELSE
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,1,piolaTensor(1,1),err,error,*999)
              piolaTensor(1,1)=piolaTensor(1,1)+P*f(1,1)
            ENDIF

            !Compute the Kirchoff stress tensor by pushing the 2nd Piola Kirchoff stress tensor forward \tau = F.S.F^T
            CALL MatrixProduct(Fe,piolaTensor,temp,err,error,*999)
            CALL MatrixProductTranspose(temp,Fe,kirchoffTensor,err,error,*999)

            !Calculate the Cauchy stress tensor
            cauchyTensor=kirchoffTensor/Je

            IF(diagnostics1) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Stress tensors:",err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Hydrostatic pressure = ",P,err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Second Piola-Kirchoff stress tensor:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,piolaTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    T','(",I1,",:)','     :",3(X,E13.6))', &
                & '(12X,3(X,E13.6))',err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Cauchy stress tensor:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,cauchyTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    sigma','(",I1,",:)',' :",3(X,E13.6))', &
                & '(12X,3(X,E13.6))',err,error,*999)
            ENDIF

            !Calculate dPhi/dZ at the gauss point, Phi is the basis function
            !CALL FINITE_ELASTICITY_GAUSS_dFdZ(dependentInterpPoint,elementNumber,gaussPointIdx,numberOfDimensions, &
            !  & numberOfXi,dFdZ,err,error,*999)

            !For membrane theory in 3D space, the final equation is multiplied by thickness. Default to unit thickness if
            !equation set subtype is not membrane
!!TODO Maybe have the thickness as a component in the equations set field. Yes, as we don't need a materials field for
!!CellML constituative laws.
            thickness = 1.0_DP
            IF(equationsSetSubtype == EQUATIONS_SET_MEMBRANE_SUBTYPE) THEN
              IF(numberOfDimensions == 3) THEN
                IF(ASSOCIATED(materialsField)) THEN
                  CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
                    & err,error,*999)
                  thickness = materialsInterpPoint%values(numberOfMaterialsComponents,1)
                ENDIF
              ENDIF
            ENDIF

            !Loop over geometric dependent basis functions.
            DO columnComponentIdx=1,numberOfDimensions
              NULLIFY(columnDomain)
              CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnDomain,err,error,*999)
              NULLIFY(columnDomainTopology)
              CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
              NULLIFY(columnDomainElements)
              CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
              NULLIFY(columnBasis)
              CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,columnBasis,err,error,*999)
              NULLIFY(columnQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(columnBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureScheme, &
                & err,error,*999)
              CALL Basis_NumberOfElementParametersGet(columnBasis,numberOfColElementParameters,err,error,*999)
              DO columnElementParameterIdx=1,numberOfColElementParameters
                !Loop over derivative directions.
                DO rowComponentIdx=1,numberOfDimensions
                  sum1=0.0_DP
                  DO rowXiIdx=1,numberOfXi
                    CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureScheme,columnElementParameterIdx, &
                      & PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(rowXiIdx),gaussPointIdx,dColumnPhidXi,err,error,*999)                
                    sum1=sum1+dependentInterpPointMetrics%dXidX(rowXiIdx,rowComponentIdx)*dColumnPhidXi
                  ENDDO !rowXiIdx
                  dPhidZ(rowComponentIdx,columnElementParameterIdx,columnComponentIdx)=sum1
                ENDDO !rowComponentIdx
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx

            !Now add up the residual terms
            rowElementDofIdx=0
            DO rowComponentIdx=1,numberOfDimensions
              NULLIFY(rowDomain)
              CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
              NULLIFY(rowDomainTopology)
              CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
              NULLIFY(rowDomainElements)
              CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
              NULLIFY(rowBasis)
              CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
              NULLIFY(rowQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(rowBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowQuadratureScheme,err,error,*999)
              CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
              DO rowElementParameterIdx=1,numberOfRowElementParameters
                rowElementDofIdx=rowElementDofIdx+1
                residualVector%elementResidual%vector(rowElementDofIdx)= &
                  & residualVector%elementResidual%vector(rowElementDofIdx)+ &
                  & jacobianGaussWeight*DOT_PRODUCT(dPhidZ(1:numberOfDimensions,rowElementParameterIdx,rowComponentIdx), &
                  & cauchyTensor(1:numberOfDimensions,rowComponentIdx))
              ENDDO !rowElementParameterIdx
            ENDDO !rowComponentIdx

            !Hydrostatic pressure component (skip for membrane problems)
            IF(equationsSetSubtype /= EQUATIONS_SET_MEMBRANE_SUBTYPE) THEN
              IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE) THEN
                tempTerm1=gaussWeight*Jzxi*(Je-(1.0_DP-darcyVolIncrease))
              ELSE
                tempTerm1=gaussWeight*Jzxi*(Je-1.0_DP)
              ENDIF
              SELECT CASE(pressureInterpolationType)
              CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
                DO rowElementParameterIdx=1,numberOfPressureElementParameters
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(pressureQuadratureScheme,rowElementParameterIdx,NO_PART_DERIV, &
                    & gaussPointIdx,rowPhi,err,error,*999)
                  rowElementDOFIdx=rowElementDOFIdx+1 
                  residualVector%elementResidual%vector(rowElementDOFIdx)= &
                    & residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                    & rowPhi*tempTerm1                  
                ENDDO !rowElementPararmeterIdx
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION) !element based
                elementDofIdx=elementDofIdx+1
                residualVector%elementResidual%vector(rowElementDofIdx)= &
                  & residualVector%elementResidual%vector(rowElementDofIdx)+tempTerm1
              CASE DEFAULT
                localError="The pressure interpolation type of "// &
                  & TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
                  & " for component "//TRIM(NumberToVString(pressureComponent,"*",err,error))// &
                  & " of the dependent variable is invalid or not implemented."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          ENDDO !gaussPointIdx

          !Call surface pressure term: should only be executed if THIS element has surface pressure on it (direct or incremented)
          IF(haveSurfacePressure) THEN
            CALL FiniteElasticity_SurfacePressureResidualEvaluate(equationsSet,elementNumber,dependentVariableType, &
              & rhsVariableType,err,error,*999)
          ENDIF

          ! ---------------------------------------------------------------
        CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
          & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)

          CALL IdentityMatrix(ITens,err,error,*999)
          !Get time step
          CALL EquationsSet_TimeIncrementGet(equationsSet,dt,err,error,*999)

          !Loop over gauss points and add residuals
          DO gaussPointIdx=1,numberOfGauss

            IF(diagnostics1) THEN
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",elementNumber,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Gauss point index  = ",gaussPointIdx,err,error,*999)
            ENDIF

            CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)

            !Interpolate dependent, previous dependent, geometric, fibre and materials fields
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx, &
              & prevDependentInterpPoint,err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,prevDependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(No_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
              & err,error,*999)
            IF(ASSOCIATED(fibreField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
                & err,error,*999)
            ENDIF

            !Calculate material fibre coordinate system
            CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
              & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
              & fibreVectors(1:numberOfDimensions,1:numberOfXi),err,error,*999)
            !Calculate F=dZ/dNu, the deformation gradient tensor at the gauss point
            CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
              & dXidNu(1:numberOfXi,1:numberOfDimensions),dZdX,JZ,dZdNu,JZNu,err,error,*999)
            !Calculate prevF=prevdZ/dNu, the relative deformation gradient tensor at the gauss point
            CALL FiniteElasticity_DeformationGradientTensorCalculate(prevDependentInterpPointMetrics,geometricInterpPointMetrics, &
              & dXidNu(1:numberOfXi,1:numberOfDimensions),prevdZdX,prevJZ,prevdZdNu,prevJZNu,err,error,*999)

            !Get BePrime from the start of the time step
            DO rowIdx=1,numberOfDimensions
              DO columnIdx=rowIdx,numberOfDimensions
                componentIdx=1+TENSOR_TO_VOIGT(rowIdx,columnIdx,numberOfDimensions)
                CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                  & gaussPointIdx,elementNumber,componentIdx,BePrime1(rowIdx,columnIdx),err,error,*999)
              ENDDO !columnIdx
              DO columnIdx=1,rowIdx-1
                BePrime1(rowIdx,columnIdx)=BePrime1(columnIdx,rowIdx)
              ENDDO !columnIdx
            ENDDO !rowIdx

            !Calculate Fr = F.prevF^-1
            CALL Invert(prevdZdNu,invPrevdZdNu,prevJF,err,error,*999)
            CALL MatrixProduct(dZdNu,invPrevdZdNu,Fr,err,error,*999)
            !Calculate Jr
            CALL Determinant(Fr,Jr,err,error,*999)

            IF(diagnostics1) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Deformation gradient tensors:",err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Deformation gradient at time t:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,prevdZdNu,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("            F','(",I1,",:)',' :",3(X,E13.6))', &
                & '(16X,3(X,E13.6))',err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Deformation gradient at time t + dt:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,dZdNu,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("            F','(",I1,",:)',' :",3(X,E13.6))', &
                & '(16X,3(X,E13.6))',err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Relative deformation gradient:",err,error,*999)
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,Fr,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("           Fr','(",I1,",:)',' :",3(X,E13.6))', &
                & '(16X,3(X,E13.6))',err,error,*999)
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Jacobians:",err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  J at time t       = ",prevJF,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  J at time t + dt  = ",J,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Jr                = ",Jr,err,error,*999)
            ENDIF

            CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)
            CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,Jzxi,err,error,*999)
            CALL FieldInterpolatedPointMetrics_JacobianGet(prevDependentInterpPointMetrics,prevJZXi,err,error,*999)

            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE)

              !Equation numbers are from M. Hollenstein, M. Jabareen and M.B. Rubin "Modeling a smoth elastic-inelastic
              !transition with a strongly objective numerical integrator needing no iteration". 2013. Comput Mech. 52:649-667.

              mu=materialsInterpPoint%values(1,1)
              a0=materialsInterpPoint%values(2,1)
              a1=materialsInterpPoint%values(3,1)
              b0=materialsInterpPoint%values(4,1)
              b1=materialsInterpPoint%values(5,1)
              m=materialsInterpPoint%values(6,1)
              kappas=materialsInterpPoint%values(7,1)

              !Get the hardening variable, kappa
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,1,kappa1,err,error,*999)

              !props(1)=K
              !props(2)=mu
              !props(3)=a0
              !props(4)=a1
              !props(5)=b0
              !props(6)=b1
              !props(7)=m
              !props(8)=kappas

              !statev(1)=prevJF
              !statev(2)=BePrime1(1,1)
              !statev(3)=BePrime1(2,2)
              !statev(4)=BePrime1(3,3)
              !statev(5)=BePrime1(1,2)
              !statev(6)=BePrime1(2,3)
              !statev(7)=BePrime1(1,3)
              !statev(8)=kappa1
              !statev(9)=0.0_DP
              !statev(10)=0.0_DP
              !statev(11)=0.0_DP
              !statev(12)=statev(2)+statev(3)+statev(4)
              !statev(13)=0.0_DP

              !CALL umat(6,13,8,2,1,prevdZdNu,dZdNu,dt,cauchyTensor,statev,ddsdde,props)

              !Eqn (4.6)
              J=Jr*prevJF
              !Eqn (4.4)
              CALL Unimodular(Fr,FrPrime,err,error,*999)
              !Calculate Elastic Trial. Eqn (4.7)
              CALL MatrixProduct(FrPrime,BePrime1,tempTensor,err,error,*999)
              CALL MatrixProductTranspose(tempTensor,FrPrime,BePrimeStar,err,error,*999)
              CALL DecomposeSphericalDeviatoric(BePrimeStar,hydBePrimeStar,BePrimePrimeStar,err,error,*999)
              !Calculate gePrimePrimeStar. Eqn (4.10)
              gePrimePrimeStar=BePrimePrimeStar/2.0_DP
              !Calculate Equivalent Strain, gammaEStar. Use Eqn (4.10) in Eqn (4.17)
              CALL DoubleDotProduct(BePrimePrimeStar,BePrimePrimeStar,gammaEStar,err,error,*999)
              gammaEStar=SQRT(3.0_DP/8.0_DP*gammaEStar)
              !Calculate Total Effective Distortional Strain, Dbar. Eqn (4.13)
              CALL MatrixProductTranspose(Fr,Fr,Br,err,error,*999)
              Dbar=(Br-ITens)/(2.0_DP*dt)
              !Calculate delta epsilon. Eqn (4.14). Note typo in paper. It should be devDbar dot devDbar
              CALL DecomposeSphericalDeviatoric(Dbar,hydDbar,devDbar,err,error,*999)
              CALL DoubleDotProduct(devDbar,devDbar,deltaEps,err,error,*999)
              deltaEps=dt*SQRT(2.0_DP/3.0_DP*deltaEps)
              !Calculate gamma. Eqn (4.18)
              dtGamma0=dt*a0+b0*deltaEps
              dtGamma1=dt*a1+b1*deltaEps
              !Eqn (4.21)
              c0=dtGamma1*(gammaEStar-(1.0_DP+dtGamma0)*kappa1)
              IF(c0<=ZERO_TOLERANCE) THEN
                !Eqn (4.19)
                gamma=0.0_DP
              ELSE
                !Eqn (4.21)
                c1=gammaEStar+dtGamma1*(kappa1-m*(gammaEStar-(1.0_DP+dtGamma0)*kappas))
                IF(ABS(m)<ZERO_TOLERANCE) THEN
                  gamma=c0/c1
                ELSE
                  !Eqn (4.21)
                  c2=m*(gammaEStar+dtGamma1*kappas)
                  !Eqn (4.22)
                  gamma=(-c1+SQRT(c1*c1+4.0_DP*c0*c2))/(2.0_DP*c2)
                ENDIF
              ENDIF
              !Calculate dtGamma. Eqn (4.15)
              dtGamma=dtGamma0+gamma
              !Calculate Hardening. Eqn (4.16)
              kappa=(kappa1+m*kappas*gamma)/(1.0_DP+m*gamma)
              !Calculate devBePrimePrime. Eqn (4.11)
              devBePrimePrime=2.0_DP/(1.0_DP+dtGamma)*gePrimePrimeStar
              !Calculate gePrimePrime (deviatoric part of gePrime). Eqn (3.1) and (4.11)
              gePrimePrime=devBePrimePrime/2.0_DP
              !Calculate alpha
              CALL Determinant(devBePrimePrime,detdevBePrimePrime,err,error,*999)
              CALL DoubleDotProduct(devBePrimePrime,devBePrimePrime,factor1,err,error,*999)
              factor1=2.0_DP/3.0_DP*factor1
              IF(ABS(factor1)<ZERO_TOLERANCE) THEN
                alpha1=3.0_DP
              ELSE
                factor2=(4.0_DP*(1.0_DP-detdevBePrimePrime))/(factor1**1.5_DP)
                IF(factor2>=1.0_DP) THEN
                  alpha1=3.0_DP*SQRT(factor1)*COSH(ACOSH(factor2)/3.0_DP)
                ELSE
                  alpha1=3.0_DP*SQRT(factor1)*COS(ACOS(factor2)/3.0_DP)
                ENDIF
              ENDIF
              !Calculate BePrime. Eqn (4.12)
              BePrime=alpha1/3.0_DP*ITens+devBePrimePrime
              !Calculate deviatoric part of Cauchy stress. Eqn (6.2)
              devT=2.0_DP*mu*gePrimePrime/J
              SELECT CASE(equationsSetSubtype)
              CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE)
                P=dependentInterpPoint%values(pressureComponent,1)
              CASE(EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE)
                P=-K*(J-1.0_DP)
              END SELECT
              !Calculate Cauchy stress. Eqn (2.9)
              cauchyTensor=devT-P*ITens

              IF(diagnostics1) THEN
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Strain tensors:",err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Be prime at t:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                  & 3,3,BePrime1,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    Be prime','(",I1,",:)',' :",3(X,E13.6))', &
                  & '(16X,3(X,E13.6))',err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Be prime at t+dt:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                  & 3,3,BePrime,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    Be prime','(",I1,",:)',' :",3(X,E13.6))', &
                  & '(16X,3(X,E13.6))',err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  gamma = ",gamma,err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Strain hardening:",err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  kappa at time t      = ",kappa1,err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  kappa at time t + dt = ",kappa,err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Stress tensors:",err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Hydrostatic pressure = ",P,err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Deviatoric Cauchy stress tensor:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                  & 3,3,devT,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    dev sigma','(",I1,",:)',' :",3(X,E13.6))', &
                  & '(16X,3(X,E13.6))',err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Cauchy stress tensor:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                  & 3,3,cauchyTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("        sigma','(",I1,",:)',' :",3(X,E13.6))', &
                  & '(16X,3(X,E13.6))',err,error,*999)
              ENDIF

              !Store the current value of the hardening variable, kappa, in the next values parameter set
              CALL Field_ParameterSetUpdateLocalGaussPoint(dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_NEXT_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,1,kappa,err,error,*999)            

            CASE(EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE,EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE)

              mu0=materialsInterpPoint%values(1,1)
              q=materialsInterpPoint%values(2,1)
              kt=materialsInterpPoint%values(3,1)
              kc=materialsInterpPoint%values(4,1)
              k1=materialsInterpPoint%values(5,1)
              k2=materialsInterpPoint%values(6,1)
              k3=materialsInterpPoint%values(7,1)
              k12=materialsInterpPoint%values(8,1)
              ka=materialsInterpPoint%values(9,1)
              Gamma=materialsInterpPoint%values(10,1)
              GammaM=materialsInterpPoint%values(11,1)
              Jh=materialsInterpPoint%values(12,1)
              H11=materialsInterpPoint%values(13,1)
              H22=materialsInterpPoint%values(14,1)
              H33=materialsInterpPoint%values(15,1)
              H12=materialsInterpPoint%values(16,1)
              H13=materialsInterpPoint%values(17,1)
              H23=materialsInterpPoint%values(18,1)

              !Get the current value of Je at the start of the time step
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,1,Je1,err,error,*999)

              !Get the structural tensor, S1, from the start of the time step
              DO rowIdx=1,numberOfDimensions
                DO columnIdx=1,numberOfDimensions
                  componentIdx=rowIdx+(columnIdx-1)*numberOfDimensions
                  CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                    & gaussPointIdx,elementNumber,componentIdx,S1(rowIdx,columnIdx),err,error,*999)
                ENDDO !columnIdx
              ENDDO !rowIdx

              !CALL clooping(1.0E-10_DP,1.0E-10_DP,100.0_DP,mu0,kc,kt,1.0_DP,k2,k3,k12,ka,q,H11,H22,H12,Jh,Gamma,Gammam,dt,Fr, &
              !  & Jr,Je1,S1(:,1),S1(:,2),S1(:,3),devH,HH,malpha1,B,Bepr,lame1,lame2,lame3,lamea,Ee11,Ee22,Ee33,Ee12,Eea,QQ,T0,T1, &
              !  & T2,T3,T4,T5,TT)

              !Calculate the elastic dilatation. Eqn (6.5) and (6.8)
              Je2 = Jr*Je1
              Je = EXP(LOG(Je2)+dt*GammaM*LOG(Jh))/(1.0_DP+dt*GammaM)
              !Update state variables
              !Update the fibre vectors s1 and s3 to give S at t2 i.e., S2 Eqn (6.4)
              CALL MatrixVectorProduct(Fr,S1(:,1),S2(:,1),err,error,*999)
              CALL Normalise(S2(:,1),S2(:,1),err,error,*999)
              CALL InvertTranspose(Fr,invFrT,detInvFrT,err,error,*999)
              CALL MatrixVectorProduct(invFrT,S1(:,3),S2(:,3),err,error,*999)
              CALL Normalise(S2(:,3),S2(:,3),err,error,*999)
              !Compute s2 = s3 x s1. Eqn (3.1)
              CALL CrossProduct(S2(:,3),S2(:,1),S2(:,2),err,error,*999)
              !Compute the structural tensor(s). Eqn (3.5)
!!TODO: Change this to use a matrix matrix tensor product?/ Indices will change???
              DO rowIdx=1,numberOfDimensions
                DO columnIdx=1,numberOfDimensions
                  CALL TensorProduct(S2(:,rowIdx),S2(:,columnIdx),S(rowIdx,columnIdx,:,:),err,error,*999)
                ENDDO !columnIdx
              ENDDO !rowIdx
              !Compute the homostatis growth tensor. Eqn (7.4) and (???)
              HPrimePrime=H11*S(1,1,:,:)+H22*S(2,2,:,:)-(H11+H22)*S(3,3,:,:)+H12*(S(1,2,:,:)+S(2,1,:,:))
              H=ITens+HPrimePrime
              !Compute alphas via non-linear Newton solve              
              !Calculate BePrimeStar
              CALL MatrixProduct(FrPrime,BePrime1,tempTensor,err,error,*999)
              CALL MatrixProductTranspose(tempTensor,FrPrime,BePrimeStar,err,error,*999)
              !Calculate BePrimePrimeStar (deviatoric part of BePrimeStar)
              CALL DecomposeSphericalDeviatoric(BePrimeStar,hydBePrimeStar,BePrimePrimeStar,err,error,*999)
              !Initialise alpha
              CALL Unimodular(BePrime1,uniBePrime1,err,error,*999)
              CALL Trace(uniBePrime1,alpha(1),err,error,*999)
              alpha(2)=1.0_DP              
              numIterations=0
              deltaAlphaNorm=1.0_DP
              deltaAlphaNormTolerance=10.0E-10
              hStep=10.0E-10
              maxNumIterations=100
              DO WHILE((deltaAlphaNorm>=deltaAlphaNormTolerance).AND.(numIterations<maxNumIterations))
                !Increment iteration count
                numIterations=numIterations+1
                !Calculate deviatoric part of BePrime2, BePrimePrime
                BePrimePrime=(BePrimePrimeStar+alpha(2)*dt*Gamma*HPrimePrime)/(1.0_DP+dt*Gamma)
                !Calculate elastic distortion, Beprime
                BePrime=alpha(1)*ITens/3.0_DP+BePrimePrime
                !Calculate resid(1)
                !Calculate inverse of BePrime
                CALL Invert(BePrime,invBePrime,detBePrime,err,error,*999)
                CALL DoubleDotProduct(invBePrime,H,BeDDotH,err,error,*999)
                resid(1)=alpha(2)-3.0_DP/BeDDotH
                !Calculate resid(2)
                CALL DoubleDotProduct(BePrimePrime,BePrimePrime,BeDDotBe,err,error,*999)
                CALL Determinant(BePrimePrime,detBePrimePrime,err,error,*999)
                resid(2)=(alpha(1)/3.0_DP)**3.0_DP-(BeDDotBe*alpha(1)/6.0_DP)-(1.0_DP-detBePrimePrime)
                perturbedAlpha=alpha
                DO columnIdx=1,2
                  hStepAlpha=MAX(hStep,ABS(hstep*perturbedAlpha(columnIdx)))
                  perturbedAlpha(columnIdx)=perturbedAlpha(columnIdx)+hstepAlpha
                  !Calculate deviatoric part of BePrime2, BePrimePrime
                  BePrimePrime=(BePrimePrimeStar+perturbedAlpha(2)*dt*Gamma*HPrimePrime)/(1.0_DP+dt*Gamma)
                  !Calculate elastic distortion, Beprime
                  BePrime=perturbedAlpha(1)*ITens/3.0_DP+BePrimePrime
                  !Calculate resid(1)
                  !Calculate inverse of BePrime
                  CALL Invert(BePrime,invBePrime,detBePrime,err,error,*999)
                  CALL DoubleDotProduct(invBePrime,H,BeDDotH,err,error,*999)
                  perturbedResid(1)=perturbedAlpha(2)-3.0_DP/BeDDotH
                  !Calculate resid(2)
                  CALL DoubleDotProduct(BePrimePrime,BePrimePrime,BeDDotBe,err,error,*999)
                  CALL Determinant(BePrimePrime,detBePrimePrime,err,error,*999)
                  perturbedResid(2)=(perturbedAlpha(1)/3.0_DP)**3.0_DP-(BeDDotBe*perturbedAlpha(1)/6.0_DP)-(1.0_DP-detBePrimePrime)
                  DO rowIdx=1,2
                    Jacobian(rowIdx,columnIdx)=(perturbedResid(rowIdx)-resid(rowIdx))/hStepAlpha
                  ENDDO !rowIdx
                  perturbedAlpha(columnIdx)=alpha(columnIdx)
                ENDDO !columnIdx
                CALL Invert(Jacobian,invJacobian,detJacobian,err,error,*999)
                CALL MatrixVectorProduct(invJacobian,resid,deltaAlpha,err,error,*999)
                CALL L2Norm(deltaAlpha,deltaAlphaNorm,err,error,*999)
                alpha=alpha-deltaAlpha
              ENDDO
              !Calculate deviatoric part of BePrime2, BePrimePrime
              BePrimePrime=(BePrimePrimeStar+alpha(2)*dt*Gamma*HPrimePrime)/(1.0_DP+dt*Gamma)
              !Calculate elastic distortion, Beprime
              BePrime=alpha(1)*ITens/3.0_DP+BePrimePrime
              !Calculate strain information
              !Calculate Be
              Be=(Je**(2.0_DP/3.0_DP))*BePrime
              !Invert Be
              CALL Invert(Be,invBe,detBe,err,error,*999)
              !Calculate lame and Ee
              Ee=0.0_DP
              DO rowIdx=1,numberOfDimensions
                CALL DoubleDotProduct(invBe,S(rowIdx,rowIdx,:,:),lame(rowIdx),err,error,*999)
                lame(rowIdx)=1.0_DP/SQRT(lame(rowIdx))
                Ee(rowIdx,rowIdx)=(lame(rowIdx)*lame(rowIdx)-1.0_DP)/2.0_DP
              ENDDO !rowIdx
              CALL DoubleDotProduct(invBe,S(1,2,:,:),Ee(1,2),err,error,*999)
              Ee(1,2)=-1.0_DP*lame(1)*lame(2)**Ee(1,2)/2.0_DP
              CALL DoubleDotProduct(Be,S(3,3,:,:),lame(4),err,error,*999)
              lame(4)=Je/SQRT(lame(4))
              Ee(4,4)=lame(4)-1.0_DP
              !Calculate stress information
              ktJe=MacaulayBracket(Je-1.0_DP)
              kcJe=MacaulayBracket(1.0_DP-Je)
              macEe11=MacaulayBracket(Ee(1,1))
              macEe22=MacaulayBracket(Ee(2,2))
              macEe33=MacaulayBracket(Ee(3,3))
              CALL MatrixProduct(invBe,S(3,3,:,:),invBeS33,err,error,*999)
              CALL MatrixProduct(S(3,3,:,:),invBe,S33invBe,err,error,*999)

              QQ=0.50_DP*kt*(ktJe**2.0_DP)+0.50_DP*kc*(kcJe**2.0_DP) &
                &  +0.50_DP*(alpha(1)-3.0_DP)+0.50_DP*k1*(macEe11**2.0_DP) &
                &  +0.50_DP*k2*(macEe22**2.0_DP)+0.50_DP*k3*(macEe33**2.0_DP) &
                &  +2.0_DP*k12*(Ee(1,2)**2.0_DP)+0.50_DP*ka*(Ee(4,4)**2.0d0)

              mu=mu0*EXP(q*QQ)
              T0=mu*(kt*ktJe-kc*kcJe)*iTens+(mu/Je)*BePrimePrime
              T1=((k1*mu*(lame(1)**2.0_DP)*macEe11)/Je)*S(1,1,:,:)
              T2=((k2*mu*(lame(2)**2.0_DP)*macEe22)/Je)*(S(2,2,:,:)-(2.0_DP*lame(2)/lame(1))*Ee(1,2)*(S(1,2,:,:)+S(2,1,:,:)))
              T3=((k3*mu*(lame(3)**2.0_DP)*macEe33)/Je)*((lame(3)**2.0_DP)*(invBeS33+S33invBe)-S(3,3,:,:))
              T4=2.0_DP*mu*k12*Ee(1,2)*(lame(2)/lame(1)/Je)*(1.0d0-4.0d0*(Ee(1,2)**2.0_DP))*(S(1,2,:,:)+S(2,1,:,:))
              T5=(mu*ka*Ee(4,4)*lame(4)/Je)*(S(1,1,:,:)+S(2,2,:,:))

              cauchyTensor=T0+T1+T2+T3+T4+T5

              IF(diagnostics1) THEN
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Je at time t      = ",Je1,err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Je at time t + dt = ",Je2,err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Je                = ",Je,err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Jh                = ",Jh,err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Structural fibre tensors:",err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  S at t:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                  & 3,3,S1,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("           S','(",I1,",:)',' :",3(X,E13.6))', &
                  & '(16X,3(X,E13.6))',err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  S at t + dt:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                  & 3,3,S2,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("           S','(",I1,",:)',' :",3(X,E13.6))', &
                  & '(16X,3(X,E13.6))',err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Growth tensors:",err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  H prime prime:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                  & 3,3,HPrimePrime,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("           H','(",I1,",:)',' :",3(X,E13.6))', &
                  & '(16X,3(X,E13.6))',err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  H:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                  & 3,3,H,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("           H','(",I1,",:)',' :",3(X,E13.6))', &
                  & '(16X,3(X,E13.6))',err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Strain tensors:",err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Be prime at t:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                  & 3,3,BePrime1,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    Be prime','(",I1,",:)',' :",3(X,E13.6))', &
                  & '(16X,3(X,E13.6))',err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Be prime at t + dt:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                  & 3,3,BePrime,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    Be prime','(",I1,",:)',' :",3(X,E13.6))', &
                  & '(16X,3(X,E13.6))',err,error,*999)
                CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,alpha,'("",2(X,E13.6))','(2(X,E13.6))',err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Ee at t + dt:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,4,1,1,4, &
                  & 4,4,Ee,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("          Ee','(",I1,",:)',' :",4(X,E13.6))', &
                  & '(16X,4(X,E13.6))',err,error,*999)
                CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,4,4,4,lame,'("",4(X,E13.6))','4(X,E13.6))',err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Stress tensors:",err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  QQ = ",QQ,err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  T1-5:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3,3,3,T1,WRITE_STRING_MATRIX_NAME_AND_INDICES, &
                  & '("            T1','(",I1,",:)',' :",3(X,E13.6))','(16X,3(X,E13.6))',err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3,3,3,T2,WRITE_STRING_MATRIX_NAME_AND_INDICES, &
                  & '("            T2','(",I1,",:)',' :",3(X,E13.6))','(16X,3(X,E13.6))',err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3,3,3,T3,WRITE_STRING_MATRIX_NAME_AND_INDICES, &
                  & '("            T3','(",I1,",:)',' :",3(X,E13.6))','(16X,3(X,E13.6))',err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3,3,3,T4,WRITE_STRING_MATRIX_NAME_AND_INDICES, &
                  & '("            T4','(",I1,",:)',' :",3(X,E13.6))','(16X,3(X,E13.6))',err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3,3,3,T5,WRITE_STRING_MATRIX_NAME_AND_INDICES, &
                  & '("            T5','(",I1,",:)',' :",3(X,E13.6))','(16X,3(X,E13.6))',err,error,*999)
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Cauchy stress tensor:",err,error,*999)
                CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                  & 3,3,cauchyTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("        sigma','(",I1,",:)',' :",3(X,E13.6))', &
                  & '(16X,3(X,E13.6))',err,error,*999)
              ENDIF

              !Store the current value of Je in the next values parameter set
              CALL Field_ParameterSetUpdateLocalGaussPoint(dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_NEXT_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,1,Je,err,error,*999)              

              !Store the current values of the structural tensor, S2, in the next values parameter set
              DO rowIdx=1,numberOfDimensions
                DO columnIdx=1,numberOfDimensions
                  componentIdx=rowIdx+(columnIdx-1)*numberOfDimensions
                  CALL Field_ParameterSetUpdateLocalGaussPoint(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_NEXT_VALUES_SET_TYPE, &
                    & gaussPointIdx,elementNumber,componentIdx,S2(rowIdx,columnIdx),err,error,*999)
                ENDDO !columnIdx
              ENDDO !rowIdx

            CASE DEFAULT
              localError="The equations set subtype of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)              
            END SELECT

            !Store BePrime in the next values parameter set
            DO rowIdx=1,numberOfDimensions
              DO columnIdx=rowIdx,numberOfDimensions
                componentIdx=1+TENSOR_TO_VOIGT(rowIdx,columnIdx,numberOfDimensions)
                CALL Field_ParameterSetUpdateLocalGaussPoint(dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_NEXT_VALUES_SET_TYPE, &
                  & gaussPointIdx,elementNumber,componentIdx,BePrime(rowIdx,columnIdx),err,error,*999)            
              ENDDO !columnIdx
            ENDDO !rowIdx

            !Loop over dependent columns directions.
            DO columnComponentIdx=1,numberOfDimensions
              NULLIFY(columnDomain)
              CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnDomain,err,error,*999)
              NULLIFY(columnDomainTopology)
              CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
              NULLIFY(columnDomainElements)
              CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
              NULLIFY(columnBasis)
              CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,columnBasis,err,error,*999)
              NULLIFY(columnQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(columnBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,columnQuadratureScheme, &
                & err,error,*999)
              CALL Basis_NumberOfElementParametersGet(columnBasis,numberOfColElementParameters,err,error,*999)
              !Loop over dependent columns element parameters.
              DO columnElementParameterIdx=1,numberOfColElementParameters
                !Loop over dependent columns directions.
                DO rowComponentIdx=1,numberOfDimensions
                  sum1=0.0_DP
                  DO rowXiIdx=1,numberOfXi
                    CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureScheme,columnElementParameterIdx, &
                      & PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(rowXiIdx),gaussPointIdx,dColumnPhidXi,err,error,*999)                
                    sum1=sum1+dependentInterpPointMetrics%dXidX(rowXiIdx,rowComponentIdx)*dColumnPhidXi
                  ENDDO !rowXiIdx
                  dPhidZ(rowComponentIdx,columnElementParameterIdx,columnComponentIdx)=sum1
                ENDDO !rowComponentIdx
              ENDDO !columnElementParameterIdx
            ENDDO !columnComponentIdx

            jacobianGaussWeight=JZxi*gaussWeight

            !Now add up the residual terms
            rowElementDofIdx=0
            DO rowComponentIdx=1,numberOfDimensions
              NULLIFY(rowDomain)
              CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
              NULLIFY(rowDomainTopology)
              CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
              NULLIFY(rowDomainElements)
              CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
              NULLIFY(rowBasis)
              CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
              NULLIFY(rowQuadratureScheme)
              CALL Basis_QuadratureSchemeGet(rowBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowQuadratureScheme,err,error,*999)
              CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
              DO rowElementParameterIdx=1,numberOfRowElementParameters
                rowElementDofIdx=rowElementDofIdx+1
                residualVector%elementResidual%vector(rowElementDofIdx)=residualVector%elementResidual%vector(rowElementDofIdx)+ &
                  & jacobianGaussWeight*DOT_PRODUCT(dPhiDz(1:numberOfDimensions,rowElementParameterIdx,rowComponentIdx), &
                  & cauchyTensor(1:numberOfDimensions,rowComponentIdx))
              ENDDO !rowElementParameterIdx
            ENDDO !rowComponentIdx

            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE)
              P=dependentInterpPoint%values(pressureComponent,1)
              !Hydrostatic pressure component
              tempTerm1=gaussWeight*(J-1.0_DP)
              SELECT CASE(pressureInterpolationType)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                rowElementDofIdx=rowElementDofIdx+1
                residualVector%elementResidual%vector(rowElementDofIdx)= &
                  & residualVector%elementResidual%vector(rowElementDofIdx)+tempTerm1
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                DO rowElementParameterIdx=1,numberOfRowElementParameters
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(pressureQuadratureScheme,rowElementParameterIdx,NO_PART_DERIV, &
                    & gaussPointIdx,rowPhi,err,error,*999)
                  rowElementDOFIdx=rowElementDOFIdx+1 
                  residualVector%elementResidual%vector(rowElementParameterIdx)= &
                    & residualVector%elementResidual%vector(rowElementParameterIdx)+ &
                    & rowPhi*tempTerm1
                ENDDO
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The dependent field interpolation type of "// &
                  & TRIM(NumberToVString(pressureInterpolationType,"*",err,error))//" for field component "// &
                  & TRIM(NumberToVString(pressureComponent,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            CASE DEFAULT
              !Do nothing
            END SELECT

          ENDDO !gaussPointIdx

          !Call surface pressure term here: should only be executed if THIS element has surface pressure on it (direct or
          !incremented)
          IF(haveSurfacePressure) THEN    ! 
            CALL FiniteElasticity_SurfacePressureResidualEvaluate(equationsSet,elementNumber,dependentVariableType, &
              & rhsVariableType,err,error,*999)
          ENDIF

        CASE(EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE)
          !keep the multi-compartment case separate for the time being until the formulation has been finalised, then perhaps
          !integrate within the single compartment case
          !Loop over gauss points and add residuals
          NULLIFY(equationsSetField)
          CALL EquationsSet_EquationsSetFieldGet(equationsSet,equationsSetField,err,error,*999)
          CALL Field_ParameterSetDataGet(equationsSetField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,equationsSetFieldData, &
            & err,error,*999)

          Ncompartments = equationsSetFieldData(2)

          DO gaussPointIdx=1,numberOfGauss

            CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)

            !Interpolate dependent, geometric, fibre and materials fields
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
                & err,error,*999)
            ENDIF
            CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
              & err,error,*999)

            IF(diagnostics1) THEN
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",elementNumber,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Gauss point index = ",gaussPointIdx,err,error,*999)
            ENDIF
            IF(diagnostics1) THEN
              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,piolaTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("     Piola Tensor','(",I1,",:)',' :",3(X,E13.6))', &
                & '(17X,3(X,E13.6))',err,error,*999)

              CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
                & 3,3,cauchyTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    Cauchy Tensor','(",I1,",:)',' :",3(X,E13.6))', &
                & '(17X,3(X,E13.6))',err,error,*999)
            ENDIF

            !Parameters settings for coupled elasticity Darcy INRIA model:
            CALL FiniteElasticity_GetDarcyParameters(darcyRho0F,Mfact,bfact,p0fact,err,error,*999)

            darcyMassIncrease = 0.0_DP
            DO imatrix=1,Ncompartments
              darcyVariableType=FIELD_V_VARIABLE_TYPE+FIELD_NUMBER_OF_VARIABLE_SUBTYPES*(imatrix-1)
              NULLIFY(darcyDependentInterpParameters)
              CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,darcyVariableType, &
                & darcyDependentInterpParameters,err,error,*999)
              NULLIFY(darcyDependentInterpPoint)
              CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,darcyVariableType,darcyDependentInterpPoint, &
                & err,error,*999)
              CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,darcyDependentInterpParameters, &
                & err,error,*999)
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,darcyDependentInterpPoint, &
                & err,error,*999)

              darcyMassIncrease = darcyMassIncrease + darcyDependentInterpPoint%values(4,NO_PART_DERIV)
            ENDDO !iMatrix

            darcyVolIncrease = darcyMassIncrease / darcyRho0F

            !Calculate material fibre coordinate system
            CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
              & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
              & fibreVectors(1:numberOfDimensions,1:numberOfXi),err,error,*999)
            !Calculate F=dZ/dNU, the deformation gradient tensor at the gauss point
            CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
              & dXidNu(1:numberOfXi,1:numberOfDimensions),dZdX,JZ,dZdNu,JZNu,err,error,*999)

            CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)

            !Calculate Sigma=1/Jznu.FTF', the Cauchy stress tensor at the gauss point
            CALL FiniteElasticity_GaussCauchyTensor(equationsSet,numberOfDimensions,dependentInterpPoint, &
              & materialsInterpPoint,geometricInterpPoint,darcyDependentInterpPoint, &
              & independentInterpPoint,elementNumber,gaussPointIdx,dZdNu,JZNu,cauchyTensor,err,error,*999)

            !Calculate dPhi/dZ at the gauss point, Phi is the basis function
            CALL FiniteElasticity_GaussdFdZ(dependentInterpPoint,elementNumber,gaussPointIdx,numberOfDimensions, &
              & numberOfXi,dFdZ,err,error,*999)

            !For membrane theory in 3D space, the final equation is multiplied by thickness. Default to unit thickness if
            !equation set subtype is not membrane
            thickness = 1.0_DP
            IF(equationsSetSubtype == EQUATIONS_SET_MEMBRANE_SUBTYPE) THEN
              IF(numberOfDimensions == 3) thickness = materialsInterpPoint%values(numberOfMaterialsComponents,1)
            ENDIF

            !Now add up the residual terms
            rowElementDOFIdx=0
            DO rowComponentIdx=1,numberOfDimensions
              CALL FieldVariable_ComponentInterpolationGet(rowsVariable,rowComponentIdx,rowInterpolationType,err,error,*999)
              SELECT CASE(rowInterpolationType)
              CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
                NULLIFY(rowDomain)
                CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
                NULLIFY(rowDomainTopology)
                CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
                NULLIFY(rowDomainElements)
                CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
                NULLIFY(rowBasis)
                CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
                CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
                DO rowElementParameterIdx=1,numberOfRowElementParameters
                  rowElementDOFIdx=rowElementDOFIdx+1
                  DO columnComponentIdx=1,numberOfDimensions
                    residualVector%elementResidual%vector(rowElementDOFIdx)= &
                      & residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                      & gaussWeight*Jxxi*Jznu*thickness*cauchyTensor(rowComponentIdx,columnComponentIdx)* &
                      & dFdZ(rowElementParameterIdx,columnComponentIdx,rowComponentIdx)
                  ENDDO !columnComponentIdx (inner component index)
                ENDDO !rowElementParameterIdx (residual vector loop)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Will probably never be used
                CALL FlagError("Finite elasticity with element based interpolation is not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The row interpolation type of "//TRIM(NumberToVString(rowInterpolationType,"*",err,error))// &
                  & " for row component "//TRIM(NumberToVString(rowComponentIdx,"*",err,error))// &
                  & " is invalid or not implemented."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDDO !componentIdx

            !Hydrostatic pressure component (skip for membrane problems)
            IF (equationsSetSubtype /= EQUATIONS_SET_MEMBRANE_SUBTYPE) THEN
              tempTerm1=gaussWeight*Jxxi*(Jznu-1.0_DP-darcyVolIncrease)
              SELECT CASE(pressureInterpolationType)
              CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
                DO rowElementParameterIdx=1,numberOfPressureElementParameters
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(pressureQuadratureScheme,rowElementParameterIdx,NO_PART_DERIV, &
                    & gaussPointIdx,rowPhi,err,error,*999)
                  rowElementDOFIdx=rowElementDOFIdx+1 
                  residualVector%elementResidual%vector(rowElementDOFIdx)= &
                    & residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                    & rowPhi*tempTerm1
                ENDDO !rowElementParameterIdx
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION) !element based
                rowElementDOFIdx=rowElementDOFIdx+1
                residualVector%elementResidual%vector(elementDOFIdx)= &
                  & residualVector%elementResidual%vector(elementDOFIdx)+tempTerm1
              CASE DEFAULT
                localError="The pressure interpolation type of "// &
                  & TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
                  & " for component "//TRIM(NumberToVString(pressureComponent,"*",err,error))// &
                  & " of the dependent variable is invalid or not implemented."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          ENDDO !gaussPointIdx

          !Call surface pressure term: should only be executed if THIS element has surface pressure on it (direct or incremented)
          IF(haveSurfacePressure) THEN    ! 
            CALL FiniteElasticity_SurfacePressureResidualEvaluate(equationsSet,elementNumber,dependentVariableType, &
              & rhsVariableType,err,error,*999)
          ENDIF

        CASE (EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE, &
          & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE, &
          & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE, &
          & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE, &
          & EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE, &
          & EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE)
          !compressible problem (no pressure component)

          !Loop over gauss points and add up residuals
          DO gaussPointIdx=1,numberOfGauss

            CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)

            !Interpolate fields at the gauss points
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
                & err,error,*999)
            ENDIF
            CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
              & err,error,*999)
            IF(darcyDependent) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx, &
                & darcyDependentInterpPoint,err,error,*999) ! 'FIRST_PART_DERIV' required ???
            ENDIF

            !Calculate material fibre coordinate system
            CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
              & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
              & fibreVectors(1:numberOfDimensions,1:numberOfXi),err,error,*999)
            !Calculate F=dZ/dNU at the gauss point
            CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
              & dXidNu(1:numberOfXi,1:numberOfDimensions),dZdX,JZ,dZdNu,JZNu,err,error,*999)

            CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,Jxxi,err,error,*999)

            !Calculate Cauchy stress tensor at the gauss point
            CALL FiniteElasticity_GaussCauchyTensor(equationsSet,numberOfDimensions,dependentInterpPoint, &
              & materialsInterpPoint,geometricInterpPoint,darcyDependentInterpPoint,independentInterpPoint, &
              & elementNumber,gaussPointIdx,dZdNu,JZNu,cauchyTensor,err,error,*999)

            !Calculate dF/DZ at the gauss point
            CALL FiniteElasticity_GaussdFdZ(dependentInterpPoint,elementNumber,gaussPointIdx,numberOfDimensions, &
              & numberOfXi,dFdZ,err,error,*999)

            !Add up the residual terms
            rowElementDOFIdx=0
            DO rowComponentIdx=1,numberOfDimensions
              CALL FieldVariable_ComponentInterpolationGet(rowsVariable,rowComponentIdx,rowInterpolationType,err,error,*999)
              SELECT CASE(rowInterpolationType)
              CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
                NULLIFY(rowDomain)
                CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
                NULLIFY(rowDomainTopology)
                CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
                NULLIFY(rowDomainElements)
                CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
                NULLIFY(rowBasis)
                CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
                CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
                DO rowElementParameterIdx=1,numberOfRowElementParameters  
                  rowElementDOFIdx=rowElementDOFIdx+1    
                  residualVector%elementResidual%vector(rowElementDOFIdx)= &
                    & residualVector%elementResidual%vector(rowElementDOFIdx)+ &
                    & gaussWeight*Jxxi*Jznu*(cauchyTensor(rowComponentIdx,1)*dFdZ(rowElementParameterIdx,1,rowComponentIdx)+ &
                    & cauchyTensor(rowComponentIdx,2)*dFdZ(rowElementParameterIdx,2,rowComponentIdx)+ &
                    & cauchyTensor(rowComponentIdx,3)*dFdZ(rowElementParameterIdx,3,rowComponentIdx))
                ENDDO !rowElementParameterIdx
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Will probably never be used
                CALL FlagError("Finite elasticity with element based interpolation is not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The row interpolation type of "//TRIM(NumberToVString(rowInterpolationType,"*",err,error))// &
                  & " for row component "//TRIM(NumberToVString(rowComponentIdx,"*",err,error))// &
                  & " is invalid or not implemented."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDDO !rowComponentIdx
          ENDDO !gaussPointIdx

          !Call surface pressure term : should only be executed if THIS element has surface pressure on it (direct or incremented)
          IF(haveSurfacePressure) THEN  
            CALL FiniteElasticity_SurfacePressureResidualEvaluate(equationsSet,elementNumber,dependentVariableType, &
              & rhsVariableType,err,error,*999)
          ENDIF

        CASE DEFAULT
          localError="The equations set subtype of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
            & " is invalid or not implemented."
          CALL FlagError(localError,err,error,*999)
        END SELECT

        !Gravity loading term
        IF(updateRHS) THEN
          IF(ASSOCIATED(sourceField)) THEN
            DO gaussPointIdx=1,numberOfGauss

              CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)

              CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
                & err,error,*999)
              CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
                & err,error,*999)
              CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,sourceInterpPoint, &
                & err,error,*999)
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx, &
                & materialsDensityInterpPoint,err,error,*999)
              IF(darcyDensity) THEN
                CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,darcyMaterialsInterpPoint, &
                  & err,error,*999)
                !Account for separate fluid and solid proportions and densities
                !Total lagrangian density = m_s + m_f = rho^0_s * (1 - phi^0) + rho_f * phi
                !By assuming solid incompressibility, phi = (J - 1 + phi^0)
                !\todo: Think about how this fits in with the constitutive relation, and what happens when the solid
                !isn't incompressible. Can we assume the solid is incompressible if we aren't enforcing that in the
                !constitutive relation?
                density=materialsDensityInterpPoint%values(1,1)*(1.0_DP-darcyMaterialsInterpPoint%values(8,1)) + &
                  & darcyMaterialsInterpPoint%values(7,1)*(Jznu-1.0_DP+darcyMaterialsInterpPoint%values(8,1))
              ELSE
                density=materialsDensityInterpPoint%values(1,1)
              ENDIF

              CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,Jzxi,err,error,*999)

              rowElementDOFIdx=0
              DO rowComponentIdx=1,numberOfDimensions
                NULLIFY(rowDomain)
                CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
                NULLIFY(rowDomainTopology)
                CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
                NULLIFY(rowDomainElements)
                CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
                NULLIFY(rowBasis)
                CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
                CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
                DO rowElementParameterIdx=1,numberOfRowElementParameters
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowQuadratureScheme,rowElementParameterIdx, &
                    & NO_PART_DERIV,gaussPointIdx,rowPhi,err,error,*999)
                  rowElementDOFIdx=rowElementDOFIdx+1
                  rhsVector%elementVector%vector(rowElementDOFIdx)=rhsVector%elementVector%vector(rowElementDOFIdx) + &
                    & density*sourceInterpPoint%values(rowComponentIdx,1)*gaussWeight*Jzxi
                ENDDO !rowElementParameterIdx
              ENDDO !rowComponentIdx
            ENDDO !gaussPointIdx
          ENDIF !source field
        ENDIF !update RHS

        !Scale factor adjustment
        CALL Field_ScalingTypeGet(dependentField,scalingType,err,error,*999)
        IF(scalingType/=FIELD_NO_SCALING) THEN

          ! Following function is necessary, otherwise wrong face scale factors from function call to surface pressure residual are
          ! used.
          NULLIFY(rowsInterpParameters)
          CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,rowsVariableType,rowsInterpParameters, &
            & err,error,*999)
          NULLIFY(dependentInterpParameters)
          CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,dependentVariableType, &
            & dependentInterpParameters,err,error,*999)
          CALL Field_InterpolationParametersScaleFactorsElementGet(elementNumber,rowsInterpParameters,err,error,*999)
          CALL Field_InterpolationParametersScaleFactorsElementGet(elementNumber,dependentInterpParameters,err,error,*999)

          rowElementDofIdx=0          
          DO rowComponentIdx=1,numberOfDimensions
            NULLIFY(rowDomain)
            CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
            NULLIFY(rowDomainTopology)
            CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
            NULLIFY(rowDomainElements)
            CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
            NULLIFY(rowBasis)
            CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
            CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfRowElementParameters,err,error,*999)
            !Loop over residual vector
            DO rowElementParameterIdx=1,numberOfRowElementParameters
              rowElementDofIdx=rowElementDofIdx+1
              IF(updateResidual) THEN
                residualVector%elementResidual%vector(rowElementDOFIdx)= &
                  & residualVector%elementResidual%vector(rowElementDOFIdx)* &
                  & rowsInterpParameters%scaleFactors(rowElementParameterIdx,rowComponentIdx)
              ENDIF
              IF(updateMass) THEN
                columnElementDofIdx=0
                !Loop over element columns
                DO columnComponentIdx=1,numberOfDimensions
                  NULLIFY(columnDomain)
                  CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnDomain,err,error,*999)
                  NULLIFY(columnDomainTopology)
                  CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
                  NULLIFY(columnDomainElements)
                  CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
                  NULLIFY(columnBasis)
                  CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,columnBasis,err,error,*999)
                  CALL Basis_NumberOfElementParametersGet(columnBasis,numberOfColElementParameters,err,error,*999)
                  DO columnElementParameterIdx=1,numberOfColElementParameters
                    columnElementDofIdx=columnElementDofIdx+1
                    massMatrix%elementMatrix%matrix(rowElementDofIdx,columnElementDofIdx)= &
                      & massMatrix%elementMatrix%matrix(rowElementDofIdx,columnElementDofIdx)* &
                      & rowsInterpParameters%scaleFactors(rowElementParameterIdx,rowComponentIdx)* &
                      & dependentInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
                  ENDDO !columnElementParameterIdx
                ENDDO !columnComponentIdx              
              ENDIF
              IF(updateRHS) THEN
                rhsVector%elementVector%vector(rowElementDOFIdx)= &
                  & rhsVector%elementVector%vector(rowElementDOFIdx)* &
                  & rowsInterpParameters%scaleFactors(rowElementParameterIdx,rowComponentIdx)
              ENDIF
            ENDDO !rowElementParameterIdx
          ENDDO !rowComponentIdx
          IF (equationsSetSubtype /= EQUATIONS_SET_MEMBRANE_SUBTYPE .AND. &
            & equationsSetSubtype /= EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE) THEN
            SELECT CASE(pressureInterpolationType)
            CASE(FIELD_NODE_BASED_INTERPOLATION) !node based
              DO rowElementParameterIdx=1,numberOfPressureElementParameters
                rowElementDOFIdx=rowElementDOFIdx+1
                IF(updateResidual) THEN
                  residualVector%elementResidual%vector(rowElementDOFIdx)= &
                    & residualVector%elementResidual%vector(rowElementDOFIdx)* &
                    & rowsInterpParameters%scaleFactors(rowElementParameterIdx,pressureComponent)
                ENDIF
                IF(updateRHS) THEN
                  rhsVector%elementVector%vector(rowElementDOFIdx)= &
                    & rhsVector%elementVector%vector(rowElementDOFIdx)* &
                    & rowsInterpParameters%scaleFactors(rowElementParameterIdx,numberOfDimensions+1)
                ENDIF
              ENDDO !rowElementParameterIdx
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              !Do nothing
            CASE DEFAULT
              localError="The interpolation type of "//TRIM(NumberToVString(pressureInterpolationType,"*",err,error))// &
                & " for row component index "//TRIM(NumberToVString(pressureComponent,"*",err,error))// &
                & " is invalid or not implemented."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ENDIF ! scaling
      ENDIF !update

    ENDIF !old or new residual evaluate

    EXITS("FiniteElasticity_FiniteElementResidualEvaluate")
    RETURN
999 ERRORS("FiniteElasticity_FiniteElementResidualEvaluate",err,error)
    EXITS("FiniteElasticity_FiniteElementResidualEvaluate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_FiniteElementResidualEvaluate

  !
  !================================================================================================================================
  !

  !>Pre-evaluates the residual for a finite elasticity finite element equations set.
  SUBROUTINE FiniteElasticity_FiniteElementPreResidualEvaluate(equationsSet,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: esSpecification(3)
    TYPE(FieldType), POINTER :: dependentField
    TYPE(FieldVariableType), POINTER :: dependentVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_FiniteElementPreResidualEvaluate",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)

    SELECT CASE(esSpecification(3))      
    CASE(EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
      & EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
      NULLIFY(dependentField)
      CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
      NULLIFY(dependentVariable)
      CALL Field_VariableGet(dependentField,FIELD_U1_VARIABLE_TYPE,dependentVariable,err,error,*999)
      CALL FiniteElasticity_StressStrainCalculate(equationsSet,EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR, &
        & dependentVariable,err,error,*999)
    CASE(EQUATIONS_SET_MEMBRANE_SUBTYPE,EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE, &
      & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE, &
      & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE,&
      & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE, EQUATIONS_SET_NO_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE,EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
      & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
      & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE, &
      & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE,EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE, &
      & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE,EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
      & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
      & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
      !Do nothing ???
    CASE DEFAULT
      localError="The third equations set specification of "//TRIM(NumberToVString(esSpecification(3),"*",err,error))// &
        & " is not valid for a finite elasticity type of an elasticity equation set."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FiniteElasticity_FiniteElementPreResidualEvaluate")
    RETURN
999 ERRORS("FiniteElasticity_FiniteElementPreResidualEvaluate",err,error)
    EXITS("FiniteElasticity_FiniteElementPreResidualEvaluate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_FiniteElementPreResidualEvaluate

  !
  !================================================================================================================================
  !

  !>Post-evaluates the residual for a finite elasticity finite element equations set.
  SUBROUTINE FiniteElasticity_FiniteElementPostResidualEvaluate(equationsSet,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: esSpecification(3)
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_FiniteElementPostResidualEvaluate",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)

    SELECT CASE(esSpecification(3))
    CASE(EQUATIONS_SET_MEMBRANE_SUBTYPE,EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, & 
      & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE, &
      & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE,EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE, &
      & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE,&
      & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE, & 
      & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE,EQUATIONS_SET_NO_SUBTYPE,EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE, &
      & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE,EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE,EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
      & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, & 
      & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
      & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE,  EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE,&
      & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE, &
      & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE,&
      & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
      & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
      & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
      !Do nothing ???
    CASE DEFAULT
      localError="The third equations set specification of "//TRIM(NumberToVString(esSpecification(3),"*",err,error))// &
        & " is not valid for a finite elasticity type of an elasticity equation set."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FiniteElasticity_FiniteElementPostResidualEvaluate")
    RETURN
999 ERRORS("FiniteElasticity_FiniteElementPostResidualEvaluate",err,error)
    EXITS("FiniteElasticity_FiniteElementPostResidualEvaluate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_FiniteElementPostResidualEvaluate

  !
  !================================================================================================================================
  !

  !>Calculated an output field for a finite elasticity equations set.
  SUBROUTINE FiniteElasticityEquationsSet_DerivedVariableCalculate(equationsSet,derivedType,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set to calculate the output for
    INTEGER(INTG), INTENT(IN) :: derivedType !<The derived field type to calculate. \see EquationsSetRoutines_DerivedTypes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    TYPE(FieldVariableType), POINTER :: derivedVariable

    ENTERS("FiniteElasticityEquationsSet_DerivedVariableCalculate",err,error,*999)
    
    NULLIFY(derivedVariable)
    CALL EquationsSet_DerivedTypeVariableGet(equationsSet,derivedType,derivedVariable,err,error,*999)
    CALL FiniteElasticity_StressStrainCalculate(equationsSet,derivedType,derivedVariable,err,error,*999)
   
    EXITS("FiniteElasticityEquationsSet_DerivedVariableCalculate")
    RETURN
999 ERRORS("FiniteElasticityEquationsSet_DerivedVariableCalculate",err,error)
    EXITS("FiniteElasticityEquationsSet_DerivedVariableCalculate")
    RETURN 1
    
  END SUBROUTINE FiniteElasticityEquationsSet_DerivedVariableCalculate

  !
  !================================================================================================================================
  !

  !>Runs after each control loop iteration. Exports fields etc.
  SUBROUTINE FiniteElasticity_PostLoop(controlLoop,err,error,*)

    !Argument variables
    TYPE(ControlLoopType), POINTER :: controlLoop !<A pointer to the control loop
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,currentIteration,inputIteration,loopType,numberOfDimensions,outputIteration,pSpecification(3)
    REAL(DP) :: currentTime,timeIncrement,startTIme,stopTime
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: dependentField,geometricField
    TYPE(FieldsType), POINTER :: fields
    TYPE(ProblemType), POINTER :: problem
    TYPE(RegionType), POINTER :: region
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(SolverMappingType), POINTER :: solverMapping
    TYPE(SolversType), POINTER :: solvers
    TYPE(VARYING_STRING) :: filename,method
    
    ENTERS("FiniteElasticity_PostLoop",err,error,*999)
    
    NULLIFY(problem)
    CALL ControlLoop_ProblemGet(controlLoop,problem,err,error,*999)
    CALL Problem_SpecificationGet(problem,3,pSpecification,err,error,*999)

    CALL ControlLoop_TypeGet(controlLoop,loopType,err,error,*999)
    
    SELECT CASE(pSpecification(3))
    CASE(PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_NO_SUBTYPE)
      IF(loopType==CONTROL_LOAD_INCREMENT_LOOP_TYPE) THEN
        CALL FiniteElasticity_ControlLoadIncrementLoopPostLoop(controlLoop,err,error,*999)
      ENDIF
    CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE)
      !Check if we are a time loop.
      IF(loopType==CONTROL_TIME_LOOP_TYPE) THEN
        !Get times
        CALL ControlLoop_CurrentTimeInformationGet(controlLoop,currentTime,timeIncrement,startTime,stopTime,currentIteration, &
          & outputIteration,inputIteration,err,error,*999)
        NULLIFY(solvers)
        IF(outputIteration/=0) THEN
          IF(MOD(currentIteration,outputIteration)==0) THEN
            CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)      
            !Get solver
            IF(pSpecification(3)==PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE) THEN
              NULLIFY(solver)
              !Get Nonlinear solver
              CALL Solvers_SolverGet(solvers,3,solver,err,error,*999)
            ELSE
              NULLIFY(solver)
              !Get dynamic solver
              CALL Solvers_SolverGet(solvers,2,solver,err,error,*999)
            ENDIF
            NULLIFY(solverEquations)
            CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
            NULLIFY(solverMapping)
            CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
            !CALL SolverMapping_NumberOfEquationsSetsGet(solverMapping,numberOfEquationsSets,err,error,*999)
            !DO equationsSetIdx=1,numberOfEquationsSets
            NULLIFY(equationsSet)
            CALL SolverMapping_EquationsSetGet(solverMapping,1,equationsSet,err,error,*999)
            NULLIFY(region)
            CALL EquationsSet_RegionGet(equationsSet,region,err,error,*999)
            NULLIFY(fields)
            CALL Region_FieldsGet(region,fields,err,error,*999)
            filename="Elasticity_"//TRIM(NumberToVString(INT(currentIteration),"*",err,error))
            method="FORTRAN"
            CALL FIELD_IO_NODES_EXPORT(fields,filename,method,err,error,*999)
            CALL FIELD_IO_ELEMENTS_EXPORT(fields,filename,method,err,error,*999)
            !ENDDO !equationsSetIdx            
          ENDIF
        ENDIF
      ELSE IF(loopType==CONTROL_LOAD_INCREMENT_LOOP_TYPE) THEN
        CALL FiniteElasticity_ControlLoadIncrementLoopPostLoop(controlLoop,err,error,*999)
      ENDIF
    CASE DEFAULT
      !Do nothing
    END SELECT
    
    EXITS("FiniteElasticity_PostLoop")
    RETURN
999 ERRORSEXITS("FiniteElasticity_PostLoop",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_PostLoop

  !
  !================================================================================================================================
  !

  !>Calculates the strain field for a finite elasticity finite element equations set.
  SUBROUTINE FiniteElasticity_StressStrainCalculate(equationsSet,derivedType,fieldVariable,err,error,*)

    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set to calculate strain for.
    INTEGER(INTG), INTENT(IN) :: derivedType !<The type of derived field to calculate.     
    TYPE(FieldVariableType), POINTER, INTENT(INOUT) :: fieldVariable !<The field variable to store the stress/strain in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,dataPointIdx,dataPointNumber,elementIdx,elementNumber,esSpecification(3),fieldInterpolation, &
      & fieldVarType,finishIdx,gaussPointIdx,meshComponentNumber,numberOfComponents,numberOfDataPoints, &
      & numberOfDependentComponents,numberOfDimensions,numberOfElementXi,numberOfGauss,numberOfTimes,numberOfXi,outputType, &
      & partIdx,startIdx,residualVariableType,variableType
    REAL(DP) :: dZdNu(3,3),Fg(3,3),Fe(3,3),J,Jg,Je,C(3,3),f(3,3),E(3,3),growthValues(3),xi(3),values(3,3)
    REAL(SP) :: elementUserElapsed,elementSystemElapsed,systemElapsed,systemTime1(1),systemTime2(1),systemTime3(1), &
      & systemTime4(1),userElapsed,userTime1(1),userTime2(1),userTime3(1),userTime4(1)
    TYPE(BasisType), POINTER :: basis
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionDataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainMappingType), POINTER :: elementsMapping
    TYPE(DomainMappingsType), POINTER :: domainMappings
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsInterpolationType), POINTER :: interpolation
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: field,dependentField,geometricField,fibreField,independentField,materialsField
    TYPE(QuadratureSchemeType), POINTER :: quadratureScheme
    TYPE(FieldInterpolationParametersType), POINTER :: geometricInterpParameters,dependentInterpParameters, &
      & fibreInterpParameters,independentInterpParameters,materialsInterpParameters
    TYPE(FieldInterpolatedPointType), POINTER :: geometricInterpPoint,dependentInterpPoint,fibreInterpPoint, &
      & independentInterpPoint,materialsInterpPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER ::geometricInterpPointMetrics,dependentInterpPointMetrics
    TYPE(FieldVariableType), POINTER :: residualVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_StressStrainCalculate",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)

    !Get the coordinate system
    NULLIFY(coordinateSystem)
    CALL EquationsSet_CoordinateSystemGet(equationsSet,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_DimensionGet(coordinateSystem,numberOfDimensions,err,error,*999)
    !Check the provided strain field variable has appropriate components and interpolation
    numberOfComponents=NUMBER_OF_VOIGT(numberOfDimensions)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    CALL FieldVariable_VariableTypeGet(fieldVariable,fieldVarType,err,error,*999)
    CALL FieldVariable_NumberOfComponentsCheck(fieldVariable,numberOfComponents,err,error,*999)
    CALL FieldVariable_ComponentInterpolationGet(fieldVariable,1,fieldInterpolation,err,error,*999)
    !Check the interpolation type
    SELECT CASE(fieldInterpolation)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      CALL FlagError("Can not calculate stress or strain for a field with constant interpolation.",err,error,*999)
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      !OK
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      CALL FlagError("Stress/strain calculation is not implemented for a field with node based interpolation.",err,error,*999)
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Stress/strain calculation is not implemented for a field with grid point based interpolation.", &
        & err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      !OK
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      !OK
    CASE DEFAULT
      localError="The field interpolation type for component 1 of "//TRIM(NumberToVString(fieldInterpolation,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    !Check that all the components have the same interpolation type
    DO componentIdx=2,numberOfComponents
      CALL FieldVariable_ComponentInterpolationCheck(fieldVariable,componentIdx,fieldInterpolation,err,error,*999)
    ENDDO !componentIdx

    NULLIFY(equations)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    NULLIFY(vectorEquations)
    CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
    NULLIFY(vectorMapping)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    NULLIFY(nonlinearMapping)
    CALL EquationsMappingVector_NonlinearMappingGet(vectorMapping,nonlinearMapping,err,error,*999)
    NULLIFY(residualMapping)
    CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,1,residualMapping,err,error,*999)
    NULLIFY(residualVariable)
    CALL EquationsMappingResidual_VariableGet(residualMapping,1,residualVariable,err,error,*999)
    CALL FieldVariable_NumberOfComponentsGet(residualVariable,numberOfDependentComponents,err,error,*999)
    CALL FieldVariable_VariableTypeGet(residualVariable,residualVariableType,err,error,*999)
  
    NULLIFY(geometricField)
    CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
    NULLIFY(dependentField)
    CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
    NULLIFY(fibreField)
    CALL EquationsSet_FibreFieldExists(equationsSet,fibreField,err,error,*999)
    NULLIFY(materialsField)
    CALL EquationsSet_MaterialsFieldExists(equationsSet,materialsField,err,error,*999)
    NULLIFY(independentField)
    CALL EquationsSet_IndependentFieldExists(equationsSet,independentField,err,error,*999)

    NULLIFY(decomposition)
    CALL Field_DecompositionGet(dependentField,decomposition,err,error,*999)
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(domain)
    CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
    NULLIFY(domainMappings)
    CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)
    NULLIFY(elementsMapping)
    CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    NULLIFY(domainElements)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    
    !Grab interpolation points
    NULLIFY(interpolation)
    CALL Equations_InterpolationGet(equations,interpolation,err,error,*999)    
    NULLIFY(geometricInterpParameters)
    CALL EquationsInterpolation_GeometricParametersGet(interpolation,FIELD_U_VARIABLE_TYPE,geometricInterpParameters,err,error,*999)
    NULLIFY(geometricInterpPoint)
    CALL EquationsInterpolation_GeometricPointGet(interpolation,FIELD_U_VARIABLE_TYPE,geometricInterpPoint,err,error,*999)
    NULLIFY(geometricInterpPointMetrics)
    CALL EquationsInterpolation_GeometricPointMetricsGet(interpolation,FIELD_U_VARIABLE_TYPE,geometricInterpPointMetrics, &
      & err,error,*999)
    NULLIFY(dependentInterpParameters)
    CALL EquationsInterpolation_DependentParametersGet(interpolation,residualVariableType,dependentInterpParameters,err,error,*999)
    NULLIFY(dependentInterpPoint)
    CALL EquationsInterpolation_DependentPointGet(interpolation,residualVariableType,dependentInterpPoint,err,error,*999)
    NULLIFY(dependentInterpPointMetrics)
    CALL EquationsInterpolation_DependentPointMetricsGet(interpolation,residualVariableType,dependentInterpPointMetrics, &
      & err,error,*999)
    NULLIFY(fibreInterpParameters)
    NULLIFY(fibreInterpPoint)
    IF(ASSOCIATED(fibreField)) THEN
      CALL EquationsInterpolation_FibreParametersGet(interpolation,FIELD_U_VARIABLE_TYPE,fibreInterpParameters,err,error,*999)
      CALL EquationsInterpolation_FibrePointGet(interpolation,FIELD_U_VARIABLE_TYPE,fibreInterpPoint,err,error,*999)
    ENDIF
    NULLIFY(materialsInterpParameters)
    NULLIFY(materialsInterpPoint)
    IF(ASSOCIATED(materialsField)) THEN
      CALL EquationsInterpolation_MaterialsParametersGet(interpolation,FIELD_U_VARIABLE_TYPE,materialsInterpParameters, &
        & err,error,*999)
      CALL EquationsInterpolation_MaterialsPointGet(interpolation,FIELD_U_VARIABLE_TYPE,materialsInterpPoint,err,error,*999)
    ENDIF
    NULLIFY(independentInterpParameters)
    NULLIFY(independentInterpPoint)
    IF(ASSOCIATED(independentField)) THEN
      CALL EquationsInterpolation_IndependentParametersGet(interpolation,FIELD_U_VARIABLE_TYPE,independentInterpParameters, &
        & err,error,*999)
      CALL EquationsInterpolation_IndependentPointGet(interpolation,FIELD_U_VARIABLE_TYPE,independentInterpPoint,err,error,*999)
    ENDIF
 
    numberOfTimes=0
    elementUserElapsed=0.0_SP
    elementSystemElapsed=0.0_SP
    CALL Equations_OutputTypeGet(equations,outputType,err,error,*999)

    !Loop over the two parts: 1 - boundary and ghost elements, 2 - internal
    DO partIdx=1,2          
      
      IF(outputType>=EQUATIONS_TIMING_OUTPUT) THEN
        CALL CPUTimer(USER_CPU,userTime1,err,error,*999)
        CALL CPUTimer(SYSTEM_CPU,systemTime1,err,error,*999)
      ENDIF
      
      IF(partIdx==1) THEN
        CALL DomainMapping_BoundaryStartGet(elementsMapping,startIdx,err,error,*999)
        CALL DomainMapping_GhostFinishGet(elementsMapping,finishIdx,err,error,*999)
      ELSE
        CALL DomainMapping_InternalStartGet(elementsMapping,startIdx,err,error,*999)
        CALL DomainMapping_InternalFinishGet(elementsMapping,finishIdx,err,error,*999)
      ENDIF
      
      !Loop over (1) the boundary and ghost elements, (2) the internal elements
      DO elementIdx=startIdx,finishIdx
        
        numberOfTimes=numberOfTimes+1
        CALL DomainMapping_NumberGet(elementsMapping,elementIdx,elementNumber,err,error,*999)
        
        IF(diagnostics1) THEN
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",elementNumber,err,error,*999)
        ENDIF

        NULLIFY(basis)
        CALL DomainElements_ElementBasisGet(domainElements,elementNumber,basis,err,error,*999)
        CALL Basis_NumberOfXiGet(basis,numberOfXi,err,error,*999)
      
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,geometricInterpParameters,err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,dependentInterpParameters,err,error,*999)
        IF(ASSOCIATED(fibreField)) THEN
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,fibreInterpParameters,err,error,*999)
        ENDIF
        IF(ASSOCIATED(materialsField)) THEN
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,materialsInterpParameters,err,error,*999)
        ENDIF
        IF(ASSOCIATED(independentField)) THEN
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,independentInterpParameters, &
            & err,error,*999)
        ENDIF

        SELECT CASE(fieldInterpolation)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Interpolate dependent, geometric, fibre etc. fields
          xi=[0.5_DP,0.5_DP,0.5_DP]
          CALL Field_InterpolateXi(FIRST_PART_DERIV,xi(1:numberOfXi),geometricInterpPoint,err,error,*999)
          CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
          CALL Field_InterpolateXi(FIRST_PART_DERIV,xi(1:numberOfXi),dependentInterpPoint,err,error,*999)
          CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
          IF(ASSOCIATED(fibreField)) &
            & CALL Field_InterpolateXi(NO_PART_DERIV,xi(1:numberOfXi),fibreInterpPoint,err,error,*999)
          IF(ASSOCIATED(materialsField)) &
            & CALL Field_InterpolateXi(FIRST_PART_DERIV,xi(1:numberOfXi),materialsInterpPoint,err,error,*999)
          IF(ASSOCIATED(independentField)) &
            & CALL Field_InterpolateXi(FIRST_PART_DERIV,xi(1:numberOfXi),independentInterpPoint,err,error,*999)
!!\TODO how to get growth values????
          growthValues = [1.0_DP,1.0_DP,1.0_DP]
        
          CALL FiniteElasticity_StressStrainPoint(equationsSet,derivedType,numberOfDimensions,numberOfXi,gaussPointIdx, &
            & elementNumber,geometricInterpPoint,geometricInterpPointMetrics,dependentInterpPoint, &
            & dependentInterpPointMetrics,fibreInterpPoint,materialsInterpPoint,independentInterpPoint, &
            & growthValues,values,err,error,*999)
          
          !We only want to store the independent components 
          SELECT CASE(numberOfDimensions)
          CASE(1)
            ! 1 dimensional problem
            CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
              & TENSOR_TO_VOIGT1(1,1),values(1,1),err,error,*999)
          CASE(2)
            ! 2 dimensional problem
            CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
              & TENSOR_TO_VOIGT2(1,1),values(1,1),err,error,*999)
            CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
              & TENSOR_TO_VOIGT2(1,2),values(1,2),err,error,*999)
            CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
              & TENSOR_TO_VOIGT2(2,2),values(2,2),err,error,*999)
          CASE(3)
            ! 3 dimensional problem
            CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
              & TENSOR_TO_VOIGT3(1,1),values(1,1),err,error,*999)
            CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
              & TENSOR_TO_VOIGT3(1,2),values(1,2),err,error,*999)
            CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
              & TENSOR_TO_VOIGT3(1,3),values(1,3),err,error,*999)
            CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
              & TENSOR_TO_VOIGT3(2,2),values(2,2),err,error,*999)
            CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
              & TENSOR_TO_VOIGT3(2,3),values(2,3),err,error,*999)
            CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
              & TENSOR_TO_VOIGT3(3,3),values(3,3),err,error,*999)
          CASE DEFAULT
            localError="The number of dimensions of "//TRIM(NumberToVString(numberofDimensions,"*",err,error))// &
                & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)            
            
          NULLIFY(quadratureScheme)               
          CALL Basis_QuadratureSchemeGet(basis,BASIS_DEFAULT_QUADRATURE_SCHEME,quadratureScheme,err,error,*999)
          CALL BasisQuadratureScheme_NumberOfGaussGet(quadratureScheme,numberOfGauss,err,error,*999)
          
          !Loop over gauss points        
          DO gaussPointIdx=1,numberOfGauss
            
            IF(diagnostics1) THEN
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Gauss point number = ",gaussPointIdx,err,error,*999)
            ENDIF
            
            !Interpolate dependent, geometric, fibre etc. fields
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
                & err,error,*999)
            ENDIF
            IF(ASSOCIATED(materialsField)) THEN
              CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
                & err,error,*999)
            ENDIF
            IF(ASSOCIATED(independentField)) THEN
              CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,independentInterpPoint, &
                & err,error,*999)
            ENDIF
            IF(esSpecification(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE.OR. &
              esSpecification(3)==EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
              CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                & gaussPointIdx,elementNumber,1,growthValues(1),err,error,*999)
              IF(numberofDimensions>1) THEN
                CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                  & gaussPointIdx,elementNumber,2,growthValues(2),err,error,*999)
                IF(numberOfDimensions>2) THEN
                  CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                  & gaussPointIdx,elementNumber,3,growthValues(3),err,error,*999)
                ENDIF
              ENDIF
            ELSE
              growthValues = [1.0_DP,1.0_DP,1.0_DP]
            ENDIF
            
            CALL FiniteElasticity_StressStrainPoint(equationsSet,derivedType,numberOfDimensions,numberOfXi,gaussPointIdx, &
              & elementNumber,geometricInterpPoint,geometricInterpPointMetrics,dependentInterpPoint, &
              & dependentInterpPointMetrics,fibreInterpPoint,materialsInterpPoint,independentInterpPoint, &
              & growthValues,values,err,error,*999)
            
            !We only want to store the independent components 
            SELECT CASE(numberOfDimensions)
            CASE(1)
              ! 1 dimensional problem
              CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,FIELD_VALUES_SET_TYPE,gaussPointIdx, &
                & elementNumber,TENSOR_TO_VOIGT1(1,1),values(1,1),err,error,*999)
            CASE(2)
              ! 2 dimensional problem
              CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,FIELD_VALUES_SET_TYPE,gaussPointIdx, &
                & elementNumber,TENSOR_TO_VOIGT2(1,1),values(1,1),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,FIELD_VALUES_SET_TYPE,gaussPointIdx, &
                & elementNumber,TENSOR_TO_VOIGT2(1,2),values(1,2),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,FIELD_VALUES_SET_TYPE,gaussPointIdx, &
                & elementNumber,TENSOR_TO_VOIGT2(2,2),values(2,2),err,error,*999)
            CASE(3)
              ! 3 dimensional problem
              CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,FIELD_VALUES_SET_TYPE,gaussPointIdx, &
                & elementNumber,TENSOR_TO_VOIGT3(1,1),values(1,1),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,FIELD_VALUES_SET_TYPE,gaussPointIdx, &
                & elementNumber,TENSOR_TO_VOIGT3(1,2),values(1,2),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,FIELD_VALUES_SET_TYPE,gaussPointIdx, &
                & elementNumber,TENSOR_TO_VOIGT3(1,3),values(1,3),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,FIELD_VALUES_SET_TYPE,gaussPointIdx, &
                & elementNumber,TENSOR_TO_VOIGT3(2,2),values(2,2),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,FIELD_VALUES_SET_TYPE,gaussPointIdx, &
                & elementNumber,TENSOR_TO_VOIGT3(2,3),values(2,3),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,FIELD_VALUES_SET_TYPE,gaussPointIdx, &
                & elementNumber,TENSOR_TO_VOIGT3(3,3),values(3,3),err,error,*999)
            CASE DEFAULT
              localError="The number of dimensions of "//TRIM(NumberToVString(numberofDimensions,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !gaussPointIdx
          
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          
          NULLIFY(dataProjection)
          CALL Field_DataProjectionGet(field,dataProjection,err,error,*999)
          NULLIFY(dataPoints)
          CALL DecompositionTopology_DecompositionDataPointsGet(decompositionTopology,dataPoints,err,error,*999)
          CALL DecompositionDataPoints_ElementNumberOfDataPointsGet(dataPoints,elementNumber,numberOfDataPoints,err,error,*999)
 
          DO dataPointIdx=1,numberOfDataPoints

            CALL DecompositionDataPoints_ElementDataGlobalNumberGet(dataPoints,dataPointIdx,elementNumber,dataPointNumber, &
              & err,error,*999)
            CALL DataProjection_ResultElementXiGet(dataProjection,dataPointNumber,numberOfElementXi,xi,err,error,*999)
            CALL Field_InterpolateXi(FIRST_PART_DERIV,xi(1:numberOfXi),geometricInterpPoint,err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateXi(FIRST_PART_DERIV,xi(1:numberOfXi),dependentInterpPoint,err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) &
              & CALL Field_InterpolateXi(NO_PART_DERIV,xi(1:numberOfXi),fibreInterpPoint,err,error,*999)
            IF(ASSOCIATED(materialsField)) &
              & CALL Field_InterpolateXi(FIRST_PART_DERIV,xi(1:numberOfXi),materialsInterpPoint,err,error,*999)
            IF(ASSOCIATED(independentField)) &
              & CALL Field_InterpolateXi(FIRST_PART_DERIV,xi(1:numberOfXi),independentInterpPoint,err,error,*999)
!!\TODO how to get growth values????
            growthValues = [1.0_DP,1.0_DP,1.0_DP]
            
            CALL FiniteElasticity_StressStrainPoint(equationsSet,derivedType,numberOfDimensions,numberOfXi,gaussPointIdx, &
              & elementNumber,geometricInterpPoint,geometricInterpPointMetrics,dependentInterpPoint, &
              & dependentInterpPointMetrics,fibreInterpPoint,materialsInterpPoint,independentInterpPoint, &
              & growthValues,values,err,error,*999)
            
            !We only want to store the independent components 
            SELECT CASE(numberOfDimensions)
            CASE(1)
              ! 1 dimensional problem
              CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
                & TENSOR_TO_VOIGT1(1,1),values(1,1),err,error,*999)
            CASE(2)
              ! 2 dimensional problem
              CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
                & TENSOR_TO_VOIGT2(1,1),values(1,1),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
                & TENSOR_TO_VOIGT2(1,2),values(1,2),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
                & TENSOR_TO_VOIGT2(2,2),values(2,2),err,error,*999)
            CASE(3)
              ! 3 dimensional problem
              CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
                & TENSOR_TO_VOIGT3(1,1),values(1,1),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
                & TENSOR_TO_VOIGT3(1,2),values(1,2),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
                & TENSOR_TO_VOIGT3(1,3),values(1,3),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
                & TENSOR_TO_VOIGT3(2,2),values(2,2),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
                & TENSOR_TO_VOIGT3(2,3),values(2,3),err,error,*999)
              CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,FIELD_VALUES_SET_TYPE,elementNumber, &
                & TENSOR_TO_VOIGT3(3,3),values(3,3),err,error,*999)
            CASE DEFAULT
              localError="The number of dimensions of "//TRIM(NumberToVString(numberofDimensions,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
                      
          ENDDO !dataPointIdx
          
        CASE DEFAULT
          localError="The field interpolation type for component 1 of "// &
            & TRIM(NumberToVString(fieldInterpolation,"*",err,error))//" is invalid or not implemented."
          CALL FlagError(localError,err,error,*999)
        END SELECT
        
      ENDDO !elementIdx
      
      !Output timing information if required
      IF(outputType>=EQUATIONS_TIMING_OUTPUT) THEN
        CALL CPUTimer(USER_CPU,userTime2,err,error,*999)
        CALL CPUTimer(SYSTEM_CPU,systemTime2,err,error,*999)
        userElapsed=userTime2(1)-userTime1(1)
        systemElapsed=systemTime2(1)-systemTime1(1)
        elementUserElapsed=elementUserElapsed+userElapsed
        elementSystemElapsed=elementSystemElapsed+systemElapsed
        IF(partIdx==1) THEN
          CALL Profiling_TimingsOutput(0,"",userElapsed,systemElapsed,err,error,*999)
          CALL Profiling_TimingsOutput(1,"Boundary+ghost elements calculation",userElapsed,systemElapsed,err,error,*999)
        ELSE
          CALL Profiling_TimingsOutput(1,"Internal elements calculation",userElapsed,systemElapsed,err,error,*999)
          IF(numberOfTimes>0) CALL Profiling_TimingsOutput(1,"Average element calculation", &
            & elementUserElapsed/numberOfTimes,elementSystemElapsed/numberOfTimes,err,error,*999)
        ENDIF
      ENDIF !outputType>=EQUATIONS_TIMING_OUTPUT
      
      IF(partIdx==1) THEN
        IF(equations%outputType>=EQUATIONS_TIMING_OUTPUT) THEN
          CALL CPUTimer(USER_CPU,userTime3,err,error,*999)
          CALL CPUTimer(SYSTEM_CPU,systemTime3,err,error,*999)
        ENDIF
        !Start to update the field
        CALL FieldVariable_ParameterSetUpdateStart(fieldVariable,FIELD_VALUES_SET_TYPE,err,error,*999)
      ELSE
        !Finish to update the field
        CALL FieldVariable_ParameterSetUpdateFinish(fieldVariable,FIELD_VALUES_SET_TYPE,err,error,*999)
        !Output timing information if required
        IF(outputType>=EQUATIONS_TIMING_OUTPUT) THEN
          CALL CPUTimer(USER_CPU,userTime4,err,error,*999)
          CALL CPUTimer(SYSTEM_CPU,systemTime4,err,error,*999)
          userElapsed=userTime4(1)-userTime3(1)
          systemElapsed=systemTime4(1)-systemTime3(1)
          CALL Profiling_TimingsOutput(1,"Parameters update transfer",userElapsed,systemElapsed,err,error,*999)
        ENDIF !equations%outputType>=EQUATIONS_TIMING_OUTPUT
      ENDIF
      
    ENDDO !partIdx
        
    EXITS("FiniteElasticity_StressStrainCalculate")
    RETURN
999 ERRORSEXITS("FiniteElasticity_StressStrainCalculate",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_StressStrainCalculate

  !
  !================================================================================================================================
  !

  !>Evaluates stress and strain at a point. \TODO merge this with interpolate xi below.
  SUBROUTINE FiniteElasticity_StressStrainPoint(equationsSet,evaluateType,numberOfDimensions,numberOfXi,pointNumber, &
    & elementNumber,geometricInterpPoint,geometricInterpPointMetrics,dependentInterpPoint, &
    & dependentInterpPointMetrics,fibreInterpPoint,materialsInterpPoint,independentInterpPoint, &
    & growthValues,values,err,error,*)
    ! Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set to calculate the tensor for
    INTEGER(INTG), INTENT(IN) :: evaluateType !<The type of tensor to evaluate.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions
    INTEGER(INTG), INTENT(IN) :: pointNumber !<The point number to evaluate the tensor for
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The user element number to evaluate the tensor for
    TYPE(FieldInterpolatedPointType), POINTER :: geometricInterpPoint !<The geometric interpolated point
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: geometricInterpPointMetrics !<The geometric interpolated point metrics
    TYPE(FieldInterpolatedPointType), POINTER :: dependentInterpPoint !<The dependent interpolated point
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: dependentInterpPointMetrics !<The dependent interpolated point metrics
    TYPE(FieldInterpolatedPointType), POINTER :: fibreInterpPoint !<The fibre interpolated point
    TYPE(FieldInterpolatedPointType), POINTER :: materialsInterpPoint !<The materials interpolated point
    TYPE(FieldInterpolatedPointType), POINTER :: independentInterpPoint !<The independent interpolated point
    REAL(DP), INTENT(IN) :: growthValues(:) !<The growth extension values if any. 
    REAL(DP), INTENT(OUT) :: values(:,:) !<On exit, the interpolated tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local variables
    INTEGER(INTG) :: componentIdx,columnComponentIdx,esSpecification(3),fieldInterpolation,rowComponentIdx
    REAL(DP) :: B(3,3),BBar(3,3),cauchyStressTensor(3,3),C(3,3),CBar(3,3),dNudXi(3,3),dXidNu(3,3),E(3,3),Ebar(3,3),EbarV(6), &
      & EV(6),F(3,3),FNu(3,3),Fbar(3,3),Fe(3,3),Fg(3,3),fibreVectors(3,3),J,Je,Jg,JNu,JZ,p,SBarV(6),sigmaV(6)
    LOGICAL :: haveHydrostaticPressure
    TYPE(FieldInterpolatedPointType), POINTER :: darcyInterpPoint
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_StressStrainPoint",err,error,*999)

    !Calculate field metrics
    CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
    CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
    
    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)
    haveHydrostaticPressure=esSpecification(3)/=EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE.AND. &
      & esSpecification(3)/=EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE.AND. &
      & esSpecification(3)/=EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE.AND. &
      & esSpecification(3)/=EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE
    IF(haveHydrostaticPressure) THEN
      p=dependentInterpPoint%values(numberOfDimensions+1,NO_PART_DERIV)
    ELSE
      p=0.0_DP
    ENDIF

    !Calculate material fibre coordinate system
    CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
      & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
      & fibreVectors(1:numberOfDimensions,1:numberOfXi),err,error,*999)
    !Calculate F=dZ/dNU, the deformation gradient tensor at the xi location
    CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
      & dXidNu(1:numberOfXi,1:numberOfDimensions),F,J,FNu,JNu,err,error,*999)

    !Calculate growth tensors
    CALL FiniteElasticity_GrowthTensorCalculate(equationsSet,numberOfDimensions,FNu,growthValues,Fg,Fe,Jg,Je,err,error,*999)

    SELECT CASE(evaluateType)
    CASE(EQUATIONS_SET_DEFORMATION_GRADIENT_TENSOR, &
      & EQUATIONS_SET_DEFORMATION_GROWTH_TENSOR)
      !Do nothing, already calculated
    CASE(EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR, &
      & EQUATIONS_SET_L_CAUCHY_GREEN_DEFORMATION_TENSOR, &
      & EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR)
      CALL FiniteElasticity_MaterialDeformationTensorsCalculate(equationsSet,numberOfDimensions,Fe,Jg,haveHydrostaticPressure, &
        & Fbar,C,Cbar,B,BBar,EV,EbarV,err,error,*999)
    CASE(EQUATIONS_SET_FIRST_PK_STRESS_TENSOR)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(EQUATIONS_SET_SECOND_PK_STRESS_TENSOR)
      CALL FiniteElasticity_MaterialStressTensorsCalculate(equationsSet,numberOfDimensions,materialsInterpPoint, &
        & Fe,Jg,p,haveHydrostaticPressure,SBarV,err,error,*999)
    CASE(EQUATIONS_SET_CAUCHY_STRESS_TENSOR)
      SELECT CASE(esSpecification(3))
      CASE(EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
        & EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE)
        CALL FiniteElasticity_SpatialStressTensorsCalculate(equationsSet,numberOfDimensions,materialsInterpPoint, &
          & Fe,Je,p,haveHydrostaticPressure,sigmaV,err,error,*999)
      CASE(EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE, &
        & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE)
        CALL FiniteElasticity_GaussCauchyTensor(equationsSet,numberOfDimensions,dependentInterpPoint,materialsInterpPoint, &
          & geometricInterpPoint,darcyInterpPoint,independentInterpPoint,elementNumber,0,FNu,JNu,cauchyStressTensor,err,error,*999)
        CALL TensorToVoigt(numberOfDimensions,[TENSOR_CONTRAVARIANT_INDEX,TENSOR_CONTRAVARIANT_INDEX],cauchyStressTensor, &
          & sigmaV,err,error,*999)
      CASE DEFAULT
        localError="The third equations set specification of "//TRIM(NumberToVString(esSpecification(3),"*",err,error))// &
          & " is invalid or not implemented."
        CALL FlagError(localError,err,error,*999)
        CALL FlagError("Not implemented.",err,error,*999)
      END SELECT
    CASE DEFAULT
      localError="The tensor evaluate type of "//TRIM(NumberToVString(evaluateType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    SELECT CASE(evaluateType)
    CASE(EQUATIONS_SET_DEFORMATION_GRADIENT_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=Fe(1:numberOfDimensions,1:numberOfDimensions)
    CASE(EQUATIONS_SET_DEFORMATION_GROWTH_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=Fg(1:numberOfDimensions,1:numberOfDimensions)      
    CASE(EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=CBar(1:numberOfDimensions,1:numberOfDimensions)
    CASE(EQUATIONS_SET_L_CAUCHY_GREEN_DEFORMATION_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=BBar(1:numberOfDimensions,1:numberOfDimensions)
    CASE(EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR)
      CALL VoigtToTensor(numberOfDimensions,[TENSOR_COVARIANT_INDEX],EbarV,values,err,error,*999)
    CASE(EQUATIONS_SET_CAUCHY_STRESS_TENSOR)
      CALL VoigtToTensor(numberOfDimensions,[TENSOR_CONTRAVARIANT_INDEX],sigmaV,values,err,error,*999)
    CASE(EQUATIONS_SET_FIRST_PK_STRESS_TENSOR)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(EQUATIONS_SET_SECOND_PK_STRESS_TENSOR)
      CALL VoigtToTensor(numberOfDimensions,[TENSOR_CONTRAVARIANT_INDEX],SBarV,values,err,error,*999)
    CASE DEFAULT
      CALL FlagError("The tensor evalaute type of "//TRIM(NumberToVString(evaluateType,"*",err,error))//" is invalid "// &
        & "for finite elasticity equation sets.",err,error,*999)
    END SELECT
 
    EXITS("FiniteElasticity_StressStrainPoint")
    RETURN
999 ERRORS("FiniteElasticity_StressStrainPoint",err,error)
    EXITS("FiniteElasticity_StressStrainPoint")
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_StressStrainPoint

  !
  !================================================================================================================================
  !

  !>Evaluates a tensor at a given element Gauss point. \TODO merge this with interpolate xi below.
  SUBROUTINE FiniteElasticity_TensorInterpolateGaussPoint(equationsSet,tensorEvaluateType,gaussPointNumber,userElementNumber, &
    & values,err,error,*)
    ! Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set to calculate the tensor for
    INTEGER(INTG), INTENT(IN) :: tensorEvaluateType !<The type of tensor to evaluate.
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to evaluate the tensor for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to evaluate the tensor for
    REAL(DP), INTENT(OUT) :: values(:,:) !<On exit, the interpolated tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    ! Local variables
    INTEGER(INTG) :: dependentVarType,meshComponentNumber
    INTEGER(INTG) :: numberOfDimensions,numberOfXi
    INTEGER(INTG) :: localElementNumber,componentIdx,columnComponentIdx,rowComponentIdx
    REAL(DP) :: C(3,3),cauchyStressTensor(3,3),cauchyStressVoigt(6),dNudXi(3,3),dXidNu(3,3),dZdNu(3,3),dZdX(3,3),E(3,3), &
      & Fe(3,3),Fg(3,3),fibreVectors(3,3),growthValues(3),Je,Jg,JZ,JZnu,dependentJacobian,geometricJacobian
    LOGICAL :: userElementExists,ghostElement
    TYPE(BasisType), POINTER :: elementBasis
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsInterpolationType), POINTER :: equationsInterpolation
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: dependentField,fibreField,geometricField,independentField,materialsField
    TYPE(FieldInterpolatedPointType), POINTER :: geometricInterpPoint,fibreInterpPoint,dependentInterpPoint,materialsInterpPoint, &
      & independentInterpPoint,darcyInterpPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: geometricInterpPointMetrics,dependentInterpPointMetrics
    TYPE(FieldInterpolationParametersType), POINTER :: dependentInterpParameters,fibreInterpParameters,geometricInterpParameters, &
      & independentInterpParameters,materialsInterpParameters
    TYPE(FieldVariableType), POINTER :: residualVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_TensorInterpolateGaussPoint",err,error,*999)

    NULLIFY(geometricField)
    CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
    NULLIFY(dependentField)
    CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
    NULLIFY(fibreField)
    CALL EquationsSet_FibreFieldExists(equationsSet,fibreField,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(dependentField,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_DimensionGet(coordinateSystem,numberOfDimensions,err,error,*999)
    IF(SIZE(values,1)<numberOfDimensions) THEN
      localError="The size of the first dimension of the supplied values array of "// &
        & TRIM(NumberToVString(SIZE(values,1),"*",err,error))//" is too small. The size must be >= "// &
        & TRIM(NumberToVString(numberOfDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(values,2)<numberOfDimensions) THEN
      localError="The size of the second dimension of the supplied values array of "// &
        & TRIM(NumberToVString(SIZE(values,2),"*",err,error))//" is too small. The size must be >= "// &
        & TRIM(NumberToVString(numberOfDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF    
    NULLIFY(equations)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    NULLIFY(vectorEquations)
    CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
    NULLIFY(vectorMapping)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    NULLIFY(nonlinearMapping)
    CALL EquationsMappingVector_NonlinearMappingGet(vectorMapping,nonlinearMapping,err,error,*999)
    NULLIFY(residualMapping)
    CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,1,residualMapping,err,error,*999)
    NULLIFY(residualVariable)
    CALL EquationsMappingResidual_VariableGet(residualMapping,1,residualVariable,err,error,*999)
    CALL FieldVariable_VariableTypeGet(residualVariable,dependentVarType,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(dependentField,decomposition,err,error,*999)
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(decompositionElements)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementCheckExists(decompositionElements,userElementNumber,userElementExists, &
      & localElementNumber,ghostElement,err,error,*999)
    IF(.NOT.userElementExists) THEN
      localError="The specified user element number of "//TRIM(NumberToVstring(userElementNumber,"*",err,error))// &
        & " does not exist in the decomposition for the dependent field."
      CALL FlagError(localError,err,error,*999)
    END IF    
    NULLIFY(domain)
    CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    NULLIFY(domainElements)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    NULLIFY(elementBasis)
    CALL DomainElements_ElementBasisGet(domainElements,userElementNumber,elementBasis,err,error,*999)
    CALL Basis_NumberOfXiGet(elementBasis,numberOfXi,err,error,*999)

    NULLIFY(equationsInterpolation)
    CALL Equations_InterpolationGet(equations,equationsInterpolation,err,error,*999)
    
    NULLIFY(geometricInterpParameters)
    CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,geometricInterpParameters, &
      & err,error,*999)
    NULLIFY(geometricInterpPoint)
    CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,geometricInterpPoint,err,error,*999)
    NULLIFY(geometricInterpPointMetrics)
    CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
      & geometricInterpPointMetrics,err,error,*999)
    CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,localElementNumber,geometricInterpParameters,err,error,*999)
    
    NULLIFY(dependentInterpParameters)
    CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,dependentVarType,dependentInterpParameters, &
      & err,error,*999)
    NULLIFY(dependentInterpPoint)
    CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,dependentVarType,dependentInterpPoint,err,error,*999)
    NULLIFY(dependentInterpPointMetrics)
    CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,dependentVarType,dependentInterpPointMetrics, &
      & err,error,*999)
    CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,localElementNumber,dependentInterpParameters,err,error,*999)
    
    NULLIFY(fibreInterpParameters)
    NULLIFY(fibreInterpPoint)
    IF(ASSOCIATED(fibreField)) THEN
      CALL EquationsInterpolation_FibreParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,fibreInterpParameters, &
        & err,error,*999)
      CALL EquationsInterpolation_FibrePointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,fibreInterpPoint,err,error,*999)
      CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,localElementNumber,fibreInterpParameters,err,error,*999)
    ENDIF
   
    IF(equationsSet%specification(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE.OR. &
      equationsSet%specification(3)==EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
      CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
        & gaussPointNumber,localElementNumber,1,growthValues(1),err,error,*999)
      IF(numberofDimensions>1) THEN
        CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
          & gaussPointNumber,localElementNumber,2,growthValues(2),err,error,*999)
        IF(numberOfDimensions>2) THEN
          CALL Field_ParameterSetGetLocalGaussPoint(dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
            & gaussPointNumber,localElementNumber,3,growthValues(3),err,error,*999)
        ENDIF
      ENDIF
    ELSE
      growthValues = [1.0_DP,1.0_DP,1.0_DP]
    ENDIF

    !Interpolate fields at xi position
    CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointNumber,dependentInterpPoint, &
      & err,error,*999)
    CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
    CALL Field_interpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointNumber,geometricInterpPoint, &
      & err,error,*999)
    CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)
    IF(ASSOCIATED(fibreField)) &
      & CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointNumber,fibreInterpPoint, &
      & err,error,*999)

    !Calculate material fibre coordinate system
    CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
      & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
      & fibreVectors(1:numberOfDimensions,1:numberOfXi),err,error,*999)
    !Calculate F=dZ/dNU, the deformation gradient tensor at the xi location
    CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
      & dXidNu(1:numberOfXi,1:numberOfDimensions),dZdX,JZ,dZdNu,JZNu,err,error,*999)

    CALL FiniteElasticity_GrowthTensorCalculate(equationsSet,numberOfDimensions,dZdNu,growthValues,Fg,Fe,Jg,Je,err,error,*999)
    
    IF(tensorEvaluateType==EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR .OR. &
      & tensorEvaluateType==EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR) THEN
      CALL MatrixTransposeProduct(Fe(1:numberOfDimensions,1:numberOfXi),Fe(1:numberOfDimensions,1:numberOfXi), &
        & C(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
    ENDIF

    IF(tensorEvaluateType==EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR) THEN
      !Calculate E
      E(1:numberOfDimensions,1:numberOfDimensions)=0.5_DP*C(1:numberOfDimensions,1:numberOfDimensions)
      DO componentIdx=1,numberOfDimensions
        E(componentIdx,componentIdx)=E(componentIdx,componentIdx)-0.5_DP
      ENDDO !componentIdx
    ENDIF

    IF(tensorEvaluateType==EQUATIONS_SET_CAUCHY_STRESS_TENSOR) THEN
      
      NULLIFY(materialsField)
      CALL EquationsSet_MaterialsFieldGet(equationsSet,materialsField,err,error,*999)
      NULLIFY(materialsInterpParameters)
      CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,materialsInterpParameters, &
        & err,error,*999)
      NULLIFY(materialsInterpPoint)
      CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,materialsInterpPoint, &
        & err,error,*999)
      CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,localElementNumber,materialsInterpParameters, &
        & err,error,*999)
      !Interpolate fields at Gauss point
      CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointNumber,materialsInterpPoint, &
        & err,error,*999)

      NULLIFY(independentField)
      NULLIFY(independentInterpParameters)
      NULLIFY(independentInterpPoint)
      CALL EquationsSet_IndependentFieldExists(equationsSet,independentField,err,error,*999)
      IF(ASSOCIATED(independentField)) THEN
        CALL EquationsInterpolation_IndependentParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & independentInterpParameters,err,error,*999)
        CALL EquationsInterpolation_IndependentPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,independentInterpPoint, &
          & err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,localElementNumber,independentInterpParameters, &
          & err,error,*999)
        CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointNumber, &
          & independentInterpPoint,err,error,*999)
      ENDIF
      
!!\TODO the whole stress thing needs to be looked at as the routines below do not take in the deformation gradient that
!! is calculated above but rather they calculate it internally. This will lead to mismatches as things like growth are
!! not taken into account. 
      
      SELECT CASE(equationsSet%specification(3))
      CASE(EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
        !Calculate the Cauchy stress tensor (in Voigt form) at the gauss point.
        CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,dependentJacobian,err,error,*999)
        CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,geometricJacobian,err,error,*999)
        Jznu=dependentJacobian/geometricJacobian
        ! Note that some problems, e.g. active contraction, require additonal fields to be evaluated at Gauss points. This is
        ! currently achieved by providing the gausspoint number to the FiniteElasticity_GaussStressTensor routine.
        ! However, the current  routine, FiniteElasticity_TensorInterpolateXi, aims to evaluate tensors as any xi, so the Gauss
        ! point number has been set to 0, which will generate an error for such problems.
        ! To address such issues, the FiniteElasticity_GaussStressTensor routine needs to be generalized to allow calculation
        ! of stress at any xi position and the GaussPoint number argument needs to be replace with a set of xi coordinates.
        CALL FiniteElasticity_GaussStressTensor(equationsSet,numberOfDimensions,dependentInterpPoint,materialsInterpPoint, &
          & geometricInterpPoint,cauchyStressVoigt,dZdNu,Jznu,localElementNumber,0,err,error,*999)
        
        !Convert from Voigt form to tensor form.
        CALL VoigtToTensor(numberOfDimensions,[TENSOR_CONTRAVARIANT_INDEX],cauchyStressVoigt,cauchyStressTensor,err,error,*999)
        
      CASE(EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE, EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE)
        CALL FiniteElasticity_GaussCauchyTensor(equationsSet,numberOfDimensions,dependentInterpPoint,materialsInterpPoint, &
          & geometricInterpPoint,darcyInterpPoint,independentInterpPoint,localElementNumber,0,dZdNu,Jznu, &
          & cauchyStressTensor,err,error,*999)
      CASE DEFAULT
        CALL FlagError("Not implemented.",err,error,*999)
      END SELECT
    ENDIF

    SELECT CASE(tensorEvaluateType)
    CASE(EQUATIONS_SET_DEFORMATION_GRADIENT_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=dZdNu(1:numberOfDimensions,1:numberOfDimensions)
    CASE(EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=C(1:numberOfDimensions,1:numberOfDimensions)
    CASE(EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=E(1:numberOfDimensions,1:numberOfDimensions)
    CASE(EQUATIONS_SET_CAUCHY_STRESS_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=cauchyStressTensor(1:numberOfDimensions,1:numberOfDimensions)
    CASE(EQUATIONS_SET_SECOND_PK_STRESS_TENSOR)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      CALL FlagError("The tensor evalaute type of "//TRIM(NumberToVString(tensorEvaluateType,"*",err,error))//" is invalid "// &
        & "for finite elasticity equation sets.",err,error,*999)
    END SELECT
 
    EXITS("FiniteElasticity_TensorInterpolateGaussPoint")
    RETURN
999 ERRORS("FiniteElasticity_TensorInterpolateGaussPoint",err,error)
    EXITS("FiniteElasticity_TensorInterpolateGaussPoint")
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_TensorInterpolateGaussPoint

  !
  !================================================================================================================================
  !

  !>Evaluates a tensor at a given element xi location. \TODO merge this with interpolate Gauss above.
  SUBROUTINE FiniteElasticity_TensorInterpolateXi(equationsSet,tensorEvaluateType,userElementNumber,xi,values,err,error,*)
    ! Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set to calculate the tensor for
    INTEGER(INTG), INTENT(IN) :: tensorEvaluateType !<The type of tensor to evaluate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to evaluate the tensor for
    REAL(DP), INTENT(IN) :: xi(:) !<The xi location to evaluate the tensor for.
    REAL(DP), INTENT(OUT) :: values(:,:) !<On exit, the interpolated tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    ! Local variables
    INTEGER(INTG) :: columnComponentIdx,dependentVarType,i,localElementNumber,meshComponentNumber,numberOfDimensions,numberOfXi, &
     & rowComponentIdx
    REAL(DP) :: C(3,3),cauchyStressTensor(3,3),cauchyStressVoigt(6),dependentJacobian,dNudXi(3,3),dXidNu(3,3),dZdNu(3,3), &
      & dZdNuT(3,3),dZdX(3,3),dZdXi(3,3),E(3,3),Fe(3,3),Fg(3,3),fibreVectors(3,3),geometricJacobian,growthValues(3),Je,Jg, &
      & JZ,JZNu,rightCauchyGreen(3,3)
    LOGICAL :: ghostElement,updateJacobian,userElementExists
    TYPE(BasisType), POINTER :: elementBasis
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsInterpolationType), POINTER :: equationsInterpolation
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: dependentField,fibreField,geometricField,independentField,materialsField
    TYPE(FieldInterpolatedPointType), POINTER :: darcyInterpPoint,dependentInterpPoint,fibreInterpPoint,geometricInterpPoint, &
      & growthInterpPoint,independentInterpPoint,materialsInterpPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: dependentInterpPointMetrics,geometricInterpPointMetrics
    TYPE(FieldInterpolationParametersType), POINTER :: dependentInterpParameters,fibreInterpParameters,geometricInterpParameters, &
      & growthInterpParameters,independentInterpParameters,materialsInterpParameters
    TYPE(FieldVariableType), POINTER :: growthVariable,residualVariable

    ENTERS("FiniteElasticity_TensorInterpolateXi",err,error,*999)

    NULLIFY(coordinateSystem)
    CALL EquationsSet_CoordinateSystemGet(equationsSet,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_DimensionGet(coordinateSystem,numberOfDimensions,err,error,*999)
    
    NULLIFY(equations)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    NULLIFY(vectorEquations)
    CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
    NULLIFY(vectorMapping)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    NULLIFY(nonlinearMapping)
    CALL EquationsMappingVector_NonlinearMappingGet(vectorMapping,nonlinearMapping,err,error,*999)
    NULLIFY(residualMapping)
    CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,1,residualMapping,err,error,*999)
    NULLIFY(residualVariable)
    CALL EquationsMappingResidual_VariableGet(residualMapping,1,residualVariable,err,error,*999)
    CALL FieldVariable_VariableTypeGet(residualVariable,dependentVarType,err,error,*999)

    NULLIFY(dependentField)
    CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(dependentField,decomposition,err,error,*999)
    CALL Decomposition_MeshComponentNumberGet(decomposition,meshComponentNumber,err,error,*999)
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(decompositionElements)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_LocalNumberGet(decompositionElements,userElementNumber,localElementNumber,ghostElement, &
      & err,error,*999)
    NULLIFY(domain)
    CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    NULLIFY(domainElements)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    NULLIFY(elementBasis)
    CALL DomainElements_ElementBasisGet(domainElements,localElementNumber,elementBasis,err,error,*999)
    CALL Basis_NumberOfXiGet(elementBasis,numberOfXi,err,error,*999)

    !Get the interpolation parameters for this element
    NULLIFY(equationsInterpolation)
    CALL Equations_InterpolationGet(equations,equationsInterpolation,err,error,*999)

    NULLIFY(geometricField)
    CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
    NULLIFY(geometricInterpParameters)
    CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,geometricInterpParameters, &
      & err,error,*999)
    NULLIFY(geometricInterpPoint)
    CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,geometricInterpPoint,err,error,*999)
    NULLIFY(geometricInterpPointMetrics)
    CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
      & geometricInterpPointMetrics,err,error,*999)
    CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,localElementNumber,geometricInterpParameters,err,error,*999)

    NULLIFY(dependentInterpParameters)
    CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,dependentVarType,dependentInterpParameters, &
      & err,error,*999)
    NULLIFY(dependentInterpPoint)
    CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,dependentVarType,dependentInterpPoint,err,error,*999)
    NULLIFY(dependentInterpPointMetrics)
    CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,dependentVarType,dependentInterpPointMetrics, &
      & err,error,*999)
    CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,localElementNumber,dependentInterpParameters,err,error,*999)

    NULLIFY(fibreField)
    CALL EquationsSet_FibreFieldExists(equationsSet,fibreField,err,error,*999)
    NULLIFY(fibreInterpParameters)
    NULLIFY(fibreInterpPoint)
    IF(ASSOCIATED(fibreField)) THEN
      CALL EquationsInterpolation_FibreParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,fibreInterpParameters, &
        & err,error,*999)
      CALL EquationsInterpolation_FibrePointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,fibreInterpPoint,err,error,*999)
      CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,localElementNumber,fibreInterpParameters,err,error,*999)
    ENDIF

    NULLIFY(growthVariable)
    NULLIFY(growthInterpParameters)
    NULLIFY(growthInterpPoint)
    IF(equationsSet%specification(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE.OR. &
      equationsSet%specification(3)==EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
      CALL Field_VariableGet(dependentField,FIELD_U3_VARIABLE_TYPE,growthVariable,err,error,*999)
      CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,FIELD_U3_VARIABLE_TYPE,growthInterpParameters, &
        & err,error,*999)
      CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,FIELD_U3_VARIABLE_TYPE,growthInterpPoint, &
        & err,error,*999)
      CALL Field_InterpolateXi(NO_PART_DERIV,xi,growthInterpPoint,err,error,*999)
      growthValues(1:numberOfDimensions)=growthInterpPoint%values(1:numberOfDimensions,NO_PART_DERIV)
    ELSE
      growthValues = [1.0_DP,1.0_DP,1.0_DP]
    ENDIF
    
    !Interpolate fields at xi position
    CALL Field_InterpolateXi(FIRST_PART_DERIV,xi,geometricInterpPoint,err,error,*999)
    CALL Field_InterpolateXi(FIRST_PART_DERIV,xi,dependentInterpPoint,err,error,*999)
    IF(ASSOCIATED(fibreField)) CALL Field_InterpolateXi(NO_PART_DERIV,xi,fibreInterpPoint,err,error,*999)

    !Calculate field metrics
    CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,geometricInterpPointMetrics,err,error,*999)
    CALL Field_InterpolatedPointMetricsCalculate(numberOfXi,dependentInterpPointMetrics,err,error,*999)

    !Calculate material fibre coordinate system
    CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
      & dNudXi(1:numberOfDimensions,1:numberOfXi),dXidNu(1:numberOfXi,1:numberOfDimensions), &
      & fibreVectors(1:numberOfDimensions,1:numberOfXi),err,error,*999)
    !Calculate F=dZ/dNU, the deformation gradient tensor at the xi location
    CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
      & dXidNu(1:numberOfXi,1:numberOfDimensions),dZdX(1:numberOfDimensions,1:numberOfDimensions),JZ, &
      & dZdNu(1:numberOfDimensions,1:numberOfDimensions),JZNu,err,error,*999)

    CALL FiniteElasticity_GrowthTensorCalculate(equationsSet,numberOfDimensions,dZdNu,growthValues,Fg,Fe,Jg,Je,err,error,*999)
    
    IF(tensorEvaluateType==EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR .OR. &
      & tensorEvaluateType==EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR) THEN
      CALL MatrixTransposeProduct(Fe(1:numberOfDimensions,1:numberOfXi),Fe(1:numberOfDimensions,1:numberOfXi), &
        & C(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
    ENDIF

    IF(tensorEvaluateType==EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR) THEN
      !Calculate E
      E(1:numberOfDimensions,1:numberOfDimensions)=0.5_DP*rightCauchyGreen(1:numberOfDimensions,1:numberOfDimensions)
      DO rowComponentIdx=1,numberOfDimensions
        E(rowComponentIdx,rowComponentIdx)=E(rowComponentIdx,rowComponentIdx)-0.5_DP
      ENDDO !rowComponentIdx
    ENDIF

    IF(tensorEvaluateType==EQUATIONS_SET_CAUCHY_STRESS_TENSOR) THEN
      
      !Get the interpolation parameters for this element
      NULLIFY(materialsField)
      CALL EquationsSet_MaterialsFieldGet(equationsSet,materialsField,err,error,*999)
      NULLIFY(materialsInterpParameters)
      CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,materialsInterpParameters, &
        & err,error,*999)
      NULLIFY(materialsInterpPoint)
      CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,materialsInterpPoint, &
        & err,error,*999)
      CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,localElementNumber,materialsInterpParameters, &
        & err,error,*999)
      !Interpolate fields at xi location
      CALL Field_InterpolateXi(NO_PART_DERIV,xi,materialsInterpPoint,err,error,*999)

      NULLIFY(independentField)
      NULLIFY(independentInterpParameters)
      NULLIFY(independentInterpPoint)
      CALL EquationsSet_IndependentFieldExists(equationsSet,independentField,err,error,*999)
      IF(ASSOCIATED(independentField)) THEN
        CALL EquationsInterpolation_IndependentParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & independentInterpParameters,err,error,*999)
        CALL EquationsInterpolation_IndependentPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,independentInterpPoint, &
          & err,error,*999)
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,localElementNumber,independentInterpParameters, &
          & err,error,*999)
        CALL Field_InterpolateXi(FIRST_PART_DERIV,xi,independentInterpPoint,err,error,*999)
      ENDIF
      
      SELECT CASE(equationsSet%specification(3))
      CASE(EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
        !Calculate the Cauchy stress tensor (in Voigt form) at the gauss point.
        CALL FieldInterpolatedPointMetrics_JacobianGet(dependentInterpPointMetrics,dependentJacobian,err,error,*999)
        CALL FieldInterpolatedPointMetrics_JacobianGet(geometricInterpPointMetrics,geometricJacobian,err,error,*999)
        Jznu=dependentJacobian/geometricJacobian
        ! Note that some problems, e.g. active contraction, require additonal fields to be evaluated at Gauss points. This is
        ! currently achieved by providing the gausspoint number to the FiniteElasticity_GaussStressTensor routine.
        ! However, the current  routine, FiniteElasticity_TensorInterpolateXi, aims to evaluate tensors as any xi, so the Gauss
        ! point number has been set to 0, which will generate an error for such problems.
        ! To address such issues, the FiniteElasticity_GaussStressTensor routine needs to be generalized to allow calculation
        ! of stress at any xi position and the GaussPoint number argument needs to be replace with a set of xi coordinates.
        CALL FiniteElasticity_GaussStressTensor(equationsSet,numberOfDimensions,dependentInterpPoint,materialsInterpPoint, &
          & geometricInterpPoint,cauchyStressVoigt,dZdNu,Jznu,localElementNumber,0,err,error,*999)
        
        !Convert from Voigt form to tensor form.
        CALL VoigtToTensor(numberOfDimensions,[TENSOR_CONTRAVARIANT_INDEX],cauchyStressVoigt,cauchyStressTensor,err,error,*999)
       
      CASE(EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE, EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE)
        CALL FiniteElasticity_GaussCauchyTensor(equationsSet,numberOfDimensions,dependentInterpPoint,materialsInterpPoint, &
          & geometricInterpPoint,darcyInterpPoint,independentInterpPoint, &
          & localElementNumber,0,dZdNu,Jznu,cauchyStressTensor,err,error,*999)
      CASE DEFAULT
        CALL FlagError("Not implemented.",err,error,*999)
      END SELECT
    ENDIF

    SELECT CASE(tensorEvaluateType)
    CASE(EQUATIONS_SET_DEFORMATION_GRADIENT_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=dZdNu(1:numberOfDimensions,1:numberOfDimensions)
    CASE(EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=C(1:numberOfDimensions,1:numberOfDimensions)
    CASE(EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=E(1:numberOfDimensions,1:numberOfDimensions)
    CASE(EQUATIONS_SET_CAUCHY_STRESS_TENSOR)
      values(1:numberOfDimensions,1:numberOfDimensions)=cauchyStressTensor(1:numberOfDimensions,1:numberOfDimensions)
    CASE(EQUATIONS_SET_SECOND_PK_STRESS_TENSOR)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      CALL FlagError("The tensor evalaute type of "//TRIM(NumberToVString(tensorEvaluateType,"*",err,error))//" is invalid "// &
        & "for finite elasticity equation sets.",err,error,*999)
    END SELECT

    EXITS("FiniteElasticity_TensorInterpolateXi")
    RETURN
999 ERRORSEXITS("FiniteElasticity_TensorInterpolateXi",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_TensorInterpolateXi

  !
  !================================================================================================================================
  !

  !>Evaluates the Jacobian surface traction (pressure) term of the equilibrium equation. Here it is assumed that pressure is
  !>constant. (if not: the jacobian has to be extended to include this) and that along the boundary of the boundary faces
  !>(the boundary line) minimal one direction perpendicular to that boundary line is fixed, or that we have no boundary line
  !>at all (a closed body). In these cases the jacobian is symmetrical.
  !>See Rumpel & Schweizerhof, "Hydrostatic fluid loading in non-linear finite element !analysis".
  SUBROUTINE FiniteElasticity_SurfacePressureJacobianEvaluate(equationsSet,elementNumber,err,error,*)
    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: elementNumber
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    INTEGER(INTG) :: columnComponentIdx,columnElementBaseDOFIndex(3),columnElementDOFIdx,columnElementParameter, &
      & columnElementParameterIdx,dependentScalingType,dependentVariableType,elementBaseDOFIndex(3),equationsSetSubtype, &
      & faceNumber,fieldVarUType,fieldVardUdnType,gaussPointIdx,localFaceIdx,meshComponentNumber, &
      & numberOfDependentFaceParameters(3),numberOfDimensions,numberOfElementParameters,numberOfFaceParameters(3), &
      & numberOfGauss,numberOfLocalFaces,numberOfRowFaceParameters(3),oh,orientation,rhsVariableType,rowComponentIdx, &
      & rowElementDOFIdx,rowElementBaseDOFIndex(3),rowElementParameter,rowElementParameterIdx,rowsVariableType, &
      & sumElementParameters,xiDirection(3)
    INTEGER(INTG), PARAMETER :: numberOffDiagComponents(3)=[0,1,3],offDiagComponent1(3)=[1,1,2],offDiagComponent2(3)=[2,3,3]
    REAL(DP) :: gaussWeight,normal(3),pressureGauss,pressureGaussWeight,pressureGaussWeightW(2),temp3,temp4,tempvec1(2), &
      & tempvec2(2),tempvec3(3),tempvec4(3),tempvec5(3)
    LOGICAL :: boundaryFace,nonzeroPressure,updateJacobian
    TYPE(BasisType), POINTER :: basis,columnBasis,columnFaceBasis,dependentFaceBasis,rowFaceBasis
    TYPE(BasisPtrType) :: columnBases(3),bases(3),rowBases(3)
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionFacesType), POINTER :: decompositionFaces
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: columnDomain,domain,rowDomain
    TYPE(DomainElementsType), POINTER :: columnDomainElements,domainElements,rowDomainElements
    TYPE(DomainFacesType), POINTER :: columnDomainFaces,domainFaces,rowDomainFaces
    TYPE(DomainTopologyType), POINTER :: columnDomainTopology,domainTopology,rowDomainTopology
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsInterpolationType), POINTER :: equationsInterpolation
    TYPE(EquationsMappingLHSType), POINTER :: lhsMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingRHSType), POINTER :: rhsMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: dependentField
    TYPE(FieldInterpolatedPointType), POINTER :: dependentInterpPoint,pressureInterpPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: dependentInterpPointMetrics
    TYPE(FieldInterpolationParametersType), POINTER :: dependentInterpParameters,pressureInterpParameters,rowInterpParameters
    TYPE(FieldVariableType), POINTER :: dependentVariable,fieldVariable,residualVariable,rhsVariable,rowsVariable
    TYPE(JacobianMatrixType), POINTER :: jacobianMatrix
    TYPE(QuadratureSchemeType), POINTER :: dependentQuadratureScheme
    TYPE(QuadratureSchemePtrType) :: columnQuadratureSchemes(3),quadratureSchemes(3),rowQuadratureSchemes(3)

    ENTERS("FiniteElasticity_SurfacePressureJacobianEvaluate",err,error,*999)

    NULLIFY(equations)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    NULLIFY(vectorEquations)
    CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
    NULLIFY(vectorMatrices)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    NULLIFY(nonlinearMatrices)
    CALL EquationsMatricesVector_NonlinearMatricesGet(vectorMatrices,nonlinearMatrices,err,error,*999)
!!TODO: SHOULD LOOP OVER ALL RESIDUALS AND ALL JACOBIANS    
    NULLIFY(residualVector)
    CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,1,residualVector,err,error,*999)
    NULLIFY(jacobianMatrix)
    CALL EquationsMatricesResidual_JacobianMatrixGet(residualVector,1,jacobianMatrix,err,error,*999)
    CALL JacobianMatrix_UpdateMatrixGet(jacobianMatrix,updateJacobian,err,error,*999)
    
    IF(updateJacobian) THEN
      
      NULLIFY(coordinateSystem)
      CALL EquationsSet_CoordinateSystemGet(equationsSet,coordinateSystem,err,error,*999)
      CALL CoordinateSystem_DimensionGet(coordinateSystem,numberOfDimensions,err,error,*999)

      NULLIFY(dependentField)
      CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(dependentField,decomposition,err,error,*999)
      NULLIFY(decompositionTopology)
      CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
      NULLIFY(decompositionElements)
      CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
      NULLIFY(decompositionFaces)
      CALL DecompositionTopology_DecompositionFacesGet(decompositionTopology,decompositionFaces,err,error,*999)
      NULLIFY(domain)
      CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      NULLIFY(basis)
      CALL DomainElements_ElementBasisGet(domainElements,elementNumber,basis,err,error,*999)
      CALL Basis_NumberOfLocalFacesGet(basis,numberOfLocalFaces,err,error,*999)
      NULLIFY(domainFaces)
      CALL DomainTopology_DomainFacesGet(domainTopology,domainFaces,err,error,*999)

      NULLIFY(vectorMapping)
      CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
      NULLIFY(lhsMapping)
      CALL EquationsMappingVector_LHSMappingGet(vectorMapping,lhsMapping,err,error,*999)
      NULLIFY(rowsVariable)
      CALL EquationsMappingLHS_LHSVariableGet(lhsMapping,rowsVariable,err,error,*999)
      CALL FieldVariable_VariableTypeGet(rowsVariable,rowsVariableType,err,error,*999)
      NULLIFY(nonlinearMapping)
      CALL EquationsMappingVector_NonlinearMappingGet(vectorMapping,nonlinearMapping,err,error,*999)
      NULLIFY(residualMapping)
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,1,residualMapping,err,error,*999)
      NULLIFY(residualVariable)
      CALL EquationsMappingResidual_VariableGet(residualMapping,1,residualVariable,err,error,*999)
      CALL FieldVariable_VariableTypeGet(residualVariable,fieldVarUType,err,error,*999)
      NULLIFY(dependentVariable)
      CALL EquationsMappingResidual_JacobianMatrixVariableGet(residualMapping,1,dependentVariable,err,error,*999)
      CALL FieldVariable_VariableTypeGet(dependentVariable,dependentVariableType,err,error,*999)
      NULLIFY(rhsMapping)
      CALL EquationsMappingVector_RHSMappingGet(vectorMapping,rhsMapping,err,error,*999)
      NULLIFY(rhsVariable)
      CALL EquationsMappingRHS_RHSVariableGet(rhsMapping,rhsVariable,err,error,*999)
      CALL FieldVariable_VariableTypeGet(rhsVariable,rhsVariableType,err,error,*999)

      NULLIFY(equationsInterpolation)
      CALL Equations_InterpolationGet(equations,equationsInterpolation,err,error,*999)
      NULLIFY(dependentInterpParameters)
      CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,dependentVariableType,dependentInterpParameters, &
        & err,error,*999)
      NULLIFY(dependentInterpPoint)
      CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,dependentVariableType,dependentInterpPoint, &
        & err,error,*999)
      NULLIFY(dependentInterpPointMetrics)
      CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,dependentVariableType, &
        & dependentInterpPointMetrics,err,error,*999)
!!TODO: why is pressure using the delUdeln variable??? It should be an independent variable
      NULLIFY(pressureInterpParameters)
      CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,rhsVariableType,pressureInterpParameters, &
        & err,error,*999)
      NULLIFY(pressureInterpPoint)
      CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,rhsVariableType,pressureInterpPoint,err,error,*999)

      !Surface pressure term calculation: Loop over all faces
      DO localFaceIdx=1,numberOfLocalFaces
        
        CALL DecompositionElements_ElementFaceNumberGet(decompositionElements,localFaceIdx,elementNumber,faceNumber,err,error,*999)
        CALL DecompositionFaces_FaceBoundaryFaceGet(decompositionFaces,faceNumber,boundaryFace,err,error,*999)
        
        !Check if it's a boundary face
        IF(boundaryFace) THEN
          CALL DecompositionFaces_FaceXiNormalDirectionGet(decompositionFaces,faceNumber,xiDirection(3),err,error,*999)

          CALL Field_InterpolationParametersFaceGet(FIELD_PRESSURE_VALUES_SET_TYPE,faceNumber,pressureInterpParameters, &
            & err,error,*999,FIELD_GEOMETRIC_COMPONENTS_TYPE)

          !Check if nonzero surface pressure is defined on the face
          nonzeroPressure=ANY(ABS(pressureInterpParameters%parameters(:,xiDirection(3)))>ZERO_TOLERANCE)
          
          !Nonzero surface pressure found?
          IF(nonzeroPressure) THEN
            NULLIFY(dependentFaceBasis)
            CALL DomainFaces_FaceBasisGet(domainFaces,faceNumber,dependentFaceBasis,err,error,*999)
            NULLIFY(dependentQuadratureScheme)
            CALL Basis_QuadratureSchemeGet(dependentFaceBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,dependentQuadratureScheme, &
              & err,error,*999)

            CALL Field_InterpolationParametersFaceGet(FIELD_VALUES_SET_TYPE,faceNumber,dependentInterpParameters, &
              & err,error,*999,FIELD_GEOMETRIC_COMPONENTS_TYPE)

            sumElementParameters=0
            !Loop over geometric dependent basis functions.
            DO rowComponentIdx=1,numberOfDimensions
              NULLIFY(rowDomain)
              CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
              NULLIFY(rowDomainTopology)
              CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
              NULLIFY(rowDomainFaces)
              CALL DomainTopology_DomainFacesGet(rowDomainTopology,rowDomainFaces,err,error,*999)
              NULLIFY(rowDomainElements)
              CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
              NULLIFY(rowFaceBasis)
              CALL DomainFaces_FaceBasisGet(rowDomainFaces,faceNumber,rowFaceBasis,err,error,*999)
              NULLIFY(rowBases(rowComponentIdx)%ptr)
              CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBases(rowComponentIdx)%ptr, &
                & err,error,*999)
              NULLIFY(rowQuadratureSchemes(columnComponentIdx)%ptr)
              CALL Basis_QuadratureSchemeGet(rowFaceBasis,BASIS_DEFAULT_QUADRATURE_SCHEME, &
                & rowQuadratureSchemes(rowComponentIdx)%ptr,err,error,*999)
              CALL Basis_NumberOfElementParametersGet(rowFaceBasis,numberOfRowFaceParameters(rowComponentIdx),err,error,*999)
              CALL Basis_NumberOfElementParametersGet(rowBases(rowComponentIdx)%ptr,numberOfElementParameters,err,error,*999)
              rowElementBaseDOFIndex(columnComponentIdx)=sumElementParameters
              sumElementParameters=sumElementParameters+numberOfElementParameters
            ENDDO !rowComponentIdx
            DO columnComponentIdx=1,numberOfDimensions
              NULLIFY(columnDomain)
              CALL FieldVariable_ComponentDomainGet(dependentVariable,columnComponentIdx,columnDomain,err,error,*999)
              NULLIFY(columnDomainTopology)
              CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
              NULLIFY(columnDomainFaces)
              CALL DomainTopology_DomainFacesGet(columnDomainTopology,columnDomainFaces,err,error,*999)
              NULLIFY(columnDomainElements)
              CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
              NULLIFY(columnFaceBasis)
              CALL DomainFaces_FaceBasisGet(columnDomainFaces,faceNumber,columnFaceBasis,err,error,*999)
              NULLIFY(columnBases(columnComponentIdx)%ptr)
              CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,columnBases(columnComponentIdx)%ptr, &
                & err,error,*999)
              NULLIFY(columnQuadratureSchemes(columnComponentIdx)%ptr)
              CALL Basis_QuadratureSchemeGet(columnFaceBasis,BASIS_DEFAULT_QUADRATURE_SCHEME, &
                & columnQuadratureSchemes(columnComponentIdx)%ptr,err,error,*999)
              CALL Basis_NumberOfElementParametersGet(columnFaceBasis,numberOfDependentFaceParameters(columnComponentIdx), &
                & err,error,*999)
              CALL Basis_NumberOfElementParametersGet(columnBases(columnComponentIdx)%ptr,numberOfElementParameters,err,error,*999)
              columnElementBaseDOFIndex(columnComponentIdx)=sumElementParameters
              sumElementParameters=sumElementParameters+numberOfElementParameters
            ENDDO !columnComponentIdx

            xiDirection(1)=OTHER_XI_DIRECTIONS3(xiDirection(3),2,1)
            xiDirection(2)=OTHER_XI_DIRECTIONS3(xiDirection(3),3,1)
            orientation=SIGN(1,OTHER_XI_ORIENTATIONS3(xiDirection(1),xiDirection(2))*xiDirection(3))

            !Loop over all Gauss points
            CALL BasisQuadratureScheme_NumberOfGaussGet(dependentQuadratureScheme,numberOfGauss,err,error,*999)
            DO gaussPointIdx=1,numberOfGauss
              
              CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)
              
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,pressureInterpPoint, &
                & err,error,*999,FIELD_GEOMETRIC_COMPONENTS_TYPE)
              CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
                & err,error,*999,FIELD_GEOMETRIC_COMPONENTS_TYPE)
              CALL Field_InterpolatedPointMetricsCalculate(COORDINATE_JACOBIAN_AREA_TYPE,dependentInterpPointMetrics, &
                & err,error,*999)
              
              CALL CrossProduct(dependentInterpPointMetrics%dXdXi(:,1),dependentInterpPointMetrics%dXdXi(:,2),normal, &
                & err,error,*999)
              pressureGauss=pressureInterpPoint%values(xiDirection(3),NO_PART_DERIV)*orientation
              pressureGaussWeight=gaussWeight*pressureGauss

              DO oh=1,numberOffDiagComponents(numberOfDimensions)
                columnComponentIdx=offDiagComponent1(oh)
                rowComponentIdx=offDiagComponent2(oh)
                pressureGaussWeightW(1:2)=(normal(rowComponentIdx)*dependentInterpPointMetrics%dXidX(1:2,columnComponentIdx)- &
                  & dependentInterpPointMetrics%dXidX(1:2,rowComponentIdx)*normal(columnComponentIdx))*pressureGaussWeight
                DO columnElementParameterIdx=1,numberOfDependentFaceParameters(columnComponentIdx)
                  !Loop over element rows belonging to geometric dependent variables
                  CALL Basis_FaceElementParameterGet(columnBases(columnComponentIdx)%ptr,columnElementParameterIdx,localFaceIdx, &
                    & columnElementParameter,err,error,*999)
                  columnElementDOFIdx=columnElementBaseDOFIndex(columnComponentIdx)+columnElementParameter
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureSchemes(columnComponentIdx)%ptr, &
                    & columnElementParameterIdx,PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(1),gaussPointIdx,tempvec1(1), &
                    & err,error,*999)
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureSchemes(columnComponentIdx)%ptr, &
                    & columnElementParameterIdx,PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(2),gaussPointIdx,tempvec1(2), &
                    & err,error,*999)
                  tempvec1(1:2)=tempvec1(1:2)*pressureGaussWeightW(1:2)
                  DO rowElementParameterIdx=1,numberOfRowFaceParameters(rowComponentIdx)
                    CALL Basis_FaceElementParameterGet(rowBases(rowComponentIdx)%ptr,rowElementParameterIdx,localFaceIdx, &
                      & rowElementParameter,err,error,*999)
                    rowElementDOFIdx=rowElementBaseDOFIndex(rowComponentIdx)+rowElementParameter
                    CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowQuadratureSchemes(rowComponentIdx)%ptr, &
                      & rowElementParameterIdx,NO_PART_DERIV,gaussPointIdx,tempvec2(1),err,error,*999)
                    tempvec2(2)=tempvec2(1)
                    jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                      & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)+ &
                      & DOT_PRODUCT(tempvec1,tempvec2)
                  ENDDO !rowElementParameterIdx
                ENDDO !columnElementParameterIdx
              ENDDO !oh

              DO oh=1,numberOffDiagComponents(numberOfDimensions)
                columnComponentIdx=offDiagComponent1(oh)
                rowComponentIdx=offDiagComponent2(oh)
                pressureGaussWeightW(1:2)=(normal(columnComponentIdx)*dependentInterpPointMetrics%dXidX(1:2,rowComponentIdx)- &
                  & dependentInterpPointMetrics%dXidX(1:2,columnComponentIdx)*normal(rowComponentIdx))*pressureGaussWeight
                DO rowElementParameterIdx=1,numberOfRowFaceParameters(rowComponentIdx)
                  !Loop over element rows belonging to geometric dependent variables
                  CALL Basis_FaceElementParameterGet(rowBases(rowComponentIdx)%ptr,rowElementParameterIdx,localFaceIdx, &
                    & rowElementParameter,err,error,*999)
                  rowElementDOFIdx=rowElementBaseDOFIndex(rowComponentIdx)+rowElementParameter
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowQuadratureSchemes(rowComponentIdx)%ptr, &
                    & rowElementParameterIdx,PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(1),gaussPointIdx,tempvec1(1), &
                    & err,error,*999)
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowQuadratureSchemes(rowComponentIdx)%ptr, &
                    & rowElementParameterIdx,PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(2),gaussPointIdx,tempvec1(2), &
                    & err,error,*999)
                  tempvec1(1:2)=tempvec1(1:2)*pressureGaussWeightW(1:2)
                  DO columnElementParameterIdx=1,numberOfDependentFaceParameters(columnComponentIdx)
                    CALL Basis_FaceElementParameterGet(columnBases(columnComponentIdx)%ptr,columnElementParameterIdx,localFaceIdx, &
                      & columnElementParameter,err,error,*999)
                    columnElementDOFIdx=columnElementBaseDOFIndex(columnComponentIdx)+columnElementParameter
                    CALL BasisQuadratureScheme_GaussBasisFunctionGet(columnQuadratureSchemes(columnComponentIdx)%ptr, &
                      & columnElementParameterIdx,NO_PART_DERIV,gaussPointIdx,tempvec2(1),err,error,*999)
                    tempvec2(2)=tempvec2(1)
                    jacobianMatrix%elementJacobian%matrix(columnElementDOFIdx,rowElementDOFIdx)= &
                      & jacobianMatrix%elementJacobian%matrix(columnElementDOFIdx,rowElementDOFIdx)+ &
                      & DOT_PRODUCT(tempvec1,tempvec2)
                  ENDDO !columnElementParameterIdx
                ENDDO !rowElementParameterIdx
              ENDDO !oh
            ENDDO !gaussPointIdx

            CALL Field_ScalingTypeGet(dependentField,dependentScalingType,err,error,*999)
            IF(dependentScalingType/=FIELD_NO_SCALING) THEN
              NULLIFY(rowInterpParameters)
              CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,rowsVariableType,rowInterpParameters, &
                & err,error,*999)
              NULLIFY(dependentInterpParameters)
              CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,dependentVariableType, &
                & dependentInterpParameters,err,error,*999)
              CALL Field_InterpolationParametersScaleFactorsFaceGet(faceNumber,rowInterpParameters,err,error,*999)
              CALL Field_InterpolationParametersScaleFactorsFaceGet(faceNumber,dependentInterpParameters,err,error,*999)
              
              DO oh=1,numberOffDiagComponents(numberOfDimensions)
                columnComponentIdx=offDiagComponent1(oh)
                rowComponentIdx=offDiagComponent2(oh)
                DO columnElementParameterIdx=1,numberOfDependentFaceParameters(columnComponentIdx)
                  CALL Basis_FaceElementParameterGet(columnBases(columnComponentIdx)%ptr,columnElementParameterIdx,localFaceIdx, &
                    & columnElementParameter,err,error,*999)
                  columnElementDOFIdx=columnElementBaseDOFIndex(columnComponentIdx)+columnElementParameter
                  DO rowElementParameterIdx=1,numberOfRowFaceParameters(rowComponentIdx)
                    CALL Basis_FaceElementParameterGet(rowBases(rowComponentIdx)%ptr,rowElementParameterIdx,localFaceIdx, &
                      & rowElementParameter,err,error,*999)
                    rowElementDOFIdx=rowElementBaseDOFIndex(rowComponentIdx)+rowElementParameter
                    jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)= &
                      & jacobianMatrix%elementJacobian%matrix(rowElementDOFIdx,columnElementDOFIdx)* &
                      & rowInterpParameters%scaleFactors(rowElementParameterIdx,rowComponentIdx)* &
                      & dependentInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
                  ENDDO !rowElementParameterIdx
                ENDDO !columnElementParameterIdx
              ENDDO !oh
              DO oh=1,numberOffDiagComponents(numberOfDimensions)
                columnComponentIdx=offDiagComponent1(oh)
                rowComponentIdx=offDiagComponent2(oh)
                DO rowElementParameterIdx=1,numberOfRowFaceParameters(rowComponentIdx)
                  !Loop over element rows belonging to geometric dependent variables
                  CALL Basis_FaceElementParameterGet(rowBases(rowComponentIdx)%ptr,rowElementParameterIdx,localFaceIdx, &
                    & rowElementParameter,err,error,*999)
                  rowElementDOFIdx=rowElementBaseDOFIndex(rowComponentIdx)+rowElementParameter
                  DO columnElementParameterIdx=1,numberOfDependentFaceParameters(columnComponentIdx)
                    CALL Basis_FaceElementParameterGet(columnBases(columnComponentIdx)%ptr,columnElementParameterIdx,localFaceIdx, &
                      & columnElementParameter,err,error,*999)
                    columnElementDOFIdx=columnElementBaseDOFIndex(columnComponentIdx)+columnElementParameter
                    jacobianMatrix%elementJacobian%matrix(columnElementDOFIdx,rowElementDOFIdx)= &
                      & jacobianMatrix%elementJacobian%matrix(columnElementDOFIdx,rowElementDOFIdx)* &
                      & rowInterpParameters%scaleFactors(rowElementParameterIdx,rowComponentIdx)* &
                      & dependentInterpParameters%scaleFactors(columnElementParameterIdx,columnComponentIdx)
                  ENDDO !columnElementParameterIdx
                ENDDO !rowElementParameterIdx
              ENDDO !oh              
            ENDIF !scaling
           
          ENDIF !Non-zero pressure on face
        ENDIF !Boundary face
      ENDDO !localFaceIdx
    ENDIF !update

    EXITS("FiniteElasticity_SurfacePressureJacobianEvaluate")
    RETURN
999 ERRORS("FiniteElasticity_SurfacePressureJacobianEvaluate",err,error)
    EXITS("FiniteElasticity_SurfacePressureJacobianEvaluate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_SurfacePressureJacobianEvaluate

  !
  !================================================================================================================================
  !

  !>Evaluates the surface traction (pressure) term of the equilibrium equation
  SUBROUTINE FiniteElasticity_SurfacePressureResidualEvaluate(equationsSet,elementNumber,var1,var2,err,error,*)
    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: elementNumber
    INTEGER(INTG), INTENT(IN) :: var1 !<'U' variable number in single-physics case
    INTEGER(INTG), INTENT(IN) :: var2 !<'DELUDELN' variable number in single-physics case
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    INTEGER(INTG) :: componentIdx,elementBaseDOFIdx,elementDOFIdx,elementFaceIdx,equationsSetSubtype,esSpecification(3), &
      & faceElementParameter,faceNumber,faceParameterIdx,fieldUVariableType,fielddUdnVariableType,gaussPointIdx,localFaceIdx, &
      & meshComponentNumber,numberOfDimensions,numberOfElementParameters,numberOfGauss,numberOfLocalFaces, &
      & numberOfRowFaceParameters,orientation,parameterIdx,residualVariableType,rhsVariableType,rowComponentIdx, &
      & rowElementDOFIdx,rowsVariableType,xiDirection(3)
    REAL(DP) :: gaussWeight,gwPressure,gwPressureNormalComponent,normal(3),pressureGauss,pressureGaussWeight, &
      & pressureGWNormalComponent,rowPhi
    LOGICAL :: boundaryFace,nonzeroPressure,updateResidual
    TYPE(BasisType), POINTER :: basis,componentBasis,componentFaceBasis,dependentFaceBasis,rowBasis,rowFaceBasis
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionFacesType), POINTER :: decompositionFaces
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain,rowDomain
    TYPE(DomainElementsType), POINTER :: domainElements,rowDomainElements
    TYPE(DomainFacesType), POINTER :: domainFaces,rowDomainFaces
    TYPE(DomainTopologyType), POINTER :: domainTopology,rowDomainTopology
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsInterpolationType), POINTER :: equationsInterpolation
    TYPE(EquationsMappingLHSType), POINTER :: lhsMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingRHSType), POINTER :: rhsMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: dependentField
    TYPE(FieldInterpolatedPointType), POINTER :: dependentInterpPoint,faceDependentInterpPoint,pressureInterpPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: dependentInterpPointMetrics,faceDependentInterpPointMetrics, &
      & facePressureInterpPoint
    TYPE(FieldInterpolationParametersType), POINTER :: dependentInterpParameters,faceDependentInterpParameters, &
      & facePressureInterpParameters,pressureInterpParameters
    TYPE(FieldVariableType), POINTER :: residualVariable,rhsVariable,rowsVariable
    TYPE(QuadratureSchemeType), POINTER :: componentFaceQuadratureScheme,dependentQuadratureScheme,faceQuadratureScheme, &
      & rowQuadratureScheme

    ENTERS("FiniteElasticity_SurfacePressureResidualEvaluate",err,error,*999)

!!TODO: THE VAR1 AND VAR2 ARGUMENTS ARE NOT USED
    
    NULLIFY(equations)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    NULLIFY(vectorEquations)
    CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
    NULLIFY(vectorMatrices)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    NULLIFY(nonlinearMatrices)
    CALL EquationsMatricesVector_NonlinearMatricesGet(vectorMatrices,nonlinearMatrices,err,error,*999)
!!TODO: SHOULD LOOP OVER ALL RESIDUALS AND ALL JACOBIANS    
    NULLIFY(residualVector)
    CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,1,residualVector,err,error,*999)
    CALL EquationsMatricesResidual_UpdateVectorGet(residualVector,updateResidual,err,error,*999)

    IF(updateResidual) THEN

      CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)
      equationsSetSubtype=esSpecification(3)
      
      NULLIFY(coordinateSystem)
      CALL EquationsSet_CoordinateSystemGet(equationsSet,coordinateSystem,err,error,*999)
      CALL CoordinateSystem_DimensionGet(coordinateSystem,numberOfDimensions,err,error,*999)

      NULLIFY(dependentField) 
      IF(equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE) THEN
        CALL EquationsSet_GeometricFieldGet(equationsSet,dependentField,err,error,*999)
      ELSE
        CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
      END IF
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(dependentField,decomposition,err,error,*999)
      NULLIFY(decompositionTopology)
      CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
      NULLIFY(decompositionElements)
      CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
      NULLIFY(decompositionFaces)
      CALL DecompositionTopology_DecompositionFacesGet(decompositionTopology,decompositionFaces,err,error,*999)
      NULLIFY(domain)
      CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      NULLIFY(basis)
      CALL DomainElements_ElementBasisGet(domainElements,elementNumber,basis,err,error,*999)
      CALL Basis_NumberOfLocalFacesGet(basis,numberOfLocalFaces,err,error,*999)
      NULLIFY(domainFaces)
      CALL DomainTopology_DomainFacesGet(domainTopology,domainFaces,err,error,*999)
      
      NULLIFY(vectorMapping)
      CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
      NULLIFY(lhsMapping)
      CALL EquationsMappingVector_LHSMappingGet(vectorMapping,lhsMapping,err,error,*999)
      NULLIFY(rowsVariable)
      CALL EquationsMappingLHS_LHSVariableGet(lhsMapping,rowsVariable,err,error,*999)
      CALL FieldVariable_VariableTypeGet(rowsVariable,rowsVariableType,err,error,*999)
      NULLIFY(nonlinearMapping)
      CALL EquationsMappingVector_NonlinearMappingGet(vectorMapping,nonlinearMapping,err,error,*999)
      NULLIFY(residualMapping)
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,1,residualMapping,err,error,*999)
      NULLIFY(residualVariable)
      CALL EquationsMappingResidual_VariableGet(residualMapping,1,residualVariable,err,error,*999)
      CALL FieldVariable_VariableTypeGet(residualVariable,residualVariableType,err,error,*999)
      NULLIFY(rhsMapping)
      CALL EquationsMappingVector_RHSMappingGet(vectorMapping,rhsMapping,err,error,*999)
      NULLIFY(rhsVariable)
      CALL EquationsMappingRHS_RHSVariableGet(rhsMapping,rhsVariable,err,error,*999)
      CALL FieldVariable_VariableTypeGet(rhsVariable,rhsVariableType,err,error,*999)

      NULLIFY(equationsInterpolation)
      CALL Equations_InterpolationGet(equations,equationsInterpolation,err,error,*999)

      IF(equationsSetSubtype == EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE) THEN
        NULLIFY(dependentInterpParameters)
        CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,residualVariableType,dependentInterpParameters, &
          & err,error,*999)
        NULLIFY(dependentInterpPoint)
        CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,residualVariableType,dependentInterpPoint, &
          & err,error,*999)
        NULLIFY(dependentInterpPointMetrics)
        CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,residualVariableType, &
          & dependentInterpPointMetrics,err,error,*999)
        faceDependentInterpParameters=>equations%interpolation%geometricInterpParameters(fieldUVariableType)%ptr
        faceDependentInterpPoint=>equations%interpolation%geometricInterpPoint(fieldUVariableType)%ptr
        faceDependentInterpPointMetrics=>equations%interpolation% &
          & geometricInterpPointMetrics(fieldUVariableType)%ptr
      ELSE
        NULLIFY(dependentInterpParameters)
        CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,residualVariableType,dependentInterpParameters, &
          & err,error,*999)
        NULLIFY(dependentInterpPoint)
        CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,residualVariableType,dependentInterpPoint, &
          & err,error,*999)
        NULLIFY(dependentInterpPointMetrics)
        CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,residualVariableType, &
          & dependentInterpPointMetrics,err,error,*999)
      ENDIF
     
!!TODO: why is pressure using the delUdeln variable??? It should be an independent variable i.e., r_p(u,p)
      NULLIFY(pressureInterpParameters)
      CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,rhsVariableType,pressureInterpParameters, &
        & err,error,*999)
      NULLIFY(pressureInterpPoint)
      CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,rhsVariableType,pressureInterpPoint,err,error,*999)

      !Surface pressure term calculation: Loop over all faces
      DO localFaceIdx=1,numberOfLocalFaces
        
        CALL DecompositionElements_ElementFaceNumberGet(decompositionElements,localFaceIdx,elementNumber,faceNumber,err,error,*999)
        CALL DecompositionFaces_FaceBoundaryFaceGet(decompositionFaces,faceNumber,boundaryFace,err,error,*999)
        
        !Check if it's a boundary face
        IF(boundaryFace) THEN
          CALL DecompositionFaces_FaceXiNormalDirectionGet(decompositionFaces,faceNumber,xiDirection(3),err,error,*999)
          
          CALL Field_InterpolationParametersFaceGet(FIELD_PRESSURE_VALUES_SET_TYPE,faceNumber,pressureInterpParameters, &
            & err,error,*999,FIELD_GEOMETRIC_COMPONENTS_TYPE)
          
          !Check if nonzero surface pressure is defined on the face
          nonzeroPressure=ANY(ABS(pressureInterpParameters%parameters(:,xiDirection(3)))>ZERO_TOLERANCE)

          !Nonzero surface pressure found?
          IF(nonzeroPressure) THEN
            NULLIFY(dependentFaceBasis)
            CALL DomainFaces_FaceBasisGet(domainFaces,faceNumber,dependentFaceBasis,err,error,*999)
            NULLIFY(dependentQuadratureScheme)
            CALL Basis_QuadratureSchemeGet(dependentFaceBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,dependentQuadratureScheme, &
              & err,error,*999)
            
            CALL Field_InterpolationParametersFaceGet(FIELD_VALUES_SET_TYPE,faceNumber,dependentInterpParameters, &
              & err,error,*999,FIELD_GEOMETRIC_COMPONENTS_TYPE)

            xiDirection(1)=OTHER_XI_DIRECTIONS3(xiDirection(3),2,1)            
            xiDirection(2)=OTHER_XI_DIRECTIONS3(xiDirection(3),3,1)
            orientation=SIGN(1,OTHER_XI_ORIENTATIONS3(xiDirection(1),xiDirection(2))*xiDirection(3))

            !Start integrating
            ! Note: As the code will look for P(appl) in the *normal* component to the face, the
            !       initial assignment of P(appl) will have to be made appropriately during bc assignment
            CALL BasisQuadratureScheme_NumberOfGaussGet(dependentQuadratureScheme,numberOfGauss,err,error,*999)
            DO gaussPointIdx=1,numberOfGauss

              CALL BasisQuadratureScheme_GaussWeightGet(dependentQuadratureScheme,gaussPointIdx,gaussWeight,err,error,*999)
                           
              !Interpolate p(appl) at gauss point
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,pressureInterpPoint, &
                & err,error,*999,FIELD_GEOMETRIC_COMPONENTS_TYPE)
              CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
                & err,error,*999)
              CALL Field_InterpolatedPointMetricsCalculate(COORDINATE_JACOBIAN_AREA_TYPE,dependentInterpPointMetrics, &
                & err,error,*999)
           
              CALL CrossProduct(dependentInterpPointMetrics%dXdXi(:,1),dependentInterpPointMetrics%dXdXi(:,2),normal, &
                & err,error,*999)
              pressureGauss=pressureInterpPoint%values(xiDirection(3),NO_PART_DERIV)*orientation
              pressureGaussWeight=gaussWeight*pressureGauss

              elementBaseDOFIdx=0
              !Loop over 3 components
              DO rowComponentIdx=1,numberOfDimensions                
                NULLIFY(rowDomain)
                CALL FieldVariable_ComponentDomainGet(rowsVariable,rowComponentIdx,rowDomain,err,error,*999)
                NULLIFY(rowDomainTopology)
                CALL Domain_DomainTopologyGet(rowDomain,rowDomainTopology,err,error,*999)
                NULLIFY(rowDomainFaces)
                CALL DomainTopology_DomainFacesGet(rowDomainTopology,rowDomainFaces,err,error,*999)
                NULLIFY(rowDomainElements)
                CALL DomainTopology_DomainElementsGet(rowDomainTopology,rowDomainElements,err,error,*999)
                NULLIFY(rowFaceBasis)
                CALL DomainFaces_FaceBasisGet(rowDomainFaces,faceNumber,rowFaceBasis,err,error,*999)
                NULLIFY(rowBasis)
                CALL DomainElements_ElementBasisGet(rowDomainElements,elementNumber,rowBasis,err,error,*999)
                NULLIFY(rowQuadratureScheme)
                CALL Basis_QuadratureSchemeGet(rowFaceBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,rowQuadratureScheme,err,error,*999)
                CALL Basis_NumberOfElementParametersGet(rowFaceBasis,numberOfRowFaceParameters,err,error,*999)
                CALL Basis_NumberOfElementParametersGet(rowBasis,numberOfElementParameters,err,error,*999)
              
                pressureGWNormalComponent=pressureGaussWeight*normal(rowComponentIdx)
                DO faceParameterIdx=1,numberOfRowFaceParameters
                  CALL Basis_FaceElementParameterGet(rowBasis,faceParameterIdx,localFaceIdx,faceElementParameter,err,error,*999)
                  CALL BasisQuadratureScheme_GaussBasisFunctionGet(rowQuadratureScheme,faceParameterIdx,NO_PART_DERIV, &
                    & gaussPointIdx,rowPhi,err,error,*999)
                  rowElementDOFIdx=elementBaseDOFIdx+faceElementParameter
                  residualVector%elementResidual%vector(rowElementDOFIdx)= &
                    & residualVector%elementResidual%vector(rowElementDOFIdx)+ & ! sign: double -'s. p(appl) always opposite to normal'
                    & pressureGWNormalComponent*rowPhi
                ENDDO !faceParameterIdx
                !Update elementBaseDOFIdx
                elementBaseDOFIdx=elementBaseDOFIdx+numberOfElementParameters
              ENDDO !rowComponentIdx
            ENDDO !gaussPointIdx
            !No scaling because this will be done in residual evaluate
          ENDIF !nonzero surface pressure check
        ENDIF !boundary face check
      ENDDO !elementFaceIdx
    ENDIF !update residual

    EXITS("FiniteElasticity_SurfacePressureResidualEvaluate")
    RETURN
999 ERRORS("FiniteElasticity_SurfacePressureResidualEvaluate",err,error)
    EXITS("FiniteElasticity_SurfacePressureResidualEvaluate")
    RETURN 1

  END SUBROUTINE FiniteElasticity_SurfacePressureResidualEvaluate

  !
  !================================================================================================================================
  !

  !>Evaluates the Cauchy stress tensor at a given Gauss point
  SUBROUTINE FiniteElasticity_GaussCauchyTensor(equationsSet,numberOfDimensions,dependentInterpPoint, &
    & materialsInterpPoint,geometricInterpPoint,darcyDependentInterpPoint,independentInterpPoint, &
    & elementNumber,gaussPointNumber,dZdNu,JZNu,cauchyTensor,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    TYPE(FieldInterpolatedPointType), POINTER :: dependentInterpPoint
    TYPE(FieldInterpolatedPointType), POINTER :: materialsInterpPoint
    TYPE(FieldInterpolatedPointType), POINTER :: darcyDependentInterpPoint
    TYPE(FieldInterpolatedPointType), POINTER :: geometricInterpPoint
    TYPE(FieldInterpolatedPointType), POINTER :: independentInterpPoint
    INTEGER(INTG), INTENT(IN) :: elementNumber !<Element number
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<Gauss point number
    REAL(DP), INTENT(IN) :: dZdNu(3,3) !<Deformation gradient tensor at the Gauss point
    REAL(DP), INTENT(OUT) :: JZNu !<Determinant of deformation gradient tensor (rCauchyGreen)
    REAL(DP), INTENT(OUT) :: cauchyTensor(:,:) !<On exit, the Cauchy stress tensor
    !REAL(DP), INTENT(OUT) :: cauchyTensorFibre(:,:) !<On exit, the Cauchy stress tensor in orthogonal deformed fibre coordinates
    !REAL(DP), INTENT(OUT) :: dZDX(:,:) !<On exit, the deformation gradient tensor mapping spatial coordintes
    !REAL(DP), INTENT(OUT) :: dNuOdNu(:,:) !<On exit, the deformation gradient tensor mapping fibre coordinates
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,darcyMassIncreaseEntry,dofIdx,equationsSetSubtype,esSpecification(3),i,j,k,lWork,node1, &
      & node2,pressureComponent
    INTEGER(INTG), PARAMETER :: lWMax=1000
    REAL(DP) :: a, A1,A2,activation,activeStress11,activeStress22,activeStress33,B(3,3),Ca(3,3),CaInv(3,3),Ce(3,3),deltaT, &
      & dfdJfact,distance1,distance2,dZdNuT(3,3),eigenvalues(3),eigenvectors(3,3),energyPerXB,eMatrix1(3,3),eMatrix2(3,3), &
      & eMatrix3(3,3),eValues(3),eVector1(3), &
      & eVector2(3),eVector3(3),Fa(3,3),FaInv(3,3),FaT(3,3),Fe(3,3),FeT(3,3),ffact,forceLength,freeEnergy,freeEnergy0, &
      & greenLagrangeStrain(3,3),I1,I2,I3,I_1e,identityMat(3,3),isometricForceAtFullActivation,lambda(3),lambdaa,lambdaf, &
      & lengthHalfSarcomere,leftNode(3),lower,maxXBNumberPerVolume,moddZdNu(3,3),moddZdNuT(3,3),N1(3,3),N2(3,3),N3(3,3), &
      & oneThirdTrace,P,piolaDeformation(3,3),piolaTensor2(3,3),piolaDeformationT(3,3),Q,rCauchyGreen(3,3), &
      & rCauchyGreenSquared(3,3), &
      & rCauchyGreenT(3,3),referenceVolume,rightNode(3),sarcoLength,slope,stressTensor(6),temp(3,3),temp1(3,3),temp2(3,3), &
      & temp3(3,3),tempdZdNuT(3,3),tempTerm,tempTerm1,tempTerm2,titinBound,titinBoundCrossFibre,titinUnbound, &
      & titinUnboundCrossFibre,titinValue, &
      & titinValueCrossFibre,tolerance,tolerance1,upper,VALUE,value1,value2,velocity,vMax,work(lWMax),wVPrime,x1,x2, &
      & xbDistortion,xbEnergyPerVolume,xbStiffness
    REAL(DP), DIMENSION (:), POINTER :: C !Parameters for constitutive laws
    REAL(DP), DIMENSION(5) :: parameters
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: dependentField,independentField
    TYPE(FieldInterpolationParametersType), POINTER :: dependentInterpParameters
    TYPE(FieldVariableType), POINTER :: dependentVariable,dependentUVariable,dependentVVariable,fieldVariable,independentVariable
    TYPE(VARYING_STRING) :: localError
 
    ENTERS("FiniteElasticity_GaussCauchyTensor",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)

    equationsSetSubtype=esSpecification(3)
    C=>materialsInterpPoint%values(:,NO_PART_DERIV)

    !rCauchyGreen = F'*F (deformed covariant or right cauchy deformation tensor, C)
    !piolaDeformation - B = C^-1; I3 = det(C)
    !E = Green-Lagrange strain tensor = 0.5*(C-I)
    !piolaTensor2 is the second Piola-Kirchoff tensor (PK2 or S)
    !P is the actual hydrostatic pressure, not double it

    CALL FiniteElasticity_ReferenceStrainTensors(numberOfDimensions,dZdNu,JZNu,rCauchyGreen,I3,piolaDeformation, &
      & greenLagrangeStrain,err,error,*999)
    CALL MatrixTranspose(dZdNu,dZdNuT,err,error,*999)

    NULLIFY(dependentInterpParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(dependentInterpPoint,dependentInterpParameters, &
      & err,error,*999)
    NULLIFY(dependentVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(dependentInterpParameters,dependentVariable,err,error,*999)
    CALL FieldVariable_NumberOfComponentsGet(dependentVariable,pressureComponent,err,error,*999)
    P=dependentInterpPoint%values(pressureComponent,NO_PART_DERIV)

    CALL IdentityMatrix(identityMat(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)

    SELECT CASE(equationsSetSubtype)
    CASE(EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE)
      !Form of constitutive model is:
      ! W_hat=c1*(I1_hat-3)+c2*(I2_hat-3)+p*J*C^(-1) + W^v(J)
      ! take W^v(J) = 1/2 * kappa * (J-1)^2
      wVPrime = C(3)*(Jznu - 1.0_DP)
      !compute the invariants, I3 a few lines up
      CALL Invariants(rCauchyGreen(1:numberOfDimensions,1:numberOfDimensions),I1,I2,err,error,*999)

!!!TODO: GENERALISE THIS FOR TWO 2D      
      piolaTensor2(1:numberOfDimensions,1:numberOfDimensions)=2.0_DP*Jznu**(-2.0_DP/3.0_DP)* &
        & ((C(1)+C(2)*I1)*identityMat(1:numberOfDimensions,1:numberOfDimensions) &
        & -C(2)*rCauchyGreen(1:numberOfDimensions,1:numberOfDimensions) &
        & -(C(1)*I1+2.0_DP*C(2)*I2-1.5_DP*wVPrime* &
        & Jznu**(5.0_DP/3.0_DP))/3.0_DP*piolaDeformation(1:numberOfDimensions,1:numberOfDimensions))

    CASE(EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE)
      !Form of constitutive model is:
      ! W_hat=c1*(I1_hat-3)+c2*(I2_hat-3)+p*J*C^(-1)

      !compute the invariants, I3 a few lines up
      CALL Invariants(rCauchyGreen(1:numberOfDimensions,1:numberOfDimensions),I1,I2,err,error,*999)
      
      !compute 2PK
      !piolaTensor2(1,1) = 2.0_DP * Jznu**(-2.0_DP/3.0_DP) * (C(1) + C(2) * I1 - C(2) * rCauchyGreen(1,1) &
      !  & - (C(1) * I1 + 2.0_DP * C(2) * I2 - 1.5_DP * P * Jznu**(5.0_DP/3.0_DP)) / 3.0_DP * piolaDeformation(1,1))
      !piolaTensor2(1,2) = 2.0_DP * Jznu**(-2.0_DP/3.0_DP) * (-C(2) * rCauchyGreen(1,2) &
      !  & - (C(1) * I1 + 2.0_DP * C(2) * I2 - 1.5_DP * P * Jznu**(5.0_DP/3.0_DP)) / 3.0_DP * piolaDeformation(1,2))
      !piolaTensor2(1,3) = 2.0_DP * Jznu**(-2.0_DP/3.0_DP) * (-C(2) * rCauchyGreen(1,3) &
      !  & - (C(1) * I1 + 2.0_DP * C(2) * I2 - 1.5_DP * P * Jznu**(5.0_DP/3.0_DP)) / 3.0_DP * piolaDeformation(1,3))
      !piolaTensor2(2,1) = piolaTensor2(1,2)
      !piolaTensor2(2,2) = 2.0_DP * Jznu**(-2.0_DP/3.0_DP) * (C(1) + C(2) * I1 - C(2) * rCauchyGreen(2,2) &
      !  & - (C(1) * I1 + 2.0_DP * C(2) * I2 - 1.5_DP * P * Jznu**(5.0_DP/3.0_DP)) / 3.0_DP * piolaDeformation(2,2))
      !piolaTensor2(2,3) = 2.0_DP * Jznu**(-2.0_DP/3.0_DP) * (-C(2) * rCauchyGreen(2,3) &
      !  & - (C(1) * I1 + 2.0_DP * C(2) * I2 - 1.5_DP * P * Jznu**(5.0_DP/3.0_DP)) / 3.0_DP * piolaDeformation(2,3))
      !piolaTensor2(3,1) = piolaTensor2(1,3)
      !piolaTensor2(3,2) = piolaTensor2(2,3)
      !piolaTensor2(3,3) = 2.0_DP * Jznu**(-2.0_DP/3.0_DP) * (C(1) + C(2) * I1 - C(2) * rCauchyGreen(3,3) &
      !  & - (C(1) * I1 + 2.0_DP * C(2) * I2 - 1.5_DP * P * Jznu**(5.0_DP/3.0_DP)) / 3.0_DP * piolaDeformation(3,3))
      !????
      
!!!TODO: GENERALISE THIS FOR TWO 2D      
      piolaTensor2=2.0_DP*Jznu**(-2.0_DP/3.0_DP)*((C(1)+C(2)*I1)*identityMat-C(2)*rCauchyGreen &
        & -(C(1)*I1+2.0_DP*C(2)*I2-1.5_DP*P*Jznu**(5.0_DP/3.0_DP))/3.0_DP*piolaDeformation)

    CASE(EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE)

!!TODO: THIS IS NOT VERY GENERAL!!
      
      NULLIFY(dependentField)
      CALL EquationsSet_DependentfieldGet(equationsSet,dependentField,err,error,*999)
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(dependentField,decomposition,err,error,*999)
      NULLIFY(domain)
      CALL Decomposition_DomainGet(decomposition,1,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      CALL DomainElements_ElementNodeGet(domainElements,13,elementNumber,node1,err,error,*999)
      CALL DomainElements_ElementNodeGet(domainElements,15,elementNumber,node1,err,error,*999)
      
      !compute the nodal distance of the previous time step
      NULLIFY(dependentVVariable)
      CALL Field_VariableGet(dependentField,FIELD_V_VARIABLE_TYPE,dependentVVariable,err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node1,1,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(1),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node1,2,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(2),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node1,3,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(3),err,error,*999)

      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node2,1,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(1),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node2,2,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(2),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node2,3,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(3),err,error,*999)

      distance1=SQRT((rightNode(1)-leftNode(1))*(rightNode(1)-leftNode(1))+ &
        & (rightNode(2)-leftNode(2))*(rightNode(2)-leftNode(2))+ &
        & (rightNode(3)-leftNode(3))*(rightNode(3)-leftNode(3)))

      ! compute the nodal distance of the current time step
      NULLIFY(dependentUVariable)
      CALL Field_VariableGet(dependentField,FIELD_U_VARIABLE_TYPE,dependentUVariable,err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node1,1,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(1),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node1,2,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(2),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node1,3,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(3),err,error,*999)

      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node2,1,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(1),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node2,2,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(2),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node2,3,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(3),err,error,*999)

      distance2=SQRT((rightNode(1)-leftNode(1))*(rightNode(1)-leftNode(1))+ &
        & (rightNode(2)-leftNode(2))*(rightNode(2)-leftNode(2))+ &
        & (rightNode(3)-leftNode(3))*(rightNode(3)-leftNode(3)))

      deltaT=0.01_DP;
      velocity=(distance2-distance1)/deltaT ! velocity>0 for lengthening
      !velocity=(distance1-distance2)/deltaT ! velocity<0 for shortening
      !velocity=velocity*1.0e-6_DP
      velocity=velocity*5.0e-8_DP 
      
      !--------------------------------------------------------------------------------------------

      !Force-Velocity-Relation
      !parameters=[1.0_DP,0.5_DP,0.5_DP,0.8_DP,0.2_DP] ! Muscle-Parameters for F-v-Relation
      !IF(velocity>=0.0_DP) THEN
      !  energyPerXB=(parameters(1)+parameters(2))*parameters(3)/(velocity+parameters(3))-parameters(2)
      !ELSE
      !  energyPerXB=((2.0_DP*parameters(1)-parameters(4))*velocity-parameters(1)*parameters(5))/(velocity-parameters(5))
      !ENDIF
      vMax=8.9e-8_DP
      xbDistortion=8.0e-9_DP*(1+velocity/vMax) ! [m]
      
      xbStiffness=2.2e-3_DP ! [N/m]

      referenceVolume=1.4965e+06_DP ! [nm^3]
      maxXBNumberPerVolume=120.0_DP*2.0_DP/referenceVolume ! [cross-bridges per nm^3]
      energyPerXB=0.5_DP*xbStiffness*xbDistortion**2 ! [J]

      sarcoLength=dZdNu(1,1)
      
      ! Calculate Filament-Overlap
      IF(sarcoLength<=0.635_DP) THEN
        forceLength=0.0_DP
      ELSE IF(sarcoLength<=0.835_DP) THEN 
        forceLength=4.2_DP*(sarcoLength-0.635_DP)
      ELSE IF(sarcoLength<=1.0_DP) THEN
        forceLength=0.84_DP+0.9697_DP*(sarcoLength-0.835_DP)
      ELSE IF(sarcoLength<=1.125_DP) THEN
        forceLength=1.0_DP
      ELSE IF(sarcoLength<=1.825_DP) THEN
        forceLength=1.0_DP-1.4286_DP*(sarcoLength-1.125_DP)
      ELSE
        forceLength=0.0_DP
      ENDIF
      
      !Mechanical Energy stored in cross-bridges - conversion from J/nm^3 to N/cm^2           
      xbEnergyPerVolume=maxXBNumberPerVolume*forceLength*energyPerXB*A2*10.0_DP**23

      !Initalize lambdaa
      lambdaa=1.0_DP

      CALL IdentityMatrix(FaInv(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
      FaInv(1,1)=1.0_DP/lambdaa

      CALL MatrixProduct(dZdNu(1:numberOfDimensions,1:numberOfDimensions),FaInv(1:numberOfDimensions,1:numberOfDimensions), &
        & Fe(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
      CALL MatrixTranspose(Fe(1:numberOfDimensions,1:numberOfDimensions),FeT(1:numberOfDimensions,1:numberOfDimensions), &
        & err,error,*999)
      CALL MatrixProduct(FeT(1:numberOfDimensions,1:numberOfDimensions),Fe(1:numberOfDimensions,1:numberOfDimensions), &
        & Ce(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)

      !Odgen law - 3 terms. Material Parameters C = [mu(1) mu(2) mu(3) alpha(1) alpha(2) alpha(3) mu_0]

      eigenvalues=0.0_DP
      eigenvectors=0.0_DP
      CALL SolveEigenproblem(Ce(1:numberOfDimensions,1:numberOfDimensions),eigenvalues,eigenvectors,err,error,*999)
      
      SELECT CASE(numberOfDimensions)
      CASE(1)
        eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
        N1(1,1)=FaInv(1,1)*eMatrix1(1,1)*FaInv(1,1)
      CASE(2)
        eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
        eMatrix1(1,2)=eigenvectors(1,1)*eigenvectors(2,1)
        eMatrix1(2,1)=eigenvectors(2,1)*eigenvectors(1,1)
        eMatrix1(2,2)=eigenvectors(2,1)*eigenvectors(2,1)
        eMatrix2(1,1)=eigenvectors(1,2)*eigenvectors(1,2)
        eMatrix2(1,2)=eigenvectors(1,2)*eigenvectors(2,2)
        eMatrix2(2,1)=eigenvectors(2,2)*eigenvectors(1,2)
        eMatrix2(2,2)=eigenvectors(2,2)*eigenvectors(2,2)
        CALL MatrixProduct(FaInv(1:2,1:2),eMatrix1(1:2,1:2),N1(1:2,1:2),err,error,*999)
        CALL MatrixProduct(N1(1:2,1:2),FaInv(1:2,1:2),N1(1:2,1:2),err,error,*999) ! FaInv=FaInvT
        CALL MatrixProduct(FaInv(1:2,1:2),eMatrix2(1:2,1:2),N2(1:2,1:2),err,error,*999)
        CALL MatrixProduct(N2(1:2,1:2),FaInv(1:2,1:2),N2(1:2,1:2),err,error,*999) ! FaInv=FaInvT
      CASE(3)
        eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
        eMatrix1(1,2)=eigenvectors(1,1)*eigenvectors(2,1)
        eMatrix1(1,3)=eigenvectors(1,1)*eigenvectors(3,1)
        eMatrix1(2,1)=eigenvectors(2,1)*eigenvectors(1,1)
        eMatrix1(2,2)=eigenvectors(2,1)*eigenvectors(2,1)
        eMatrix1(2,3)=eigenvectors(2,1)*eigenvectors(3,1)
        eMatrix1(3,1)=eigenvectors(3,1)*eigenvectors(1,1)
        eMatrix1(3,2)=eigenvectors(3,1)*eigenvectors(2,1)
        eMatrix1(3,3)=eigenvectors(3,1)*eigenvectors(3,1)
        eMatrix2(1,1)=eigenvectors(1,2)*eigenvectors(1,2)
        eMatrix2(1,2)=eigenvectors(1,2)*eigenvectors(2,2)
        eMatrix2(1,3)=eigenvectors(1,2)*eigenvectors(3,2)
        eMatrix2(2,1)=eigenvectors(2,2)*eigenvectors(1,2)
        eMatrix2(2,2)=eigenvectors(2,2)*eigenvectors(2,2)
        eMatrix2(2,3)=eigenvectors(2,2)*eigenvectors(3,2)
        eMatrix2(3,1)=eigenvectors(3,2)*eigenvectors(1,2)
        eMatrix2(3,2)=eigenvectors(3,2)*eigenvectors(2,2)
        eMatrix2(3,3)=eigenvectors(3,2)*eigenvectors(3,2)
        eMatrix3(1,1)=eigenvectors(1,3)*eigenvectors(1,3)
        eMatrix3(1,2)=eigenvectors(1,3)*eigenvectors(2,3)
        eMatrix3(1,3)=eigenvectors(1,3)*eigenvectors(3,3)
        eMatrix3(2,1)=eigenvectors(2,3)*eigenvectors(1,3)
        eMatrix3(2,2)=eigenvectors(2,3)*eigenvectors(2,3)
        eMatrix3(2,3)=eigenvectors(2,3)*eigenvectors(3,3)
        eMatrix3(3,1)=eigenvectors(3,3)*eigenvectors(1,3)
        eMatrix3(3,2)=eigenvectors(3,3)*eigenvectors(2,3)
        eMatrix3(3,3)=eigenvectors(3,3)*eigenvectors(3,3)
        CALL MatrixProduct(FaInv,eMatrix1,N1,err,error,*999)
        CALL MatrixProduct(N1,FaInv,N1,err,error,*999) ! FaInv=FaInvT
        CALL MatrixProduct(FaInv,eMatrix2,N2,err,error,*999)
        CALL MatrixProduct(N2,FaInv,N2,err,error,*999) ! FaInv=FaInvT
        CALL MatrixProduct(FaInv,eMatrix3,N3,err,error,*999)
        CALL MatrixProduct(N3,FaInv,N3,err,error,*999) ! FaInv=FaInvT 
      CASE DEFAULT
        localError="The number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT

      freeEnergy0=0.0_DP
      DO i=1,numberOfDimensions
        freeEnergy0=freeEnergy0+C(i)/C(i+numberOfDimensions)*( &
          & eigenvalues(1)**(C(i+numberOfDimensions)/2.0_DP)+ &
          & eigenvalues(2)**(C(i+numberOfDimensions)/2.0_DP)+ &
          & eigenvalues(3)**(C(i+numberOfDimensions)/2.0_DP)-REAL(numberOfDimensions,DP))
      END DO
      freeEnergy0=C(2*numberOfDimensions+1)*freeEnergy0

      freeEnergy=freeEnergy0

      value=xbEnergyPerVolume-(freeEnergy-freeEnergy0)

      !tolerance for Newton's method
      tolerance=0.00001_DP
      !tolerance for the bisection method as preconditioner. Since Newton's method does not converge,
      !we only use the bisection method here      
      tolerance1=tolerance 
      upper=lambdaa
      lower=0.001_DP
      
!      WRITE(*,*) "value: ", value

      DO WHILE(ABS(value)>=tolerance)

        !bisection method
        IF(ABS(value)>=tolerance1) THEN
          lambdaa=upper-(upper-lower)/2.0_DP

          FaInv=0.0_DP
          IF(lambdaa<tolerance) THEN
            CALL FlagWarning("lambdaa is close to zero.",err,error,*999)
            lambdaa=lambdaa+tolerance
          ENDIF

          CALL IdentityMatrix(FaInv(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
          FaInv(1,1)=1.0_DP/lambdaa
          
          CALL MatrixProduct(dZdNu(1:numberOfDimensions,1:numberOfDimensions),FaInv(1:numberOfDimensions,1:numberOfDimensions), &
            & Fe(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
          CALL MatrixTranspose(Fe(1:numberOfDimensions,1:numberOfDimensions),FeT(1:numberOfDimensions,1:numberOfDimensions), &
            & err,error,*999)
          CALL MatrixProduct(FeT(1:numberOfDimensions,1:numberOfDimensions),Fe(1:numberOfDimensions,1:numberOfDimensions), &
            & Ce(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
          
          CALL SolveEigenproblem(Ce(1:numberOfDimensions,1:numberOfDimensions),eigenvalues,eigenvectors,err,error,*999)
          
          SELECT CASE(numberOfDimensions)
          CASE(1)
            eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
            N1(1,1)=FaInv(1,1)*eMatrix1(1,1)*FaInv(1,1)
          CASE(2)
            eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
            eMatrix1(1,2)=eigenvectors(1,1)*eigenvectors(2,1)
            eMatrix1(2,1)=eigenvectors(2,1)*eigenvectors(1,1)
            eMatrix1(2,2)=eigenvectors(2,1)*eigenvectors(2,1)
            eMatrix2(1,1)=eigenvectors(1,2)*eigenvectors(1,2)
            eMatrix2(1,2)=eigenvectors(1,2)*eigenvectors(2,2)
            eMatrix2(2,1)=eigenvectors(2,2)*eigenvectors(1,2)
            eMatrix2(2,2)=eigenvectors(2,2)*eigenvectors(2,2)
            CALL MatrixProduct(FaInv(1:2,1:2),eMatrix1(1:2,1:2),N1(1:2,1:2),err,error,*999)
            CALL MatrixProduct(N1(1:2,1:2),FaInv(1:2,1:2),N1(1:2,1:2),err,error,*999) ! FaInv=FaInvT
            CALL MatrixProduct(FaInv(1:2,1:2),eMatrix2(1:2,1:2),N2(1:2,1:2),err,error,*999)
            CALL MatrixProduct(N2(1:2,1:2),FaInv(1:2,1:2),N2(1:2,1:2),err,error,*999) ! FaInv=FaInvT
          CASE(3)
            eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
            eMatrix1(1,2)=eigenvectors(1,1)*eigenvectors(2,1)
            eMatrix1(1,3)=eigenvectors(1,1)*eigenvectors(3,1)
            eMatrix1(2,1)=eigenvectors(2,1)*eigenvectors(1,1)
            eMatrix1(2,2)=eigenvectors(2,1)*eigenvectors(2,1)
            eMatrix1(2,3)=eigenvectors(2,1)*eigenvectors(3,1)
            eMatrix1(3,1)=eigenvectors(3,1)*eigenvectors(1,1)
            eMatrix1(3,2)=eigenvectors(3,1)*eigenvectors(2,1)
            eMatrix1(3,3)=eigenvectors(3,1)*eigenvectors(3,1)
            eMatrix2(1,1)=eigenvectors(1,2)*eigenvectors(1,2)
            eMatrix2(1,2)=eigenvectors(1,2)*eigenvectors(2,2)
            eMatrix2(1,3)=eigenvectors(1,2)*eigenvectors(3,2)
            eMatrix2(2,1)=eigenvectors(2,2)*eigenvectors(1,2)
            eMatrix2(2,2)=eigenvectors(2,2)*eigenvectors(2,2)
            eMatrix2(2,3)=eigenvectors(2,2)*eigenvectors(3,2)
            eMatrix2(3,1)=eigenvectors(3,2)*eigenvectors(1,2)
            eMatrix2(3,2)=eigenvectors(3,2)*eigenvectors(2,2)
            eMatrix2(3,3)=eigenvectors(3,2)*eigenvectors(3,2)
            eMatrix3(1,1)=eigenvectors(1,3)*eigenvectors(1,3)
            eMatrix3(1,2)=eigenvectors(1,3)*eigenvectors(2,3)
            eMatrix3(1,3)=eigenvectors(1,3)*eigenvectors(3,3)
            eMatrix3(2,1)=eigenvectors(2,3)*eigenvectors(1,3)
            eMatrix3(2,2)=eigenvectors(2,3)*eigenvectors(2,3)
            eMatrix3(2,3)=eigenvectors(2,3)*eigenvectors(3,3)
            eMatrix3(3,1)=eigenvectors(3,3)*eigenvectors(1,3)
            eMatrix3(3,2)=eigenvectors(3,3)*eigenvectors(2,3)
            eMatrix3(3,3)=eigenvectors(3,3)*eigenvectors(3,3)
            CALL MatrixProduct(FaInv,eMatrix1,N1,err,error,*999)
            CALL MatrixProduct(N1,FaInv,N1,err,error,*999) ! FaInv=FaInvT
            CALL MatrixProduct(FaInv,eMatrix2,N2,err,error,*999)
            CALL MatrixProduct(N2,FaInv,N2,err,error,*999) ! FaInv=FaInvT
            CALL MatrixProduct(FaInv,eMatrix3,N3,err,error,*999)
            CALL MatrixProduct(N3,FaInv,N3,err,error,*999) ! FaInv=FaInvT 
          CASE DEFAULT
            localError="The number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          
          freeEnergy0=0.0_DP
          DO i=1,numberOfDimensions
            freeEnergy0=freeEnergy0+C(i)/C(i+numberOfDimensions)*( &
              & eigenvalues(1)**(C(i+numberOfDimensions)/2.0_DP)+ &
              & eigenvalues(2)**(C(i+numberOfDimensions)/2.0_DP)+ &
              & eigenvalues(3)**(C(i+numberOfDimensions)/2.0_DP)-REAL(numberOfDimensions,DP))
          END DO
          freeEnergy0=C(2*numberOfDimensions+1)*freeEnergy0
         
          value=xbEnergyPerVolume-(freeEnergy-freeEnergy0)

          IF(value>=0.0_DP) THEN
            upper=lambdaa
          ELSE
            lower=lambdaa
          ENDIF

        ELSE 
          !Newton's method -- needs to be checked TODO

          CALL MatrixTranspose(dZdNu(1:numberOfDimensions,1:numberOfDimensions), &
            & dZdNuT(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
          
          temp(1:numberOfDimensions,1:numberOfDimensions)=dZdNu(1:numberOfDimensions,1:numberOfDimensions)+ &
            & dZdNuT(1:numberOfDimensions,1:numberOfDimensions)
          CALL MatrixProduct(FeT(1:numberOfDimensions,1:numberOfDimensions), &
            & tempdZdNuT(1:numberOfDimensions,1:numberOfDimensions),temp(1:numberOfDimensions,1:numberOfDimensions), &
            & err,error,*999)

          CALL MatrixProduct(temp(1:numberOfDimensions,1:numberOfDimensions),N1(1:numberOfDimensions,1:numberOfDimensions), &
            & temp1(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
          IF(numberOfDimensions>1) THEN
            CALL MatrixProduct(temp(1:numberOfDimensions,1:numberOfDimensions),N2(1:numberOfDimensions,1:numberOfDimensions), &
              & temp2(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
            IF(numberOfDimensions>2) THEN
              CALL MatrixProduct(temp(1:numberOfDimensions,1:numberOfDimensions),N3(1:numberOfDimensions,1:numberOfDimensions), &
                & temp3(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
            ELSE
              temp3(1:numberOfDimensions,1:numberOfDimensions)=0.0_DP
            ENDIF
          ELSE
            temp2(1:numberOfDimensions,1:numberOfDimensions)=0.0_DP
            temp3(1:numberOfDimensions,1:numberOfDimensions)=0.0_DP
          ENDIF
          
          temp=0.0_DP
          DO i=1,numberOfDimensions
            temp(1:numberOfDimensions,1:numberOfDimensions)=temp(1:numberOfDimensions,1:numberOfDimensions)+ &
              & C(i)*eValues(1)**(C(i+numberOfDimensions)/2.0_DP-1.0_DP)*temp1(1:numberOfDimensions,1:numberOfDimensions)+ &
              & C(i)*eValues(2)**(C(i+numberOfDimensions)/2.0_DP-1.0_DP)*temp2(1:numberOfDimensions,1:numberOfDimensions)+ &
              & C(i)*eValues(3)**(C(i+numberOfDimensions)/2.0_DP-1.0_DP)*temp3(1:numberOfDimensions,1:numberOfDimensions)
          ENDDO !i
          slope=temp(1,1)*C(7)
          lambdaa=lambdaa-value/slope
          !IF (lambdaa<=0.0_DP) THEN
          ! lambdaa=0.1_DP
          !END IF
          !lambdaa=lambdaa-0.001

          CALL IdentityMatrix(FaInv(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
          FaInv(1,1)=1.0_DP/lambdaa

          CALL MatrixProduct(dZdNu(1:numberOfDimensions,1:numberOfDimensions),FaInv(1:numberOfDimensions,1:numberOfDimensions), &
            & Fe(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
          CALL MatrixTranspose(Fe(1:numberOfDimensions,1:numberOfDimensions),FeT(1:numberOfDimensions,1:numberOfDimensions), &
            & err,error,*999)
          CALL MatrixProduct(FeT(1:numberOfDimensions,1:numberOfDimensions),Fe(1:numberOfDimensions,1:numberOfDimensions), &
            & Ce(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)

          eigenvalues=0.0_DP
          CALL SolveEigenproblem(Ce(1:numberOfDimensions,1:numberOfDimensions),eigenvalues,eigenvectors,err,error,*999)
          
          SELECT CASE(numberOfDimensions)
          CASE(1)
            eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
            N1(1,1)=FaInv(1,1)*eMatrix1(1,1)*FaInv(1,1)
          CASE(2)
            eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
            eMatrix1(1,2)=eigenvectors(1,1)*eigenvectors(2,1)
            eMatrix1(2,1)=eigenvectors(2,1)*eigenvectors(1,1)
            eMatrix1(2,2)=eigenvectors(2,1)*eigenvectors(2,1)
            eMatrix2(1,1)=eigenvectors(1,2)*eigenvectors(1,2)
            eMatrix2(1,2)=eigenvectors(1,2)*eigenvectors(2,2)
            eMatrix2(2,1)=eigenvectors(2,2)*eigenvectors(1,2)
            eMatrix2(2,2)=eigenvectors(2,2)*eigenvectors(2,2)
            CALL MatrixProduct(FaInv(1:2,1:2),eMatrix1(1:2,1:2),N1(1:2,1:2),err,error,*999)
            CALL MatrixProduct(N1(1:2,1:2),FaInv(1:2,1:2),N1(1:2,1:2),err,error,*999) ! FaInv=FaInvT
            CALL MatrixProduct(FaInv(1:2,1:2),eMatrix2(1:2,1:2),N2(1:2,1:2),err,error,*999)
            CALL MatrixProduct(N2(1:2,1:2),FaInv(1:2,1:2),N2(1:2,1:2),err,error,*999) ! FaInv=FaInvT
          CASE(3)
            eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
            eMatrix1(1,2)=eigenvectors(1,1)*eigenvectors(2,1)
            eMatrix1(1,3)=eigenvectors(1,1)*eigenvectors(3,1)
            eMatrix1(2,1)=eigenvectors(2,1)*eigenvectors(1,1)
            eMatrix1(2,2)=eigenvectors(2,1)*eigenvectors(2,1)
            eMatrix1(2,3)=eigenvectors(2,1)*eigenvectors(3,1)
            eMatrix1(3,1)=eigenvectors(3,1)*eigenvectors(1,1)
            eMatrix1(3,2)=eigenvectors(3,1)*eigenvectors(2,1)
            eMatrix1(3,3)=eigenvectors(3,1)*eigenvectors(3,1)
            eMatrix2(1,1)=eigenvectors(1,2)*eigenvectors(1,2)
            eMatrix2(1,2)=eigenvectors(1,2)*eigenvectors(2,2)
            eMatrix2(1,3)=eigenvectors(1,2)*eigenvectors(3,2)
            eMatrix2(2,1)=eigenvectors(2,2)*eigenvectors(1,2)
            eMatrix2(2,2)=eigenvectors(2,2)*eigenvectors(2,2)
            eMatrix2(2,3)=eigenvectors(2,2)*eigenvectors(3,2)
            eMatrix2(3,1)=eigenvectors(3,2)*eigenvectors(1,2)
            eMatrix2(3,2)=eigenvectors(3,2)*eigenvectors(2,2)
            eMatrix2(3,3)=eigenvectors(3,2)*eigenvectors(3,2)
            eMatrix3(1,1)=eigenvectors(1,3)*eigenvectors(1,3)
            eMatrix3(1,2)=eigenvectors(1,3)*eigenvectors(2,3)
            eMatrix3(1,3)=eigenvectors(1,3)*eigenvectors(3,3)
            eMatrix3(2,1)=eigenvectors(2,3)*eigenvectors(1,3)
            eMatrix3(2,2)=eigenvectors(2,3)*eigenvectors(2,3)
            eMatrix3(2,3)=eigenvectors(2,3)*eigenvectors(3,3)
            eMatrix3(3,1)=eigenvectors(3,3)*eigenvectors(1,3)
            eMatrix3(3,2)=eigenvectors(3,3)*eigenvectors(2,3)
            eMatrix3(3,3)=eigenvectors(3,3)*eigenvectors(3,3)
            CALL MatrixProduct(FaInv,eMatrix1,N1,err,error,*999)
            CALL MatrixProduct(N1,FaInv,N1,err,error,*999) ! FaInv=FaInvT
            CALL MatrixProduct(FaInv,eMatrix2,N2,err,error,*999)
            CALL MatrixProduct(N2,FaInv,N2,err,error,*999) ! FaInv=FaInvT
            CALL MatrixProduct(FaInv,eMatrix3,N3,err,error,*999)
            CALL MatrixProduct(N3,FaInv,N3,err,error,*999) ! FaInv=FaInvT 
          CASE DEFAULT
            localError="The number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          
          freeEnergy0=0.0_DP
          DO i=1,numberOfDimensions
            freeEnergy=freeEnergy+C(i)/C(i+numberOfDimensions)*( &
              & eigenvalues(1)**(C(i+numberOfDimensions)/2.0_DP)+ &
              & eigenvalues(2)**(C(i+numberOfDimensions)/2.0_DP)+ &
              & eigenvalues(3)**(C(i+numberOfDimensions)/2.0_DP)-REAL(numberOfDimensions,DP))
          ENDDO !i
          freeEnergy=C(2*numberOfDimensions+1)*freeEnergy          

          value=xbEnergyPerVolume-(freeEnergy-freeEnergy0)
        ENDIF
      ENDDO
    
      piolaTensor2=0.0_DP
      DO i=1,numberOfDimensions
        piolaTensor2=piolaTensor2+ &
          & C(i)*eValues(1)**(C(i+numberOfDimensions)/2.0_DP-1.0_DP)*N1(1:numberOfDimensions,1:numberOfDimensions)+ &
          & C(i)*eValues(2)**(C(i+numberOfDimensions)/2.0_DP-1.0_DP)*N2(1:numberOfDimensions,1:numberOfDimensions)+ &
          & C(i)*eValues(3)**(C(i+numberOfDimensions)/2.0_DP-1.0_DP)*N3(1:numberOfDimensions,1:numberOfDimensions)
      END DO
      piolaTensor2=piolaTensor2*C(2*numberOfDimensions+1)+2.0_DP*P*piolaDeformation

    CASE(EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE)

!!TODO: THIS IS NOT VERY GENERAL!!
      
      NULLIFY(dependentField)
      CALL EquationsSet_DependentfieldGet(equationsSet,dependentField,err,error,*999)
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(dependentField,decomposition,err,error,*999)
      NULLIFY(domain)
      CALL Decomposition_DomainGet(decomposition,1,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      CALL DomainElements_ElementNodeGet(domainElements,13,elementNumber,node1,err,error,*999)
      CALL DomainElements_ElementNodeGet(domainElements,15,elementNumber,node1,err,error,*999)
      
      !compute the nodal distance of the previous time step
      NULLIFY(dependentVVariable)
      CALL Field_VariableGet(dependentField,FIELD_V_VARIABLE_TYPE,dependentVVariable,err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node1,1,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(1),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node1,2,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(2),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node1,3,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(3),err,error,*999)

      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node2,1,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(1),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node2,2,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(2),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentVVariable,1,1,node2,3,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentVVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(3),err,error,*999)


      distance1=SQRT((rightNode(1)-leftNode(1))*(rightNode(1)-leftNode(1))+ &
               & (rightNode(2)-leftNode(2))*(rightNode(2)-leftNode(2))+ &
               & (rightNode(3)-leftNode(3))*(rightNode(3)-leftNode(3)))

      ! compute the nodal distance of the current time step
      NULLIFY(dependentUVariable)
      CALL Field_VariableGet(dependentField,FIELD_U_VARIABLE_TYPE,dependentUVariable,err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node1,1,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(1),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node1,2,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(2),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node1,3,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,leftNode(3),err,error,*999)

      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node2,1,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(1),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node2,2,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(2),err,error,*999)
      CALL FieldVariable_LocalNodeDOFGet(dependentUVariable,1,1,node2,3,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(dependentUVariable,FIELD_VALUES_SET_TYPE,dofIdx,rightNode(3),err,error,*999)
      
      distance2=SQRT((rightNode(1)-leftNode(1))*(rightNode(1)-leftNode(1))+ &
        & (rightNode(2)-leftNode(2))*(rightNode(2)-leftNode(2))+ &
        & (rightNode(3)-leftNode(3))*(rightNode(3)-leftNode(3)))
      
      deltaT=0.001_DP;
      velocity=(distance2-distance1)/deltaT ! velocity>0 == lengthening
      !conversion of velocity at the continuum macroscale to the micromechanical cell model half-sarcomere velocity
      velocity=velocity*5.0e-8_DP 
      !velocity=velocity*5.0e-2_DP
      !velocity=velocity*5.0e-7_DP 

      CALL Field_ParameterSetUpdateGaussPoint(dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointNumber, &
        & elementNumber,2,velocity,err,error,*999)
      
      !--------------------------------------------------------------------------------------------
      NULLIFY(independentField)
      CALL EquationsSet_IndependentFieldGet(equationsSet,independentField,err,error,*999)
      NULLIFY(independentVariable)
      CALL Field_VariableGet(independentField,FIELD_U_VARIABLE_TYPE,independentVariable,err,error,*999)

      CALL FieldVariable_LocalGaussDOFGet(independentVariable,gaussPointNumber,elementNumber,1,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(independentVariable,FIELD_VALUES_SET_TYPE,dofIdx,A1, err,error,*999)
      CALL FieldVariable_LocalGaussDOFGet(independentVariable,gaussPointNumber,elementNumber,2,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(independentVariable,FIELD_VALUES_SET_TYPE,dofIdx,A2, err,error,*999)
      CALL FieldVariable_LocalGaussDOFGet(independentVariable,gaussPointNumber,elementNumber,3,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(independentVariable,FIELD_VALUES_SET_TYPE,dofIdx,x1,err,error,*999)
      CALL FieldVariable_LocalGaussDOFGet(independentVariable,gaussPointNumber,elementNumber,4,dofIdx,err,error,*999)
      CALL FieldVariable_ParameterSetGetLocalDOF(independentVariable,FIELD_VALUES_SET_TYPE,dofIdx,x2,err,error,*999)

      !--------------------------------------------------------------------------------------------
      sarcoLength=dZdNu(1,1)
      ! Calculate Filament-Overlap
      IF(sarcoLength<=0.635_DP) THEN
        forceLength=0.0_DP
      ELSE IF(sarcoLength<=0.835_DP) THEN 
        forceLength=4.2_DP*(sarcoLength-0.635_DP)
      ELSE IF(sarcoLength<=1.0_DP) THEN
        forceLength=0.84_DP+0.9697_DP*(sarcoLength-0.835_DP)
      ELSE IF(sarcoLength<=1.125_DP) THEN
        forceLength=1.0_DP
      ELSE IF(sarcoLength<=1.825_DP) THEN
        forceLength=1.0_DP-1.4286_DP*(sarcoLength-1.125_DP)
      ELSE
        forceLength=0.0_DP
      ENDIF

      referenceVolume=1.4965e+06_DP ! [nm^3]
      maxXBNumberPerVolume=120.0_DP*2.0_DP/referenceVolume ! [cross-bridges per nm^3]
      energyPerXB=0.5_DP*x2**2*C(8) ! joule
      
      !Mechanical Energy stored in cross-bridges - conversion from J/nm^3 to N/cm^2
      xbEnergyPerVolume=maxXBNumberPerVolume*forceLength*energyPerXB*A2*10.0_DP**23

      !Initalize lambdaa
      lambdaa=1.0_DP

      CALL IdentityMatrix(FaInv(1:numberOfdimensions,1:numberOfDimensions),err,error,*999)
      FaInv(1,1)=1.0_DP/lambdaa

      CALL MatrixProduct(dZdNu(1:numberOfDimensions,1:numberOfDimensions),FaInv(1:numberOfDimensions,1:numberOfDimensions), &
        & Fe(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
      CALL MatrixTranspose(Fe(1:numberOfDimensions,1:numberOfDimensions),FeT(1:numberOfDimensions,1:numberOfDimensions), &
        & err,error,*999)
      CALL MatrixProduct(FeT(1:numberOfDimensions,1:numberOfDimensions),Fe(1:numberOfDimensions,1:numberOfDimensions), &
        & Ce(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)

      !Odgen law - 3 terms. Material Parameters C = [mu(1) mu(2) mu(3) alpha(1) alpha(2) alpha(3) mu_0]
      
      eigenvalues=0.0_DP
      eigenvectors=0.0_DP
      CALL SolveEigenproblem(Ce(1:numberOfDimensions,1:numberOfDimensions),eigenvalues,eigenvectors,err,error,*999)

      SELECT CASE(numberOfDimensions)
      CASE(1)
        eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
        N1(1,1)=FaInv(1,1)*eMatrix1(1,1)*FaInv(1,1)
      CASE(2)
        eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
        eMatrix1(1,2)=eigenvectors(1,1)*eigenvectors(2,1)
        eMatrix1(2,1)=eigenvectors(2,1)*eigenvectors(1,1)
        eMatrix1(2,2)=eigenvectors(2,1)*eigenvectors(2,1)
        eMatrix2(1,1)=eigenvectors(1,2)*eigenvectors(1,2)
        eMatrix2(1,2)=eigenvectors(1,2)*eigenvectors(2,2)
        eMatrix2(2,1)=eigenvectors(2,2)*eigenvectors(1,2)
        eMatrix2(2,2)=eigenvectors(2,2)*eigenvectors(2,2)
        CALL MatrixProduct(FaInv(1:2,1:2),eMatrix1(1:2,1:2),N1(1:2,1:2),err,error,*999)
        CALL MatrixProduct(N1(1:2,1:2),FaInv(1:2,1:2),N1(1:2,1:2),err,error,*999) ! FaInv=FaInvT
        CALL MatrixProduct(FaInv(1:2,1:2),eMatrix2(1:2,1:2),N2(1:2,1:2),err,error,*999)
        CALL MatrixProduct(N2(1:2,1:2),FaInv(1:2,1:2),N2(1:2,1:2),err,error,*999) ! FaInv=FaInvT
      CASE(3)
        eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
        eMatrix1(1,2)=eigenvectors(1,1)*eigenvectors(2,1)
        eMatrix1(1,3)=eigenvectors(1,1)*eigenvectors(3,1)
        eMatrix1(2,1)=eigenvectors(2,1)*eigenvectors(1,1)
        eMatrix1(2,2)=eigenvectors(2,1)*eigenvectors(2,1)
        eMatrix1(2,3)=eigenvectors(2,1)*eigenvectors(3,1)
        eMatrix1(3,1)=eigenvectors(3,1)*eigenvectors(1,1)
        eMatrix1(3,2)=eigenvectors(3,1)*eigenvectors(2,1)
        eMatrix1(3,3)=eigenvectors(3,1)*eigenvectors(3,1)
        eMatrix2(1,1)=eigenvectors(1,2)*eigenvectors(1,2)
        eMatrix2(1,2)=eigenvectors(1,2)*eigenvectors(2,2)
        eMatrix2(1,3)=eigenvectors(1,2)*eigenvectors(3,2)
        eMatrix2(2,1)=eigenvectors(2,2)*eigenvectors(1,2)
        eMatrix2(2,2)=eigenvectors(2,2)*eigenvectors(2,2)
        eMatrix2(2,3)=eigenvectors(2,2)*eigenvectors(3,2)
        eMatrix2(3,1)=eigenvectors(3,2)*eigenvectors(1,2)
        eMatrix2(3,2)=eigenvectors(3,2)*eigenvectors(2,2)
        eMatrix2(3,3)=eigenvectors(3,2)*eigenvectors(3,2)
        eMatrix3(1,1)=eigenvectors(1,3)*eigenvectors(1,3)
        eMatrix3(1,2)=eigenvectors(1,3)*eigenvectors(2,3)
        eMatrix3(1,3)=eigenvectors(1,3)*eigenvectors(3,3)
        eMatrix3(2,1)=eigenvectors(2,3)*eigenvectors(1,3)
        eMatrix3(2,2)=eigenvectors(2,3)*eigenvectors(2,3)
        eMatrix3(2,3)=eigenvectors(2,3)*eigenvectors(3,3)
        eMatrix3(3,1)=eigenvectors(3,3)*eigenvectors(1,3)
        eMatrix3(3,2)=eigenvectors(3,3)*eigenvectors(2,3)
        eMatrix3(3,3)=eigenvectors(3,3)*eigenvectors(3,3)
        CALL MatrixProduct(FaInv,eMatrix1,N1,err,error,*999)
        CALL MatrixProduct(N1,FaInv,N1,err,error,*999) ! FaInv=FaInvT
        CALL MatrixProduct(FaInv,eMatrix2,N2,err,error,*999)
        CALL MatrixProduct(N2,FaInv,N2,err,error,*999) ! FaInv=FaInvT
        CALL MatrixProduct(FaInv,eMatrix3,N3,err,error,*999)
        CALL MatrixProduct(N3,FaInv,N3,err,error,*999) ! FaInv=FaInvT 
      CASE DEFAULT
        localError="The number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT

      freeEnergy0=0.0_DP
      DO i=1,numberOfDimensions
        freeEnergy0=freeEnergy0+C(i)/C(i+numberOfDimensions)*( &
          & eValues(1)**(C(i+numberOfDimensions)/2.0_DP)+ &
          & eValues(2)**(C(i+numberOfDimensions)/2.0_DP)+ &
          & eValues(3)**(C(i+numberOfDimensions)/2.0_DP)-REAL(numberOfDimensions,DP))
      ENDDO !i
      freeEnergy0=C(2*numberOfDimensions+1)*freeEnergy0

      freeEnergy=freeEnergy0

      value=xbEnergyPerVolume-(freeEnergy-freeEnergy0)

      !tolerance for Newton's method
      tolerance=0.00001_DP
      !tolerance for the bisection method as preconditioner. Since Newton's method does not converge,
      !we only use the bisection method here
      tolerance1=tolerance 
      upper=lambdaa
      lower=0.001_DP
      
      DO WHILE (ABS(value)>=tolerance)
        
        !bisection method
        IF (ABS(VALUE)>=tolerance1) THEN
          lambdaa=upper-(upper-lower)/2.0_DP

          FaInv=0.0_DP
          IF(lambdaa<tolerance) THEN
           CALL FlagWarning("lambdaa is close to zero",err,error,*999)
            lambdaa=lambdaa+tolerance
          ENDIF
          CALL IdentityMatrix(FaInv(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
          FaInv(1,1)=1.0_DP/lambdaa

          CALL MatrixProduct(dZdNu(1:numberOfDimensions,1:numberOfDimensions),FaInv(1:numberOfDimensions,1:numberOfDimensions), &
            & Fe(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
          CALL MatrixTranspose(Fe(1:numberOfDimensions,1:numberOfDimensions),FeT(1:numberOfDimensions,1:numberOfDimensions), &
            & err,error,*999)
          CALL MatrixProduct(FeT(1:numberOfDimensions,1:numberOfDimensions),Fe(1:numberOfDimensions,1:numberOfDimensions), &
            & Ce(1:numberOfDimensions,1:numberOfDimensions),err,error,*999)
          
          eigenvalues=0.0_DP
          eigenvectors=0.0_DP
          CALL SolveEigenproblem(Ce(1:numberOfDimensions,1:numberOfDimensions),eigenvalues,eigenvectors,err,error,*999)
          
          SELECT CASE(numberOfDimensions)
          CASE(1)
            eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
            N1(1,1)=FaInv(1,1)*eMatrix1(1,1)*FaInv(1,1)
          CASE(2)
            eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
            eMatrix1(1,2)=eigenvectors(1,1)*eigenvectors(2,1)
            eMatrix1(2,1)=eigenvectors(2,1)*eigenvectors(1,1)
            eMatrix1(2,2)=eigenvectors(2,1)*eigenvectors(2,1)
            eMatrix2(1,1)=eigenvectors(1,2)*eigenvectors(1,2)
            eMatrix2(1,2)=eigenvectors(1,2)*eigenvectors(2,2)
            eMatrix2(2,1)=eigenvectors(2,2)*eigenvectors(1,2)
            eMatrix2(2,2)=eigenvectors(2,2)*eigenvectors(2,2)
            CALL MatrixProduct(FaInv(1:2,1:2),eMatrix1(1:2,1:2),N1(1:2,1:2),err,error,*999)
            CALL MatrixProduct(N1(1:2,1:2),FaInv(1:2,1:2),N1(1:2,1:2),err,error,*999) ! FaInv=FaInvT
            CALL MatrixProduct(FaInv(1:2,1:2),eMatrix2(1:2,1:2),N2(1:2,1:2),err,error,*999)
            CALL MatrixProduct(N2(1:2,1:2),FaInv(1:2,1:2),N2(1:2,1:2),err,error,*999) ! FaInv=FaInvT
          CASE(3)
            eMatrix1(1,1)=eigenvectors(1,1)*eigenvectors(1,1)
            eMatrix1(1,2)=eigenvectors(1,1)*eigenvectors(2,1)
            eMatrix1(1,3)=eigenvectors(1,1)*eigenvectors(3,1)
            eMatrix1(2,1)=eigenvectors(2,1)*eigenvectors(1,1)
            eMatrix1(2,2)=eigenvectors(2,1)*eigenvectors(2,1)
            eMatrix1(2,3)=eigenvectors(2,1)*eigenvectors(3,1)
            eMatrix1(3,1)=eigenvectors(3,1)*eigenvectors(1,1)
            eMatrix1(3,2)=eigenvectors(3,1)*eigenvectors(2,1)
            eMatrix1(3,3)=eigenvectors(3,1)*eigenvectors(3,1)
            eMatrix2(1,1)=eigenvectors(1,2)*eigenvectors(1,2)
            eMatrix2(1,2)=eigenvectors(1,2)*eigenvectors(2,2)
            eMatrix2(1,3)=eigenvectors(1,2)*eigenvectors(3,2)
            eMatrix2(2,1)=eigenvectors(2,2)*eigenvectors(1,2)
            eMatrix2(2,2)=eigenvectors(2,2)*eigenvectors(2,2)
            eMatrix2(2,3)=eigenvectors(2,2)*eigenvectors(3,2)
            eMatrix2(3,1)=eigenvectors(3,2)*eigenvectors(1,2)
            eMatrix2(3,2)=eigenvectors(3,2)*eigenvectors(2,2)
            eMatrix2(3,3)=eigenvectors(3,2)*eigenvectors(3,2)
            eMatrix3(1,1)=eigenvectors(1,3)*eigenvectors(1,3)
            eMatrix3(1,2)=eigenvectors(1,3)*eigenvectors(2,3)
            eMatrix3(1,3)=eigenvectors(1,3)*eigenvectors(3,3)
            eMatrix3(2,1)=eigenvectors(2,3)*eigenvectors(1,3)
            eMatrix3(2,2)=eigenvectors(2,3)*eigenvectors(2,3)
            eMatrix3(2,3)=eigenvectors(2,3)*eigenvectors(3,3)
            eMatrix3(3,1)=eigenvectors(3,3)*eigenvectors(1,3)
            eMatrix3(3,2)=eigenvectors(3,3)*eigenvectors(2,3)
            eMatrix3(3,3)=eigenvectors(3,3)*eigenvectors(3,3)
            CALL MatrixProduct(FaInv,eMatrix1,N1,err,error,*999)
            CALL MatrixProduct(N1,FaInv,N1,err,error,*999) ! FaInv=FaInvT
            CALL MatrixProduct(FaInv,eMatrix2,N2,err,error,*999)
            CALL MatrixProduct(N2,FaInv,N2,err,error,*999) ! FaInv=FaInvT
            CALL MatrixProduct(FaInv,eMatrix3,N3,err,error,*999)
            CALL MatrixProduct(N3,FaInv,N3,err,error,*999) ! FaInv=FaInvT 
          CASE DEFAULT
            localError="The number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          
          freeEnergy=0.0_DP
          DO i=1,numberOfDimensions
            freeEnergy=freeEnergy+C(i)/C(i+numberOfDimensions)*( &
              & eValues(1)**(C(i+numberOfDimensions)/2.0_DP)+ &
              & eValues(2)**(C(i+numberOfDimensions)/2.0_DP)+ &
              & eValues(3)**(C(i+numberOfDimensions)/2.0_DP)-REAL(numberOfDimensions,DP))
          END DO
          freeEnergy=C(2*numberOfDimensions+1)*freeEnergy

          value=xbEnergyPerVolume-(freeEnergy-freeEnergy0)

          IF(value>=0.0_DP) THEN
            upper=lambdaa
          ELSE
            lower=lambdaa
          ENDIF

        ELSE 
          !Newton's method -- needs to be checked TODO

          temp=dZdNu+dZdNuT
          CALL MatrixProduct(FeT,temp,temp,err,error,*999)
          CALL MatrixProduct(temp,N1,temp1,err,error,*999) 
          CALL MatrixProduct(temp,N2,temp2,err,error,*999) 
          CALL MatrixProduct(temp,N3,temp3,err,error,*999) 

          temp=0.0_DP
          DO i=1,3
            temp=temp+ &
              & C(i)*eValues(1)**(C(i+3)/2.0_DP-1.0_DP)*temp1+ &
              & C(i)*eValues(2)**(C(i+3)/2.0_DP-1.0_DP)*temp2+ &
              & C(i)*eValues(3)**(C(i+3)/2.0_DP-1.0_DP)*temp3
          END DO
          slope=temp(1,1)*C(7)
          lambdaa=lambdaa-value/slope
          !IF (lambdaa.LE.0.0_DP) THEN
          ! lambdaa=0.1_DP
          !END IF
          !lambdaa=lambdaa-0.001

          FaInv=0.0_DP
          FaInv(1,1)=1.0_DP/lambdaa
          FaInv(2,2)=1.0_DP
          FaInv(3,3)=1.0_DP

          CALL MatrixProduct(dZdNu,FaInv,Fe,err,error,*999)
          CALL MatrixTranspose(Fe,FeT,err,error,*999)
          CALL MatrixProduct(FeT,Fe,Ce,err,error,*999)

          CALL DSYEV('V','U',3,Ce,3,eValues,work,-1,ERR)
          IF(ERR.NE.0) CALL FlagError("Error in Eigenvalue computation",err,error,*999)
          lWork=MIN(lWMax,INT(work(1)))
          CALL DSYEV('V','U',3,Ce,3,eValues,work,lWork,ERR)
          IF(ERR.NE.0) CALL FlagError("Error in Eigenvalue computation",err,error,*999)
          eVector1=Ce(:,1)
          eVector2=Ce(:,2)
          eVector3=Ce(:,3)

          DO i=1,3
            DO j=1,3
              eMatrix1(i,j)=eVector1(i)*eVector1(j)
              eMatrix2(i,j)=eVector2(i)*eVector2(j)
              eMatrix3(i,j)=eVector3(i)*eVector3(j)
            END DO
          END DO

          CALL MatrixProduct(FaInv,eMatrix1,N1,err,error,*999)
          CALL MatrixProduct(N1,FaInv,N1,err,error,*999) ! FaInv=FaInvT
          CALL MatrixProduct(FaInv,eMatrix2,N2,err,error,*999)
          CALL MatrixProduct(N2,FaInv,N2,err,error,*999) ! FaInv=FaInvT
          CALL MatrixProduct(FaInv,eMatrix3,N3,err,error,*999)
          CALL MatrixProduct(N3,FaInv,N3,err,error,*999) ! FaInv=FaInvT 

          freeEnergy=0.0_DP
          DO i=1,3
            freeEnergy=freeEnergy+C(i)/C(i+3)*( &
              & eValues(1)**(C(i+3)/2.0_DP)+ &
              & eValues(2)**(C(i+3)/2.0_DP)+ &
              & eValues(3)**(C(i+3)/2.0_DP)-3.0_DP)
          END DO
          freeEnergy=C(7)*freeEnergy

          value=xbEnergyPerVolume-(freeEnergy-freeEnergy0)
        ENDIF
      ENDDO
    
      piolaTensor2=0.0_DP
      DO i=1,3
        piolaTensor2=piolaTensor2+ &
          & C(i)*eValues(1)**(C(i+3)/2.0_DP-1.0_DP)*N1+ &
          & C(i)*eValues(2)**(C(i+3)/2.0_DP-1.0_DP)*N2+ &
          & C(i)*eValues(3)**(C(i+3)/2.0_DP-1.0_DP)*N3
      END DO
      piolaTensor2=piolaTensor2*C(7)+2.0_DP*P*piolaDeformation
      
      !store lambdaf, so it can be used in the CellML file
      lambdaf=SQRT(rCauchyGreen(1,1))
      CALL Field_ParameterSetUpdateGaussPoint(dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointNumber,&
        & elementNumber,1,lambdaf,err,error,*999)

    CASE(EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE)

      NULLIFY(independentField)
      independentField=>equationsSet%INDEPENDENT%independentField
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(independentField,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)

      dofIdx=fieldVariable%COMPONENTS(5)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gaussPointNumber, &
        & elementNumber)
      CALL Field_ParameterSetGetLocalDOF(independentField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,dofIdx,lambdaa, &
        & err,error,*999)

      FaInv=0.0_DP
      FaInv(1,1)=1.0_DP/lambdaa
      FaInv(2,2)=1.0_DP
      FaInv(3,3)=1.0_DP

      CALL MatrixProduct(dZdNu,FaInv,Fe,err,error,*999)
      CALL MatrixTranspose(Fe,FeT,err,error,*999)
      CALL MatrixProduct(FeT,Fe,Ce,err,error,*999)
      
      !Odgen law - 3 terms. Material Parameters C = [mu(1) mu(2) mu(3) alpha(1) alpha(2) alpha(3) mu_0]
!      CALL Eigenvalue(Ce,eValues,err,error,*999)
      CALL DSYEV('V','U',3,Ce,3,eValues,work,-1,ERR)
      IF(ERR.NE.0) CALL FlagError("Error in Eigenvalue computation",err,error,*999)
      lWork=MIN(lWMax,INT(work(1)))
      CALL DSYEV('V','U',3,Ce,3,eValues,work,lWork,ERR)
      IF(ERR.NE.0) CALL FlagError("Error in Eigenvalue computation",err,error,*999)
      eVector1=Ce(:,1)
      eVector2=Ce(:,2)
      eVector3=Ce(:,3)

      DO i=1,3
        DO j=1,3
          eMatrix1(i,j)=eVector1(i)*eVector1(j)
          eMatrix2(i,j)=eVector2(i)*eVector2(j)
          eMatrix3(i,j)=eVector3(i)*eVector3(j)
        END DO
      END DO

      CALL MatrixProduct(FaInv,eMatrix1,N1,err,error,*999)
      CALL MatrixProduct(N1,FaInv,N1,err,error,*999) ! FaInv=FaInvT
      CALL MatrixProduct(FaInv,eMatrix2,N2,err,error,*999)
      CALL MatrixProduct(N2,FaInv,N2,err,error,*999) ! FaInv=FaInvT
      CALL MatrixProduct(FaInv,eMatrix3,N3,err,error,*999)
      CALL MatrixProduct(N3,FaInv,N3,err,error,*999) ! FaInv=FaInvT 

      piolaTensor2=0.0_DP
      DO i=1,3
        piolaTensor2=piolaTensor2+ &
          & C(i)*eValues(1)**(C(i+3)/2.0_DP-1.0_DP)*N1+ &
          & C(i)*eValues(2)**(C(i+3)/2.0_DP-1.0_DP)*N2+ &
          & C(i)*eValues(3)**(C(i+3)/2.0_DP-1.0_DP)*N3
      END DO
      piolaTensor2=piolaTensor2*C(7)+2.0_DP*P*piolaDeformation
      
    CASE(EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE,EQUATIONS_SET_MEMBRANE_SUBTYPE,&
      & EQUATIONS_SET_NO_SUBTYPE,EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE,&
      & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE,EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE, &
      & EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE, &
      & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE,EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
      & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE,EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
      !Form of constitutive model is:
      ! W=c1*(I1-3)+c2*(I2-3)+p*(I3-1)
      !Also assumed I3 = det(rCauchyGreen) = 1.0
      !  Note that because PIOLA = 2.del{W}/del{C}=[...]+2.lambda.J^2.C^{-1}
      !  lambda here is actually half of hydrostatic pressure -- is this comment still correct?
      !If subtype is membrane, assume Mooney Rivlin constitutive law
      IF (equationsSetSubtype/=EQUATIONS_SET_MEMBRANE_SUBTYPE) THEN
          piolaTensor2(1,3)=2.0_DP*(C(2)*(-rCauchyGreen(3,1)))+P*piolaDeformation(1,3)
          piolaTensor2(2,3)=2.0_DP*(C(2)*(-rCauchyGreen(3,2)))+P*piolaDeformation(2,3)
          piolaTensor2(3,1)=piolaTensor2(1,3)
          piolaTensor2(3,2)=piolaTensor2(2,3)
          piolaTensor2(3,3)=2.0_DP*(C(1)+C(2)*(rCauchyGreen(1,1)+rCauchyGreen(2,2)))+P*piolaDeformation(3,3)
      ELSE
        ! Membrane Equations
        ! Assume incompressible => I3 = 1 => C33(C11 x C22 - C12*C21) = 1
        rCauchyGreen(3,3) = 1.0_DP / ((rCauchyGreen(1,1) * rCauchyGreen(2,2)) - (rCauchyGreen(1,2) * rCauchyGreen (2,1)))
        ! Assume Mooney-Rivlin constitutive relation
        P = -1.0_DP*((C(1) + C(2) * (rCauchyGreen(1,1) + rCauchyGreen(2,2))) * rCauchyGreen(3,3))
        ! Assume stress normal to the surface is neglible i.e. piolaTensor2(:,3) = 0,piolaTensor2(3,:) = 0
        piolaTensor2(:,3) = 0.0_DP
        piolaTensor2(3,:) = 0.0_DP
      ENDIF
      piolaTensor2(1,1)=2.0_DP*(C(1)+C(2)*(rCauchyGreen(2,2)+rCauchyGreen(3,3)))+P*piolaDeformation(1,1)
      piolaTensor2(1,2)=2.0_DP*(     C(2)*(-rCauchyGreen(2,1)))+P*piolaDeformation(1,2)
      piolaTensor2(2,1)=piolaTensor2(1,2)
      piolaTensor2(2,2)=2.0_DP*(C(1)+C(2)*(rCauchyGreen(3,3)+rCauchyGreen(1,1)))+P*piolaDeformation(2,2)


      SELECT CASE(equationsSetSubtype)
      CASE(EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE)
        !add active contraction stress value to the trace of the stress tensor - basically adding to hydrostatic pressure.
        !the active stress is stored inside the independent field that has been set up in the user program.
        !for generality we could set up 3 components in independent field for 3 different active stress components
        !1 isotropic value assumed here.
        CALL Field_ParameterSetGetLocalGaussPoint(equationsSet%INDEPENDENT%independentField, & 
          &  FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointNumber,elementNumber,1,activeStress11, &
          & err,error,*999) ! get the independent field stress value

        CALL Field_ParameterSetGetLocalGaussPoint(equationsSet%INDEPENDENT%independentField, & 
          &  FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointNumber,elementNumber,2,activeStress22, &
          & err,error,*999) ! get the independent field stress value

        CALL Field_ParameterSetGetLocalGaussPoint(equationsSet%INDEPENDENT%independentField, & 
          &  FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointNumber,elementNumber,3,activeStress33, &
          & err,error,*999) ! get the independent field stress value

        piolaTensor2(1,1)=piolaTensor2(1,1)+activeStress11
        piolaTensor2(2,2)=piolaTensor2(2,2)+activeStress22
        piolaTensor2(3,3)=piolaTensor2(3,3)+activeStress33

      CASE(EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE)
        ! add the active stress component (stored in the independent field) to the 1,1-direction of the 2-PK tensor
        piolaTensor2(1,1)=piolaTensor2(1,1)+independentInterpPoint%values(1,NO_PART_DERIV)

      CASE(EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE)
        !passive anisotropic stiffness -- only in the tension range
        IF(rCauchyGreen(1,1) > 1.0_DP) THEN
          piolaTensor2(1,1)=piolaTensor2(1,1)+C(3)/rCauchyGreen(1,1)*(rCauchyGreen(1,1)**(C(4)/2.0_DP)-1.0_DP)
        ENDIF
        !active stress component
        CALL Field_ParameterSetGetLocalGaussPoint(equationsSet%INDEPENDENT%independentField, & 
          & FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointNumber,elementNumber,1,value, &
          & err,error,*999)
        !divide by lambda and multiply by P_max
        value=value/SQRT(rCauchyGreen(1,1))*C(5)

        !HINDAWI paper - force-length relation at the continuum level
!        if((SQRT(rCauchyGreen(1,1))>0.72_DP).AND.(SQRT(rCauchyGreen(1,1))<1.68_DP)) then
!          value=value*(-25.0_DP/4.0_DP*rCauchyGreen(1,1)/1.2_DP/1.2_DP + 25.0_DP/2.0_DP*SQRT(rCauchyGreen(1,1))/1.2_DP - 5.25_DP)
!        else
!          value=0.0_DP
!        endif

        piolaTensor2(1,1)=piolaTensor2(1,1)+value

      CASE(EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE)
        !passive anisotropic stiffness -- only in the tension range
        IF(rCauchyGreen(1,1) > 1.0_DP) THEN
          piolaTensor2(1,1)=piolaTensor2(1,1)+C(3)/rCauchyGreen(1,1)*(rCauchyGreen(1,1)**(C(4)/2.0_DP)-1.0_DP)
        ENDIF
        !active stress component
        CALL Field_VariableGet(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
        dofIdx=fieldVariable%COMPONENTS(1)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gaussPointNumber, &
          & elementNumber)
        CALL Field_ParameterSetGetLocalDOF(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE, &
          & FIELD_VALUES_SET_TYPE,dofIdx,value,err,error,*999)

        IF(value.LT.0.0_DP) value=0.0_DP

        !divide by lambda and multiply by P_max
        value=value/SQRT(rCauchyGreen(1,1))*C(5)

        piolaTensor2(1,1)=piolaTensor2(1,1)+value

        ! unbound Titin-stress
        dofIdx=fieldVariable%COMPONENTS(2)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gaussPointNumber, &
          & elementNumber)
        CALL Field_ParameterSetGetLocalDOF(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE, &
            & FIELD_VALUES_SET_TYPE,dofIdx,titinUnbound,err,error,*999)
        ! bound Titin-stress -> Rode Model
        dofIdx=fieldVariable%COMPONENTS(3)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gaussPointNumber, &
          & elementNumber)
        CALL Field_ParameterSetGetLocalDOF(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE, &
          & FIELD_VALUES_SET_TYPE,dofIdx,titinBound,err,error,*999)
        ! activation
        dofIdx=fieldVariable%COMPONENTS(6)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gaussPointNumber, &
          & elementNumber)
        CALL Field_ParameterSetGetLocalDOF(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE, &
          & FIELD_VALUES_SET_TYPE,dofIdx,activation,err,error,*999)

        IF(activation.GT.1.0_DP) activation=1.0_DP
        IF(activation.LT.0.0_DP) activation=0.0_DP

        ! parameter to switch on and off actin-titin interaction
        activation=C(6)*activation
        
        ! normalized Titin-stress -> weighted sum of bound and unbound titin-stress
        titinValue=activation*titinBound+(1.0_DP-activation)*titinUnbound
        !titinValue=activation*titinBound*0.5_DP+(1.0_DP-activation)*titinUnbound !TK Hack
        ! divide by lambda and multiply by P_max
        titinValue=titinValue/SQRT(rCauchyGreen(1,1))*C(5)

        piolaTensor2(1,1)=piolaTensor2(1,1)+titinValue

        ! unbound titin-stress in cross-fibre direction
        dofIdx=fieldVariable%COMPONENTS(4)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gaussPointNumber, &
          & elementNumber)
        CALL Field_ParameterSetGetLocalDOF(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE, &
          & FIELD_VALUES_SET_TYPE,dofIdx,titinUnboundCrossFibre,err,error,*999)
        ! bound titin-stress in cross-fibre direction
        dofIdx=fieldVariable%COMPONENTS(5)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gaussPointNumber, &
          & elementNumber)
        CALL Field_ParameterSetGetLocalDOF(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE, &
          & FIELD_VALUES_SET_TYPE,dofIdx,titinBoundCrossFibre,err,error,*999)

        ! normalized XF-Titin-stress -> weighted sum of bound and unbound XF-titin-stress
        titinValueCrossFibre=activation*titinBoundCrossFibre+(1.0_DP-activation)*titinUnboundCrossFibre
        ! divide by lambda and multiply by P_max
        titinValueCrossFibre=titinValueCrossFibre*C(5) !/SQRT(rCauchyGreen(1,1))
 
        piolaTensor2(2,2)=piolaTensor2(2,2)+titinValueCrossFibre
        piolaTensor2(3,3)=piolaTensor2(3,3)+titinValueCrossFibre

      CASE(EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE)
        !passive anisotropic stiffness -- only in the tension range
        IF(rCauchyGreen(1,1) > 1.0_DP) THEN
!tomo
!          piolaTensor2(1,1)=piolaTensor2(1,1)+C(3)/rCauchyGreen(1,1)*(rCauchyGreen(1,1)**(C(4)/2.0_DP)-1.0_DP)
          piolaTensor2(1,1)=piolaTensor2(1,1)+0.355439810963035_DP/rCauchyGreen(1,1)*(rCauchyGreen(1,1)** &
            & (12.660539325481963_DP/2.0_DP)-1.0_DP)
        ENDIF
        IF(rCauchyGreen(2,2) > 1.0_DP) THEN
          piolaTensor2(2,2)=piolaTensor2(2,2)+5316.372204148964_DP/rCauchyGreen(2,2)*(rCauchyGreen(2,2)** &
            & (0.014991843974911_DP/2.0_DP)-1.0_DP)
        ENDIF
        IF(rCauchyGreen(3,3) > 1.0_DP) THEN
          piolaTensor2(3,3)=piolaTensor2(3,3)+5316.372204148964_DP/rCauchyGreen(3,3)*(rCauchyGreen(3,3)** &
            & (0.014991843974911_DP/2.0_DP)-1.0_DP)
        ENDIF
        !active stress component
        CALL Field_VariableGet(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
        dofIdx=fieldVariable%COMPONENTS(1)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gaussPointNumber, &
          & elementNumber)
        CALL Field_ParameterSetGetLocalDOF(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE, &
          & FIELD_VALUES_SET_TYPE,dofIdx,value,err,error,*999)
        !divide by lambda and multiply by P_max
        value1=value
        value=value/SQRT(rCauchyGreen(1,1))*C(5)


        !alpha*K_rfe*(lambda-lambda_start)/lambda
        !TODO make lambda_start variable --> independent field
!        value2=value1*100.0_DP*(SQRT(rCauchyGreen(1,1))-1) !stretch and compression!!!
        value2=100.0_DP*(SQRT(rCauchyGreen(1,1))-1) !stretch and compression!!!
        value=value+value2/SQRT(rCauchyGreen(1,1))
        piolaTensor2(1,1)=piolaTensor2(1,1)+value

!        piolaTensor2(1,1)=piolaTensor2(1,1)+value

      CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE)
        !Additional term for transversely isotropic (fibre-reinforced) materials (Markert, B., W. Ehlers, and N. Karajan.
        !A general polyconvex strain-energy function for fiber-reinforced materials.
        !Proceedings in Applied Mathematics and Mechanics 5.1 (2005): 245-246.)

        ! W_aniso=c3*(sqrt(I4)^(c4-2)-1/I4)M
        ! with M being the mapping towards the fibre direction, here: I4=C_11
        !C(3)=c3...polynomial coefficient
        !C(4)=c4...power coefficient
        IF(rCauchyGreen(1,1) > 1.0_DP) THEN ! only in the tension range
          piolaTensor2(1,1)=piolaTensor2(1,1)+C(3)/rCauchyGreen(1,1)*(rCauchyGreen(1,1)**(C(4)/2.0_DP)-1.0_DP)
        ENDIF

      CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE)
        !Isotropic and anisotropic part from above, additionally an active part in fibre direction
        ! W=W_iso+W_aniso+W_act
        !  with W_act=(1/sqrt(I4)*P_max*f*alpha)M
        !C(5)=alpha...activation parameter [0,1]
        IF(rCauchyGreen(1,1) > 1.0_DP) THEN ! only in the tension range
          piolaTensor2(1,1)=piolaTensor2(1,1)+C(3)/rCauchyGreen(1,1)*(rCauchyGreen(1,1)**(C(4)/2.0_DP)-1.0_DP)
        ENDIF
!        IF((SQRT(rCauchyGreen(1,1))>0.84_DP).AND.(SQRT(rCauchyGreen(1,1))<1.96_DP)) THEN
        if((SQRT(rCauchyGreen(1,1))>0.72_DP).AND.(SQRT(rCauchyGreen(1,1))<1.68_DP)) then
!          value=(-25.0_DP/4.0_DP*rCauchyGreen(1,1)/1.4_DP/1.4_DP + 25.0_DP/2.0_DP*SQRT(rCauchyGreen(1,1))/1.4_DP - 5.25_DP) !f
          value=(-25.0_DP/4.0_DP*rCauchyGreen(1,1)/1.2_DP/1.2_DP + 25.0_DP/2.0_DP*SQRT(rCauchyGreen(1,1))/1.2_DP - 5.25_DP)
          value=value*(1.0_DP/SQRT(rCauchyGreen(1,1)))*20.0_DP*C(5)
          piolaTensor2(1,1)=piolaTensor2(1,1)+value
        ENDIF

      CASE(EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE)
        !Three additional terms for transversely isotropic (fibre-reinforced) materials (Markert, B., W. Ehlers, and N. Karajan.
        !A general polyconvex strain-energy function for fiber-reinforced materials.
        !Proceedings in Applied Mathematics and Mechanics 5.1 (2005): 245-246.)
        ! W_aniso=c3*(sqrt(I4)^(c4-2)-1/I4)M_1 + c5*(sqrt(I4)^(c6-2)-1/I4)M_2 + c7*(sqrt(I4)^(c8-2)-1/I4)M_3
        ! with M_1 being the mapping towards the fibre direction, here: I4=C_11
        !C(3)=c3...polynomial coefficient
        !C(4)=c4...power coefficient
        !C(5)=c5...polynomial coefficient
        !C(6)=c6...power coefficient
        !C(7)=c7...polynomial coefficient
        !C(8)=c8...power coefficient
        IF(rCauchyGreen(1,1) > 1.0_DP) THEN ! only in the tension range
          piolaTensor2(1,1)=piolaTensor2(1,1)+C(3)/rCauchyGreen(1,1)*(rCauchyGreen(1,1)**(C(4)/2.0_DP)-1.0_DP)
        ENDIF
        IF(rCauchyGreen(2,2) > 1.0_DP) THEN
          piolaTensor2(2,2)=piolaTensor2(2,2)+C(5)/rCauchyGreen(2,2)*(rCauchyGreen(2,2)**(C(6)/2.0_DP)-1.0_DP)
        ENDIF
        IF(rCauchyGreen(3,3) > 1.0_DP) THEN
          piolaTensor2(3,3)=piolaTensor2(3,3)+C(7)/rCauchyGreen(3,3)*(rCauchyGreen(3,3)**(C(8)/2.0_DP)-1.0_DP)
        ENDIF

      CASE(EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE)
        !Three additional terms for transversely isotropic (fibre-reinforced) materials (Markert, B., W. Ehlers, and N. Karajan.
        !A general polyconvex strain-energy function for fiber-reinforced materials.
        !Proceedings in Applied Mathematics and Mechanics 5.1 (2005): 245-246.)
        ! W_aniso=c3*(sqrt(I4)^(c4-2)-1/I4)M_1 + c5*(sqrt(I4)^(c6-2)-1/I4)M_2 + c7*(sqrt(I4)^(c8-2)-1/I4)M_3
        ! with M_1 being the mapping towards the fibre direction, here: I4=C_11
        !C(3)=c3...polynomial coefficient
        !C(4)=c4...power coefficient
        !C(5)=c5...polynomial coefficient
        !C(6)=c6...power coefficient
        !C(7)=c7...polynomial coefficient
        !C(8)=c8...power coefficient
        !C(9)=lambda_opt...optimal fibre stretch
        !C(10)=P_max...maximum active tension
        !C(11)=alpha...activation parameter [0 1]
        !C(12)=K_rfe...stiffness of the residual force enhancement
        IF(rCauchyGreen(1,1) > 1.0_DP) THEN ! only in the tension range
          piolaTensor2(1,1)=piolaTensor2(1,1)+C(3)/rCauchyGreen(1,1)*(rCauchyGreen(1,1)**(C(4)/2.0_DP)-1.0_DP)
        ENDIF
        IF(rCauchyGreen(2,2) > 1.0_DP) THEN
          piolaTensor2(2,2)=piolaTensor2(2,2)+C(5)/rCauchyGreen(2,2)*(rCauchyGreen(2,2)**(C(6)/2.0_DP)-1.0_DP)
        ENDIF
        IF(rCauchyGreen(3,3) > 1.0_DP) THEN
          piolaTensor2(3,3)=piolaTensor2(3,3)+C(7)/rCauchyGreen(3,3)*(rCauchyGreen(3,3)**(C(8)/2.0_DP)-1.0_DP)
        ENDIF

        value1=SQRT(rCauchyGreen(1,1))/C(9) !lambda/lambda_opt
        IF((value1>0.7_DP).AND.(value1<1.3_DP)) THEN
          !active force-length relation
          value=(-11.1111_DP*value1*value1+22.2222_DP*value1-10.1111_DP)
          !multiply by P_max and alpha, divide by lambda
          value=value*C(10)*C(11)/SQRT(rCauchyGreen(1,1))
        ELSE
          value=0.0_DP
        ENDIF
        !alpha*K_rfe*(lambda-lambda_start)/lambda
        !TODO make lambda_start variable --> independent field
        value2=C(11)*C(12)*(SQRT(rCauchyGreen(1,1))-1) !stretch and compression!!!
        value=value+value2/SQRT(rCauchyGreen(1,1))
        piolaTensor2(1,1)=piolaTensor2(1,1)+value

      END SELECT


    CASE(EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE)
      !Equations set for transversely isotropic (fibre-reinforced), active contractible bodies consitisting of two materials
      ! The local portion between them is defined by the parameter trans
      ! Material 1 is active contractible, material 2 is only passive
      !W=W_iso+W_aniso+W_act
      ! where the three parts are adopted from above (iso Mooney-Rivlin, aniso Markert, active part)
      !Markert, B., W. Ehlers, and N. Karajan.
      !A general polyconvex strain-energy function for fiber-reinforced materials.
      !Proceedings in Applied Mathematics and Mechanics 5.1 (2005): 245-246.)

      !C(1)=c1_m1...Mooney Rivlin parameter material 1
      !C(2)=c2_m1...Mooney Rivlin parameter material 1
      !C(3)=c4_m1...polynomial coefficient (Markert model) material 1
      !C(4)=c5_m1...power coefficient (Markert model) material 1
      !C(5)=c1_m2...Mooney Rivlin parameter material 2
      !C(6)=c2_m2...Mooney Rivlin parameter material 2
      !C(7)=c4_m2...polynomial coefficient (Markert model) material 2
      !C(8)=c5_m2...power coefficient (Markert model) material 2
      !C(9)=alpha...activation parameter [0,1]
      !C(10)=trans...transition parameter [0,1] for the portion between the two materials
      !C(11)=P_max...maximum isometric stress

      !Weighting the Mooney Rivlin parameters and obtaining resulting c1 and c2
      value1=C(1)*C(10)+C(5)*(1.0_DP-C(10))
      value2=C(2)*C(10)+C(6)*(1.0_DP-C(10))

      !Mooney-Rivlin for the isotropic part
      piolaTensor2(1,1)=2.0_DP*(value1+value2*(rCauchyGreen(2,2)+rCauchyGreen(3,3))+P*piolaDeformation(1,1))
      piolaTensor2(1,2)=2.0_DP*(     value2*(-rCauchyGreen(2,1))        +P*piolaDeformation(1,2))
      piolaTensor2(1,3)=2.0_DP*(     value2*(-rCauchyGreen(3,1))        +P*piolaDeformation(1,3))
      piolaTensor2(2,1)=piolaTensor2(1,2)
      piolaTensor2(2,2)=2.0_DP*(value1+value2*(rCauchyGreen(3,3)+rCauchyGreen(1,1))+P*piolaDeformation(2,2))
      piolaTensor2(2,3)=2.0_DP*(     value2*(-rCauchyGreen(3,2))        +P*piolaDeformation(2,3))
      piolaTensor2(3,1)=piolaTensor2(1,3)
      piolaTensor2(3,2)=piolaTensor2(2,3)
      piolaTensor2(3,3)=2.0_DP*(value1+value2*(rCauchyGreen(1,1)+rCauchyGreen(2,2))+P*piolaDeformation(3,3))

      !passive anisotropic part -- only in the tension range (Markert)
      IF(rCauchyGreen(1,1) > 1.0_DP) THEN
        value1=C(3)/rCauchyGreen(1,1)*(rCauchyGreen(1,1)**(C(4)/2.0_DP)-1.0_DP)
        value2=C(7)/rCauchyGreen(1,1)*(rCauchyGreen(1,1)**(C(8)/2.0_DP)-1.0_DP)
        piolaTensor2(1,1)=piolaTensor2(1,1)+(value1*C(10)+value2*(1.0_DP-C(10)))
      ENDIF

      !active part
      IF((SQRT(rCauchyGreen(1,1))>0.84_DP).AND.(SQRT(rCauchyGreen(1,1))<1.96_DP)) THEN
        value=(-25.0_DP/4.0_DP*rCauchyGreen(1,1)/1.4_DP/1.4_DP + 25.0_DP/2.0_DP*SQRT(rCauchyGreen(1,1))/1.4_DP - 5.25_DP)
        value=value*(1.0_DP/SQRT(rCauchyGreen(1,1)))*C(9)*C(10)*C(11)
        piolaTensor2(1,1)=piolaTensor2(1,1)+value
      ENDIF

    CASE(EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE)
      !Form of constitutive model is:
      ! W=c1/2 (e^(c2*(I1-3)) - 1)
      ! S = 2*dW/dC + 2pC^-1
      piolaTensor2=C(1)*C(2)*EXP(C(2)*(rCauchyGreen(1,1)+rCauchyGreen(2,2)+rCauchyGreen(3,3)-3.0_DP))*identityMat+2.0_DP*P* &
        & piolaDeformation
    CASE(EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE)
      !C(1)=Mooney Rivlin parameter
      !C(2)=Mooney Rivlin parameter
      !C(3)=K
      !C(4)=M, Biot modulus
      !C(5)=b, skeleton parameter
      !C(6)=p0, reference pressure

      P=darcyDependentInterpPoint%values(1,NO_PART_DERIV) !Fluid pressure
      CALL MatrixTranspose(rCauchyGreen,rCauchyGreenT,err,error,*999)
      I1=rCauchyGreen(1,1)+rCauchyGreen(2,2)+rCauchyGreen(3,3)
      temp=MATMUL(rCauchyGreen,rCauchyGreen)
      I2=0.5_DP*(I1**2.0_DP-temp(1,1)-temp(2,2)-temp(3,3))

      CALL FiniteElasticity_EvaluateChapelleFunction(Jznu,ffact,dfdJfact,err,error,*999)

      piolaTensor2=2.0_DP*C(1)*Jznu**(-2.0_DP/3.0_DP)*(identityMat-(1.0_DP/3.0_DP)*I1*piolaDeformation)
      piolaTensor2=piolaTensor2+2.0_DP*C(2)*Jznu**(-4.0_DP/3.0_DP)*(I1*identityMat-rCauchyGreenT- &
        & (2.0_DP/3.0_DP)*I2*piolaDeformation)
      piolaTensor2=piolaTensor2+(C(3)-C(4)*C(5)**2)*(Jznu-1.0_DP)*piolaDeformation
      piolaTensor2=piolaTensor2-C(5)*(P-C(6))*Jznu*piolaDeformation
      piolaTensor2=piolaTensor2+0.5_DP*((P-C(6))**2/C(4))*(dfdJfact/(ffact**2))*Jznu*piolaDeformation
    CASE(EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE)
      ! See Holmes MH, Mow VC. The nonlinear characteristics of soft gels and hydrated connective tissues in ultrafiltration.
      ! Journal of Biomechanics. 1990;23(11):1145-1156. DOI: 10.1016/0021-9290(90)90007-P
      ! The form of constitutive relation is:
      ! sigma = sigma^s + sigma^f
      ! sigma^f = -phi^f p I
      ! sigma^s = -phi^s p I + rho_0^s sigma^s_E
      ! sigma^s_E is the effective Cauchy stress obtained by differentiating
      ! the free energy function to get the second Piola-Kirchoff stress tensor:
      ! rho_0^s W^s = c0 exp(c1(I1 - 3) + c2(I2 - 3)) / (I_3^(c1 + 2c2))
      ! Rather than add the "phi^s p I" term to the Cauchy stress, we add it here as "phi^s p J C^-1"
      ! We also set rho_0^s = the solid density * initial solidity, and move the solidity
      ! inside the strain energy density function
      !
      ! c0 = C(1)
      ! c1 = C(2)
      ! c2 = C(3)
      ! phi^s_0 = C(4)

      CALL MatrixTranspose(rCauchyGreen,rCauchyGreenT,err,error,*999)
      CALL MatrixTranspose(piolaDeformation,piolaDeformationT,err,error,*999)
      I1=rCauchyGreen(1,1)+rCauchyGreen(2,2)+rCauchyGreen(3,3)
      temp=MATMUL(rCauchyGreen,rCauchyGreen)
      I2=0.5_DP*(I1**2.0_DP-temp(1,1)-temp(2,2)-temp(3,3))
      !I3 already defined

      tempTerm=2.0_DP*C(4)*C(1)*EXP(C(2)*(I1 - 3.0_DP) + C(3)*(I2 - 3.0_DP)) / (I3**(C(2)+2.0_DP*C(3)))
      piolaTensor2=C(2)*tempTerm*identityMat + C(3)*tempTerm*(I1*identityMat-rCauchyGreenT) - (C(2)+2.0_DP*C(3))*tempTerm* &
        & piolaDeformationT
      piolaTensor2=piolaTensor2 - darcyDependentInterpPoint%values(1,NO_PART_DERIV)*Jznu*piolaDeformation

    CASE(EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE)
      ! See Holmes MH, Mow VC. The nonlinear characteristics of soft gels and hydrated connective tissues in ultrafiltration.
      ! Journal of Biomechanics. 1990;23(11):1145-1156. DOI: 10.1016/0021-9290(90)90007-P
      ! The form of constitutive relation is:
      ! sigma = sigma^s + sigma^f
      ! sigma^f = -phi^f p I
      ! sigma^s = -phi^s p I + rho_0^s sigma^s_E
      ! sigma^s_E is the effective Cauchy stress obtained by differentiating
      ! the free energy function to get the second Piola-Kirchoff stress tensor:
      ! rho_0^s W^s = c0 exp(c1(I1 - 3) + c2(I2 - 3)) / (I_3^(c1 + 2c2))
      ! Rather than add the "phi^s p I" term to the Cauchy stress, we add it here as "phi^s p J C^-1"
      ! We also set rho_0^s = the solid density * initial solidity, and move the solidity
      ! inside the strain energy density function
      !
      ! c0 = C(1)
      ! c1 = C(2)
      ! c2 = C(3)
      ! phi^s_0 = C(4)
      ! alpha = C(5) (activation level)
      ! P_max = C(6) (maximum isometric active stress)

      CALL MatrixTranspose(rCauchyGreen,rCauchyGreenT,err,error,*999)
      CALL MatrixTranspose(piolaDeformation,piolaDeformationT,err,error,*999)
      I1=rCauchyGreen(1,1)+rCauchyGreen(2,2)+rCauchyGreen(3,3)
      temp=MATMUL(rCauchyGreen,rCauchyGreen)
      I2=0.5_DP*(I1**2.0_DP-temp(1,1)-temp(2,2)-temp(3,3))
      !I3 already defined

      tempTerm=2.0_DP*C(4)*C(1)*EXP(C(2)*(I1 - 3.0_DP) + C(3)*(I2 - 3.0_DP)) / (I3**(C(2)+2.0_DP*C(3)))
      piolaTensor2=C(2)*tempTerm*identityMat + C(3)*tempTerm*(I1*identityMat-rCauchyGreenT) - (C(2)+2.0_DP*C(3))*tempTerm* &
        & piolaDeformationT
      piolaTensor2=piolaTensor2 - darcyDependentInterpPoint%values(1,NO_PART_DERIV)*Jznu*piolaDeformation

      IF((SQRT(rCauchyGreen(1,1))>0.72_DP).AND.(SQRT(rCauchyGreen(1,1))<1.68_DP)) THEN
        value=(-25.0_DP/4.0_DP*rCauchyGreen(1,1)/1.2_DP/1.2_DP + 25.0_DP/2.0_DP*SQRT(rCauchyGreen(1,1))/1.2_DP - 5.25_DP)
      ELSE
        value=0.0_DP
      END IF

      piolaTensor2(1,1) = piolaTensor2(1,1) + 1.0_DP/SQRT(rCauchyGreen(1,1))*C(5)*C(6)*value

    CASE(EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE)
    ! For of constitutive model is:
    ! W = 0.5lambda*tr(E)^2 + mu*tr(E^2)
    ! S = dW/dE = lambda*tr(E)Identity + 2muE
      piolaTensor2(1,3)=(2.0_DP*C(2)*greenLagrangeStrain(1,3))+(2.0_DP*P*piolaDeformation(1,3))
      piolaTensor2(2,3)=(2.0_DP*C(2)*greenLagrangeStrain(2,3))+(2.0_DP*P*piolaDeformation(2,3))
      piolaTensor2(3,1)=piolaTensor2(1,3)
      piolaTensor2(3,2)=piolaTensor2(2,3)
      piolaTensor2(3,3)=C(1)*(greenLagrangeStrain(1,1)+greenLagrangeStrain(2,2)+greenLagrangeStrain(3,3))+ &
        & (2.0_DP*greenLagrangeStrain(3,3)*C(2)+(2.0_DP*P*piolaDeformation(3,3)))

      piolaTensor2(1,1)=C(1)*(greenLagrangeStrain(1,1)+greenLagrangeStrain(2,2)+greenLagrangeStrain(3,3))+ &
        & (2.0_DP*greenLagrangeStrain(1,1)*C(2)+(2.0_DP*P*piolaDeformation(1,1)))
      piolaTensor2(1,2)=(2.0_DP*C(2)*greenLagrangeStrain(1,2))+(2.0_DP*P*piolaDeformation(1,2))
      piolaTensor2(2,1)=piolaTensor2(1,2)
      piolaTensor2(2,2)=C(1)*(greenLagrangeStrain(1,1)+greenLagrangeStrain(2,2)+greenLagrangeStrain(3,3))+ &
        & (2.0_DP*greenLagrangeStrain(2,2)*C(2)+(2.0_DP*P*piolaDeformation(2,2)))

      CALL Field_ParameterSetGetLocalGaussPoint(equationsSet%INDEPENDENT%independentField, &
        &  FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointNumber,elementNumber,1,activeStress11, &
        & err,error,*999) ! get the independent field stress value

      CALL Field_ParameterSetGetLocalGaussPoint(equationsSet%INDEPENDENT%independentField, &
        &  FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointNumber,elementNumber,2,activeStress22, &
        & err,error,*999) ! get the independent field stress value

      CALL Field_ParameterSetGetLocalGaussPoint(equationsSet%INDEPENDENT%independentField, &
        &  FIELD_U_VARIABLE_TYPE, FIELD_VALUES_SET_TYPE,gaussPointNumber,elementNumber,3,activeStress33, &
        & err,error,*999) ! get the independent field stress value

      piolaTensor2(1,1)=piolaTensor2(1,1)+activeStress11
      piolaTensor2(2,2)=piolaTensor2(2,2)+activeStress22
      piolaTensor2(3,3)=piolaTensor2(3,3)+activeStress33

    CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE)
      !Form of constitutive model is:
      ! W=c1/2 (e^Q - 1)
      ! where Q=2c2(E11+E22+E33)+c3(E11^2)+c4(E22^2+E33^2+E23^2+E32^2)+c5(E12^2+E21^2+E31^2+E13^2)
      ! with E expressed in fibre coordinates

      tempTerm=C(1)*EXP(2.0*C(2)*(greenLagrangeStrain(1,1)+greenLagrangeStrain(2,2)+greenLagrangeStrain(3,3))+C(3)* &
        & greenLagrangeStrain(1,1)**2+C(4)*(greenLagrangeStrain(2,2)**2+greenLagrangeStrain(3,3)**2+ &
        & 2.0_DP*greenLagrangeStrain(2,3)**2)+C(5)*2.0_DP*(greenLagrangeStrain(1,2)**2+greenLagrangeStrain(1,3)**2))
      piolaTensor2(1,1)=(C(2)+C(3)*greenLagrangeStrain(1,1))*tempTerm+2.0_DP*P*piolaDeformation(1,1)
      piolaTensor2(1,2)=C(5)*greenLagrangeStrain(1,2)*tempTerm+2.0_DP*P*piolaDeformation(1,2)
      piolaTensor2(1,3)=C(5)*greenLagrangeStrain(1,3)*tempTerm+2.0_DP*P*piolaDeformation(1,3)
      piolaTensor2(2,1)=piolaTensor2(1,2)
      piolaTensor2(2,2)=(C(2)+C(4)*greenLagrangeStrain(2,2))*tempTerm+2.0_DP*P*piolaDeformation(2,2)
      piolaTensor2(2,3)=C(4)*greenLagrangeStrain(2,3)*tempTerm+2.0_DP*P*piolaDeformation(2,3)
      piolaTensor2(3,1)=piolaTensor2(1,3)
      piolaTensor2(3,2)=piolaTensor2(2,3)
      piolaTensor2(3,3)=(C(2)+C(4)*greenLagrangeStrain(3,3))*tempTerm+2.0_DP*P*piolaDeformation(3,3)
    CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE,EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE)
      ! W=C1/2*exp*(Q) + p(J-1)
      ! Q=C2*greenLagrangeStrain(1,1)^2 + C3*(greenLagrangeStrain(2,2)^2+greenLagrangeStrain(3,3)^2+ &
      !  & 2*greenLagrangeStrain(2,3)*greenLagrangeStrain(3,2)) + 2*C4*(greenLagrangeStrain(1,2)*greenLagrangeStrain(2,1)+ &
      !  & greenLagrangeStrain(1,3)*greenLagrangeStrain(3,1))
      Q=C(2)*greenLagrangeStrain(1,1)**2 + C(3)*(greenLagrangeStrain(2,2)**2+greenLagrangeStrain(3,3)**2+ &
        & 2.0_DP*greenLagrangeStrain(2,3)**2) + 2.0_DP*C(4)*(greenLagrangeStrain(1,2)**2+greenLagrangeStrain(1,3)**2)
      tempTerm=0.5_DP*C(1)*exp(Q) ! iso term
      piolaTensor2(1,1) = 2.0_DP*C(2) * greenLagrangeStrain(1,1)
      piolaTensor2(2,2) = 2.0_DP*C(3) * greenLagrangeStrain(2,2)
      piolaTensor2(3,3) = 2.0_DP*C(3) * greenLagrangeStrain(3,3)
      piolaTensor2(1,2) = 2.0_DP*C(4) * greenLagrangeStrain(1,2)
      piolaTensor2(2,1) = piolaTensor2(1,2)
      piolaTensor2(1,3) = 2.0_DP*C(4) * greenLagrangeStrain(1,3)
      piolaTensor2(3,1) = piolaTensor2(1,3)
      piolaTensor2(3,2) = 2.0_DP*C(3) * greenLagrangeStrain(2,3)
      piolaTensor2(2,3) = piolaTensor2(3,2)
      piolaTensor2 = piolaTensor2 * tempTerm
      ! pressure terms
!
! TEMP DURING MERGE
!
!      piolaTensor2 = piolaTensor2 + 2.0_DP*p*Jznu*piolaDeformation   ! is Jznu required here, or is it omitted everywhere else?
!
!      IF(equationsSet%SPECIFICATION(3)==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE) THEN
!        !the active stress is stored inside the independent field that has been set up in the user program.
!        !for better generality we could set up 3 components in independent field for 3 different active stress components,
!        !but only one component is implemented so far for fibre active tension.
!        CALL Field_VariableGet(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
!        DO i=1,fieldVariable%numberOfComponents
!          dofIdx=fieldVariable%COMPONENTS(i)%paramToDOFMap%gaussPointParam2DOFMap% &
!            & gaussPoints(gaussPointNumber,elementNumber)
!          CALL Field_ParameterSetGetLocalDOF(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE, &
!            & FIELD_VALUES_SET_TYPE,dofIdx,value,err,error,*999)
!          piolaTensor2(1,1)=piolaTensor2(1,1)+value
!        ENDDO
!      ENDIF
      !piolaTensor2 = piolaTensor2 + 2.0_DP*p*Jznu*piolaDeformation   ! is Jznu required here, or is it omitted everywhere else?
      IF(equationsSet%specification(3)==EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE) THEN
        pressureComponent=geometricInterpPoint%interpolationParameters%fieldVariable%numberOfComponents
        P=geometricInterpPoint%values(pressureComponent,NO_PART_DERIV)
      ELSE
        pressureComponent=dependentInterpPoint%interpolationParameters%fieldVariable%numberOfComponents
        P=dependentInterpPoint%values(pressureComponent,NO_PART_DERIV)
      ENDIF 
      piolaTensor2 = piolaTensor2 + P*piolaDeformation   ! is Jznu required here, or is it omitted everywhere else?
      IF(equationsSetSubtype==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE) THEN
      !add active contraction stress value to the trace of the stress tensor - basically adding to hydrostatic pressure.
      !the active stress is stored inside the independent field that has been set up in the user program.
      !for generality we could set up 3 components in independent field for 3 different active stress components
        lambda = 1.0_DP
        !lambda(1) = SQRT(rCauchyGreen(1,1))
        CALL Field_VariableGet(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
        DO componentIdx=1,fieldVariable%numberOfComponents
          SELECT CASE(fieldVariable%COMPONENTS(componentIdx)%interpolationType)
          CASE(FIELD_CONSTANT_INTERPOLATION)
            value=0.1_DP
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            dofIdx=fieldVariable%COMPONENTS(componentIdx)%paramToDOFMap%gaussPointParam2DOFMap% &
              & gaussPoints(gaussPointNumber,elementNumber)
            CALL Field_ParameterSetGetLocalDOF(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_VALUES_SET_TYPE,dofIdx,value,err,error,*999)
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            value=independentInterpPoint%values(componentIdx,NO_PART_DERIV)
          CASE DEFAULT
            localError="This independent field variable interpolation type is not supported."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          piolaTensor2(componentIdx,componentIdx)=piolaTensor2(componentIdx,componentIdx)+ &
            & value*(1.0_DP+1.45_DP*(lambda(componentIdx)-1.0_DP))/dZdNu(componentIdx,componentIdx)
        ENDDO
      ENDIF
    CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE)
      ! W=a*(exp(b(I1-3))-1) + c*(exp(d(alpha-1)^2)-1)
      ! a=C(1), b=C(2), c=C(3), d=C(4)
      I1=rCauchyGreen(1,1)+rCauchyGreen(2,2)+rCauchyGreen(3,3)
      piolaTensor2(1,1)=C(1)*C(2)*EXP(C(2)*(I1-3))+ &
        & C(3)*2.0_DP*(SQRT(rCauchyGreen(1,1))-1)*C(4)*EXP(C(4)*(SQRT(rCauchyGreen(1,1))-1)**2)/(2*SQRT(rCauchyGreen(1,1)))+P* &
        & piolaDeformation(1,1)
      piolaTensor2(2,2)=C(1)*C(2)*EXP(C(2)*(I1-3))+P*piolaDeformation(2,2)
      piolaTensor2(3,3)=C(1)*C(2)*EXP(C(2)*(I1-3))+P*piolaDeformation(3,3)
      piolaTensor2(1,2)=P*piolaDeformation(1,2)
      piolaTensor2(1,3)=P*piolaDeformation(1,3)
      piolaTensor2(2,3)=P*piolaDeformation(2,3)
      piolaTensor2(2,1)=piolaTensor2(1,2)
      piolaTensor2(3,1)=piolaTensor2(1,3)
      piolaTensor2(3,2)=piolaTensor2(2,3)
      piolaTensor2=piolaTensor2*2.0_DP
    CASE(EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE,EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE) !added by Robert 2010-01-23
      !Form of constitutive model is:
      ! W=a/2 (e^Q - 1)
      ! where Q=[b_ff 2b_fs 2b_fn b_ss 2b_sn b_nn]'* [E_ff E_fs E_fn E_ss E_sn E_nn].^2;
      ! f,s,n denotes the fibre sheet and sheet-normal direction
      a = materialsInterpPoint%values(1,1)
      B(1,1) = materialsInterpPoint%values(1+1,1)
      B(1,2) = materialsInterpPoint%values(1+2,1)
      B(1,3) = materialsInterpPoint%values(1+3,1)
      B(2,1) = B(1,2);
      B(2,2) = materialsInterpPoint%values(1+4,1)
      B(2,3) = materialsInterpPoint%values(1+5,1)
      B(3,1) = B(1,3);
      B(3,2) = B(2,3);
      B(3,3) = materialsInterpPoint%values(1+6,1)
      Q = 0.0_DP;
      DO i=1,3,1
       DO j=1,3,1
         IF (i==j) THEN
              greenLagrangeStrain(i,j) = 0.5_DP * (rCauchyGreen(i,j)-1);
         ELSE
              greenLagrangeStrain(i,j) = 0.5_DP * rCauchyGreen(i,j);
         ENDIF
         Q = Q + B(i,j) * greenLagrangeStrain(i,j) * greenLagrangeStrain(i,j)
       ENDDO
      ENDDO
      Q = exp(Q);
      DO i=1,3,1
       DO j=1,3,1
         piolaTensor2(i,j)=a*B(i,j)*greenLagrangeStrain(i,j)*Q + p*piolaDeformation(i,j);
       ENDDO
      ENDDO

      IF(equationsSetSubtype == EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE) THEN
        CALL FiniteElasticity_PiolaAddActiveContraction(equationsSet%equations%interpolation%independentField, &
          & equationsSet%equations%interpolation%materialsField,equationsSet%currentTime,equationsSet%deltaTime, &
          & piolaTensor2(1,1),greenLagrangeStrain(1,1),elementNumber,gaussPointNumber,err,error,*999)
      ENDIF
    CASE (EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE,EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE, &
      & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE,EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE)
      !Form of constitutive model is:
      ! W=c1*(I1-3)+c2*(I2-3)+c3*(J-1)^2   (this is actually nearly incompressible)
      C(1)=materialsInterpPoint%values(1,1)
      C(2)=materialsInterpPoint%values(2,1)

      piolaTensor2(1,1)=C(1)+C(2)*(rCauchyGreen(2,2)+rCauchyGreen(3,3))
      piolaTensor2(1,2)=C(2)*(-rCauchyGreen(2,1))
      piolaTensor2(1,3)=C(2)*(-rCauchyGreen(3,1))
      piolaTensor2(2,1)=piolaTensor2(1,2)
      piolaTensor2(2,2)=C(1)+C(2)*(rCauchyGreen(3,3)+rCauchyGreen(1,1))
      piolaTensor2(2,3)=C(2)*(-rCauchyGreen(3,2))
      piolaTensor2(3,1)=piolaTensor2(1,3)
      piolaTensor2(3,2)=piolaTensor2(2,3)
      piolaTensor2(3,3)=C(1)+C(2)*(rCauchyGreen(1,1)+rCauchyGreen(2,2))
      piolaTensor2=piolaTensor2*2.0_DP

      IF(diagnostics1) THEN
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  C(1) = ",C(1),err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  C(2) = ",C(2),err,error,*999)
        CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
          & 3,3,rCauchyGreen,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    rCauchyGreen','(",I1,",:)',' :",3(X,E13.6))', &
          & '(17X,3(X,E13.6))',err,error,*999)
      ENDIF

      IF(equationsSetSubtype==EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE) THEN

        CALL Field_ParameterSetGetLocalGaussPoint(equationsSet%INDEPENDENT%independentField, &
          &  FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointNumber,elementNumber,1,activeStress11, &
          & err,error,*999) ! get the independent field stress value

        CALL Field_ParameterSetGetLocalGaussPoint(equationsSet%INDEPENDENT%independentField, &
          &  FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointNumber,elementNumber,2,activeStress22, &
          & err,error,*999) ! get the independent field stress value

        CALL Field_ParameterSetGetLocalGaussPoint(equationsSet%INDEPENDENT%independentField, &
          &  FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointNumber,elementNumber,3,activeStress33, &
          & err,error,*999) ! get the independent field stress value

        piolaTensor2(1,1)=piolaTensor2(1,1)+activeStress11
        piolaTensor2(2,2)=piolaTensor2(2,2)+activeStress22
        piolaTensor2(3,3)=piolaTensor2(3,3)+activeStress33
      ENDIF
      IF(equationsSetSubtype==EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE) THEN
        C(3)=materialsInterpPoint%values(3,1)
        piolaTensor2=piolaTensor2+2.0_DP*C(3)*(I3-SQRT(I3))*piolaDeformation
      ELSEIF(equationsSetSubtype==EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE.OR. &
        & equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE .OR. &
        & equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE) THEN
        SELECT CASE (equationsSetSubtype)
        CASE (EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE) !Nearly incompressible
          C(3)=materialsInterpPoint%values(3,1)
          !Starting point for this models is above compressible form of 2nd PK tensor
          !Adjust for the modified Ciarlet-Geymonat expression: Eq.(22) of the INRIA paper
          ! Question is: What deviation is to be penalized : (J-1) or (J-1-m/rho) ??? Probably the latter !
          ! However, m/rho is a given 'constant' and, upon differentiation, drops out.
          ! But it is important to retain I3 = J^2, since J ~ 1 + m/rho /= 1
          piolaTensor2=piolaTensor2+C(3)*(SQRT(I3)-1.0_DP)*piolaDeformation
          darcyMassIncreaseEntry = 5 !fifth entry
        CASE (EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
           &  EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE) !Incompressible
          !Constitutive model: W=c1*(I1-3)+c2*(I2-3)+p*(I3-1)
          ! The term 'p*(I3-1)' gives rise to: '2p I3 piolaDeformation'
          ! Retain I3 = J^2, since J ~ 1 + m/rho /= 1
!         CASE (EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE)
          !Constitutive model: W=C1*(J1-3)+C2*(J2-3)+C3*(J-1)^2+lambda.(J-1-m/rho)
          !J1 and J2 are the modified invariants, adjusted for volume change (J1=I1*J^(-2/3), J2=I2*J^(-4/3))
          !Strictly speaking this law isn't for an incompressible material, but the fourth equation in the elasticity
          !is used to satisfy a subtly different constraint, which is to require the solid portion of the poroelastic
          !material retains its volume. (This law is applied on the whole pororous body).

          piolaTensor2=0.0_DP
          temp=0.0_DP

          C(1)=materialsInterpPoint%values(1,1)
          C(2)=materialsInterpPoint%values(2,1)
          C(3)=materialsInterpPoint%values(3,1)

          !J1 term: del(J1)/del(C)=J^(-2/3)*I-2/3*I_1*J^(-2/3)*C^-1
          tempTerm=Jznu**(-2.0_DP/3.0_DP)
          temp(1,1)=tempTerm
          temp(2,2)=tempTerm
          temp(3,3)=tempTerm
          I1=rCauchyGreen(1,1)+rCauchyGreen(2,2)+rCauchyGreen(3,3)
          piolaTensor2=C(1)* (temp-1.0_DP/3.0_DP*I1*tempTerm*piolaDeformation)

          !J2 term: del(J2)/del(C)=J^(-4/3)*del(I2)/del(C) -4/3*I_2*J^(-4/3)*C^-1
          temp=MATMUL(rCauchyGreen,rCauchyGreen)  ! C^2
          I2=0.5_DP*(I1**2.0_DP-(temp(1,1)+temp(2,2)+temp(3,3)))
          tempTerm=Jznu**(-4.0_DP/3.0_DP)
          !temp is now del(I2)/del(C)
          temp(1,1)=rCauchyGreen(2,2)+rCauchyGreen(3,3)
!           temp(1,2)=-2.0_DP*rCauchyGreen(1,2)
          temp(1,2)=-1.0_DP*rCauchyGreen(1,2)
!           temp(1,3)=-2.0_DP*rCauchyGreen(1,3)
          temp(1,3)=-1.0_DP*rCauchyGreen(1,3)
          temp(2,1)=temp(1,2)
          temp(2,2)=rCauchyGreen(1,1)+rCauchyGreen(3,3)
!           temp(2,3)=-2.0_DP*rCauchyGreen(2,3)
          temp(2,3)=-1.0_DP*rCauchyGreen(2,3)
          temp(3,1)=temp(1,3)
          temp(3,2)=temp(2,3)
          temp(3,3)=rCauchyGreen(1,1)+rCauchyGreen(2,2)
          piolaTensor2=piolaTensor2+C(2)* (tempTerm*temp-2.0_DP/3.0_DP*I2*tempTerm*piolaDeformation)

          !J (det(F)) term: (2.C3.(J-1)+lambda)*J.C^-1
          piolaTensor2=piolaTensor2+(2.0_DP*C(3)*(Jznu-1.0_DP)+P)*Jznu*piolaDeformation

          !Don't forget, it's wrt C so there is a factor of 2 - but not for the pressure !!??
          piolaTensor2=2.0_DP*piolaTensor2


          darcyMassIncreaseEntry = 4 !fourth entry

        END SELECT

!         darcyMassIncrease = darcyDependentInterpPoint%values(darcyMassIncreaseEntry,NO_PART_DERIV)
! 
!         CALL FiniteElasticity_EvalChapellePiolaTensorAddition(rCauchyGreen,piolaDeformation,DARCY_MASS_INCREASE,piolaTensor2_ADDITION,err,error,*999)
! 
!         IF(diagnostics1) THEN
!           CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
!             & 3,3,piolaTensor2,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    piolaTensor2','(",I1,",:)',' :",3(X,E13.6))', &
!             & '(17X,3(X,E13.6))',err,error,*999)
!           CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
!             & 3,3,piolaTensor2_ADDITION, &
!             & WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    piolaTensor2_ADDITION','(",I1,",:)',' :",3(X,E13.6))', &
!             & '(17X,3(X,E13.6))',err,error,*999)
!         ENDIF
!
!         piolaTensor2 = piolaTensor2 + piolaTensor2_ADDITION
      ENDIF

    CASE (EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE, &
        & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE)
      !Form of the constitutive model is:
      ! W = a/(2*b)*exp[b*(I1-3)] + sum_(i=f,s)[H(I4i-1)*a_i/(2*b_i)*(exp[b_i*(I4i-1)^2]-1)] + a_fs/(2*b_fs)*(exp[b_fs*I8fs^2]-1)
      !where H is the Heaviside step function. Fibres only contribute stiffness if in tension.
      !Also assumed I3 = det(rCauchyGreen) = J^2 = 1.0  -  incompressible material
      !Assume directions: fibre f_0=[1 0 0], sheet s_0=[0 1 0], (sheet) normal n_0=[0 0 1]
      !Based on: Holzapfel, G. A., & Ogden, R. W. (2009). Constitutive modelling of passive myocardium: A structurally based
      !  framework for material characterization. Philosophical Transactions of the Royal Society A: Mathematical, Physical and
      !  Engineering Sciences, 367(1902), 3445-3475. doi:10.1098/rsta.2009.0091
      C(1)=materialsInterpPoint%values(1,1) !a
      C(2)=materialsInterpPoint%values(2,1) !b
      C(3)=materialsInterpPoint%values(3,1) !a_f
      C(4)=materialsInterpPoint%values(4,1) !a_s
      C(5)=materialsInterpPoint%values(5,1) !b_f
      C(6)=materialsInterpPoint%values(6,1) !b_s
      C(7)=materialsInterpPoint%values(7,1) !a_fs
      C(8)=materialsInterpPoint%values(8,1) !b_fs
      I1=rCauchyGreen(1,1)+rCauchyGreen(2,2)+rCauchyGreen(3,3)
      tempTerm=C(1)*EXP(C(2)*(I1-3.0_DP))
      piolaTensor2(1,1)=-P*piolaDeformation(1,1)+tempTerm
      IF(rCauchyGreen(1,1)>1.0_DP) THEN
        piolaTensor2(1,1)=piolaTensor2(1,1)+2.0_DP*C(3)*(rCauchyGreen(1,1)-1.0_DP)*EXP(C(5)*(rCauchyGreen(1,1)-1.0_DP)**2.0_DP)
      END IF
      piolaTensor2(1,2)=-P*piolaDeformation(1,2)+C(7)*rCauchyGreen(1,2)*EXP(C(8)*rCauchyGreen(1,2)**2.0_DP)
      piolaTensor2(1,3)=-P*piolaDeformation(1,3)
      piolaTensor2(2,1)=piolaTensor2(1,2)
      piolaTensor2(2,2)=-P*piolaDeformation(2,2)+tempTerm
      IF(rCauchyGreen(2,2)>1.0_DP) THEN
        piolaTensor2(2,2)=piolaTensor2(2,2)+2.0_DP*C(4)*(rCauchyGreen(2,2)-1.0_DP)*EXP(C(6)*(rCauchyGreen(2,2)-1.0_DP)**2.0_DP)
      END IF
      piolaTensor2(2,3)=-P*piolaDeformation(2,3)
      piolaTensor2(3,1)=piolaTensor2(1,3)
      piolaTensor2(3,2)=piolaTensor2(2,3)
      piolaTensor2(3,3)=-P*piolaDeformation(3,3)+tempTerm

      IF(equationsSetSubtype==EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE) THEN
      !add active contraction stress value to the trace of the stress tensor - basically adding to hydrostatic pressure.
      !the active stress is stored inside the independent field that has been set up in the user program.
      !for generality we could set up 3 components in independent field for 3 different active stress components
        CALL Field_VariableGet(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
        DO componentIdx=1,fieldVariable%numberOfComponents
          dofIdx=fieldVariable%COMPONENTS(componentIdx)%paramToDOFMap%gaussPointParam2DOFMap% &
            & gaussPoints(gaussPointNumber,elementNumber)
          CALL Field_ParameterSetGetLocalDOF(equationsSet%INDEPENDENT%independentField,FIELD_U_VARIABLE_TYPE, &
            & FIELD_VALUES_SET_TYPE,dofIdx,value,err,error,*999)
          piolaTensor2(componentIdx,componentIdx)=piolaTensor2(componentIdx,componentIdx)+value
        ENDDO
      ENDIF

    CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE)
      ! Form of constitutive model is:
      ! W = 0.5*lambda*tr(E)^2 + mu*tr(E^2) + p/2*(I3-1)^2
      ! S = dW/dE = lambda*tr(E)*I + 2*mu*E + p*J*C^(-1)
      !Calculate isochoric fictitious 2nd Piola tensor (in Voigt form)
      
      I1=greenLagrangeStrain(1,1)+greenLagrangeStrain(2,2)+greenLagrangeStrain(3,3)
      tempTerm1=C(2)*I1
      tempTerm2=2.0_DP*C(3)
      piolaTensor2(1,1)=tempTerm1+tempTerm2*greenLagrangeStrain(1,1)+P*piolaDeformation(1,1)
      piolaTensor2(1,2)=tempTerm2*greenLagrangeStrain(1,2)+P*piolaDeformation(1,2)
      piolaTensor2(1,3)=tempTerm2*greenLagrangeStrain(1,3)+P*piolaDeformation(1,3)
      piolaTensor2(2,2)=tempTerm1+tempTerm2*greenLagrangeStrain(2,2)+P*piolaDeformation(2,2)
      piolaTensor2(2,3)=tempTerm2*greenLagrangeStrain(2,3)+P*piolaDeformation(2,3)
      piolaTensor2(3,3)=tempTerm1+tempTerm2*greenLagrangeStrain(3,3)+P*piolaDeformation(3,3)
      piolaTensor2(2,1)=piolaTensor2(1,2)
      piolaTensor2(3,1)=piolaTensor2(1,3)
      piolaTensor2(3,2)=piolaTensor2(2,3)
     
    CASE(EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE)
      !Form of constitutive model is:
      ! W_hat=c1*(I1_hat-3)+c2*(I2_hat-3)+p*J*C^(-1)
      
      CALL MatrixTransposeProduct(dZdNu,dZdNu,rCauchyGreen,err,error,*999)      
      CALL Invert(rCauchyGreen,piolaDeformation,I3,err,error,*999)
     
      !Calculate isochoric fictitious 2nd Piola tensor (in Voigt form)
      I1=rCauchyGreen(1,1)+rCauchyGreen(2,2)+rCauchyGreen(3,3)
      tempTerm1=-2.0_DP*C(2)
      tempTerm2=2.0_DP*(C(1)+I1*C(2))
      piolaTensor2(1,1)=tempTerm1*rCauchyGreen(1,1)+tempTerm2+P*Jznu*piolaDeformation(1,1)
      piolaTensor2(2,2)=tempTerm1*rCauchyGreen(2,2)+tempTerm2+P*Jznu*piolaDeformation(2,2)
      piolaTensor2(3,3)=tempTerm1*rCauchyGreen(3,3)+tempTerm2+P*Jznu*piolaDeformation(3,3)
      piolaTensor2(1,2)=tempTerm1*rCauchyGreen(2,1)+P*Jznu*piolaDeformation(1,2)
      piolaTensor2(1,3)=tempTerm1*rCauchyGreen(3,1)+P*Jznu*piolaDeformation(1,3)
      piolaTensor2(2,3)=tempTerm1*rCauchyGreen(3,2)+P*Jznu*piolaDeformation(2,3)
      piolaTensor2(2,1)=piolaTensor2(1,2)
      piolaTensor2(3,1)=piolaTensor2(1,3)
      piolaTensor2(3,2)=piolaTensor2(2,3)
     
    CASE DEFAULT
      localError="The third equations set specification of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
        & " is not valid for a finite elasticity type of an elasticity equation set."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    CALL MatrixProduct(dZdNu,piolaTensor2,temp,err,error,*999)
    CALL MatrixProduct(temp,dZdNuT,cauchyTensor,err,error,*999)      
    cauchyTensor=cauchyTensor/Jznu
    IF(diagnostics1) THEN
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  elementNumber = ",elementNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  gaussPointIdx = ",gaussPointNumber,err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
        & 3,3,piolaTensor2,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    piolaTensor2','(",I1,",:)',' :",3(X,E13.6))', &
        & '(17X,3(X,E13.6))',err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3, &
        & 3,3,cauchyTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    cauchyTensor','(",I1,",:)',' :",3(X,E13.6))', &
        & '(17X,3(X,E13.6))',err,error,*999)
    ENDIF
    NULLIFY(C)

    EXITS("FiniteElasticity_GaussCauchyTensor")
    RETURN
999 ERRORSEXITS("FiniteElasticity_GaussCauchyTensor",err,error)
    RETURN 1
  END SUBROUTINE FiniteElasticity_GaussCauchyTensor

  !
  !================================================================================================================================
  !

  !>Evaluates the growth tensor at a given Gauss point and calculates the elastic part of the deformation gradient tensor
  SUBROUTINE FiniteElasticity_GrowthTensorCalculate(equationsSet,numberOfDimensions,deformationGradientTensor,growthValues, &
    & growthTensor,elasticDeformationGradientTensor,Jg,Je,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    REAL(DP), INTENT(IN) :: deformationGradientTensor(:,:) !<The full deformation gradient tensor
    REAL(DP), INTENT(IN) :: growthValues(:) !<The fibre, sheet and normal growth extensions.
    REAL(DP), INTENT(OUT) :: growthTensor(:,:) !<On output, the growth tensor
    REAL(DP), INTENT(OUT) :: elasticDeformationGradientTensor(:,:) !<On output, the elastic part of the deformation gradient tensor
    REAL(DP), INTENT(OUT) :: Jg !<On output, the Jacobian of the growth tensor
    REAL(DP), INTENT(OUT) :: Je !<On output, the Jacobian of the elastic tensor
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: esSpecification(3)
    REAL(DP) :: growthTensorInverse(SIZE(growthTensor,1),SIZE(growthTensor,2)),J
    
    ENTERS("FiniteElasticity_GrowthTensorCalculate",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)
    
    CALL IdentityMatrix(growthTensor,err,error,*999)
    IF(equationsSet%specification(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE.OR. &
      equationsSet%specification(3)==EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
      growthTensor(1,1)=growthValues(1)
      IF(numberofDimensions>1) THEN
        growthTensor(2,2)=growthValues(2)
        IF(numberOfDimensions>2) THEN
          growthTensor(3,3)=growthValues(3)
        ENDIF
      ENDIF
      !Calculate inverse growth deformation tensor, Fg^-1, Jg 
      CALL Invert(growthTensor,growthTensorInverse,Jg,err,error,*999)
      !Calculate elastic deformation tensor, Fe=F.(Fg)^-1.       
      CALL MatrixProduct(deformationGradientTensor,growthTensorInverse,elasticDeformationGradientTensor,err,error,*999)
    ELSE
      Jg=1.0_DP
      elasticDeformationGradientTensor=deformationGradientTensor
    ENDIF
    CALL Determinant(elasticDeformationGradientTensor,Je,err,error,*999)

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Growth information:",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Total deformation gradient tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3,3,3,deformationGradientTensor, &
        & WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    F','(",I1,",:)','  :",3(X,E13.6))','(13X,3(X,E13.6))',err,error,*999)
      CALL Determinant(deformationGradientTensor,J,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Determinant F, J = ",J,err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Elastic component of the deformation gradient tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3,3,3,elasticDeformationGradientTensor, &
        & WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    Fe','(",I1,",:)',' :",3(X,E13.6))','(13X,3(X,E13.6))',err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Determinant Fe, Je = ",Je,err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Growth component of the deformation gradient tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3,3,3,growthTensor, &
        & WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    Fg','(",I1,",:)',' :",3(X,E13.6))','(13X,3(X,E13.6))',err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Determinant Fg, Jg = ",Jg,err,error,*999)
    ENDIF
   
    EXITS("FiniteElasticity_GrowthTensorCalculate")
    RETURN
    999 ERRORSEXITS("FiniteElasticity_GrowthTensorCalculate",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_GrowthTensorCalculate

  !
  !================================================================================================================================
  !

  !>Evaluates the reference strain and deformation tensors given the deformation gradient tensor
  SUBROUTINE FiniteElasticity_ReferenceStrainTensors(numberOfDimensions,deformationGradientTensor,deformationGradientDeterminant, &
    & rightCauchyDeformationTensor,rightCauchyDeterminant,piolaDeformationTensor,greenLagrangeStrainTensor,err,error,*)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    REAL(DP), INTENT(IN) :: deformationGradientTensor(:,:) !<The deformation gradient tensor
    REAL(DP), INTENT(OUT) :: deformationGradientDeterminant !<On output, the determinant of the deformation gradient tensor
    REAL(DP), INTENT(OUT) :: rightCauchyDeformationTensor(:,:) !<On output, the right Cauchy deformation tensor, C
    REAL(DP), INTENT(OUT) :: rightCauchyDeterminant !<On output, the determinant of the right Cauchy deformation tensor
    REAL(DP), INTENT(OUT) :: piolaDeformationTensor(:,:) !<On output, the finger deformation tensor, B=C^-1
    REAL(DP), INTENT(OUT) :: greenLagrangeStrainTensor(:,:) !<On output, the Green-Lagrange strain tensor, E
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: i
    
    ENTERS("FiniteElasticity_ReferenceStrainTensors",err,error,*999)

    CALL MatrixTransposeProduct(deformationGradientTensor,deformationGradientTensor,rightCauchyDeformationTensor,err,error,*999)
    CALL Invert(rightCauchyDeformationTensor,piolaDeformationTensor,rightCauchyDeterminant,err,error,*999)
    CALL Determinant(deformationGradientTensor,deformationGradientDeterminant,err,error,*999)

    greenLagrangeStrainTensor=0.5_DP*rightCauchyDeformationTensor
    DO i=1,numberOfDimensions
      greenLagrangeStrainTensor(i,i)=greenLagrangeStrainTensor(i,i)-0.5_DP
    ENDDO !i
    
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Reference strain and deformation information:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of dimensions = ",numberOfDimensions,err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Deformation gradient tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,numberOfDimensions, &
        & numberOfDimensions,deformationGradientTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    F','(",I1,",:)', &
        & ' :",3(X,E13.6))','(12X,3(X,E13.6))',err,error,*999)
      CALL WriteStringFmtValue(DIAGNOSTIC_OUTPUT_TYPE,"    det F = ",deformationGradientDeterminant,'(E13.6)',err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Right Cauchy-Green deformation tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,numberOfDimensions, &
        & numberOfDimensions,rightCauchyDeformationTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    C','(",I1,",:)', &
        & ' :",3(X,E13.6))','(12X,3(X,E13.6))',err,error,*999)
      CALL WriteStringFmtValue(DIAGNOSTIC_OUTPUT_TYPE,"    det C = ",rightCauchyDeterminant,'(E13.6)',err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Piola deformation tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,numberOfDimensions, &
        & numberOfDimensions,piolaDeformationTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    B','(",I1,",:)', &
        & ' :",3(X,E13.6))','(12X,3(X,E13.6))',err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Green-Lagrange strain tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,numberOfDimensions, &
        & numberOfDimensions,greenLagrangeStrainTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    E','(",I1,",:)', &
        & ' :",3(X,E13.6))','(12X,3(X,E13.6))',err,error,*999)
    ENDIF
   
    EXITS("FiniteElasticity_ReferenceStrainTensors")
    RETURN
    999 ERRORSEXITS("FiniteElasticity_ReferenceStrainTensors",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_ReferenceStrainTensors

  !
  !================================================================================================================================
  !

  !>Evaluates the spatial strain and deformation tensors given the deformation gradient tensor
  SUBROUTINE FiniteElasticity_SpatialStrainTensors(numberOfDimensions,deformationGradientTensor,deformationGradientDeterminant, &
    & leftCauchyDeformationTensor,leftCauchyDeterminant,cauchyDeformationTensor,eulerAlmansiStrainTensor,err,error,*)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    REAL(DP), INTENT(IN) :: deformationGradientTensor(:,:) !<The deformation gradient tensor
    REAL(DP), INTENT(OUT) :: deformationGradientDeterminant !<On output, the determinant of the deformation gradient tensor
    REAL(DP), INTENT(OUT) :: leftCauchyDeformationTensor(:,:) !<On output, the left Cauchy deformation tensor, b
    REAL(DP), INTENT(OUT) :: leftCauchyDeterminant !<On output, the determinant of the left Cauchy deformation tensor
    REAL(DP), INTENT(OUT) :: cauchyDeformationTensor(:,:) !<On output, the Cauchy deformation tensor, c=b^-1
    REAL(DP), INTENT(OUT) :: eulerAlmansiStrainTensor(:,:) !<On output, the Euler-Almansi strain tensor, e
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: i
    
    ENTERS("FiniteElasticity_SpatialStrainTensors",err,error,*999)

    CALL MatrixProductTranspose(deformationGradientTensor,deformationGradientTensor,leftCauchyDeformationTensor,err,error,*999)
    CALL Invert(leftCauchyDeformationTensor,cauchyDeformationTensor,leftCauchyDeterminant,err,error,*999)
    CALL Determinant(deformationGradientTensor,deformationGradientDeterminant,err,error,*999)

    eulerAlmansiStrainTensor=-0.5_DP*cauchyDeformationTensor
    DO i=1,numberOfDimensions
      eulerAlmansiStrainTensor(i,i)=eulerAlmansiStrainTensor(i,i)+0.5_DP
    ENDDO !i
    
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Spatial strain and deformation information:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of dimensions = ",numberOfDimensions,err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Deformation gradient tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,numberOfDimensions, &
        & numberOfDimensions,deformationGradientTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    F','(",I1,",:)', &
        & ' :",3(X,E13.6))','(12X,3(X,E13.6))',err,error,*999)
      CALL WriteStringFmtValue(DIAGNOSTIC_OUTPUT_TYPE,"    det F = ",deformationGradientDeterminant,'(E13.6)',err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Left Cauchy-Green deformation tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,numberOfDimensions, &
        & numberOfDimensions,leftCauchyDeformationTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    b','(",I1,",:)', &
        & ' :",3(X,E13.6))','(12X,3(X,E13.6))',err,error,*999)
      CALL WriteStringFmtValue(DIAGNOSTIC_OUTPUT_TYPE,"    det b = ",leftCauchyDeterminant,'(E13.6)',err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Cauchy deformation tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,numberOfDimensions, &
        & numberOfDimensions,cauchyDeformationTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    c','(",I1,",:)', &
        & ' :",3(X,E13.6))','(12X,3(X,E13.6))',err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Euler-Almansi strain tensor:",err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,1,1,numberOfDimensions,numberOfDimensions, &
        & numberOfDimensions,eulerAlmansiStrainTensor,WRITE_STRING_MATRIX_NAME_AND_INDICES, '("    e','(",I1,",:)', &
        & ' :",3(X,E13.6))','(12X,3(X,E13.6))',err,error,*999)
    ENDIF
   
    EXITS("FiniteElasticity_SpatialStrainTensors")
    RETURN
    999 ERRORSEXITS("FiniteElasticity_SpatialStrainTensors",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_SpatialStrainTensors

  !
  !================================================================================================================================
  !

  !>Evaluates the Cauchy stress tensor at a given Gauss point
  SUBROUTINE FiniteElasticity_GaussStressTensor(equationsSet,numberOfDimensions,dependentInterpPoint,materialsInterpPoint, &
    & geometricInterpPoint,stressTensorV,dZdNu,Jznu,elementNumber,gaussPointNumber,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER, INTENT(IN) :: equationsSet !<A pointer to the equations set
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions in the equations set
    TYPE(FieldInterpolatedPointType), POINTER :: dependentInterpPoint !<A pointer to the dependent interpolated point
    TYPE(FieldInterpolatedPointType), POINTER :: materialsInterpPoint !<A pointer to the materials interpolated point
    TYPE(FieldInterpolatedPointType), POINTER :: geometricInterpPoint !<A pointer to the geometric interpolated point
    REAL(DP), INTENT(OUT) :: stressTensorV(:) !<On exit, the stress tensor in voight form
    REAL(DP), INTENT(IN) :: dZdNu(:,:) !<Deformation gradient tensor at the gauss point
    REAL(DP), INTENT(IN) :: Jznu !<Determinant of deformation gradient tensor (rCauchyGreen)
    INTEGER(INTG), INTENT(IN) :: elementNumber !<Element point number
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<Gauss point number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,dofIdx,esSpecification(3),numberOfIndependentComponents,pressureComponent
    REAL(DP) :: B(6),dQdE(6),dZdNuT(3,3),E(6),I1,I2,I3,identity(3,3),moddZdNu(3,3),moddZdNuT(3,3),oneThirdTrace,P, &
      & piolaDeformation(3,3),rCauchyGreen(3,3),rCauchyGreenSq(3,3),secondPiolaKirchoff(3,3),tempTerm1,tempTerm2,VALUE,wvPrime
    REAL(DP), POINTER :: C(:) !Parameters for constitutive laws
    TYPE(FieldType), POINTER :: independentField
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldInterpolatedPointType), POINTER :: geometricInterpolatedPoint
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_GaussStressTensor",err,error,*999)

    NULLIFY(fieldVariable,C)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)

    !rCauchyGreen = F'*F (deformed covariant or right cauchy deformation tensor, C)
    !piolaDeformation - deformed contravariant tensor; I3 = det(C)

    moddZdNu=dZdNu*Jznu**(-1.0_DP/3.0_DP)
    CALL MatrixTranspose(moddZdNu,moddZdNuT,err,error,*999)
    CALL MatrixProduct(moddZdNuT,moddZdNu,rCauchyGreen,err,error,*999)
    C=>materialsInterpPoint%values(:,NO_PART_DERIV)

    SELECT CASE(esSpecification(3))
    CASE(EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
      
      CALL MatrixTransposeProduct(dZdNu,dZdNu,rCauchyGreen,err,error,*999)
      CALL Invert(rCauchyGreen,piolaDeformation,I3,err,error,*999)

      NULLIFY(interpolationParameters)
      CALL FieldInterpolatedPoint_InterpolationParametersGet(dependentInterpPoint,interpolationParameters,err,error,*999)
      NULLIFY(fieldVariable)
      CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
      CALL FieldVariable_NumberOfComponentsGet(fieldVariable,pressureComponent,err,error,*999)
      
      P=dependentInterpPoint%values(pressureComponent,NO_PART_DERIV)
      !Form of constitutive model is:
      !W=c1*(I1-3)+c2*(I2-3)+p/2*(I3-1)

      !Calculate isochoric fictitious 2nd Piola tensor (in Voigt form)
      I1=rCauchyGreen(1,1)+rCauchyGreen(2,2)+rCauchyGreen(3,3)
      tempTerm1=-2.0_DP*C(2)
      tempTerm2=2.0_DP*(C(1)+I1*C(2))
      secondPiolaKirchoff(1,1)=tempTerm1*rCauchyGreen(1,1)+tempTerm2+P*piolaDeformation(1,1)*Jznu
      secondPiolaKirchoff(2,2)=tempTerm1*rCauchyGreen(2,2)+tempTerm2+P*piolaDeformation(2,2)*Jznu
      secondPiolaKirchoff(3,3)=tempTerm1*rCauchyGreen(3,3)+tempTerm2+P*piolaDeformation(3,3)*Jznu
      secondPiolaKirchoff(1,2)=tempTerm1*rCauchyGreen(1,2)+P*piolaDeformation(1,2)*Jznu
      secondPiolaKirchoff(1,3)=tempTerm1*rCauchyGreen(1,3)+P*piolaDeformation(1,3)*Jznu
      secondPiolaKirchoff(2,3)=tempTerm1*rCauchyGreen(2,3)+P*piolaDeformation(2,3)*Jznu
      
      IF(esSpecification(3)==EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE) THEN
        !add active contraction stress values
        !Be aware for modified dZdNu, should active contraction be added here? Normally should be okay as modified dZdNu and dZdNu
        !converge during the Newton iteration.
        NULLIFY(independentField)
        CALL EquationsSet_IndependentFieldGet(equationsSet,independentField,err,error,*999)
        NULLIFY(fieldVariable)
        CALL Field_VariableGet(independentField,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
        CALL FieldVariable_NumberOfComponentsGet(fieldVariable,numberOfIndependentComponents,err,error,*999)
        DO componentIdx=1,numberOfIndependentComponents
          CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,elementNumber,componentIdx,dofIdx,err,error,*999)
          CALL FieldVariable_ParameterSetGetLocalDOF(fieldVariable,FIELD_VALUES_SET_TYPE,dofIdx,value,err,error,*999)
          secondPiolaKirchoff(componentIdx,componentIdx)=secondPiolaKirchoff(componentIdx,componentIdx)+value
        ENDDO !componentIdx
      ENDIF

      !Convert to Voigt form
      CALL TensorToVoigt(3,[TENSOR_CONTRAVARIANT_INDEX,TENSOR_CONTRAVARIANT_INDEX],secondPiolaKirchoff,stressTensorV, &
        & err,error,*999)

      !Do push-forward of 2nd Piola tensor. 
      !CALL FiniteElasticity_PushStressTensor(stressTensor,moddZdNu,Jznu,err,error,*999)
      !!Calculate isochoric Cauchy tensor (the deviatoric part) and add the volumetric part (the hydrostatic pressure).
      !oneThirdTrace=sum(stressTensorV(1:3))/3.0_DP
      !stressTensorV(1:3)=stressTensorV(1:3)-oneThirdTrace+P
      
      CALL FiniteElasticity_PushStressTensor(stressTensorV,dZdNu,Jznu,err,error,*999)

    CASE(EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE)
      
      CALL MatrixTransposeProduct(dZdNu,dZdNu,rCauchyGreen,err,error,*999)
      CALL Invert(rCauchyGreen,piolaDeformation,I3,err,error,*999)
      CALL IdentityMatrix(identity,err,error,*999)

      !Form of constitutive model is: W_hat=c1*(I1_hat-3)+c2*(I2_hat-3)+p*J*C^(-1) + W^v(J)
      !take W^v(J) = 1/2 * kappa * (J-1)^2

      wvPrime=C(3)*(Jznu-1.0_DP)
      !Compute invariants
      CALL MatrixProduct(rCauchyGreen,rCauchyGreen,rCauchyGreenSq,err,error,*999)
      I1=rCauchyGreen(1,1)+rCauchyGreen(2,2)+rCauchyGreen(3,3)
      I2=0.5_DP*(I1*I1-rCauchyGreenSq(1,1)-rCauchyGreenSq(2,2)-rCauchyGreenSq(3,3))

      !Calculate isochoric fictitious 2nd Piola tensor 
      secondPiolaKirchoff=2.0_DP*Jznu**(-2.0_DP/3.0_DP)*((C(1)+C(2)*I1)*identity-C(2)*rCauchyGreen- &
        & (C(1)*I1+2.0_DP*C(2)*I2-1.5_DP*wvPrime*Jznu**(5.0_DP/3.0_DP))/3.0_DP*piolaDeformation)
      
      !Convert to Voigt form
      CALL TensorToVoigt(3,[TENSOR_CONTRAVARIANT_INDEX,TENSOR_CONTRAVARIANT_INDEX],secondPiolaKirchoff,stressTensorV, &
        & err,error,*999)
     
      !Do push-forward of 2nd Piola tensor.      
      CALL FiniteElasticity_PushStressTensor(stressTensorV,dZdNu,Jznu,err,error,*999)
      
    CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE,EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE)
      IF(equationsSet%specification(3)==EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE) THEN
        NULLIFY(interpolationParameters)
        CALL FieldInterpolatedPoint_InterpolationParametersGet(geometricInterpolatedPoint,interpolationParameters,err,error,*999)
        NULLIFY(fieldVariable)
        CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
        CALL FieldVariable_NumberOfComponentsGet(fieldVariable,pressureComponent,err,error,*999)
        P=geometricInterpPoint%values(pressureComponent,NO_PART_DERIV)
      ELSE
        NULLIFY(interpolationParameters)
        CALL FieldInterpolatedPoint_InterpolationParametersGet(dependentInterpPoint,interpolationParameters,err,error,*999)
        NULLIFY(fieldVariable)
        CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
        CALL FieldVariable_NumberOfComponentsGet(fieldVariable,pressureComponent,err,error,*999)
        P=dependentInterpPoint%values(pressureComponent,NO_PART_DERIV)
      ENDIF
      B=[2.0_DP*C(2),2.0_DP*C(3),2.0_DP*C(3),C(4),C(4),C(3)] ![2*b_f,2*b_t,2*b_t,b_ft,b_ft,b_t]
      E=[0.5_DP*(rCauchyGreen(1,1)-1.0_DP),0.5_DP*(rCauchyGreen(2,2)-1.0_DP),0.5_DP*(rCauchyGreen(3,3)-1.0_DP), &
        & rCauchyGreen(2,1),rCauchyGreen(3,1),rCauchyGreen(3,2)] !(Modified) strain tensor in Voigt form.
      dQdE=B*E
      tempTerm1=0.5_DP*C(1)*EXP(0.5_DP*DOT_PRODUCT(E,dQdE))
      ! Calculate isochoric fictitious 2nd Piola tensor (in Voigt form)
      stressTensorV=tempTerm1*dQdE
      IF(equationsSet%specification(3)==EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE) THEN
        !add active contraction stress values
        !Be aware for modified dZdNu, should active contraction be added here? Normally should be okay as modified dZdNu and dZdNu
        !converge during the Newton iteration.
        NULLIFY(independentField)
        CALL EquationsSet_IndependentFieldGet(equationsSet,independentField,err,error,*999)
        NULLIFY(fieldVariable)
        CALL Field_VariableGet(independentField,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
        CALL FieldVariable_NumberOfComponentsGet(fieldVariable,numberOfIndependentComponents,err,error,*999)
        DO componentIdx=1,numberOfIndependentComponents
          CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,elementNumber,componentIdx,dofIdx,err,error,*999)
          CALL FieldVariable_ParameterSetGetLocalDOF(fieldVariable,FIELD_VALUES_SET_TYPE,dofIdx,value,err,error,*999)
          stressTensorV(TENSOR_TO_VOIGT3(componentIdx,componentIdx))= &
            & stressTensorV(TENSOR_TO_VOIGT3(componentIdx,componentIdx))+value
        ENDDO !componentIdx
      ENDIF
      ! Do push-forward of 2nd Piola tensor. 
      CALL FiniteElasticity_PushStressTensor(stressTensorV,moddZdNu,Jznu,err,error,*999)
      !Calculate isochoric Cauchy tensor (the deviatoric part) and add the volumetric part (the hydrostatic pressure).
      oneThirdTrace=sum(stressTensorV(1:3))/3.0_DP
      stressTensorV(1:3)=stressTensorV(1:3)-oneThirdTrace+P
    CASE DEFAULT
      localError="The third equations set specification of "//TRIM(NumberToVString(esSpecification(3),"*",err,error))// &
        & " is not valid for a finite elasticity type of an elasticity equation set."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FiniteElasticity_GaussStressTensor")
    RETURN
    999 ERRORSEXITS("FiniteElasticity_GaussStressTensor",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_GaussStressTensor

  !
  !================================================================================================================================
  !

  ! calculates the current active contraction component using the independent field
  ! Uses a hardcoded tension transient based on GPB+NHS with length-dependence for now
  SUBROUTINE FiniteElasticity_PiolaAddActiveContraction(independentField,materialsField,currentTime,dt,piolaFF,Eff,&
    & elementNumber,gaussPointNumber,err,error,*)
    !Argument variables
    TYPE(FieldType), POINTER, INTENT(IN) :: independentField
    TYPE(FieldType), POINTER, INTENT(IN) :: materialsField
    REAL(DP), INTENT(IN) :: currentTime !<The time to evaluate at
    REAL(DP), INTENT(IN) :: dt !<The delta time to evaluate at
    REAL(DP), INTENT(INOUT) :: piolaFF  !<The (1,1)=(fiber,fiber) component of the stress tensor
    REAL(DP), INTENT(IN)    :: Eff !<E(1,1)
    INTEGER(INTG), INTENT(IN) :: elementNumber,gaussPointNumber !<Element/Gauss point number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string

    INTEGER(INTG)  :: i
    REAL(DP) :: s, lambda, isoTA, ta, activationTime, time
    REAL(DP), DIMENSION(1:4) :: ql

    REAL(DP), PARAMETER :: period = 1000 ! 1 Hz
    REAL(DP), PARAMETER, DIMENSION(28) :: times    =    [ 0, 20, 30, 40, 60, 80, 100, 120, 150, 160, 170, 175, 180, 190, 200,&
    & 225, 250, 300, 333, 366, 400, 450, 500, 600, 700, 800, 900,1000 ] ! simple tension curve based on GPB/NHS: times

    REAL(DP), PARAMETER, DIMENSION(28) :: tensionFrac = [ 0.0194, 0.0193, 0.0200, 0.0254, 0.0778, 0.1713, 0.2794, 0.3708,&
    & 0.4472, 0.4578, 0.4624, 0.4627, 0.4618, 0.4567, 0.4478, 0.4121, 0.3614, 0.2326, 0.1471, 0.0920, 0.0681, 0.0526, 0.0438,&
    & 0.0332, 0.0271, 0.0234, 0.0210, 0.0194 ] ! simple isometric tension curve based on GPB/NHS: tension/tref 
    REAL(DP), PARAMETER :: tRef = 100          ! reference tension
  
    ENTERS("FiniteElasticity_PiolaAddActiveContraction",err,error,*999)

    !Get Q's
    DO i=1,4
      CALL Field_ParameterSetGetLocalGaussPoint(independentField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
        & gaussPointNumber,elementNumber,i,ql(i),err,error,*999)  ! Q(1) Q(2) Q(3) Lambda for prev in 1/2/3/4
    ENDDO !i

    ! get activation time from material field
    CALL Field_ParameterSetGetLocalGaussPoint(materialsField,FIELD_V_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
      & gaussPointNumber,elementNumber,1,activationTime,err,error,*999)

    lambda = SQRT(2*Eff + 1)
    time =  MAX( MOD(currentTime, period) - activationTime, 0.0) ! start activation at this time
   
    i=1
    DO WHILE (times(i) <= time) ! find first i such that times(i) >= time
      i=i+1
    ENDDO
    s = (time - times(i-1)) /  (times(i) - times(i-1))                     !| linear interpolation of ta/tref
    isoTA = tRef * (tensionFrac(i-1) * (1-s) + tensionFrac(i) * s)        !/ + multiply by tref
  
    CALL FiniteElasticity_FMM(time,dt,ql(4),lambda,ql,isoTA,ta,err,error,*999)

    ql(4) = lambda  ! bounds applied in FMM, Qi integrated
    DO i=1,4
      CALL Field_ParameterSetUpdateGaussPoint(independentField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
        & gaussPointNumber,elementNumber,4+i,ql(i),err,error,*999) ! store Q(1) Q(2) Q(3) Lambda for next in 5/6/7/8
    ENDDO

    piolaFF = piolaFF + ta

    EXITS("FiniteElasticity_PiolaAddActiveContraction")
    RETURN
999 ERRORSEXITS("FiniteElasticity_PiolaAddActiveContraction",err,error)
    RETURN 1

  END SUBROUTINE FiniteElasticity_PiolaAddActiveContraction

  !
  !================================================================================================================================
  !

  !>Implements length and velocity dependence. can be used in both weak and strong coupling
  SUBROUTINE FiniteElasticity_FMM(time,dt,previousLambda,currentLambda,q123,isoTA,ta,err,error,*)

    !Argument variables
    REAL(DP), INTENT(IN) :: time !<The current time
    REAL(DP), INTENT(IN) :: dt !<The delta time
    REAL(DP), INTENT(IN) :: previousLambda !<The previous lambda
    REAL(DP), INTENT(INOUT) :: currentLambda !<The current lamdda
    REAL(DP), INTENT(INOUT) :: q123(:) !<?
    REAL(DP), INTENT(IN) :: isoTA !<?
    REAL(DP), INTENT(OUT) :: ta !<?
    INTEGER(INTG) :: err
    TYPE(VARYING_STRING) :: error
    !Local Variables
    INTEGER(INTG) :: i
    REAL(DP) :: qfac, dLambdadt, q, overlap
    ! PARAMETERS FROM Niederer Hunter & Smith 2006
    REAL(DP), PARAMETER, DIMENSION(1:3) :: a     = [-29.0,138.0,129.0]  ! 'A'
    REAL(DP), PARAMETER, DIMENSION(1:3) :: alpha = [0.03,0.13,0.625]
    REAL(DP), PARAMETER :: la   = 0.35, beta0 = 4.9  ! 'a'

    ENTERS("FiniteElasticity_FMM",err,error,*999)

    currentLambda = MIN(1.15, MAX(0.8, currentLambda))  ! inout -> save this

    IF( time - 1e-10 <= 0.0) THEN  ! preload / first step -> update method off
      qfac = 1.0
    ELSE
      dLambdadt = (currentLambda - previousLambda) / dt
      DO i=1,3
        q123(i) = q123(i) + dt * (a(i) * dLambdadt - alpha(i) * q123(i))
      ENDDO
      q = q123(1)+q123(2)+q123(3)
      IF(q < 0.0) THEN
        qfac = (la*q + 1.0) / (1.0 - q)
      ELSE
        qfac = (1.0 + (la+2.0)*q)/(1.0+q);
      ENDIF
    ENDIF

    overlap= 1.0 + beta0 * (currentLambda-1.0)
    ta = overlap * qfac * isoTA  ! length dep * vel dep * isometric tension
    
    EXITS("FiniteElasticity_FMM")
    RETURN
999 ERRORSEXITS("FiniteElasticity_FMM",err,error)
    RETURN 1

  END SUBROUTINE FiniteElasticity_FMM

  !
  !================================================================================================================================
  !

  !>Evaluates df/dz (derivative of interpolation function wrt deformed coord) matrix at a given Gauss point
  SUBROUTINE FiniteElasticity_GaussdFdZ(interpolatedPoint,elementNumber,gaussPointNumber,numberOfDimensions, &
    & numberOfXi,dFdZ,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint !<Interpolated point for the dependent field
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions for the interpolation
    REAL(DP), INTENT(OUT) :: dFdZ(:,:,:) !<On return, a matrix containing the derivatives of the basis functions wrt the deformed coordinates
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx1,componentIdx2,numberOfElementParameters,parameterIdx,partialDerivativeIdx,xiIdx
    REAL(DP) :: dXidZ(numberOfDimensions,numberOfDimensions),dZdXi(numberOfDimensions,numberOfDimensions)
    REAL(DP) :: Jzxi,dFdXi(numberOfDimensions,64,numberOfXi)!temporary until a proper alternative is found
    TYPE(BasisType), POINTER :: componentBasis
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(QuadratureSchemeType), POINTER :: quadratureScheme
    
    ENTERS("FiniteElasticity_GaussdFdZ",err,error,*999)

    NULLIFY(interpolationParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(interpolatedPoint,interpolationParameters,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)

    !Initialise dFdXi array
    dFdXi=0.0_DP !dFdXi(componentIdx,parameterIdx,xiIdx)
    dFdZ=0.0_DP
    DO componentIdx2=1,numberOfDimensions
      DO xiIdx=1,numberOfXi
        partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx) !2,4,7
        dZdXi(componentIdx2,xiIdx)=interpolatedPoint%values(componentIdx2,partialDerivativeIdx) !dZ/dXi
      ENDDO !xiIdx
    ENDDO !componentIdx2

    !Populate a 3 x 3 square dZdXi if this is a membrane problem in 3D space
    IF(numberOfDimensions==3.AND.numberOfXi==2) THEN
      CALL CrossProduct(dZdXi(:,1),dZdXi(:,2),dZdXi(:,3),err,error,*999)
      CALL Normalise(dZdXi(:,3),dZdXi(:,3),err,error,*999)
    ENDIF

    CALL Invert(dZdXi,dXidZ,Jzxi,err,error,*999) !dxi/dz

    DO componentIdx1=1,numberOfDimensions
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx1,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      NULLIFY(componentBasis)
      CALL DomainElements_ElementBasisGet(domainElements,elementNumber,componentBasis,err,error,*999)
      NULLIFY(quadratureScheme)
      CALL Basis_QuadratureSchemeGet(componentBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,quadratureScheme,err,error,*999)
      CALL Basis_NumberOfElementParametersGet(componentBasis,numberOfElementParameters,err,error,*999)
      DO parameterIdx=1,numberOfElementParameters
        DO xiIdx=1,numberOfXi
          partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
          CALL BasisQuadratureScheme_GaussBasisFunctionGet(quadratureScheme,parameterIdx,partialDerivativeIdx,gaussPointNumber, &
            & dFdXi(componentIdx1,parameterIdx,xiIdx),err,error,*999)
        ENDDO !xiIdx
      ENDDO !parameterIdx
    ENDDO !componentIdx1

    DO componentIdx1=1,numberOfDimensions
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx1,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      NULLIFY(componentBasis)
      CALL DomainElements_ElementBasisGet(domainElements,elementNumber,componentBasis,err,error,*999)
      NULLIFY(quadratureScheme)
      CALL Basis_QuadratureSchemeGet(componentBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,quadratureScheme,err,error,*999)
      CALL Basis_NumberOfElementParametersGet(componentBasis,numberOfElementParameters,err,error,*999)
      DO componentIdx2=1,numberOfDimensions
        DO parameterIdx=1,numberOfElementParameters
          DO xiIdx=1,numberOfXi
            dFdZ(parameterIdx,componentIdx2,componentIdx1)=dFdZ(parameterIdx,componentIdx2,componentIdx1) + &
              & dFdXi(componentIdx1,parameterIdx,xiIdx)*dXidZ(xiIdx,componentIdx2)
          ENDDO !xiIdx
        ENDDO !parameterIdx
      ENDDO !componentIdx2
    ENDDO !componentIdx1

    EXITS("FiniteElasticity_GaussdFdZ")
    RETURN
999 ERRORSEXITS("FiniteElasticity_GaussdFdZ",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_GaussdFdZ

  !
  !================================================================================================================================
  !

  !>Sets up the finite elasticity equation type of an elasticity equations set class.
  SUBROUTINE FiniteElasticity_EquationsSetSetup(equationsSet,equationsSetSetup,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set to setup a Laplace equation on.
    TYPE(EquationsSetSetupType), INTENT(INOUT) :: equationsSetSetup !<The equations set setup information
    INTEGER(INTG), INTENT(OUT) :: err           !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error  !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,dependentFieldNumberOfVariables,derivedIdx,dimensionIdx,equationsSetFieldNumberOfComponents, &
      & equationsSetFieldNumberOfVariables,equationsSetSubtype,esSpecification(3),geometricComponentNumber, &
      & geometricMeshComponent,geometricScalingType,lumpingType,numberOfCompartments,numberOfComponents,numberOfComponents2, &
      & numberOfDimensions,numberOfDarcyComponents,numberOfFluidComponents,numberOfTensorComponents,numberOfVariables, &
      & solutionMethod,sparsityType,variableIdx,variableType
    INTEGER(INTG), POINTER :: equationsSetFieldData(:)
    INTEGER(INTG), ALLOCATABLE :: variableTypes(:)
    LOGICAL :: isHydrostaticPressureDependentField
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: geometricDecomposition
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsSetAnalyticType), POINTER :: esAnalytic
    TYPE(EquationsSetDependentType), POINTER :: esDependent
    TYPE(EquationsSetDerivedType), POINTER :: esDerived
    TYPE(EquationsSetEquationsFieldType), POINTER :: equationsSetEquationsField
    TYPE(EquationsSetIndependentType), POINTER :: esIndependent
    TYPE(EquationsSetMaterialsType), POINTER :: esMaterials
    TYPE(EquationsSetSourceType), POINTER :: esSource
    TYPE(FieldType), POINTER :: analyticField,dependentField,equationsSetField,fibreField,geometricField
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(RegionType), POINTER :: region
    TYPE(VARYING_STRING) :: localError
 
    ENTERS("FiniteElasticity_EquationsSetSetup",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)

    equationsSetSubtype=esSpecification(3)

    SELECT CASE(equationsSetSubtype)
    CASE(EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_MEMBRANE_SUBTYPE, &
      & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE, &
      & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE, &
      & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE, &
      & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE, EQUATIONS_SET_NO_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE,EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
      & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, & 
      & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
      & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE, &
      & EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
      & EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE, &
      & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE,EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE, &
      & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE,EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
      & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
      & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
      !OK
    CASE DEFAULT
      localError="The third equations set specification of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
        & " is not valid for a finite elasticity type of an elasticity equation set."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    
    isHydrostaticPressureDependentField = equationsSetSubtype/=EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_MEMBRANE_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE &
      & .AND. equationsSetSubtype/=EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE

    NULLIFY(region)
    CALL EquationsSet_RegionGet(equationsSet,region,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Region_CoordinateSystemGet(region,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_DimensionGet(coordinateSystem,numberOfDimensions,err,error,*999)

    IF(isHydrostaticPressureDependentField) THEN
      numberOfComponents = numberOfDimensions + 1
    ELSE
      numberOfComponents = numberOfDimensions
    ENDIF
    
    SELECT CASE(equationsSetSetup%setupType)
    CASE(EQUATIONS_SET_SETUP_INITIAL_TYPE)
      !-----------------------------------------------------------------
      ! I n i t i a l   s e t u p
      !-----------------------------------------------------------------
      SELECT CASE(equationsSetSetup%actionType)
      CASE(EQUATIONS_SET_SETUP_START_ACTION)
        !Default to FEM solution method
        CALL FiniteElasticity_EquationsSetSolutionMethodSet(equationsSet,EQUATIONS_SET_FEM_SOLUTION_METHOD,err,error,*999)
        CALL EquationsSet_LabelSet(equationsSet,"Finite elasticity equations set",err,error,*999)
        IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE) THEN
          !setup equations set field to store number of fluid compartments
          equationsSetFieldNumberOfVariables = 1
          equationsSetFieldNumberOfComponents = 2
          NULLIFY(equationsSetEquationsField)
          CALL EquationsSet_EquationsFieldGet(equationsSet,equationsSetEquationsField,err,error,*999)
          IF(equationsSetEquationsField%equationsSetFieldAutoCreated) THEN
            !Create the auto created equations set field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,equationsSetEquationsField%equationsSetField, &
              & err,error,*999)
            CALL Field_LabelSet(equationsSetEquationsField%equationsSetField,"Equations Set Field",err,error,*999)
            CALL Field_TypeSetAndLock(equationsSetEquationsField%equationsSetField,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(equationsSetEquationsField%equationsSetField,FIELD_INDEPENDENT_TYPE,err,error,*999)
            CALL Field_NumberOfVariablesSet(equationsSetEquationsField%equationsSetField, equationsSetFieldNumberOfVariables, &
              & err,error,*999)
            CALL Field_VariableTypesSetAndLock(equationsSetEquationsField%equationsSetField,[FIELD_U_VARIABLE_TYPE],err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSetEquationsField%equationsSetField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSetEquationsField%equationsSetField,FIELD_U_VARIABLE_TYPE,FIELD_INTG_TYPE, &
              & err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSetEquationsField%equationsSetField,FIELD_U_VARIABLE_TYPE, &
              & equationsSetFieldNumberOfComponents,err,error,*999)
          ELSE
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_INDEPENDENT_TYPE,err,error,*999)
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,equationsSetFieldNumberOfVariables, err,error,*999)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE],err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_INTG_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE, &
              & equationsSetFieldNumberOfComponents,err,error,*999)
          ENDIF
        ENDIF
      CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
        IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE) THEN
          NULLIFY(equationsSetEquationsField)
          CALL EquationsSet_EquationsFieldGet(equationsSet,equationsSetEquationsField,err,error,*999)
          IF(equationsSetEquationsField%equationsSetFieldAutoCreated) THEN
            CALL Field_CreateFinish(equationsSetEquationsField%equationsSetField,err,error,*999)
            CALL Field_ComponentValuesInitialise(equationsSetEquationsField%equationsSetField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_VALUES_SET_TYPE,1,1_INTG,err,error,*999)
            CALL Field_ComponentValuesInitialise(equationsSetEquationsField%equationsSetField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_VALUES_SET_TYPE,2,1_INTG,err,error,*999)
          ENDIF
        ENDIF
!!TODO: Check valid setup
      CASE DEFAULT
        localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
          & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
          & " is invalid for a finite elasticity equation."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(EQUATIONS_SET_SETUP_GEOMETRY_TYPE)
      !-----------------------------------------------------------------
      ! G e o m e t r i c   f i e l d
      !-----------------------------------------------------------------
      !\todo Check dimension of geometric field
      SELECT CASE(equationsSetSetup%actionType)
      CASE(EQUATIONS_SET_SETUP_START_ACTION)
        !Check whether a fibre field is required, and if so, make sure it has been set
        SELECT CASE(equationsSetSubtype)
        CASE(EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
          & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE, &
          & EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE,&
          & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE,&
          & EQUATIONS_SET_NO_SUBTYPE, &
          & EQUATIONS_SET_MEMBRANE_SUBTYPE, &
          & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE, &
          & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE, &
          & EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE, &
          & EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, & 
          & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
          & EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE, &
          & EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
          & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE, &
          & EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE, &
          & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
          & EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE, &
          & EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
          ! pass, fibre field isn't required as the constitutive relation is isotropic
        CASE(EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE, &
          & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE, &
          & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE, &
          & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE, &
          & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE, &
          & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE, &
          & EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE, &
          & EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, &
          & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
          & EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE, &
          & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
          & EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
          & EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE, &
          & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE, &
          & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
          & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE, &
          & EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE,EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE, &
          & EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE,EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE, &
          & EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE,EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE, &
          & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE, &
          & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
          & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)
          NULLIFY(fibreField)
          CALL EquationsSet_FibreFieldExists(equationsSet,fibreField,err,error,*999)
          IF(.NOT.ASSOCIATED(fibreField)) CALL FlagError("Finite elasticity equations require a fibre field.",err,error,*999)
        CASE DEFAULT
          localError="The third equations set specification of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
            & " is invalid for a finite elasticity equation."
          CALL FlagError(localError,err,error,*999)
        END SELECT
        IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE .OR. &
          & equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE) THEN
          ! Set up mesh displacement and equations set field info for elasticity Darcy problems
          NULLIFY(geometricField)
          CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          CALL FieldVariable_ParameterSetEnsureCreated(geometricVariable,FIELD_MESH_DISPLACEMENT_SET_TYPE,err,error,*999)
          IF(equationsSetSubtype==EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE .OR. &
            equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE) THEN
            !Create the equations set field for multi-compartment Darcy
            equationsSetFieldNumberOfComponents = 2
            NULLIFY(equationsSetEquationsField)
            CALL EquationsSet_EquationsFieldGet(equationsSet,equationsSetEquationsField,err,error,*999)
            IF(equationsSetEquationsField%equationsSetFieldAutoCreated) THEN
              NULLIFY(geometricDecomposition)
              CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
              CALL Field_DecompositionSetAndLock(equationsSetEquationsField%equationsSetField,geometricDecomposition, &
                & err,error,*999)
              CALL Field_GeometricFieldSetAndLock(equationsSetEquationsField%equationsSetField,geometricField,err,error,*999)
              CALL FieldVariable_ComponentMeshComponentGet(geometricVariable,1,geometricComponentNumber,err,error,*999)
              DO componentIdx=1,equationsSetFieldNumberOfComponents
                CALL Field_ComponentMeshComponentSetAndLock(equationsSetEquationsField%equationsSetField,FIELD_U_VARIABLE_TYPE, &
                  & componentIdx,geometricComponentNumber,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSetEquationsField%equationsSetField,FIELD_U_VARIABLE_TYPE, &
                  & componentIdx,FIELD_CONSTANT_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              !Default the field scaling to that of the geometric field
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(equationsSetEquationsField%equationsSetField,geometricScalingType,err,error,*999)
            ELSE
              !Do nothing
            ENDIF
          ENDIF
        ENDIF
      CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
        ! do nothing
      CASE DEFAULT
        localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
          & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
          & " is invalid for a linear diffusion equation."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(EQUATIONS_SET_SETUP_DEPENDENT_TYPE)
      !-----------------------------------------------------------------
      ! D e p e n d e n t   f i e l d
      !-----------------------------------------------------------------
      NULLIFY(geometricField)
      CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
      CALL Field_NumberOfComponentsGet(geometricField,FIELD_U_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
      SELECT CASE(equationsSetSubtype)
      CASE(EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, & 
        & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
        & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE, &
        & EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE, &
        & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE, &
        & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE, &
        & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE, &
        & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE,&
        & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE, &
        & EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE, EQUATIONS_SET_NO_SUBTYPE,EQUATIONS_SET_MEMBRANE_SUBTYPE, &
        & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
        & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE, &
        & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE, &
        & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE,EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE, &
        & EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE, &
        & EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
        & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE, &
        & EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
        & EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
        !-----------------------------------------------------------------------
        ! Dependent field setup for single-physics
        !-----------------------------------------------------------------------
        SELECT CASE(equationsSetSetup%actionType)
        CASE(EQUATIONS_SET_SETUP_START_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            !Create the auto created dependent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,equationsSet%dependent%dependentField,err,error,*999)
            CALL Field_LabelSet(equationsSet%dependent%dependentField,"Dependent Field",err,error,*999)
            CALL Field_TypeSetAndLock(equationsSet%dependent%dependentField,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(equationsSet%dependent%dependentField,geometricDecomposition, err,error,*999)
            CALL Field_GeometricFieldSetAndLock(equationsSet%dependent%dependentField,geometricField,err,error,*999)
            IF(equationsSetSubtype==EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,3,err,error,*999)
            ELSE IF(equationsSetSubtype==EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,4,err,error,*999)
            ELSE
              dependentFieldNumberOfVariables=2
              CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,dependentFieldNumberOfVariables, &
                & err,error,*999)
              CALL Field_VariableTypesSetAndLock(equationsSet%dependent%dependentField,[FIELD_U_VARIABLE_TYPE, &
                & FIELD_DELUDELN_VARIABLE_TYPE],err,error,*999)
              CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,"U",err,error,*999)
              CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,"del U/del n", &
                & err,error,*999)
            ENDIF
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE, &
              & err,error,*999)
            CALL Field_NumberOfComponentsGet(geometricField,FIELD_U_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & numberOfComponents,err,error,*999)
            IF(equationsSetSubtype==EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE,FIELD_DP_TYPE, &
                & err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
                & numberOfDimensions,err,error,*999)
            ELSE IF(equationsSetSubtype==EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE,FIELD_DP_TYPE, &
                & err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
                & numberOfDimensions,err,error,*999)
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_DP_TYPE, &
                & err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE,2,err,error,*999)
            ENDIF
            !Default to the geometric interpolation setup
            DO componentIdx=1,numberOfDimensions
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,componentIdx,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              IF(equationsSetSubtype==EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE) THEN
                CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
                  & componentIdx,geometricMeshComponent,err,error,*999)
              ELSE IF(equationsSetSubtype==EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE) THEN
                CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
                  & componentIdx,geometricMeshComponent,err,error,*999)
              ENDIF
            ENDDO !componentIdx
            IF(equationsSetSubtype==EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE,1, &
                & geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE,2, &
                & geometricMeshComponent,err,error,*999)
            ENDIF
            IF(isHydrostaticPressureDependentField) THEN
              !Set the hydrostatic component to that of the first geometric component
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & numberOfComponents,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & numberOfComponents,geometricMeshComponent,err,error,*999)
            ENDIF
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Set the displacement components to node based interpolation
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                  & componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              IF(isHydrostaticPressureDependentField) THEN
                !Set the hydrostatic pressure component to element based interpolation
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                  & numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              ENDIF
              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(equationsSet%dependent%dependentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_DEPENDENT_TYPE,err,error,*999)
            IF(equationsSetSubtype==EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,3,err,error,*999)
              CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_V_VARIABLE_TYPE],err,error,*999)
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            ELSE IF(equationsSetSubtype==EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,4,err,error,*999)
              CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_V_VARIABLE_TYPE,FIELD_U1_VARIABLE_TYPE],err,error,*999)
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            ELSE
              CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,2,err,error,*999)
              CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE], &
                & err,error,*999)
            ENDIF
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
              & err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents, &
              & err,error,*999)
            IF(equationsSetSubtype==EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
            ELSE IF(equationsSetSubtype==EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
              CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,2,err,error,*999)
            ENDIF
            !Check that the pressure values set type is created here?? (second variable is a DELUDELN type, as checked above)
            !\todo: Decide whether these set_types (previous one as well) is to be created by user or automatically.
            CALL Field_ParameterSetEnsureCreated(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_PRESSURE_VALUES_SET_TYPE,err,error,*999)
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            CALL Field_CreateFinish(equationsSet%dependent%dependentField,err,error,*999)
          ENDIF
          IF(equationsSet%specification(3)==EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE) THEN
            CALL Field_ParameterSetCreate(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_PREVIOUS_VALUES_SET_TYPE,err,error,*999)
            CALL Field_ParameterSetCreate(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_PREVIOUS_ITERATION_VALUES_SET_TYPE,err,error,*999)
          ELSE IF(equationsSet%specification(3)==EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
            & equationsSet%specification(3)==EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE.OR. &
            & equationsSet%specification(3)==EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE.OR. &
            & equationsSet%specification(3)==EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE) THEN
            CALL Field_ParameterSetCreate(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_BOUNDARY_CONDITIONS_SET_TYPE,err,error,*999)                
          ENDIF
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity equation"
          CALL FlagError(localError,err,error,*999)
        END SELECT

      CASE(EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE)

        SELECT CASE(equationsSetSetup%actionType)
        CASE(EQUATIONS_SET_SETUP_START_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            !Create the auto created dependent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,equationsSet%dependent%dependentField,err,error,*999)
            CALL Field_LabelSet(equationsSet%dependent%dependentField,"Dependent Field",err,error,*999)
            CALL Field_TypeSetAndLock(equationsSet%dependent%dependentField,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(equationsSet%dependent%dependentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(equationsSet%dependent%dependentField,geometricField,err,error,*999)
            CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,2,err,error,*999)
            CALL Field_VariableTypesSetAndLock(equationsSet%dependent%dependentField,[FIELD_U_VARIABLE_TYPE, &
              & FIELD_DELUDELN_VARIABLE_TYPE],err,error,*999)
            CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,"Z",err,error,*999)
            CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,"Traction", &
              & err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE, &
              & err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & numberOfDimensions,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & numberOfDimensions,err,error,*999)

            !Default to the geometric interpolation setup
            DO componentIdx=1,numberOfDimensions
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,componentIdx,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
            ENDDO !componentIdx

            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Set the displacement components to node based interpolation
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_U_VARIABLE_TYPE,componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_DELUDELN_VARIABLE_TYPE,componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx

              IF(isHydrostaticPressureDependentField) THEN
                !Set the hydrostatic pressure component to element based interpolation
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & numberOfDimensions+1,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                  & numberOfDimensions+1,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              ENDIF
              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(equationsSet%dependent%dependentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_DEPENDENT_TYPE,err,error,*999)
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,2,err,error,*999)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE], &
              & err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
              & err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,numberOfDimensions, &
              & err,error,*999)
            !Check that the pressure values set type is created here?? (second variable is a DELUDELN type, as checked above)
            !\todo: Decide whether these set_types (previous one as well) is to be created by user or automatically..
            CALL Field_ParameterSetEnsureCreated(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_PRESSURE_VALUES_SET_TYPE,err,error,*999)
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            CALL Field_CreateFinish(equationsSet%dependent%dependentField,err,error,*999)
          ENDIF
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity equation"
          CALL FlagError(localError,err,error,*999)
        END SELECT

      CASE(EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
        !--------------------------------------------------------------------------------------
        ! Dependent field setup for a code constitutive law with a growth law defined in CellML
        !--------------------------------------------------------------------------------------
        SELECT CASE(equationsSetSetup%actionType)
        CASE(EQUATIONS_SET_SETUP_START_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            !Create the auto created dependent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,equationsSet%dependent%dependentField,err,error,*999)
            CALL Field_TypeSetAndLock(equationsSet%dependent%dependentField,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(equationsSet%dependent%dependentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(equationsSet%dependent%dependentField,geometricField,err,error,*999)
            CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,3,err,error,*999)
            CALL Field_VariableTypesSetAndLock(equationsSet%dependent%dependentField,[FIELD_U_VARIABLE_TYPE, &
              & FIELD_DELUDELN_VARIABLE_TYPE,FIELD_U3_VARIABLE_TYPE],err,error,*999)
            CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,"U",err,error,*999)
            CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,"del U/del n", &
              & err,error,*999)
            CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_U3_VARIABLE_TYPE,"U3",err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U3_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE, &
              & err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U3_VARIABLE_TYPE, &
              & numberOfDimensions,err,error,*999)

            !Default to the geometric interpolation setup
            DO componentIdx=1,numberOfDimensions
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,componentIdx,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U3_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
            ENDDO !componentIdx

            IF(isHydrostaticPressureDependentField) THEN
              !Set the hydrostatic component to that of the first geometric component
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & numberOfComponents,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & numberOfComponents,geometricMeshComponent,err,error,*999)
            ENDIF

            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Set the displacement components to node based interpolation, set the growth to Gauss point
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_U_VARIABLE_TYPE,componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_DELUDELN_VARIABLE_TYPE,componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_U3_VARIABLE_TYPE,componentIdx,FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx

              IF(isHydrostaticPressureDependentField) THEN
                !Set the hydrostatic pressure component to element based interpolation
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                  & numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              ENDIF

              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(equationsSet%dependent%dependentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT

          ELSE !.NOT. equationsSet%dependent%dependentFieldAutoCreated

            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_DEPENDENT_TYPE,err,error,*999)
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,4,err,error,*999)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_U3_VARIABLE_TYPE],err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
              & err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U3_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U3_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents, &
              & err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U3_VARIABLE_TYPE,numberOfDimensions,err,error,*999)

            !Check that the pressure values set type is created here?? (second variable is a DELUDELN type, as checked above)
            !\todo: Decide whether these set_types (previous one as well) is to be created by user or automatically..
            CALL Field_ParameterSetEnsureCreated(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_PRESSURE_VALUES_SET_TYPE,err,error,*999)
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U3_VARIABLE_TYPE,componentIdx, &
                  & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF !equationsSet%dependent%dependentFieldAutoCreated
        CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            CALL Field_CreateFinish(equationsSet%dependent%dependentField,err,error,*999)
          ENDIF
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity equation"
          CALL FlagError(localError,err,error,*999)
        END SELECT

      CASE(EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
        & EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
        !-------------------------------------------------------------------------------
        ! Dependent field setup for elasticity evaluated in CellML
        !-------------------------------------------------------------------------------
        SELECT CASE(equationsSetSetup%actionType)
        CASE(EQUATIONS_SET_SETUP_START_ACTION)
          IF(numberOfDimensions==3) THEN
            numberOfComponents2 = 6
          ELSE IF(numberOfDimensions==2) THEN
            numberOfComponents2 = 3
          ELSE
            CALL FlagError("Only 2 and 3 dimensional problems are implemented at the moment.",err,error,*999)
          ENDIF !numberOfDimensions
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            !Create the auto created dependent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,equationsSet%dependent%dependentField,err,error,*999)
            CALL Field_TypeSetAndLock(equationsSet%dependent%dependentField,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(equationsSet%dependent%dependentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(equationsSet%dependent%dependentField,geometricField,err,error,*999)
            IF(equationsSet%SPECIFICATION(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
              CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,5,err,error,*999)
              CALL Field_VariableTypesSetAndLock(equationsSet%dependent%dependentField,[FIELD_U_VARIABLE_TYPE, &
                & FIELD_DELUDELN_VARIABLE_TYPE,FIELD_U1_VARIABLE_TYPE,FIELD_U2_VARIABLE_TYPE,FIELD_U3_VARIABLE_TYPE], &
                & err,error,*999)
            ELSE
              CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,4,err,error,*999)
              CALL Field_VariableTypesSetAndLock(equationsSet%dependent%dependentField,[FIELD_U_VARIABLE_TYPE, &
                & FIELD_DELUDELN_VARIABLE_TYPE,FIELD_U1_VARIABLE_TYPE,FIELD_U2_VARIABLE_TYPE],err,error,*999)
            ENDIF
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U2_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE, &
              & err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
              & numberOfComponents2,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U2_VARIABLE_TYPE, &
              & numberOfComponents2,err,error,*999)

            IF(equationsSet%specification(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U3_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U3_VARIABLE_TYPE,FIELD_DP_TYPE, &
                & err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U3_VARIABLE_TYPE, &
                & numberOfDimensions,err,error,*999)
            ENDIF

            !Default to the geometric interpolation setup
            DO componentIdx=1,numberOfDimensions
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,componentIdx,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
            ENDDO !componentIdx

            IF(isHydrostaticPressureDependentField) THEN
              !Set the hydrostatic component to that of the first geometric component
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & numberOfComponents,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & numberOfComponents,geometricMeshComponent,err,error,*999)
              !kmith
            ENDIF

            !Set the stress and strain components to that of the first geometric component
            CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
            DO componentIdx=1,numberOfComponents2
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U2_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              IF(equationsSet%specification(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
                CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U3_VARIABLE_TYPE, &
                  & componentIdx,geometricMeshComponent,err,error,*999)
              ENDIF
            ENDDO !componentIdx

            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Set the displacement components to node based interpolation
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_DELUDELN_VARIABLE_TYPE,componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx

              IF(isHydrostaticPressureDependentField) THEN
                !Set the hydrostatic pressure component to element based interpolation
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField, &
                  & FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              ENDIF

              !Set the stress and strain components to gauss point interpolation
              DO componentIdx=1,numberOfComponents2
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_U1_VARIABLE_TYPE,componentIdx,FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_U2_VARIABLE_TYPE,componentIdx,FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
                IF(equationsSet%specification(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
                  CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                    & FIELD_U3_VARIABLE_TYPE,componentIdx,FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
                ENDIF
              ENDDO !componentIdx

              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(equationsSet%dependent%dependentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT

          ELSE !equationsSet%dependent%dependentFieldAutoCreated

            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_DEPENDENT_TYPE,err,error,*999)
            IF(equationsSet%specification(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
              CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,5,err,error,*999)
              CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_U1_VARIABLE_TYPE,FIELD_U2_VARIABLE_TYPE,FIELD_U3_VARIABLE_TYPE],err,error,*999)
            ELSE
              CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,4,err,error,*999)
              CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_U1_VARIABLE_TYPE,FIELD_U2_VARIABLE_TYPE],err,error,*999)
            ENDIF
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
              & err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U2_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U2_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents, &
              & err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,numberOfComponents2,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U2_VARIABLE_TYPE,numberOfComponents2,err,error,*999)
            IF(equationsSet%specification(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U3_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U3_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U3_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
            ENDIF

            !Check that the pressure values set type is created here?? (second variable is a DELUDELN type, as checked above)
            !\todo: Decide whether these set_types (previous one as well) is to be created by user or automatically..
            CALL Field_ParameterSetEnsureCreated(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_PRESSURE_VALUES_SET_TYPE,err,error,*999)
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                IF(equationsSet%specification(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
                  CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U3_VARIABLE_TYPE,componentIdx, &
                    & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
                ENDIF
              ENDDO !componentIdx
              DO componentIdx=1,numberOfComponents2
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,componentIdx, &
                  & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U2_VARIABLE_TYPE,componentIdx, &
                  & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF !equationsSet%dependent%dependentFieldAutoCreated
        CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            CALL Field_CreateFinish(equationsSet%dependent%dependentField,err,error,*999)
          ENDIF
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity equation"
          CALL FlagError(localError,err,error,*999)
        END SELECT

      CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
        & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)
        !Rubin rate based formulations
        SELECT CASE(equationsSetSetup%actionType)
        CASE(EQUATIONS_SET_SETUP_START_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            !Create the auto created dependent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,equationsSet%dependent%dependentField,err,error,*999)
            CALL Field_LabelSet(equationsSet%dependent%dependentField,"Dependent Field",err,error,*999)
            CALL Field_TypeSetAndLock(equationsSet%dependent%dependentField,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(equationsSet%dependent%dependentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(equationsSet%dependent%dependentField,geometricField,err,error,*999)
            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE)
              CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,3,err,error,*999)
              CALL Field_VariableTypesSetAndLock(equationsSet%dependent%dependentField,[FIELD_U_VARIABLE_TYPE, &
                & FIELD_DELUDELN_VARIABLE_TYPE,FIELD_U1_VARIABLE_TYPE],err,error,*999)
              CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,"U",err,error,*999)
              CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,"del U/del n", &
                & err,error,*999)
              CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE,"U1",err,error,*999)
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE, &
                & err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE, &
                & err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_DP_TYPE, &
                & err,error,*999)
            CASE( EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)
              CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,4,err,error,*999)
              CALL Field_VariableTypesSetAndLock(equationsSet%dependent%dependentField,[FIELD_U_VARIABLE_TYPE, &
                & FIELD_DELUDELN_VARIABLE_TYPE,FIELD_U1_VARIABLE_TYPE,FIELD_U2_VARIABLE_TYPE],err,error,*999)
              CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,"U",err,error,*999)
              CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,"del U/del n", &
                & err,error,*999)
              CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE,"U1",err,error,*999)
              CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE,"U2",err,error,*999)
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U2_VARIABLE_TYPE, &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE, &
                & err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE, &
                & err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_DP_TYPE, &
                & err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_DP_TYPE, &
                & err,error,*999)
            CASE DEFAULT
              localError="The equations set subtype of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & numberOfComponents,err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & numberOfComponents,err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                & 1+NUMBER_OF_VOIGT(numberOfDimensions),err,error,*999)
            CASE(EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & numberOfComponents,err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & numberOfComponents,err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                & 1+NUMBER_OF_VOIGT(numberOfDimensions),err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U2_VARIABLE_TYPE, &
                & numberOfDimensions*numberOfDimensions,err,error,*999)
            CASE DEFAULT
              localError="The equations set subtype of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            !Default to the geometric interpolation setup
            CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
            DO componentIdx=1,numberOfComponents
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
            ENDDO !componentIdx
            IF(isHydrostaticPressureDependentField) THEN
              !Set the hydrostatic component to that of the first geometric component
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & numberOfDimensions+1,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & numberOfDimensions+1,geometricMeshComponent,err,error,*999)
            ENDIF
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Set the displacement components to node based interpolation
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField, &
                  & FIELD_DELUDELN_VARIABLE_TYPE,componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              IF(isHydrostaticPressureDependentField) THEN
                !Set the hydrostatic pressure component to element based interpolation
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & numberOfDimensions+1,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField, &
                  & FIELD_DELUDELN_VARIABLE_TYPE,numberOfDimensions+1,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              ENDIF
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE)
              !Set the U1 variable components
              DO componentIdx=1,1+NUMBER_OF_VOIGT(numberOfDimensions)
                CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                  & componentIdx,geometricMeshComponent,err,error,*999)
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                  & componentIdx,FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
            CASE(EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)
              !Set the U1 variable components
              DO componentIdx=1,1+NUMBER_OF_VOIGT(numberOfDimensions)
                CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                  & componentIdx,geometricMeshComponent,err,error,*999)
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                  & componentIdx,FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              !Set the U2 variable components
              DO componentIdx=1,numberOfDimensions*numberOfDimensions
                CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U2_VARIABLE_TYPE, &
                  & componentIdx,geometricMeshComponent,err,error,*999)
                CALL Field_ComponentInterpolationSet(equationsSet%dependent%dependentField,FIELD_U2_VARIABLE_TYPE, &
                  & componentIdx,FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
            CASE DEFAULT
              localError="The equations set subtype of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            !Default the scaling to the geometric field scaling
            CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
            CALL Field_ScalingTypeSet(equationsSet%dependent%dependentField,geometricScalingType,err,error,*999)
          ELSE
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_DEPENDENT_TYPE,err,error,*999)
            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE)
              CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,3,err,error,*999)
              CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_U1_VARIABLE_TYPE],err,error,*999)
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
                & err,error,*999)
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CASE( EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)
              CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,4,err,error,*999)
              CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE, &
                & FIELD_U1_VARIABLE_TYPE,FIELD_U2_VARIABLE_TYPE],err,error,*999)
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
                & err,error,*999)
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U2_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U2_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CASE DEFAULT
              localError="The equations set subtype of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents, &
              & err,error,*999)
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE)
              CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE, &
                & 1+NUMBER_OF_VOIGT(numberOfDimensions),err,error,*999)
              DO componentIdx=1,1+NUMBER_OF_VOIGT(numberOfDimensions)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,componentIdx, &
                  & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
            CASE(EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)
              CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE, &
                & 1+NUMBER_OF_VOIGT(numberOfDimensions),err,error,*999)
              CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U2_VARIABLE_TYPE, &
                & numberOfDimensions*numberOfDimensions,err,error,*999)
              DO componentIdx=1,1+NUMBER_OF_VOIGT(numberOfDimensions)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,componentIdx, &
                  & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              DO componentIdx=1,numberOfDimensions*numberOfDimensions
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U2_VARIABLE_TYPE,componentIdx, &
                  & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
            CASE DEFAULT
              localError="The equations set subtype of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            !Check that the pressure values set type is created here?? (second variable is a DELUDELN type, as checked above)
            !\todo: Decide whether these set_types (previous one as well) is to be created by user or automatically..
            CALL Field_ParameterSetEnsureCreated(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_PRESSURE_VALUES_SET_TYPE,err,error,*999)
          ENDIF
        CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            CALL Field_CreateFinish(equationsSet%dependent%dependentField,err,error,*999)
            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE)
              !Initialise U1 variables
              !Initialise Be prime to the identity matrix
              DO dimensionIdx=1,numberOfDimensions
                componentIdx=1+TENSOR_TO_VOIGT(dimensionIdx,dimensionIdx,numberOfDimensions)
                CALL Field_ComponentValuesInitialise(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                  & FIELD_VALUES_SET_TYPE,componentIdx,1.0_DP,err,error,*999)
              ENDDO !dimensionIdx
            CASE(EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
              & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)
              !Initialise U1 variables
              !Initialise Je to 1.0
              CALL Field_ComponentValuesInitialise(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                & FIELD_VALUES_SET_TYPE,1,1.0_DP,err,error,*999)
              !Initialise Be prime to the identity matrix
              DO dimensionIdx=1,numberOfDimensions
                componentIdx=1+TENSOR_TO_VOIGT(dimensionIdx,dimensionIdx,numberOfDimensions)
                CALL Field_ComponentValuesInitialise(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
                  & FIELD_VALUES_SET_TYPE,componentIdx,1.0_DP,err,error,*999)
              ENDDO !dimensionIdx
              !Initialise U2 variables
              !Initialise S to the identity matrix
              DO dimensionIdx=1,numberOfDimensions
                componentIdx=dimensionIdx+(dimensionIdx-1)*numberOfDimensions
                CALL Field_ComponentValuesInitialise(equationsSet%dependent%dependentField,FIELD_U2_VARIABLE_TYPE, &
                  & FIELD_VALUES_SET_TYPE,componentIdx,1.0_DP,err,error,*999)
              ENDDO !dimensionIdx
            CASE DEFAULT
              localError="The equations set subtype of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
          CALL Field_ParameterSetEnsureCreated(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
            & FIELD_PREVIOUS_VALUES_SET_TYPE,err,error,*999)
          CALL Field_ParameterSetEnsureCreated(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
            & FIELD_PREVIOUS_ITERATION_VALUES_SET_TYPE,err,error,*999)
          CALL Field_ParameterSetEnsureCreated(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
            & FIELD_PREVIOUS_VALUES_SET_TYPE,err,error,*999)
          CALL Field_ParameterSetEnsureCreated(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
            & FIELD_PRESSURE_VALUES_SET_TYPE,err,error,*999)
          SELECT CASE(equationsSetSubtype)
          CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
            & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE)
            CALL Field_ParameterSetEnsureCreated(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
              & FIELD_NEXT_VALUES_SET_TYPE,err,error,*999)
          CASE(EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
            & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)
            CALL Field_ParameterSetEnsureCreated(equationsSet%dependent%dependentField,FIELD_U1_VARIABLE_TYPE, &
              & FIELD_NEXT_VALUES_SET_TYPE,err,error,*999)
            CALL Field_ParameterSetEnsureCreated(equationsSet%dependent%dependentField,FIELD_U2_VARIABLE_TYPE, &
              & FIELD_NEXT_VALUES_SET_TYPE,err,error,*999)
          CASE DEFAULT
            localError="The equations set subtype of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity equation"
          CALL FlagError(localError,err,error,*999)
        END SELECT

      CASE(EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE,EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE, &
        & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE)
        !-------------------------------------------------------------------------------
        ! Shared Dependent field setup for multi-physics: elasticity coupled with Darcy
        !-------------------------------------------------------------------------------
        SELECT CASE(equationsSetSetup%actionType)
        CASE(EQUATIONS_SET_SETUP_START_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            !Create the auto created dependent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,equationsSet%dependent%dependentField,err,error,*999)
            CALL Field_TypeSetAndLock(equationsSet%dependent%dependentField,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(equationsSet%dependent%dependentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(equationsSet%dependent%dependentField,geometricField,err,error,*999)
            CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,4,err,error,*999)
            CALL Field_VariableTypesSetAndLock(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_V_VARIABLE_TYPE,FIELD_DELVDELN_VARIABLE_TYPE],err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE, &
              & err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE,FIELD_DP_TYPE, &
              & err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & numberOfComponents,err,error,*999)
            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE)
              numberOfDarcyComponents=numberOfDimensions+2 !for INRIA model: velocity components, pressure, mass increase
            CASE (EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE)
              numberOfDarcyComponents=numberOfDimensions+1 !for standard Darcy: velocity components and pressure
            CASE (EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE)
              numberOfDarcyComponents=numberOfDimensions+1 !for Darcy with pressure driven by solid: velocity components and mass increase
            END SELECT

            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
              & numberOfDarcyComponents,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE, &
              & numberOfDarcyComponents,err,error,*999)

            !Elasticity: Default to the geometric interpolation setup
            DO componentIdx=1,numberOfDimensions
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,componentIdx,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
            ENDDO !componentIdx

            IF (isHydrostaticPressureDependentField) THEN
              !Set the hydrostatic component to that of the first geometric component
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & numberOfComponents,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & numberOfComponents,geometricMeshComponent,err,error,*999)
              !kmith
            ENDIF

            !Darcy: Default to the geometric interpolation setup
            DO componentIdx=1,numberOfDimensions
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,componentIdx,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
            ENDDO !componentIdx

            !Darcy: Default pressure and, if present, mass increase to the first geometric component
            CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
            DO componentIdx=numberOfDimensions+1,numberOfDarcyComponents
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
            ENDDO !componentIdx

            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Elasticity: Set the displacement components to node based interpolation
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_DELUDELN_VARIABLE_TYPE,componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx

              IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE) THEN
                !Elasticity: Set the hydrostatic pressure component to node based interpolation
                !as this is used as the pressure field for the Darcy equations
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & numberOfComponents,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ELSE IF (isHydrostaticPressureDependentField) THEN
                !Elasticity: Set the hydrostatic pressure component to element based interpolation
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              ENDIF

              !Darcy: Set the velocity, pressure and, if present, mass increase components to node based interpolation
              DO componentIdx=1,numberOfDarcyComponents
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
                  & componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_DELVDELN_VARIABLE_TYPE,componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx

              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(equationsSet%dependent%dependentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_DEPENDENT_TYPE,err,error,*999)
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,4,err,error,*999)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE,&
              & FIELD_V_VARIABLE_TYPE,FIELD_DELVDELN_VARIABLE_TYPE],err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
              & err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_DELVDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
              & err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_DELVDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents, &
              & err,error,*999)

            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE)
              numberOfDarcyComponents=numberOfDimensions+2 !for INRIA model: velocity components, pressure, mass increase
            CASE (EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE)
              numberOfDarcyComponents=numberOfDimensions+1 !for standard Darcy: velocity components and pressure
            CASE (EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE)
              numberOfDarcyComponents=numberOfDimensions+1 !for Darcy with pressure driven by solid: velocity components and mass increase
            END SELECT

            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,numberOfDarcyComponents,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_DELVDELN_VARIABLE_TYPE,numberOfDarcyComponents, &
              & err,error,*999)

            !Check that the impermeability flag values set type is created here??
            !\todo: Decide whether these set_types is to be created by user or automatically..
            CALL Field_ParameterSetEnsureCreated(equationsSetSetup%field,FIELD_DELVDELN_VARIABLE_TYPE, &
              & FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE,err,error,*999)

            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Elasticity:
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE) THEN
                !If solid hydrostatic pressure is driving Darcy flow, check that pressure uses node based interpolation
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,4, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,4, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDIF
              !Darcy:
              DO componentIdx=1,numberOfDarcyComponents
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELVDELN_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx

            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            CALL Field_CreateFinish(equationsSet%dependent%dependentField,err,error,*999)
          ENDIF
          CALL Field_ParameterSetCreate(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
            & FIELD_INITIAL_VALUES_SET_TYPE,err,error,*999)
          CALL Field_ParameterSetCreate(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
            & FIELD_RELATIVE_VELOCITY_SET_TYPE,err,error,*999)
          CALL Field_ParameterSetCreate(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
            & FIELD_PREVIOUS_ITERATION_VALUES_SET_TYPE,err,error,*999)
          CALL Field_ParameterSetCreate(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE, &
            & FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE,err,error,*999)
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity equation"
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE, &
        & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE, &
        & EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE)
        !---------------------------------------------------------------------------------------------
        ! Shared Dependent field setup for multi-physics: elasticity coupled with Darcy fluid pressure
        !---------------------------------------------------------------------------------------------
        numberOfDarcyComponents=1 !Only solving for the fluid pressure at the moment
        SELECT CASE(equationsSetSetup%actionType)
        CASE(EQUATIONS_SET_SETUP_START_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            !Create the auto created dependent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,equationsSet%dependent%dependentField,err,error,*999)
            CALL Field_TypeSetAndLock(equationsSet%dependent%dependentField,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_LabelSet(equationsSet%dependent%dependentField,"Dependent Field",err,error,*999)
            CALL Field_DependentTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(equationsSet%dependent%dependentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(equationsSet%dependent%dependentField,geometricField,err,error,*999)
            CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,4,err,error,*999)
            CALL Field_VariableTypesSetAndLock(equationsSet%dependent%dependentField,[FIELD_U_VARIABLE_TYPE, &
              & FIELD_DELUDELN_VARIABLE_TYPE,FIELD_V_VARIABLE_TYPE,FIELD_DELVDELN_VARIABLE_TYPE],err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE, &
              & err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE,FIELD_DP_TYPE, &
              & err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
              & numberOfDarcyComponents,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE, &
              & numberOfDarcyComponents,err,error,*999)

            !Set labels
            CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,"U",err,error,*999)
            CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,"del U/del n", &
              & err,error,*999)
            CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE,"V",err,error,*999)
            CALL Field_VariableLabelSet(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE,"del V/del n", &
              & err,error,*999)
            CALL Field_ComponentLabelSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,1,"x1",err,error,*999)
            CALL Field_ComponentLabelSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,2,"x2",err,error,*999)
            CALL Field_ComponentLabelSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,3,"x3",err,error,*999)
            CALL Field_ComponentLabelSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,1,"del x1/del n", &
              & err,error,*999)
            CALL Field_ComponentLabelSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,2,"del x2/del n", &
              & err,error,*999)
            CALL Field_ComponentLabelSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,3,"del x3/del n", &
              & err,error,*999)
            CALL Field_ComponentLabelSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,1,"p",err,error,*999)
            CALL Field_ComponentLabelSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE,1,"del p/del n", &
              & err,error,*999)

            !Elasticity: Default to the geometric interpolation setup
            DO componentIdx=1,numberOfDimensions
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,componentIdx,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE,componentIdx, &
                & geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
            ENDDO !componentIdx
            !Darcy: Default pressure and mass increase to the first geometric component
            CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
            DO componentIdx=1,numberOfDarcyComponents
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
            ENDDO !componentIdx

            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Elasticity: Set the displacement components to node based interpolation
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_DELUDELN_VARIABLE_TYPE,componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              !Darcy: Set the pressure and mass increase components to node based interpolation
              DO componentIdx=1,numberOfDarcyComponents
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
                  & componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_DELVDELN_VARIABLE_TYPE,componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx

              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(equationsSet%dependent%dependentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_DEPENDENT_TYPE,err,error,*999)
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,4,err,error,*999)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_V_VARIABLE_TYPE,FIELD_DELVDELN_VARIABLE_TYPE],err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
              & err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_DELVDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
              & err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_DELVDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents, &
              & err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,numberOfDarcyComponents,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_DELVDELN_VARIABLE_TYPE,numberOfDarcyComponents, &
              & err,error,*999)

            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Elasticity:
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              !Darcy:
              DO componentIdx=1,numberOfDarcyComponents
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELVDELN_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx

            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            CALL Field_CreateFinish(equationsSet%dependent%dependentField,err,error,*999)
          ENDIF
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity equation"
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE)
        !-------------------------------------------------------------------------------
        ! Shared Dependent field setup for multi-physics: elasticity coupled with multi-compartment Darcy
        !-------------------------------------------------------------------------------
        !Get the number of Darcy compartments from the equations set field
        NULLIFY(equationsSetField)
        CALL EquationsSet_EquationsSetFieldGet(equationsSet,equationsSetField,err,error,*999)
        NULLIFY(equationsSetFieldData)
        CALL Field_ParameterSetDataGet(equationsSetField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,equationsSetFieldData, &
          & err,error,*999)
        numberOfCompartments=equationsSetFieldData(2)
        SELECT CASE(equationsSetSetup%actionType)
        CASE(EQUATIONS_SET_SETUP_START_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) THEN
            !Create the auto created dependent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,equationsSet%dependent%dependentField,err,error,*999)
            CALL Field_TypeSetAndLock(equationsSet%dependent%dependentField,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(equationsSet%dependent%dependentField,FIELD_DEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(equationsSet%dependent%dependentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(equationsSet%dependent%dependentField,geometricField,err,error,*999)
            !Set number of variables to be 2+2*numberOfCompartments
            CALL Field_NumberOfVariablesSetAndLock(equationsSet%dependent%dependentField,(2+2*numberOfCompartments),err,error,*999)
            ALLOCATE(variableTypes(2*numberOfCompartments+2),STAT=err)
            IF(err/=0) CALL FlagError("Could not allocate variable types.",err,error,*999)
            DO variableIdx=1,numberOfCompartments+1
              variableTypes(2*variableIdx-1)=FIELD_U_VARIABLE_TYPE+(FIELD_NUMBER_OF_VARIABLE_SUBTYPES*(variableIdx-1))
              variableTypes(2*variableIdx)=FIELD_DELUDELN_VARIABLE_TYPE+(FIELD_NUMBER_OF_VARIABLE_SUBTYPES*(variableIdx-1))
            ENDDO !variableIdx
            CALL Field_VariableTypesSetAndLock(equationsSetSetup%field,variableTypes,err,error,*999)
            numberOfComponents=numberOfDimensions+1
            numberOfDarcyComponents=numberOfDimensions+1 !for Darcy with pressure driven by solid: vel components and mass increase
            DO variableIdx=1,2*numberOfCompartments+2
              CALL Field_DimensionSetAndLock(equationsSet%dependent%dependentField,variableTypes(variableIdx), &
                & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
              CALL Field_DataTypeSetAndLock(equationsSet%dependent%dependentField,variableTypes(variableIdx), &
                & FIELD_DP_TYPE,err,error,*999)
              CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,variableTypes(variableIdx), &
                & numberOfComponents,err,error,*999)
            ENDDO !variableIdx

            !CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
            !  & numberOfComponents,err,error,*999)
            !CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
            !  & numberOfComponents,err,error,*999)
            !numberOfDarcyComponents=numberOfDimensions+1 !for Darcy with pressure driven by solid: vel components and mass increase
            !CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_V_VARIABLE_TYPE, &
            !  & numberOfDarcyComponents,err,error,*999)
            !CALL Field_NumberOfComponentsSetAndLock(equationsSet%dependent%dependentField,FIELD_DELVDELN_VARIABLE_TYPE, &
            !  & numberOfDarcyComponents,err,error,*999)

            !Elasticity: Default to the geometric interpolation setup
            DO componentIdx=1,numberOfDimensions
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,componentIdx,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                & componentIdx,geometricMeshComponent,err,error,*999)
            ENDDO !componentIdx

            !Set the hydrostatic component to that of the first geometric component
            CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
            CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              & numberOfComponents,geometricMeshComponent,err,error,*999)
            CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & numberOfComponents,geometricMeshComponent,err,error,*999)
            DO variableIdx=3,2*numberOfCompartments+2
              !Darcy: Default to the geometric interpolation setup
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,componentIdx,geometricMeshComponent, &
                  & err,error,*999)
                CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,variableTypes(variableIdx), &
                  & componentIdx,geometricMeshComponent,err,error,*999)
              ENDDO !componentIdx
              !Darcy: Default pressure and, if present, mass increase to the first geometric component
              DO componentIdx=numberOfDimensions+1,numberOfDarcyComponents
                CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent, &
                  & err,error,*999)
                CALL Field_ComponentMeshComponentSet(equationsSet%dependent%dependentField,variableTypes(variableIdx), &
                  & componentIdx,geometricMeshComponent,err,error,*999)
              ENDDO !componentIdx
            ENDDO !variableIdx
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Elasticity: Set the displacement components to node based interpolation
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                  & componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                  & FIELD_DELUDELN_VARIABLE_TYPE,componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx

              !IF(equationsSetSubtype==EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE) THEN
              !Elasticity: Set the hydrostatic pressure component to node based interpolation
              !as this is used as the pressure field for the Darcy equations
              CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
                & numberOfComponents,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                & FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              !ELSE IF (isHydrostaticPressureDependentField) THEN
              !  !Elasticity: Set the hydrostatic pressure component to element based interpolation
              !  CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField,FIELD_U_VARIABLE_TYPE, &
              !    & numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              !  CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
              !    & FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              !ENDIF
              DO variableIdx=3,2*numberOfCompartments+2
                !Darcy: Set the velocity, pressure and, if present, mass increase components to node based interpolation
                DO componentIdx=1,numberOfDarcyComponents
                  CALL Field_ComponentInterpolationSetAndLock(equationsSet%dependent%dependentField, &
                    & variableTypes(variableIdx),componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                ENDDO !componentIdx
              ENDDO !variableIdx
              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(equationsSet%dependent%dependentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GEOMETRIC_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_DEPENDENT_TYPE,err,error,*999)
            !Get the number of Darcy compartments from the equations set field
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,(2+2*numberOfCompartments),err,error,*999)
            ALLOCATE(variableTypes(2*numberOfCompartments+2),STAT=err)
            IF(err/=0) CALL FlagError("Could not allocate variable types.",err,error,*999)
            DO variableIdx=1,numberOfCompartments+1
              variableTypes(2*variableIdx-1)=FIELD_U_VARIABLE_TYPE+(FIELD_NUMBER_OF_VARIABLE_SUBTYPES*(variableIdx-1))
              variableTypes(2*variableIdx)=FIELD_DELUDELN_VARIABLE_TYPE+(FIELD_NUMBER_OF_VARIABLE_SUBTYPES*(variableIdx-1))
            ENDDO !variableIdx
            CALL Field_VariableTypesCheck(equationsSetSetup%field,variableTypes,err,error,*999)

            numberOfComponents=numberOfDimensions+1
            numberOfDarcyComponents=numberOfDimensions+1

            DO variableIdx=1,2*numberOfCompartments+2
              CALL Field_DimensionCheck(equationsSetSetup%field,variableTypes(variableIdx),FIELD_VECTOR_DIMENSION_TYPE, &
                & err,error,*999)
              CALL Field_DataTypeCheck(equationsSetSetup%field,variableTypes(variableIdx),FIELD_DP_TYPE,err,error,*999)
              CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,variableTypes(variableIdx),numberOfComponents, &
                & err,error,*999)
            ENDDO !variableIdx

            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Elasticity:
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,componentIdx, &
                  & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              !If solid hydrostatic pressure is driving Darcy flow, check that pressure uses node based interpolation
              CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfComponents, &
                & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents, &
                & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)

              DO variableIdx=3,2*numberOfCompartments+2
                !Darcy:
                DO componentIdx=1,numberOfDarcyComponents
                  CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,variableTypes(variableIdx),componentIdx, &
                    & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                ENDDO !componentIdx
              ENDDO !variableIdx
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            DEALLOCATE(variableTypes)
          ENDIF
        CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
          IF(equationsSet%dependent%dependentFieldAutoCreated) &
            & CALL Field_CreateFinish(equationsSet%dependent%dependentField,err,error,*999)
          ALLOCATE(variableTypes(2*numberOfCompartments+2),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate variable types.",err,error,*999)
          DO variableIdx=1,numberOfCompartments+1
            variableTypes(2*variableIdx-1)=FIELD_U_VARIABLE_TYPE+(FIELD_NUMBER_OF_VARIABLE_SUBTYPES*(variableIdx-1))
            variableTypes(2*variableIdx)=FIELD_DELUDELN_VARIABLE_TYPE+(FIELD_NUMBER_OF_VARIABLE_SUBTYPES*(variableIdx-1))
          ENDDO !variableIdx
          DO variableIdx=3,2*numberOfCompartments+2
            CALL Field_ParameterSetCreate(equationsSet%dependent%dependentField,variableTypes(variableIdx), &
              & FIELD_INITIAL_VALUES_SET_TYPE,err,error,*999)
            CALL Field_ParameterSetCreate(equationsSet%dependent%dependentField,variableTypes(variableIdx), &
              & FIELD_RELATIVE_VELOCITY_SET_TYPE,err,error,*999)
            CALL Field_ParameterSetCreate(equationsSet%dependent%dependentField,variableTypes(variableIdx), &
              & FIELD_PREVIOUS_ITERATION_VALUES_SET_TYPE,err,error,*999)
          ENDDO !variableIdx
          DEALLOCATE(variableTypes)
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity equation"
          CALL FlagError(localError,err,error,*999)
        END SELECT
        !end: Dependent field setup for elasticity coupled with Darcy
      CASE DEFAULT
        localError="The equation set subtype of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
          & " is invalid for a finite elasticity equation"
        CALL FlagError(localError,err,error,*999)
      END SELECT

    CASE(EQUATIONS_SET_SETUP_INDEPENDENT_TYPE)
      !-----------------------------------------------------------------
      ! I n d e p e n d e n t   f i e l d
      !-----------------------------------------------------------------
      NULLIFY(geometricField)
      CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
      CALL Field_NumberOfComponentsGet(geometricField,FIELD_U_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
      NULLIFY(esIndependent)
      CALL EquationsSet_IndependentGet(equationsSet,esIndependent,err,error,*999)
      SELECT CASE(equationsSetSetup%actionType)
      CASE(EQUATIONS_SET_SETUP_START_ACTION)
        SELECT CASE(equationsSetSubtype)
        CASE(EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE)
          !ACTIVE CONTRACTION
          numberOfComponents = 8  ! Q1 Q2 Q3 lambda    prev Q1 Q2 Q3 lambda
          CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
          IF(solutionMethod/=EQUATIONS_SET_FEM_SOLUTION_METHOD.OR..NOT.esIndependent%independentFieldAutoCreated) THEN
            CALL FlagError("Not implemented.",err,error,*999)
          ENDIF
          CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,esIndependent%independentField,err,error,*999)
          CALL Field_TypeSetAndLock(esIndependent%independentField,FIELD_GENERAL_TYPE,err,error,*999)
          CALL Field_DependentTypeSetAndLock(esIndependent%independentField,FIELD_INDEPENDENT_TYPE,err,error,*999)
          NULLIFY(geometricDecomposition)
          CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
          CALL Field_DecompositionSetAndLock(esIndependent%independentField,geometricDecomposition,err,error,*999)
          CALL Field_GeometricFieldSetAndLock(esIndependent%independentField,geometricField,err,error,*999)
          CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,numberOfComponents, &
            & err,error,*999)

          DO componentIdx=1,numberOfComponents ! other gauss pt based
            CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,componentIdx, &
              & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
          ENDDO !componentIdx

        CASE(EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE,EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE, EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE)
          !Mooney Rivlin, St Venant Kirchoff and Compressible active contraction subtype
          numberOfComponents = 3 !one contractile stress value for each of the three directions
          IF(esIndependent%independentFieldAutoCreated) THEN
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,esIndependent%independentField,err,error,*999)
            CALL Field_TypeSetAndLock(esIndependent%independentField,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(esIndependent%independentField,FIELD_INDEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(esIndependent%independentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(esIndependent%independentField,geometricField,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,numberOfComponents, &
              & err,error,*999)
            !Set component to be gauss point based
            DO componentIdx=1,numberOfComponents
              CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,componentIdx, &
                & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
            ENDDO !componentIdx
          ELSE
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_INDEPENDENT_TYPE,err,error,*999)
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,1,err,error,*999)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE],err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
          ENDIF !equationsSet%dependent%dependentFieldAutoCreated
          CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
          SELECT CASE(solutionMethod)
          CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
            !Check field interpolation
            !TODO: Field_ComponentInterpolationCheck only checks for a specific type of interpolation and does not check
            !against multiple interpolation types that could be valid
            !DO componentIdx=1,numberOfComponents
            !  CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,componentIdx, &
            !    & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
            !ENDDO !componentIdx
          CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT

        CASE(EQUATIONS_SET_STANDARD_ELASTICITY_DARCY_SUBTYPE,EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE, &
          & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE,EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE,&
          & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE, &
          & EQUATIONS_SET_ELASTICITY_MULTI_COMPARTMENT_DARCY_INRIA_SUBTYPE, &
          & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE,EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE)
          ! COUPLED DARCY
          IF(esIndependent%independentFieldAutoCreated) THEN
            !Create the auto created dependent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,esIndependent%independentField,err,error,*999)
            CALL Field_TypeSetAndLock(esIndependent%independentField,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(esIndependent%independentField,FIELD_INDEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(esIndependent%independentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(esIndependent%independentField,geometricField,err,error,*999)
            CALL Field_NumberOfVariablesSetAndLock(esIndependent%independentField,2,err,error,*999)
            CALL Field_DimensionSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
              & err,error,*999)
            CALL Field_DimensionSetAndLock(esIndependent%independentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(esIndependent%independentField,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            numberOfComponents=numberOfDimensions !+1 !Include hydrostatic pressure component
            CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,numberOfComponents, &
              & err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              & numberOfComponents,err,error,*999)
            !Default to the geometric interpolation setup
            DO componentIdx=1,numberOfDimensions
              CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,componentIdx,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,componentIdx, &
                & geometricMeshComponent,err,error,*999)
              CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_DELUDELN_VARIABLE_TYPE,componentIdx, &
                & geometricMeshComponent,err,error,*999)
            ENDDO !componentIdx

            !Set the hydrostatic component to that of the first geometric component
            !CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
            !CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,numberOfComponents, &
            !  & geometricMeshComponent,err,error,*999)
            !CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_DELUDELN_VARIABLE_TYPE, &
            !  & numberOfComponents,geometricMeshComponent,err,error,*999)

            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Set the displacement components to node based interpolation
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE, &
                  & componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_DELUDELN_VARIABLE_TYPE, &
                  & componentIdx,FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              !Set the hydrostatic pressure component to element based interpolation
              !CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE, &
              !  & numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              !CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_DELUDELN_VARIABLE_TYPE, &
              !  & numberOfComponents,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(esIndependent%independentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE !independentField_AUTO_CREATED
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_INDEPENDENT_TYPE,err,error,*999)
            !Question:Better to leave it up for the user to play around?
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,2,err,error,*999)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE], &
              & err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
              & err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,numberOfComponents, &
              & err,error,*999)
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !DO componentIdx=1,numberOfDimensions
              !  CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,componentIdx, &
              !    & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              !  CALL Field_ComponentInterpolationCheck(equationsSetSetup%field,FIELD_DELUDELN_VARIABLE_TYPE,componentIdx, &
              !    & FIELD_NODE_BASED_INTERPOLATION,err,error,*999)
              !ENDDO !componentIdx
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF !independentField_AUTO_CREATED

        CASE(EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE)
          ! BIOELECTRICS COUPLED TO FINITE ELASTICITY
          IF(esIndependent%independentFieldAutoCreated) THEN
            !Create the auto created dependent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,esIndependent%independentField,err,error,*999)
            CALL Field_TypeSetAndLock(esIndependent%independentField,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(esIndependent%independentField,FIELD_INDEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(esIndependent%independentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(esIndependent%independentField,geometricField,err,error,*999)
            CALL Field_NumberOfVariablesSetAndLock(esIndependent%independentField,1,err,error,*999)
            CALL Field_DimensionSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,FIELD_SCALAR_DIMENSION_TYPE, &
              & err,error,*999)
            CALL Field_DataTypeSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,1,err,error,*999)
            !Default to the first component of the geometric interpolation setup
            CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
            CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent, &
              & err,error,*999)

            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Set to node based interpolation
              CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,1, &
                & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(esIndependent%independentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE !independentField_AUTO_CREATED
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_INDEPENDENT_TYPE,err,error,*999)
            !Question:Better to leave it up for the user to play around?
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,1,err,error,*999)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE],err,error,*999)
            CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_SCALAR_DIMENSION_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,1,err,error,*999)
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !do/check nothing???
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF !independentField_AUTO_CREATED

        CASE(EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE,EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE, &
          & EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE)
          IF(esIndependent%independentFieldAutoCreated) THEN
            !Create the auto created independent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,esIndependent%independentField,err,error,*999)
            CALL Field_TypeSetAndLock(esIndependent%independentField,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(esIndependent%independentField,FIELD_INDEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(esIndependent%independentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(esIndependent%independentField,geometricField,err,error,*999)
            CALL Field_NumberOfVariablesSetAndLock(esIndependent%independentField,2,err,error,*999)
            CALL Field_VariableTypesSetAndLock(esIndependent%independentField,[FIELD_U_VARIABLE_TYPE,FIELD_V_VARIABLE_TYPE], &
              & err,error,*999)
            IF(equationsSetSubtype==EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE) THEN
              CALL Field_DimensionSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,FIELD_SCALAR_DIMENSION_TYPE, &
                & err,error,*999)
            ENDIF
            CALL Field_DataTypeSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(esIndependent%independentField,FIELD_V_VARIABLE_TYPE,FIELD_INTG_TYPE,err,error,*999)
            IF(equationsSetSubtype==EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE) THEN
              CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,1,err,error,*999)
            ELSE IF(equationsSetSubtype==EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE) THEN
              CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,6,err,error,*999)
            ELSE IF(equationsSetSubtype==EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,5,err,error,*999)
            ENDIF
            CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_V_VARIABLE_TYPE,numberOfDimensions+1, &
              & err,error,*999)
            !Default to the first component of the geometric interpolation setup
            CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
            CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent, &
              & err,error,*999)
            IF(equationsSetSubtype==EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE) THEN
              CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,2,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,3,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,4,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,5,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,6,geometricMeshComponent, &
                & err,error,*999)
            ELSE IF(equationsSetSubtype==EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,2,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,3,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,4,geometricMeshComponent, &
                & err,error,*999)
              CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,5,geometricMeshComponent, &
                & err,error,*999)
            ENDIF
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Set to node based interpolation
              CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,1, &
                & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              IF(equationsSetSubtype==EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE) THEN
                CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,2, &
                  & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,3, &
                  & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,4, &
                  & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,5, &
                  & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
                CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,6, &
                  & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              ENDIF
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_V_VARIABLE_TYPE, &
                  & componentIdx,FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(esIndependent%independentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE !independentField_AUTO_CREATED
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_INDEPENDENT_TYPE,err,error,*999)
            !Question:Better to leave it up for the user to play around?
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,2,err,error,*999)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_V_VARIABLE_TYPE],err,error,*999)
            IF(equationsSetSubtype==EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE) THEN
              CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_SCALAR_DIMENSION_TYPE,err,error,*999)
            ENDIF
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,FIELD_INTG_TYPE,err,error,*999)
            IF(equationsSetSubtype==EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE) THEN
              CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,1,err,error,*999)
            ELSE IF(equationsSetSubtype==EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE) THEN
              CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,6,err,error,*999)
            ELSE IF(equationsSetSubtype==EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE) THEN
              CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,5,err,error,*999)
            ENDIF
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,numberOfDimensions+1,err,error,*999)
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !do/check nothing???
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF !independentField_AUTO_CREATED

        CASE(EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE)
          IF(esIndependent%independentFieldAutoCreated) THEN
            !Create the auto created independent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,esIndependent%independentField,err,error,*999)
            CALL Field_TypeSetAndLock(esIndependent%independentField,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(esIndependent%independentField,FIELD_INDEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(esIndependent%independentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(esIndependent%independentField,geometricField,err,error,*999)
            CALL Field_NumberOfVariablesSetAndLock(esIndependent%independentField,3,err,error,*999)
            CALL Field_VariableTypesSetAndLock(esIndependent%independentField,[FIELD_U_VARIABLE_TYPE,FIELD_V_VARIABLE_TYPE, &
              & FIELD_U1_VARIABLE_TYPE],err,error,*999)
            CALL Field_DataTypeSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(esIndependent%independentField,FIELD_V_VARIABLE_TYPE,FIELD_INTG_TYPE,err,error,*999)
            CALL Field_DataTypeSetAndLock(esIndependent%independentField,FIELD_U1_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,1,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_V_VARIABLE_TYPE,numberOfDimensions+1, &
              & err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_U1_VARIABLE_TYPE,3,err,error,*999)
            !Default to the first component of the geometric interpolation setup
            CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
            CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent, &
              & err,error,*999)
            CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,2,geometricMeshComponent, &
              & err,error,*999)
            CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U1_VARIABLE_TYPE,1,geometricMeshComponent, &
              & err,error,*999)
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Set to node based interpolation
              CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,1, &
                & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U1_VARIABLE_TYPE,1, &
                & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              DO componentIdx=1,numberOfDimensions
                CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_V_VARIABLE_TYPE,componentIdx, &
                  & FIELD_ELEMENT_BASED_INTERPOLATION,err,error,*999)
              ENDDO !componentIdx
              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(esIndependent%independentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE !independentField_AUTO_CREATED
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_INDEPENDENT_TYPE,err,error,*999)
            !Question:Better to leave it up for the user to play around?
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,3,err,error,*999)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_V_VARIABLE_TYPE, &
              & FIELD_U1_VARIABLE_TYPE],err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,FIELD_INTG_TYPE,err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,1,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,numberOfDimensions+1,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,3,err,error,*999)
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !do/check nothing???
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF !independentFieldAutoCreated

        CASE(EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE)
          IF(esIndependent%independentFieldAutoCreated) THEN
            !Create the auto created independent field
            CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,esIndependent%independentField,err,error,*999)
            CALL Field_TypeSetAndLock(esIndependent%independentField,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeSetAndLock(esIndependent%independentField,FIELD_INDEPENDENT_TYPE,err,error,*999)
            NULLIFY(geometricDecomposition)
            CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
            CALL Field_DecompositionSetAndLock(esIndependent%independentField,geometricDecomposition,err,error,*999)
            CALL Field_GeometricFieldSetAndLock(esIndependent%independentField,geometricField,err,error,*999)
            CALL Field_NumberOfVariablesSetAndLock(esIndependent%independentField,1,err,error,*999)
            CALL Field_VariableTypesSetAndLock(esIndependent%independentField,[FIELD_U_VARIABLE_TYPE],err,error,*999)
            CALL Field_DataTypeSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,4,err,error,*999)
            !Default to the first component of the geometric interpolation setup
            CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)
            CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent, &
              & err,error,*999)
            CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,2,geometricMeshComponent, &
              & err,error,*999)
            CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,3,geometricMeshComponent, &
              & err,error,*999)
            CALL Field_ComponentMeshComponentSet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,4,geometricMeshComponent, &
              & err,error,*999)
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !Set to node based interpolation
              CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,1, &
                & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              CALL Field_ComponentInterpolationSetAndLock(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,2, &
                & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999)
              !Default the scaling to the geometric field scaling
              CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
              CALL Field_ScalingTypeSet(esIndependent%independentField,geometricScalingType,err,error,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE !independentFieldAutoCreated
            !Check the user specified field
            CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GENERAL_TYPE,err,error,*999)
            CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_INDEPENDENT_TYPE,err,error,*999)
            !Question:Better to leave it up for the user to play around?
            CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,1,err,error,*999)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE],err,error,*999)
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,4,err,error,*999)              
            CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
            SELECT CASE(solutionMethod)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              !do/check nothing???
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF !independentFieldAutoCreated

        CASE DEFAULT
          localError="The third equations set specification of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
            & " is invalid for an independent field of a finite elasticity equation."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
        IF(esIndependent%independentFieldAutoCreated) THEN
          CALL Field_CreateFinish(esIndependent%independentField,err,error,*999)
          ! initialize values for active contraction independent field. TODO: actual init for z, trpn, or flag to presolve
          IF(equationsSetSubtype==EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE) THEN
            CALL Field_NumberOfComponentsGet(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,numberOfComponents, &
              & err,error,*999)
            DO componentIdx=1,numberOfComponents
              CALL Field_ComponentValuesInitialise(esIndependent%independentField,FIELD_U_VARIABLE_TYPE, &
                & FIELD_VALUES_SET_TYPE,componentIdx,0.0_DP,Err,ERROR,*999)
            ENDDO !componentIdx
          ENDIF
        ENDIF
        IF(equationsSetSubtype==EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE) THEN
          CALL Field_ParameterSetCreate(esIndependent%independentField,FIELD_U_VARIABLE_TYPE,FIELD_PREVIOUS_VALUES_SET_TYPE, &
            & err,error,*999)
          CALL Field_ParameterSetCreate(esIndependent%independentField,FIELD_U1_VARIABLE_TYPE,FIELD_PREVIOUS_VALUES_SET_TYPE, &
            & err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
          & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
          & " is invalid for a finite elasticity equation."
        CALL FlagError(localError,err,error,*999)
      END SELECT

    CASE(EQUATIONS_SET_SETUP_MATERIALS_TYPE)
      !-----------------------------------------------------------------
      ! M a t e r i a l s   f i e l d
      !-----------------------------------------------------------------
      NULLIFY(esMaterials)
      CALL EquationsSet_MaterialsGet(equationsSet,esMaterials,err,error,*999)
      NULLIFY(geometricField)
      CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
      CALL Field_NumberOfComponentsGet(geometricFIeld,FIELD_U_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
      SELECT CASE(equationsSetSetup%actionType)
      CASE(EQUATIONS_SET_SETUP_START_ACTION)
        numberOfFluidComponents=0
        SELECT CASE(equationsSetSubtype)
        CASE(EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_NO_SUBTYPE, &
          & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE, &
          & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE, &
          & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
          numberOfComponents=2;
        CASE(EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE)
          numberOfComponents=8;
        CASE(EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE)
          numberOfComponents=8;
        CASE(EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
          & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE)
          numberOfComponents=3;
        CASE(EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE,EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE)
          numberOfComponents=5;
        CASE(EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE)
          numberOfComponents=6;
        CASE(EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE)
          numberOfComponents=8;
        CASE(EQUATIONS_SET_MEMBRANE_SUBTYPE)
          !\todo Currently the number of components for a membrane problem's material field has been set to 3 in 3D space or
          ! 2 in 2D space to work with a Mooney Rivlin material (2 material parameters) and a membrane thickness parameter
          ! (only if in 3D space). Extra subtypes will need to be added to use other constitutive relations with
          ! membrane mechanics problems.
          IF(numberOfDimensions==3) THEN
            numberOfComponents=3
          ELSE
            numberOfComponents=2
          ENDIF
        CASE(EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE, &
          & EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE, &
          & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE)
          numberOfComponents=2;
        CASE(EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE)
          numberOfComponents=2;
        CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE)
          numberOfComponents=5;
        CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE)
          numberOfComponents=4;
        CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE)
          numberOfComponents=5;
        CASE(EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE)
          numberOfComponents=8;
        CASE(EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE)
          numberOfComponents=12;
        CASE(EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE)
          numberOfComponents=11;
        CASE(EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE,EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE)
          numberOfComponents=7;
        CASE(EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE,&
          & EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE)
          numberOfComponents=3;
        CASE(EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE, &
          & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE)
          numberOfComponents=8;
        CASE(EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE)
          numberOfComponents=2;  
        CASE(EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE)
          numberOfComponents=3;
        CASE(EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
          & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, &
          & EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE, &
          & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE)
          numberOfComponents=4;
        CASE(EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE)
          numberOfComponents=6;
          numberOfFluidComponents=8
        CASE(EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE)
          numberOfComponents=4
          numberOfFluidComponents=8
        CASE(EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE)
          numberOfComponents=6
          numberOfFluidComponents=8
        CASE(EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE)
          numberOfComponents=24
        CASE(EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE)
          CALL FlagError("Materials field is not required for CellML based constituative laws.",err,error,*999)
        CASE(EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE)
          CALL FlagError("Materials field is not required for CellML based constituative laws.",err,error,*999)
        CASE(EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE)
          numberOfComponents=7
        CASE(EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE)
          numberOfComponents=8
        CASE(EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE)
          numberOfComponents=9+3+NUMBER_OF_VOIGT(numberOfDimensions)
        CASE(EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)
          numberOfComponents=9+3+NUMBER_OF_VOIGT(numberOfDimensions)
        CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
          numberOfComponents=3 !Density, lambda and mu
        CASE(EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE)
          numberOfComponents=3 !Density, c01 and c10.
        CASE DEFAULT
          localError="The third equations set specification of "//TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
            & " is not valid for a finite elasticity type of an elasticity equation set."
          CALL FlagError(localError,err,error,*999)
        END SELECT
        IF(esMaterials%materialsFieldAutoCreated) THEN
          !Create the auto created materials field
          CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,esMaterials%materialsField,err,error,*999)
          CALL Field_TypeSetAndLock(esMaterials%materialsField,FIELD_MATERIAL_TYPE,err,error,*999)
          CALL Field_DependentTypeSetAndLock(esMaterials%materialsField,FIELD_INDEPENDENT_TYPE,err,error,*999)
          NULLIFY(geometricDecomposition)
          CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
          CALL Field_DecompositionSetAndLock(esMaterials%materialsField,geometricDecomposition,err,error,*999)
          CALL Field_GeometricFieldSetAndLock(esMaterials%materialsField,geometricField,err,error,*999)
          CALL Field_ComponentMeshComponentGet(geometricField,FIELD_U_VARIABLE_TYPE,1,geometricMeshComponent,err,error,*999)  ! get 1 = x (?) component

          !U variable type is constitutive law parameters
          !V variable type has one component, density
          IF(numberOfFluidComponents>0) THEN
            !If coupled with Darcy pressure equation then a shared material field is used and Darcy material parameters are in U1
            CALL Field_NumberOfVariablesSetAndLock(esMaterials%materialsField,3,err,error,*999)
            CALL Field_VariableTypesSetAndLock(esMaterials%materialsField,[FIELD_U_VARIABLE_TYPE,FIELD_V_VARIABLE_TYPE, &
              & FIELD_U1_VARIABLE_TYPE],err,error,*999)
          ELSE
            CALL Field_NumberOfVariablesSetAndLock(esMaterials%materialsField,2,err,error,*999)
            CALL Field_VariableTypesSetAndLock(esMaterials%materialsField,[FIELD_U_VARIABLE_TYPE,FIELD_V_VARIABLE_TYPE], &
              & err,error,*999)
          ENDIF
          CALL Field_LabelSet(esMaterials%materialsField,"Materials",err,error,*999)

          CALL Field_DimensionSetAndLock(esMaterials%materialsField,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
            & err,error,*999)
          CALL Field_DataTypeSetAndLock(esMaterials%materialsField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
          CALL Field_NumberOfComponentsSetAndLock(esMaterials%materialsField,FIELD_U_VARIABLE_TYPE,numberOfComponents, &
            & err,error,*999)
          CALL Field_DimensionSetAndLock(esMaterials%materialsField,FIELD_V_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, &
            & err,error,*999)
          CALL Field_DataTypeSetAndLock(esMaterials%materialsField,FIELD_V_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
          CALL Field_VariableLabelSet(esMaterials%materialsField,FIELD_U_VARIABLE_TYPE,"Parameters",err,error,*999)

          IF(equationsSetSubtype == EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE) THEN
            CALL Field_NumberOfComponentsSetAndLock(esMaterials%materialsField,FIELD_V_VARIABLE_TYPE,1,err,error,*999) ! just 1 component: activation time
            CALL Field_ComponentInterpolationSetAndLock(esMaterials%materialsField,FIELD_V_VARIABLE_TYPE,1, &
              & FIELD_GAUSS_POINT_BASED_INTERPOLATION,err,error,*999) ! gauss pt based interp.
          ELSE
            !Solid density
            CALL Field_NumberOfComponentsSetAndLock(esMaterials%materialsField,FIELD_V_VARIABLE_TYPE,1,err,error,*999)
            CALL Field_ComponentInterpolationSet(esMaterials%materialsField,FIELD_V_VARIABLE_TYPE,1, &
              & FIELD_CONSTANT_INTERPOLATION,err,error,*999)
            CALL Field_ComponentMeshComponentSet(esMaterials%materialsField,FIELD_V_VARIABLE_TYPE,1, &
              & geometricMeshComponent,err,error,*999)
            CALL Field_VariableLabelSet(esMaterials%materialsField,FIELD_V_VARIABLE_TYPE,"Density",err,error,*999)
          ENDIF

          DO componentIdx=1,numberOfComponents
            !Default the materials components to the geometric interpolation setup with constant interpolation
            CALL Field_ComponentInterpolationSet(esMaterials%materialsField,FIELD_U_VARIABLE_TYPE,componentIdx, &
              & FIELD_CONSTANT_INTERPOLATION,err,error,*999)
            CALL Field_ComponentMeshComponentSet(esMaterials%materialsField,FIELD_U_VARIABLE_TYPE,componentIdx, &
              & geometricMeshComponent,err,error,*999)
          ENDDO

          IF(numberOfFluidComponents>0) THEN
            CALL Field_NumberOfComponentsSetAndLock(esMaterials%materialsField,FIELD_U1_VARIABLE_TYPE,numberOfFluidComponents, &
              & err,error,*999)
            CALL Field_VariableLabelSet(esMaterials%materialsField,FIELD_U1_VARIABLE_TYPE,"Fluid Parameters",err,error,*999)
          ENDIF
          DO componentIdx=1,numberOfFluidComponents
            CALL Field_ComponentInterpolationSet(esMaterials%materialsField,FIELD_U1_VARIABLE_TYPE,componentIdx, &
              & FIELD_CONSTANT_INTERPOLATION,err,error,*999)
            CALL Field_ComponentMeshComponentSet(esMaterials%materialsField,FIELD_U1_VARIABLE_TYPE,componentIdx, &
              & geometricMeshComponent,err,error,*999)
          ENDDO !componentIdx

          !Default the field scaling to that of the geometric field
          CALL Field_ScalingTypeGet(geometricField,geometricScalingType,err,error,*999)
          CALL Field_ScalingTypeSet(esMaterials%materialsField,geometricScalingType,err,error,*999)
        ELSE
          !Check the user specified field
          CALL Field_TypeCheck(equationsSetSetup%field,FIELD_MATERIAL_TYPE,err,error,*999)
          CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_INDEPENDENT_TYPE,err,error,*999)
          CALL Field_NumberOfVariablesGet(equationsSetSetup%field,equationsSetFieldNumberOfVariables,err,error,*999)
          SELECT CASE(equationsSetFieldNumberOfVariables)
          CASE(1)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE],err,error,*999)
          CASE(2)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_V_VARIABLE_TYPE],err,error,*999)
          CASE(3)
            CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE,FIELD_V_VARIABLE_TYPE, &
              & FIELD_U1_VARIABLE_TYPE],err,error,*999)
          CASE DEFAULT
            localError="Invalid number of variables. The number of variables for field number "// &
              & TRIM(NumberToVString(equationsSetSetup%field%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(equationsSetFieldNumberOfVariables,"*",err,error))// &
              & " but should be either 1, 2 or 3."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
          CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
          CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
          IF(equationsSetFieldNumberOfVariables>1) THEN
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_V_VARIABLE_TYPE,1,err,error,*999)
          ENDIF
          IF (equationsSetFieldNumberOfVariables>2) THEN
            CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
            CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U1_VARIABLE_TYPE,numberOfFluidComponents, &
              & err,error,*999)
          ENDIF
        ENDIF
      CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
        IF(esMaterials%materialsFieldAutoCreated) THEN
          !Finish creating the materials field
          CALL Field_CreateFinish(esMaterials%materialsField,err,error,*999)
          !Set the default values for the materials field
          !Don't bother checking equations types, just default to all componets = 1.0
          CALL Field_NumberOfComponentsGet(esMaterials%materialsField,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
          DO componentIdx=1,numberOfComponents
            CALL Field_ComponentValuesInitialise(esMaterials%materialsField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
              & componentIdx,1.0_DP,err,error,*999)
          ENDDO !componentIdx
          !Initialise density to 0
          CALL Field_ComponentValuesInitialise(esMaterials%materialsField,FIELD_V_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,1, &
            & 0.0_DP,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
          & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
          & " is invalid for a finite elasticity equation."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(EQUATIONS_SET_SETUP_SOURCE_TYPE)
      !-----------------------------------------------------------------
      ! S o u r c e   f i e l d 
      !-----------------------------------------------------------------
      NULLIFY(esSource)
      CALL EquationsSet_SourceGet(equationsSet,esSource,err,error,*999)
      NULLIFY(geometricField)
      CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
      CALL Field_NumberOfComponentsGet(geometricField,FIELD_U_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
      numberOfComponents=numberOfDimensions
      SELECT CASE(equationsSetSetup%actionType)
      CASE(EQUATIONS_SET_SETUP_START_ACTION)
        IF(esSource%sourceFieldAutoCreated) THEN
          CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,esSource%sourceField,err,error,*999)
          CALL Field_TypeSetAndLock(esSource%sourceField,FIELD_GENERAL_TYPE,err,error,*999)
          CALL Field_LabelSet(esSource%sourceField,"Source Field",err,error,*999)
          CALL Field_DependentTypeSetAndLock(esSource%sourceField,FIELD_INDEPENDENT_TYPE,err,error,*999)
          NULLIFY(geometricDecomposition)
          CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
          CALL Field_DecompositionSetAndLock(esSource%sourceField,geometricDecomposition,err,error,*999)
          CALL Field_GeometricFieldSetAndLock(esSource%sourceField,geometricField,err,error,*999)
          CALL Field_NumberOfVariablesSetAndLock(esSource%sourceField,1,err,error,*999)
          CALL Field_VariableTypesSetAndLock(esSource%sourceField,[FIELD_U_VARIABLE_TYPE],err,error,*999)
          CALL Field_DimensionSetAndLock(esSource%sourceField,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
          CALL Field_DataTypeSetAndLock(esSource%sourceField,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
          CALL Field_NumberOfComponentsSetAndLock(esSource%sourceField,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
          CALL Field_VariableLabelSet(esSource%sourceField,FIELD_U_VARIABLE_TYPE,"Gravity",err,error,*999)
          CALL Field_ComponentLabelSet(esSource%sourceField,FIELD_U_VARIABLE_TYPE,1,"g1",err,error,*999)
          CALL Field_ComponentLabelSet(esSource%sourceField,FIELD_U_VARIABLE_TYPE,2,"g2",err,error,*999)
          IF(numberOfComponents==3) THEN
            CALL Field_ComponentLabelSet(esSource%sourceField,FIELD_U_VARIABLE_TYPE,3,"g3",err,error,*999)
          ENDIF
          
          DO componentIdx=1,numberOfComponents
            CALL Field_ComponentInterpolationSetAndLock(esSource%sourceField,FIELD_U_VARIABLE_TYPE,componentIdx, &
              & FIELD_CONSTANT_INTERPOLATION,err,error,*999)
          ENDDO !componentIdx
        ELSE
          !Check the user specified field
          CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GENERAL_TYPE,err,error,*999)
          CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_INDEPENDENT_TYPE,err,error,*999)
          CALL Field_NumberOfVariablesCheck(equationsSetSetup%field,1,err,error,*999)
          CALL Field_VariableTypesCheck(equationsSetSetup%field,[FIELD_U_VARIABLE_TYPE],err,error,*999)
          CALL Field_DimensionCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_VECTOR_DIMENSION_TYPE, err,error,*999)
          CALL Field_DataTypeCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,FIELD_DP_TYPE,err,error,*999)
          CALL Field_NumberOfComponentsCheck(equationsSetSetup%field,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
        ENDIF
      CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
        IF(esSource%sourceFieldAutoCreated) THEN
          !Finish creating the source field
          CALL Field_CreateFinish(esSource%sourceField,err,error,*999)
          !Set the default values for the field
          CALL Field_NumberOfComponentsGet(esSource%sourceField,FIELD_U_VARIABLE_TYPE,numberOfComponents,err,error,*999)
          DO componentIdx=1,numberOfComponents-1
            CALL Field_ComponentValuesInitialise(esSource%sourceField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
              & componentIdx,0.0_DP,err,error,*999)
          ENDDO !componentIdx
          CALL Field_ComponentValuesInitialise(esSource%sourceField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
            & numberOfComponents,-9.80665_DP,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
          & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
          & " is invalid for a finite elasticity equation."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(EQUATIONS_SET_SETUP_ANALYTIC_TYPE)
      !-----------------------------------------------------------------
      ! A n a l y t i c   f i e l d
      !-----------------------------------------------------------------
      NULLIFY(esAnalytic)
      CALL EquationsSet_AnalyticGet(equationsSet,esAnalytic,err,error,*999)
      NULLIFY(geometricField)
      CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
      CALL Field_NumberOfComponentsGet(geometricField,FIELD_U_VARIABLE_TYPE,numberOfDimensions,err,error,*999)
      SELECT CASE(equationsSetSetup%actionType)
      CASE(EQUATIONS_SET_SETUP_START_ACTION)
        CALL EquationsSet_AssertDependentIsFinished(equationsSet,err,error,*999)
        NULLIFY(dependentField)
        CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
        SELECT CASE(equationsSetSetup%analyticFunctionType)
        CASE(EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER)
          IF(equationsSetSubtype==EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE) THEN
            !Create analytic field if required
            !Set analtyic function type
            esAnalytic%analyticFunctionType=EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER
          ELSE
            localError="The thrid equations set specification of "// &
              & TRIM(NumberToVString(equationsSetSubtype,"*",err,error))// &
              & " is invalid. The analytic function type of "// &
              & TRIM(NumberToVString(equationsSetSetup%analyticFunctionType,"*",err,error))// &
              & " requires that the third equations set specification be a Mooney-Rivlin finite elasticity equation."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE DEFAULT
          localError="The specified analytic function type of "// &
            & TRIM(NumberToVString(equationsSetSetup%analyticFunctionType,"*",err,error))// &
            & " is invalid for a finite elasticity equation."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
        NULLIFY(analyticField)
        CALL EquationsSet_AnalyticFieldExists(equationsSet,analyticField,err,error,*999)
        IF(ASSOCIATED(analyticField)) THEN
          IF(esAnalytic%analyticFieldAutoCreated) THEN
            CALL Field_CreateFinish(esAnalytic%analyticField,err,error,*999)
          ENDIF
        ENDIF
      CASE DEFAULT
        localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
          & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
          & " is invalid for a finite elasticity equation."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(EQUATIONS_SET_SETUP_EQUATIONS_TYPE)
      !-----------------------------------------------------------------
      ! E q u a t i o n s 
      !-----------------------------------------------------------------
      SELECT CASE(equationsSetSetup%actionType)
      CASE(EQUATIONS_SET_SETUP_START_ACTION)
        CALL EquationsSet_AssertDependentIsFinished(equationsSet,err,error,*999)
        !Start the equations creation
        NULLIFY(equations)
        CALL Equations_CreateStart(equationsSet,equations,err,error,*999)
        CALL Equations_LinearityTypeSet(equations,EQUATIONS_NONLINEAR,err,error,*999)
        SELECT CASE(equationsSetSubtype)
        CASE(EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE, & 
          & EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE, & 
          & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE)
          CALL Equations_TimeDependenceTypeSet(equations,EQUATIONS_QUASISTATIC,err,error,*999)
        CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
          & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE)
          CALL Equations_TimeDependenceTypeSet(equations,EQUATIONS_SECOND_ORDER_DYNAMIC,err,error,*999)                
        CASE DEFAULT
          CALL Equations_TimeDependenceTypeSet(equations,EQUATIONS_STATIC,err,error,*999)
        END SELECT
      CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
        CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)
        SELECT CASE(solutionMethod)
        CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
          !Finish the equations creation
          NULLIFY(equations)
          CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
          CALL Equations_CreateFinish(equations,err,error,*999)
          NULLIFY(vectorEquations)
          CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
          !Create the equations mapping.
          NULLIFY(vectorMapping)
          CALL EquationsMapping_VectorCreateStart(vectorEquations,FIELD_U_VARIABLE_TYPE,vectorMapping,err,error,*999)
          CALL EquationsMappingVector_NumberOfResidualsSet(vectorMapping,1,err,error,*999)
          SELECT CASE(equationsSetSubtype)
          CASE(EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE, &
            & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE, &
            & EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE)
            !Residual vector also depends on the fluid pressure variable
            CALL EquationsMappingVector_ResidualNumberOfVariablesSet(vectorMapping,1,2,err,error,*999)
            CALL EquationsMappingVector_ResidualVariableTypesSet(vectorMapping,1,[FIELD_U_VARIABLE_TYPE,FIELD_V_VARIABLE_TYPE], &
              & err,error,*999)
          CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
            & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE)
            !Single residual variable
            CALL EquationsMappingVector_ResidualNumberOfVariablesSet(vectorMapping,1,1,err,error,*999)
            CALL EquationsMappingVector_ResidualVariableTypesSet(vectorMapping,1,[FIELD_U_VARIABLE_TYPE],err,error,*999)
            !Set dynamic for mass matrix
            CALL EquationsMappingVector_DynamicVariableTypeSet(vectorMapping,FIELD_U_VARIABLE_TYPE,err,error,*999)
            CALL EquationsMappingVector_DynamicMatricesSet(vectorMapping,.TRUE.,.FALSE.,.FALSE.,err,error,*999)
          CASE DEFAULT
            !Single residual variable
            CALL EquationsMappingVector_ResidualNumberOfVariablesSet(vectorMapping,1,1,err,error,*999)
            CALL EquationsMappingVector_ResidualVariableTypesSet(vectorMapping,1,[FIELD_U_VARIABLE_TYPE],err,error,*999)
          END SELECT
          CALL EquationsMappingVector_NumberOfLinearMatricesSet(vectorMapping,0,err,error,*999)
          CALL EquationsMappingVector_RHSVariableTypeSet(vectorMapping,FIELD_DELUDELN_VARIABLE_TYPE,err,error,*999)
          CALL EquationsMapping_VectorCreateFinish(vectorMapping,err,error,*999)
          !Create the equations matrices
          NULLIFY(vectorMatrices)
          CALL EquationsMatrices_VectorCreateStart(vectorEquations,vectorMatrices,err,error,*999)
          ! set structure and storage types
          CALL Equations_SparsityTypeGet(equations,sparsityType,err,error,*999)
          SELECT CASE(sparsityType)
          CASE(EQUATIONS_MATRICES_FULL_MATRICES)
            CALL EquationsMatricesVector_NonlinearStorageTypeSet(vectorMatrices,1,MATRIX_BLOCK_STORAGE_TYPE,err,error,*999)
            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
              & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE)
              IF(EQUATIONS%lumpingType==EQUATIONS_LUMPED_MATRICES) THEN
                !Set up lumping
                CALL EquationsMatricesVector_DynamicLumpingTypeSet(vectorMatrices,[EQUATIONS_MATRIX_LUMPED],err,error,*999)
                CALL EquationsMatricesVector_DynamicStorageTypeSet(vectorMatrices,[DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE], &
                  & err,error,*999)
                CALL EquationsMatricesVector_DynamicStructureTypeSet(vectorMatrices,[EQUATIONS_MATRIX_DIAGONAL_STRUCTURE], &
                  & err,error,*999)
              ELSE
                CALL EquationsMatricesVector_DynamicStorageTypeSet(vectorMatrices,[MATRIX_BLOCK_STORAGE_TYPE],err,error,*999)
              ENDIF
            CASE DEFAULT
              !Do nothing
            END SELECT
          CASE(EQUATIONS_MATRICES_SPARSE_MATRICES)
            CALL EquationsMatricesVector_NonlinearStorageTypeSet(vectorMatrices,1,MATRIX_COMPRESSED_ROW_STORAGE_TYPE,err,error,*999)
            CALL EquationsMatricesVector_NonlinearStructureTypeSet(vectorMatrices,1,EQUATIONS_MATRIX_FEM_STRUCTURE,err,error,*999)
            SELECT CASE(equationsSetSubtype)
            CASE(EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
              & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE)
              CALL Equations_LumpingTypeGet(equations,lumpingType,err,error,*999)
              IF(lumpingType==EQUATIONS_LUMPED_MATRICES) THEN
                !Set up lumping
                CALL EquationsMatricesVector_DynamicLumpingTypeSet(vectorMatrices,[EQUATIONS_MATRIX_LUMPED],err,error,*999)
                CALL EquationsMatricesVector_DynamicStorageTypeSet(vectorMatrices,[DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE], &
                  & err,error,*999)
                CALL EquationsMatricesVector_DynamicStructureTypeSet(vectorMatrices,[EQUATIONS_MATRIX_DIAGONAL_STRUCTURE], &
                  & err,error,*999)
              ELSE
                CALL EquationsMatricesVector_DynamicStorageTypeSet(vectorMatrices,[MATRIX_COMPRESSED_ROW_STORAGE_TYPE], &
                  & err,error,*999)
                CALL EquationsMatricesVector_DynamicStructureTypeSet(vectorMatrices,[EQUATIONS_MATRIX_FEM_STRUCTURE], &
                  & err,error,*999)
              ENDIF
            CASE DEFAULT
              !Do nothing
            END SELECT
          CASE DEFAULT
            localError="The equations matrices sparsity type of "//TRIM(NumberToVString(sparsityType,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          CALL EquationsMatrices_VectorCreateFinish(vectorMatrices,err,error,*999)
          !Set Jacobian matrices calculation type to default finite difference. 
          CALL EquationsMatricesVector_JacobianCalculationTypeSet(vectorMatrices,FIELD_U_VARIABLE_TYPE,1, &
            & EQUATIONS_JACOBIAN_FINITE_DIFFERENCE_CALCULATED,err,error,*999)
        CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE DEFAULT
        localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
          & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
          & " is invalid for a finite elasticity equation."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(EQUATIONS_SET_SETUP_DERIVED_TYPE)
      !-----------------------------------------------------------------
      ! D e r i v e d   f i e l d
      !-----------------------------------------------------------------
      ! We want to be able to set which derived variables are calculated before finishing the derived
      ! field, so don't create field variables or check the provided field until the finish action.
      NULLIFY(esDerived)
      CALL EquationsSet_DerivedGet(equationsSet,esDerived,err,error,*999)
      NULLIFY(geometricField)
      CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
      SELECT CASE(equationsSetSetup%actionType)
      CASE(EQUATIONS_SET_SETUP_START_ACTION)
        IF(esDerived%derivedFieldAutoCreated) THEN
          CALL Field_CreateStart(equationsSetSetup%fieldUserNumber,region,esDerived%derivedField,err,error,*999)
          CALL Field_TypeSetAndLock(esDerived%derivedField,FIELD_GENERAL_TYPE,err,error,*999)
          CALL Field_LabelSet(esDerived%derivedField,"Derived Field",err,error,*999)
          CALL Field_DependentTypeSetAndLock(esDerived%derivedField,FIELD_DEPENDENT_TYPE,err,error,*999)
          NULLIFY(geometricDecomposition)
          CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
          CALL Field_DecompositionSetAndLock(esDerived%derivedField,geometricDecomposition,err,error,*999)
          CALL Field_GeometricFieldSetAndLock(esDerived%derivedField,geometricField,err,error,*999)
        ENDIF
      CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
        ALLOCATE(variableTypes(esDerived%numberOfVariables),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate derived field variable types.",err,error,*999)
        variableIdx=0
        DO derivedIdx=1,EQUATIONS_SET_NUMBER_OF_TENSOR_TYPES
          IF(esDerived%variableTypes(derivedIdx)/=0) THEN
            variableIdx=variableIdx+1
            variableTypes(variableIdx)=esDerived%variableTypes(derivedIdx)
          END IF
        ENDDO !derivedIdx
        numberOfTensorComponents=NUMBER_OF_VOIGT(numberOfDimensions)
        IF(esDerived%derivedFieldAutoCreated) THEN
          CALL Field_NumberOfVariablesSetAndLock(esDerived%derivedField,esDerived%numberOfVariables,err,error,*999)
          CALL Field_VariableTypesSetAndLock(esDerived%derivedField,variableTypes,err,error,*999)
          DO derivedIdx=1,EQUATIONS_SET_NUMBER_OF_TENSOR_TYPES
            variableType=esDerived%variableTypes(derivedIdx)
            IF(variableType/=0) THEN
              CALL Field_DataTypeSetAndLock(esDerived%derivedField,variableType,FIELD_DP_TYPE,err,error,*999)
              SELECT CASE(derivedidx)
              CASE(EQUATIONS_SET_DEFORMATION_GRADIENT_TENSOR)
                CALL Field_DimensionSetAndLock(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_VariableLabelSet(esDerived%derivedField,variableType,"Strain",err,error,*999)
                CALL Field_NumberOfComponentsSetAndLock(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE(EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR)
                CALL Field_DimensionSetAndLock(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_VariableLabelSet(esDerived%derivedField,variableType,"Strain",err,error,*999)
                CALL Field_NumberOfComponentsSetAndLock(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE(EQUATIONS_SET_L_CAUCHY_GREEN_DEFORMATION_TENSOR)
                CALL Field_DimensionSetAndLock(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_VariableLabelSet(esDerived%derivedField,variableType,"Strain",err,error,*999)
                CALL Field_NumberOfComponentsSetAndLock(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE(EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR)
                CALL Field_DimensionSetAndLock(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_VariableLabelSet(esDerived%derivedField,variableType,"Strain",err,error,*999)
                CALL Field_NumberOfComponentsSetAndLock(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE(EQUATIONS_SET_CAUCHY_STRESS_TENSOR)
                CALL Field_DimensionSetAndLock(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_VariableLabelSet(esDerived%derivedField,variableType,"Stress",err,error,*999)
                CALL Field_NumberOfComponentsSetAndLock(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE(EQUATIONS_SET_FIRST_PK_STRESS_TENSOR)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_SECOND_PK_STRESS_TENSOR)
                CALL Field_DimensionSetAndLock(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_VariableLabelSet(esDerived%derivedField,variableType,"Stress",err,error,*999)
                CALL Field_NumberOfComponentsSetAndLock(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE DEFAULT
                CALL FlagError("The specified derived field type of "//TRIM(NumberToVString(derivedIdx,"*",err,error))// &
                  & " is not supported for a finite elasticity equations set type.",err,error,*999)
              END SELECT
            ENDIF
          ENDDO !derivedIdx
          !Finish creating the derived field
          CALL Field_CreateFinish(esDerived%derivedField,err,error,*999)
        ELSE
          !Check the user specified derived field
          CALL Field_TypeCheck(equationsSetSetup%field,FIELD_GENERAL_TYPE,err,error,*999)
          CALL Field_DependentTypeCheck(equationsSetSetup%field,FIELD_DEPENDENT_TYPE,err,error,*999)            
          DO derivedIdx=1,EQUATIONS_SET_NUMBER_OF_TENSOR_TYPES
            variableType=esDerived%variableTypes(derivedIdx)
            IF(variableType/=0) THEN
              CALL Field_DataTypeCheck(equationsSetSetup%field,variableType,FIELD_DP_TYPE,err,error,*999)
              SELECT CASE(derivedidx)
              CASE(EQUATIONS_SET_DEFORMATION_GRADIENT_TENSOR)
                CALL Field_DimensionCheck(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_NumberOfComponentsCheck(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE(EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR)
                CALL Field_DimensionCheck(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_NumberOfComponentsCheck(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE(EQUATIONS_SET_L_CAUCHY_GREEN_DEFORMATION_TENSOR)
                CALL Field_DimensionCheck(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_NumberOfComponentsCheck(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE(EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR)
                CALL Field_DimensionCheck(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_NumberOfComponentsCheck(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE(EQUATIONS_SET_CAUCHY_STRESS_TENSOR)
                CALL Field_DimensionCheck(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_NumberOfComponentsCheck(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE(EQUATIONS_SET_FIRST_PK_STRESS_TENSOR)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(EQUATIONS_SET_SECOND_PK_STRESS_TENSOR)
                CALL Field_DimensionCheck(esDerived%derivedField,variableType,FIELD_VECTOR_DIMENSION_TYPE,err,error,*999)
                CALL Field_NumberOfComponentsCheck(esDerived%derivedField,variableType,numberOfTensorComponents,err,error,*999)
              CASE DEFAULT
                CALL FlagError("The specified derived field type of "//TRIM(NumberToVString(derivedIdx,"*",err,error))// &
                  & " is not supported for a finite elasticity equations set type.",err,error,*999)
              END SELECT
            ENDIF
          ENDDO !derivedIdx
        ENDIF
      CASE DEFAULT
        localError="The action type of "//TRIM(NumberToVString(equationsSetSetup%actionType,"*",err,error))// &
          & " for a setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
          & " is invalid for a finite elasticity equation."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE DEFAULT
      localError="The setup type of "//TRIM(NumberToVString(equationsSetSetup%setupType,"*",err,error))// &
        & " is invalid for a finite elasticity equation."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FiniteElasticity_EquationsSetSetup")
    RETURN
999 ERRORSEXITS("FiniteElasticity_EquationsSetSetup",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_EquationsSetSetup

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for a finite elasticity equation type of an elasticity equations set class.
  SUBROUTINE FiniteElasticity_EquationsSetSolutionMethodSet(equationsSet,solutionMethod,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set to set the solution method for
    INTEGER(INTG), INTENT(IN) :: solutionMethod !<The solution method to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: esSpecification(3)
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_EquationsSetSolutionMethodSet",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)
    SELECT CASE(esSpecification(3))
    CASE(EQUATIONS_SET_MEMBRANE_SUBTYPE,EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE, &
      & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE, &
      & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE, &
      & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE,EQUATIONS_SET_NO_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE,EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE, &
      & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
      & EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE, &
      & EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
      & EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE, & 
      & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE, &
      & EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE, &
      & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE, &
      & EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
      & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE, &
      & EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE, &
      & EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE, &
      & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
      & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
      SELECT CASE(solutionMethod)
      CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
        equationsSet%solutionMethod=EQUATIONS_SET_FEM_SOLUTION_METHOD
      CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="The specified solution method of "//TRIM(NumberToVString(solutionMethod,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE DEFAULT
      localError="Equations set subtype of "//TRIM(NumberToVString(esSpecification(3),"*",err,error))// &
        & " is not valid for a finite elasticity equation type of an elasticity equations set class."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FiniteElasticity_EquationsSetSolutionMethodSet")
    RETURN
999 ERRORS("FiniteElasticity_EquationsSetSolutionMethodSet",err,error)
    EXITS("FiniteElasticity_EquationsSetSolutionMethodSet")
    RETURN 1

  END SUBROUTINE FiniteElasticity_EquationsSetSolutionMethodSet

  !
  !================================================================================================================================
  !

  !>Sets the equation specification for a finite elasticity equation type of an elasticity equations set class.
  SUBROUTINE FiniteElasticity_EquationsSetSpecificationSet(equationsSet,specification,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set to set the equation subtype for
    INTEGER(INTG), INTENT(IN) :: specification(:) !<The equations set specification to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: subtype
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_EquationsSetSpecificationSet",err,error,*999)

    IF(.NOT.ASSOCIATED(equationsSet)) CALL FlagError("Equations set is not associated.",err,error,*999)
    IF(ALLOCATED(equationsSet%specification)) CALL FlagError("Equations set specification is already allocated.",err,error,*999)    
    IF(SIZE(specification,1)<3) THEN
      localError="The size of the specified specification array of "// &
        & TRIM(NumberToVString(SIZE(specification,1),"*",err,error))//" is invalid. The size should be >= 3."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    subtype=specification(3)
    
    SELECT CASE(subtype)
    CASE(EQUATIONS_SET_MEMBRANE_SUBTYPE,EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE, &
      & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE, &
      & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE, &
      & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE, EQUATIONS_SET_NO_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE,EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
      & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE,EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE,EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
      & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE, &
      & EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
      & EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_MR_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE, &
      & EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE, &
      & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE, &
      & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE,EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE, &
      & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE,EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE, &
      & EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE,EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
      & EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE, &
      & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE, &
      & EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
      & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE,EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
      & EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE,EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE)
      !OK
    CASE DEFAULT
      localError="Equations set subtype "//TRIM(NumberToVstring(subtype,"*",err,error))// &
        & " is not valid for a finite elasticity equation type of an elasticity equations set class."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    
    !Set full specification
    ALLOCATE(equationsSet%specification(3),stat=err)
    IF(err/=0) CALL FlagError("Could not allocate equations set specification.",err,error,*999)
    equationsSet%specification(1:3)=[EQUATIONS_SET_ELASTICITY_CLASS,EQUATIONS_SET_FINITE_ELASTICITY_TYPE,subtype]

    EXITS("FiniteElasticity_EquationsSetSpecificationSet")
    RETURN
999 ERRORS("FiniteElasticity_EquationsSetSpecificationSet",err,error)
    EXITS("FiniteElasticity_EquationsSetSpecificationSet")
    RETURN 1

  END SUBROUTINE FiniteElasticity_EquationsSetSpecificationSet

  !
  !================================================================================================================================
  !

  !>Sets up the finite elasticity problem.
  SUBROUTINE FiniteElasticity_ProblemSetup(problem,problemSetup,err,error,*)

    !Argument variables
    TYPE(ProblemType), POINTER :: problem !<A pointer to the problem set to setup a Laplace equation on.
    TYPE(ProblemSetupType), INTENT(INOUT) :: problemSetup !<The problem setup information
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: problemSubType,pSpecification(3)
    TYPE(ControlLoopType), POINTER :: controlLoop,controlLoopRoot
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverType), POINTER :: cellMLSolver
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(SolversType), POINTER :: solvers
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_ProblemSetup",err,error,*999)

    CALL Problem_SpecificationGet(problem,3,pSpecification,err,error,*999)

    problemSubType=pSpecification(3)
    SELECT CASE(problemSubType)
    CASE(PROBLEM_NO_SUBTYPE,PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE, &
      & PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE,PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE, &
      & PROBLEM_MULTISCALE_FINITE_ELASTICITY_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE, &
      & PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE)
      SELECT CASE(problemSetup%setupType)
      CASE(PROBLEM_SETUP_INITIAL_TYPE)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Do nothing????
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Do nothing????
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(PROBLEM_SETUP_CONTROL_TYPE)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Set up a simple control loop: default is load increment type now
          NULLIFY(controlLoop)
          CALL ControlLoop_CreateStart(problem,controlLoop,err,error,*999)
          SELECT CASE(problemSubType)
          CASE(PROBLEM_NO_SUBTYPE,PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE)
            CALL ControlLoop_TypeSet(controlLoop,CONTROL_LOAD_INCREMENT_LOOP_TYPE,err,error,*999)
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE, &
            & PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE, &
            & PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE)
!!TODO: Should we have a load step loop inside the time loop?
            CALL ControlLoop_TypeSet(controlLoop,CONTROL_TIME_LOOP_TYPE,err,error,*999)
            CALL ControlLoop_LabelSet(controlLoop,"Time Loop",err,error,*999)
          CASE DEFAULT
            localError="Problem subtype "//TRIM(NumberToVString(problemSubType,"*",err,error))// &
              & " is not valid for a finite elasticity type of an elasticity problem class."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Finish the control loops
          NULLIFY(controlLoopRoot)
          CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
          NULLIFY(controlLoop)
          CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
          CALL ControlLoop_CreateFinish(controlLoop,err,error,*999)
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(PROBLEM_SETUP_SOLVERS_TYPE)
        !Get the control loop
        NULLIFY(controlLoopRoot)
        CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
        NULLIFY(controlLoop)
        CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Start the solvers creation
          NULLIFY(solvers)
          CALL Solvers_CreateStart(controlLoop,solvers,err,error,*999)
          SELECT CASE(problemSubType)
          CASE(PROBLEM_NO_SUBTYPE,PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE)
            CALL Solvers_NumberOfSolversSet(solvers,1,err,error,*999)
            !Set the solver to be a nonlinear solver
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_NONLINEAR_TYPE,err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_PETSC_LIBRARY,err,error,*999)              
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE)
            CALL Solvers_NumberOfSolversSet(solvers,2,err,error,*999)
            !Set the first solver to be an CellML Evaluator for time varying boundary conditions
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_CELLML_EVALUATOR_TYPE,err,error,*999)
            CALL Solver_LabelSet(solver,"Boundary Condition Evaluation Solver",err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_CMISS_LIBRARY,err,error,*999)
            !Set the second solver to be a nonlinear solver to solve the mechanics
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,2,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_NONLINEAR_TYPE,err,error,*999)
            CALL Solver_LabelSet(solver,"Nonlinear Solver",err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_PETSC_LIBRARY,err,error,*999)
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE)
            CALL Solvers_NumberOfSolversSet(solvers,3,err,error,*999)
            !Set the first solver to be an CellML Evaluator for time varying boundary conditions
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_CELLML_EVALUATOR_TYPE,err,error,*999)
            CALL Solver_LabelSet(solver,"Boundary Condition Evaluation Solver",err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_CMISS_LIBRARY,err,error,*999)
            !Set the second solver to be an ODE integrator for growth
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,2,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_DAE_TYPE,err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_CMISS_LIBRARY,err,error,*999)
            !Set the third solver to be a nonlinear solver for elasticity
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,3,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_NONLINEAR_TYPE,err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_PETSC_LIBRARY,err,error,*999)
          CASE(PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE)
            CALL Solvers_NumberOfSolversSet(solvers,2,err,error,*999)
            !Set the first solver to be an CellML Evaluator for time varying boundary conditions
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_CELLML_EVALUATOR_TYPE,err,error,*999)
            CALL Solver_LabelSet(solver,"Boundary Condition Evaluation Solver",err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_CMISS_LIBRARY,err,error,*999)
            !Set the solver to be a second order dynamic nonlinear solver to solve the mechanics
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,2,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_DYNAMIC_TYPE,err,error,*999)
            CALL Solver_LabelSet(solver,"Dynamic nolinear solver",err,error,*999)
            CALL Solver_DynamicOrderSet(solver,SOLVER_DYNAMIC_SECOND_ORDER,err,error,*999)
            CALL Solver_DynamicDegreeSet(solver,SOLVER_DYNAMIC_SECOND_DEGREE,err,error,*999)
            CALL Solver_DynamicLinearityTypeSet(solver,SOLVER_DYNAMIC_NONLINEAR,err,error,*999)
            !Set solver defaults
            CALL Solver_DynamicSchemeSet(solver,SOLVER_DYNAMIC_NEWMARK1_SCHEME,err,error,*999)
            CALL Solver_LibraryTypeSet(solver,SOLVER_CMISS_LIBRARY,err,error,*999)
          CASE(PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE) 
            CALL Solvers_NumberOfSolversSet(solvers,2,err,error,*999)
            !Set the first solver to be an ODE integrator for growth
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_DAE_TYPE,err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_CMISS_LIBRARY,err,error,*999)
            !Set the second solver to be a nonlinear solver for elasticity
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,2,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_NONLINEAR_TYPE,err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_PETSC_LIBRARY,err,error,*999)
            !Create the CellML evaluator solver for a constituative law via CellML
            NULLIFY(cellMLSolver)
            CALL Solver_NewtonCellMLEvaluatorCreate(solver,cellMLSolver,err,error,*999)
            !Link the CellML evaluator solver to the solver
            CALL Solver_LinkedSolverAdd(solver,cellMLSolver,SOLVER_CELLML_EVALUATOR_TYPE,err,error,*999)
          CASE(PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE)
            CALL Solvers_NumberOfSolversSet(solvers,1,err,error,*999)
            !Set the solver to be a nonlinear solver
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_NONLINEAR_TYPE,err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_PETSC_LIBRARY,err,error,*999)
            !Create the CellML evaluator solver
            NULLIFY(cellMLSolver)
            CALL Solver_NewtonCellMLEvaluatorCreate(solver,cellMLSolver,err,error,*999)
            !Link the CellML evaluator solver to the solver
            CALL Solver_LinkedSolverAdd(solver,cellMLSolver,SOLVER_CELLML_EVALUATOR_TYPE,err,error,*999)
          CASE(PROBLEM_MULTISCALE_FINITE_ELASTICITY_SUBTYPE)
            CALL Solvers_NumberOfSolversSet(solvers,2,err,error,*999)
            !Set the first solver to be a DAE solver
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_DAE_TYPE,err,error,*999)
            CALL Solver_LabelSet(solver,"ODE_Solver",err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_CMISS_LIBRARY,err,error,*999)
            NULLIFY(solver)
            !Set the second solver to be a nonlinear solver 
            CALL Solvers_SolverGet(solvers,2,solver,err,error,*999)
            CALL Solver_TypeSet(solver,SOLVER_NONLINEAR_TYPE,err,error,*999)
            CALL Solver_LabelSet(solver,"Nonlinear_Solver",err,error,*999)
            !Set solver defaults
            CALL Solver_LibraryTypeSet(solver,SOLVER_PETSC_LIBRARY,err,error,*999)
          CASE DEFAULT
            localError="The third problem specification of "//TRIM(NumberToVString(problemSubType,"*",err,error))// &
              & " is not valid for a finite elasticity type of an elasticity problem class."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Get the solvers
          NULLIFY(solvers)
          CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)
          !Finish the solvers creation
          CALL Solvers_CreateFinish(solvers,err,error,*999)
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(PROBLEM_SETUP_SOLVER_EQUATIONS_TYPE)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Get the control loop
          NULLIFY(controlLoopRoot)
          CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
          NULLIFY(controlLoop)
          CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
          !Get the solver
          NULLIFY(solvers)
          CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)
          NULLIFY(solver)
          SELECT CASE(problemSubType)
          CASE(PROBLEM_NO_SUBTYPE,PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE, &
            & PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE, &
            & PROBLEM_MULTISCALE_FINITE_ELASTICITY_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE)
            CALL Solvers_SolverGet(solvers,2,solver,err,error,*999)
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE)
            CALL Solvers_SolverGet(solvers,3,solver,err,error,*999)
          CASE DEFAULT
            localError="The third problem specification of "//TRIM(NumberToVString(problemSubType,"*",err,error))// &
              & " is not valid for a finite elasticity type of an elasticity problem class."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          !Create the solver equations
          NULLIFY(solverEquations)
          CALL SolverEquations_CreateStart(solver,solverEquations,err,error,*999)
          CALL SolverEquations_SparsityTypeSet(solverEquations,SOLVER_SPARSE_MATRICES,err,error,*999)
          CALL SolverEquations_LinearityTypeSet(solverEquations,SOLVER_EQUATIONS_NONLINEAR,err,error,*999)
          !Set time dependence
          SELECT CASE(problemSubType)
          CASE(PROBLEM_NO_SUBTYPE,PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_MULTISCALE_FINITE_ELASTICITY_SUBTYPE, &
            & PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE)
            CALL SolverEquations_TimeDependenceTypeSet(solverEquations,SOLVER_EQUATIONS_STATIC,err,error,*999)
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE, & 
            & PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE)
            CALL SolverEquations_TimeDependenceTypeSet(solverEquations,SOLVER_EQUATIONS_QUASISTATIC,err,error,*999)
          CASE(PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE)
            CALL SolverEquations_TimeDependenceTypeSet(solverEquations,SOLVER_EQUATIONS_SECOND_ORDER_DYNAMIC, &
              & err,error,*999)
          CASE DEFAULT
            localError="The third problem specification of "//TRIM(NumberToVString(problemSubType,"*",err,error))// &
              & " is not valid for a finite elasticity type of an elasticity problem class."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Get the control loop
          NULLIFY(controlLoopRoot)
          CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
          NULLIFY(controlLoop)
          CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
          !Get the solver equations
          NULLIFY(solvers)
          CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)
          NULLIFY(solver)
          SELECT CASE(problemSubType)
          CASE(PROBLEM_NO_SUBTYPE,PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE, &
            & PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE, &
            & PROBLEM_MULTISCALE_FINITE_ELASTICITY_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE)
            CALL Solvers_SolverGet(solvers,2,solver,err,error,*999)
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE)
            CALL Solvers_SolverGet(solvers,3,solver,err,error,*999)
          CASE DEFAULT
            localError="The third problem specification of "//TRIM(NumberToVString(problemSubType,"*",err,error))// &
              & " is not valid for a finite elasticity type of an elasticity problem class."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          NULLIFY(solverEquations)
          CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
          !Finish the solver equations creation
          CALL SolverEquations_CreateFinish(solverEquations,err,error,*999)
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(PROBLEM_SETUP_CELLML_EQUATIONS_TYPE)
        !Get the control loop
        NULLIFY(controlLoopRoot)
        CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
        NULLIFY(controlLoop)
        CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
        NULLIFY(solvers)
        CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          SELECT CASE(problemSubType)
          CASE(PROBLEM_NO_SUBTYPE,PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE)
            !Do nothing
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE)
            !Get the CellML solver
            NULLIFY(cellMLSolver)
            CALL Solvers_SolverGet(solvers,1,cellMLSolver,err,error,*999)
            !Create the CellML equations
            NULLIFY(cellMLEquations)
            CALL CellMLEquations_CreateStart(cellMLSolver,cellMLEquations,err,error,*999)
            !Set the time dependence
            CALL CellMLEquations_TimeDependenceTypeSet(cellMLEquations,CELLML_EQUATIONS_QUASISTATIC,err,error,*999)
          CASE(PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE)
            !Get the CellML solver
            NULLIFY(cellMLSolver)
            CALL Solvers_SolverGet(solvers,1,cellMLSolver,err,error,*999)
            !Create the CellML equations
            NULLIFY(cellMLEquations)
            CALL CellMLEquations_CreateStart(cellMLSolver,cellMLEquations,err,error,*999)
            !Set the time dependence
            CALL CellMLEquations_TimeDependenceTypeSet(cellMLEquations,CELLML_EQUATIONS_DYNAMIC,err,error,*999)
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE)
            !Get the CellML BC solver
            NULLIFY(cellMLSolver)
            CALL Solvers_SolverGet(solvers,1,cellMLSolver,err,error,*999)
            !Create the CellML equations
            NULLIFY(cellMLEquations)
            CALL CellMLEquations_CreateStart(cellMLSolver,cellMLEquations,err,error,*999)
            !Set the time dependence
            CALL CellMLEquations_TimeDependenceTypeSet(cellMLEquations,CELLML_EQUATIONS_QUASISTATIC,err,error,*999)
            !Get the CellML Growth solver
            NULLIFY(cellMLSolver)
            CALL Solvers_SolverGet(solvers,2,cellMLSolver,err,error,*999)
            !Create the CellML equations
            NULLIFY(cellMLEquations)
            CALL CellMLEquations_CreateStart(cellMLSolver,cellMLEquations,err,error,*999)
            !Set the time dependence
            CALL CellMLEquations_TimeDependenceTypeSet(cellMLEquations,CELLML_EQUATIONS_QUASISTATIC,err,error,*999)
          CASE(PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE)
            !Get the nonlinear solver
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
            !Get the CellML evaluator solver
            NULLIFY(cellMLSolver)
            CALL Solver_NewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
            !Create the CellML equations
            NULLIFY(cellMLEquations)
            CALL CellMLEquations_CreateStart(cellMLSolver,cellMLEquations,err,error,*999)
            !Set the time dependence
            CALL CellMLEquations_TimeDependenceTypeSet(cellMLEquations,CELLML_EQUATIONS_STATIC,err,error,*999)
          CASE(PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE) 
            !Get the CellML integrator solver
            NULLIFY(cellMLSolver)
            CALL Solvers_SolverGet(solvers,1,cellMLSolver,err,error,*999)
            NULLIFY(cellMLEquations)
            CALL CellMLEquations_CreateStart(cellMLSolver,cellMLEquations,err,error,*999)
            !Get the nonlinear solver
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,2,solver,err,error,*999)
            !Get the CellML evaluator solver
            NULLIFY(cellMLSolver)
            CALL Solver_NewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
            !Create the CellML equations
            NULLIFY(cellMLEquations)
            CALL CellMLEquations_CreateStart(cellMLSolver,cellMLEquations,err,error,*999)
          CASE(PROBLEM_MULTISCALE_FINITE_ELASTICITY_SUBTYPE)
            !Create the CellML equations for the first DAE solver
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
            NULLIFY(cellMLEquations)
            CALL CellMLEquations_CreateStart(solver,cellMLEquations,err,error,*999)
          CASE DEFAULT
            localError="The third problem specification of "//TRIM(NumberToVString(problemSubType,"*",err,error))// &
              & " is not valid for a finite elasticity type of an elasticity problem."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          SELECT CASE(problemSubType)
          CASE(PROBLEM_NO_SUBTYPE,PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE)
            !Do nothing
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE)
            !Get the CellML evaluator solver
            NULLIFY(cellMLSolver)
            CALL Solvers_SolverGet(solvers,1,cellMLSolver,err,error,*999)
            !Get the CellML equations for the CellML evaluator solver
            NULLIFY(cellMLEquations)
            CALL Solver_CellMLEquationsGet(cellMLSolver,cellMLEquations,err,error,*999)
            !Finish the CellML equations creation
            CALL CellMLEquations_CreateFinish(cellMLEquations,err,error,*999)
          CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE)
            !Get the CellML BC evaluator solver
            NULLIFY(cellMLSolver)
            CALL Solvers_SolverGet(solvers,1,cellMLSolver,err,error,*999)
            !Get the CellML equations for the CellML evaluator solver
            NULLIFY(cellMLEquations)
            CALL Solver_CellMLEquationsGet(cellMLSolver,cellMLEquations,err,error,*999)
            !Finish the CellML equations creation
            CALL CellMLEquations_CreateFinish(cellMLEquations,err,error,*999)
            !Get the CellML growth integration solver
            NULLIFY(cellMLSolver)
            CALL Solvers_SolverGet(solvers,2,cellMLSolver,err,error,*999)
            !Get the CellML equations for the CellML integration solver
            NULLIFY(cellMLEquations)
            CALL Solver_CellMLEquationsGet(cellMLSolver,cellMLEquations,err,error,*999)
            !Finish the CellML equations creation
            CALL CellMLEquations_CreateFinish(cellMLEquations,err,error,*999)
          CASE(PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE)
            !Get the nonlinear solver
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
            !Get the CellML evaluator solver
            NULLIFY(cellMLSolver)
            CALL Solver_NewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
            !Get the CellML equations for the CellML evaluator solver
            NULLIFY(cellMLEquations)
            CALL Solver_CellMLEquationsGet(cellMLSolver,cellMLEquations,err,error,*999)
            !Finish the CellML equations creation
            CALL CellMLEquations_CreateFinish(cellMLEquations,err,error,*999)
          CASE(PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE) 
            !Get the CellML integrator solver
            NULLIFY(cellMLSolver)
            CALL Solvers_SolverGet(solvers,1,cellMLSolver,err,error,*999)
            !Get the CellML equations for the CellML evaluator solver
            NULLIFY(cellMLEquations)
            CALL Solver_CellMLEquationsGet(cellMLSolver,cellMLEquations,err,error,*999)
            !Finish the CellML equations creation
            CALL CellMLEquations_CreateFinish(cellMLEquations,err,error,*999)
            !Get the nonlinear solver
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,2,solver,err,error,*999)
            !Get the CellML evaluator solver
            NULLIFY(cellMLSolver)
            CALL Solver_NewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
            !Get the CellML equations for the CellML evaluator solver
            NULLIFY(cellMLEquations)
            CALL Solver_CellMLEquationsGet(cellMLSolver,cellMLEquations,err,error,*999)
            !Finish the CellML equations creation
            CALL CellMLEquations_CreateFinish(cellMLEquations,err,error,*999)
          CASE(PROBLEM_MULTISCALE_FINITE_ELASTICITY_SUBTYPE)
            !Get the CellML equations for the first DAE solver
            NULLIFY(solver)
            CALL Solvers_SolverGet(solvers,1,solver,err,error,*999)
            NULLIFY(cellMLEquations)
            CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
            !Finish the CellML equations creation
            CALL CellMLEquations_CreateFinish(cellMLEquations,err,error,*999)
          CASE DEFAULT
            localError="The third problem specification of "//TRIM(NumberToVString(problemSubType,"*",err,error))// &
              & " is not valid for a finite elasticity type of an elasticity problem class."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity equation."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE DEFAULT
        localError="The setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
          & " is invalid for a finite elasticity problem."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE DEFAULT
      localError="Problem subtype "//TRIM(NumberToVString(problemSubType,"*",err,error))// &
        & " is not valid for a finite elasticity type of an elasticity problem class."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FiniteElasticity_ProblemSetup")
    RETURN
999 ERRORSEXITS("FiniteElasticity_ProblemSetup",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_ProblemSetup

  !
  !================================================================================================================================
  !

  !>Sets up the finite elasticity problem.
  SUBROUTINE FiniteElasticity_ContactProblemSetup(problem,problemSetup,err,error,*)

    !Argument variables
    TYPE(ProblemType), POINTER :: problem !<A pointer to the problem set to setup a Laplace equation on.
    TYPE(ProblemSetupType), INTENT(INOUT) :: problemSetup !<The problem setup information
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: problemSubType,pSpecification(3)
    TYPE(ControlLoopType), POINTER :: controlLoop,controlLoopRoot
    TYPE(SolverType), POINTER :: nonlinearSolver,transformationSolver
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(SolversType), POINTER :: solvers
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_ContactProblemSetup",err,error,*999)

    CALL Problem_SpecificationGet(problem,3,pSpecification,err,error,*999)
    
    problemSubType=pSpecification(3)
    SELECT CASE(problemSubType)
    CASE(PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE,PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE)
      SELECT CASE(problemSetup%setupType)
      CASE(PROBLEM_SETUP_INITIAL_TYPE)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Do nothing????
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Do nothing????
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(PROBLEM_SETUP_CONTROL_TYPE)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Set up a simple control loop: default is load increment type now
          NULLIFY(controlLoop)
          CALL ControlLoop_CreateStart(problem,controlLoop,err,error,*999)
          CALL ControlLoop_TypeSet(controlLoop,CONTROL_LOAD_INCREMENT_LOOP_TYPE,err,error,*999)
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Finish the control loops
          NULLIFY(controlLoopRoot)
          CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
          NULLIFY(controlLoop)
          CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
          CALL ControlLoop_CreateFinish(controlLoop,err,error,*999)
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(PROBLEM_SETUP_SOLVERS_TYPE)
        !Get the control loop
        NULLIFY(controlLoopRoot)
        CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
        NULLIFY(controlLoop)
        CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Start the solvers creation
          NULLIFY(solvers)
          CALL Solvers_CreateStart(controlLoop,solvers,err,error,*999)
          CALL Solvers_NumberOfSolversSet(solvers,2,err,error,*999)
          !Set the first solver to be a geometric transformation solver
          NULLIFY(transformationSolver)
          CALL Solvers_SolverGet(solvers,1,transformationSolver,err,error,*999)
          CALL Solver_TypeSet(transformationSolver,SOLVER_GEOMETRIC_TRANSFORMATION_TYPE,err,error,*999)
          !Set the second solver to be a nonlinear solver
          NULLIFY(nonlinearSolver)
          CALL Solvers_SolverGet(solvers,2,nonlinearSolver,err,error,*999)
          CALL Solver_TypeSet(nonlinearSolver,SOLVER_NONLINEAR_TYPE,err,error,*999)
          !Set solver defaults
          CALL Solver_LibraryTypeSet(nonlinearSolver,SOLVER_PETSC_LIBRARY,err,error,*999)
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Get the solvers
          NULLIFY(solvers)
          CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)
          !Finish the solvers creation
          CALL Solvers_CreateFinish(solvers,err,error,*999)
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(PROBLEM_SETUP_SOLVER_EQUATIONS_TYPE)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Get the control loop
          NULLIFY(controlLoopRoot)
          CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
          NULLIFY(controlLoop)
          CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
          !Get the solver
          NULLIFY(solvers)
          CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)
          NULLIFY(nonlinearSolver)
          CALL Solvers_SolverGet(solvers,2,nonlinearSolver,err,error,*999)
          !Create the solver equatgions
          NULLIFY(solverEquations)
          CALL SolverEquations_CreateStart(nonlinearSolver,solverEquations,err,error,*999)
          CALL SolverEquations_LinearityTypeSet(solverEquations,SOLVER_EQUATIONS_NONLINEAR,err,error,*999)
          CALL SolverEquations_TimeDependenceTypeSet(solverEquations,SOLVER_EQUATIONS_STATIC,err,error,*999)
          CALL SolverEquations_SparsityTypeSet(solverEquations,SOLVER_SPARSE_MATRICES,err,error,*999)
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Get the control loop
          NULLIFY(controlLoopRoot)
          CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
          NULLIFY(controlLoop)
          CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
          !Get the solver equations
          NULLIFY(solvers)
          CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)
          NULLIFY(nonlinearSolver)
          CALL Solvers_SolverGet(solvers,2,nonlinearSolver,err,error,*999)
          NULLIFY(solverEquations)
          CALL Solver_SolverEquationsGet(nonlinearSolver,solverEquations,err,error,*999)
          !Finish the solver equations creation
          CALL SolverEquations_CreateFinish(solverEquations,err,error,*999)
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE DEFAULT
        localError="The setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
          & " is invalid for a finite elasticity problem."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE)
      SELECT CASE(problemSetup%setupType)
      CASE(PROBLEM_SETUP_INITIAL_TYPE)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Do nothing????
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Do nothing????
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(PROBLEM_SETUP_CONTROL_TYPE)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Set up a simple control loop: default is load increment type now
          NULLIFY(controlLoop)
          CALL ControlLoop_CreateStart(problem,controlLoop,err,error,*999)
          CALL ControlLoop_TypeSet(controlLoop,CONTROL_LOAD_INCREMENT_LOOP_TYPE,err,error,*999)
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Finish the control loops
          NULLIFY(controlLoopRoot)
          CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
          NULLIFY(controlLoop)
          CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
          CALL ControlLoop_CreateFinish(controlLoop,err,error,*999)
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(PROBLEM_SETUP_SOLVERS_TYPE)
        !Get the control loop
        NULLIFY(controlLoopRoot)
        CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
        NULLIFY(controlLoop)
        CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Start the solvers creation
          NULLIFY(solvers)
          CALL Solvers_CreateStart(controlLoop,solvers,err,error,*999)
          CALL Solvers_NumberOfSolversSet(solvers,1,err,error,*999)
          !Set the solver to be a nonlinear solver
          NULLIFY(nonlinearSolver)
          CALL Solvers_SolverGet(solvers,1,nonlinearSolver,err,error,*999)
          CALL Solver_TypeSet(nonlinearSolver,SOLVER_NONLINEAR_TYPE,err,error,*999)
          !Set solver defaults
          CALL Solver_LibraryTypeSet(nonlinearSolver,SOLVER_PETSC_LIBRARY,err,error,*999)
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Get the solvers
          NULLIFY(solvers)
          CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)
          !Finish the solvers creation
          CALL Solvers_CreateFinish(solvers,err,error,*999)
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(PROBLEM_SETUP_SOLVER_EQUATIONS_TYPE)
        SELECT CASE(problemSetup%actionType)
        CASE(PROBLEM_SETUP_START_ACTION)
          !Get the control loop
          NULLIFY(controlLoopRoot)
          CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
          NULLIFY(controlLoop)
          CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
          !Get the solver
          NULLIFY(solvers)
          CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)
          NULLIFY(nonlinearSolver)
          CALL Solvers_SolverGet(solvers,1,nonlinearSolver,err,error,*999)
          !Create the solver equatgions
          NULLIFY(solverEquations)
          CALL SolverEquations_CreateStart(nonlinearSolver,solverEquations,err,error,*999)
          CALL SolverEquations_LinearityTypeSet(solverEquations,SOLVER_EQUATIONS_NONLINEAR,err,error,*999)
          CALL SolverEquations_TimeDependenceTypeSet(solverEquations,SOLVER_EQUATIONS_STATIC,err,error,*999)
          CALL SolverEquations_SparsityTypeSet(solverEquations,SOLVER_SPARSE_MATRICES,err,error,*999)
        CASE(PROBLEM_SETUP_FINISH_ACTION)
          !Get the control loop
          NULLIFY(controlLoopRoot)
          CALL Problem_ControlLoopRootGet(problem,controlLoopRoot,err,error,*999)
          NULLIFY(controlLoop)
          CALL ControlLoop_Get(controlLoopRoot,CONTROL_LOOP_NODE,controlLoop,err,error,*999)
          !Get the solver equations
          NULLIFY(solvers)
          CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)
          NULLIFY(nonlinearSolver)
          CALL Solvers_SolverGet(solvers,1,nonlinearSolver,err,error,*999)
          NULLIFY(solverEquations)
          CALL Solver_SolverEquationsGet(nonlinearSolver,solverEquations,err,error,*999)
          !Finish the solver equations creation
          CALL SolverEquations_CreateFinish(solverEquations,err,error,*999)
        CASE DEFAULT
          localError="The action type of "//TRIM(NumberToVString(problemSetup%actionType,"*",err,error))// &
            & " for a setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
            & " is invalid for a finite elasticity problem."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE DEFAULT
        localError="The setup type of "//TRIM(NumberToVString(problemSetup%setupType,"*",err,error))// &
          & " is invalid for a finite elasticity problem."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE DEFAULT
      localError="Problem subtype "//TRIM(NumberToVString(problemSubType,"*",err,error))// &
        & " is not valid for a finite elasticity contact type of an elasticity problem class."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FiniteElasticity_ContactProblemSetup")
    RETURN
999 ERRORSEXITS("FiniteElasticity_ContactProblemSetup",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_ContactProblemSetup

  !
  !================================================================================================================================
  !

  !>Sets the problem specification for a finite elasticity type problem.
  SUBROUTINE FiniteElasticity_ProblemSpecificationSet(problem,problemSpecification,err,error,*)

    !Argument variables
    TYPE(ProblemType), POINTER :: problem !<A pointer to the problem to set the problem subtype for
    INTEGER(INTG), INTENT(IN) :: problemSpecification(:) !<The problem specification to set
    INTEGER(INTG), INTENT(OUT) :: err !<the error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<the error string
    !Local Variables
    INTEGER(INTG) :: problemSubtype
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_ProblemSpecificationSet",err,error,*999)

    IF(.NOT.ASSOCIATED(problem)) CALL FlagError("Problem is not associated.",err,error,*999)
    IF(ALLOCATED(problem%specification)) CALL FlagError("Problem specification is already allocated.",err,error,*999)
    IF(SIZE(problemSpecification,1)<3) THEN
      localError="The size of the specified problem specification array of "// &
        & TRIM(NumberToVString(SIZE(problemSpecification,1),"*",err,error))// &
        & " is invalid. The size should be >= 3."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    problemSubtype=problemSpecification(3)
    
    SELECT CASE(problemSubtype)
    CASE(PROBLEM_NO_SUBTYPE)
      !ok
    CASE(PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE)
      !ok
    CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE)
      !ok
    CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE)
      !ok
    CASE(PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE)
      !ok
    CASE(PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE)
      !ok
    CASE(PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE)
      !ok
    CASE(PROBLEM_MULTISCALE_FINITE_ELASTICITY_SUBTYPE)
      !ok
    CASE(PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE)
      !ok
    CASE DEFAULT
      localError="The third problem specification of "//TRIM(NumberToVstring(problemSubtype,"*",err,error))// &
        & " is not valid for a finite elasticity type of an elasticity problem."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    
    ALLOCATE(problem%specification(3),stat=err)
    IF(err/=0) CALL FlagError("Could not allocate problem specification.",err,error,*999)
    problem%specification(1:3)=[PROBLEM_ELASTICITY_CLASS,PROBLEM_FINITE_ELASTICITY_TYPE,problemSubtype]

    EXITS("FiniteElasticity_ProblemSpecificationSet")
    RETURN
999 ERRORS("FiniteElasticity_ProblemSpecificationSet",err,error)
    EXITS("FiniteElasticity_ProblemSpecificationSet")
    RETURN 1

  END SUBROUTINE FiniteElasticity_ProblemSpecificationSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the problem subtype for a finite elasticity contact type .
  SUBROUTINE FiniteElasticity_ContactProblemSpecificationSet(problem,problemSpecification,err,error,*)

    !Argument variables
    TYPE(ProblemType), POINTER :: problem !<A pointer to the problem to set the problem subtype for
    INTEGER(INTG), INTENT(IN) :: problemSpecification(:) !<The problem specification to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: problemSubtype
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_ContactProblemSpecificationSet",err,error,*999)

    IF(.NOT.ASSOCIATED(problem)) CALL FlagError("Problem is not associated.",err,error,*999)
    IF(ALLOCATED(problem%specification)) CALL FlagError("Problem specification is already allocated.",err,error,*999)
    IF(SIZE(problemSpecification,1)<3) THEN
      localError="The size of the specified problem specification array of "// &
        & TRIM(NumberToVString(SIZE(problemSpecification,1),"*",err,error))// &
        & " is invalid. The size should be >= 3."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    problemSubtype=problemSpecification(3)
    SELECT CASE(problemSubtype)
    CASE(PROBLEM_NO_SUBTYPE)
      !Normal finite elasticity problem subject to contact constraint, no extra solvers required
    CASE(PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE)
      !ok
    CASE(PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE)
      !ok
    CASE(PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE)
      !ok
    CASE DEFAULT
      localError="The third problem specification of "//TRIM(NumberToVstring(problemSubtype,"*",err,error))// &
        & " is not valid for a finite elasticity contact type of an elasticity problem."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    ALLOCATE(problem%specification(3),stat=err)
    IF(err/=0) CALL FlagError("Could not allocate problem specification.",err,error,*999)
    problem%specification(1:3)=[PROBLEM_ELASTICITY_CLASS,PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE,problemSubtype]

    EXITS("FiniteElasticity_ContactProblemSpecificationSet")
    RETURN
999 ERRORS("FiniteElasticity_ContactProblemSpecificationSet",err,error)
    EXITS("FiniteElasticity_ContactProblemSpecificationSet")
    RETURN 1

  END SUBROUTINE FiniteElasticity_ContactProblemSpecificationSet

  !
  !================================================================================================================================
  !

  !>Sets up the finite elasticity problem post solve.
  SUBROUTINE FiniteElasticity_PostSolve(solver,err,error,*)

    !Argument variables
    TYPE(SolverType), POINTER :: solver!<A pointer to the solver
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,equationsSetIdx,esSpecification(3),loopType,numberOfEquationsSets,pSpecification(3), &
      & problemSubType,solverNumber,subLoopIndex
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: dependentField,independentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(SolverMappingType), POINTER :: solverMapping
    TYPE(SolverType), POINTER :: nonlinearSolver
 
    ENTERS("FiniteElasticity_PostSolve",err,error,*999)
    
    NULLIFY(controlLoop)
    CALL Solver_ControlLoopGet(solver,controlLoop,err,error,*999)
    NULLIFY(problem)
    CALL ControlLoop_ProblemGet(controlLoop,problem,err,error,*999)
    CALL Problem_SpecificationGet(problem,3,pSpecification,err,error,*999)
    problemSubType=pSpecification(3)
    CALL Solver_GlobalNumberGet(solver,solverNumber,err,error,*999)
    
    SELECT CASE(problemSubType)
    CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE)
      IF(solverNumber==2) THEN
        !Nonlinear solver
        CALL Solver_NonlinearDivergenceExit(solver,err,error,*999)
        !Update the hardening variable if we have converged
        NULLIFY(solverEquations)
        CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
        NULLIFY(solverMapping)
        CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
        CALL SolverMapping_NumberOfEquationsSetsGet(solverMapping,numberOfEquationsSets,err,error,*999)
        DO equationsSetIdx=1,numberOfEquationsSets
          NULLIFY(equationsSet)
          CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
          CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)
          IF(esSpecification(1)==EQUATIONS_SET_ELASTICITY_CLASS.AND. &
            & esSpecification(2)==EQUATIONS_SET_FINITE_ELASTICITY_TYPE) THEN
            IF(esSpecification(3)==EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE.OR. &
              & esSpecification(3)==EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE) THEN
              !Rate based smooth model
              NULLIFY(dependentField)
              CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
              !Update U1 variable
              CALL Field_ParameterSetsCopy(dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_NEXT_VALUES_SET_TYPE, &
                & FIELD_VALUES_SET_TYPE,1.0_DP,err,error,*999)
            ELSE IF(esSpecification(3)==EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE.OR. &
              & esSpecification(3)==EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE) THEN
              !Rate based growh model
              NULLIFY(dependentField)
              CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
              !Update U1 variable
              CALL Field_ParameterSetsCopy(dependentField,FIELD_U1_VARIABLE_TYPE,FIELD_NEXT_VALUES_SET_TYPE, &
                & FIELD_VALUES_SET_TYPE,1.0_DP,err,error,*999)
              !Update U2 variable
              CALL Field_ParameterSetsCopy(dependentField,FIELD_U2_VARIABLE_TYPE,FIELD_NEXT_VALUES_SET_TYPE, &
                & FIELD_VALUES_SET_TYPE,1.0_DP,err,error,*999)
            ENDIF
          ENDIF
        ENDDO !equationsSetIdx
        !Output results
        CALL FiniteElasticity_PostSolveOutputData(solver,err,error,*999)          
      ENDIF
    CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE)
      !Add in other quasi-static stuff
      IF(solverNumber==3) THEN
        !Nonlinear solver
        CALL Solver_NonlinearDivergenceExit(solver,err,error,*999)
        CALL FiniteElasticity_PostSolveOutputData(solver,err,error,*999)          
      ENDIF
    CASE(PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE)
      IF(solverNumber==2) THEN
        !Dynamic solver
        NULLIFY(nonlinearSolver)
        CALL Solver_DynamicLinkedNonlinearSolverGet(solver,nonlinearSolver,err,error,*999)
        CALL Solver_NonlinearDivergenceExit(nonlinearSolver,err,error,*999)
        CALL FiniteElasticity_PostSolveOutputData(solver,err,error,*999)
!!TODO: shOULDNT THIS BE IN A POSTLOOP?
        !Output results
        CALL FiniteElasticity_PostSolveOutputData(solver,err,error,*999)          
      ENDIF
    CASE(PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE)
      IF(solverNumber==2) THEN
        !Nonlinear solver
        CALL Solver_NonlinearDivergenceExit(solver,err,error,*999)
        CALL FiniteElasticity_PostSolveOutputData(solver,err,error,*999)          
      ENDIF
    CASE(PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE, &
      & PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE,PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE)
      !Call divergence test only if finite element loop: THIS IS NOT A PROPER FIX
      CALL ControlLoop_SubLoopIndexGet(controlLoop,subLoopIndex,err,error,*999)
      CALL ControlLoop_TypeGet(controlLoop,loopType,err,error,*999)
      IF(subLoopIndex==1) CALL Solver_NonlinearDivergenceExit(solver,err,error,*999)
      IF(loopType==CONTROL_LOAD_INCREMENT_LOOP_TYPE.AND.solverNumber==1) &
        & CALL FiniteElasticity_PostSolveOutputData(solver,err,error,*999)
    CASE(PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE)
      ! how to check eqn subtype? assume active contraction
      NULLIFY(solverEquations)
      CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
      NULLIFY(solverMapping)
      CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
      NULLIFY(equationsSet)
      CALL SolverMapping_EquationsSetGet(solverMapping,1,equationsSet,err,error,*999)
      NULLIFY(independentField)
      CALL EquationsSet_IndependentFieldGet(equationsSet,independentField,err,error,*999)
      !store lambda Q (5-8) in prev lambda Q (1-4)
      DO componentIdx=1,4
        CALL Field_ParametersToFieldParametersCopy(independentField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,componentIdx+4, &
          & independentField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,componentIdx,err,error,*999)
      ENDDO !componentIdx
      ! output data
      CALL FiniteElasticity_PostSolveOutputData(solver,err,error,*999)
    CASE(PROBLEM_MULTISCALE_FINITE_ELASTICITY_SUBTYPE)
      IF(solverNumber==1) THEN
        !do nothing
      ELSE IF(solverNumber==2) THEN
        CALL Solver_NonlinearDivergenceExit(solver,err,error,*999)
      ENDIF
    CASE DEFAULT
      !Check that solver converged
      CALL Solver_NonlinearDivergenceExit(solver,err,error,*999)
    END SELECT

    EXITS("FiniteElasticity_PostSolve")
    RETURN
999 ERRORSEXITS("FiniteElasticity_PostSolve",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_PostSolve

  !
  !================================================================================================================================
  !

  !>Sets up the finite elasticity problem post solve output data.
  SUBROUTINE FiniteElasticity_PostSolveOutputData(solver,err,error,*)

    !Argument variables
    TYPE(SolverType), POINTER :: solver !<A pointer to the solver
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: currentIteration,equationsSetIdx,equationsSetNumber,esSpecification(3),inputIteration,loopIdx, &
      & numberOfEquationsSets,outputIteration,outputType,problemSubType,pSpecification(3)
    REAL(DP) :: currentTime,startTime,stopTime,timeIncrement
    CHARACTER(14) :: file
    CHARACTER(15) :: fileName
    LOGICAL :: exportField
    TYPE(ControlLoopType), POINTER :: controlLoop,timeLoop
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldsType), POINTER :: fields
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(SolverMappingType), POINTER :: solverMapping
    TYPE(ProblemType), POINTER :: problem
    TYPE(RegionType), POINTER :: region
    TYPE(VARYING_STRING) :: localError,method,outputFile

    ENTERS("FiniteElasticity_PostSolveOutputData",err,error,*999)

    NULLIFY(controlLoop)
    CALL Solver_ControlLoopGet(solver,controlLoop,err,error,*999)
    NULLIFY(problem)
    CALL ControlLoop_ProblemGet(controlLoop,problem,err,error,*999)
    CALL Problem_SpecificationGet(problem,3,pSpecification,err,error,*999)

    CALL Solver_OutputTypeGet(solver,outputType,err,error,*999)
    
    problemSubType=pSpecification(3)
    SELECT CASE(problemSubType)
    CASE(PROBLEM_NO_SUBTYPE,PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE, &
      & PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE, &
      & PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE, &
      & PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE, &
      & PROBLEM_MULTISCALE_FINITE_ELASTICITY_SUBTYPE)
      NULLIFY(solverEquations)
      CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
      NULLIFY(solverMapping)
      CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
      !Make sure the equations sets are up to date
      CALL SolverMapping_NumberOfEquationsSetsGet(solverMapping,numberOfEquationsSets,err,error,*999)
      DO equationsSetIdx=1,numberOfEquationsSets
        NULLIFY(equationsSet)
        CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
        NULLIFY(region)
        CALL EquationsSet_RegionGet(equationsSet,region,err,error,*999)
        CALL EquationsSet_GlobalNumberGet(equationsSet,equationsSetNumber,err,error,*999)
        method="FORTRAN"
        !exportField=.TRUE.
        exportField=.FALSE.
        IF(exportField) THEN          
          IF(outputType>=SOLVER_PROGRESS_OUTPUT) THEN
            CALL WriteString(GENERAL_OUTPUT_TYPE,"Finite Elasticity export fields ... ",err,error,*999)
            CALL WriteString(GENERAL_OUTPUT_TYPE,"Static solution",err,error,*999)
          ENDIF
          CALL FLUID_MECHANICS_IO_WRITE_CMGUI(region,equationsSetNumber,"StaticSolidSolution",err,error,*999)
        ENDIF
      ENDDO !equationsSetIdx
    CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE,PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE, &
      & PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE)
      !Get the current time information
      CALL ControlLoop_CurrentTimeInformationGet(controlLoop,currentTime,timeIncrement,startTime,stopTime,currentIteration, &
        & outputIteration,inputIteration,err,error,*999)
      !See if we should output
      IF(currentTime<=stopTime) THEN
        IF(outputIteration/=0) THEN
          IF(MOD(currentIteration,outputIteration)==0) THEN
            !Output 
            WRITE(fileName,'("Elasticity_",I0)') currentIteration
            outputFile=fileName(1:LEN_TRIM(filename))
            method="FORTRAN"
            !Loop over the equations sets and output
            NULLIFY(solverEquations)
            CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
            NULLIFY(solverMapping)
            CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
            CALL SolverMapping_NumberOfEquationsSetsGet(solverMapping,numberOfEquationsSets,err,error,*999)
            DO equationsSetIdx=1,numberOfEquationsSets
              NULLIFY(equationsSet)
              CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
              CALL EquationsSet_SpecificationGet(equationsSet,2,esSpecification,err,error,*999)
              IF(esSpecification(2)==EQUATIONS_SET_FINITE_ELASTICITY_TYPE) THEN
                NULLIFY(region)
                CALL EquationsSet_RegionGet(equationsSet,region,err,error,*999)
                NULLIFY(fields)
                CALL Region_FieldsGet(region,fields,err,error,*999)
                CALL FIELD_IO_NODES_EXPORT(fields,outputFile,method,err,error,*999)
                CALL FIELD_IO_ELEMENTS_EXPORT(fields,outputFile,method,err,error,*999)
              ENDIF
            ENDDO !equationsSetIdx
          ENDIF
        ENDIF
      ENDIF
    CASE(PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE, &
      & PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE,PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE, &
      & PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE)
      !Get the current time information
      CALL ControlLoop_CurrentTimeInformationGet(controlLoop,currentTime,timeIncrement,startTime,stopTime,currentIteration, &
        & outputIteration,inputIteration,err,error,*999)
      NULLIFY(solverEquations)
      CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
      NULLIFY(solverMapping)
      CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
      !Make sure the equations sets are up to date
      CALL SolverMapping_NumberOfEquationsSetsGet(solverMapping,numberOfEquationsSets,err,error,*999)
      DO equationsSetIdx=1,numberOfEquationsSets
        NULLIFY(equationsSet)
        CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
        CALL EquationsSet_SpecificationGet(equationsSet,2,esSpecification,err,error,*999)
        IF(esSpecification(2)==EQUATIONS_SET_FINITE_ELASTICITY_TYPE) THEN             
          !Write out fields at each timestep
          IF(currentTime<=stopTime) THEN
            IF(outputIteration/=0) THEN
              IF(MOD(currentIteration,outputIteration)==0) THEN
                WRITE(filename,'("S_TimeStep_",I4.4)') currentIteration
                file=filename
                method="FORTRAN"
                exportField=.TRUE.
                IF(exportField) THEN
                  IF(outputType>=SOLVER_PROGRESS_OUTPUT) THEN
                    CALL WriteString(GENERAL_OUTPUT_TYPE,"Finite Elasticity export fields ...",err,error,*999)
                    CALL WriteString(GENERAL_OUTPUT_TYPE,outputFile,err,error,*999)
                  ENDIF
                  NULLIFY(region)
                  CALL EquationsSet_RegionGet(equationsSet,region,err,error,*999)
                  CALL EquationsSet_GlobalNumberGet(equationsSet,equationsSetNumber,err,error,*999)
                  CALL FLUID_MECHANICS_IO_WRITE_CMGUI(region,equationsSetNumber,file,err,error,*999)
                  IF(outputType>=SOLVER_PROGRESS_OUTPUT) &
                     & CALL WriteString(GENERAL_OUTPUT_TYPE,"Finite Elasticity all fields exported ...",err,error,*999)
                ENDIF
              ENDIF            
            ENDIF
          ENDIF
        ENDIF
      ENDDO !equationsSetIdx
    CASE DEFAULT
      localError="The third problem specification of "//TRIM(NumberToVString(problemSubType,"*",err,error))// &
        & " is not valid for a finite elasticity problem class."
      CALL FlagError(localError,err,error,*999)
    END SELECT
      
    EXITS("FiniteElasticity_PostSolveOutputData")
    RETURN
999 ERRORSEXITS("FiniteElasticity_PostSolveOutputData",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_PostSolveOutputData

  !
  !================================================================================================================================
  !

  !>Runs before each loop for a finite elasticity problem.
  SUBROUTINE FiniteElasticity_PreLoop(controlLoop,err,error,*)

    !Argument variables
    TYPE(ControlLoopType), POINTER :: controlLoop !<A pointer to the control loop
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: loopType,pSpecification(3)
    TYPE(ControlLoopType), POINTER :: solidControlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(SolverType), POINTER :: solidSolver
    TYPE(SolversType), POINTER :: solvers
    TYPE(VARYING_STRING) :: localError

    ENTERS("FiniteElasticity_PreLoop",err,error,*999)

    CALL ControlLoop_TypeGet(controlLoop,loopType,err,error,*999)
    SELECT CASE(loopType)
    CASE(CONTROL_SIMPLE_TYPE)
      !Do nothing
    CASE(CONTROL_FIXED_LOOP_TYPE)
      !Do nothing
    CASE(CONTROL_TIME_LOOP_TYPE)
      NULLIFY(problem)
      CALL ControlLoop_ProblemGet(controlLoop,problem,err,error,*999)
      CALL Problem_SpecificationGet(problem,3,pSpecification,err,error,*999)
         
      SELECT CASE(pSpecification(3))
      CASE(PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE,PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE)
        NULLIFY(solidControlLoop)
        CALL ControlLoop_Get(controlLoop,[1,CONTROL_LOOP_NODE],solidControlLoop,err,error,*999)
        NULLIFY(solvers)
        CALL ControlLoop_SolversGet(solidControlLoop,solvers,err,error,*999)
        NULLIFY(solidSolver)
        CALL Solvers_SolverGet(solvers,1,solidSolver,err,error,*999)
        !--- 3.0 For Standard Elasticity Darcy: Update the boundary conditions of the solid
        CALL FiniteElasticity_PreSolveUpdateBoundaryConditions(solidSolver,err,error,*999)
      CASE(PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE,PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE)
        NULLIFY(solidControlLoop)        
        CALL ControlLoop_Get(controlLoop,[1,1,CONTROL_LOOP_NODE],solidControlLoop,err,error,*999)
        NULLIFY(solvers)
        CALL ControlLoop_SolversGet(solidControlLoop,solvers,err,error,*999)
        NULLIFY(solidSolver)
        CALL Solvers_SolverGet(solvers,1,solidSolver,err,error,*999)        
        !--- 3.0 For Standard Elasticity Darcy: Update the boundary conditions of the solid
        CALL FiniteElasticity_PreSolveUpdateBoundaryConditions(solidSolver,err,error,*999)
      CASE DEFAULT
        !do nothing
      END SELECT
    CASE(CONTROL_WHILE_LOOP_TYPE)
      !Do nothing
    CASE(CONTROL_LOAD_INCREMENT_LOOP_TYPE)
      !Do nothing
    CASE DEFAULT
      localError="The control loop type of "//TRIM(NumberToVString(loopType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT    

    EXITS("FiniteElasticity_PreLoop")
    RETURN
999 ERRORSEXITS("FiniteElasticity_PreLoop",err,error)
    RETURN 1

  END SUBROUTINE FiniteElasticity_PreLoop

  !
  !================================================================================================================================
  !

  !>Executes after each loop of a control loop for finite elasticity problems, i.e., after each load increment in a load increment loop
  SUBROUTINE FiniteElasticity_ControlLoadIncrementLoopPostLoop(controlLoop,err,error,*)

    !Argument variables
    TYPE(ControlLoopType), POINTER :: controlLoop !<A pointer to the control loop
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: currentIteration,equationsSetIdx,inputIteration,maxNumberOfIterations,numberOfEquationsSets, &
      & numberOfSolvers,outputIteration,solverIdx
    LOGICAL :: dirExist
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldsType), POINTER :: fields
    TYPE(RegionType), POINTER :: region
    TYPE(SolversType), POINTER :: solvers
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(SolverMappingType), POINTER :: solverMapping
    TYPE(VARYING_STRING) :: fileName,method,directory

    ENTERS("FiniteElasticity_ControlLoadIncrementLoopPostLoop",err,error,*999)

    CALL ControlLoop_CurrentLoadIncrementInfoGet(controlLoop,currentIteration,maxNumberOfIterations,outputIteration, &
      & inputIteration,err,error,*999)
    IF(outputIteration>0) THEN
      IF(MOD(currentIteration,outputIteration)==0) THEN
        NULLIFY(solvers)
        CALL ControlLoop_SolversGet(controlLoop,solvers,err,error,*999)
        CALL Solvers_NumberOfSolversGet(solvers,numberOfSolvers,err,error,*999)
        DO solverIdx=1,numberOfSolvers
          NULLIFY(solver)
          CALL Solvers_SolverGet(solvers,solverIdx,solver,err,error,*999)
          NULLIFY(solverEquations)
          CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
          NULLIFY(solverMapping)
          CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
          CALL SolverMapping_NumberOfEquationsSetsGet(solverMapping,numberOfEquationsSets,err,error,*999)
          DO equationsSetIdx=1,numberOfEquationsSets
            NULLIFY(equationsSet)
            CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
            NULLIFY(region)
            CALL EquationsSet_RegionGet(equationsSet,region,err,error,*999)
            NULLIFY(fields)
            CALL Region_FieldsGet(region,fields,err,error,*999)
            directory="results_load/"
            INQUIRE(FILE=CHAR(directory),EXIST=dirExist)
            IF(.NOT.dirExist) CALL System(CHAR("mkdir "//directory))
            fileName=directory//"mesh"//TRIM(NumberToVString(equationsSetIdx,"*",err,error))// &
              & "_load"//TRIM(NumberToVString(currentIteration,"*",err,error))
            method="FORTRAN"
            CALL FIELD_IO_ELEMENTS_EXPORT(fields,fileName,method,err,error,*999)
            CALL FIELD_IO_NODES_EXPORT(fields,fileName,method,err,error,*999)
          ENDDO !equationsSetIdx
        ENDDO !solverIdx
      ENDIF
    ENDIF

    EXITS("FiniteElasticity_ControlLoadIncrementLoopPostLoop")
    RETURN
999 ERRORS("FiniteElasticity_ControlLoadIncrementLoopPostLoop",err,error)
    EXITS("FiniteElasticity_ControlLoadIncrementLoopPostLoop")
    RETURN 1

  END SUBROUTINE FiniteElasticity_ControlLoadIncrementLoopPostLoop

  !
  !================================================================================================================================
  !

  !>Sets up the finite elasticity problem pre-solve.
  SUBROUTINE FiniteElasticity_PreSolve(solver,err,error,*)

    !Argument variables
    TYPE(SolverType), POINTER :: solver !<A pointer to the solver
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: equationsSetIdx,esSpecification(3),numberOfEquationsSets,numberOfSolverMatrices,pSpecification(3), &
      & solverMatrixIdx,solverNumber
    REAL(DP) :: currentTime,timeIncrement
    LOGICAL :: cellMLSolve,nonlinearSolve,validSubType
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: dependentField
    TYPE(FieldVariableType), POINTER :: dependentVariable
    TYPE(NonlinearSolverType), POINTER :: nonlinearSolver
    TYPE(NewtonSolverType), POINTER :: newtonSolver
    TYPE(ProblemType), POINTER :: problem
    TYPE(SolverType), POINTER :: cellMLSolver
    TYPE(SolverEquationsType), POINTER :: solverEquations 
    TYPE(SolverMappingType), POINTER :: solverMapping
    TYPE(SolverMatricesType), POINTER :: solverMatrices
    TYPE(SolverMatrixType), POINTER :: solverMatrix
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("FiniteElasticity_PreSolve",err,error,*999)

    NULLIFY(controlLoop)
    CALL Solver_ControlLoopGet(solver,controlLoop,err,error,*999)
    NULLIFY(problem)
    CALL ControlLoop_ProblemGet(controlLoop,problem,err,error,*999)
    CALL Problem_SpecificationGet(problem,3,pSpecification,err,error,*999)

    CALL Solver_GlobalNumberGet(solver,solverNumber,err,error,*999)

    SELECT CASE(pSpecification(3))
    CASE(PROBLEM_NO_SUBTYPE)
      !Do nothing ???
    CASE(PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE)
      !Do nothing ???
    CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE)
      !Do nothing ???
    CASE(PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE)
      IF(solverNumber==2) THEN
        CALL ControlLoop_CurrentTimesGet(controlLoop,currentTime,timeIncrement,err,error,*999)
        CALL Solver_DAETimesSet(solver,currentTime,currentTime+timeIncrement,err,error,*999)
      ENDIF
    CASE(PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE)
      !Do nothing ???
    CASE(PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE, &
      & PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE)
      IF(pSpecification(3)==PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE) THEN
        IF(solverNumber==1) THEN
          cellMLSolve=.TRUE.
          nonlinearSolve=.FALSE.
        ELSE
          cellMLSolve=.FALSE.
          nonlinearSolve=.TRUE.
        ENDIF
      ELSE
        cellMLSolve=.FALSE.
        nonlinearSolve=.TRUE.
      ENDIF
      IF(cellMLSolve) THEN
        CALL ControlLoop_CurrentTimesGet(controlLoop,currentTime,timeIncrement,err,error,*999)
        CALL Solver_DAETimesSet(solver,currentTime,currentTime+timeIncrement,err,error,*999)
      ENDIF
      IF(nonlinearSolve) THEN
        NULLIFY(solverEquations)
        CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
        NULLIFY(solverMapping)
        CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
        validSubType=.FALSE.
        CALL SolverMapping_NumberOfEquationsSetsGet(solverMapping,numberOfEquationsSets,err,error,*999)
        DO equationsSetIdx=1,numberOfEquationsSets
          NULLIFY(equationsSet)
          CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
          CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)
          IF(esSpecification(3)==EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE.OR. &
            esSpecification(3)==EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE) THEN
            validSubtype=.TRUE.
            !compute the strain field
            NULLIFY(dependentField)
            CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
            NULLIFY(dependentVariable)
            CALL Field_VariableGet(dependentField,FIELD_U1_VARIABLE_TYPE,dependentVariable,err,error,*999)
            CALL FiniteElasticity_StressStrainCalculate(equationsSet,EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR, &
              & dependentVariable,err,error,*999)
            !Check for a linked CellML solver
            NULLIFY(nonlinearSolver)
            CALL Solver_NonlinearSolverGet(solver,nonlinearSolver,err,error,*999)
            NULLIFY(newtonSolver)
            CALL SolverNonlinear_NewtonSolverGet(nonlinearSolver,newtonSolver,err,error,*999)
            NULLIFY(cellMLSolver)
            CALL SolverNonlinearNewton_LinkedCellMLSolverExists(newtonSolver,cellMLSolver,err,error,*999)
            IF(ASSOCIATED(cellMLSolver)) THEN
!!TODO: why is this being done inside and equations set loop
              !evaluate the constiutive equation in CellML
              CALL Solver_Solve(cellMLSolver,err,error,*999)
            ENDIF
          ENDIF
        ENDDO !equationsSetIdx
      ENDIF
    CASE(PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE)
      ! do nothing, time values get updated in CONTROL_TIME_LOOP_PRE_LOOP as there might be 
      ! a load increment loop below the time loop, so we don't want to update times here before
      ! every solve
    CASE(PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE)
      ! do nothing
    CASE(PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE,PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE)
      ! do nothing
    CASE(EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE)
      ! do nothing
    CASE(PROBLEM_MULTISCALE_FINITE_ELASTICITY_SUBTYPE)
      ! do nothing
    CASE(PROBLEM_MONODOMAIN_1D3D_ACTIVE_STRAIN_SUBTYPE)
      !evaluate the evolution law using the cell model variables of the current time step and the deformation gradient
      !tensor of the previous time step
      CALL FiniteElasticity_EvaluateEvolutionLaw(solver,err,error,*999)
    CASE(PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE)
      ! do nothing
    CASE(PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE, &
      & PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE,PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE)      
      !--- Set 'solverMatrix%updateMatrix=.TRUE.'
      NULLIFY(solverEquations)
      CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
      NULLIFY(solverMapping)
      CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
      NULLIFY(solverMatrices)
      CALL SolverEquations_SolverMatricesGet(solverEquations,solverMatrices,err,error,*999)
      CALL SolverMatrices_NumberOfSolverMatricesGet(solverMatrices,numberOfSolverMatrices,err,error,*999)      
      DO solverMatrixIdx=1,numberOfSolverMatrices
        NULLIFY(solverMatrix)
        CALL SolverMatrices_SolverMatrixGet(solverMatrices,solverMatrixIdx,solverMatrix,err,error,*999)
        solverMatrix%updateMatrix=.TRUE.
      ENDDO !solverMatrixIdx      
    CASE DEFAULT
      localError="Problem subtype "//TRIM(NumberToVString(pSpecification(3),"*",err,error))// &
        & " is not valid for a finite elasticity problem class."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FiniteElasticity_PreSolve")
    RETURN
999 ERRORSEXITS("FiniteElasticity_PreSolve",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_PreSolve
      
  !   
  !================================================================================================================================
  !

  !>Evaluates the evolution law of a multiscale active strain muscle model
  SUBROUTINE FiniteElasticity_EvaluateEvolutionLaw(solver,err,error,*)

    !Argument variables
    TYPE(SolverType), POINTER :: solver !<A pointer to the solver
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dependentNumberOfGauss,dependentNumberOfXi,dofIdx,elementIdx,elementNumber,equationsSetIdx, &
      & esSpecification(3),gaussPointIdx,geometricNumberOfXi,i,internalStart,internalFinish,j,numberOfDimensions, &
      & numberOfEquationsSets,residualVariableType,solverMatrixIdx
    INTEGER(INTG), PARAMETER :: lWMax=1000
    REAL(DP) :: a1,a2,Ca(3,3),CaInv(3,3),Ce(3,3),dNudXi(3,3),dXidNu(3,3),dZdX(3,3),dZdXi(3,3),dZdNu(3,3),dZdNuT(3,3), &
      & FaInv(3,3),FaInvT(3,3),FaT(3,3),Fe(3,3),FeT(3,3),eMatrix1(3,3),eMatrix2(3,3),eMatrix3(3,3),energyPerXB,eValues(3), &
      & eVectors(3,3),fibreVectors(3,3),forceLength,I_1e,freeEnergy,freeEnergy0,JZ,JZNu,lambdaa,lambdaf,lower, &
      & maxXBNumberPerVolume,N1(3,3), N2(3,3),N3(3,3),referenceVolume,sarcomereLength,slope,temp(3,3),temp1(3,3), &
      & temp2(3,3),temp3(3,3),tolerance,tolerance1,up,value,x1,x2,xbDistortion,xbEnergyPerVolume,xbStiffness
    REAL(DP), POINTER :: C(:) !Parameters for constitutive laws
    TYPE(BasisType), POINTER :: dependentBasis,geometricBasis
    TYPE(DecompositionType), POINTER :: dependentDecomposition,geometricDecomposition
    TYPE(DomainType), POINTER :: columnDomain,dependentDomain,geometricDomain
    TYPE(DomainElementsType), POINTER :: columnDomainElements,geometricDomainElements
    TYPE(DomainMappingType), POINTER :: elementsMapping
    TYPE(DomainMappingsType), POINTER :: domainMappings
    TYPE(DomainTopologyType), POINTER :: columnDomainTopology,geometricDomainTopology
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsInterpolationType), POINTER :: equationsInterpolation
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: dependentField,independentField,fibreField,geometricField,materialsField
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable,independentVariable
    TYPE(FieldInterpolationParametersType), POINTER :: geometricInterpParameters,independentInterpParameters, &
      & fibreInterpParameters,materialsInterpParameters,dependentInterpParameters
    TYPE(FieldInterpolatedPointType), POINTER :: dependentInterpPoint,fibreInterpPoint,geometricInterpPoint, &
      & independentInterpPoint,materialsInterpPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: dependentInterpPointMetrics,geometricInterpPointMetrics
    TYPE(QuadratureSchemeType), POINTER :: dependentQuadratureScheme
    TYPE(SolverEquationsType), POINTER :: solverEquations  !<A pointer to the solver equations
    TYPE(SolverMappingType), POINTER :: solverMapping !<A pointer to the solver mapping
    TYPE(SolverMatricesType), POINTER :: solverMatrices
    TYPE(SolverMatrixType), POINTER :: solverMatrix
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("FiniteElasticity_EvaluateEvolutionLaw",err,error,*999)

    !compute the deformation gradient tensor at the Gauss point
    NULLIFY(solverEquations)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    NULLIFY(solverMapping)
    CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
    CALL SolverMapping_NumberOfEquationsSetsGet(solverMapping,numberOfEquationsSets,err,error,*999)
    DO equationsSetIdx=1,numberOfEquationsSets
      NULLIFY(equationsSet)
      CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
      CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)
      NULLIFY(equations)
      CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
      NULLIFY(equationsInterpolation)
      CALL Equations_InterpolationGet(equations,equationsInterpolation,err,error,*999)
      NULLIFY(vectorEquations)
      CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
      NULLIFY(vectorMapping)
      CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
      NULLIFY(nonlinearMapping)
      CALL EquationsMappingVector_NonlinearMappingGet(vectorMapping,nonlinearMapping,err,error,*999)
      NULLIFY(residualMapping)
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,1,residualMapping,err,error,*999)
      CALL EquationsMappingResidual_VariableTypeGet(residualMapping,1,residualVariableType,err,error,*999)
      NULLIFY(geometricField)
      CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
      NULLIFY(geometricVariable)
      CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
      CALL FieldVariable_NumberOfComponentsGet(geometricVariable,numberOfDimensions,err,error,*999)
      NULLIFY(geometricInterpParameters)
      CALL EquationsInterpolation_GeometricParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,geometricInterpParameters, &
        & err,error,*999)
      NULLIFY(geometricInterpPoint)
      CALL EquationsInterpolation_GeometricPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,geometricInterpPoint, &
        & err,error,*999)
      NULLIFY(geometricInterpPointMetrics)
      CALL EquationsInterpolation_GeometricPointMetricsGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
        & geometricInterpPointMetrics,err,error,*999)
      NULLIFY(fibreField)
      CALL EquationsSet_FibreFieldExists(equationsSet,fibreField,err,error,*999)
      NULLIFY(fibreInterpParameters)
      NULLIFY(fibreInterpPoint)
      IF(ASSOCIATED(fibreField)) THEN
        CALL EquationsInterpolation_FibreParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,fibreInterpParameters, &
          & err,error,*999)
        CALL EquationsInterpolation_FibrePointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,fibreInterpPoint,err,error,*999)
      ENDIF
      NULLIFY(dependentField)
      CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
      NULLIFY(dependentInterpParameters)
      CALL EquationsInterpolation_DependentParametersGet(equationsInterpolation,residualVariableType,dependentInterpParameters, &
        & err,error,*999)
      NULLIFY(dependentInterpPoint)
      CALL EquationsInterpolation_DependentPointGet(equationsInterpolation,residualVariableType,dependentInterpPoint, &
        & err,error,*999)
      NULLIFY(dependentInterpPointMetrics)
      CALL EquationsInterpolation_DependentPointMetricsGet(equationsInterpolation,residualVariableType, &
        & dependentInterpPointMetrics,err,error,*999)
      NULLIFY(materialsField)
      CALL EquationsSet_MaterialsFieldExists(equationsSet,materialsField,err,error,*999)
      NULLIFY(materialsInterpParameters)
      NULLIFY(materialsInterpPoint)
      IF(ASSOCIATED(materialsField)) THEN
        CALL EquationsInterpolation_MaterialsParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
          & materialsInterpParameters,err,error,*999)
        CALL EquationsInterpolation_MaterialsPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,materialsInterpPoint, &
          & err,error,*999)
      ENDIF
      NULLIFY(independentField)
      CALL EquationsSet_IndependentFieldGet(equationsSet,independentField,err,error,*999)
      NULLIFY(independentVariable)
      CALL Field_VariableGet(independentField,FIELD_U_VARIABLE_TYPE,independentVariable,err,error,*999)
      NULLIFY(independentInterpParameters)
      NULLIFY(independentInterpPoint)
      !CALL EquationsInterpolation_IndependentParametersGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE, &
      !  & independentInterpParameters,err,error,*999)
      !CALL EquationsInterpolation_IndependentPointGet(equationsInterpolation,FIELD_U_VARIABLE_TYPE,independentInterpPoint, &
      !  & err,error,*999)
      SELECT CASE(esSpecification(3))
      CASE(EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE)
        NULLIFY(dependentDecomposition)
        CALL Field_DecompositionGet(dependentField,dependentDecomposition,err,error,*999)
        NULLIFY(columnDomain)
        CALL Decomposition_DomainGet(dependentDecomposition,0,dependentDomain,err,error,*999)
        NULLIFY(columnDomainTopology)
        CALL Domain_DomainTopologyGet(columnDomain,columnDomainTopology,err,error,*999)
        NULLIFY(columnDomainElements)
        CALL DomainTopology_DomainElementsGet(columnDomainTopology,columnDomainElements,err,error,*999)
        NULLIFY(geometricDecomposition)
        CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
        NULLIFY(geometricDomain)
        CALL Decomposition_DomainGet(geometricDecomposition,0,geometricDomain,err,error,*999)
        NULLIFY(geometricDomainTopology)
        CALL Domain_DomainTopologyGet(geometricDomain,geometricDomainTopology,err,error,*999)
        NULLIFY(geometricDomainElements)
        CALL DomainTopology_DomainElementsGet(geometricDomainTopology,geometricDomainElements,err,error,*999)
        NULLIFY(domainMappings)
        CALL Domain_DomainMappingsGet(geometricDomain,domainMappings,err,error,*999)
        NULLIFY(elementsMapping)
        CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
        CALL DomainMapping_InternalStartGet(elementsMapping,internalStart,err,error,*999)
        CALL DomainMapping_InternalFinishGet(elementsMapping,internalFinish,err,error,*999) 
        DO elementIdx=internalStart,internalFinish
          CALL DomainMapping_NumberGet(elementsMapping,elementIdx,elementNumber,err,error,*999)
          NULLIFY(dependentBasis)
          CALL DomainElements_ElementBasisGet(columnDomainElements,elementNumber,dependentBasis,err,error,*999)
          CALL Basis_NumberOfXiGet(dependentBasis,dependentNumberOfXi,err,error,*999)
          NULLIFY(dependentQuadratureScheme)
          CALL Basis_QuadratureSchemeGet(dependentBasis,BASIS_DEFAULT_QUADRATURE_SCHEME,dependentQuadratureScheme,err,error,*999)
          CALL BasisQuadratureScheme_NumberOfGaussGet(dependentQuadratureScheme,dependentNumberOfGauss,err,error,*999)
          NULLIFY(geometricBasis)
          CALL DomainElements_ElementBasisGet(geometricDomainElements,elementNumber,geometricBasis,err,error,*999)
          CALL Basis_NumberOfXiGet(geometricBasis,geometricNumberOfXi,err,error,*999)

          !Initialise tensors and matrices
          CALL IdentityMatrix(dZdNu(1:3,1:3),err,error,*999)
          
          !Grab interpolation parameters
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,geometricInterpParameters, &
            & err,error,*999)
          IF(ASSOCIATED(fibreField)) THEN
            CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,fibreInterpParameters, &
              & err,error,*999)
          ENDIF
          CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,dependentInterpParameters, &
            & err,error,*999)
          IF(ASSOCIATED(materialsField)) THEN
            CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,materialsInterpParameters, &
              & err,error,*999)
          ENDIF
          !CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementNumber,independentInterpParameters, &
          !  & err,error,*999)
            
          C=>materialsInterpPoint%values(:,1)

          !Loop over gauss points
          DO gaussPointIdx=1,dependentNumberOfGauss

            !Interpolate dependent, geometric, fibre and material fields
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,dependentInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(dependentNumberOfXi,dependentInterpPointMetrics,err,error,*999)
            CALL Field_InterpolateGauss(FIRST_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,geometricInterpPoint, &
              & err,error,*999)
            CALL Field_InterpolatedPointMetricsCalculate(geometricNumberOfXi,geometricInterpPointMetrics,err,error,*999)
            IF(ASSOCIATED(fibreField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,fibreInterpPoint, &
                & err,error,*999)
            ENDIF
            IF(ASSOCIATED(materialsField)) THEN
              CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,materialsInterpPoint, &
                & err,error,*999)
            ENDIF
            !CALL Field_InterpolateGauss(NO_PART_DERIV,BASIS_DEFAULT_QUADRATURE_SCHEME,gaussPointIdx,independentInterpPoint, &
            !  & err,error,*999)

            !Calculate material fibre coordinate system
            CALL CoordinateSystem_MaterialFibreSystemCalculate(geometricInterpPointMetrics,fibreInterpPoint, &
              & dNudXi(1:numberOfDimensions,1:geometricNumberOfXi),dXidNu(1:geometricNumberOfXi,1:numberOfDimensions), &
              & fibreVectors(1:numberOfDimensions,1:geometricNumberOfXi),err,error,*999)
            !Calculate F=dZ/dNU, the deformation gradient tensor at the gauss point
            CALL FiniteElasticity_DeformationGradientTensorCalculate(dependentInterpPointMetrics,geometricInterpPointMetrics, &
              & dXidNu(1:geometricNumberOfXi,1:numberOfDimensions),dZdX,JZ,dZdNu,JZNu,err,error,*999)

            !get A1, A2, x1, x2 at the Gauss point of the 3D finite elasticity element
            CALL FieldVariable_LocalGaussDOFGet(independentVariable,gaussPointIdx,elementNumber,1,dofIdx,err,error,*999)
            CALL FieldVariable_ParameterSetGetLocalDOF(independentVariable,FIELD_VALUES_SET_TYPE,dofIdx,a1,err,error,*999)
            CALL FieldVariable_LocalGaussDOFGet(independentVariable,gaussPointIdx,elementNumber,2,dofIdx,err,error,*999)
            CALL FieldVariable_ParameterSetGetLocalDOF(independentVariable,FIELD_VALUES_SET_TYPE,dofIdx,a2,err,error,*999)
            CALL FieldVariable_LocalGaussDOFGet(independentVariable,gaussPointIdx,elementNumber,3,dofIdx,err,error,*999)
            CALL FieldVariable_ParameterSetGetLocalDOF(independentVariable,FIELD_VALUES_SET_TYPE,dofIdx,x1,err,error,*999)
            CALL FieldVariable_LocalGaussDOFGet(independentVariable,gaussPointIdx,elementNumber,4,dofIdx,err,error,*999)
            CALL FieldVariable_ParameterSetGetLocalDOF(independentVariable,FIELD_VALUES_SET_TYPE,dofIdx,x2,err,error,*999)
            
            !--------------------------------------------------------------------------------------------
            sarcomereLength=dZdNu(1,1)
            ! Calculate Filament-Overlap
            IF(sarcomereLength.LE.0.635_DP) THEN
              forceLength=0.0_DP
            ELSE IF(sarcomereLength.LE.0.835_DP) THEN 
              forceLength=4.2_DP*(sarcomereLength-0.635_DP)
            ELSE IF(sarcomereLength.LE.1.0_DP) THEN
              forceLength=0.84_DP+0.9697_DP*(sarcomereLength-0.835_DP)
            ELSE IF(sarcomereLength.LE.1.125_DP) THEN
              forceLength=1.0_DP
            ELSE IF(sarcomereLength.LE.1.825_DP) THEN
              forceLength=1.0_DP-1.4286_DP*(sarcomereLength-1.125_DP)
            ELSE
              forceLength=0.0_DP
            ENDIF

            referenceVolume=1.4965e-03_DP ! [micrometer^3]
            maxXBNumberPerVolume=120.0_DP*2.0_DP/referenceVolume ! [cross-bridges per micrometer^3]
            energyPerXB=0.5_DP*x2**2*C(8) ! [Newton times micrometer]
            
            !Mechanical Energy stored in cross-bridges
            xbEnergyPerVolume=maxXBNumberPerVolume*forceLength*energyPerXB*a2 ! [Newton per micrometer^2]
            !Mechanical Energy stored in cross-bridges converted in Newton per cm^2
            xbEnergyPerVolume=xbEnergyPerVolume*1e+08_DP ! [Newton per cm^2]
            
            !Initalize lambdaa
            lambdaa=1.0_DP
            
            FaInv=0.0_DP
            FaInv(1,1)=1.0_DP/lambdaa
            FaInv(2,2)=1.0_DP
            FaInv(3,3)=1.0_DP
            
            CALL MatrixProduct(dZdNu,FaInv,Fe,err,error,*999)
            CALL MatrixTranspose(Fe,FeT,err,error,*999)
            CALL MatrixProduct(FeT,Fe,Ce,err,error,*999)
            
            !Odgen law - 3 terms. Material Parameters C = [mu(1) mu(2) mu(3) alpha(1) alpha(2) alpha(3) mu_0]
            CALL SolveEigenproblem(Ce(1:3,1:3),eValues(1:3),eVectors(1:3,1:3),err,error,*999)
            
            DO i=1,3
              DO j=1,3
                eMatrix1(i,j)=eVectors(i,1)*eVectors(j,1)
                eMatrix2(i,j)=eVectors(i,2)*eVectors(j,2)
                eMatrix3(i,j)=eVectors(i,3)*eVectors(j,3)
              ENDDO !j
            ENDDO !i

            CALL MatrixProduct(FaInv,eMatrix1,N1,err,error,*999)
            CALL MatrixProduct(N1,FaInv,N1,err,error,*999) ! FaInv=FaInvT
            CALL MatrixProduct(FaInv,eMatrix2,N2,err,error,*999)
            CALL MatrixProduct(N2,FaInv,N2,err,error,*999) ! FaInv=FaInvT
            CALL MatrixProduct(FaInv,eMatrix3,N3,err,error,*999)
            CALL MatrixProduct(N3,FaInv,N3,err,error,*999) ! FaInv=FaInvT 

            freeEnergy0=0.0_DP
            DO i=1,3
              freeEnergy0=freeEnergy0+C(i)/C(i+3)*( &
                & eValues(1)**(C(i+3)/2.0_DP)+ &
                & eValues(2)**(C(i+3)/2.0_DP)+ &
                & eValues(3)**(C(i+3)/2.0_DP)-3.0_DP)
            ENDDO !i
            freeEnergy0=C(7)*freeEnergy0

            freeEnergy=freeEnergy0
            
            value=xbEnergyPerVolume-(freeEnergy-freeEnergy0)

            !tolerance for Newton's method
            tolerance=0.00001_DP
            !tolerance for the bisection method as preconditioner. Since Newton's method does not converge,
            !we only use the bisection method here            
            tolerance1=tolerance 
            up=lambdaa
            lower=0.001_DP
            
            DO WHILE(ABS(VALUE).GE.tolerance)

              !bisection method
              IF(ABS(VALUE).GE.tolerance1) THEN
                lambdaa=up-(up-lower)/2.0_DP

                FaInv=0.0_DP
                FaInv(1,1)=1.0_DP/lambdaa
                FaInv(2,2)=1.0_DP
                FaInv(3,3)=1.0_DP
                
                CALL MatrixProduct(dZdNu,FaInv,Fe,err,error,*999)
                CALL MatrixTranspose(Fe,FeT,err,error,*999)
                CALL MatrixProduct(FeT,Fe,Ce,err,error,*999)
                
                CALL SolveEigenproblem(Ce(1:3,1:3),eValues(1:3),eVectors(1:3,1:3),err,error,*999)
 
                DO i=1,3
                  DO j=1,3
                    eMatrix1(i,j)=eVectors(i,1)*eVectors(j,1)
                    eMatrix2(i,j)=eVectors(i,2)*eVectors(j,2)
                    eMatrix3(i,j)=eVectors(i,3)*eVectors(j,3)
                  ENDDO !j
                ENDDO !i

                CALL MatrixProduct(FaInv,eMatrix1,N1,err,error,*999)
                CALL MatrixProduct(N1,FaInv,N1,err,error,*999) ! FaInv=FaInvT
                CALL MatrixProduct(FaInv,eMatrix2,N2,err,error,*999)
                CALL MatrixProduct(N2,FaInv,N2,err,error,*999) ! FaInv=FaInvT
                CALL MatrixProduct(FaInv,eMatrix3,N3,err,error,*999)
                CALL MatrixProduct(N3,FaInv,N3,err,error,*999) ! FaInv=FaInvT 
                
                freeEnergy=0.0_DP
                DO i=1,3
                  freeEnergy=freeEnergy+C(i)/C(i+3)*( &
                    & eValues(1)**(C(i+3)/2.0_DP)+ &
                    & eValues(2)**(C(i+3)/2.0_DP)+ &
                    & eValues(3)**(C(i+3)/2.0_DP)-3.0_DP)
                ENDDO !i
                freeEnergy=C(7)*freeEnergy

                value=xbEnergyPerVolume-(freeEnergy-freeEnergy0)

                IF(value.GE.0.0_DP) THEN
                  up=lambdaa
                ELSE
                  lower=lambdaa
                ENDIF
                
              ELSE 
                !Newton's method -- needs to be checked TODO
                
                temp=dZdNu+dZdNuT
                CALL MatrixProduct(FeT,temp,temp,err,error,*999)
                CALL MatrixProduct(temp,N1,temp1,err,error,*999) 
                CALL MatrixProduct(temp,N2,temp2,err,error,*999) 
                CALL MatrixProduct(temp,N3,temp3,err,error,*999) 

                temp=0.0_DP
                DO i=1,3
                  temp=temp+ &
                    & C(i)*eValues(1)**(C(i+3)/2.0_DP-1.0_DP)*temp1+ &
                    & C(i)*eValues(2)**(C(i+3)/2.0_DP-1.0_DP)*temp2+ &
                    & C(i)*eValues(3)**(C(i+3)/2.0_DP-1.0_DP)*temp3
                END DO
                    
                !slope=temp(1,1)*C(7)
                lambdaa=lambdaa-VALUE/slope
                !IF(lambdaa.LE.0.0_DP) THEN
                !  lambdaa=0.1_DP
                !ENDIF
                !lambdaa=lambdaa-0.001_DP

                FaInv=0.0_DP
                FaInv(1,1)=1.0_DP/lambdaa
                FaInv(2,2)=1.0_DP
                FaInv(3,3)=1.0_DP
                
                CALL MatrixProduct(dZdNu,FaInv,Fe,err,error,*999)
                CALL MatrixTranspose(Fe,FeT,err,error,*999)
                CALL MatrixProduct(FeT,Fe,Ce,err,error,*999)
                
                CALL SolveEigenproblem(Ce(1:3,1:3),eValues(1:3),eVectors(1:3,1:3),err,error,*999)

                DO i=1,3
                  DO j=1,3
                    eMatrix1(i,j)=eVectors(i,1)*eVectors(j,1)
                    eMatrix2(i,j)=eVectors(i,2)*eVectors(j,2)
                    eMatrix3(i,j)=eVectors(i,3)*eVectors(j,3)
                  ENDDO !j
                ENDDO !i

                CALL MatrixProduct(FaInv,eMatrix1,N1,err,error,*999)
                CALL MatrixProduct(N1,FaInv,N1,err,error,*999) ! FaInv=FaInvT
                CALL MatrixProduct(FaInv,eMatrix2,N2,err,error,*999)
                CALL MatrixProduct(N2,FaInv,N2,err,error,*999) ! FaInv=FaInvT
                CALL MatrixProduct(FaInv,eMatrix3,N3,err,error,*999)
                CALL MatrixProduct(N3,FaInv,N3,err,error,*999) ! FaInv=FaInvT 
                
                freeEnergy=0.0_DP
                DO i=1,3
                  freeEnergy=freeEnergy+C(i)/C(i+3)*( &
                    & eValues(1)**(C(i+3)/2.0_DP)+ &
                    & eValues(2)**(C(i+3)/2.0_DP)+ &
                    & eValues(3)**(C(i+3)/2.0_DP)-3.0_DP)
                ENDDO !i
                freeEnergy=C(7)*freeEnergy

                value=xbEnergyPerVolume-(freeEnergy-freeEnergy0)
              ENDIF
            ENDDO !coverged

            !store lambdaa at the Gauss point
            CALL FieldVariable_LocalGaussDOFGet(independentVariable,gaussPointIdx,elementNumber,5,dofIdx,err,error,*999)
            CALL FieldVariable_ParameterSetUpdateLocalDOF(independentVariable,FIELD_VALUES_SET_TYPE,dofIdx,lambdaa,err,error,*999)
            
          ENDDO !gaussPointIdx
        ENDDO !elementIdx
      CASE DEFAULT
        localError="This routine is not implemented for the third equations set specification of "// &
          & TRIM(NumberToVString(esSpecification(3),"*",err,error))//" of a finite elasticity type of an elasticity equation set."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ENDDO

    EXITS("FiniteElasticity_EvaluateEvolutionLaw")
    RETURN
999 ERRORS("FiniteElasticity_EvaluateEvolutionLaw",err,error)
    EXITS("FiniteElasticity_EvaluateEvolutionLaw")
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_EvaluateEvolutionLaw

  !
  !================================================================================================================================
  !

  !>Update boundary conditions for finite elasticity pre solve
  SUBROUTINE FiniteElasticity_PreSolveUpdateBoundaryConditions(solver,err,error,*)

    !Argument variables
    TYPE(SolverType), POINTER :: solver !<A pointer to the solver
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: boundaryConditionCheckVariable,dependentNumberOfDOFs,dofIdx,esSpecification(3),geometricNumberOfDOFs, &
      & loopIdx,numberOfDependentDOFs,numberOfGeometricDOFs,problemSubType,pSpecification(3),solverGlobalNumber,solverOutputType
    REAL(DP) :: alpha,currentTime,newPressureValue,timeIncrement
    REAL(DP), POINTER :: currentPressureValues(:),dependentFieldValues(:),geometricFieldValues(:),meshPositionValues(:) 
    REAL(DP), ALLOCATABLE :: newPressureValues(:)
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(BoundaryConditionsVariableType), POINTER :: boundaryConditionsVariable
    TYPE(ControlLoopType), POINTER :: controlLoop!<A pointer to the control loop to solve.
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsSetType), POINTER :: equationsSet !<A pointer to the equations set
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(FieldType), POINTER :: dependentField, geometricField
    TYPE(FieldVariableType), POINTER :: dependentVariable,geometricVariable
    TYPE(ProblemType), POINTER :: problem
    TYPE(SolverEquationsType), POINTER :: solverEquations  !<A pointer to the solver equations
    TYPE(SolverMappingType), POINTER :: solverMapping !<A pointer to the solver mapping
 
    ENTERS("FiniteElasticity_PreSolveUpdateBoundaryConditions",err,error,*999)

    CALL Solver_GlobalNumberGet(solver,solverGlobalNumber,err,error,*999)
   
    IF(solverGlobalNumber==1) THEN
      CALL Solver_OutputTypeGet(solver,solverOutputType,err,error,*999)
      NULLIFY(solverEquations)
      CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
      NULLIFY(solverMapping)
      CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
      NULLIFY(controlLoop)
      CALL Solver_ControlLoopGet(solver,controlLoop,err,error,*999)
      CALL ControlLoop_CurrentTimesGet(controlLoop,currentTime,timeIncrement,err,error,*999)
      NULLIFY(problem)
      CALL ControlLoop_ProblemGet(controlLoop,problem,err,error,*999)
      CALL Problem_SpecificationGet(problem,3,pSpecification,err,error,*999)
      problemSubType=pSpecification(3)
      NULLIFY(equationsSet)
      CALL SolverMapping_EquationsSetGet(solverMapping,1,equationsSet,err,error,*999)
      NULLIFY(equations)
      CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
      CALL EquationsSet_SpecificationGet(equationsSet,3,esSpecification,err,error,*999)
      SELECT CASE(problemSubType)
      CASE(PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE,PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE)
        SELECT CASE(esSpecification(3))
        CASE(EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE)
          NULLIFY(dependentField)
          CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
          NULLIFY(boundaryConditions)
          CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
          NULLIFY(vectorEquations)
          CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
          NULLIFY(vectorMapping)
          CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
          CALL Field_VariableGet(dependentField,FIELD_DELUDELN_VARIABLE_TYPE,dependentVariable,err,error,*999)
          CALL FieldVariable_NumberOfDOFsGet(dependentVariable,dependentNumberOfDOFs,err,error,*999)
          NULLIFY(boundaryConditionsVariable)
          CALL BoundaryConditions_VariableGet(boundaryConditions,dependentVariable,boundaryConditionsVariable,err,error,*999)
          IF(boundaryConditionsVariable%dofCounts(BOUNDARY_CONDITION_PRESSURE)>0) THEN              
            IF(solverOutputType >= SOLVER_PROGRESS_OUTPUT) &
              & CALL WriteString(GENERAL_OUTPUT_TYPE,"Finite elasticity update pressure BCs.",err,error,*999)
            NULLIFY(currentPressureValues)
            CALL FieldVariable_ParameterSetDataGet(dependentVariable,FIELD_PRESSURE_VALUES_SET_TYPE,currentPressureValues, &
              & err,error,*999)
            IF(diagnostics1) THEN
              CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,dependentNumberOfDOFs,dependentNumberOfDOFs, &
                & dependentNumberOfDOFs,currentPressureValues,'(" Current pressure values :",4(X,E13.6))','(26X,4(X,E13.6))', &
                & err,error,*999)
            ENDIF
            
            !Linear increase of cavity pressure: just a test example prototype
            !\todo: general time-dependent boundary condition input method?
            alpha = ( currentTime + timeIncrement ) / currentTime
            DO dofIdx=1,dependentNumberOfDOFs
              newPressureValue = alpha * currentPressureValues(dofIdx)
              CALL FieldVariable_ParameterSetUpdateLocalDOF(dependentVariable,FIELD_PRESSURE_VALUES_SET_TYPE,dofIdx, &
               & newPressureValue,err,error,*999)
            ENDDO !dofIdx
            CALL FieldVariable_ParameterSetUpdateStart(dependentVariable,FIELD_PRESSURE_VALUES_SET_TYPE,err,error,*999)
            CALL FieldVariable_ParameterSetUpdateFinish(dependentVariable,FIELD_PRESSURE_VALUES_SET_TYPE,err,error,*999)
                        
            IF(diagnostics1) THEN
              CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,dependentNumberOfDOFs,dependentNumberOfDOFs, &
                & dependentNumberOfDOFs,currentPressureValues,'(" Updated pressure values :",4(X,E13.6))','(26X,4(X,E13.6))', &
                & err,error,*999)
            ENDIF
            CALL FieldVariable_ParameterSetDataRestore(dependentVariable,FIELD_PRESSURE_VALUES_SET_TYPE,currentPressureValues, &
              & err,error,*999)
          ENDIF !Pressure_condition_used
        CASE DEFAULT
          ! do nothing 
        END SELECT
        
      CASE(PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE)
        
        SELECT CASE(esSpecification(3))
        CASE(EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE, &
          & EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE, &
          & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE)
          IF(solver%outputType>=SOLVER_PROGRESS_OUTPUT) &
            & CALL WriteString(GENERAL_OUTPUT_TYPE,"Finite elasticity update BCs.",err,error,*999)
          NULLIFY(dependentField)
          CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
          NULLIFY(dependentVariable)
          CALL Field_VariableGet(dependentField,FIELD_U_VARIABLE_TYPE,dependentVariable,err,error,*999)
          NULLIFY(geometricField)
          CALL EquationsSet_GeometricFieldGet(equationsSet,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          NULLIFY(boundaryConditions)
          CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
          NULLIFY(vectorEquations)
          CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
          NULLIFY(vectorMapping)
          CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
          CALL FieldVariable_NumberOfDOFsGet(dependentVariable,numberOfDependentDOFs,err,error,*999)
          CALL FieldVariable_NumberOfDOFsGet(geometricVariable,numberOfGeometricDOFs,err,error,*999)
          NULLIFY(boundaryConditionsVariable)
          CALL BoundaryConditions_VariableGet(boundaryConditions,dependentVariable,boundaryConditionsVariable,err,error,*999)
          NULLIFY(dependentFieldValues)
          CALL FieldVariable_ParameterSetDataGet(dependentVariable,FIELD_VALUES_SET_TYPE,dependentFieldValues,err,error,*999)

          IF(diagnostics1) THEN
           CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,dependentNumberOfDOFs,dependentNumberOfDOFs, &
             & dependentNumberOfDOFs,dependentFieldValues,'(" Current dependent values :",4(X,E13.6))','(27X,4(X,E13.6))', &
             & err,error,*999)
          ENDIF
          
          ! requires solid dependent field and geometry to be interpolated identically !!!
          ! assumes that DOFs for dependent and geometric field are stored in the same order
          ! How does this routine take into account the BC value ???
          alpha = 0.10_DP * SIN( 2.0_DP * PI * currentTime / 4.0_DP )
          CALL Field_ParameterSetsCopy(geometricField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
            & FIELD_MESH_DISPLACEMENT_SET_TYPE,alpha,err,error,*999)

          NULLIFY(geometricFieldValues)
          CALL FieldVariable_ParameterSetDataGet(geometricVariable,FIELD_VALUES_SET_TYPE,geometricFieldValues,err,error,*999)
          
          DO dofIdx=1,geometricNumberOfDOFs
            boundaryConditionCheckVariable=boundaryConditionsVariable%conditionTypes(dofIdx)
            IF(boundaryConditionCheckVariable==BOUNDARY_CONDITION_MOVED_WALL .OR. &
              & boundaryConditionCheckVariable==BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED) THEN
              !--- To obtain absolute positions, add nodal coordinates on top of mesh displacement
              CALL FieldVariable_ParameterSetAddLocalDOF(geometricVariable,FIELD_MESH_DISPLACEMENT_SET_TYPE,dofIdx, &
                & geometricFieldValues(dofIdx),err,error,*999)
            ELSE
              ! do nothing ???
            END IF
          ENDDO !dofIdx
            
          NULLIFY(meshPositionValues)
          CALL FieldVariable_ParameterSetDataGet(geometricVariable,FIELD_MESH_DISPLACEMENT_SET_TYPE,meshPositionValues, &
            & err,error,*999)
          
          DO dofIdx=1,dependentNumberOfDOFs
            boundaryConditionCheckVariable=boundaryConditionsVariable%conditionTypes(dofIdx)
            IF(boundaryConditionCheckVariable==BOUNDARY_CONDITION_MOVED_WALL .OR. &
              & boundaryConditionCheckVariable==BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED) THEN
              
              !Update FIELD_BOUNDARY_CONDITIONS_SET_TYPE or FIELD_VALUES_SET_TYPE
              !(so it is one or the other, but not both) depending on whether or not load increments are used
              IF(boundaryConditionCheckVariable==BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED) THEN
                CALL FieldVariable_ParameterSetUpdateLocalDOF(dependentVariable,FIELD_BOUNDARY_CONDITIONS_SET_TYPE, &
                  & dofIdx,meshPositionValues(dofIdx),err,error,*999)
              ELSE
                !--- Update the dependent field with the new absolute position
                CALL FieldVariable_ParameterSetUpdateLocalDOF(dependentVariable,FIELD_VALUES_SET_TYPE,dofIdx, &
                  & meshPositionValues(dofIdx),err,error,*999)
              ENDIF
              
            ELSE
              ! do nothing ???
            END IF
          ENDDO !dofIdx
            
          CALL FieldVariable_ParameterSetDataRestore(geometricVariable,FIELD_VALUES_SET_TYPE,geometricFieldValues,err,error,*999)
          CALL FieldVariable_ParameterSetDataRestore(geometricVariable,FIELD_MESH_DISPLACEMENT_SET_TYPE,meshPositionValues, &
            & err,error,*999)
           
          IF(boundaryConditionCheckVariable==BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED) THEN
            CALL FieldVariable_ParameterSetUpdateStart(dependentVariable,FIELD_BOUNDARY_CONDITIONS_SET_TYPE,err,error,*999)
            CALL FieldVariable_ParameterSetUpdateFinish(dependentVariable,FIELD_BOUNDARY_CONDITIONS_SET_TYPE,err,error,*999)
          ENDIF
          CALL FieldVariable_ParameterSetUpdateStart(dependentVariable,FIELD_VALUES_SET_TYPE,err,error,*999)
          CALL FieldVariable_ParameterSetUpdateFinish(dependentVariable,FIELD_VALUES_SET_TYPE,err,error,*999)
          
          IF(diagnostics1) THEN
            CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,dependentNumberOfDOFs,dependentNumberOfDOFs, &
              & dependentNumberOfDOFs,dependentFieldValues,'(" Updated dependent values :",4(X,E13.6))','(27X,4(X,E13.6))', &
              & err,error,*999)
          ENDIF
          CALL FieldVariable_ParameterSetDataRestore(dependentVariable,FIELD_VALUES_SET_TYPE,dependentFieldValues,err,error,*999)
         
        CASE DEFAULT
          ! do nothing
        END SELECT
      CASE DEFAULT
        ! do nothing 
      END SELECT
    ENDIF
    
    EXITS("FiniteElasticity_PreSolveUpdateBoundaryConditions")
    RETURN
999 ERRORS("FiniteElasticity_PreSolveUpdateBoundaryConditions",err,error)
    EXITS("FiniteElasticity_PreSolveUpdateBoundaryConditions")
    RETURN 1

  END SUBROUTINE FiniteElasticity_PreSolveUpdateBoundaryConditions

  !
  !================================================================================================================================
  !

  !>Evaluates the functions f(J) and f\'(J);
  !>  Eq.(21) in Chapelle, Gerbeau, Sainte-Marie, Vignon-Clementel, Computation Mechanics (2010)
  SUBROUTINE FiniteElasticity_EvaluateChapelleFunction(Jznu,ffact,dfdJfact,err,error,*)
  
    !Argument variables
    REAL(DP), INTENT(IN) :: Jznu !<Jznu=DETERMINANT(rCauchyGreen,err,error)**0.5_DP
    REAL(DP), INTENT(OUT) :: ffact !<f(Jznu) of the INRIA model
    REAL(DP), INTENT(OUT) :: dfdJfact !<dfdJfact = f'(Jznu) of the INRIA model
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    
    ENTERS("FiniteElasticity_EvaluateChapelleFunction",err,error,*999)

    !IF( ABS(Jznu-1.0_DP) > 5.0E-02_DP ) THEN
    IF( ABS(Jznu-1.0_DP) > 1.0E-10_DP ) THEN
      !Eq.(21) of the INRIA paper
      ffact = 2.0_DP * (Jznu - 1.0_DP - log(Jznu)) / (Jznu - 1.0_DP)**2.0_DP
      dfdJfact = ( 2.0_DP * (1.0_DP - 1.0_DP/Jznu) * (Jznu - 1.0_DP)**2.0_DP &
        & - 4.0_DP * (Jznu - 1.0_DP - log(Jznu)) * (Jznu - 1.0_DP) ) / (Jznu - 1.0_DP)**4.0_DP
    ELSE
      ffact = 1.0_DP
      dfdJfact = 0.0_DP
    ENDIF

    EXITS("FiniteElasticity_EvaluateChapelleFunction")
    RETURN
999 ERRORSEXITS("FiniteElasticity_EvaluateChapelleFunction",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_EvaluateChapelleFunction

  !
  !================================================================================================================================
  !

  !>Evaluates the 2nd Piola-Kirchhoff stress tensor;
  !>  Eq.(13) in Chapelle, Gerbeau, Sainte-Marie, Vignon-Clementel, Computational Mechanics (2010)
  SUBROUTINE FiniteElasticity_EvalChapellePiolaTensorAddition(rCauchyGreen,piolaDeformation,darcyMassIncrease, &
    & piolaTensor2Addition,err,error,*)
  
    !Argument variables
    REAL(DP), INTENT(IN) :: rCauchyGreen(3,3) !<C=F\'F
    REAL(DP), INTENT(IN) :: piolaDeformation(3,3) !<inverse of rCauchyGreen
    REAL(DP), INTENT(IN) :: darcyMassIncrease !<mass increase
    REAL(DP), INTENT(OUT) :: piolaTensor2Addition(3,3) !<Addition to the 2nd Piola-Kirchhoff tensor
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    INTEGER(INTG) :: i,j
    REAL(DP) :: Jznu !<Jznu=DETERMINANT(rCauchyGreen,err,error)**0.5_DP
    REAL(DP) :: ffact !<f(Jznu) of the INRIA model
    REAL(DP) :: dfdJfact !<dfdJfact = f\'(Jznu) of the INRIA model
    REAL(DP) :: Mfact, bfact, p0fact  !<INRIA constitutive law
    REAL(DP) :: darcyVolIncrease, darcyRho0F

    
    ENTERS("FiniteElasticity_EvalChapellePiolaTensorAddition",err,error,*999)

    !Parameters settings for coupled elasticity Darcy INRIA model:
    CALL FiniteElasticity_GetDarcyParameters(darcyRho0F,Mfact,bfact,p0fact,err,error,*999)

    darcyVolIncrease = darcyMassIncrease / darcyRho0F

    CALL Determinant(rCauchyGreen,Jznu,err,error,*999)
    Jznu=Jznu**0.5_DP
    IF(ABS(Jznu)<1.0E-10_DP) &
      & CALL FlagError("FiniteElasticity_EvalChapellePiolaTensorAddition: ABS(Jznu) < 1.0E-10_DP.",err,error,*999)
 
    CALL FiniteElasticity_EvaluateChapelleFunction(Jznu,ffact,dfdJfact,err,error,*999)

    DO i=1,3
      DO j=1,3
        !piolaTensor2Addition(i,j) = - Mfact*bfact*darcyVolIncrease*(ffact+(Jznu-1.0_DP)*dfdJfact)*Jznu*piolaDeformation(i,j) &
        !  & + 0.5_DP*Mfact*darcyVolIncrease**2.0_DP*dfdJfact*Jznu*piolaDeformation(i,j)
        piolaTensor2Addition(i,j) = 0.5_DP * Mfact * darcyVolIncrease**2.0_DP * Jznu * piolaDeformation(i,j)
        !piolaTensor2Addition(i,j) = 0.0_DP
      ENDDO !j
    ENDDO !i

    !piolaTensor2Addition = - Mfact * bfact * darcyVolIncrease * (ffact + (Jznu - 1.0_DP) * dfdJfact) * Jznu * piolaDeformation &
    !  & + 0.5_DP * Mfact * darcyVolIncrease**2.0_DP * dfdJfact * Jznu * piolaDeformation

    IF(diagnostics1) THEN
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  darcyVolIncrease = ",darcyVolIncrease,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Jznu = ",Jznu,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  ffact = ",ffact,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  dfdJfact = ",dfdJfact,err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3,3,3,piolaDeformation,WRITE_STRING_MATRIX_NAME_AND_INDICES, &
        & '("    piolaDeformation','(",I1,",:)',' :",3(X,E13.6))','(17X,3(X,E13.6))',err,error,*999)
      CALL WriteStringMatrix(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,1,1,3,3,3,piolaTensor2Addition, &
        & WRITE_STRING_MATRIX_NAME_AND_INDICES,'("    piolaTensor2Addition','(",I1,",:)',' :",3(X,E13.6))', &
        & '(17X,3(X,E13.6))',err,error,*999)
    ENDIF

    EXITS("FiniteElasticity_EvalChapellePiolaTensorAddition")
    RETURN
999 ERRORSEXITS("FiniteElasticity_EvalChapellePiolaTensorAddition",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_EvalChapellePiolaTensorAddition

  !
  !================================================================================================================================
  !

  !>Sets some data for the coupled Darcy / finite-elasticity model
  SUBROUTINE FiniteElasticity_GetDarcyParameters(darcyRho0F,Mfact,bfact,p0fact,err,error,*)
  
    !Argument variables
    REAL(DP), INTENT(OUT) :: darcyRho0F
    REAL(DP), INTENT(OUT) :: Mfact
    REAL(DP), INTENT(OUT) :: bfact
    REAL(DP), INTENT(OUT) :: p0fact
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    
    ENTERS("FiniteElasticity_GetDarcyParameters",err,error,*999)

!   darcyRho0F = 1.0E-03_DP
    darcyRho0F = 1.0_DP
!   Mfact = 2.18E05_DP
    Mfact = 2.18E00_DP
    bfact = 1.0_DP
    p0fact = 0.0_DP

    EXITS("FiniteElasticity_GetDarcyParameters")
    RETURN
999 ERRORSEXITS("FiniteElasticity_GetDarcyParameters",err,error)
    RETURN 1
    
  END SUBROUTINE FiniteElasticity_GetDarcyParameters

  !
  !================================================================================================================================
  !

  !> Apply load increments to the gravity vector
  SUBROUTINE FiniteElasticity_LoadIncrementApply(equationsSet,iterationNumber,maximumNumberOfIterations,err,error,*)

    !Argument variables
    TYPE(EquationsSetType), POINTER :: equationsSet
    INTEGER(INTG), INTENT(IN) :: iterationNumber !<The current load increment iteration index
    INTEGER(INTG), INTENT(IN) :: maximumNumberOfIterations !<Final index for load increment loop
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    REAL(DP) :: increment
    TYPE(EquationsType), POINTER :: equations
    TYPE(FieldType), POINTER :: sourceField

    ENTERS("FiniteElasticity_LoadIncrementApply",err,error,*999)

    NULLIFY(equations)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    NULLIFY(sourceField)
    CALL EquationsSet_SourceFieldExists(equationsSet,sourceField,err,error,*999)
    IF(ASSOCIATED(sourceField)) THEN
      IF(maximumNumberOfIterations>1) THEN
        IF(iterationNumber==1) THEN
          !Setup initial values parameter set
          CALL Field_ParameterSetEnsureCreated(sourceField,FIELD_U_VARIABLE_TYPE,FIELD_INITIAL_VALUES_SET_TYPE,err,error,*999)
          CALL Field_ParameterSetsCopy(sourceField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,FIELD_INITIAL_VALUES_SET_TYPE, &
            & 1.0_DP,err,error,*999)
        ENDIF
        increment=REAL(iterationNumber)/REAL(maximumNumberOfIterations)
        CALL Field_ParameterSetsCopy(sourceField,FIELD_U_VARIABLE_TYPE,FIELD_INITIAL_VALUES_SET_TYPE,FIELD_VALUES_SET_TYPE, &
          & increment,err,error,*999)
      ENDIF
    ENDIF

    EXITS("FiniteElasticity_LoadIncrementApply")
    RETURN
999 ERRORSEXITS("FiniteElasticity_LoadIncrementApply",err,error)
    RETURN 1

  END SUBROUTINE FiniteElasticity_LoadIncrementApply

  !
  !================================================================================================================================
  !
  
!   Main functions to compute everything
      
  SUBROUTINE clooping(hstep,tol,maxitr,mu0,kc,kt,k1,k2,k3,k12,ka, &
    & q,H1,H2,H12,Jh,Gamma,Gammam,Dt,Fr,Jr,Jen,Beprn,s1n,s2n,s3n, &
    & alpha1n,Bn,Je,s1,s2,s3,devH,HH,alpha1,B,Bepr,lame1,lame2,lame3, &
    & lamea,Ee11,Ee22,Ee33,Ee12,Eea,QQ,T0,T1,T2,T3,T4,T5,TT)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 hstep,tol,maxitr,alpha1n,Bn
    REAL*8 mu0,kc,kt,k1,k2,k3,k12,ka,q,H1,H2,H12,Jh,Gamma,Gammam,Dt
    REAL*8 Fr(3,3),Jr,Jen,Beprn(3,3),s1n(3),s2n(3),s3n(3),Je,s1(3)
    REAL*8 s2(3),s3(3),S11(3,3),S22(3,3),S33(3,3),S12(3,3),S21(3,3)
    REAL*8 S13(3,3),S31(3,3),S23(3,3),S32(3,3),devH(3,3),HH(3,3)
    REAL*8 alpha1,B,Bepr(3,3),lame1,lame2,lame3,lamea,Ee11,Ee22,Ee33
    REAL*8 Ee12,Eea,devBepr(3,3),QQ,T0(3,3),T1(3,3),T2(3,3),T3(3,3)
    REAL*8 T4(3,3),T5(3,3),TT(3,3)
    INTEGER i1,i2
    
    CALL ElasticDil(Jr,Jh,Dt,Gammam,Jen,Je)
    
    CALL StateVarsIntegrator(hstep,tol,maxitr,Fr,Dt,Gamma,Beprn, &
      & alpha1n,Bn,s1n,s2n,s3n,H1,H2,H12,s1,s2,s3,S11,S22,S33,S12,S21, &
      & devH,HH,B,alpha1,devBepr,Bepr)
      
    CALL ElasticMeasures(Je,Bepr,S11,S22,S33,S12,lame1,lame2,lame3, &
      & lamea,Ee11,Ee22,Ee33,Ee12,Eea)
     
    CALL Constitutive(mu0,kc,kt,k1,k2,k3,k12,ka,q,Je,devBepr,Bepr, &
      & alpha1,S11,S22,S33,S12,S21,lame1,lame2,lame3,lamea,Ee12,Ee11, &
      & Ee22,Ee33,Eea,QQ,T0,T1,T2,T3,T4,T5,TT)
                      
  END SUBROUTINE clooping
      
!   ====================================================================
      
!   Elastic dilatation at t=t2
      
  SUBROUTINE ElasticDil(Jr,Jh,Dt,Gammam,Jen,Je) 
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 Jr,Jh,Dt,Gammam,Jen,Jn,Je,Jes
    
    Jes=Jr*Jen
    Je=dexp((dlog(Jes)+Dt*Gammam*dlog(Jh))/(1+Dt*Gammam))
    
  END SUBROUTINE ElasticDil
      
!   ====================================================================
      
  SUBROUTINE StateVarsIntegrator(hstep,tol,maxitr,Fr,Dt,Gamma, &
    & Beprn,alpha1n,Bn,s1n,s2n,s3n,H1,H2,H12,s1,s2,s3,S11,S22,S33,S12, &
    & S21,devH,HH,B,alpha1,devBepr,Bepr)
    
    IMPLICIT NONE
      
!   Declarations
    REAL*8 hstep,tol,maxitr,Fr(3,3),Beprn(3,3),Dt,Gamma,alpha1n,Bn
    REAL*8 s1n(3),s2n(3),s3n(3),H1,H2,H12,alpha1,B,Bepr(3,3),s1(3)
    REAL*8 s2(3),s3(3),S11(3,3),S22(3,3),S33(3,3),S12(3,3),S21(3,3)
    REAL*8 S13(3,3),S31(3,3),S23(3,3),S32(3,3),devH(3,3),devBepr(3,3)
    REAL*8 HH(3,3),BB(3,3),Frt(3,3),aux(3,3),EyeTens(3,3)
    INTEGER i1,i2
      
    CALL IdentityTens(EyeTens)
    CALL UpdateFibersHomeo(s1n,s2n,s3n,Fr,H1,H2,H12,s1,s2,s3,S11, &
      & S22,S33,S12,S21,S13,S31,S23,S32,devH,HH)     
    CALL alpha1B(hstep,tol,maxitr,Fr,Beprn,Dt,Gamma,devH,HH,alpha1n, &
      & Bn,alpha1,B)       
    CALL deviatorBepr(Fr,Beprn,Dt,Gamma,B,devH,devBepr)
    DO i1=1,3
      DO i2=1,3
        Bepr(i1,i2)=(alpha1/3.0d0)*EyeTens(i1,i2)+devBepr(i1,i2)
      END DO
    END DO
    
  END SUBROUTINE StateVarsIntegrator
  
!   ====================================================================
      
!   Compute the deviatoric part Be''

  SUBROUTINE deviatorBepr(Fr,Beprn,Dt,Gamma,B,devH,devBepr)
      
    IMPLICIT NONE
      
    !   Declarations
    REAL*8 Fr(3,3),Beprn(3,3),Dt,Gamma,B,devH(3,3),devBepr(3,3)
    REAL*8 Beprs(3,3),hydBeprs(3,3),devBeprs(3,3),Frpr(3,3)
    REAL*8 FrprT(3,3),aux(3,3)
    INTEGER i1,i2
    
    CALL MUnimodular(Fr,Frpr)
    CALL TransTens(Frpr,FrprT)
    CALL JuxtaTensTens(Frpr,Beprn,aux)
    CALL JuxtaTensTens(aux,FrprT,Beprs)
    CALL DevTens(Beprs,devBeprs,hydBeprs)
    
    DO i1=1,3
      DO i2=1,3
        devBepr(i1,i2)=(1.0d0/(1.0d0+Dt*Gamma)) & 
          & *(devBeprs(i1,i2)+B*Dt*Gamma*devH(i1,i2))
      END DO
    END DO
    
  END SUBROUTINE deviatorBepr
  
!   ====================================================================
      
!   Updated fibers directions and the homeostatic state
      
  SUBROUTINE UpdateFibersHomeo(s1n,s2n,s3n,Fr,H1,H2,H12,s1,s2,s3, &
    & S11,S22,S33,S12,S21,S13,S31,S23,S32,devH,HH)
    
    IMPLICIT NONE
      
!   Declarations
    REAL*8 s1n(3),s2n(3),s3n(3),Fr(3,3),H1,H2,H12,s1(3),s2(3),s3(3)
    REAL*8 S11(3,3),S22(3,3),S33(3,3),S12(3,3),S21(3,3),S13(3,3)
    REAL*8 S31(3,3),S23(3,3),S32(3,3),devH(3,3),HH(3,3),Frt(3,3)
    REAL*8 invFrt(3,3),EyeTens(3,3),ms1,ms3
    INTEGER i,j
    
    CALL IdentityTens(EyeTens)
    CALL TransTens(Fr,Frt)
    CALL InvTens(Frt,invFrt)
    
    CALL JuxtaTensVec(Fr,s1n,s1)
    ms1=dsqrt(s1(1)**2.0d0+s1(2)**2.0d0+s1(3)**2.0d0)
    s1(1)=s1(1)/ms1
    s1(2)=s1(2)/ms1
    s1(3)=s1(3)/ms1
    
    CALL JuxtaTensVec(invFrt,s3n,s3)
    ms3=dsqrt(s3(1)**2.0d0+s3(2)**2.0d0+s3(3)**2.0d0)
    s3(1)=s3(1)/ms3
    s3(2)=s3(2)/ms3
    s3(3)=s3(3)/ms3
    
    CALL CrossVecVec(s3,s1,s2)
    
    DO i=1,3
      DO j=1,3
        S11(i,j)=s1(i)*s1(j)
        S22(i,j)=s2(i)*s2(j)
        S33(i,j)=s3(i)*s3(j)
        S12(i,j)=s1(i)*s2(j)
        S21(i,j)=s2(i)*s1(j)
        S13(i,j)=s1(i)*s3(j)
        S31(i,j)=s3(i)*s1(j)
        S23(i,j)=s2(i)*s3(j)
        S32(i,j)=s3(i)*s2(j)        
        devH(i,j)=H1*S11(i,j)+H2*S22(i,j)-(H1+H2)*S33(i,j) &
          & +H12*(S12(i,j)+S21(i,j))          
        HH(i,j)=EyeTens(i,j)+devH(i,j)
      END DO
    END DO
    
  END SUBROUTINE UpdateFibersHomeo
  
!   ====================================================================
  
!   Compute the nonlinear function to compute {alpha1, B}
      
  SUBROUTINE nonlinearfuncs(Fr,Beprn,Dt,Gamma,devH,HH,alpha1,B, &
    & devBepr,f1,f2)
    
    IMPLICIT NONE
      
!   Declarations
    REAL*8 Fr(3,3),Beprn(3,3),Dt,Gamma,devH(3,3),HH(3,3),alpha1,B
    REAL*8 devBepr(3,3),Bepr(3,3),invBepr(3,3),EyeTens(3,3),f1,f2
    REAL*8 aux1,aux2,detdevBepr
    INTEGER i1,i2
    
    CALL IdentityTens(EyeTens)
    
    DO i1=1,3
      DO i2=1,3
        Bepr(i1,i2)=(alpha1/3.0d0)*EyeTens(i1,i2)+devBepr(i1,i2)
      END DO
    END DO
    CALL InvTens(Bepr,invBepr)
    CALL DotTensTens(invBepr,HH,aux1)
    f1=B-3.0d0/aux1
    
    CALL DotTensTens(devBepr,devBepr,aux2)
    CALL DetTens(devBepr,detdevBepr)
    f2=(alpha1/3.0d0)**3.0d0-(aux2/2.0d0)*(alpha1/3.0d0) &
      & -(1.0d0-detdevBepr)
    
  END SUBROUTINE nonlinearfuncs
      
!   ====================================================================
      
!   Compute the scalars {alpha1, B}
      
  SUBROUTINE alpha1B(hstep,tol,maxitr,Fr,Beprn,Dt,Gamma,devH,HH, &
    & alpha1n,Bn,alpha1,B)   
    
    IMPLICIT NONE
      
!   Declarations
    REAL*8 hstep,tol,maxitr,Fr(3,3),Beprn(3,3),Dt,Gamma,devH(3,3)
    REAL*8 HH(3,3),alpha1n,Bn,alpha1,B,devBepr(3,3),n,mDvars
    REAL*8 varsn(2),xpertb(2),ff(2),ffp(2),Jacob(2,2),varsnew(2)
    REAL*8 invJ(2,2),invJff(2),Dvars(2),hstepx
    INTEGER i1,i2,i3
      
    n=0.0d0
    mDvars=1.0d0
    alpha1=alpha1n
    B=Bn
    
    DO WHILE ((mDvars.GT.tol).AND.(n.LT.maxitr))
      varsn(1)=alpha1
      varsn(2)=B
      CALL deviatorBepr(Fr,Beprn,Dt,Gamma,varsn(2),devH,devBepr)
      CALL nonlinearfuncs(Fr,Beprn,Dt,Gamma,devH,HH,varsn(1), &
        & varsn(2),devBepr,ff(1),ff(2)) 
      xpertb(1)=varsn(1)
      xpertb(2)=varsn(2)
      DO i2=1,2
        hstepx=MAX(hstep,dabs(hstep*xpertb(i2)))
        xpertb(i2)=xpertb(i2)+hstepx
        CALL deviatorBepr(Fr,Beprn,Dt,Gamma,xpertb(2),devH,devBepr)
        CALL nonlinearfuncs(Fr,Beprn,Dt,Gamma,devH,HH,xpertb(1), &
          & xpertb(2),devBepr,ffp(1),ffp(2))         
        DO i3=1,2
          Jacob(i3,i2)=(ffp(i3)-ff(i3))/hstepx
        END DO
        xpertb(i2)=varsn(i2)
      END DO
      CALL InvTens2by2(Jacob,invJ)
      DO i1=1,2
        invJff(i1)=0.0d0
        DO i2=1,2
          invJff(i1)=invJff(i1)+Jacob(i1,i2)*ff(i2)
        END DO
        varsnew(i1)=varsn(i1)-invJff(i1)
        Dvars(i1)=varsnew(i1)-varsn(i1)
      END DO
      mDvars=dsqrt(Dvars(1)**2.0d0+Dvars(2)**2.0d0)
      n=n+1.0d0 
      alpha1=varsnew(1)
      B=varsnew(2)
      
      WRITE(*,*) mDvars
      WRITE(*,*) ''
      WRITE(*,*) n
      WRITE(*,*) '=========================='
      
    END DO
    
  END SUBROUTINE alpha1B
  
!   ====================================================================
      
!   compute the elastic stretches and strains

  SUBROUTINE ElasticMeasures(Je,Bepr,S11,S22,S33,S12,lame1,lame2, &
    & lame3,lamea,Ee11,Ee22,Ee33,Ee12,Eea)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 Je,Bepr(3,3),Be(3,3),S11(3,3),S22(3,3),S33(3,3),S12(3,3)
    REAL*8 lame1,lame2,lame3,lamea,Ee11,Ee22,Ee33,Ee12,Eea,invBe(3,3)
    REAL*8 aux3
    INTEGER i1,i2
    
    DO i1=1,3
      DO i2=1,3
        Be(i1,i2)=(Je**(2.0d0/3.0d0))*Bepr(i1,i2)
      END DO
    END DO
    
    CALL InvTens(Be,invBe)
    
    CALL DotTensTens(invBe,S11,lame1)
    lame1=lame1**(-0.50d0)
    Ee11=0.50d0*((lame1**2.0d0)-1.0d0)
    
    CALL DotTensTens(invBe,S22,lame2)
    lame2=lame2**(-0.50d0)
    Ee22=0.50d0*((lame2**2.0d0)-1.0d0)
    
    CALL DotTensTens(invBe,S33,lame3)
    lame3=lame3**(-0.50d0)
    Ee33=0.50d0*((lame3**2.0d0)-1.0d0)
    
    CALL DotTensTens(invBe,S12,Ee12)
    Ee12=-0.50d0*lame1*lame2*Ee12
    
    CALL DotTensTens(Be,S33,lamea)
    lamea=Je*(lamea**(-0.50d0))
    Eea=lamea-1.0d0
    
  END SUBROUTINE ElasticMeasures
  
!   ====================================================================
      
!   Constitutive Equations (Cauchy Stresses)
      
  SUBROUTINE Constitutive(mu0,kc,kt,k1,k2,k3,k12,ka,q,Je,devBepr, &
    & Bepr,alpha1,S11,S22,S33,S12,S21,lame1,lame2,lame3,lamea,Ee12, &
    & Ee11,Ee22,Ee33,Eea,QQ,T0,T1,T2,T3,T4,T5,TT)
    
    IMPLICIT NONE
      
!   Declarations
    REAL*8 mu0,kc,kt,k1,k2,k3,k12,ka,q,mu,Je,Bepr(3,3),Be(3,3),alpha1
    REAL*8 S11(3,3),S22(3,3),S33(3,3),S12(3,3),S21(3,3),lame1,lame2
    REAL*8 lame3,lamea,Ee12,Ee11,Ee22,Ee33,Eea,QQ,T0(3,3),T1(3,3)
    REAL*8 T2(3,3),T3(3,3),T4(3,3),T5(3,3),TT(3,3),ktJe,kcJe
    REAL*8 macEe11,macEe22,macEe33,EyeTens(3,3),devBepr(3,3)
    REAL*8 invBe(3,3),invBeS33(3,3),S33invBe(3,3)
    INTEGER i1,i2
    
    CALL IdentityTens(EyeTens)
    CALL MacBrackets(Je-1,ktJe)
    CALL MacBrackets(1-Je,kcJe)
    CALL MacBrackets(Ee11,macEe11)
    CALL MacBrackets(Ee22,macEe22)
    CALL MacBrackets(Ee33,macEe33)
    DO i1=1,3
      DO i2=1,3
        Be(i1,i2)=(Je**(2.0d0/3.0d0))*Bepr(i1,i2)
      END DO
    END DO
    CALL InvTens(Be,invBe)
    CALL JuxtaTensTens(invBe,S33,invBeS33)
    CALL JuxtaTensTens(S33,invBe,S33invBe)
    
    QQ=0.50d0*kt*(ktJe**2.0d0)+0.50d0*kc*(kcJe**2.0d0) &
      & +0.50d0*(alpha1-3.0d0)+0.50d0*k1*(macEe11**2.0d0) &
      & +0.50d0*k2*(macEe22**2.0d0)+0.50d0*k3*(macEe33**2.0d0) &
      & +2.0d0*k12*(Ee12**2.0d0)+0.50d0*ka*(Eea**2.0d0) 
    
    mu=mu0*dexp(q*QQ)
    DO i1=1,3
      DO i2=1,3
        T0(i1,i2)=mu*(kt*ktJe-kc*kcJe)*EyeTens(i1,i2) &
          & +(mu/Je)*devBepr(i1,i2)
        T1(i1,i2)=((k1*mu*(lame1**2.0d0)*macEe11)/Je)*S11(i1,i2)
        T2(i1,i2)=((k2*mu*(lame2**2.0d0)*macEe22)/Je) & 
          & *(S22(i1,i2)-(2.0d0*lame2/lame1) &
          & *Ee12*(S12(i1,i2)+S21(i1,i2)))
        T3(i1,i2)=((k3*mu*(lame3**2.0d0)*macEe33)/Je) &
          & *((lame3**2.0d0)*(invBeS33(i1,i2)+S33invBe(i1,i2)) &
          & -S33(i1,i2))
        T4(i1,i2)=2.0d0*mu*k12*Ee12*(lame2/lame1/Je) &
          & *(1.0d0-4.0d0*(Ee12**2.0d0)) &
          & *(S12(i1,i2)+S21(i1,i2))
        T5(i1,i2)=(mu*ka*Eea*lamea/Je)*(S11(i1,i2)+S22(i1,i2))
        TT(i1,i2)=T0(i1,i2)+T1(i1,i2)+T2(i1,i2)+T3(i1,i2)+T4(i1,i2) &
          & +T5(i1,i2)
      END DO
    END DO
    
  END SUBROUTINE Constitutive
      
!   ====================================================================
      
  SUBROUTINE umat(ntens,nstatv,nprops,kstep,kinc,dfgrd0,dfgrd1,dtime,stress,statev,ddsdde,props)
    
!  SUBROUTINE umat(stress,statev,ddsdde,sse,spd,scd,rpl,ddsddt, &
!    & drplde,drpldt,stran,dstran,time,dtime,temp,dtemp,predef,dpred, &
!    & materl,ndi,nshr,ntens,nstatv,props,nprops,coords,drot,pnewdt, &
!    & celent,dfgrd0,dfgrd1,noel,npt,kslay,kspt,kstep,kinc)
    
    !include 'aba_param.inc'
    
    CHARACTER*8 materl
    INTEGER ntens,nstatv,nprops
    INTEGER ndi,nshr,noel,npt,kslay,kspt,kstep,kinc
    REAL*8 sse,spd,scd,rpl,drpldt,dtime,temp,dtemp,pnewdt,celent
    REAL*8 stress(ntens),statev(nstatv),ddsdde(ntens,ntens), &
      & ddsddt(ntens),drplde(ntens),stran(ntens),dstran(ntens), &
      & dfgrd0(3,3),dfgrd1(3,3),time(2),predef(1),dpred(1), &
      & props(nprops),coords(3),drot(3,3)
    
    REAL*8 EyeTens(3,3),Dt,K,mu,a0,b0,a1,b1,m,kappas,Jn,kappan
    REAL*8 Beprn(3,3),Fr(3,3),J,Beprs(3,3),devBeprs(3,3),games,game
    REAL*8 Br(3,3),Deps,DtGam0,DtGam1,c0,c1,c2,gam,GAMMA
    REAL*8 devBepr(3,3),alpha1,Bepr(3,3),kappa,T(3,3),dJdFrFrT(3,3)
    REAL*8 ddevBeprsdFrFrT(3,3,3,3),dgamesdFrFrT(3,3)
    REAL*8 dDepsdFrFrT(3,3),dDtGam0dFrFrT(3,3),dDtGam1dFrFrT(3,3)
    REAL*8 dgamdFrFrT(3,3),dc0dFrFrT(3,3),dc1dFrFrT(3,3)
    REAL*8 dc2dFrFrT(3,3),dDtGAMdFrFrT(3,3),ddevBeprdFrFrT(3,3,3,3)
    REAL*8 tanmat(3,3,3,3)
    REAL*8 Ft1(3,3),Ft2(3,3),invFt1(3,3)
   
    INTEGER ii1,ii2,ii3,ii4

    INTEGER ind11(6),ind21(6)
    DATA    ind11/1,2,3,1,1,2/
    DATA    ind21/1,2,3,2,3,3/
    INTEGER i1,i2
      
    CALL IdentityTens(EyeTens)

!   -------------------     
!   Material constants
!   -------------------
    K=props(1)
    mu=props(2)
    a0=props(3)
    a1=props(4)
    b0=props(5)
    b1=props(6)
    m=props(7)
    kappas=props(8)
    
!   ----------------------------------------------
!   Set the initial values of the state variables
!   ----------------------------------------------
    IF ((kstep.EQ.1).AND.(kinc.EQ.1)) THEN
      statev(1)=1.0d0
      statev(2)=1.0d0
      statev(3)=1.0d0
      statev(4)=1.0d0
      statev(5)=0.0d0
      statev(6)=0.0d0
      statev(7)=0.0d0
      statev(8)=0.010d0        
      statev(9)=0.0d0
      statev(10)=0.0d0
      statev(11)=0.0d0
      statev(12)=statev(2)+statev(3)+statev(4)
      statev(13)=0.0d0
    END IF
    
!   ------------------------------------------
!   Get the old values of the state variables
!   ------------------------------------------      
    Jn=statev(1)
    Beprn(1,1)=statev(2)
    Beprn(2,2)=statev(3)
    Beprn(3,3)=statev(4)
    Beprn(1,2)=statev(5)
    Beprn(2,3)=statev(6)
    Beprn(1,3)=statev(7)
    kappan=statev(8)
    games=statev(9)
    Deps=statev(10)
    GAMMA=statev(11)
    alpha1=statev(12)
    game=statev(13)
    
    Beprn(2,1)=Beprn(1,2)
    Beprn(3,2)=Beprn(2,3)
    Beprn(3,1)=Beprn(1,3)
    
!   -----------------------------------------
!   Time step; Relative deformation gradient
!   -----------------------------------------
    Dt=dtime
    
    DO i1=1,3
      DO i2=1,3
!           <Ft1=F(t1)>
        Ft1(i1,i2)=dfgrd0(i1,i2)
!           <Ft2=F(t2)>
        Ft2(i1,i2)=dfgrd1(i1,i2)
      END DO
    END DO
      
    CALL InvTens(Ft1,invFt1)
    CALL JuxtaTensTens(Ft2,invFt1,Fr)
    
!   -------------------------------------------------------------------------------------------
!   Calculate the updated values of the state variables, stresses, and Spatial-Tangent Modulus
!   -------------------------------------------------------------------------------------------     
    CALL SmoothMultiPhase(Dt,K,mu,a0,b0,a1,b1,m,kappas,Jn,Beprn, &
      & kappan,Fr,J,Beprs,devBeprs,games,Br,Deps,DtGam0,DtGam1,c0,c1,c2, &
      & gam,GAMMA,devBepr,alpha1,Bepr,kappa,T,dJdFrFrT,ddevBeprsdFrFrT, &
      & dgamesdFrFrT,dDepsdFrFrT,dDtGam0dFrFrT,dDtGam1dFrFrT,dc0dFrFrT, &
      & dc1dFrFrT,dc2dFrFrT,dgamdFrFrT,dDtGAMdFrFrT,ddevBeprdFrFrT, &
      & tanmat)     
      
!   --------------------------- 
!   Update the state variables
!   ---------------------------
    statev(1)=J
    statev(2)=Bepr(1,1)
    statev(3)=Bepr(2,2)
    statev(4)=Bepr(3,3)
    statev(5)=Bepr(1,2)
    statev(6)=Bepr(2,3)
    statev(7)=Bepr(1,3)
    statev(8)=kappa
!      
    statev(9)=games
    statev(10)=Deps
    statev(11)=GAMMA
    statev(12)=alpha1      
    CALL EquivStrain(devBepr,game)
    statev(13)=game   
    
!   ------------------------------------------------
!   Update the Stresses and Spatial-Tangent Modulus
!   ------------------------------------------------
    IF (ntens.EQ.6) THEN
!       !   
!       ! 3D Problem 
!       !
      DO i1=1,6
        ii1=ind11(i1)
        ii2=ind21(i1)
        stress(i1)=T(ii1,ii2)
        DO i2=1,6
          ii3=ind11(i2)
          ii4=ind21(i2)
          ddsdde(i1,i2)=tanmat(ii1,ii2,ii3,ii4)
        END DO ! i2
      END DO ! i1
      
    ELSE IF (ntens.EQ.4) THEN
!       !
!       ! Axisymmetric Problem
!       !
      stress(1)=T(1,1) 
      stress(2)=T(2,2) 
      stress(3)=T(1,2) 
      stress(4)=T(3,3)        
      
      ddsdde(1,1)=tanmat(1,1,1,1)
      ddsdde(1,2)=tanmat(1,1,2,2)
      ddsdde(1,3)=tanmat(1,1,1,2)
      ddsdde(1,4)=tanmat(1,1,3,3)
      
      ddsdde(2,1)=tanmat(2,2,1,1)
      ddsdde(2,2)=tanmat(2,2,2,2)
      ddsdde(2,3)=tanmat(2,2,1,2)
      ddsdde(2,4)=tanmat(2,2,3,3)
        
      ddsdde(3,1)=tanmat(1,2,1,1)
      ddsdde(3,2)=tanmat(1,2,2,2)
      ddsdde(3,3)=tanmat(1,2,1,2)
      ddsdde(3,4)=tanmat(1,2,3,3)
        
      ddsdde(4,1)=tanmat(3,3,1,1)
      ddsdde(4,2)=tanmat(3,3,2,2)
      ddsdde(4,3)=tanmat(3,3,1,2)
      ddsdde(4,4)=tanmat(3,3,3,3)
        
    ELSE IF (ntens.EQ.3) THEN
!       !   
!       ! 2D Problem
!       !
      stress(1)=T(1,1) 
      stress(2)=T(2,2) 
      stress(3)=T(1,2)        
      
      ddsdde(1,1)=tanmat(1,1,1,1)
      ddsdde(1,2)=tanmat(1,1,2,2)
      ddsdde(1,3)=tanmat(1,1,1,2)
      
      ddsdde(2,1)=tanmat(2,2,1,1)
      ddsdde(2,2)=tanmat(2,2,2,2)
      ddsdde(2,3)=tanmat(2,2,1,2)
      
      ddsdde(3,1)=tanmat(1,2,1,1)
      ddsdde(3,2)=tanmat(1,2,2,2)
      ddsdde(3,3)=tanmat(1,2,1,2)
      
    END IF
      
    RETURN
  END SUBROUTINE umat

!   ***************************************************************************
!   ***************************************************************************  
            
!   ================
!   Main Subroutine
!   ================
           
  SUBROUTINE SmoothMultiPhase(Dt,K,mu,a0,b0,a1,b1,m,kappas,Jn, &
    & Beprn,kappan,Fr,J,Beprs,devBeprs,games,Br,Deps,DtGam0, &
    & DtGam1,c0,c1,c2,gam,GAMMA,devBepr,alpha1,Bepr,kappa,T,dJdFrFrT, &
    & ddevBeprsdFrFrT,dgamesdFrFrT,dDepsdFrFrT,dDtGam0dFrFrT, &
    & dDtGam1dFrFrT,dc0dFrFrT,dc1dFrFrT,dc2dFrFrT,dgamdFrFrT, &
    & dDtGAMdFrFrT,ddevBeprdFrFrT,tanmat)
      
    IMPLICIT NONE
      
    REAL*8 EyeTens(3,3),Dt,K,mu,a0,b0,a1,b1,m,kappas,Jn,kappan
    REAL*8 Beprn(3,3),Fr(3,3),FrT(3,3),Frpr(3,3),Jr,J,Beprs(3,3)
    REAL*8 devBeprs(3,3),hydBeprs(3,3),devgeprs(3,3),games
    REAL*8 Dbar(3,3),Br(3,3),Deps,DtGam0,DtGam1,c0,c1,c2,gam
    REAL*8 GAMMA,devBepr(3,3),devgepr(3,3),alpha1,Bepr(3,3)
    REAL*8 kappa,p,devT(3,3),T(3,3),dJdFrFrT(3,3),dgamesdFrFrT(3,3)
    REAL*8 ddevBeprsdFrFrT(3,3,3,3),dDepsdFrFrT(3,3)
    REAL*8 dDtGam0dFrFrT(3,3),dDtGam1dFrFrT(3,3),dgamdFrFrT(3,3)
    REAL*8 dc0dFrFrT(3,3),dc1dFrFrT(3,3),dc2dFrFrT(3,3)
    REAL*8 dDtGAMdFrFrT(3,3),ddevBeprdFrFrT(3,3,3,3),tanmat(3,3,3,3)
    INTEGER i1,i2
      
    CALL IdentityTens(EyeTens)
    CALL DetTens(Fr,Jr)
    J=Jr*Jn
    
    CALL MUnimodular(Fr,Frpr)
    CALL ElasticTrialDist(Frpr,Beprn,Beprs)
    CALL DevTens(Beprs,devBeprs,hydBeprs) 
    DO i1=1,3
      DO i2=1,3
        devgeprs(i1,i2)=0.50d0*devBeprs(i1,i2)
      END DO
    END DO
    
    CALL EquivStrain(devBeprs,games)
    
    CALL TransTens(Fr,FrT)
    CALL JuxtaTensTens(Fr,FrT,Br)
    DO i1=1,3
      DO i2=1,3
        Dbar(i1,i2)=0.50d0/Dt*(Br(i1,i2)-EyeTens(i1,i2))
      END DO
    END DO
    CALL EffDistStrain(Dbar,Dt,Deps) 
    
    CALL DeltatGamma(a0,a1,b0,b1,m,kappas,Dt,kappan,games,Deps, &
      & DtGam0,DtGam1,c0,c1,c2,gam,GAMMA)
    
    CALL Beprpr(devgeprs,Dt,GAMMA,devBepr)
    DO i1=1,3
      DO i2=1,3
        devgepr(i1,i2)=0.50d0*devBepr(i1,i2)
      END DO
    END DO
    CALL OneThirdAlpha(devBepr,alpha1)
    CALL Beprime(devBepr,alpha1,Bepr)
    
    CALL CauchyStress(K,mu,J,devgepr,p,devT,T)      
    CALL hardening(kappan,kappas,m,gam,kappa)
    
    CALL Tangent(K,mu,a0,a1,b0,b1,m,Dt,kappas,kappan,DtGam0, &
      & DtGam1,c0,c1,c2,gam,GAMMA,Fr,J,Beprs,devBeprs,games,devBepr, &
      & Deps,T,dJdFrFrT,ddevBeprsdFrFrT,dgamesdFrFrT,dDepsdFrFrT, &
      & dDtGam0dFrFrT,dDtGam1dFrFrT,dc0dFrFrT,dc1dFrFrT,dc2dFrFrT, &
      & dgamdFrFrT,dDtGAMdFrFrT,ddevBeprdFrFrT,tanmat)
    
    RETURN
  END SUBROUTINE SmoothMultiPhase
            
!   ===========================
!   DISTORTIONAL ELASTIC TRIAL
!   ===========================
      
!   Compute the elastic trial value Be'* of Be'    
     
  SUBROUTINE ElasticTrialDist(Frpr,Beprn,Bepret)
    
    IMPLICIT NONE
    
!   Declarations
    REAL*8 Frpr(3,3),FrprT(3,3),Beprn(3,3),aux(3,3),Bepret(3,3)     
    
    CALL TransTens(Frpr,FrprT)
    CALL JuxtaTensTens(Frpr,Beprn,aux)
    CALL JuxtaTensTens(aux,FrprT,Bepret)
    
    RETURN
  END SUBROUTINE ElasticTrialDist
  
!   ==========================
!   EQUIVALENT STRAIN gamma_e
!   ==========================
      
  SUBROUTINE EquivStrain(devBepr,game)
    
    IMPLICIT NONE
    
!   Declarations
    REAL*8 devBepr(3,3),game
      
    CALL DotTensTens(devBepr,devBepr,game)
    game=dsqrt((3.0d0/8.0d0)*game)
    
    RETURN
  END SUBROUTINE EquivStrain
  
!   ================================================
!   EFFECTIVE TOTAL DISTORTIONAL DEFORMATION D(eps)
!   ================================================
      
  SUBROUTINE EffDistStrain(Dbar,Dt,Deps)
      
    IMPLICIT NONE
    
!   Declarations
    REAL*8 Dbar(3,3),Dt,Deps,devDbar(3,3),hydDbar(3,3)
      
    CALL DevTens(Dbar,devDbar,hydDbar)
    CALL DotTensTens(devDbar,devDbar,Deps)
    Deps=Dt*dsqrt(2.0d0/3.0d0*Deps)
    
    RETURN
  END SUBROUTINE EffDistStrain
            
!   ============================
!   Deviatoric part Be'' of Be'
!   ============================
      
  SUBROUTINE Beprpr(devgeprs,Dt,GAMMA,devBepr)
    
    IMPLICIT NONE
    
!   Declarations
    REAL*8 Dt,GAMMA,devgeprs(3,3),devBepr(3,3),fac1
    INTEGER i1,i2
    
    fac1=2.0d0/(1.0d0+(Dt*GAMMA))
    
    DO i1=1,3
      DO i2=1,3
        devBepr(i1,i2)=fac1*devgeprs(i1,i2)
      END DO
    END DO
      
    RETURN
  END SUBROUTINE Beprpr
            
!   ======================================
!   FIRST NON-TRIVIAL INVARIANT (alpha_1)
!   ======================================
      
!   Calculate alpha=trace(Bepr) by solving a quadratic equation
      
  SUBROUTINE OneThirdAlpha(devBepr,alpha1)
    
    IMPLICIT NONE
    
!   Declarations
    REAL*8 devBepr(3,3),alpha1
    REAL*8 fac1,fac2,detdevBepr,dotprod
    
    CALL DetTens(devBepr,detdevBepr)
    CALL DotTensTens(devBepr,devBepr,dotprod)
      
    fac1=2.0d0*dotprod/3.0d0
    IF (fac1.EQ.0.0d0) THEN
      alpha1=3.0d0
    ELSE
      fac2=(4.0d0*(1.0d0-detdevBepr))/(fac1**1.5d0)
      IF (fac2.GE.1.0d0) THEN
        alpha1=3.0d0*dsqrt(fac1)*dcosh(dacosh(fac2)/3.0d0)
      ELSE
        alpha1=3.0d0*dsqrt(fac1)*dcos(dacos(fac2)/3.0d0)
      END IF
    END IF
    
    RETURN
  END SUBROUTINE OneThirdAlpha
            
!   =========================
!   ELASTIC DISTORTION (Be')
!   =========================
      
  SUBROUTINE Beprime(devBepr,alpha1,Bepr)
      
    IMPLICIT NONE

!   Declarations
    REAL*8 EyeTens(3,3),devBepr(3,3),alpha1,Bepr(3,3)
    INTEGER i1,i2
    
    CALL IdentityTens(EyeTens)
    DO i1=1,3
      DO i2=1,3
        Bepr(i1,i2)=alpha1/3.0d0*EyeTens(i1,i2)+devBepr(i1,i2)
      END DO
    END DO
    
    RETURN
  END SUBROUTINE Beprime
  
!   ======================================
!   AUXILIARY VARIABLES (gamma and GAMMA)
!   ======================================
      
  SUBROUTINE DeltatGamma(a0,a1,b0,b1,m,kappas,Dt,kappan,games, &
    & Deps,DtGam0,DtGam1,c0,c1,c2,gam,GAMMA)
      
    IMPLICIT NONE
    
!   Declarations
    REAL*8 a0,a1,b0,b1,Dt,games,kappan,gam,GAMMA,DtGam0,DtGam1
    REAL*8 c0,c1,c2,Deps,m,kappas
    
    DtGam0=Dt*a0+b0*Deps
    DtGam1=Dt*a1+b1*Deps  
    c0=DtGam1*(games-(1.0d0+DtGam0)*kappan)
    
    IF (c0.LE.0.0d0) THEN
      gam=0.0d0
    ELSE
      c1=games+DtGam1*(kappan-m*(games-(1+DtGam0)*kappas))
      IF (m.EQ.0.0d0) THEN
        gam=c0/c1
      ELSE
        c2=m*(games+DtGam1*kappas)
        gam=(-c1+dsqrt(c1**2.0d0+4.0d0*c0*c2))/2.0d0/c2
      END IF
    END IF
      
    GAMMA=DtGam0/Dt+gam/Dt
      
    RETURN
  END SUBROUTINE DeltatGamma
            
!   =====================
!   CAUCHY STRESS TENSOR
!   =====================
      
  SUBROUTINE CauchyStress(K,mu,J,devgepr,p,devT,T)
    
    IMPLICIT NONE
      
!   Declarations
    REAL*8 K,mu,J,devgepr(3,3),p,devT(3,3),T(3,3)
    REAL*8 EyeTens(3,3)
    INTEGER i1,i2
      
    CALL IdentityTens(EyeTens)
      
    p=-K*(J-1.0d0)
    DO i1=1,3
      DO i2=1,3
        devT(i1,i2)=2.0d0*mu*devgepr(i1,i2)/J
        T(i1,i2)=-p*EyeTens(i1,i2)+devT(i1,i2)
      END DO
    END DO
      
    RETURN
  END SUBROUTINE CauchyStress
            
!   ===================
!   HARDENING VARIABLE
!   ===================
      
  SUBROUTINE hardening(kappan,kappas,m,gam,kappa)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 kappan,kappas,m,gam,kappa
    
    kappa=(kappan+m*kappas*gam)/(1.0d0+m*gam)
    
    RETURN
  END SUBROUTINE hardening
  
!   =======================
!   SPATIAL TANGENT MODULI
!   =======================
      
  SUBROUTINE Tangent(K,mu,a0,a1,b0,b1,m,Dt,kappas,kappan,DtGam0, &
    & DtGam1,c0,c1,c2,gam,GAMMA,Fr,J,Beprs,devBeprs,games,devBepr, &
    & Deps,T,dJdFrFrT,ddevBeprsdFrFrT,dgamesdFrFrT,dDepsdFrFrT, &
    & dDtGam0dFrFrT,dDtGam1dFrFrT,dc0dFrFrT,dc1dFrFrT,dc2dFrFrT, &
    & dgamdFrFrT,dDtGAMdFrFrT,ddevBeprdFrFrT,tanmat)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 EyeTens(3,3),K,mu,a0,a1,b0,b1,m,Dt,kappas,kappan
    REAL*8 DtGam0,DtGam1,c0,c1,c2,gam,GAMMA,Fr(3,3),J,Beprs(3,3)
    REAL*8 devBeprs(3,3),games,devBepr(3,3),Deps,ex(3,3),hx(3,3)
    REAL*8 Frt(3,3),Br(3,3),T(3,3),devBr(3,3),dJdFrFrT(3,3)
    REAL*8 ddevBeprsdFrFrT(3,3,3,3),dgamesdFrFrT(3,3)
    REAL*8 dDepsdFrFrT(3,3),dDtGam0dFrFrT(3,3),dDtGam1dFrFrT(3,3)
    REAL*8 cf0,dc0dFrFrT(3,3),cf1,dc1dFrFrT(3,3),dc2dFrFrT(3,3)
    REAL*8 dgamdFrFrT(3,3),dDtGAMdFrFrT(3,3),ddevBeprdFrFrT(3,3,3,3)
    REAL*8 cft1,cft2,tanmat(3,3,3,3)
    INTEGER i1,i2,i3,i4
    
    
    CALL IdentityTens(EyeTens)
    CALL JuxtaTensTens(devBeprs,Beprs,ex)
    CALL DevTens(ex,dgamesdFrFrT,hx)
    CALL TransTens(Fr,Frt)
    CALL JuxtaTensTens(Fr,Frt,Br)
    CALL DevTens(Br,devBr,hx)
    CALL JuxtaTensTens(devBr,Br,dDepsdFrFrT)
    
!     calculate diff(J,Fr)*Fr^T     
    DO i1=1,3
      DO i2=1,3
        dJdFrFrT(i1,i2)=J*EyeTens(i1,i2)
      END DO
    END DO
      
!     calculate diff(gammae*,Fr)*Fr^T     
    DO i1=1,3
      DO i2=1,3
        dgamesdFrFrT(i1,i2)=3.0d0/4.0d0/games*dgamesdFrFrT(i1,i2)
      END DO
    END DO
      
!     calculate diff(Depsilon,Fr)*Fr^T 
    DO i1=1,3
      DO i2=1,3
        dDepsdFrFrT(i1,i2)=1.0d0/3.0d0/Deps*dDepsdFrFrT(i1,i2)
      END DO
    END DO
    
!     calculate diff(Dt*Gamma0,Fr)*Fr^T      
    DO i1=1,3
      DO i2=1,3
        dDtGam0dFrFrT(i1,i2)=b0*dDepsdFrFrT(i1,i2)
      END DO
    END DO
      
!     calculate diff(Dt*Gamma1,Fr)*Fr^T   
    DO i1=1,3
      DO i2=1,3
        dDtGam1dFrFrT(i1,i2)=b1*dDepsdFrFrT(i1,i2)
      END DO
    END DO
    
!     calculate diff(gamma,Fr)*Fr^T   
    cf0=games-(1.0d0+DtGam0)*kappan
    cf1=kappan-m*(games-(1.0d0+DtGam0)*kappas)
    DO i1=1,3
      DO i2=1,3
        IF (c0.LE.0.0d0) THEN
          dgamdFrFrT(i1,i2)=0.0d0
        ELSE
          dc0dFrFrT(i1,i2)=cf0*dDtGam1dFrFrT(i1,i2) & 
            & +DtGam1*(dgamesdFrFrT(i1,i2)-kappan*dDtGam0dFrFrT(i1,i2))
          dc1dFrFrT(i1,i2)=(1.0d0-m*DtGam1)*dgamesdFrFrT(i1,i2) &
            & +m*kappas*DtGam1*dDtGam0dFrFrT(i1,i2) &
            & +cf1*dDtGam1dFrFrT(i1,i2)
          dc2dFrFrT(i1,i2)=m*(dgamesdFrFrT(i1,i2) &
            & +kappas*dDtGam1dFrFrT(i1,i2))
          IF (m.EQ.0.0d0) THEN
            dgamdFrFrT(i1,i2)=(1.0d0/c1)*(dc0dFrFrT(i1,i2) &
              & -gam*dc1dFrFrT(i1,i2))
          ELSE
            dgamdFrFrT(i1,i2)=(gam/(2.0d0*c0-c1*gam)) &
              &  *(dc0dFrFrT(i1,i2)-gam*dc1dFrFrT(i1,i2) &
              &  -(gam**2.0d0)*dc2dFrFrT(i1,i2))
          END IF
          dDtGAMdFrFrT(i1,i2)=dDtGam0dFrFrT(i1,i2)+dgamdFrFrT(i1,i2)
        END IF
      END DO
    END DO
      
!     calculate diff(Be''*,Fr)*Fr^T         
    DO i1=1,3
      DO i2=1,3
        DO i3=1,3
          DO i4=1,3
            ddevBeprsdFrFrT(i1,i2,i3,i4)= &
              & EyeTens(i1,i3)*Beprs(i2,i4) &
              & +Beprs(i1,i4)*EyeTens(i2,i3) &
              & -(2.0d0/3.0d0)*Beprs(i1,i2)*EyeTens(i3,i4) &
              & -(2.0d0/3.0d0)*EyeTens(i1,i2)*devBeprs(i3,i4)
          END DO
        END DO
      END DO
    END DO
      
!     calculate diff(Be'',Fr)*Fr^T      
    DO i1=1,3
      DO i2=1,3
        DO i3=1,3
          DO i4=1,3
            ddevBeprdFrFrT(i1,i2,i3,i4)=(1.0d0/(1.0d0+Dt*GAMMA))* &
              & (ddevBeprsdFrFrT(i1,i2,i3,i4)-devBepr(i1,i2)* &
              & dDtGAMdFrFrT(i3,i4))
          END DO
        END DO
      END DO
    END DO

!     calculate the spatial tangent moduli     
    cft1=K/J*(2*J-1.0d0)
    cft2=mu/J
    DO i1=1,3
      DO i2=1,3
        DO i3=1,3
          DO i4=1,3
            tanmat(i1,i2,i3,i4)=cft1*EyeTens(i1,i2)*dJdFrFrT(i3,i4) &
              & +cft2*ddevBeprdFrFrT(i1,i2,i3,i4) &
              & -T(i1,i4)*EyeTens(i2,i3)
          END DO
        END DO
      END DO
    END DO
      
    RETURN
  END SUBROUTINE Tangent

!   ***************************************************************************
!   ***************************************************************************  
      
!   Juxtaposition of a 3x3 tensor and a 3x1 vector
!   Also holds for a Dot Product between a 2nd order tensor and a vector
      
  SUBROUTINE JuxtaTensVec(A,v,Av)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 A(3,3),v(3),Av(3)
    INTEGER i,j
    
    DO i=1,3
      Av(i)=0.0d0
      DO j=1,3
        Av(i)=Av(i)+A(i,j)*v(j)
      END DO
    END DO
    
    RETURN
  END SUBROUTINE JuxtaTensVec
      
!   ====================================================================
      
!   Juxtaposition between two 2nd order tensors
      
  SUBROUTINE JuxtaTensTens(A,B,AB)
    
    IMPLICIT NONE
    
!   Declarations
    REAL*8 A(3,3),B(3,3),AB(3,3)
    INTEGER i,j,k

    DO i=1,3
      DO j=1,3        
        AB(i,j)=0.0d0
        DO k=1,3
          AB(i,j)=AB(i,j)+A(i,k)*B(k,j)
        END DO
      END DO
    END DO
    
    RETURN
  END SUBROUTINE JuxtaTensTens
  
!   ====================================================================
      
!   Transpose of a 2nd order tensor
      
  SUBROUTINE TransTens(A,At)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 A(3,3),At(3,3)
    INTEGER i,j
    
    DO i=1,3
      DO j=1,3
        At(i,j)=A(j,i)
      END DO
    END DO
    
    RETURN
  END SUBROUTINE TransTens
      
!   ====================================================================
      
!   Determinant of a 2nd order tensor
      
  SUBROUTINE DetTens(A,detA)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 A(3,3),A2(3,3),A3(3,3),detA,trA,trA2,trA3
    
    CALL JuxtaTensTens(A,A,A2)
    CALL JuxtaTensTens(A,A2,A3)
    
    CALL TraceTens(A,trA)
    CALL TraceTens(A2,trA2)
    CALL TraceTens(A3,trA3)
    
    detA=1.0d0/3.0d0*(trA3-trA*trA2+0.50d0*(trA**2.0d0-trA2)*trA)
    
    RETURN
  END SUBROUTINE DetTens
  
!   ====================================================================           
      
!   Trace of a 2nd order tensor
      
  SUBROUTINE TraceTens(A,trA)
    
    IMPLICIT NONE

!   Declarations
    REAL*8 A(3,3)
    REAL*8 trA
    
    trA=A(1,1)+A(2,2)+A(3,3)
    
    RETURN
  END SUBROUTINE TraceTens
  
!   ====================================================================    
      
!   Inverse of a 2nd order tensor
      
  SUBROUTINE InvTens(A,invA)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 EyeTens(3,3),A(3,3),detA,I11,A2(3,3),trA2,I22,invA(3,3)
    INTEGER i1,i2
    
    CALL IdentityTens(EyeTens)
    CALL DetTens(A,detA)   
    I11=A(1,1)+A(2,2)+A(3,3)      
    CALL JuxtaTensTens(A,A,A2)
    trA2=A2(1,1)+A2(2,2)+A2(3,3)
    I22=0.50d0*(I11**2.0d0-trA2)
    
    DO i1=1,3
      DO i2=1,3
        invA(i1,i2)=1.0d0/detA*(A2(i1,i2)-I11*A(i1,i2) &
          & +I22*EyeTens(i1,i2))
      END DO
    END DO
    
    RETURN
  END SUBROUTINE InvTens
  
!   ====================================================================
      
!   Dot Product between two 2nd order tensors
      
  SUBROUTINE DotTensTens(A,B,AdotB)
      
    IMPLICIT NONE
    
!   Declarations
    REAL*8 A(3,3),B(3,3),Bt(3,3),ABt(3,3)
    REAL*8 trABt,AdotB
    
    CALL TransTens(B,Bt)
    CALL JuxtaTensTens(A,Bt,ABt)
    CALL TraceTens(ABt,trABt)
    
    AdotB=trABt
    
    RETURN
  END SUBROUTINE DotTensTens
      
!   ====================================================================
      
!   2nd order identity tensor
      
  SUBROUTINE IdentityTens(EyeTens)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 EyeTens(3,3)
      
    EyeTens(1,1)=1.0d0
    EyeTens(1,2)=0.0d0
    EyeTens(1,3)=0.0d0
    EyeTens(2,1)=0.0d0
    EyeTens(2,2)=1.0d0
    EyeTens(2,3)=0.0d0
    EyeTens(3,1)=0.0d0
    EyeTens(3,2)=0.0d0
    EyeTens(3,3)=1.0d0
    
    RETURN
  END SUBROUTINE IdentityTens
      
!   ====================================================================
      
!   2nd order sparse tensor
      
  SUBROUTINE ZeroTens(zero3)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 zero3(3,3)
    
    zero3(1,1)=0.0d0
    zero3(1,2)=0.0d0
    zero3(1,3)=0.0d0
    zero3(2,1)=0.0d0
    zero3(2,2)=0.0d0
    zero3(2,3)=0.0d0
    zero3(3,1)=0.0d0
    zero3(3,2)=0.0d0
    zero3(3,3)=0.0d0
      
    RETURN
  END SUBROUTINE ZeroTens
      
!   ====================================================================
      
!   Deviator of a 2nd order tensor
      
  SUBROUTINE DevTens(A,devA,hydA)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 A(3,3),devA(3,3),EyeTens(3,3),hydA(3,3)
    REAL*8 p,trA
    INTEGER i,j
    
    CALL TraceTens(A,trA)
    p=-trA/3.0d0
    CALL IdentityTens(EyeTens)
    
    DO i=1,3
      DO j=1,3
        hydA(i,j)=-p*EyeTens(i,j)
        devA(i,j)=A(i,j)-hydA(i,j)
      END DO
    END DO
      
    RETURN
  END SUBROUTINE DevTens
      
!   ====================================================================
      
!   Unimodular 2nd order tensor
      
  SUBROUTINE MUnimodular(A,Apr)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 A(3,3),Apr(3,3)
    REAL*8 detA,power,fac
    INTEGER i,j
    power=-1.0d0/3.0d0
    
    CALL DetTens(A,detA)
    
    DO i=1,3
      DO j=1,3
        Apr(i,j)=SIGN(dabs(detA)**power, detA)*A(i,j) 
      END DO
    END DO
      
!       do i=1,3
!         do j=1,3
!           Apr(i,j)=fac*A(i,j)
!         enddo
!       enddo  
      
    RETURN
  END SUBROUTINE MUnimodular
      
!   ====================================================================
      
!   Cross Product between two vectors
      
  SUBROUTINE CrossVecVec(a,b,axb)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 a(3),b(3),axb(3)
      
    axb(1)=a(2)*b(3)-a(3)*b(2)
    axb(2)=a(3)*b(1)-a(1)*b(3)
    axb(3)=a(1)*b(2)-a(2)*b(1)
    
    RETURN
  END SUBROUTINE CrossVecVec
      
!   ====================================================================
      
!   Dot Product between two vectors
      
  SUBROUTINE DotVecVec(a,b,adotb)
      
    IMPLICIT NONE
      
    REAL*8 a(3),b(3)
    REAL*8 adotb
      
    adotb=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
    
    RETURN
  END SUBROUTINE DotVecVec
      
!   ====================================================================
      
!   Tensor Product between two vectors
      
  SUBROUTINE TensProd(a,b,aoxb)
      
    IMPLICIT NONE
      
    REAL*8 a(3),b(3),aoxb(3,3)
    INTEGER i,j
      
    DO i=1,3
      DO j=1,3
        aoxb(i,j)=a(i)*b(j)
      END DO
    END DO
    
    RETURN
  END SUBROUTINE TensProd
      
!   ====================================================================
      
!   Tensor Product berween two 2nd order tensors

  SUBROUTINE TensProd33(A,B,AoxB)
      
    IMPLICIT NONE
      
    REAL*8 A(3,3),B(3,3),AoxB(3,3,3,3)
    INTEGER i,j,m,n
    
    DO i=1,3
      DO j=1,3
        DO m=1,3
          DO n=1,3
            AoxB(i,j,m,n)=A(i,j)*B(m,n)
          END DO
        END DO
      END DO
    END DO
    
    RETURN
  END SUBROUTINE TensProd33
      
!   ====================================================================
      
!   The Operation "oplus" between two 2nd order tensors

  SUBROUTINE oplus(A,B,AopB)
      
    IMPLICIT NONE
      
    REAL*8 A(3,3),B(3,3),AopB(3,3,3,3)
    INTEGER i,j,m,n
    
    DO i=1,3
      DO j=1,3
        DO m=1,3
          DO n=1,3
            AopB(i,j,m,n)=A(i,n)*B(j,m)
          END DO
        END DO
      END DO
    END DO
      
    RETURN
  END SUBROUTINE oplus
      
!   ====================================================================      
!   The Operation "ominus" between two 2nd order tensors

  SUBROUTINE ominus(A,B,AomB)
      
    IMPLICIT NONE
      
    REAL*8 A(3,3),B(3,3),AomB(3,3,3,3)
    INTEGER i,j,m,n
    
    DO i=1,3
      DO j=1,3
        DO m=1,3
          DO n=1,3
            AomB(i,j,m,n)=A(i,m)*B(j,n)
          END DO
        END DO
      END DO
    END DO
    
    RETURN
  END SUBROUTINE ominus
      
!   ====================================================================
      
!   Dot Product between a 2nd order tensor and a 4th order tensor
      
  SUBROUTINE DotTens2Tens4(A2,B4,A2dotB4)
    
    IMPLICIT NONE
    
!   Declarations
    REAL*8 A2(3,3),B4(3,3,3,3),A2dotB4(3,3)
    INTEGER i,j,m,n
    
    DO i=1,3
      DO j=1,3
        A2dotB4(i,j)=0.0d0
        DO m=1,3
          DO n=1,3
            A2dotB4(i,j)=A2dotB4(i,j)+A2(m,n)*B4(m,n,i,j)
          END DO
        END DO
      END DO
    END DO
    
    RETURN
  END SUBROUTINE DotTens2Tens4
      
!   ====================================================================
      
!   Dot Product between a 4th order tensor and a 2nd order tensor
      
  SUBROUTINE DotTens4Tens2(A4,B2,A4dotB2)
    
    IMPLICIT NONE
    
!   Declarations
    REAL*8 A4(3,3,3,3),B2(3,3),A4dotB2(3,3)
    INTEGER i,j,m,n
    
    DO i=1,3
      DO j=1,3
        A4dotB2(i,j)=0.0d0
        DO m=1,3
          DO n=1,3
            A4dotB2(i,j)=A4dotB2(i,j)+A4(i,j,m,n)*B2(m,n)
          END DO
        END DO
      END DO
    END DO
    
    RETURN
  END SUBROUTINE DotTens4Tens2
      
!   ====================================================================    
      
!   Inverse of a 2 by 2 matrix
      
  SUBROUTINE InvTens2by2(A,invA)
      
    IMPLICIT NONE
      
!   Declarations
    REAL*8 A(2,2),detA,invA(2,2)
    
    detA=A(1,1)*A(2,2)-A(1,2)*A(2,1)
    invA(1,1)=1.0d0/detA*A(2,2)
    invA(1,2)=-1.0d0/detA*A(1,2)
    invA(2,1)=-1.0d0/detA*A(2,1)
    invA(2,2)=1.0d0/detA*A(1,1)
    
  END SUBROUTINE InvTens2by2
      
!   ====================================================================  
        
!   Macauley Brackets
      
  SUBROUTINE MacBrackets(x,Macx)
    
    IMPLICIT NONE
      
!   Declarations
    REAL*8 x,Macx
    
    Macx=MAX(x,0.0d0)
      
  END SUBROUTINE MacBrackets
  
END MODULE FiniteElasticityRoutines
