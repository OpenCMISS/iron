!> \file
!> \author Chris Bradley
!> \brief This module handles all solver matrix and rhs routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!> This module handles all solver matrix and rhs routines.
MODULE SOLVER_MATRICES_ROUTINES

  USE BaseRoutines
  USE DistributedMatrixVector
  USE DistributedMatrixVectorAccessRoutines
  USE INTERFACE_CONDITIONS_CONSTANTS
  USE InterfaceMatricesAccessRoutines
  USE ISO_VARYING_STRING
  USE Kinds
  USE MatrixVector
  USE PROBLEM_CONSTANTS
  USE SolverMatricesAccessRoutines
  USE Strings
  USE Types

#include "macros.h"  

  IMPLICIT NONE

  PRIVATE

  !Module parameters


  !> \addtogroup SOLVER_MATRICES_ROUTINES_SelectMatricesTypes SOLVER_MATRICES_ROUTINES::SelectMatricesTypes
  !> \brief The types of selection available for the solver matrices
  !> \see SOLVER_MATRICES_ROUTINES
  !>@{
  INTEGER(INTG), PARAMETER :: SOLVER_MATRICES_ALL=1 !<Select all the solver matrices and vectors \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
!  redundant when introducing dynamic nonlinear equations
!  INTEGER(INTG), PARAMETER :: SOLVER_MATRICES_DYNAMIC_ONLY=2 !<Select only the dynamic solver matrices and vectors \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: SOLVER_MATRICES_LINEAR_ONLY=3 !<Select only the linear solver matrices and vectors \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: SOLVER_MATRICES_NONLINEAR_ONLY=4 !<Select only the nonlinear solver matrices and vectors \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: SOLVER_MATRICES_JACOBIAN_ONLY=5 !<Select only the Jacobian solver matrix \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: SOLVER_MATRICES_RESIDUAL_ONLY=6 !<Select only the residual solver vector \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: SOLVER_MATRICES_RHS_ONLY=7 !<Select only the RHS solver vector \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: SOLVER_MATRICES_RHS_RESIDUAL_ONLY=8 !<Select only the residual and RHS solver vectors \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: SOLVER_MATRICES_LINEAR_RESIDUAL_ONLY=9 !<Select only the linear solver matrices and vectors plus the residual \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
  !>@}

  !Module types

  !Module variables

  !Interfaces
 
  INTERFACE SolverMatrices_CreateFinish
    MODULE PROCEDURE SOLVER_MATRICES_CREATE_FINISH
  END INTERFACE SolverMatrices_CreateFinish
  
  INTERFACE SolverMatrices_CreateStart
    MODULE PROCEDURE SOLVER_MATRICES_CREATE_START
  END INTERFACE SolverMatrices_CreateStart
  
  INTERFACE SolverMatrices_Destroy
    MODULE PROCEDURE SOLVER_MATRICES_DESTROY
  END INTERFACE SolverMatrices_Destroy
  
  INTERFACE SolverMatrices_Output
    MODULE PROCEDURE SOLVER_MATRICES_OUTPUT
  END INTERFACE SolverMatrices_Output
  
  INTERFACE SolverMatrices_StorageTypeGet
    MODULE PROCEDURE SOLVER_MATRICES_STORAGE_TYPE_GET
  END INTERFACE SolverMatrices_StorageTypeGet

  INTERFACE SolverMatrices_StorageTypeSet
    MODULE PROCEDURE SOLVER_MATRICES_STORAGE_TYPE_SET
  END INTERFACE SolverMatrices_StorageTypeSet  

  PUBLIC SOLVER_MATRICES_ALL,SOLVER_MATRICES_LINEAR_ONLY,SOLVER_MATRICES_NONLINEAR_ONLY, &
    & SOLVER_MATRICES_JACOBIAN_ONLY,SOLVER_MATRICES_RESIDUAL_ONLY,SOLVER_MATRICES_RHS_ONLY, & 
    & SOLVER_MATRICES_RHS_RESIDUAL_ONLY,SOLVER_MATRICES_LINEAR_RESIDUAL_ONLY !,SOLVER_MATRICES_DYNAMIC_ONLY

  PUBLIC SolverMatrix_EquationsMatrixAdd

  PUBLIC SolverMatrix_InterfaceMatrixAdd

  PUBLIC SolverMatrix_JacobianMatrixAdd

  PUBLIC SOLVER_MATRICES_CREATE_FINISH,SOLVER_MATRICES_CREATE_START

  PUBLIC SolverMatrices_CreateFinish,SolverMatrices_CreateStart

  PUBLIC SOLVER_MATRICES_DESTROY

  PUBLIC SolverMatrices_Destroy

  PUBLIC SolverMatrices_LibraryTypeGet,SolverMatrices_LibraryTypeSet

  PUBLIC SOLVER_MATRICES_OUTPUT

  PUBLIC SolverMatrices_Output

  PUBLIC SOLVER_MATRICES_STORAGE_TYPE_GET,SOLVER_MATRICES_STORAGE_TYPE_SET

  PUBLIC SolverMatrices_StorageTypeGet,SolverMatrices_StorageTypeSet

  PUBLIC SolverMatrices_SymmetryTypeGet,SolverMatrices_SymmetryTypeSet

CONTAINS

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating the solver matrices
  SUBROUTINE SOLVER_MATRICES_CREATE_FINISH(SOLVER_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES !<A pointer to the solver matrices
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,matrix_idx,NUMBER_OF_NON_ZEROS
    INTEGER(INTG), POINTER :: COLUMN_INDICES(:),ROW_INDICES(:)
    TYPE(DomainMappingType), POINTER :: ROW_DOMAIN_MAP,COLUMN_DOMAIN_MAP
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    NULLIFY(COLUMN_INDICES)
    NULLIFY(ROW_INDICES)
    
    ENTERS("SOLVER_MATRICES_CREATE_FINISH",ERR,ERROR,*998)

    IF(ASSOCIATED(SOLVER_MATRICES)) THEN
      IF(SOLVER_MATRICES%SOLVER_MATRICES_FINISHED) THEN
        CALL FlagError("Solver matrices have already been finished",ERR,ERROR,*998)
      ELSE
        SOLVER_EQUATIONS=>SOLVER_MATRICES%SOLVER_EQUATIONS
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          SOLVER_MAPPING=>SOLVER_EQUATIONS%solverMapping
          IF(ASSOCIATED(SOLVER_MAPPING)) THEN
            !Now create the individual solver matrices
            ROW_DOMAIN_MAP=>SOLVER_MAPPING%rowDOFsMapping
            IF(ASSOCIATED(ROW_DOMAIN_MAP)) THEN
              DO matrix_idx=1,SOLVER_MATRICES%NUMBER_OF_MATRICES
                SOLVER_MATRIX=>SOLVER_MATRICES%MATRICES(matrix_idx)%PTR
                IF(ASSOCIATED(SOLVER_MATRIX)) THEN
                  COLUMN_DOMAIN_MAP=>SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(matrix_idx)%columnDOFSMapping
                  IF(ASSOCIATED(COLUMN_DOMAIN_MAP)) THEN
                    !!Create the distributed solver matrix
                    CALL DistributedMatrix_CreateStart(ROW_DOMAIN_MAP,COLUMN_DOMAIN_MAP,SOLVER_MATRICES%MATRICES(matrix_idx)% &
                         & PTR%MATRIX,ERR,ERROR,*999)
                    CALL DistributedMatrix_LibraryTypeSet(SOLVER_MATRIX%MATRIX,SOLVER_MATRICES%matrixLibraryType,ERR,ERROR,*999)
                    CALL DistributedMatrix_DataTypeSet(SOLVER_MATRIX%MATRIX,MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
                    CALL DistributedMatrix_StorageTypeSet(SOLVER_MATRIX%MATRIX,SOLVER_MATRIX%storageType,ERR,ERROR,*999)
                    CALL DistributedMatrix_TransposeTypeSet(SOLVER_MATRIX%MATRIX,DISTRIBUTED_MATRIX_NO_TRANSPOSE_REQUIRED, &
                      & err,error,*999)
                    !Calculate and set the matrix structure/sparsity pattern
                    IF(SOLVER_MATRIX%storageType/=DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE.AND. &
                      & SOLVER_MATRIX%storageType/=DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE) THEN
                      CALL SOLVER_MATRIX_STRUCTURE_CALCULATE(SOLVER_MATRIX,NUMBER_OF_NON_ZEROS,ROW_INDICES, &
                        & COLUMN_INDICES,ERR,ERROR,*999)                  
                      CALL DistributedMatrix_NumberOfNonZerosSet(SOLVER_MATRIX%MATRIX,NUMBER_OF_NON_ZEROS, &
                        & ERR,ERROR,*999)
                      CALL DistributedMatrix_StorageLocationsSet(SOLVER_MATRIX%MATRIX,ROW_INDICES,COLUMN_INDICES, &
                        & ERR,ERROR,*999)
                      IF(ASSOCIATED(ROW_INDICES)) DEALLOCATE(ROW_INDICES)
                      IF(ASSOCIATED(COLUMN_INDICES)) DEALLOCATE(COLUMN_INDICES)
                    ENDIF
                    CALL DistributedMatrix_SymmetryTypeSet(SOLVER_MATRIX%matrix,SOLVER_MATRIX%symmetryType,err,error,*999)
                    CALL DistributedMatrix_CreateFinish(SOLVER_MATRIX%MATRIX,ERR,ERROR,*999)
                    !Allocate the distributed solver vector
                    CALL DistributedVector_CreateStart(COLUMN_DOMAIN_MAP,SOLVER_MATRICES%MATRICES(matrix_idx)% &
                         & PTR%SOLVER_VECTOR,ERR,ERROR,*999)
                    CALL DistributedVector_LibraryTypeSet(SOLVER_MATRIX%SOLVER_VECTOR,SOLVER_MATRICES%matrixLibraryType, &
                      & ERR,ERROR,*999)
                    CALL DistributedVector_DataTypeSet(SOLVER_MATRIX%SOLVER_VECTOR,MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
                    CALL DistributedVector_CreateFinish(SOLVER_MATRIX%SOLVER_VECTOR,ERR,ERROR,*999)
                  ELSE
                    CALL FlagError("Column domain mapping is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Solver matrix is not associated.",ERR,ERROR,*999)
                ENDIF
              ENDDO !matrix_idx
              IF(SOLVER_EQUATIONS%linearity==PROBLEM_SOLVER_NONLINEAR) THEN
                !Allocate the nonlinear matrices and vectors                  
                !Allocate the distributed residual vector
                CALL DistributedVector_CreateStart(ROW_DOMAIN_MAP,SOLVER_MATRICES%RESIDUAL,ERR,ERROR,*999)
                CALL DistributedVector_LibraryTypeSet(SOLVER_MATRICES%RESIDUAL,SOLVER_MATRICES%matrixLibraryType,ERR,ERROR,*999)
                CALL DistributedVector_DataTypeSet(SOLVER_MATRICES%RESIDUAL,MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
                CALL DistributedVector_CreateFinish(SOLVER_MATRICES%RESIDUAL,ERR,ERROR,*999)                  
              ENDIF
!!TODO: what to do if there is no RHS
              !Allocate the distributed rhs vector
              CALL DistributedVector_CreateStart(ROW_DOMAIN_MAP,SOLVER_MATRICES%rhsVector,ERR,ERROR,*999)
              CALL DistributedVector_LibraryTypeSet(SOLVER_MATRICES%rhsVector,SOLVER_MATRICES%matrixLibraryType,ERR,ERROR,*999)
              CALL DistributedVector_DataTypeSet(SOLVER_MATRICES%rhsVector,MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
              CALL DistributedVector_CreateFinish(SOLVER_MATRICES%rhsVector,ERR,ERROR,*999)
              !Finish up
              SOLVER_MATRICES%SOLVER_MATRICES_FINISHED=.TRUE.
            ELSE
              CALL FlagError("Row domain mapping is not associated.",ERR,ERROR,*998)
            ENDIF
          ELSE
            CALL FlagError("Solver equations solver mapping is not associated.",ERR,ERROR,*998)
          ENDIF
        ELSE
          CALL FlagError("Solver matrices solver equations is not associated.",ERR,ERROR,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver matrices is not associated.",ERR,ERROR,*998)
    ENDIF
        
    EXITS("SOLVER_MATRICES_CREATE_FINISH")
    RETURN
999 IF(ASSOCIATED(ROW_INDICES)) DEALLOCATE(ROW_INDICES)
    IF(ASSOCIATED(COLUMN_INDICES)) DEALLOCATE(COLUMN_INDICES)
    CALL SOLVER_MATRICES_FINALISE(SOLVER_MATRICES,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("SOLVER_MATRICES_CREATE_FINISH",ERR,ERROR)    
    RETURN 1
    
  END SUBROUTINE SOLVER_MATRICES_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Starts the process of creating the solver matrices
  SUBROUTINE SOLVER_MATRICES_CREATE_START(SOLVER_EQUATIONS,SOLVER_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS !<A pointer to the solver equations to create the solver matrices for
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES !<On return, a pointer to the solver matrices. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR
    
    ENTERS("SOLVER_MATRICES_CREATE_START",ERR,ERROR,*998)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      IF(SOLVER_EQUATIONS%SOLVER_EQUATIONS_FINISHED) THEN
        IF(ASSOCIATED(SOLVER_MATRICES)) THEN
          CALL FlagError("Solver matrices is already associated",ERR,ERROR,*998)
        ELSE
          NULLIFY(SOLVER_EQUATIONS%SOLVER_MATRICES)
          CALL SOLVER_MATRICES_INITIALISE(SOLVER_EQUATIONS,ERR,ERROR,*999)
          SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
        ENDIF
      ELSE
        CALL FlagError("Solver equations are not finished",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated",ERR,ERROR,*998)
    ENDIF
        
    EXITS("SOLVER_MATRICES_CREATE_START")
    RETURN
999 CALL SOLVER_MATRICES_FINALISE(SOLVER_EQUATIONS%SOLVER_MATRICES,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("SOLVER_MATRICES_CREATE_START",ERR,ERROR)    
    RETURN 1
   
  END SUBROUTINE SOLVER_MATRICES_CREATE_START
        
  !
  !================================================================================================================================
  !

  !>Destroy the solver matrices
  SUBROUTINE SOLVER_MATRICES_DESTROY(SOLVER_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES !<A pointer the solver matrices to destroy
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("SOLVER_MATRICES_DESTROY",ERR,ERROR,*999)

    IF(ASSOCIATED(SOLVER_MATRICES)) THEN
      CALL SOLVER_MATRICES_FINALISE(SOLVER_MATRICES,ERR,ERROR,*999)
    ELSE
      CALL FlagError("Solver matrices is not associated",ERR,ERROR,*999)
    ENDIF
        
    EXITS("SOLVER_MATRICES_DESTROY")
    RETURN
999 ERRORSEXITS("SOLVER_MATRICES_DESTROY",ERR,ERROR)    
    RETURN 1
   
  END SUBROUTINE SOLVER_MATRICES_DESTROY

  !
  !================================================================================================================================
  !

  !>Finalises the solver matrices and deallocates all memory
  SUBROUTINE SOLVER_MATRICES_FINALISE(SOLVER_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES !<A pointer to the solver matrices to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx

    ENTERS("SOLVER_MATRICES_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(SOLVER_MATRICES)) THEN
      IF(ALLOCATED(SOLVER_MATRICES%MATRICES)) THEN
        DO matrix_idx=1,SIZE(SOLVER_MATRICES%MATRICES,1)
          CALL SOLVER_MATRIX_FINALISE(SOLVER_MATRICES%MATRICES(matrix_idx)%PTR,ERR,ERROR,*999)
        ENDDO !matrix_idx
        DEALLOCATE(SOLVER_MATRICES%MATRICES)
      ENDIF
      IF(ASSOCIATED(SOLVER_MATRICES%RESIDUAL)) CALL DistributedVector_Destroy(SOLVER_MATRICES%RESIDUAL,ERR,ERROR,*999)
      IF(ASSOCIATED(SOLVER_MATRICES%rhsVector)) CALL DistributedVector_Destroy(SOLVER_MATRICES%rhsVector,ERR,ERROR,*999)
      DEALLOCATE(SOLVER_MATRICES)
    ENDIF
        
    EXITS("SOLVER_MATRICES_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_MATRICES_FINALISE",ERR,ERROR)    
    RETURN 1
   
  END SUBROUTINE SOLVER_MATRICES_FINALISE
        
  !
  !================================================================================================================================
  !

  !>Initialises the solver matrices for solver equations
  SUBROUTINE SOLVER_MATRICES_INITIALISE(SOLVER_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS !<A pointer to the solver equations to initialise the solver matrices for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,equations_matrix_idx,equations_set_idx,matrix_idx
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("SOLVER_MATRICES_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      IF(ASSOCIATED(SOLVER_EQUATIONS%SOLVER_MATRICES)) THEN
        CALL FlagError("Solver matrices is already associated for this solver equations.",ERR,ERROR,*998)
      ELSE
        SOLVER_MAPPING=>SOLVER_EQUATIONS%solverMapping
        IF(ASSOCIATED(SOLVER_MAPPING)) THEN
          ALLOCATE(SOLVER_EQUATIONS%SOLVER_MATRICES,STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate solver matrices.",ERR,ERROR,*999)
          SOLVER_EQUATIONS%SOLVER_MATRICES%SOLVER_EQUATIONS=>SOLVER_EQUATIONS
          SOLVER_EQUATIONS%SOLVER_MATRICES%SOLVER_MATRICES_FINISHED=.FALSE.
          SOLVER_EQUATIONS%SOLVER_MATRICES%solverMapping=>SOLVER_MAPPING
          SOLVER_EQUATIONS%SOLVER_MATRICES%numberOfRows=SOLVER_MAPPING%numberOfRows
          SOLVER_EQUATIONS%SOLVER_MATRICES%numberOfGlobalRows=SOLVER_MAPPING%numberOfGlobalRows
          SOLVER_EQUATIONS%SOLVER_MATRICES%solverLibraryType=0
          SOLVER_EQUATIONS%SOLVER_MATRICES%matrixLibraryType=0
          SOLVER_EQUATIONS%SOLVER_MATRICES%NUMBER_OF_MATRICES=SOLVER_MAPPING%NUMBER_OF_SOLVER_MATRICES
          ALLOCATE(SOLVER_EQUATIONS%SOLVER_MATRICES%MATRICES(SOLVER_MAPPING%NUMBER_OF_SOLVER_MATRICES),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate solver matrices matrices.",ERR,ERROR,*999)
          DO matrix_idx=1,SOLVER_MAPPING%NUMBER_OF_SOLVER_MATRICES
            NULLIFY(SOLVER_EQUATIONS%SOLVER_MATRICES%MATRICES(matrix_idx)%PTR)
            CALL SOLVER_MATRIX_INITIALISE(SOLVER_EQUATIONS%SOLVER_MATRICES,matrix_idx,ERR,ERROR,*999)
            DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
              IF(ALLOCATED(SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM( &
                & matrix_idx)%DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS)) THEN
                DO equations_matrix_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                  & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(matrix_idx)%NUMBER_OF_DYNAMIC_EQUATIONS_MATRICES
                  !Add the solver matrix to the solvers mapping
                  SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM( &
                    & matrix_idx)%DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS(equations_matrix_idx)%PTR%SOLVER_MATRIX=> &
                    & SOLVER_EQUATIONS%SOLVER_MATRICES%MATRICES(matrix_idx)%PTR
                ENDDO !equations_matrix_idx
              ELSE
                IF(ALLOCATED(SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                  & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(matrix_idx)%JACOBIAN_TO_SOLVER_MATRIX_MAPS)) THEN
                  DO equations_matrix_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                    & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(matrix_idx)%NUMBER_OF_EQUATIONS_JACOBIANS
                    SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                      & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(matrix_idx)%JACOBIAN_TO_SOLVER_MATRIX_MAPS(equations_matrix_idx)%PTR% &
                      & SOLVER_MATRIX=>SOLVER_EQUATIONS%SOLVER_MATRICES%MATRICES(matrix_idx)%PTR
                  ENDDO
                ELSE
                  DO equations_matrix_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                    & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(matrix_idx)%NUMBER_OF_LINEAR_EQUATIONS_MATRICES
                    !Add the solver matrix to the solvers mapping
                    SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM( &
                      & matrix_idx)%LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS(equations_matrix_idx)%PTR%SOLVER_MATRIX=> &
                      & SOLVER_EQUATIONS%SOLVER_MATRICES%MATRICES(matrix_idx)%PTR
                  ENDDO !equations_matrix_idx
                ENDIF
              ENDIF
            ENDDO !equations_set_idx
          ENDDO !matrix_idx
          IF(SOLVER_EQUATIONS%linearity==PROBLEM_SOLVER_NONLINEAR) THEN
            SOLVER_EQUATIONS%SOLVER_MATRICES%UPDATE_RESIDUAL=.TRUE.
          ELSE
            SOLVER_EQUATIONS%SOLVER_MATRICES%UPDATE_RESIDUAL=.FALSE.
          ENDIF
          NULLIFY(SOLVER_EQUATIONS%SOLVER_MATRICES%RESIDUAL)
          SOLVER_EQUATIONS%SOLVER_MATRICES%UPDATE_RHS_VECTOR=.TRUE.
          NULLIFY(SOLVER_EQUATIONS%SOLVER_MATRICES%rhsVector)
        ELSE
          CALL FlagError("Solver equations solver mapping is not associated",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver equations is not associated",ERR,ERROR,*998)
    ENDIF
        
    EXITS("SOLVER_MATRICES_INITIALISE")
    RETURN
999 CALL SOLVER_MATRICES_FINALISE(SOLVER_EQUATIONS%SOLVER_MATRICES,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("SOLVER_MATRICES_INITIALISE",ERR,ERROR)    
    RETURN 1
   
  END SUBROUTINE SOLVER_MATRICES_INITIALISE
  
  !
  !================================================================================================================================
  !

  !>Sets the library type for the solver matrices (and vectors)
  SUBROUTINE SolverMatrices_LibraryTypeSet(solverMatrices,libraryType,err,error,*)

    !Argument variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices !<A pointer to the solver matrices.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type to set \see SOLVER_ROUTINES_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SolverMatrices_LibraryTypeSet",err,error,*999)

    IF(.NOT.ASSOCIATED(solverMatrices)) CALL FlagError("Solver matrices is not associated.",ERR,ERROR,*999)
    IF(solverMatrices%SOLVER_MATRICES_FINISHED) CALL FlagError("Solver matrices has been finished.",ERR,ERROR,*999)
    
    SELECT CASE(libraryType)
    CASE(LIBRARY_CMISS_TYPE)
      solverMatrices%matrixLibraryType=DISTRIBUTED_MATRIX_VECTOR_CMISS_TYPE
    CASE(LIBRARY_PETSC_TYPE)
      solverMatrices%matrixLibraryType=DISTRIBUTED_MATRIX_VECTOR_PETSC_TYPE
    CASE(LIBRARY_MUMPS_TYPE)
      solverMatrices%matrixLibraryType=DISTRIBUTED_MATRIX_VECTOR_PETSC_TYPE
    CASE(LIBRARY_SUPERLU_TYPE)
      solverMatrices%matrixLibraryType=DISTRIBUTED_MATRIX_VECTOR_PETSC_TYPE
    CASE(LIBRARY_SPOOLES_TYPE)
    CASE(LIBRARY_UMFPACK_TYPE)
      solverMatrices%matrixLibraryType=DISTRIBUTED_MATRIX_VECTOR_PETSC_TYPE
    CASE(LIBRARY_LUSOL_TYPE)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(LIBRARY_ESSL_TYPE)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(LIBRARY_LAPACK_TYPE)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(LIBRARY_HYPRE_TYPE)
      solverMatrices%matrixLibraryType=DISTRIBUTED_MATRIX_VECTOR_PETSC_TYPE
    CASE(LIBRARY_PASTIX_TYPE)
      solverMatrices%matrixLibraryType=DISTRIBUTED_MATRIX_VECTOR_PETSC_TYPE
    CASE DEFAULT
      localError="The solver library type of "// TRIM(NumberToVString(libraryType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    solverMatrices%solverLibraryType=libraryType
    
    EXITS("SolverMatrices_LibraryTypeSet")
    RETURN
999 ERRORSEXITS("SolverMatrices_LibraryTypeSet",err,error)
    RETURN 1
     
  END SUBROUTINE SolverMatrices_LibraryTypeSet

  !
  !================================================================================================================================
  !

  !>Outputs the solver matrices
  SUBROUTINE SOLVER_MATRICES_OUTPUT(ID,SELECTION_TYPE,SOLVER_MATRICES,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ID !<The ID of the ouptut stream
    INTEGER(INTG), INTENT(IN) :: SELECTION_TYPE !<The type of matrix selection \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES !<A pointer to the solver matrices
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX
    
    ENTERS("SOLVER_MATRICES_OUTPUT",ERR,ERROR,*999)

    IF(ASSOCIATED(SOLVER_MATRICES)) THEN
      IF(SOLVER_MATRICES%SOLVER_MATRICES_FINISHED) THEN
        CALL WriteString(ID,"",ERR,ERROR,*999)
        IF(SELECTION_TYPE==SOLVER_MATRICES_ALL.OR. &
!           & SELECTION_TYPE==SOLVER_MATRICES_DYNAMIC_ONLY.OR. &
          & SELECTION_TYPE==SOLVER_MATRICES_LINEAR_ONLY.OR. &
          & SELECTION_TYPE==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
          & SELECTION_TYPE==SOLVER_MATRICES_JACOBIAN_ONLY) THEN
          CALL WriteString(ID,"Solver matrices:",ERR,ERROR,*999)
          CALL WriteStringValue(ID,"Number of matrices = ",SOLVER_MATRICES%NUMBER_OF_MATRICES,ERR,ERROR,*999)
          DO matrix_idx=1,SOLVER_MATRICES%NUMBER_OF_MATRICES
            SOLVER_MATRIX=>SOLVER_MATRICES%MATRICES(matrix_idx)%PTR
            IF(ASSOCIATED(SOLVER_MATRIX)) THEN
              CALL WriteStringValue(ID,"Solver matrix : ",matrix_idx,ERR,ERROR,*999)
              CALL DistributedMatrix_Output(ID,SOLVER_MATRIX%MATRIX,ERR,ERROR,*999)
            ELSE
              CALL FlagError("Solver matrix is not associated.",ERR,ERROR,*999)
            ENDIF
          ENDDO !matrix_idx
        ENDIF
        IF(SELECTION_TYPE==SOLVER_MATRICES_ALL.OR. &
          & SELECTION_TYPE==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
          & SELECTION_TYPE==SOLVER_MATRICES_RESIDUAL_ONLY.OR. &
          & SELECTION_TYPE==SOLVER_MATRICES_RHS_RESIDUAL_ONLY) THEN
          IF(ASSOCIATED(SOLVER_MATRICES%RESIDUAL)) THEN
            CALL WriteString(ID,"Solver residual vector:",ERR,ERROR,*999)     
            CALL DistributedVector_Output(ID,SOLVER_MATRICES%RESIDUAL,ERR,ERROR,*999)  
          ENDIF
        ENDIF
        IF(SELECTION_TYPE==SOLVER_MATRICES_ALL.OR. &
!          & SELECTION_TYPE==SOLVER_MATRICES_DYNAMIC_ONLY.OR. &
          & SELECTION_TYPE==SOLVER_MATRICES_LINEAR_ONLY.OR. &
          & SELECTION_TYPE==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
          & SELECTION_TYPE==SOLVER_MATRICES_RHS_ONLY.OR. &
          & SELECTION_TYPE==SOLVER_MATRICES_RHS_RESIDUAL_ONLY) THEN
          IF(ASSOCIATED(SOLVER_MATRICES%rhsVector)) THEN
            CALL WriteString(ID,"Solver RHS vector:",ERR,ERROR,*999)     
            CALL DistributedVector_Output(ID,SOLVER_MATRICES%rhsVector,ERR,ERROR,*999)
          ENDIF
        ENDIF
      ELSE
        CALL FlagError("Solver matrices have not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    EXITS("SOLVER_MATRICES_OUTPUT")
    RETURN
999 ERRORSEXITS("SOLVER_MATRICES_OUTPUT",ERR,ERROR)
    RETURN 1
  END SUBROUTINE SOLVER_MATRICES_OUTPUT
  
  !
  !================================================================================================================================
  !
  
  !>Gets the storage type (sparsity) of the solver matrices
  SUBROUTINE SOLVER_MATRICES_STORAGE_TYPE_GET(SOLVER_MATRICES,STORAGE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES !<A pointer to the solver matrices
    INTEGER(INTG), INTENT(OUT) :: STORAGE_TYPE(:) !<STORAGE_TYPE(matrix_idx). On return, the storage type for the matrix_idx'th solver matrix
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    ENTERS("SOLVER_MATRICES_STORAGE_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(SOLVER_MATRICES)) THEN
      IF(SOLVER_MATRICES%SOLVER_MATRICES_FINISHED) THEN
        IF(SIZE(STORAGE_TYPE,1)>=SOLVER_MATRICES%NUMBER_OF_MATRICES) THEN
          DO matrix_idx=1,SOLVER_MATRICES%NUMBER_OF_MATRICES
            SOLVER_MATRIX=>SOLVER_MATRICES%MATRICES(matrix_idx)%PTR
            IF(ASSOCIATED(SOLVER_MATRIX)) THEN
              STORAGE_TYPE(matrix_idx)=SOLVER_MATRIX%storageType
            ELSE
              CALL FlagError("Solver matrix is not associated.",ERR,ERROR,*999)
            ENDIF
          ENDDO !matrix_idx
        ELSE
          LOCAL_ERROR="The size of STORAGE_TYPE is too small. The supplied size is "// &
            & TRIM(NUMBER_TO_VSTRING(SIZE(STORAGE_TYPE,1),"*",ERR,ERROR))//" and it needs to be >= "// &
            & TRIM(NUMBER_TO_VSTRING(SOLVER_MATRICES%NUMBER_OF_MATRICES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver matrices have not finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    EXITS("SOLVER_MATRICES_STORAGE_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_MATRICES_STORAGE_TYPE_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE SOLVER_MATRICES_STORAGE_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets the storage type (sparsity) of the solver matrices
  SUBROUTINE SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,STORAGE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES !<A pointer to the solver matrices
    INTEGER(INTG), INTENT(IN) :: STORAGE_TYPE(:) !<STORAGE_TYPE(matrix_idx). The storage type for the matrix_idx'th solver matrix
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    ENTERS("SOLVER_MATRICES_STORAGE_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(SOLVER_MATRICES)) THEN
      IF(SOLVER_MATRICES%SOLVER_MATRICES_FINISHED) THEN
        CALL FlagError("Solver matrices have been finished.",ERR,ERROR,*999)
      ELSE
        IF(SIZE(STORAGE_TYPE,1)==SOLVER_MATRICES%NUMBER_OF_MATRICES) THEN
          DO matrix_idx=1,SOLVER_MATRICES%NUMBER_OF_MATRICES
            SOLVER_MATRIX=>SOLVER_MATRICES%MATRICES(matrix_idx)%PTR
            IF(ASSOCIATED(SOLVER_MATRIX)) THEN
              SELECT CASE(STORAGE_TYPE(matrix_idx))
              CASE(MATRIX_BLOCK_STORAGE_TYPE)
                SOLVER_MATRIX%storageType=MATRIX_BLOCK_STORAGE_TYPE
              CASE(MATRIX_DIAGONAL_STORAGE_TYPE)
                SOLVER_MATRIX%storageType=MATRIX_DIAGONAL_STORAGE_TYPE        
              CASE(MATRIX_COLUMN_MAJOR_STORAGE_TYPE)
                SOLVER_MATRIX%storageType=MATRIX_COLUMN_MAJOR_STORAGE_TYPE
              CASE(MATRIX_ROW_MAJOR_STORAGE_TYPE)
                SOLVER_MATRIX%storageType=MATRIX_ROW_MAJOR_STORAGE_TYPE
              CASE(MATRIX_COMPRESSED_ROW_STORAGE_TYPE)
                SOLVER_MATRIX%storageType=MATRIX_COMPRESSED_ROW_STORAGE_TYPE
              CASE(MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE)
                SOLVER_MATRIX%storageType=MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE
              CASE(MATRIX_ROW_COLUMN_STORAGE_TYPE)
                SOLVER_MATRIX%storageType=MATRIX_ROW_COLUMN_STORAGE_TYPE
              CASE DEFAULT
                LOCAL_ERROR="The specified storage type of "//TRIM(NUMBER_TO_VSTRING(STORAGE_TYPE(matrix_idx),"*",ERR,ERROR))// &
                  & " for the matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))//" is invalid."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              CALL FlagError("Solver matrix is not associated.",ERR,ERROR,*999)
            ENDIF
          ENDDO !matrix_idx
        ELSE
          LOCAL_ERROR="The size of the storage type array ("//TRIM(NUMBER_TO_VSTRING(SIZE(STORAGE_TYPE,1),"*",ERR,ERROR))// &
            & ") is not equal to the number of matrices ("// &
            & TRIM(NUMBER_TO_VSTRING(SOLVER_MATRICES%NUMBER_OF_MATRICES,"*",ERR,ERROR))//")."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    EXITS("SOLVER_MATRICES_STORAGE_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_MATRICES_STORAGE_TYPE_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE SOLVER_MATRICES_STORAGE_TYPE_SET

  !
  !================================================================================================================================
  !
  
  !>Gets the symmetry type of the solver matrices
  SUBROUTINE SolverMatrices_SymmetryTypeGet(solverMatrices,symmetryTypes,err,error,*)

    !Argument variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices !<A pointer to the solver matrices
    INTEGER(INTG), INTENT(OUT) :: symmetryTypes(:) !<symmetryTypes(matrixIdx). On return, the symmtry type for the matrixIdx'th solver matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: matrixIdx
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: solverMatrix
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SolverMatrices_SymmetryTypeGet",err,error,*999)

    IF(.NOT.ASSOCIATED(solverMatrices)) CALL FlagError("Solver matrices is not associated.",ERR,ERROR,*999)
    IF(.NOT.solverMatrices%SOLVER_MATRICES_FINISHED) CALL FlagError("Solver matrices have not finished.",ERR,ERROR,*999)
    IF(SIZE(symmetryTypes,1)<solverMatrices%NUMBER_OF_MATRICES) THEN
      localError="The size of symmetry types is too small. The supplied size is "// &
        & TRIM(NumberToVString(SIZE(symmetryTypes,1),"*",err,error))//" and it needs to be >= "// &
        & TRIM(NumberToVString(solverMatrices%NUMBER_OF_MATRICES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    DO matrixIdx=1,solverMatrices%NUMBER_OF_MATRICES
      NULLIFY(solverMatrix)
      CALL SolverMatrices_SolverMatrixGet(solverMatrices,matrixIdx,solverMatrix,err,error,*999)
      symmetryTypes(matrixIdx)=solverMatrix%symmetryType
    ENDDO !matrixIdx
    
    EXITS("SolverMatrices_SymmetryTypeGet")
    RETURN
999 ERRORSEXITS("SolverMatrices_SymmetryTypeGet",err,error)
    RETURN 1
    
  END SUBROUTINE SolverMatrices_SymmetryTypeGet

  !
  !================================================================================================================================
  !

  !>Sets the symmetry type of the solver matrices
  SUBROUTINE SolverMatrices_SymmetryTypeSet(solverMatrices,symmetryTypes,err,error,*)

    !Argument variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices !<A pointer to the solver matrices to set the symmetry types for
    INTEGER(INTG), INTENT(IN) :: symmetryTypes(:) !<symmetryTypes(matrixIdx). The symmetry type for the matrixIdx'th solver matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: matrixIdx
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: solverMatrix
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SolverMatrices_SymmetryTypeSet",err,error,*999)

    IF(.NOT.ASSOCIATED(solverMatrices)) CALL FlagError("Solver matrices is not associated.",err,error,*999)
    IF(solverMatrices%SOLVER_MATRICES_FINISHED) CALL FlagError("Solver matrices have been finished.",ERR,ERROR,*999)
    IF(SIZE(symmetryTypes,1)/=solverMatrices%NUMBER_OF_MATRICES) THEN
      localError="The size of the symmetry types array of "//TRIM(NumberToVString(SIZE(symmetryTypes,1),"*",err,error))// &
        & " is not equal to the number of matrices of "//TRIM(NumberToVString(solverMatrices%NUMBER_OF_MATRICES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
      
    DO matrixIdx=1,solverMatrices%NUMBER_OF_MATRICES
      NULLIFY(solverMatrix)
      CALL SolverMatrices_SolverMatrixGet(solverMatrices,matrixIdx,solverMatrix,err,error,*999)
      solverMatrix%symmetryType=symmetryTypes(matrixIdx)
    ENDDO !matrixIdx
    
    EXITS("SolverMatrices_SymmetryTypeSet")
    RETURN
999 ERRORSEXITS("SolverMatrices_SymmetryTypeSet",err,error)
    RETURN 1
    
  END SUBROUTINE SolverMatrices_SymmetryTypeSet

  !
  !================================================================================================================================
  !

  !>Adds alpha times the equations matrix into the solver matrix
  SUBROUTINE SolverMatrix_EquationsMatrixAdd(SOLVER_MATRIX,equations_set_idx,ALPHA,equationsMatrix,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX !<A pointer to the solver matrix
    INTEGER(INTG), INTENT(IN) :: equations_set_idx !<The equations set index in the solver mapping that contains the equations matrix to add
    REAL(DP), INTENT(IN) :: ALPHA !<The multiplicative factor for the equations matrix
    TYPE(EquationsMatrixType), POINTER :: equationsMatrix !<A pointer to the equations matrix to add    
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG), POINTER :: COLUMN_INDICES(:),ROW_INDICES(:)
    REAL(DP), POINTER :: EQUATIONS_MATRIX_DATA(:)
    TYPE(DistributedMatrixType), POINTER :: EQUATIONS_DISTRIBUTED_MATRIX,SOLVER_DISTRIBUTED_MATRIX
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatricesDynamicType), POINTER :: dynamicMatrices
    TYPE(EquationsMatricesLinearType), POINTER :: linearMatrices
    TYPE(EQUATIONS_TO_SOLVER_MAPS_TYPE), POINTER :: EQUATIONS_TO_SOLVER_MAP
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    ENTERS("SolverMatrix_EquationsMatrixAdd",ERR,ERROR,*999)

    NULLIFY(EQUATIONS_MATRIX_DATA)
    NULLIFY(COLUMN_INDICES)
    NULLIFY(ROW_INDICES)

    IF(ASSOCIATED(SOLVER_MATRIX)) THEN
      IF(ASSOCIATED(equationsMatrix)) THEN
        IF(ABS(ALPHA)>ZERO_TOLERANCE) THEN
          SOLVER_MATRICES=>SOLVER_MATRIX%SOLVER_MATRICES
          IF(ASSOCIATED(SOLVER_MATRICES)) THEN
            IF(SOLVER_MATRICES%SOLVER_MATRICES_FINISHED) THEN
              SOLVER_MAPPING=>SOLVER_MATRICES%solverMapping
              IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                linearMatrices=>equationsMatrix%linearMatrices
                dynamicMatrices=>equationsMatrix%dynamicMatrices
                IF(ASSOCIATED(dynamicMatrices).OR.ASSOCIATED(linearMatrices)) THEN
                  IF(ASSOCIATED(dynamicMatrices)) THEN
                    vectorMatrices=>dynamicMatrices%vectorMatrices
                  ELSE
                    vectorMatrices=>linearMatrices%vectorMatrices
                  ENDIF
                  IF(ASSOCIATED(vectorMatrices)) THEN
                    IF(vectorMatrices%vectorMatricesFinished) THEN
                      IF(equations_set_idx>0.AND.equations_set_idx<=SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS) THEN
                        EQUATIONS_TO_SOLVER_MAP=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM(equationsMatrix%matrixNumber)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS(SOLVER_MATRIX%matrixNumber)%PTR
                        IF(ASSOCIATED(EQUATIONS_TO_SOLVER_MAP)) THEN
                          SOLVER_DISTRIBUTED_MATRIX=>SOLVER_MATRIX%MATRIX
                          IF(ASSOCIATED(SOLVER_DISTRIBUTED_MATRIX)) THEN
                            EQUATIONS_DISTRIBUTED_MATRIX=>equationsMatrix%MATRIX
                            IF(ASSOCIATED(EQUATIONS_DISTRIBUTED_MATRIX)) THEN
                              CALL DistributedMatrix_MatrixCoupleAdd(SOLVER_DISTRIBUTED_MATRIX,SOLVER_MAPPING% &
                                & EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%equationsRowToSolverRowsMap, &
                                & EQUATIONS_TO_SOLVER_MAP%equationsColToSolverColsMap,ALPHA,EQUATIONS_DISTRIBUTED_MATRIX, &
                                & .FALSE.,err,error,*999)                              
                            ELSE
                              CALL FlagError("The equations matrix distributed matrix is not associated",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Solver matrix distributed matrix is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Equations to solver map is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="The specified equations set index of "// &
                          & TRIM(NUMBER_TO_VSTRING(equations_set_idx,"*",ERR,ERROR))// &
                          & " is invalid. The equations set index needs to be between 1 and "// &
                          & TRIM(NUMBER_TO_VSTRING(SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS,"*",ERR,ERROR))//"."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Equations matrices have not been finished.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Dynamic or linear matrices equations matrices is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Equations matrix dynamic or linear matrices is not associated.",ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("Solver matrices solver mapping is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver matrices have not been finished.",ERR,ERROR,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver matrix solver matrices is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
      ELSE
        CALL FlagError("Equations matrix is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver matrix is not associated.",ERR,ERROR,*999)
    ENDIF
    
    EXITS("SolverMatrix_EquationsMatrixAdd")
    RETURN
999 ERRORSEXITS("SolverMatrix_EquationsMatrixAdd",ERR,ERROR)
    RETURN 1
    
  END SUBROUTINE SolverMatrix_EquationsMatrixAdd

  !
  !================================================================================================================================
  !

  !>Adds alpha times the interface matrix into the solver matrix
  SUBROUTINE SolverMatrix_InterfaceMatrixAdd(SOLVER_MATRIX,interface_condition_idx,ALPHA,INTERFACE_MATRIX,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX !<A pointer to the solver matrix
    INTEGER(INTG), INTENT(IN) :: interface_condition_idx !<The interface_condition_idx index in the solver mapping that contains the interface matrix to add
    REAL(DP), INTENT(IN) :: ALPHA(2) !<The multiplicative factor for the interface matrix
    TYPE(InterfaceMatrixType), POINTER :: INTERFACE_MATRIX !<A pointer to the interface matrix to add    
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG), POINTER :: COLUMN_INDICES(:),ROW_INDICES(:)
    REAL(DP), POINTER :: INTERFACE_MATRIX_DATA(:)
    TYPE(DistributedMatrixType), POINTER :: INTERFACE_DISTRIBUTED_MATRIX,SOLVER_DISTRIBUTED_MATRIX
    TYPE(InterfaceMatricesType), POINTER :: INTERFACE_MATRICES
    TYPE(INTERFACE_TO_SOLVER_MAPS_TYPE), POINTER :: INTERFACE_TO_SOLVER_MAP
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    ENTERS("SolverMatrix_InterfaceMatrixAdd",ERR,ERROR,*999)

    NULLIFY(INTERFACE_MATRIX_DATA)
    NULLIFY(COLUMN_INDICES)
    NULLIFY(ROW_INDICES)

    IF(ASSOCIATED(SOLVER_MATRIX)) THEN
      IF(ASSOCIATED(INTERFACE_MATRIX)) THEN
        IF(ABS(ALPHA(1))>ZERO_TOLERANCE) THEN
          SOLVER_MATRICES=>SOLVER_MATRIX%SOLVER_MATRICES
          IF(ASSOCIATED(SOLVER_MATRICES)) THEN
            IF(SOLVER_MATRICES%SOLVER_MATRICES_FINISHED) THEN
              SOLVER_MAPPING=>SOLVER_MATRICES%solverMapping
              IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                INTERFACE_MATRICES=>INTERFACE_MATRIX%interfaceMatrices
                CALL InterfaceMatrices_AssertIsFinished(INTERFACE_MATRICES,err,error,*999)
                IF(interface_condition_idx>0.AND.interface_condition_idx<=SOLVER_MAPPING%numberOfInterfaceConditions) THEN
                  INTERFACE_TO_SOLVER_MAP=>SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                    & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(INTERFACE_MATRIX%matrixNumber)%INTERFACE_TO_SOLVER_MATRIX_MAPS( &
                    & SOLVER_MATRIX%matrixNumber)%PTR
                  IF(ASSOCIATED(INTERFACE_TO_SOLVER_MAP)) THEN
                    SOLVER_DISTRIBUTED_MATRIX=>SOLVER_MATRIX%MATRIX
                    IF(ASSOCIATED(SOLVER_DISTRIBUTED_MATRIX)) THEN
                      INTERFACE_DISTRIBUTED_MATRIX=>INTERFACE_MATRIX%MATRIX
                      IF(ASSOCIATED(INTERFACE_DISTRIBUTED_MATRIX)) THEN
                        CALL DistributedMatrix_MatrixCoupleAdd(SOLVER_DISTRIBUTED_MATRIX,SOLVER_MAPPING% &
                          & INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(INTERFACE_MATRIX%matrixNumber)% &
                          & interfaceRowToSolverRowsMap,SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP( &
                          & interface_condition_idx)%INTERFACE_TO_SOLVER_MATRIX_MAPS_SM( &
                          & SOLVER_MATRIX%matrixNumber)%interfaceColToSolverColsMap,alpha(1),INTERFACE_DISTRIBUTED_MATRIX, &
                          & .FALSE.,ERR,ERROR,*999)                           
                        IF(INTERFACE_MATRIX%hasTranspose) THEN
                          IF(ABS(ALPHA(2))>ZERO_TOLERANCE) THEN
                            INTERFACE_DISTRIBUTED_MATRIX=>INTERFACE_MATRIX%matrixTranspose
                            CALL DistributedMatrix_MatrixCoupleAdd(SOLVER_DISTRIBUTED_MATRIX,SOLVER_MAPPING% &
                              & INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                              & interfaceColToSolverRowsMap,INTERFACE_TO_SOLVER_MAP%interfaceRowToSolverColsMap, &
                              & alpha(2),INTERFACE_DISTRIBUTED_MATRIX,.FALSE.,ERR,ERROR,*999)
                          ELSE
                            CALL FlagError("The transpose interface matrix distributed matrix is not associated", &
                              & ERR,ERROR,*999)
                          ENDIF
                        ENDIF !Interface matrix transpose
                      ELSE
                        CALL FlagError("The interface matrix distributed matrix is not associated",ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Solver matrix distributed matrix is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Interface to solver map is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The specified interface condition index of "// &
                    & TRIM(NUMBER_TO_VSTRING(interface_condition_idx,"*",ERR,ERROR))// &
                    & " is invalid. The interface condition index needs to be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(SOLVER_MAPPING%numberOfInterfaceConditions,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("Solver matrices solver mapping is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver matrices have not been finished.",ERR,ERROR,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver matrix solver matrices is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
      ELSE
        CALL FlagError("Interface matrix is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver matrix is not associated.",ERR,ERROR,*999)
    ENDIF
    
    EXITS("SolverMatrix_InterfaceMatrixAdd")
    RETURN
999 ERRORSEXITS("SolverMatrix_InterfaceMatrixAdd",ERR,ERROR)
    RETURN 1
    
  END SUBROUTINE SolverMatrix_InterfaceMatrixAdd

  !
  !================================================================================================================================
  !

  !>Adds alpha times the Jacobian matrix into the solver matrix
  SUBROUTINE SolverMatrix_JacobianMatrixAdd(SOLVER_MATRIX,equations_set_idx,ALPHA,jacobianMatrix,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX !<A pointer to the solver matrix
    INTEGER(INTG), INTENT(IN) :: equations_set_idx !<The equations set index in the solver mapping that contains the Jacobian matrix to add
    REAL(DP), INTENT(IN) :: ALPHA !<The multiplicative factor for the Jacobian matrix
    TYPE(EquationsJacobianType), POINTER :: jacobianMatrix !<A pointer to the Jacobian matrix to add    
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    REAL(DP), POINTER :: JACOBIAN_MATRIX_DATA(:)
    TYPE(DistributedMatrixType), POINTER :: JACOBIAN_DISTRIBUTED_MATRIX,SOLVER_DISTRIBUTED_MATRIX
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(JACOBIAN_TO_SOLVER_MAP_TYPE), POINTER :: JACOBIAN_TO_SOLVER_MAP
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    ENTERS("SolverMatrix_JacobianMatrixAdd",ERR,ERROR,*999)

    IF(ASSOCIATED(SOLVER_MATRIX)) THEN
      NULLIFY(SOLVER_MATRICES)
      NULLIFY(SOLVER_MAPPING)
      NULLIFY(nonlinearMatrices)
      NULLIFY(vectorMatrices)
      NULLIFY(JACOBIAN_TO_SOLVER_MAP)
      NULLIFY(SOLVER_DISTRIBUTED_MATRIX)
      NULLIFY(JACOBIAN_DISTRIBUTED_MATRIX)
      NULLIFY(JACOBIAN_MATRIX_DATA)

      IF(ASSOCIATED(jacobianMatrix)) THEN
        IF(ABS(ALPHA)>ZERO_TOLERANCE) THEN
          SOLVER_MATRICES=>SOLVER_MATRIX%SOLVER_MATRICES
          IF(ASSOCIATED(SOLVER_MATRICES)) THEN
            IF(SOLVER_MATRICES%SOLVER_MATRICES_FINISHED) THEN
              SOLVER_MAPPING=>SOLVER_MATRICES%solverMapping
              IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                nonlinearMatrices=>jacobianMatrix%nonlinearMatrices

                IF(ASSOCIATED(nonlinearMatrices)) THEN
                  vectorMatrices=>nonlinearMatrices%vectorMatrices
                  IF(ASSOCIATED(vectorMatrices)) THEN
                    IF(vectorMatrices%vectorMatricesFinished) THEN
                      IF(equations_set_idx>0.AND.equations_set_idx<=SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS) THEN
                        JACOBIAN_TO_SOLVER_MAP=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(SOLVER_MATRIX%matrixNumber)%JACOBIAN_TO_SOLVER_MATRIX_MAPS( &
                          & jacobianMatrix%jacobianNumber)%PTR
                        IF(ASSOCIATED(JACOBIAN_TO_SOLVER_MAP)) THEN
                          SOLVER_DISTRIBUTED_MATRIX=>SOLVER_MATRIX%MATRIX
                          IF(ASSOCIATED(SOLVER_DISTRIBUTED_MATRIX)) THEN
                            JACOBIAN_DISTRIBUTED_MATRIX=>jacobianMatrix%JACOBIAN
                            IF(ASSOCIATED(JACOBIAN_DISTRIBUTED_MATRIX)) THEN
                              CALL DistributedMatrix_MatrixCoupleAdd(SOLVER_DISTRIBUTED_MATRIX,SOLVER_MAPPING% &
                                & EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%equationsRowToSolverRowsMap, &
                                & JACOBIAN_TO_SOLVER_MAP%jacobianColToSolverColsMap,alpha,JACOBIAN_DISTRIBUTED_MATRIX, &
                                & .FALSE.,ERR,ERROR,*999)
                            ELSE
                              CALL FlagError("The Jacobian matrix distributed matrix is not associated",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Solver matrix distributed matrix is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Jacobian to solver map is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="The specified equations set index of "// &
                          & TRIM(NUMBER_TO_VSTRING(equations_set_idx,"*",ERR,ERROR))// &
                          & " is invalid. The equations set index needs to be between 1 and "// &
                          & TRIM(NUMBER_TO_VSTRING(SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS,"*",ERR,ERROR))//"."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Equations matrices have not been finished.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Nonlinear matrices equations matrices is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Jacobian matrix nonlinear matrices is not associated.",ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("Solver matrices solver mapping is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver matrices have not been finished.",ERR,ERROR,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver matrix solver matrices is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
      ELSE
        CALL FlagError("Jacobian matrix is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver matrix is not associated.",ERR,ERROR,*999)
    ENDIF
    
    EXITS("SolverMatrix_JacobianMatrixAdd")
    RETURN
999 ERRORSEXITS("SolverMatrix_JacobianMatrixAdd",ERR,ERROR)
    RETURN 1
  END SUBROUTINE SolverMatrix_JacobianMatrixAdd

  !
  !================================================================================================================================
  !

  !>Calculates the structure (sparsity) of the solver matrix from the soluton mapping.
  SUBROUTINE SOLVER_MATRIX_STRUCTURE_CALCULATE(SOLVER_MATRIX,NUMBER_OF_NON_ZEROS,ROW_INDICES,COLUMN_INDICES,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX !<A pointer to the solver matrix to calculate the structure for
    INTEGER(INTG), INTENT(OUT) :: NUMBER_OF_NON_ZEROS !<On return the number of non-zeros in the solver matrix
    INTEGER(INTG), POINTER :: ROW_INDICES(:) !<On return a pointer to row location indices in compressed row format. The pointers must be NULL on entry and the calling routine is responsible for deallocation.
    INTEGER(INTG), POINTER :: COLUMN_INDICES(:) !<On return a pointer to the column location indices in compressed row format. The pointers must be NULL on entry and the calling routine is responsible for deallocation.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,equations_matrix_idx, &
      & equations_set_idx,interface_condition_idx, &
      & interface_matrix_idx, &
      & MAX_COLUMN_INDICES,MAX_COLUMNS_PER_ROW,MAX_TRANSPOSE_COLUMNS_PER_ROW, &
      & NUMBER_OF_COLUMNS,solver_column_idx,solver_matrix_idx,solver_row_number
    INTEGER(INTG), ALLOCATABLE :: COLUMNS(:)
    REAL(DP) :: SPARSITY
    TYPE(DistributedMatrixType), POINTER :: DISTRIBUTED_MATRIX,SOLVER_DISTRIBUTED_MATRIX
    TYPE(EquationsJacobianType), POINTER :: jacobianMatrix
    TYPE(EquationsMatrixType), POINTER :: equationsMatrix
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatricesDynamicType), POINTER :: dynamicMatrices
    TYPE(EquationsMatricesLinearType), POINTER :: linearMatrices
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EQUATIONS_TO_SOLVER_MAPS_TYPE), POINTER :: EQUATIONS_TO_SOLVER_MAP
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(InterfaceMatrixType), POINTER :: INTERFACE_MATRIX
    TYPE(InterfaceMatricesType), POINTER :: INTERFACE_MATRICES    
    TYPE(INTERFACE_TO_SOLVER_MAPS_TYPE), POINTER :: INTERFACE_TO_SOLVER_MAP
    TYPE(JACOBIAN_TO_SOLVER_MAP_TYPE), POINTER :: JACOBIAN_TO_SOLVER_MAP
    TYPE(ListPtrType), ALLOCATABLE :: COLUMN_INDICES_LISTS(:)
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR
    
    ENTERS("SOLVER_MATRIX_STRUCTURE_CALCULATE",ERR,ERROR,*999)

    NUMBER_OF_NON_ZEROS=0
    IF(ASSOCIATED(SOLVER_MATRIX)) THEN
      IF(.NOT.ASSOCIATED(ROW_INDICES)) THEN
        IF(.NOT.ASSOCIATED(COLUMN_INDICES)) THEN
          SOLVER_DISTRIBUTED_MATRIX=>SOLVER_MATRIX%MATRIX
          IF(ASSOCIATED(SOLVER_DISTRIBUTED_MATRIX)) THEN
            IF(SOLVER_DISTRIBUTED_MATRIX%matrixFinished) THEN
              CALL FlagError("The solver distributed matrix has already been finished.",ERR,ERROR,*998)
            ELSE
              SOLVER_MATRICES=>SOLVER_MATRIX%SOLVER_MATRICES
              IF(ASSOCIATED(SOLVER_MATRICES)) THEN
                SOLVER_MAPPING=>SOLVER_MATRICES%solverMapping
                IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                  SELECT CASE(SOLVER_MATRIX%storageType)
                  CASE(DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE)
                    CALL FlagError("Can not calculate the structure for a block storage matrix.",ERR,ERROR,*999)
                  CASE(DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE)
                    CALL FlagError("Can not calcualte the structure for a diagonal matrix.",ERR,ERROR,*999)
                  CASE(DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE)
                    CALL FlagError("Not implemented.",ERR,ERROR,*999)
                  CASE(DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE)
                    CALL FlagError("Not implemented.",ERR,ERROR,*999)
                  CASE(DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE)
                    solver_matrix_idx=SOLVER_MATRIX%matrixNumber
                    !Find the maximum number of column indices
                    MAX_COLUMN_INDICES=0
                    DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                      !Loop over dynamic matrices mapped to the solver matrix
                      DO equations_matrix_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                        & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_DYNAMIC_EQUATIONS_MATRICES
                        EQUATIONS_TO_SOLVER_MAP=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS( &
                          & equations_matrix_idx)%PTR
                        IF(ASSOCIATED(EQUATIONS_TO_SOLVER_MAP)) THEN
                          equationsMatrix=>EQUATIONS_TO_SOLVER_MAP%EQUATIONS_MATRIX
                          IF(ASSOCIATED(equationsMatrix)) THEN
                            dynamicMatrices=>equationsMatrix%dynamicMatrices
                            IF(ASSOCIATED(dynamicMatrices)) THEN
                              vectorMatrices=>dynamicMatrices%vectorMatrices
                              IF(ASSOCIATED(vectorMatrices)) THEN
                                DISTRIBUTED_MATRIX=>equationsMatrix%MATRIX
                                IF(ASSOCIATED(DISTRIBUTED_MATRIX)) THEN
                                  CALL DistributedMatrix_MaxColumnsPerRowGet(DISTRIBUTED_MATRIX,MAX_COLUMNS_PER_ROW, &
                                    & ERR,ERROR,*999)
                                  MAX_COLUMN_INDICES=MAX_COLUMN_INDICES+MAX_COLUMNS_PER_ROW
                                ELSE
                                  CALL FlagError("Equations matrix distributed matrix is not associated.",ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Dynamic matrices equations matrices is not associated.",ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("Equations matrix dynamic matrices is not associated.",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Equations matrix is not assocaited.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Equations to solver matrix map is not assocaited.",ERR,ERROR,*999)
                        ENDIF
                      ENDDO !equations_matrix_idx
                      !Loop over linear matrices mapped to the solver matrix
                      DO equations_matrix_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                        & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_LINEAR_EQUATIONS_MATRICES
                        EQUATIONS_TO_SOLVER_MAP=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS( &
                          & equations_matrix_idx)%PTR
                        IF(ASSOCIATED(EQUATIONS_TO_SOLVER_MAP)) THEN
                          equationsMatrix=>EQUATIONS_TO_SOLVER_MAP%EQUATIONS_MATRIX
                          IF(ASSOCIATED(equationsMatrix)) THEN
                            linearMatrices=>equationsMatrix%linearMatrices
                            IF(ASSOCIATED(linearMatrices)) THEN
                              vectorMatrices=>linearMatrices%vectorMatrices
                              IF(ASSOCIATED(vectorMatrices)) THEN
                                DISTRIBUTED_MATRIX=>equationsMatrix%MATRIX
                                IF(ASSOCIATED(DISTRIBUTED_MATRIX)) THEN
                                  CALL DistributedMatrix_MaxColumnsPerRowGet(DISTRIBUTED_MATRIX,MAX_COLUMNS_PER_ROW, &
                                    & ERR,ERROR,*999)
                                  MAX_COLUMN_INDICES=MAX_COLUMN_INDICES+MAX_COLUMNS_PER_ROW
                                ELSE
                                  CALL FlagError("Equations matrix distributed matrix is not associated.",ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Linear matrices equations matrices is not associated.",ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("Equations matrix linear matrices is not associated.",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Equations matrix is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Equations to solver matrix map is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ENDDO !equations_matrix_idx
                      !Loop over Jacobian matrices mapped to the solver matrix
                      DO equations_matrix_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                        & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_EQUATIONS_JACOBIANS
                        JACOBIAN_TO_SOLVER_MAP=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%JACOBIAN_TO_SOLVER_MATRIX_MAPS( &
                          & equations_matrix_idx)%PTR
                        IF(ASSOCIATED(JACOBIAN_TO_SOLVER_MAP)) THEN
                          jacobianMatrix=>JACOBIAN_TO_SOLVER_MAP%JACOBIAN_MATRIX
                          IF(ASSOCIATED(jacobianMatrix)) THEN
                            nonlinearMatrices=>jacobianMatrix%nonlinearMatrices
                            IF(ASSOCIATED(nonlinearMatrices)) THEN
                              vectorMatrices=>nonlinearMatrices%vectorMatrices
                              IF(ASSOCIATED(vectorMatrices)) THEN
                                DISTRIBUTED_MATRIX=>jacobianMatrix%JACOBIAN
                                IF(ASSOCIATED(DISTRIBUTED_MATRIX)) THEN
                                  CALL DistributedMatrix_MaxColumnsPerRowGet(DISTRIBUTED_MATRIX,MAX_COLUMNS_PER_ROW, &
                                    & ERR,ERROR,*999)
                                  MAX_COLUMN_INDICES=MAX_COLUMN_INDICES+MAX_COLUMNS_PER_ROW
                                ELSE
                                  CALL FlagError("Jacobian distributed matrix is not associated.",ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Nonlinear matrices equations matrices is not associated.",ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("Jacobian matrix nonlinear matrices is not associated.",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Jacobian matrix is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ENDIF
                      ENDDO !equations_matrix_idx
                    ENDDO !equations_set_idx
                    !Loop over any interface conditions
                    DO interface_condition_idx=1,SOLVER_MAPPING%numberOfInterfaceConditions
                      INTERFACE_CONDITION=>SOLVER_MAPPING%interfaceConditions(interface_condition_idx)%PTR
                      SELECT CASE(INTERFACE_CONDITION%METHOD)
                      CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,INTERFACE_CONDITION_PENALTY_METHOD)
                        DO interface_matrix_idx=1,SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%numberOfInterfaceMatrices
                          INTERFACE_TO_SOLVER_MAP=>SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_conditioN_idx)% &
                            & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS( &
                            & interface_matrix_idx)%PTR
                          IF(ASSOCIATED(INTERFACE_TO_SOLVER_MAP)) THEN
                            INTERFACE_MATRIX=>INTERFACE_TO_SOLVER_MAP%interfaceMatrix
                            IF(ASSOCIATED(INTERFACE_MATRIX)) THEN
                              INTERFACE_MATRICES=>INTERFACE_MATRIX%interfaceMatrices
                              IF(ASSOCIATED(INTERFACE_MATRICES)) THEN
                                DISTRIBUTED_MATRIX=>INTERFACE_MATRIX%MATRIX
                                IF(ASSOCIATED(DISTRIBUTED_MATRIX)) THEN
                                  CALL DistributedMatrix_MaxColumnsPerRowGet(DISTRIBUTED_MATRIX,MAX_COLUMNS_PER_ROW, &
                                    & ERR,ERROR,*999)
                                ELSE
                                  CALL FlagError("Interface matrix distributed matrix is not associated.",ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Interface matrix interface matrices is not associated.",ERR,ERROR,*999)
                              ENDIF
                              MAX_TRANSPOSE_COLUMNS_PER_ROW=0
                              IF(INTERFACE_MATRIX%hasTranspose) THEN
                                DISTRIBUTED_MATRIX=>INTERFACE_MATRIX%matrixTranspose
                                IF(ASSOCIATED(DISTRIBUTED_MATRIX)) THEN
                                  CALL DistributedMatrix_MaxColumnsPerRowGet(DISTRIBUTED_MATRIX, &
                                    & MAX_TRANSPOSE_COLUMNS_PER_ROW,ERR,ERROR,*999)
                                ELSE
                                  CALL FlagError("Interface matrix distributed matrix transpose is not associated.",ERR,ERROR,*999)
                                ENDIF
                              ENDIF
                              MAX_COLUMN_INDICES=MAX_COLUMN_INDICES+MAX(MAX_COLUMNS_PER_ROW,MAX_TRANSPOSE_COLUMNS_PER_ROW)
                            ELSE
                              CALL FlagError("Interface to solver map interface matrix is not associated.",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Interface to solver matrix map is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ENDDO !interface_matrix_idx
                      CASE(INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD)
                        CALL FlagError("Not implemented.",ERR,ERROR,*999)
                      CASE(INTERFACE_CONDITION_POINT_TO_POINT_METHOD)
                        CALL FlagError("Not implemented.",ERR,ERROR,*999)
                      CASE DEFAULT
                        LOCAL_ERROR="The interface condition method of "// &
                          & TRIM(NUMBER_TO_VSTRING(INTERFACE_CONDITION%METHOD,"*",ERR,ERROR))// &
                          & " is invalid."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      END SELECT
                    ENDDO !interface_condition_idx
                    !Allocate lists
                    ALLOCATE(COLUMN_INDICES_LISTS(SOLVER_MAPPING%numberOfRows),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate column indices lists.",ERR,ERROR,*999)
                    !Allocate row indices
                    ALLOCATE(ROW_INDICES(SOLVER_MAPPING%numberOfRows+1),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate row indices.",ERR,ERROR,*999)
                    ROW_INDICES(1)=1
                    !Set up the column indicies lists
                    DO solver_row_number=1,SOLVER_MAPPING%numberOfRows
                      NULLIFY(COLUMN_INDICES_LISTS(solver_row_number)%PTR)
                      CALL LIST_CREATE_START(COLUMN_INDICES_LISTS(solver_row_number)%PTR,ERR,ERROR,*999)
                      CALL LIST_DATA_TYPE_SET(COLUMN_INDICES_LISTS(solver_row_number)%PTR,LIST_INTG_TYPE,ERR,ERROR,*999)
                      CALL LIST_INITIAL_SIZE_SET(COLUMN_INDICES_LISTS(solver_row_number)%PTR,MAX_COLUMN_INDICES,ERR,ERROR,*999)
                      CALL LIST_CREATE_FINISH(COLUMN_INDICES_LISTS(solver_row_number)%PTR,ERR,ERROR,*999)
                    ENDDO !solver_row_number
                    !Loop over the equations sets
                    DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                      !Loop over the dynamic equations matrices mapped to the solver matrix and calculate the col indices by row.
                      DO equations_matrix_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                        & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_DYNAMIC_EQUATIONS_MATRICES
                        !Note: pointers have been checked above
                        EQUATIONS_TO_SOLVER_MAP=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS( &
                          & equations_matrix_idx)%PTR
                        equationsMatrix=>EQUATIONS_TO_SOLVER_MAP%EQUATIONS_MATRIX
                        dynamicMatrices=>equationsMatrix%dynamicMatrices
                        vectorMatrices=>dynamicMatrices%vectorMatrices
                        DISTRIBUTED_MATRIX=>equationsMatrix%MATRIX

                        CALL DistributedMatrix_MatrixStructureCoupleCalculate(DISTRIBUTED_MATRIX,.FALSE.,SOLVER_MAPPING% &
                          & EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%equationsRowToSolverRowsMap, &
                          & EQUATIONS_TO_SOLVER_MAP%equationsColToSolverColsMap,COLUMN_INDICES_LISTS,err,error,*999)
                        
                      ENDDO !equations_matrix_idx
                      !Loop over the linear equations matrices mapped to the solver matrix and calculate the col indices by row.
                      DO equations_matrix_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                        & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_LINEAR_EQUATIONS_MATRICES
                        !Note: pointers have been checked above
                        EQUATIONS_TO_SOLVER_MAP=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS( &
                          & equations_matrix_idx)%PTR
                        equationsMatrix=>EQUATIONS_TO_SOLVER_MAP%EQUATIONS_MATRIX
                        linearMatrices=>equationsMatrix%linearMatrices
                        vectorMatrices=>linearMatrices%vectorMatrices
                        DISTRIBUTED_MATRIX=>equationsMatrix%MATRIX

                        CALL DistributedMatrix_MatrixStructureCoupleCalculate(DISTRIBUTED_MATRIX,.FALSE.,SOLVER_MAPPING% &
                          & EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%equationsRowToSolverRowsMap, &
                          & EQUATIONS_TO_SOLVER_MAP%equationsColToSolverColsMap,COLUMN_INDICES_LISTS,err,error,*999)
                        
                      ENDDO !equations_matrix_idx
                      !Now add any columns from the Jacobians
                      DO equations_matrix_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                        & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_EQUATIONS_JACOBIANS
                        JACOBIAN_TO_SOLVER_MAP=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%JACOBIAN_TO_SOLVER_MATRIX_MAPS( &
                          & equations_matrix_idx)%PTR
                        IF(ASSOCIATED(JACOBIAN_TO_SOLVER_MAP)) THEN
                          !Note: pointers have been checked above
                          jacobianMatrix=>JACOBIAN_TO_SOLVER_MAP%JACOBIAN_MATRIX
                          nonlinearMatrices=>jacobianMatrix%nonlinearMatrices
                          vectorMatrices=>nonlinearMatrices%vectorMatrices
                          DISTRIBUTED_MATRIX=>jacobianMatrix%JACOBIAN
                          
                          CALL DistributedMatrix_MatrixStructureCoupleCalculate(DISTRIBUTED_MATRIX,.FALSE.,SOLVER_MAPPING% &
                            & EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%equationsRowToSolverRowsMap, &
                            & JACOBIAN_TO_SOLVER_MAP%jacobianColToSolverColsMap,COLUMN_INDICES_LISTS,ERR,ERROR,*999)
                          
                        ENDIF
                      ENDDO !equations_matrix_idx
                      !Now add in any interface matrices columns
                      DO interface_condition_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                        & numberOfInterfaceConditions
                      ENDDO !interface_condition_idx
                    ENDDO !equations_set_idx
                    !Loop over any equations sets
                    DO interface_condition_idx=1,SOLVER_MAPPING%numberOfInterfaceConditions
                      INTERFACE_CONDITION=>SOLVER_MAPPING%interfaceConditions(interface_condition_idx)%PTR
                      SELECT CASE(INTERFACE_CONDITION%METHOD)
                      CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,INTERFACE_CONDITION_PENALTY_METHOD)
                        DO interface_matrix_idx=1,SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%numberOfInterfaceMatrices
                          INTERFACE_TO_SOLVER_MAP=>SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_conditioN_idx)% &
                            & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS( &
                            & interface_matrix_idx)%PTR
                          INTERFACE_MATRIX=>INTERFACE_TO_SOLVER_MAP%interfaceMatrix
                          INTERFACE_MATRICES=>INTERFACE_MATRIX%interfaceMatrices
                          DISTRIBUTED_MATRIX=>INTERFACE_MATRIX%MATRIX

                          CALL DistributedMatrix_MatrixStructureCoupleCalculate(DISTRIBUTED_MATRIX,.FALSE.,SOLVER_MAPPING% &
                            & INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)%INTERFACE_TO_SOLVER_MATRIX_MAPS_IM( &
                            & interface_matrix_idx)%interfaceRowToSolverRowsMap,SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP( &
                            & interface_condition_idx)%INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)% &
                            & interfaceColToSolverColsMap,COLUMN_INDICES_LISTS,ERR,ERROR,*999)

                          IF(INTERFACE_MATRIX%hasTranspose) THEN
                            DISTRIBUTED_MATRIX=>INTERFACE_MATRIX%matrixTranspose

                            CALL DistributedMatrix_MatrixStructureCoupleCalculate(DISTRIBUTED_MATRIX,.FALSE.,SOLVER_MAPPING% &
                              & INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)%interfaceColToSolverRowsMap, &
                              & INTERFACE_TO_SOLVER_MAP%interfaceRowToSolverColsMap,COLUMN_INDICES_LISTS,ERR,ERROR,*999)
                            
                          ENDIF
                        ENDDO !interface_matrix_idx
                      CASE(INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD)
                        CALL FlagError("Not implemented.",ERR,ERROR,*999)
                      CASE(INTERFACE_CONDITION_POINT_TO_POINT_METHOD)
                        CALL FlagError("Not implemented.",ERR,ERROR,*999)
                      CASE DEFAULT
                        LOCAL_ERROR="The interface condition method of "// &
                          & TRIM(NUMBER_TO_VSTRING(INTERFACE_CONDITION%METHOD,"*",ERR,ERROR))// &
                          & " is invalid."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      END SELECT                        
                    ENDDO !interface_condition_idx
                    !Loop over the rows to calculate the number of non-zeros and setup the row indicces
                    DO solver_row_number=1,SOLVER_MAPPING%numberOfRows
                      CALL LIST_REMOVE_DUPLICATES(COLUMN_INDICES_LISTS(solver_row_number)%PTR,ERR,ERROR,*999)
                      CALL LIST_NUMBER_OF_ITEMS_GET(COLUMN_INDICES_LISTS(solver_row_number)%PTR,NUMBER_OF_COLUMNS,ERR,ERROR,*999)
                      NUMBER_OF_NON_ZEROS=NUMBER_OF_NON_ZEROS+NUMBER_OF_COLUMNS
                      ROW_INDICES(solver_row_number+1)=NUMBER_OF_NON_ZEROS+1
                    ENDDO !solver_row_number
                    !Allocate and setup the column locations
                    ALLOCATE(COLUMN_INDICES(NUMBER_OF_NON_ZEROS),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate column indices.",ERR,ERROR,*999)
                    DO solver_row_number=1,SOLVER_MAPPING%numberOfRows
                      CALL LIST_DETACH_AND_DESTROY(COLUMN_INDICES_LISTS(solver_row_number)%PTR,NUMBER_OF_COLUMNS,COLUMNS, &
                        & ERR,ERROR,*999)
                      DO solver_column_idx=1,NUMBER_OF_COLUMNS
                        COLUMN_INDICES(ROW_INDICES(solver_row_number)+solver_column_idx-1)=COLUMNS(solver_column_idx)
                      ENDDO !solver_column_idx
                      DEALLOCATE(COLUMNS)
                    ENDDO !solver_row_idx
                  CASE(DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE)
                    CALL FlagError("Not implemented.",ERR,ERROR,*999)                        
                  CASE(DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE)
                    CALL FlagError("Not implemented.",ERR,ERROR,*999)                      
                  CASE DEFAULT
                    LOCAL_ERROR="The matrix storage type of "// &
                      & TRIM(NUMBER_TO_VSTRING(SOLVER_MATRIX%storageType,"*",ERR,ERROR))//" is invalid."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  END SELECT

                  IF(DIAGNOSTICS1) THEN
                    CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Solver matrix structure:",ERR,ERROR,*999)
                    CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"Solver matrix number : ",SOLVER_MATRIX%matrixNumber, &
                      & ERR,ERROR,*999)
                    CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of rows = ",SOLVER_MATRICES%numberOfRows, &
                      & ERR,ERROR,*999)
                    CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of columns = ",SOLVER_MATRIX%numberOfColumns, &
                      & ERR,ERROR,*999)
                    CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of non zeros = ",NUMBER_OF_NON_ZEROS,ERR,ERROR,*999)
                    IF(SOLVER_MATRICES%numberOfRows*SOLVER_MATRIX%numberOfColumns/=0) THEN
                      SPARSITY=REAL(NUMBER_OF_NON_ZEROS,DP)/REAL(SOLVER_MATRICES%numberOfRows* &
                        & SOLVER_MATRIX%numberOfColumns,DP)*100.0_DP
                      CALL WriteStringFmtValue(DIAGNOSTIC_OUTPUT_TYPE,"  Sparsity (%) = ",SPARSITY,"F6.2", ERR,ERROR,*999)
                    ENDIF
                    IF(DIAGNOSTICS2) THEN
                      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,SOLVER_MATRICES%numberOfRows+1,8,8,ROW_INDICES, &
                        & '("  Row indices    :",8(X,I13))','(18X,8(X,I13))',ERR,ERROR,*999)
                      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_NON_ZEROS,8,8,COLUMN_INDICES, &
                        & '("  Column indices :",8(X,I13))','(18X,8(X,I13))', ERR,ERROR,*999)
                    ENDIF
                  ENDIF
                ELSE
                  CALL FlagError("Solver matrices solver mapping is not associated",ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("Solver matrix solver matrices is not associated",ERR,ERROR,*999)
              ENDIF
            ENDIF
          ELSE
            CALL FlagError("Solver matrix distributed matrix is not associated",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FlagError("Column indices is already associated",ERR,ERROR,*998)
        ENDIF
      ELSE
        CALL FlagError("Row indices is already associated",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FlagError("Solver matrix is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("SOLVER_MATRIX_STRUCTURE_CALCULATE")
    RETURN
999 IF(ASSOCIATED(ROW_INDICES)) DEALLOCATE(ROW_INDICES)
    IF(ASSOCIATED(COLUMN_INDICES)) DEALLOCATE(COLUMN_INDICES)
    IF(ALLOCATED(COLUMNS)) DEALLOCATE(COLUMNS)
    IF(ALLOCATED(COLUMN_INDICES_LISTS)) THEN
      DO solver_row_number=1,SOLVER_MAPPING%numberOfRows
        IF(ASSOCIATED(COLUMN_INDICES_LISTS(solver_row_number)%PTR)) &
          & CALL LIST_DESTROY(COLUMN_INDICES_LISTS(solver_row_number)%PTR,DUMMY_ERR,DUMMY_ERROR,*998)
      ENDDO !solver_row_number
      DEALLOCATE(COLUMN_INDICES_LISTS)
    ENDIF
998 ERRORSEXITS("SOLVER_MATRIX_STRUCTURE_CALCULATE",ERR,ERROR)    
    RETURN 1
   
  END SUBROUTINE SOLVER_MATRIX_STRUCTURE_CALCULATE
        
  !
  !================================================================================================================================
  !

  !>Finalises a solver matrix and deallocates all memory
  SUBROUTINE SOLVER_MATRIX_FINALISE(SOLVER_MATRIX,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX !<A pointer to the solver matrix to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    
    ENTERS("SOLVER_MATRIX_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(SOLVER_MATRIX)) THEN
      IF(ASSOCIATED(SOLVER_MATRIX%MATRIX)) CALL DistributedMatrix_Destroy(SOLVER_MATRIX%MATRIX,ERR,ERROR,*999)
      IF(ASSOCIATED(SOLVER_MATRIX%SOLVER_VECTOR)) CALL DistributedVector_Destroy(SOLVER_MATRIX%SOLVER_VECTOR,ERR,ERROR,*999)
      DEALLOCATE(SOLVER_MATRIX)
    ENDIF
    
    EXITS("SOLVER_MATRIX_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_MATRIX_FINALISE",ERR,ERROR)    
    RETURN 1
   
  END SUBROUTINE SOLVER_MATRIX_FINALISE
        
  !
  !================================================================================================================================
  !

  !>Forms a solver matrix by initialising the structure of the matrix to zero.
  SUBROUTINE SOLVER_MATRIX_FORM(SOLVER_MATRIX,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX !<A pointer to the solver matrix to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    
    ENTERS("SOLVER_MATRIX_FORM",ERR,ERROR,*999)

    IF(ASSOCIATED(SOLVER_MATRIX)) THEN
      CALL DistributedMatrix_Form(SOLVER_MATRIX%MATRIX,ERR,ERROR,*999)
    ELSE
      CALL FlagError("Solver matrix is not associated.",ERR,ERROR,*999)
    ENDIF
    
    EXITS("SOLVER_MATRIX_FORM")
    RETURN
999 ERRORSEXITS("SOLVER_MATRIX_FORM",ERR,ERROR)    
    RETURN 1
   
  END SUBROUTINE SOLVER_MATRIX_FORM
        
    !
  !================================================================================================================================
  !

  !>Initialises a solver matrix
  SUBROUTINE SOLVER_MATRIX_INITIALISE(SOLVER_MATRICES,MATRIX_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES !<A pointer to the solver matrices to initialise
    INTEGER(INTG), INTENT(IN) :: MATRIX_NUMBER !<The matrix number in the solver matrices to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR
    
    ENTERS("SOLVER_MATRIX_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(SOLVER_MATRICES)) THEN
      IF(MATRIX_NUMBER>0.AND.MATRIX_NUMBER<=SOLVER_MATRICES%NUMBER_OF_MATRICES) THEN
        SOLVER_MAPPING=>SOLVER_MATRICES%solverMapping
        IF(ASSOCIATED(SOLVER_MAPPING)) THEN
          IF(ASSOCIATED(SOLVER_MATRICES%MATRICES(MATRIX_NUMBER)%PTR)) THEN
            CALL FlagError("Solver matrix is already associated.",ERR,ERROR,*998)
          ELSE
            ALLOCATE(SOLVER_MATRICES%MATRICES(MATRIX_NUMBER)%PTR,STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate solver matrix.",ERR,ERROR,*999)
            SOLVER_MATRIX=>SOLVER_MATRICES%MATRICES(MATRIX_NUMBER)%PTR
            SOLVER_MATRIX%matrixNumber=MATRIX_NUMBER
            SOLVER_MATRIX%SOLVER_MATRICES=>SOLVER_MATRICES
            SOLVER_MATRIX%storageType=MATRIX_BLOCK_STORAGE_TYPE
            SOLVER_MATRIX%updateMatrix=.TRUE.
            SOLVER_MATRIX%numberOfColumns=SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(MATRIX_NUMBER)%numberOfColumns
            SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(MATRIX_NUMBER)%SOLVER_MATRIX=>SOLVER_MATRIX
            NULLIFY(SOLVER_MATRIX%SOLVER_VECTOR)
            NULLIFY(SOLVER_MATRIX%MATRIX)
          ENDIF
        ELSE
          CALL FlagError("Solver mapping is not associated.",ERR,ERROR,*998)
        ENDIF
      ELSE
        LOCAL_ERROR="The specified matrix number of "//TRIM(NUMBER_TO_VSTRING(MATRIX_NUMBER,"*",ERR,ERROR))// &
          & " is invalid. The number must be > 0 and <= "// &
          & TRIM(NUMBER_TO_VSTRING(SOLVER_MATRICES%NUMBER_OF_MATRICES,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FlagError("Solver matrices is not associated.",ERR,ERROR,*998)
    ENDIF
    
    EXITS("SOLVER_MATRIX_INITIALISE")
    RETURN
999 CALL SOLVER_MATRIX_FINALISE(SOLVER_MATRICES%MATRICES(MATRIX_NUMBER)%PTR,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("SOLVER_MATRIX_INITIALISE",ERR,ERROR)    
    RETURN 1
   
  END SUBROUTINE SOLVER_MATRIX_INITIALISE
        
  !
  !================================================================================================================================
  !

END MODULE SOLVER_MATRICES_ROUTINES
