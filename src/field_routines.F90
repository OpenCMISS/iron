!> \file
!> \author Chris Bradley
!> \brief This module handles all field related routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s): Chris Bradley
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!> 

!> This module handles all field related routines.
MODULE FieldRoutines

  USE BaseRoutines
  USE BasisRoutines
  USE BasisAccessRoutines
  USE ComputationRoutines
  USE ComputationAccessRoutines
  USE Constants
  USE CoordinateSystemRoutines
  USE CoordinateSystemAccessRoutines
  USE CmissMPI
  USE DecompositionRoutines
  USE DecompositionAccessRoutines
  USE DistributedMatrixVector
  USE DistributedMatrixVectorAccessRoutines
  USE DomainMappings
  USE FieldAccessRoutines
  USE Kinds
  USE InputOutput
  USE InterfaceAccessRoutines
  USE ISO_VARYING_STRING
  USE Lists
  USE Maths
#ifndef NOMPIMOD
  USE MPI
#endif
  USE Strings
  USE Types

#include "macros.h"  

  IMPLICIT NONE

#ifdef NOMPIMOD
#include "mpif.h"
#endif

  PRIVATE

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Sets/changes the label for a field variable component.
  INTERFACE Field_ComponentLabelSet
    MODULE PROCEDURE Field_ComponentLabelSetC
    MODULE PROCEDURE Field_ComponentLabelSetVS
  END INTERFACE Field_ComponentLabelSet

  !>Sets/changes the label for a field variable component and locks so that no further changes can be made.
  INTERFACE Field_ComponentLabelSetAndLock
    MODULE PROCEDURE Field_ComponentLabelSetAndLockC
    MODULE PROCEDURE Field_ComponentLabelSetAndLockVS
  END INTERFACE Field_ComponentLabelSetAndLock

  !>Initialises the values of parameter set of a field variable component to a constant value.
  INTERFACE Field_ComponentValuesInitialise
    MODULE PROCEDURE Field_ComponentValuesInitialiseIntg
    MODULE PROCEDURE Field_ComponentValuesInitialiseSP
    MODULE PROCEDURE Field_ComponentValuesInitialiseDP
    MODULE PROCEDURE Field_ComponentValuesInitialiseL
  END INTERFACE Field_ComponentValuesInitialise

  !>Starts the process of creating a field
  INTERFACE Field_CreateStart
    MODULE PROCEDURE Field_CreateStartInterface
    MODULE PROCEDURE Field_CreateStartRegion
  END INTERFACE Field_CreateStart

  !>Sets/changes the label for a field.
  INTERFACE Field_LabelSet
    MODULE PROCEDURE Field_LabelSetC
    MODULE PROCEDURE Field_LabelSetVS
  END INTERFACE Field_LabelSet

  !>Sets/changes the label for a field and locks so that no further changes can be made.
  INTERFACE Field_LabelSetAndLock
    MODULE PROCEDURE Field_LabelSetAndLockC
    MODULE PROCEDURE Field_LabelSetAndLockVS
  END INTERFACE Field_LabelSetAndLock

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type.
  INTERFACE Field_ParameterSetsAdd
    MODULE PROCEDURE Field_ParameterSetsAddDP0
    MODULE PROCEDURE Field_ParameterSetsAddDP1
  END INTERFACE Field_ParameterSetsAdd

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE Field_ParameterSetAddConstant
    MODULE PROCEDURE Field_ParameterSetAddConstantIntg
    MODULE PROCEDURE Field_ParameterSetAddConstantSP
    MODULE PROCEDURE Field_ParameterSetAddConstantDP
    MODULE PROCEDURE Field_ParameterSetAddConstantL
  END INTERFACE Field_ParameterSetAddConstant

  !>Adds the given value to the given parameter set for a particular local dof of the field variable.
  INTERFACE Field_ParameterSetAddLocalDOF
    MODULE PROCEDURE Field_ParameterSetAddLocalDOFIntg
    MODULE PROCEDURE Field_ParameterSetAddLocalDOFSP
    MODULE PROCEDURE Field_ParameterSetAddLocalDOFDP
    MODULE PROCEDURE Field_ParameterSetAddLocalDOFL
  END INTERFACE Field_ParameterSetAddLocalDOF

  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE Field_ParameterSetAddElement
    MODULE PROCEDURE Field_ParameterSetAddElementIntg
    MODULE PROCEDURE Field_ParameterSetAddElementSP
    MODULE PROCEDURE Field_ParameterSetAddElementDP
    MODULE PROCEDURE Field_ParameterSetAddElementL
  END INTERFACE Field_ParameterSetAddElement

  !>Adds the given value to the given parameter set for a particular Gauss point of a user element of the field variable component.
  INTERFACE Field_ParameterSetAddGaussPoint
    MODULE PROCEDURE Field_ParameterSetAddGaussPointIntg
    MODULE PROCEDURE Field_ParameterSetAddGaussPointSP
    MODULE PROCEDURE Field_ParameterSetAddGaussPointDP
    MODULE PROCEDURE Field_ParameterSetAddGaussPointL
  END INTERFACE Field_ParameterSetAddGaussPoint

  !>Adds the given value to the given parameter set for a particular local element of the field variable component.
  INTERFACE Field_ParameterSetAddLocalElement
    MODULE PROCEDURE Field_ParameterSetAddLocalElementIntg
    MODULE PROCEDURE Field_ParameterSetAddLocalElementSP
    MODULE PROCEDURE Field_ParameterSetAddLocalElementDP
    MODULE PROCEDURE Field_ParameterSetAddLocalElementL
  END INTERFACE Field_ParameterSetAddLocalElement

  !>Adds the given value to the given parameter set for a particular local node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetAddLocalNode
    MODULE PROCEDURE Field_ParameterSetAddLocalNodeIntg
    MODULE PROCEDURE Field_ParameterSetAddLocalNodeSP
    MODULE PROCEDURE Field_ParameterSetAddLocalNodeDP
    MODULE PROCEDURE Field_ParameterSetAddLocalNodeL
  END INTERFACE Field_ParameterSetAddLocalNode

  !>Adds the given value to the given parameter set for a particular user node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetAddNode
    MODULE PROCEDURE Field_ParameterSetAddNodeIntg
    MODULE PROCEDURE Field_ParameterSetAddNodeSP
    MODULE PROCEDURE Field_ParameterSetAddNodeDP
    MODULE PROCEDURE Field_ParameterSetAddNodeL
  END INTERFACE Field_ParameterSetAddNode

  !>Returns a pointer to the specified field parameter set array. The pointer must be restored with a call to FieldRoutines::Field_ParameterSetDataGet call. Note: the values can be used for read operations but a Field_ParameterSetUpdate call must be used to change any values.
  INTERFACE Field_ParameterSetDataGet
    MODULE PROCEDURE Field_ParameterSetDataGetIntg
    MODULE PROCEDURE Field_ParameterSetDataGetSP
    MODULE PROCEDURE Field_ParameterSetDataGetDP
    MODULE PROCEDURE Field_ParameterSetDataGetL
  END INTERFACE Field_ParameterSetDataGet

  !>Restores the specified field variable parameter set array that was obtained with FieldRoutines::Field_ParameterSetDataGet.
  INTERFACE Field_ParameterSetDataRestore
    MODULE PROCEDURE Field_ParameterSetDataRestoreIntg
    MODULE PROCEDURE Field_ParameterSetDataRestoreSP
    MODULE PROCEDURE Field_ParameterSetDataRestoreDP
    MODULE PROCEDURE Field_ParameterSetDataRestoreL
  END INTERFACE Field_ParameterSetDataRestore

  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE Field_ParameterSetGetConstant
    MODULE PROCEDURE Field_ParameterSetGetConstantIntg
    MODULE PROCEDURE Field_ParameterSetGetConstantSP
    MODULE PROCEDURE Field_ParameterSetGetConstantDP
    MODULE PROCEDURE Field_ParameterSetGetConstantL
  END INTERFACE Field_ParameterSetGetConstant

  !>Returns from the given parameter set a value for the specified data point of a field variable component.
  INTERFACE Field_ParameterSetGetDataPoint
    MODULE PROCEDURE Field_ParameterSetGetDataPointIntg
    MODULE PROCEDURE Field_ParameterSetGetDataPointSp
    MODULE PROCEDURE Field_ParameterSetGetDataPointDp
    MODULE PROCEDURE Field_ParameterSetGetDataPointL
  END INTERFACE Field_ParameterSetGetDataPoint

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE Field_ParameterSetGetElement
    MODULE PROCEDURE Field_ParameterSetGetElementIntg
    MODULE PROCEDURE Field_ParameterSetGetElementSP
    MODULE PROCEDURE Field_ParameterSetGetElementDP
    MODULE PROCEDURE Field_ParameterSetGetElementL
  END INTERFACE Field_ParameterSetGetElement

  !>Returns from the given parameter set a value for the specified user element and Gauss point of a field variable component.  TODO: sp/int/l versions
  INTERFACE Field_ParameterSetGetGaussPoint
    MODULE PROCEDURE Field_ParameterSetGetGaussPointIntg
    MODULE PROCEDURE Field_ParameterSetGetGaussPointSP
    MODULE PROCEDURE Field_ParameterSetGetGaussPointDP
    MODULE PROCEDURE Field_ParameterSetGetGaussPointL
  END INTERFACE Field_ParameterSetGetGaussPoint

   !>Returns the given parameter set value for a particular local dof of the field variable.
  INTERFACE Field_ParameterSetGetLocalDOF
    MODULE PROCEDURE Field_ParameterSetGetLocalDOFIntg
    MODULE PROCEDURE Field_ParameterSetGetLocalDOFSP
    MODULE PROCEDURE Field_ParameterSetGetLocalDOFDP
    MODULE PROCEDURE Field_ParameterSetGetLocalDOFL
  END INTERFACE Field_ParameterSetGetLocalDOF

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetLocalElement
    MODULE PROCEDURE Field_ParameterSetGetLocalElementIntg
    MODULE PROCEDURE Field_ParameterSetGetLocalElementSP
    MODULE PROCEDURE Field_ParameterSetGetLocalElementDP
    MODULE PROCEDURE Field_ParameterSetGetLocalElementL
  END INTERFACE Field_ParameterSetGetLocalElement

  !>Returns from the given parameter set a value for the specified local element and Gauss point of a field variable component. 
  INTERFACE Field_ParameterSetGetLocalGaussPoint
    MODULE PROCEDURE Field_ParameterSetGetLocalGaussPointIntg
    MODULE PROCEDURE Field_ParameterSetGetLocalGaussPointSP
    MODULE PROCEDURE Field_ParameterSetGetLocalGaussPointDP
    MODULE PROCEDURE Field_ParameterSetGetLocalGaussPointL
  END INTERFACE Field_ParameterSetGetLocalGaussPoint

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetLocalNode
    MODULE PROCEDURE Field_ParameterSetGetLocalNodeIntg
    MODULE PROCEDURE Field_ParameterSetGetLocalNodeSP
    MODULE PROCEDURE Field_ParameterSetGetLocalNodeDP
    MODULE PROCEDURE Field_ParameterSetGetLocalNodeL
  END INTERFACE Field_ParameterSetGetLocalNode

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetNode
    MODULE PROCEDURE Field_ParameterSetGetNodeIntg
    MODULE PROCEDURE Field_ParameterSetGetNodeSP
    MODULE PROCEDURE Field_ParameterSetGetNodeDP
    MODULE PROCEDURE Field_ParameterSetGetNodeL
  END INTERFACE Field_ParameterSetGetNode

  !>Interpolates the given parameter set at the specified gauss point number for the specified element and derviative. \todo Update FieldInterpolatedPointType to include values array for other data types eg sp/int and then add ability to Field_ParameterSetInterpolateXi with these data types
  INTERFACE Field_ParameterSetInterpolateGauss
    MODULE PROCEDURE Field_ParameterSetInterpolateGaussDP0
    MODULE PROCEDURE Field_ParameterSetInterpolateGaussDP1
  END INTERFACE Field_ParameterSetInterpolateGauss

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative. \todo Update FieldInterpolatedPointType to include values array for other data types eg sp/int and then add ability to Field_ParameterSetInterpolateXi with these data types
  INTERFACE Field_ParameterSetInterpolateXi
    MODULE PROCEDURE Field_ParameterSetInterpolateXiDP0
    MODULE PROCEDURE Field_ParameterSetInterpolateXiDP1
  END INTERFACE Field_ParameterSetInterpolateXi

   !>Updates the given parameter set with the given value for the constant of the field variable component.
  INTERFACE Field_ParameterSetUpdateConstant
    MODULE PROCEDURE Field_ParameterSetUpdateConstantIntg
    MODULE PROCEDURE Field_ParameterSetUpdateConstantSP
    MODULE PROCEDURE Field_ParameterSetUpdateConstantDP
    MODULE PROCEDURE Field_ParameterSetUpdateConstantL
  END INTERFACE Field_ParameterSetUpdateConstant

  !>Updates the given parameter set a value for the specified data point of a field variable component.
  INTERFACE Field_ParameterSetUpdateDataPoint
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointSp
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointDp
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointL
  END INTERFACE Field_ParameterSetUpdateDataPoint

  !>Updates the given parameter set with the given value for a particular user element of the field variable component.
  INTERFACE Field_ParameterSetUpdateElement
    MODULE PROCEDURE Field_ParameterSetUpdateElementIntg
    MODULE PROCEDURE Field_ParameterSetUpdateElementSP
    MODULE PROCEDURE Field_ParameterSetUpdateElementDP
    MODULE PROCEDURE Field_ParameterSetUpdateElementL
  END INTERFACE Field_ParameterSetUpdateElement

  !>Updates the given parameter set with the given value for a particular element and data point of the field variable component.
  INTERFACE Field_ParameterSetUpdateElementDataPoint
    MODULE PROCEDURE Field_ParameterSetUpdateElementDataPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateElementDataPointSP
    MODULE PROCEDURE Field_ParameterSetUpdateElementDataPointDP
    MODULE PROCEDURE Field_ParameterSetUpdateElementDataPointL
  END INTERFACE Field_ParameterSetUpdateElementDataPoint

  !>Updates the given parameter set with the given value for a particular element and gauss point of the field variable component. 
  INTERFACE Field_ParameterSetUpdateGaussPoint
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointSP
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointDP
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointL
  END INTERFACE Field_ParameterSetUpdateGaussPoint

  !>Updates the given parameter set a value for the specified local data point of a field variable component.
  INTERFACE Field_ParameterSetUpdateLocalDataPoint
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointSp
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointDp
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointL
  END INTERFACE Field_ParameterSetUpdateLocalDataPoint

  !>Updates the given parameter set with the given value for a particular local dof of the field variable.
  INTERFACE Field_ParameterSetUpdateLocalDOF
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDOFIntg
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDOFSP
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDOFDP
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDOFL
  END INTERFACE Field_ParameterSetUpdateLocalDOF

  !>Updates the given parameter set with the given value for a particular local element of the field variable component.
  INTERFACE Field_ParameterSetUpdateLocalElement
    MODULE PROCEDURE Field_ParameterSetUpdateLocalElementIntg
    MODULE PROCEDURE Field_ParameterSetUpdateLocalElementSP
    MODULE PROCEDURE Field_ParameterSetUpdateLocalElementDP
    MODULE PROCEDURE Field_ParameterSetUpdateLocalElementL
  END INTERFACE Field_ParameterSetUpdateLocalElement

  !>Updates the given parameter set with the given value for a particular local element and gauss point of the field variable component. 
  INTERFACE Field_ParameterSetUpdateLocalGaussPoint
    MODULE PROCEDURE Field_ParameterSetUpdateLocalGaussPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateLocalGaussPointSP
    MODULE PROCEDURE Field_ParameterSetUpdateLocalGaussPointDP
    MODULE PROCEDURE Field_ParameterSetUpdateLocalGaussPointL
  END INTERFACE Field_ParameterSetUpdateLocalGaussPoint

  !>Updates the given parameter set with the given value for a particular local node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetUpdateLocalNode
    MODULE PROCEDURE Field_ParameterSetUpdateLocalNodeIntg
    MODULE PROCEDURE Field_ParameterSetUpdateLocalNodeSP
    MODULE PROCEDURE Field_ParameterSetUpdateLocalNodeDP
    MODULE PROCEDURE Field_ParameterSetUpdateLocalNodeL
  END INTERFACE Field_ParameterSetUpdateLocalNode

  !>Updates the given parameter set with the given value for a particular user node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetUpdateNode
    MODULE PROCEDURE Field_ParameterSetUpdateNodeIntg
    MODULE PROCEDURE Field_ParameterSetUpdateNodeSP
    MODULE PROCEDURE Field_ParameterSetUpdateNodeDP
    MODULE PROCEDURE Field_ParameterSetUpdateNodeL
  END INTERFACE Field_ParameterSetUpdateNode

  !>Sets/changes the label for a field variable type.
  INTERFACE Field_VariableLabelSet
    MODULE PROCEDURE Field_VariableLabelSetC
    MODULE PROCEDURE Field_VariableLabelSetVS
  END INTERFACE Field_VariableLabelSet

  !>Sets/changes the label for a field variable type and locks so that no further changes can be made.
  INTERFACE Field_VariableLabelSetAndLock
    MODULE PROCEDURE Field_VariableLabelSetAndLockC
    MODULE PROCEDURE Field_VariableLabelSetAndLockVS
  END INTERFACE Field_VariableLabelSetAndLock

  !>Sets/changes the field variable types and locks so that no further changes can be made.
  INTERFACE Field_VariableTypesSetAndLock
    MODULE PROCEDURE Field_VariableTypesSetAndLock0
    MODULE PROCEDURE Field_VariableTypesSetAndLock1
  END INTERFACE Field_VariableTypesSetAndLock

  !>Sets/changes the field variable types.
  INTERFACE Field_VariableTypesSet
    MODULE PROCEDURE Field_VariableTypesSet0
    MODULE PROCEDURE Field_VariableTypesSet1
  END INTERFACE Field_VariableTypesSet

  !>Initialises the values of parameter set of a field variable component to a constant value.
  INTERFACE FieldVariable_ComponentValuesInitialise
    MODULE PROCEDURE FieldVariable_ComponentValuesInitialiseIntg
    MODULE PROCEDURE FieldVariable_ComponentValuesInitialiseSP
    MODULE PROCEDURE FieldVariable_ComponentValuesInitialiseDP
    MODULE PROCEDURE FieldVariable_ComponentValuesInitialiseL
  END INTERFACE FieldVariable_ComponentValuesInitialise

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE FieldVariable_ParameterSetAddConstant
    MODULE PROCEDURE FieldVariable_ParameterSetAddConstantIntg
    MODULE PROCEDURE FieldVariable_ParameterSetAddConstantSP
    MODULE PROCEDURE FieldVariable_ParameterSetAddConstantDP
    MODULE PROCEDURE FieldVariable_ParameterSetAddConstantL
  END INTERFACE FieldVariable_ParameterSetAddConstant
  
  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE FieldVariable_ParameterSetAddElement
    MODULE PROCEDURE FieldVariable_ParameterSetAddElementIntg
    MODULE PROCEDURE FieldVariable_ParameterSetAddElementSP
    MODULE PROCEDURE FieldVariable_ParameterSetAddElementDP
    MODULE PROCEDURE FieldVariable_ParameterSetAddElementL
  END INTERFACE FieldVariable_ParameterSetAddElement

  !>Adds the given value to the given parameter set for a particular Gauss point of a user element of the field variable component.
  INTERFACE FieldVariable_ParameterSetAddGaussPoint
    MODULE PROCEDURE FieldVariable_ParameterSetAddGaussPointIntg
    MODULE PROCEDURE FieldVariable_ParameterSetAddGaussPointSP
    MODULE PROCEDURE FieldVariable_ParameterSetAddGaussPointDP
    MODULE PROCEDURE FieldVariable_ParameterSetAddGaussPointL
  END INTERFACE FieldVariable_ParameterSetAddGaussPoint

  !>Adds the given value to the given parameter set for a particular local dof of the field variable.
  INTERFACE FieldVariable_ParameterSetAddLocalDOF
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalDOFIntg
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalDOFSP
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalDOFDP
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalDOFL
  END INTERFACE FieldVariable_ParameterSetAddLocalDOF

  !>Adds the given value to the given parameter set for a particular local element of the field variable component.
  INTERFACE FieldVariable_ParameterSetAddLocalElement
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalElementIntg
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalElementSP
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalElementDP
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalElementL
  END INTERFACE FieldVariable_ParameterSetAddLocalElement

  !>Adds the given value to the given parameter set for a particular local node, derivative and version of the field variable component.
  INTERFACE FieldVariable_ParameterSetAddLocalNode
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalNodeIntg
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalNodeSP
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalNodeDP
    MODULE PROCEDURE FieldVariable_ParameterSetAddLocalNodeL
  END INTERFACE FieldVariable_ParameterSetAddLocalNode
  
  !>Adds the given value to the given parameter set for a particular user node, derivative and version of the field variable component.
  INTERFACE FieldVariable_ParameterSetAddNode
    MODULE PROCEDURE FieldVariable_ParameterSetAddNodeIntg
    MODULE PROCEDURE FieldVariable_ParameterSetAddNodeSP
    MODULE PROCEDURE FieldVariable_ParameterSetAddNodeDP
    MODULE PROCEDURE FieldVariable_ParameterSetAddNodeL
  END INTERFACE FieldVariable_ParameterSetAddNode

  !>Returns a pointer to the specified field variable parameter set array. The pointer must be restored with a call to FieldRoutines::FieldVariable_ParameterSetDataGet call. Note: the values can be used for read operations but a FieldVariable_ParameterSetUpdate call must be used to change any values.
  INTERFACE FieldVariable_ParameterSetDataGet
    MODULE PROCEDURE FieldVariable_ParameterSetDataGetIntg
    MODULE PROCEDURE FieldVariable_ParameterSetDataGetSP
    MODULE PROCEDURE FieldVariable_ParameterSetDataGetDP
    MODULE PROCEDURE FieldVariable_ParameterSetDataGetL
  END INTERFACE FieldVariable_ParameterSetDataGet

  !>Restores the specified field variable parameter set array that was obtained with FieldRoutines::FieldVariable_ParameterSetDataGet.
  INTERFACE FieldVariable_ParameterSetDataRestore
    MODULE PROCEDURE FieldVariable_ParameterSetDataRestoreIntg
    MODULE PROCEDURE FieldVariable_ParameterSetDataRestoreSP
    MODULE PROCEDURE FieldVariable_ParameterSetDataRestoreDP
    MODULE PROCEDURE FieldVariable_ParameterSetDataRestoreL
  END INTERFACE FieldVariable_ParameterSetDataRestore

  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE FieldVariable_ParameterSetGetConstant
    MODULE PROCEDURE FieldVariable_ParameterSetGetConstantIntg
    MODULE PROCEDURE FieldVariable_ParameterSetGetConstantSP
    MODULE PROCEDURE FieldVariable_ParameterSetGetConstantDP
    MODULE PROCEDURE FieldVariable_ParameterSetGetConstantL
  END INTERFACE FieldVariable_ParameterSetGetConstant

  !>Returns from the given parameter set a value for the specified data point of a field variable component.
  INTERFACE FieldVariable_ParameterSetGetDataPoint
    MODULE PROCEDURE FieldVariable_ParameterSetGetDataPointIntg
    MODULE PROCEDURE FieldVariable_ParameterSetGetDataPointSp
    MODULE PROCEDURE FieldVariable_ParameterSetGetDataPointDp
    MODULE PROCEDURE FieldVariable_ParameterSetGetDataPointL
  END INTERFACE FieldVariable_ParameterSetGetDataPoint

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE FieldVariable_ParameterSetGetElement
    MODULE PROCEDURE FieldVariable_ParameterSetGetElementIntg
    MODULE PROCEDURE FieldVariable_ParameterSetGetElementSP
    MODULE PROCEDURE FieldVariable_ParameterSetGetElementDP
    MODULE PROCEDURE FieldVariable_ParameterSetGetElementL
  END INTERFACE FieldVariable_ParameterSetGetElement

  !>Returns from the given parameter set a value for the specified user element and Gauss point of a field variable component.  TODO: sp/int/l versions
  INTERFACE FieldVariable_ParameterSetGetGaussPoint
    MODULE PROCEDURE FieldVariable_ParameterSetGetGaussPointIntg
    MODULE PROCEDURE FieldVariable_ParameterSetGetGaussPointSP
    MODULE PROCEDURE FieldVariable_ParameterSetGetGaussPointDP
    MODULE PROCEDURE FieldVariable_ParameterSetGetGaussPointL
  END INTERFACE FieldVariable_ParameterSetGetGaussPoint

  !>Returns the given parameter set value for a particular local dof of the field variable.
  INTERFACE FieldVariable_ParameterSetGetLocalDOF
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalDOFIntg
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalDOFSP
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalDOFDP
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalDOFL
  END INTERFACE FieldVariable_ParameterSetGetLocalDOF

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE FieldVariable_ParameterSetGetLocalElement
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalElementIntg
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalElementSP
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalElementDP
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalElementL
  END INTERFACE FieldVariable_ParameterSetGetLocalElement

  !>Returns from the given parameter set a value for the specified local element and Gauss point of a field variable component. 
  INTERFACE FieldVariable_ParameterSetGetLocalGaussPoint
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalGaussPointIntg
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalGaussPointSP
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalGaussPointDP
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalGaussPointL
  END INTERFACE FieldVariable_ParameterSetGetLocalGaussPoint

   !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE FieldVariable_ParameterSetGetLocalNode
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalNodeIntg
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalNodeSP
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalNodeDP
    MODULE PROCEDURE FieldVariable_ParameterSetGetLocalNodeL
  END INTERFACE FieldVariable_ParameterSetGetLocalNode

 !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE FieldVariable_ParameterSetGetNode
    MODULE PROCEDURE FieldVariable_ParameterSetGetNodeIntg
    MODULE PROCEDURE FieldVariable_ParameterSetGetNodeSP
    MODULE PROCEDURE FieldVariable_ParameterSetGetNodeDP
    MODULE PROCEDURE FieldVariable_ParameterSetGetNodeL
  END INTERFACE FieldVariable_ParameterSetGetNode

 !>Interpolates the given parameter set at the specified gauss point number for the specified element and derviative. \todo Update FieldInterpolatedPointType to include values array for other data types eg sp/int and then add ability to FieldVariable_ParameterSetInterpolateXi with these data types
  INTERFACE FieldVariable_ParameterSetInterpolateGauss
    MODULE PROCEDURE FieldVariable_ParameterSetInterpolateGaussDP0
    MODULE PROCEDURE FieldVariable_ParameterSetInterpolateGaussDP1
  END INTERFACE FieldVariable_ParameterSetInterpolateGauss

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative. \todo Update FieldInterpolatedPointType to include values array for other data types eg sp/int and then add ability to Field_ParameterSetInterpolateXi with these data types
  INTERFACE FieldVariable_ParameterSetInterpolateXi
    MODULE PROCEDURE FieldVariable_ParameterSetInterpolateXiDP0
    MODULE PROCEDURE FieldVariable_ParameterSetInterpolateXiDP1
  END INTERFACE FieldVariable_ParameterSetInterpolateXi

    !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type.
  INTERFACE FieldVariable_ParameterSetsAdd
    MODULE PROCEDURE FieldVariable_ParameterSetsAddDP0
    MODULE PROCEDURE FieldVariable_ParameterSetsAddDP1
  END INTERFACE FieldVariable_ParameterSetsAdd

  !>Updates the given parameter set with the given value for the constant of the field variable component.
  INTERFACE FieldVariable_ParameterSetUpdateConstant
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateConstantIntg
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateConstantSP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateConstantDP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateConstantL
  END INTERFACE FieldVariable_ParameterSetUpdateConstant

  !>Updates the given parameter set a value for the specified data point of a field variable component.
  INTERFACE FieldVariable_ParameterSetUpdateDataPoint
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateDataPointIntg
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateDataPointSP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateDataPointDP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateDataPointL
  END INTERFACE FieldVariable_ParameterSetUpdateDataPoint

  !>Updates the given parameter set with the given value for a particular user element of the field variable component.
  INTERFACE FieldVariable_ParameterSetUpdateElement
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateElementIntg
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateElementSP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateElementDP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateElementL
  END INTERFACE FieldVariable_ParameterSetUpdateElement

  !>Updates the given parameter set with the given value for a particular element and data point of the field variable component.
  INTERFACE FieldVariable_ParameterSetUpdateElementDataPoint
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateElementDataPointIntg
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateElementDataPointSP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateElementDataPointDP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateElementDataPointL
  END INTERFACE FieldVariable_ParameterSetUpdateElementDataPoint

  !>Updates the given parameter set with the given value for a particular user element and gauss point of the field variable component. 
  INTERFACE FieldVariable_ParameterSetUpdateGaussPoint
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateGaussPointIntg
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateGaussPointSP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateGaussPointDP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateGaussPointL
  END INTERFACE FieldVariable_ParameterSetUpdateGaussPoint

  !>Updates the given parameter set with the given value for a particular local dof of the field variable.
  INTERFACE FieldVariable_ParameterSetUpdateLocalDOF
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalDOFIntg
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalDOFSP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalDOFDP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalDOFL
  END INTERFACE FieldVariable_ParameterSetUpdateLocalDOF

  !>Updates the given parameter set with the given value for a particular local data point of the field variable component.
  INTERFACE FieldVariable_ParameterSetUpdateLocalDataPoint
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalDataPointIntg
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalDataPointSP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalDataPointDP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalDataPointL
  END INTERFACE FieldVariable_ParameterSetUpdateLocalDataPoint

  !>Updates the given parameter set with the given value for a particular local element of the field variable component.
  INTERFACE FieldVariable_ParameterSetUpdateLocalElement
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalElementIntg
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalElementSP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalElementDP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalElementL
  END INTERFACE FieldVariable_ParameterSetUpdateLocalElement

  !>Updates the given parameter set with the given value for a particular local element and gauss point of the field variable component. 
  INTERFACE FieldVariable_ParameterSetUpdateLocalGaussPoint
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalGaussPointIntg
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalGaussPointSP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalGaussPointDP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalGaussPointL
  END INTERFACE FieldVariable_ParameterSetUpdateLocalGaussPoint

  !>Updates the given parameter set with the given value for a particular local node, derivative and version of the field variable component.
  INTERFACE FieldVariable_ParameterSetUpdateLocalNode
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalNodeIntg
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalNodeSP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalNodeDP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateLocalNodeL
  END INTERFACE FieldVariable_ParameterSetUpdateLocalNode

  !>Updates the given parameter set with the given value for a particular user node, derivative and version of the field variable component.
  INTERFACE FieldVariable_ParameterSetUpdateNode
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateNodeIntg
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateNodeSP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateNodeDP
    MODULE PROCEDURE FieldVariable_ParameterSetUpdateNodeL
  END INTERFACE FieldVariable_ParameterSetUpdateNode

  !>Initialises the fields.
  INTERFACE Fields_Initialise
    MODULE PROCEDURE Fields_InitialiseInterface
    MODULE PROCEDURE Fields_InitialiseRegion
  END INTERFACE Fields_Initialise

  PUBLIC Field_ComponentInterpolationSet,Field_ComponentInterpolationSetAndLock

  PUBLIC Field_ComponentLabelSet,Field_ComponentLabelSetAndLock

  PUBLIC Field_ComponentMeshComponentSet,Field_ComponentMeshComponentSetAndLock

  PUBLIC Field_ComponentValuesInitialise

  PUBLIC Field_CreateFinish,Field_CreateStart

  PUBLIC Field_DataProjectionSet

  PUBLIC Field_DataTypeSet,Field_DataTypeSetAndLock

  PUBLIC Field_DecompositionSet,Field_DecompositionSetAndLock

  PUBLIC Field_DependentTypeSet,Field_DependentTypeSetAndLock

  PUBLIC Field_Destroy

  PUBLIC Field_DimensionSet,Field_DimensionSetAndLock

  PUBLIC Field_DOFOrderTypeSet,Field_DOFOrderTypeSetAndLock

  PUBLIC Field_GeometricFieldSet,Field_GeometricFieldSetAndLock

  PUBLIC Field_GeometricParametersElementLineLengthGet

  PUBLIC Field_GeometricParametersElementVolumeGet

  PUBLIC Field_InterpolateGauss

  PUBLIC Field_InterpolateFieldNode

  PUBLIC Field_InterpolateFieldVariableNode

  PUBLIC Field_InterpolateNode

  PUBLIC Field_InterpolateLocalFaceGauss

  PUBLIC Field_InterpolateXi

  PUBLIC Field_InterpolationParametersFinalise,Field_InterpolationParametersInitialise
  
  PUBLIC Field_InterpolationParametersElementGet

  PUBLIC Field_InterpolationParametersFaceGet

  PUBLIC Field_InterpolationParametersLineGet

  PUBLIC Field_InterpolatedPointMetricsCalculate

  PUBLIC Field_InterpolatedPointFinalise,Field_InterpolatedPointInitialise
  
  PUBLIC Field_InterpolatedPointMetricsFinalise,Field_InterpolatedPointMetricsInitialise
  
  PUBLIC Field_InterpolatedPointsFinalise,Field_InterpolatedPointsInitialise

  PUBLIC Field_InterpolatedPointsMetricsFinalise,Field_InterpolatedPointsMetricsInitialise

  PUBLIC Field_InterpolationParametersScaleFactorsElementGet

  PUBLIC Field_InterpolationParametersScaleFactorsFaceGet

  PUBLIC Field_InterpolationParametersScaleFactorsLineGet

  PUBLIC Field_LabelSet,Field_LabelSetAndLock

  PUBLIC Field_NumberOfComponentsSet,Field_NumberOfComponentsSetAndLock

  PUBLIC Field_NumberOfVariablesSet,Field_NumberOfVariablesSetAndLock

  PUBLIC Field_ParameterSetsAdd

  PUBLIC Field_ParameterSetsCopy

  PUBLIC Field_ParameterSetsCopyIfExists

  PUBLIC Field_ParameterSetDestroy

  PUBLIC Field_ParametersToFieldParametersCopy

  PUBLIC Field_ParameterSetAddConstant

  PUBLIC Field_ParameterSetAddElement

  PUBLIC Field_ParameterSetAddGaussPoint

  PUBLIC Field_ParameterSetAddLocalDOF

  PUBLIC Field_ParameterSetAddLocalElement

  PUBLIC Field_ParameterSetAddLocalNode

  PUBLIC Field_ParameterSetAddNode

  PUBLIC Field_ParameterSetCreate

  PUBLIC Field_ParameterSetCreated

  PUBLIC Field_ParameterSetEnsureCreated

  PUBLIC Field_ParameterSetDataGet

  PUBLIC Field_ParameterSetDataRestore

  PUBLIC Field_ParameterSetGetConstant

  PUBLIC Field_ParameterSetGetDataPoint

  PUBLIC Field_ParameterSetGetElement

  PUBLIC Field_ParameterSetGetGaussPoint

  PUBLIC Field_ParameterSetGetLocalDOF

  PUBLIC Field_ParameterSetGetLocalElement

  PUBLIC Field_ParameterSetGetLocalGaussPoint

  PUBLIC Field_ParameterSetGetLocalNode

  PUBLIC Field_ParameterSetGetNode

  PUBLIC Field_ParameterSetInterpolateXi

  PUBLIC Field_ParameterSetInterpolateGauss

  PUBLIC Field_ParameterSetOutput

  PUBLIC Field_ParameterSetUpdateFinish,Field_ParameterSetUpdateStart

  PUBLIC Field_ParameterSetUpdateConstant

  PUBLIC Field_ParameterSetUpdateDataPoint

  PUBLIC Field_ParameterSetUpdateElement

  PUBLIC Field_ParameterSetUpdateElementDataPoint

  PUBLIC Field_ParameterSetUpdateGaussPoint

  PUBLIC Field_ParameterSetUpdateLocalDataPoint

  PUBLIC Field_ParameterSetUpdateLocalDOF

  PUBLIC Field_ParameterSetUpdateLocalElement

  PUBLIC Field_ParameterSetUpdateLocalGaussPoint

  PUBLIC Field_ParameterSetUpdateLocalNode

  PUBLIC Field_ParameterSetUpdateNode

  PUBLIC Field_ParameterSetNodeScaleFactorGet,Field_ParameterSetNodeScaleFactorSet

  PUBLIC Field_ParameterSetNodeScaleFactorsGet,Field_ParameterSetNodeScaleFactorsSet

  PUBLIC Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  PUBLIC Field_ParameterSetVectorGet

  PUBLIC Field_PhysicalPointFinalise,Field_PhysicalPointInitialise

  PUBLIC Field_PhysicalPointsFinalise,Field_PhysicalPointsInitialise

  PUBLIC Field_PositionNormalTangentsCalculateNode

  PUBLIC Field_PositionNormalTangentsCalculateIntPtMetric

  PUBLIC Field_ScalingTypeSet,Field_ScalingTypeSetAndLock

  PUBLIC Field_TypeSet,Field_TypeSetAndLock

  PUBLIC Field_VariableLabelSet,Field_VariableLabelSetAndLock

  PUBLIC Field_VariableTypesSet,Field_VariableTypesSetAndLock

  PUBLIC FieldVariable_ComponentInterpolationCheck

  PUBLIC FieldVariable_ComponentValuesInitialise

  PUBLIC FieldVariable_InterpolationParameterFinalise,FieldVariable_InterpolationParameterInitialise
  
  PUBLIC FieldVariable_ParameterSetAddConstant

  PUBLIC FieldVariable_ParameterSetAddElement
  
  PUBLIC FieldVariable_ParameterSetAddGaussPoint
  
  PUBLIC FieldVariable_ParameterSetAddLocalDOF
  
  PUBLIC FieldVariable_ParameterSetAddLocalElement
  
  PUBLIC FieldVariable_ParameterSetAddLocalNode
  
  PUBLIC FieldVariable_ParameterSetAddNode
  
  PUBLIC FieldVariable_ParameterSetCreate
  
  PUBLIC FieldVariable_ParameterSetEnsureCreated,FieldVariable_ParameterSetCreated

  PUBLIC FieldVariable_ParameterSetDestroy

  PUBLIC FieldVariable_ParameterSetDataGet

  PUBLIC FieldVariable_ParameterSetDataRestore

  PUBLIC FieldVariable_ParameterSetGet

  PUBLIC FieldVariable_ParameterSetGetConstant

  PUBLIC FieldVariable_ParameterSetGetDataPoint

  PUBLIC FieldVariable_ParameterSetGetElement

  PUBLIC FieldVariable_ParameterSetGetGaussPoint

  PUBLIC FieldVariable_ParameterSetGetLocalDOF

  PUBLIC FieldVariable_ParameterSetGetLocalElement

  PUBLIC FieldVariable_ParameterSetGetLocalGaussPoint

  PUBLIC FieldVariable_ParameterSetGetLocalNode

  PUBLIC FieldVariable_ParameterSetGetNode

  PUBLIC FieldVariable_ParameterSetInterpolateGauss

  PUBLIC FieldVariable_ParameterSetInterpolateXi

  PUBLIC FieldVariable_ParameterSetOutput

  PUBLIC FieldVariable_ParameterSetsAdd

  PUBLIC FieldVariable_ParameterSetsCopy

  PUBLIC FieldVariable_ParameterSetsCopyIfExists

  PUBLIC FieldVariable_ParameterSetUpdateConstant

  PUBLIC FieldVariable_ParameterSetUpdateDataPoint

  PUBLIC FieldVariable_ParameterSetUpdateElement

  PUBLIC FieldVariable_ParameterSetUpdateElementDataPoint

  PUBLIC FieldVariable_ParameterSetUpdateFinish

  PUBLIC FieldVariable_ParameterSetUpdateGaussPoint

  PUBLIC FieldVariable_ParameterSetUpdateLocalDataPoint

  PUBLIC FieldVariable_ParameterSetUpdateLocalDOF

  PUBLIC FieldVariable_ParameterSetUpdateLocalElement

  PUBLIC FieldVariable_ParameterSetUpdateLocalGaussPoint

  PUBLIC FieldVariable_ParameterSetUpdateLocalNode

  PUBLIC FieldVariable_ParameterSetUpdateNode

  PUBLIC FieldVariable_ParameterSetUpdateStart

  PUBLIC FieldVariable_ParameterSetVectorGet

  PUBLIC FieldVariable_ParametersToFieldVariableParametersCopy

  PUBLIC FieldVariablesList_CreateStart,FieldVariablesList_CreateFinish

  PUBLIC FieldVariablesList_Destroy
  
  PUBLIC FieldVariablesList_NumberOfVariablesGet
  
  PUBLIC FieldVariablesList_VariableAdd
  
  PUBLIC FieldVariablesList_VariableGet
  
  PUBLIC FieldVariablesList_VariableInListCheck

  PUBLIC Fields_AddField
  
  PUBLIC Fields_Finalise,Fields_Initialise
  
  PUBLIC MeshEmbedding_PushData, MeshEmbedding_PullGaussPointData, Field_ParameterSetGetGaussPointCoord

CONTAINS

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component. \see OpenCMISS::Iron::cmfe_Field_ComponentInterpolationSet
  SUBROUTINE Field_ComponentInterpolationSet(field,variableType,componentNumber,interpolationType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type of the field variable component to set \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number of the field variable component to set
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set \see FieldRoutines_InterpolationTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ComponentInterpolationSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " is invalid. The variable type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ANY(createValuesCache%variableTypes==variableType)) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " has not been created on field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF      
    IF(componentNumber<1.OR.componentNumber>createValuesCache%numberOfComponents(variableType)) THEN
      localError="The specified component number of "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & ". The component number should be >=1 and <= "// &
        & TRIM(NumberToVString(createValuesCache%numberOfComponents(variableType),"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF      
    IF(createValuesCache%interpolationTypesLocked(componentNumber,variableType)) THEN
      localError="The interpolation type has been locked for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    SELECT CASE(interpolationType)                
    CASE(FIELD_CONSTANT_INTERPOLATION)
      createValuesCache%interpolationTypes(componentNumber,variableType)=interpolationType
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      createValuesCache%interpolationTypes(componentNumber,variableType)=interpolationType
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      createValuesCache%interpolationTypes(componentNumber,variableType)=interpolationType
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      createValuesCache%interpolationTypes(componentNumber,variableType)=interpolationType
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      createValuesCache%interpolationTypes(componentNumber,variableType)=interpolationType
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      createValuesCache%interpolationTypes(componentNumber,variableType)=interpolationType
    CASE DEFAULT
      localError="The specified interpolation type of "// &
        & TRIM(NumberToVString(interpolationType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ComponentInterpolationSet")
    RETURN
999 ERRORSEXITS("Field_ComponentInterpolationSet",err,error)
    RETURN 1

  END SUBROUTINE Field_ComponentInterpolationSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component and locks so that no further changes can be made.
  SUBROUTINE Field_ComponentInterpolationSetAndLock(field,variableType,componentNumber,interpolationType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type of the field variable component to set \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number of the field variable component to set
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set \see FieldRoutines_InterpolationTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_ComponentInterpolationSetAndLock",err,error,*999)

    CALL Field_ComponentInterpolationSet(field,variableType,componentNumber,interpolationType,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%interpolationTypesLocked(componentNumber,variableType)=.TRUE.

    EXITS("Field_ComponentInterpolationSetAndLock")
    RETURN
999 ERRORSEXITS("Field_ComponentInterpolationSetAndLock",err,error)
    RETURN 1

  END SUBROUTINE Field_ComponentInterpolationSetAndLock
 
  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable component for character labels. \see OpenCMISS::Iron::cmfe_Field_ComponentLabelSet
  SUBROUTINE Field_ComponentLabelSetC(field,variableType,componentNumber,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to get
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ComponentLabelSetC",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " is invalid. The variable type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ANY(createValuesCache%variableTypes==variableType)) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " has not been created on field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF      
    IF(componentNumber<1.OR.componentNumber>createValuesCache%numberOfComponents(variableType)) THEN
      localError="The specified component number of "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & ". The component number should be >=1 and <= "// &
        & TRIM(NumberToVString(createValuesCache%numberOfComponents(variableType),"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF      
    IF(createValuesCache%componentLabelsLocked(componentNumber,variableType)) THEN
      localError="The component label has been locked for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    createValuesCache%componentLabels(componentNumber,variableType)=label

    EXITS("Field_ComponentLabelSetC")
    RETURN
999 ERRORSEXITS("Field_ComponentLabelSetC",err,error)
    RETURN 1

  END SUBROUTINE Field_ComponentLabelSetC

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable component for varying string labels. \see OpenCMISS::Iron::cmfe_Field_ComponentLabelSet
  SUBROUTINE Field_ComponentLabelSetVS(field,variableType,componentNumber,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to get
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ComponentLabelSetVS",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " is invalid. The variable type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ANY(createValuesCache%variableTypes==variableType)) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " has not been created on field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF      
    IF(componentNumber<1.OR.componentNumber>createValuesCache%numberOfComponents(variableType)) THEN
      localError="The specified component number of "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & ". The component number should be >=1 and <= "// &
        & TRIM(NumberToVString(createValuesCache%numberOfComponents(variableType),"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF      
    IF(createValuesCache%componentLabelsLocked(componentNumber,variableType)) THEN
      localError="The component label has been locked for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    field%createValuesCache%componentLabels(componentNumber,variableType)=label
 
    EXITS("Field_ComponentLabelSetVS")
    RETURN
999 ERRORSEXITS("Field_ComponentLabelSetVS",err,error)
    RETURN 1

  END SUBROUTINE Field_ComponentLabelSetVS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels and locks so that no further changes can be made.
  SUBROUTINE Field_ComponentLabelSetAndLockC(field,variableType,componentNumber,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to get
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_ComponentLabelSetAndLockC",err,error,*999)

    CALL Field_ComponentLabelSet(field,variableType,componentNumber,label,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%componentLabelsLocked(componentNumber,variableType)=.TRUE.

    EXITS("Field_ComponentLabelSetAndLockC")
    RETURN
999 ERRORSEXITS("Field_ComponentLabelSetAndLockC",err,error)
    RETURN 1

  END SUBROUTINE Field_ComponentLabelSetAndLockC

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels and locks so that no further changes can be made.
  SUBROUTINE Field_ComponentLabelSetAndLockVS(field,variableType,componentNumber,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to get
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_ComponentLabelSetAndLockVS",err,error,*999)

    CALL Field_ComponentLabelSet(field,variableType,componentNumber,label,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%componentLabelsLocked(componentNumber,variableType)=.TRUE.

    EXITS("Field_ComponentLabelSetAndLockVS")
    RETURN
999 ERRORSEXITS("Field_ComponentLabelSetAndLockVS",err,error)
    RETURN 1

  END SUBROUTINE Field_ComponentLabelSetAndLockVS

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component. \see OpenCMISS::Iron::cmfe_Field_ComponentMeshComponentSet
  SUBROUTINE Field_ComponentMeshComponentSet(field,variableType,componentNumber,meshComponentNumber,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the mesh component for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component to set for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ComponentMeshComponentSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " is invalid. The variable type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ANY(createValuesCache%variableTypes==variableType)) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " has not been created on field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF      
    IF(componentNumber<1.OR.componentNumber>createValuesCache%numberOfComponents(variableType)) THEN
      localError="The specified component number of "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & ". The component number should be >=1 and <= "// &
        & TRIM(NumberToVString(createValuesCache%numberOfComponents(variableType),"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF      
    IF(createValuesCache%meshComponentNumberLocked(componentNumber,variableType)) THEN
      localError="The mesh component has been locked for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    SELECT CASE(createValuesCache%interpolationTypes(componentNumber,variableType))
    CASE(FIELD_CONSTANT_INTERPOLATION,FIELD_ELEMENT_BASED_INTERPOLATION,FIELD_NODE_BASED_INTERPOLATION, &
      & FIELD_GRID_POINT_BASED_INTERPOLATION,FIELD_GAUSS_POINT_BASED_INTERPOLATION, FIELD_DATA_POINT_BASED_INTERPOLATION)
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(field,decomposition,err,error,*999)
      IF(meshComponentNumber<1.OR.meshComponentNumber>decomposition%numberOfComponents) THEN
        localError="The specified mesh component number of "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
          & " is invalid. The mesh component number must be between 1 and "// &
          & TRIM(NumberToVString(decomposition%numberOfComponents,"*",err,error))// &
          & " for decomposition number "//TRIM(NumberToVString(decomposition%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      createValuesCache%meshComponentNumber(componentNumber,variableType)=meshComponentNumber
    CASE DEFAULT
      localError="The interpolation type "// &
        & TRIM(NumberToVString(createValuesCache%interpolationTypes(componentNumber,variableType),"*",err,error))// &
        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ComponentMeshComponentSet")
    RETURN
999 ERRORSEXITS("Field_ComponentMeshComponentSet",err,error)
    RETURN 1

  END SUBROUTINE Field_ComponentMeshComponentSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component and locks it so that no further changes can be made.
  SUBROUTINE Field_ComponentMeshComponentSetAndLock(field,variableType,componentNumber,meshComponentNumber,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the mesh component for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component to set for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_ComponentMeshComponentSetAndLock",err,error,*999)

    CALL Field_ComponentMeshComponentSet(field,variableType,componentNumber,meshComponentNumber,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%meshComponentNumberLocked(componentNumber,variableType)=.TRUE.
 
    EXITS("Field_ComponentMeshComponentSetAndLock")
    RETURN
999 ERRORS("Field_ComponentMeshComponentSetAndLock",err,error)
    EXITS("Field_ComponentMeshComponentSetAndLock")
    RETURN 1

  END SUBROUTINE Field_ComponentMeshComponentSetAndLock

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a constant integer value. \see OpenCMISS::Iron::cmfe_Field_ComponentValuesInitialise
  SUBROUTINE Field_ComponentValuesInitialiseIntg(field,variableType,fieldSetType,componentNumber,initValue,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to intialise \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to initialise \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to initialise
    INTEGER(INTG), INTENT(IN) :: initValue !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ComponentValuesInitialiseIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ComponentValuesInitialise(fieldVariable,fieldSetType,componentNumber,initValue,err,error,*999)

    EXITS("Field_ComponentValuesInitialiseIntg")
    RETURN
999 ERRORSEXITS("Field_ComponentValuesInitialiseIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ComponentValuesInitialiseIntg

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value. \see OpenCMISS::Iron::cmfe_Field_ComponentValuesInitialise
  SUBROUTINE Field_ComponentValuesInitialiseSP(field,variableType,fieldSetType,componentNumber,initValue,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to intiialise \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to initialise \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to initialise
    REAL(SP), INTENT(IN) :: initValue !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ComponentValuesInitialiseSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ComponentValuesInitialise(fieldVariable,fieldSetType,componentNumber,initValue,err,error,*999)

    EXITS("Field_ComponentValuesInitialiseSP")
    RETURN
999 ERRORSEXITS("Field_ComponentValuesInitialiseSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ComponentValuesInitialiseSP

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value. \see OpenCMISS::Iron::cmfe_Field_ComponentValuesInitialise
  SUBROUTINE Field_ComponentValuesInitialiseDP(field,variableType,fieldSetType,componentNumber,initValue,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to intiialise \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to initialise \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to initialise
    REAL(DP), INTENT(IN) :: initValue !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ComponentValuesInitialiseDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ComponentValuesInitialise(fieldVariable,fieldSetType,componentNumber,initValue,err,error,*999)

    EXITS("Field_ComponentValuesInitialiseDP")
    RETURN
999 ERRORSEXITS("Field_ComponentValuesInitialiseDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ComponentValuesInitialiseDP

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value. \see OpenCMISS::Iron::cmfe_Field_ComponentValuesInitialise
  SUBROUTINE Field_ComponentValuesInitialiseL(field,variableType,fieldSetType,componentNumber,initValue,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to intiialise \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to initialise \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to initialise
    LOGICAL, INTENT(IN) :: initValue !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ComponentValuesInitialiseL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ComponentValuesInitialise(fieldVariable,fieldSetType,componentNumber,initValue,err,error,*999)
 
    EXITS("Field_ComponentValuesInitialiseL")
    RETURN
999 ERRORSEXITS("Field_ComponentValuesInitialiseL",err,error)
    RETURN 1

  END SUBROUTINE Field_ComponentValuesInitialiseL

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field. \see OpenCMISS::Iron::cmfe_Field_CreateFinish
  SUBROUTINE Field_CreateFinish(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,parameterSetIdx,scalingIdx,variableIdx
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: geometricField

    ENTERS("Field_CreateFinish",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    !Check field has a decomposition associated
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    !Check for field validity
    CALL Field_VariablesCheck(field,err,error,*999)
    !Initialise the components
    CALL Field_VariablesInitialise(field,err,error,*999)
    !Check geometric field
    NULLIFY(geometricField)
    CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
    CALL Field_CreateValuesCacheFinalise(field%createValuesCache,err,error,*999)
    field%fieldFinished=.TRUE.
    !Calculate dof mappings
    CALL Field_MappingsCalculate(field,err,error,*999)
    !Set up the geometric parameters
    CALL Field_GeometricParametersInitialise(field,err,error,*999)
    !Initialise the scalings
    CALL Field_ScalingsInitialise(field,err,error,*999)
    !Initialise the field parameter sets 
    CALL Field_ParametersSetsInitialise(field,err,error,*999)

    IF(diagnostics1) THEN
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"Field number : ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Global number = ",field%globalNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  User number = ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Label = ",field%label,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Dependent type = ",field%dependentType,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field type = ",field%type,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of variables = ",field%numberOfVariables,err,error,*999)
      IF(diagnostics2) THEN
        DO variableIdx=1,field%numberOfVariables
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Variable : ",variableIdx,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Variable Type = ",variableIdx,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Variable Label = ",field%variables(variableIdx)%variableLabel, &
            & err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Dimension = ",field%variables(variableIdx)%dimension, &
            & err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Data type = ",field%variables(variableIdx)%dataType, &
            & err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      DOF order type = ",field%variables(variableIdx)%dofOrderType, &
            & err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Max num element interpolation parameters = ",field% &
            & variables(variableIdx)%maxNumberElementInterpolationParameters,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Max num node interpolation parameters = ",field% &
            & variables(variableIdx)%maxNumberNodeInterpolationParameters,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of DOFs = ",field%variables(variableIdx)% &
            & numberOfDofs,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Total number of DOFs = ",field%variables(variableIdx)% &
            & totalNumberOfDofs,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of global DOFs = ",field%variables(variableIdx)% &
            & numberOfGlobalDofs,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of components = ",field%variables(variableIdx)% &
            & numberOfComponents,err,error,*999)
          IF(diagnostics3) THEN
            DO componentIdx=1,field%variables(variableIdx)%numberOfComponents
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Component : ",componentIdx,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Component label = ",field%variables(variableIdx)% &
                components(componentIdx)%componentLabel,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Interpolation type = ",field%variables(variableIdx)% &
                components(componentIdx)%interpolationType,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Mesh component number = ",field%variables(variableIdx)% &
                components(componentIdx)%meshComponentNumber,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Scaling index = ",field%variables(variableIdx)% &
                components(componentIdx)%scalingIndex,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Max num element interpolation parameters = ",field% &
                & variables(variableIdx)%components(componentIdx)%maxNumberElementInterpolationParameters,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Max num node interpolation parameters = ",field% &
                & variables(variableIdx)%components(componentIdx)%maxNumberNodeInterpolationParameters,err,error,*999)         
            ENDDO !componentIdx
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameter sets = ",field%variables(variableIdx)% &
            & parameterSets%numberOfParameterSets,err,error,*999)
          IF(diagnostics3) THEN
            DO parameterSetIdx=1,field%variables(variableIdx)%parameterSets%numberOfParameterSets
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Parameter set index : ",parameterSetIdx,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Set type : ",field%variables(variableIdx)% &
                & parameterSets%parameterSets(parameterSetIdx)%ptr%setType,err,error,*999)
            ENDDO !parameterSetIdx
          ENDIF
        ENDDO !variableIdx
      ENDIF
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Scaling type = ",field%scalings%scalingType,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of scaling indices = ",field%scalings%numberOfScalingIndices, &
        & err,error,*999)
      IF(diagnostics2) THEN
        DO scalingIdx=1,field%scalings%numberOfScalingIndices
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Scaling index : ",scalingIdx,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Mesh component number : ",field%scalings%scalings(scalingIdx)% &
            & meshComponentNumber,err,error,*999)
        ENDDO !scalingIdx
      ENDIF
    ENDIF

    EXITS("Field_CreateFinish")
    RETURN
999 ERRORSEXITS("Field_CreateFinish",err,error)
    RETURN 1

  END SUBROUTINE Field_CreateFinish

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field.
  SUBROUTINE Field_CreateStartGeneric(fields,userNumber,field,err,error,*)

    !Argument variables
    TYPE(FieldsType), POINTER :: fields !<A pointer to the fields
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number for the field to create
    TYPE(FieldType), POINTER :: field !<On return, a pointer to the field. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: fieldIdx
    TYPE(FieldType), POINTER :: newField
    TYPE(FieldPtrType), ALLOCATABLE :: newFields(:)

    NULLIFY(newField)

    ENTERS("Field_CreateStartGeneric",err,error,*998)

    IF(.NOT.ASSOCIATED(fields)) CALL FlagError("Fields is not associated.",err,error,*998)
    IF(ASSOCIATED(field)) CALL FlagError("Field is already associated.",err,error,*998)
    
    !Set default field properties
    CALL Field_Initialise(newField,err,error,*999)
    newField%globalNumber=fields%numberOfFields+1
    newField%userNumber=userNumber
    newField%label="Field "//TRIM(NumberToVString(userNumber,"*",err,error))
    IF(err/=0) GOTO 999
    newField%fields=>fields
    NULLIFY(newField%region)
    NULLIFY(newField%interface)
    newField%geometricField=>newField
    newField%numberOfVariables=1
    newField%scalings%scalingType=FIELD_ARITHMETIC_MEAN_SCALING
    newField%scalings%numberOfScalingIndices=0
    NULLIFY(newField%createValuesCache)
    !Add new field into list of fields 
    ALLOCATE(newFields(fields%numberOfFields+1),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate new fields.",err,error,*999)
    DO fieldIdx=1,fields%numberOfFields
      newFields(fieldIdx)%ptr=>fields%fields(fieldIdx)%ptr
    ENDDO !fieldIdx
    newFields(fields%numberOfFields+1)%ptr=>newField
    CALL MOVE_ALLOC(newFields,fields%fields)
    fields%numberOfFields=fields%numberOfFields+1
    field=>newField

    EXITS("Field_CreateStartGeneric")
    RETURN
999 IF(ASSOCIATED(newField)) DEALLOCATE(newField)
    IF(ALLOCATED(newFields)) DEALLOCATE(newFields)
    NULLIFY(field)
998 ERRORSEXITS("Field_CreateStartGeneric",err,error)
    RETURN 1

  END SUBROUTINE Field_CreateStartGeneric

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field defined by a user number in the specified interface. \see OpenCMISS::Iron::cmfe_Field_CreateStart
  !>Default values set for the FIELD's attributes are:
  !>- DEPENDENT_TYPE: 1 (FIELD_INDEPENDENT_TYPE)
  !>- DIMENSION: 2 (FIELD_VECTOR_DIMENSION_TYPE)
  !>- TYPE: 1 (FIELD_GEOMETRIC_TYPE)
  !>- NUMBER_OF_VARIABLES: 1
  !>- GEOMETRIC_FIELD: itself
  !>- SCALINGS%scalingType: 3 (FIELD_ARITHMETIC_MEAN_SCALING)
  !>\todo Add in Field_Initialise
  SUBROUTINE Field_CreateStartInterface(userNumber,interface,field,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number for the field
    TYPE(InterfaceType), POINTER :: interface !<A pointer to the interface in which to create the field
    TYPE(FieldType), POINTER :: field !<On return, a pointer to the field being created. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError    

    ENTERS("Field_CreateStartInterface",err,error,*999)

    IF(.NOT.ASSOCIATED(interface)) CALL FlagError("Interface is not associated.",err,error,*999)
    IF(ASSOCIATED(field)) CALL FlagError("Field is already associated.",err,error,*999)
    
    NULLIFY(field)
    CALL Field_UserNumberFind(userNumber,interface,field,err,error,*999)
    IF(ASSOCIATED(field)) THEN
      localError="Field number "//TRIM(NumberToVString(userNumber,"*",err,error))// &
        & " has already been created on interface number "//TRIM(NumberToVString(interface%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL Field_CreateStartGeneric(interface%fields,userNumber,field,err,error,*999)
    field%interface=>interface
    CALL Field_CreateValuesCacheInitialise(field,err,error,*999)
 
    EXITS("Field_CreateStartInterface")
    RETURN
999 ERRORSEXITS("Field_CreateStartInterface",err,error)
    RETURN 1

  END SUBROUTINE Field_CreateStartInterface

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field defined by a user number in the specified region. \see OpenCMISS::Iron::cmfe_Field_CreateStart
  !>Default values set for the FIELD's attributes are:
  !>- DEPENDENT_TYPE: 1 (FIELD_INDEPENDENT_TYPE)
  !>- DIMENSION: 2 (FIELD_VECTOR_DIMENSION_TYPE)
  !>- TYPE: 1 (FIELD_GEOMETRIC_TYPE)
  !>- NUMBER_OF_VARIABLES: 1
  !>- GEOMETRIC_FIELD: itself
  !>- SCALINGS%scalingType: 3 (FIELD_ARITHMETIC_MEAN_SCALING)
  !>\todo Add in Field_Initialise
  SUBROUTINE Field_CreateStartRegion(userNumber,region,FIELD,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number for the field
    TYPE(RegionType), POINTER :: region !<A pointer to the region in which to create the field
    TYPE(FieldType), POINTER :: field !<On return, a pointer to the field being created
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_CreateStartRegion",err,error,*999)

    IF(.NOT.ASSOCIATED(region)) CALL FlagError("Region is not associated.",err,error,*999)
    IF(ASSOCIATED(field)) CALL FlagError("Field is already associated.",err,error,*999)
    
    NULLIFY(field)
    CALL Field_UserNumberFind(userNumber,region,FIELD,err,error,*999)
    IF(ASSOCIATED(field)) THEN
      localError="Field number "//TRIM(NumberToVString(userNumber,"*",err,error))// &
        & " has already been created on region number "//TRIM(NumberToVString(region%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL Field_CreateStartGeneric(region%fields,userNumber,field,err,error,*999)
    field%region=>region
    CALL Field_CreateValuesCacheInitialise(field,err,error,*999)

    EXITS("Field_CreateStartRegion")
    RETURN
999 ERRORSEXITS("Field_CreateStartRegion",err,error)
    RETURN 1

  END SUBROUTINE Field_CreateStartRegion

  !
  !================================================================================================================================
  !

  !>Finalise the create values cache for a field.
  SUBROUTINE Field_CreateValuesCacheFinalise(createValuesCache,err,error,*)

    !Argument variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache !<A pointer to the create values cache to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,variableIdx

    ENTERS("Field_CreateValuesCacheFinalise",err,error,*999)

    IF(ASSOCIATED(createValuesCache)) THEN
      IF(ALLOCATED(createValuesCache%variableTypes)) DEALLOCATE(createValuesCache%variableTypes)
      IF(ALLOCATED(createValuesCache%variableLabels)) THEN
        DO variableIdx=1,SIZE(createValuesCache%variableLabels,1)
          createValuesCache%variableLabels(variableIdx)=""
        ENDDO !variableIdx
        DEALLOCATE(createValuesCache%variableLabels)
      ENDIF
      IF(ALLOCATED(createValuesCache%variableLabelsLocked)) DEALLOCATE(createValuesCache%variableLabelsLocked)
      IF(ALLOCATED(createValuesCache%dimension)) DEALLOCATE(createValuesCache%dimension)
      IF(ALLOCATED(createValuesCache%dimensionLocked)) DEALLOCATE(createValuesCache%dimensionLocked)
      IF(ALLOCATED(createValuesCache%dataTypes)) DEALLOCATE(createValuesCache%dataTypes)
      IF(ALLOCATED(createValuesCache%dataTypesLocked)) DEALLOCATE(createValuesCache%dataTypesLocked)
      IF(ALLOCATED(createValuesCache%dofOrderTypes)) DEALLOCATE(createValuesCache%dofOrderTypes)
      IF(ALLOCATED(createValuesCache%dofOrderTypesLocked)) DEALLOCATE(createValuesCache%dofOrderTypesLocked)
      IF(ALLOCATED(createValuesCache%numberOfComponents)) DEALLOCATE(createValuesCache%numberOfComponents)
      IF(ALLOCATED(createValuesCache%numberOfComponentsLocked)) DEALLOCATE(createValuesCache%numberOfComponentsLocked)
      IF(ALLOCATED(createValuesCache%componentLabels)) THEN
        DO variableIdx=1,SIZE(createValuesCache%componentLabels,2)
          DO componentIdx=1,SIZE(createValuesCache%componentLabels,1)
            createValuesCache%componentLabels(componentIdx,variableIdx)=""
          ENDDO !componentIdx
        ENDDO !variableIdx
        DEALLOCATE(createValuesCache%componentLabels)
      ENDIF
      IF(ALLOCATED(createValuesCache%componentLabelsLocked)) DEALLOCATE(createValuesCache%componentLabelsLocked)
      IF(ALLOCATED(createValuesCache%interpolationTypes)) DEALLOCATE(createValuesCache%interpolationTypes)
      IF(ALLOCATED(createValuesCache%interpolationTypesLocked)) DEALLOCATE(createValuesCache%interpolationTypesLocked)
      IF(ALLOCATED(createValuesCache%meshComponentNumber)) DEALLOCATE(createValuesCache%meshComponentNumber)
      IF(ALLOCATED(createValuesCache%meshComponentNumberLocked)) DEALLOCATE(createValuesCache%meshComponentNumberLocked)
      DEALLOCATE(createValuesCache)
    ENDIF

    EXITS("Field_CreateValuesCacheFinalise")
    RETURN
999 ERRORSEXITS("Field_CreateValuesCacheFinalise",err,error)
    RETURN 1

  END SUBROUTINE Field_CreateValuesCacheFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the create values cache for a field.
  SUBROUTINE Field_CreateValuesCacheInitialise(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the create values cache for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,numberOfComponents,componentIdx,variableIdx
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(VARYING_STRING) :: dummyError,localError

    ENTERS("Field_CreateValuesCacheInitialise",err,error,*998)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*998)
    IF(ASSOCIATED(field%createValuesCache)) CALL FlagError("Create values cache is already associated.",err,error,*998)
     
    ALLOCATE(field%createValuesCache,STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate create values cache.",err,error,*999)
    SELECT CASE(field%TYPE)
    CASE(FIELD_GEOMETRIC_TYPE,FIELD_FIBRE_TYPE,FIELD_GEOMETRIC_GENERAL_TYPE)
      NULLIFY(coordinateSystem)
      CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
      numberOfComponents=coordinateSystem%numberOfDimensions
    CASE(FIELD_GENERAL_TYPE,FIELD_MATERIAL_TYPE)
      numberOfComponents=1
    CASE DEFAULT
      localError="The field type of "//TRIM(NumberToVString(field%type,"*",err,error))//" is invalid for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    ALLOCATE(field%createValuesCache%variableTypes(field%numberOfVariables),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache variable types.",err,error,*999)
    ALLOCATE(field%createValuesCache%variableLabels(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache variable labels.",err,error,*999)
    ALLOCATE(field%createValuesCache%variableLabelsLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache variable labels locked.",err,error,*999)
    ALLOCATE(field%createValuesCache%dimension(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache dimension.",err,error,*999)
    ALLOCATE(field%createValuesCache%dimensionLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache dimension locked.",err,error,*999)
    ALLOCATE(field%createValuesCache%dataTypes(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache data types.",err,error,*999)
    ALLOCATE(field%createValuesCache%dataTypesLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache data types locked.",err,error,*999)
    ALLOCATE(field%createValuesCache%dofOrderTypes(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache DOF order types.",err,error,*999)
    ALLOCATE(field%createValuesCache%dofOrderTypesLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache DOF order types locked.",err,error,*999)
    ALLOCATE(field%createValuesCache%numberOfComponents(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache number of components.",err,error,*999)
    ALLOCATE(field%createValuesCache%numberOfComponentsLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache number of components locked.",err,error,*999)
    ALLOCATE(field%createValuesCache%componentLabels(numberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache component labels.",err,error,*999)
    ALLOCATE(field%createValuesCache%componentLabelsLocked(numberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache component labels locked.",err,error,*999)
    ALLOCATE(field%createValuesCache%interpolationTypes(numberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache interpolation type.",err,error,*999)
    ALLOCATE(field%createValuesCache%interpolationTypesLocked(numberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache interpolation type locked.",err,error,*999)
    ALLOCATE(field%createValuesCache%meshComponentNumber(numberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache mesh component type.",err,error,*999)
    ALLOCATE(field%createValuesCache%meshComponentNumberLocked(numberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocated create values cache mesh component type locked.",err,error,*999)
    field%createValuesCache%labelLocked=.FALSE.
    field%createValuesCache%decompositionLocked=.FALSE.
    field%createValuesCache%dependentTypeLocked=.FALSE.
    field%createValuesCache%dimensionLocked=.FALSE.
    field%createValuesCache%numberOfVariablesLocked=.FALSE.
    field%createValuesCache%geometricFieldLocked=.FALSE.
    field%createValuesCache%scalingTypeLocked=.FALSE.
    field%createValuesCache%typeLocked=.FALSE.
    field%createValuesCache%variableTypes=0
    field%createValuesCache%variableTypesLocked=.FALSE.
    field%createValuesCache%variableLabels=""
    field%createValuesCache%variableLabelsLocked=.FALSE.
    field%createValuesCache%dimension=0
    field%createValuesCache%dimensionLocked=.FALSE.
    field%createValuesCache%dataTypes=0
    field%createValuesCache%dataTypesLocked=.FALSE.
    field%createValuesCache%dofOrderTypes=0
    field%createValuesCache%dofOrderTypesLocked=.FALSE.
    field%createValuesCache%numberOfComponents=0
    field%createValuesCache%numberOfComponentsLocked=.FALSE.
    field%createValuesCache%componentLabels=""
    field%createValuesCache%componentLabelsLocked=.FALSE.
    field%createValuesCache%interpolationTypes=0
    field%createValuesCache%interpolationTypesLocked=.FALSE.
    field%createValuesCache%meshComponentNumber=0
    field%createValuesCache%meshComponentNumberLocked=.FALSE.
    field%createValuesCache%DataProjectionLocked=.FALSE.
    DO variableIdx=1,field%numberOfVariables
      field%createValuesCache%variableTypes(variableIdx)=variableIdx
      SELECT CASE(variableIdx)
      CASE(FIELD_U_VARIABLE_TYPE)
        SELECT CASE(field%TYPE)
        CASE(FIELD_GEOMETRIC_TYPE)
          field%createValuesCache%variableLabels(variableIdx)="Coordinate"
        CASE(FIELD_FIBRE_TYPE)
          field%createValuesCache%variableLabels(variableIdx)="Fibre"
        CASE(FIELD_MATERIAL_TYPE)
          field%createValuesCache%variableLabels(variableIdx)="Material"              
        CASE(FIELD_GENERAL_TYPE)
          field%createValuesCache%variableLabels(variableIdx)="U"
        CASE(FIELD_GEOMETRIC_GENERAL_TYPE)
          field%createValuesCache%variableLabels(variableIdx)="U"
        CASE DEFAULT
          localError="The field type of "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is invalid for field number "// &
            & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(FIELD_DELUDELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U/del n"
      CASE(FIELD_DELUDELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U/del t"
      CASE(FIELD_DEL2UDELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 U/del t^2"
      CASE(FIELD_V_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="V"
      CASE(FIELD_DELVDELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del V/del n"
      CASE(FIELD_DELVDELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del V/del t"
      CASE(FIELD_DEL2VDELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 V/del t^2"
      CASE(FIELD_U1_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="U1"
      CASE(FIELD_DELU1DELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U1/del n"
      CASE(FIELD_DELU1DELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U1/del t"
      CASE(FIELD_DEL2U1DELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 U1/del t^2"
      CASE(FIELD_U2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="U2"
      CASE(FIELD_DELU2DELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U2/del n"
      CASE(FIELD_DELU2DELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U2/del t"
      CASE(FIELD_DEL2U2DELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 U2/del t^2"
      CASE(FIELD_U3_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="U3"
      CASE(FIELD_DELU3DELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U3/del n"
      CASE(FIELD_DELU3DELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U3/del t"
      CASE(FIELD_DEL2U3DELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 U3/del t^2"
      CASE(FIELD_U4_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="U4"
      CASE(FIELD_DELU4DELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U4/del n"
      CASE(FIELD_DELU4DELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U4/del t"
      CASE(FIELD_DEL2U4DELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 U4/del t^2"
      CASE(FIELD_U5_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="U5"
      CASE(FIELD_DELU5DELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U5/del n"
      CASE(FIELD_DELU5DELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U5/del t"
      CASE(FIELD_DEL2U5DELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 U5/del t^2"
      CASE(FIELD_U6_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="U6"
      CASE(FIELD_DELU6DELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U6/del n"
      CASE(FIELD_DELU6DELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U6/del t"
      CASE(FIELD_DEL2U6DELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 U6/del t^2"
      CASE(FIELD_U7_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="U7"
      CASE(FIELD_DELU7DELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U7/del n"
      CASE(FIELD_DELU7DELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U7/del t"
      CASE(FIELD_DEL2U7DELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 U7/del t^2"
      CASE(FIELD_U8_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="U8"
      CASE(FIELD_DELU8DELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U8/del n"
      CASE(FIELD_DELU8DELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U8/del t"
      CASE(FIELD_DEL2U8DELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 U8/del t^2"
      CASE(FIELD_U9_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="U9"
      CASE(FIELD_DELU9DELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U9/del n"
      CASE(FIELD_DELU9DELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U9/del t"
      CASE(FIELD_DEL2U9DELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 U/9del t^2"
      CASE(FIELD_U10_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="U10"
      CASE(FIELD_DELU10DELN_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U10/del n"
      CASE(FIELD_DELU10DELT_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del U10/del t"
      CASE(FIELD_DEL2U10DELT2_VARIABLE_TYPE)
        field%createValuesCache%variableLabels(variableIdx)="del^2 U10/del t^2"
      CASE DEFAULT
        localError="The variable type of "//TRIM(NumberToVString(variableIdx,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
      field%createValuesCache%dimension(variableIdx)=FIELD_VECTOR_DIMENSION_TYPE
      field%createValuesCache%dataTypes(variableIdx)=FIELD_DP_TYPE
      field%createValuesCache%dofOrderTypes(variableIdx)=FIELD_SEPARATED_COMPONENT_DOF_ORDER
      field%createValuesCache%numberOfComponents(variableIdx)=numberOfComponents
      DO componentIdx=1,numberOfComponents
        field%createValuesCache%componentLabels(componentIdx,variableIdx)=TRIM(NumberToVString(componentIdx,"*",err,error))
        IF(err/=0) GOTO 999
        field%createValuesCache%interpolationTypes(componentIdx,variableIdx)=FIELD_NODE_BASED_INTERPOLATION
        field%createValuesCache%meshComponentNumber(componentIdx,variableIdx)=1
      ENDDO !componentIdx
    ENDDO !variableIdx

    EXITS("Field_CreateValuesCacheInitialise")
    RETURN
999 CALL Field_CreateValuesCacheFinalise(field%createValuesCache,dummyErr,dummyError,*998)
998 ERRORSEXITS("Field_CreateValuesCacheInitialise",err,error)
    RETURN 1

  END SUBROUTINE Field_CreateValuesCacheInitialise

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field. \see OpenCMISS::Iron::cmfe_Field_DataProjectionSet
  SUBROUTINE Field_DataProjectionSet(field,dataProjection,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the decomposition for
    TYPE(DataProjectionType), POINTER :: dataProjection !<A pointer to the data projection to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    TYPE(VARYING_STRING) :: localError
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_DataProjectionSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    IF(.NOT.ASSOCIATED(dataProjection)) CALL FlagError("Data projection is not associated.",err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%dataProjectionLocked) THEN
      localError="The data projection has been locked for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    field%dataProjection=>dataProjection

    EXITS("Field_DataProjectionSet")
    RETURN
999 ERRORSEXITS("Field_DataProjectionSet",err,error)
    RETURN 1

  END SUBROUTINE Field_DataProjectionSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable. \see OpenCMISS::Iron::cmfe_Field_DataTypeSet
  SUBROUTINE Field_DataTypeSet(field,variableType,dataType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type of the field variable component to set \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dataType !<The data type to set \see FieldRoutines_DataTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_DataTypeSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " is invalid. The variable type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ANY(createValuesCache%variableTypes==variableType)) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " has not been created on field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF      
    IF(createValuesCache%dataTypesLocked(variableType)) THEN
      localError="The data type has been locked for variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    SELECT CASE(dataType)                
    CASE(FIELD_INTG_TYPE)
      createValuesCache%dataTypes(variableType)=FIELD_INTG_TYPE
    CASE(FIELD_SP_TYPE)
      createValuesCache%dataTypes(variableType)=FIELD_SP_TYPE
    CASE(FIELD_DP_TYPE)
      createValuesCache%dataTypes(variableType)=FIELD_DP_TYPE
    CASE(FIELD_L_TYPE)
      createValuesCache%dataTypes(variableType)=FIELD_L_TYPE
    CASE DEFAULT
      localError="The specified data type of "//TRIM(NumberToVString(dataType,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_DataTypeSet")
    RETURN
999 ERRORSEXITS("Field_DataTypeSet",err,error)
    RETURN 1

  END SUBROUTINE Field_DataTypeSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable and locks it so that no further changes can be made.
  SUBROUTINE Field_DataTypeSetAndLock(field,variableType,dataType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type of the field variable component to set \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dataType !<The data type to set \see FieldRoutines_DataTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_DataTypeSetAndLock",err,error,*999)

    CALL Field_DataTypeSet(field,variableType,dataType,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%dataTypesLocked(variableType)=.TRUE.

    EXITS("Field_DataTypeSetAndLock")
    RETURN
999 ERRORSEXITS("Field_DataTypeSetAndLock",err,error)
    RETURN 1
    
  END SUBROUTINE Field_DataTypeSetAndLock

  !
  !================================================================================================================================
  !

  !>Sets/changes the decomposition for a field. \see OpenCMISS::Iron::cmfe_Field_DecompositionSet
  SUBROUTINE Field_DecompositionSet(field,decomposition,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the decomposition for
    TYPE(DecompositionType), POINTER :: decomposition !<A pointer to the decomposition to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    LOGICAL :: isInterfaceDecomposition,isInterfaceField,isRegionDecomposition,isRegionField
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(InterfaceType), POINTER :: decompositionInterface,fieldInterface
    TYPE(RegionType), POINTER :: decompositionRegion,fieldRegion,parentRegion
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_DecompositionSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    CALL Decomposition_AssertIsDecomposed(decomposition,err,error,*999)

    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%decompositionLocked) THEN
      localError="The mesh decomposition has been locked for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL Field_IsRegionField(field,isRegionField,err,error,*999)
    CALL Field_IsInterfaceField(field,isInterfaceField,err,error,*999)
    CALL Decomposition_IsRegionDecomposition(decomposition,isRegionDecomposition,err,error,*999)
    CALL Decomposition_IsInterfaceDecomposition(decomposition,isInterfaceDecomposition,err,error,*999)
    IF(isRegionField) THEN
      NULLIFY(fieldRegion)
      CALL Field_RegionGet(field,fieldRegion,err,error,*999)
      IF(isRegionDecomposition) THEN
        NULLIFY(decompositionRegion)
        CALL Decomposition_RegionGet(decomposition,decompositionRegion,err,error,*999)
        IF(decompositionRegion%userNumber/=fieldRegion%userNumber) THEN
          localError="Inconsitent regions. The field is defined on region number "// &
            & TRIM(NumberToVString(fieldRegion%userNumber,"*",err,error))// &
            & " and the decomposition is defined on region number "//&
            & TRIM(NumberToVString(decompositionRegion%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE IF(isInterfaceDecomposition) THEN
        NULLIFY(decompositionInterface)
        CALL Decomposition_InterfaceGet(decomposition,decompositionInterface,err,error,*999)
        NULLIFY(parentRegion)
        CALL Interface_ParentRegionGet(decompositionInterface,parentRegion,err,error,*999)
        localError="Inconsitent setup. The field is defined on region number "// &
          & TRIM(NumberToVString(fieldRegion%userNumber,"*",err,error))// &
          & " and the decomposition is defined on interface number "// &
          & TRIM(NumberToVString(decompositionInterface%userNumber,"*",err,error))// &
          & " of parent region number "//TRIM(NumberToVString(parentRegion%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ELSE
        localError="Decomposition number "//TRIM(NumberToVString(decomposition%userNumber,"*",err,error))// &
          & " is not defined on either a region or an interface."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE IF(isInterfaceField) THEN
      NULLIFY(fieldInterface)
      CALL Field_InterfaceGet(field,fieldInterface,err,error,*999)
      NULLIFY(parentRegion)
      CALL Interface_ParentRegionGet(fieldInterface,parentRegion,err,error,*999)
      IF(isRegionDecomposition) THEN
        NULLIFY(decompositionRegion)
        CALL Decomposition_RegionGet(decomposition,decompositionRegion,err,error,*999)
        localError="Inconsitent setup. The field is defined on interface number "// &
          & TRIM(NumberToVString(fieldInterface%userNumber,"*",err,error))// &
          & " of parent region number "//TRIM(NumberToVString(parentRegion%userNumber,"*",err,error))// &
          & " and the decomposition is defined on region number "// &
          & TRIM(NumberToVString(decompositionRegion%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ELSE IF(isInterfaceDecomposition) THEN
        NULLIFY(decompositionInterface)
        CALL Decomposition_InterfaceGet(decomposition,decompositionInterface,err,error,*999)
        IF(decompositionInterface%userNumber/=fieldInterface%userNumber) THEN
          localError="Inconsitent interfaces. The field is defined on interface number "// &
            & TRIM(NumberToVString(fieldInterface%userNumber,"*",err,error))// &
            & " and the decomposition is defined on interface number "//&
            & TRIM(NumberToVString(decompositionInterface%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Decomposition number "//TRIM(NumberToVString(decomposition%userNumber,"*",err,error))// &
          & " is not defined on either a region or an interface."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " is not defined on either a region or an interface."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    field%decomposition=>decomposition

    EXITS("Field_DecompositionSet")
    RETURN
999 ERRORSEXITS("Field_DecompositionSet",err,error)
    RETURN 1

  END SUBROUTINE Field_DecompositionSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the decomposition for a field and locks so that no further changes can be made.
  SUBROUTINE Field_DecompositionSetAndLock(field,decomposition,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the decomposition for
    TYPE(DecompositionType), POINTER :: decomposition !<A pointer to the decomposition to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_DecompositionSetAndLock",err,error,*999)

    CALL Field_DecompositionSet(field,decomposition,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)

    createValuesCache%decompositionLocked=.TRUE.

    EXITS("Field_DecompositionSetAndLock")
    RETURN
999 ERRORSEXITS("Field_DecompositionSetAndLock",err,error)
    RETURN 1

  END SUBROUTINE Field_DecompositionSetAndLock

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field. \see OpenCMISS::Iron::cmfe_Field_DependentTypeSet
  SUBROUTINE Field_DependentTypeSet(field,dependentType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the dependent type for
    INTEGER(INTG), INTENT(IN) :: dependentType !<The dependent type to set/change \see FieldRoutines_DependentTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_DependentTypeSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%dependentTypeLocked) THEN
      localError="The dependent type has been locked for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    SELECT CASE(dependentType)
    CASE(FIELD_INDEPENDENT_TYPE)
      field%dependentType=FIELD_INDEPENDENT_TYPE
    CASE(FIELD_DEPENDENT_TYPE)
      field%dependentType=FIELD_DEPENDENT_TYPE
    CASE DEFAULT
      localError="The supplied dependent type of "//TRIM(NumberToVString(dependentType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_DependentTypeSet")
    RETURN
999 ERRORSEXITS("Field_DependentTypeSet",err,error)
    RETURN 1

  END SUBROUTINE Field_DependentTypeSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field and locks so that no further changes are possible.
  SUBROUTINE Field_DependentTypeSetAndLock(field,dependentType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the dependent type for
    INTEGER(INTG), INTENT(IN) :: dependentType !<The dependent type to set/change \see FieldRoutines_DependentTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache 

    ENTERS("Field_DependentTypeSetAndLock",err,error,*999)

    CALL Field_DependentTypeSet(field,dependentType,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)

    createValuesCache%dependentTypeLocked=.TRUE.

    EXITS("Field_DependentTypeSetAndLock")
    RETURN
999 ERRORSEXITS("Field_DependentTypeSetAndLock",err,error)
    RETURN 1

  END SUBROUTINE Field_DependentTypeSetAndLock

  !
  !================================================================================================================================
  !

  !>Destroys a field. \see OpenCMISS::Iron::cmfe_Field_Destroy
  SUBROUTINE Field_Destroy(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to destroy
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: fieldIdx,fieldPosition,fieldPosition2
    TYPE(FieldType), POINTER :: field2,geometricField
    TYPE(FieldsType), POINTER :: fields
    TYPE(FieldPtrType), ALLOCATABLE :: newFields(:),newFieldsUsing(:)

    ENTERS("Field_Destroy",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    
    NULLIFY(fields)
    CALL Field_FieldsGet(field,fields,err,error,*999)    
    fieldPosition=field%globalNumber
    NULLIFY(geometricField)
    CALL Field_GeometricFieldExists(field,geometricField,err,error,*999)
    IF(ASSOCIATED(geometricField)) THEN
      IF(ASSOCIATED(geometricField%geometricFieldParameters)) THEN
        !Delete this field from the list of fields using the geometric field.
        fieldPosition2=0
        DO fieldIdx=1,geometricField%geometricFieldParameters%numberOfFieldsUsing
          field2=>geometricField%geometricFieldParameters%fieldsUsing(fieldIdx)%ptr
          IF(field2%userNumber==field%userNumber) THEN
            fieldPosition2=fieldIdx
            EXIT
          ENDIF
        ENDDO !fieldIdx
        IF(fieldPosition2/=0) THEN
          ALLOCATE(newFieldsUsing(geometricField%geometricFieldParameters%numberOfFieldsUsing+1),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate new fields using.",err,error,*999)
          DO fieldIdx=1,geometricField%geometricFieldParameters%numberOfFieldsUsing
            IF(fieldIdx<fieldPosition2) THEN
              newFieldsUsing(fieldIdx)%ptr=>geometricField%geometricFieldParameters%fieldsUsing(fieldIdx)%ptr
            ELSE IF(fieldIdx>fieldPosition2) THEN
              newFieldsUsing(fieldIdx-1)%ptr=>geometricField%geometricFieldParameters%fieldsUsing(fieldIdx)%ptr
            ENDIF
          ENDDO !fieldIdx
          geometricField%geometricFieldParameters%numberOfFieldsUsing=geometricField%geometricFieldParameters%numberOfFieldsUsing-1
          CALL MOVE_ALLOC(newFieldsUsing,geometricField%geometricFieldParameters%fieldsUsing)
        ELSE
          !??? Error
        ENDIF
      ENDIF
    ENDIF
    CALL Field_Finalise(field,err,error,*999)
    IF(fields%numberOfFields>1) THEN
      ALLOCATE(newFields(fields%numberOfFields-1),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate new fields.",err,error,*999)
      DO fieldIdx=1,fields%numberOfFields
        IF(fieldIdx<fieldPosition) THEN
          newFields(fieldIdx)%ptr=>fields%fields(fieldIdx)%ptr
        ELSE IF(fieldIdx>fieldPosition) THEN
          fields%fields(fieldIdx)%ptr%globalNumber=fields%fields(fieldIdx)%ptr%globalNumber-1
          newFields(fieldIdx-1)%ptr=>fields%fields(fieldIdx)%ptr
        ENDIF
      ENDDO !fieldIdx
      CALL MOVE_ALLOC(newFields,fields%fields)
      fields%numberOfFields=fields%numberOfFields-1
    ELSE
      DEALLOCATE(fields%fields)
      fields%numberOfFields=0
    ENDIF

    EXITS("Field_Destroy")
    RETURN
999 IF(ALLOCATED(newFields)) DEALLOCATE(newFields)
    IF(ALLOCATED(newFieldsUsing)) DEALLOCATE(newFieldsUsing)
    ERRORSEXITS("Field_Destroy",err,error)
    RETURN 1

  END SUBROUTINE Field_Destroy

  !
  !================================================================================================================================
  !

  !>Sets/changes the field dimension for a field variable. \see OpenCMISS::Iron::cmfe_Field_DimensionSet
  SUBROUTINE Field_DimensionSet(field,variableType,fieldDimension,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldDimension !<The field dimension to set/change \see FieldRoutines_DimensionTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: numberOfComponents,newNumberOfComponents,variableIdx
    INTEGER(INTG), ALLOCATABLE :: newInterpolationType(:,:),newMeshComponentNumber(:,:)
    LOGICAL, ALLOCATABLE :: newComponentLabelsLocked(:,:),newInterpolationTypeLocked(:,:), &
      & newMeshComponentNumberLocked(:,:)
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError
    TYPE(VARYING_STRING), ALLOCATABLE :: newComponentLabels(:,:)

    ENTERS("Field_DimensionSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " is invalid. The variable type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ANY(createValuesCache%variableTypes==variableType)) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " has not been created on field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF      
    IF(createValuesCache%dimensionLocked(variableType)) THEN
      localError="The field dimension has been locked for for variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    SELECT CASE(fieldDimension)
    CASE(FIELD_SCALAR_DIMENSION_TYPE)
      IF(createValuesCache%numberOfComponents(variableType)/=1) THEN
        numberOfComponents=SIZE(createValuesCache%interpolationTypes,1)
        newNumberOfComponents=1
        !Here, new number of components always >= old_number_of_components
        DO variableIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          IF(createValuesCache%numberOfComponents(variableIdx) > newNumberOfComponents) THEN 
            IF(variableIdx /= variableType) THEN
              newNumberOfComponents=createValuesCache%numberOfComponents(variableIdx)
            ENDIF
          ENDIF
        ENDDO !variableIdx
        ALLOCATE(newComponentLabels(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new component labels.",err,error,*999)
        ALLOCATE(newComponentLabelsLocked(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new component labels locked.",err,error,*999)
        ALLOCATE(newInterpolationType(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new interpolation type.",err,error,*999)
        ALLOCATE(newInterpolationTypeLocked(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new interpolation type locked.",err,error,*999)
        ALLOCATE(newMeshComponentNumber(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new mesh component number.",err,error,*999)
        ALLOCATE(newMeshComponentNumberLocked(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new mesh component number locked.",err,error,*999)
        newComponentLabels(1:newNumberOfComponents,:)=createValuesCache%componentLabels(1:newNumberOfComponents,:)
        newComponentLabelsLocked(1:newNumberOfComponents,:)=createValuesCache%componentLabelsLocked(1:newNumberOfComponents,:)
        newInterpolationType(1:newNumberOfComponents,:)=createValuesCache%interpolationTypes(1:newNumberOfComponents,:)
        newInterpolationTypeLocked(1:newNumberOfComponents,:)=createValuesCache%interpolationTypesLocked(1:newNumberOfComponents,:)
        newMeshComponentNumber(1:newNumberOfComponents,:)=createValuesCache%meshComponentNumber(1:newNumberOfComponents,:)
        newMeshComponentNumberLocked(1:newNumberOfComponents,:)= &
          & createValuesCache%meshComponentNumberLocked(1:newNumberOfComponents,:)        
        CALL MOVE_ALLOC(newComponentLabels,createValuesCache%componentLabels)
        CALL MOVE_ALLOC(newComponentLabelsLocked,createValuesCache%componentLabelsLocked)
        CALL MOVE_ALLOC(newInterpolationType,createValuesCache%interpolationTypes)
        CALL MOVE_ALLOC(newInterpolationTypeLocked,createValuesCache%interpolationTypesLocked)
        CALL MOVE_ALLOC(newMeshComponentNumber,createValuesCache%meshComponentNumber)
        CALL MOVE_ALLOC(newMeshComponentNumberLocked,createValuesCache%meshComponentNumberLocked)        
        createValuesCache%numberOfComponents(variableType)=1
      ENDIF
      createValuesCache%dimension(variableType)=FIELD_SCALAR_DIMENSION_TYPE
    CASE(FIELD_VECTOR_DIMENSION_TYPE)
      createValuesCache%dimension(variableType)=FIELD_VECTOR_DIMENSION_TYPE
    CASE(FIELD_TENSOR_DIMENSION_TYPE)
      createValuesCache%dimension(variableType)=FIELD_TENSOR_DIMENSION_TYPE
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The specified field dimension of "//TRIM(NumberToVString(fieldDimension,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_DimensionSet")
    RETURN
999 IF(ALLOCATED(newComponentLabels)) DEALLOCATE(newComponentLabels)
    IF(ALLOCATED(newComponentLabelsLocked)) DEALLOCATE(newComponentLabelsLocked)
    IF(ALLOCATED(newInterpolationType)) DEALLOCATE(newInterpolationType)
    IF(ALLOCATED(newInterpolationTypeLocked)) DEALLOCATE(newInterpolationTypeLocked)
    IF(ALLOCATED(newMeshComponentNumber)) DEALLOCATE(newMeshComponentNumber)
    IF(ALLOCATED(newMeshComponentNumberLocked)) DEALLOCATE(newMeshComponentNumberLocked)
    ERRORSEXITS("Field_DimensionSet",err,error)
    RETURN 1

  END SUBROUTINE Field_DimensionSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the field dimension for a field variable  and locks so that no further changes can be made.
  SUBROUTINE Field_DimensionSetAndLock(field,variableType,fieldDimension,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldDimension !<The field dimension to set/change \see FieldRoutines_DimensionTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_DimensionSetAndLock",err,error,*999)

    CALL Field_DimensionSet(field,variableType,fieldDimension,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)

    createValuesCache%dimensionLocked(variableType)=.TRUE.

    EXITS("Field_DimensionSetAndLock")
    RETURN
999 ERRORSEXITS("Field_DimensionSetAndLock",err,error)
    RETURN 1

  END SUBROUTINE Field_DimensionSetAndLock

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable. Note: for contiguous component DOF ordering all the components of the field variable must have the same interpolation type. \see OpenCMISS::Iron::cmfe_Field_DOFOrderTypeSet
  SUBROUTINE Field_DOFOrderTypeSet(field,variableType,dofOrderType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the DOF order type for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofOrderType !<The DOF order type to set \see FieldRoutines_DOFOrderTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx
    LOGICAL :: sameInterpolation,sameMeshComponent
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_DOFOrderTypeSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " is invalid. The variable type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ANY(createValuesCache%variableTypes==variableType)) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " has not been created on field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF      
    IF(createValuesCache%dofOrderTypesLocked(variableType)) THEN
      localError="The DOF order type has been locked for variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    SELECT CASE(dofOrderType)                
    CASE(FIELD_SEPARATED_COMPONENT_DOF_ORDER)
      createValuesCache%dofOrderTypes(variableType)=FIELD_SEPARATED_COMPONENT_DOF_ORDER
    CASE(FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER)
      sameInterpolation=.TRUE.
      sameMeshComponent=.TRUE.
      DO componentIdx=2,createValuesCache%numberOfComponents(variableType)
        IF(createValuesCache%interpolationTypes(componentIdx,variableType)/= &
          & createValuesCache%interpolationTypes(1,variableType)) THEN
          sameInterpolation=.FALSE.
          EXIT
        ENDIF
        IF(createValuesCache%meshComponentNumber(componentIdx,variableType)/= &
          & createValuesCache%meshComponentNumber(1,variableType)) THEN
          sameMeshComponent=.FALSE.
          EXIT
        ENDIF
      ENDDO !componentIdx
      IF(sameInterpolation.AND.sameMeshComponent) THEN
        createValuesCache%dofOrderTypes(variableType)=FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER
      ELSE
        CALL FlagError("Invalid field variable component set. For continguous component DOF "// &
          & "ordering the field variable components must have the same interpolation type and mesh components.", &
          & err,error,*999)
      ENDIF
    CASE DEFAULT
      localError="The specified DOF order type of "//TRIM(NumberToVString(dofOrderType,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_DOFOrderTypeSet")
    RETURN
999 ERRORSEXITS("Field_DOFOrderTypeSet",err,error)
    RETURN 1

  END SUBROUTINE Field_DOFOrderTypeSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable and locks it so that no further changes can be made.
  SUBROUTINE Field_DOFOrderTypeSetAndLock(field,variableType,dofOrderType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the DOF order for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofOrderType !<The DOF order type to set \see FieldRoutines_DOFOrderTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_DOFOrderTypeSetAndLock",err,error,*999)

    CALL Field_DOFOrderTypeSet(field,variableType,dofOrderType,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%dofOrderTypesLocked(variableType)=.TRUE.

    EXITS("Field_DOFOrderTypeSetAndLock")
    RETURN
999 ERRORSEXITS("Field_DOFOrderTypeSetAndLock",err,error)
    RETURN 1

  END SUBROUTINE Field_DOFOrderTypeSetAndLock

  !
  !================================================================================================================================
  !

  !>Finalises a field and deallocates all memory.
  SUBROUTINE Field_Finalise(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_Finalise",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      field%label=""
      CALL Field_ScalingsFinalise(field,err,error,*999)
      CALL Field_VariablesFinalise(field,err,error,*999)
      CALL Field_CreateValuesCacheFinalise(field%createValuesCache,err,error,*999)
      CALL Field_GeometricParametersFinalise(field%geometricFieldParameters,err,error,*999)
      IF(ALLOCATED(field%variableTypeMap)) DEALLOCATE(field%variableTypeMap)
      DEALLOCATE(field)     
    ENDIF

    EXITS("Field_Finalise")
    RETURN
999 ERRORSEXITS("Field_Finalise",err,error)
    RETURN 1

  END SUBROUTINE Field_Finalise

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field. \see OpenCMISS::Iron::cmfe_Field_GeometricFieldSet
  SUBROUTINE Field_GeometricFieldSet(field,geometricField,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the geometric field for
    TYPE(FieldType), POINTER :: geometricField !<A pointer to the geometric field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DecompositionType), POINTER :: fieldDecomposition,geometricDecomposition
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_GeometricFieldSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    CALL Field_AssertIsFinished(geometricField,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%geometricFieldLocked) THEN
      localError="The geometric field has been locked for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(ASSOCIATED(field%geometricField)) THEN
      localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " already has a geometric field associated."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(geometricField%TYPE/=FIELD_GEOMETRIC_TYPE) &
      & CALL FlagError("The specified geometric field is not a geometric field.",err,error,*999)

    NULLIFY(fieldDecomposition)
    CALL Field_DecompositionGet(field,fieldDecomposition,err,error,*999)
    NULLIFY(geometricDecomposition)
    CALL Field_DecompositionGet(geometricField,geometricDecomposition,err,error,*999)
    IF(.NOT.ASSOCIATED(fieldDecomposition,geometricDecomposition)) &
      & CALL FlagError("The specified field and geometric field do not have the same decomposition.",err,error,*999)
    
    SELECT CASE(field%TYPE)
    CASE(FIELD_FIBRE_TYPE,FIELD_GENERAL_TYPE,FIELD_MATERIAL_TYPE,FIELD_GEOMETRIC_GENERAL_TYPE)
      field%geometricField=>geometricField
    CASE(FIELD_GEOMETRIC_TYPE)
      CALL FlagError("Can not set the geometric field for a geometric field.",err,error,*999)
    CASE DEFAULT
      localError="The field type "//TRIM(NumberToVString(field%type,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_GeometricFieldSet")
    RETURN
999 ERRORSEXITS("Field_GeometricFieldSet",err,error)
    RETURN 1

  END SUBROUTINE Field_GeometricFieldSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field and locks so that no further changes can be made.
  SUBROUTINE Field_GeometricFieldSetAndLock(field,geometricField,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the geometric field for
    TYPE(FieldType), POINTER :: geometricField !<A pointer to the geometric field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_GeometricFieldSetAndLock",err,error,*999)

    CALL Field_GeometricFieldSet(field,geometricField,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    field%createValuesCache%geometricFieldLocked=.TRUE.

    EXITS("Field_GeometricFieldSetAndLock")
    RETURN
999 ERRORSEXITS("Field_GeometricFieldSetAndLock",err,error)
    RETURN 1

  END SUBROUTINE Field_GeometricFieldSetAndLock

  !
  !================================================================================================================================
  !

  !>Calculates the geometric parameters (line lengths, areas, volumes, scaling etc.) for a field.
  SUBROUTINE Field_GeometricParametersCalculate(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<The field to calculate the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_GeometricParametersCalculate",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    IF(field%type/=FIELD_GEOMETRIC_TYPE) THEN
      localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" is not a geometric field."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    IF(decomposition%calculateLines) CALL Field_GeometricParametersLineLengthsCalculate(field,err,error,*999)
    !IF(decomposition%calculateFaces) CALL Field_GeometricParametersFaceAreasCalculate(field,err,error,*999) 
    CALL Field_GeometricParametersElementVolumesCalculate(field,err,error,*999)

    EXITS("Field_GeometricParametersCalculate")
    RETURN
999 ERRORSEXITS("Field_GeometricParametersCalculate",err,error)
    RETURN 1

  END SUBROUTINE Field_GeometricParametersCalculate

  !
  !================================================================================================================================
  !

  !>Finalises the geometric parameters and deallocates all memory.
  SUBROUTINE Field_GeometricParametersFinalise(geometricParameters,err,error,*)

    !Argument variables
    TYPE(FieldGeometricParametersType), POINTER :: geometricParameters !<A pointer to the geometric field parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: fieldIdx
    TYPE(FieldType), POINTER :: field2

    ENTERS("Field_GeometricParametersFinalise",err,error,*999)

    IF(ASSOCIATED(geometricParameters)) THEN
      !Nullify the geometric field pointer of those fields using this geometric field.
      DO fieldIdx=1,geometricParameters%numberOfFieldsUsing
        field2=>geometricParameters%fieldsUsing(fieldIdx)%ptr
        IF(ASSOCIATED(field2)) NULLIFY(field2%geometricField)
      ENDDO !fieldIdx
      IF(ALLOCATED(geometricParameters%fieldsUsing)) DEALLOCATE(geometricParameters%fieldsUsing)
      IF(ALLOCATED(geometricParameters%lengths)) DEALLOCATE(geometricParameters%lengths)
      !IF(ALLOCATED(geometricParameters%volumes)) DEALLOCATE(geometricParameters%volumes)
      DEALLOCATE(geometricParameters)
    ENDIF

    EXITS("Field_GeometricParametersFinalise")
    RETURN
999 ERRORSEXITS("Field_GeometricParametersFinalise",err,error)
    RETURN 1

  END SUBROUTINE Field_GeometricParametersFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the geometric parameters for a geometric field
  SUBROUTINE Field_GeometricParametersInitialise(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: fieldIdx
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    !TYPE(DecompositionFacesType), POINTER :: decompositionFaces
    TYPE(DecompositionLinesType), POINTER :: decompositionLines
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(FieldType), POINTER :: fieldGeometricField
    TYPE(FieldPtrType), ALLOCATABLE :: newFieldsUsing(:)
    TYPE(FieldGeometricParametersType), POINTER :: geometricParameters
 
     ENTERS("Field_GeometricParametersInitialise",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    
    IF(field%type==FIELD_GEOMETRIC_TYPE) THEN
      !Field is a geometric field
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(field,decomposition,err,error,*999)
      NULLIFY(decompositionTopology)
      CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
      ALLOCATE(field%geometricFieldParameters,STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate geometric field parameters.",err,error,*999)
      IF(decomposition%calculateLines) THEN
        NULLIFY(decompositionLines)
        CALL DecompositionTopology_DecompositionLinesGet(decompositionTopology,decompositionLines,err,error,*999)
        field%geometricFieldParameters%numberOfLines=decompositionLines%numberOfLines
        ALLOCATE(field%geometricFieldParameters%lengths(field%geometricFieldParameters%numberOfLines),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate lengths.",err,error,*999)
        field%geometricFieldParameters%lengths=0.0_DP
      ENDIF
      !IF(decomposition%calculateFaces) THEN !temporarily commented out
      !  NULLIFY(decompositionFaces)
      !  CALL DecompositionTopology_DecompositionFacesGet(decompositionTopology,decompositionFaces,err,error,*999)
      !  field%geometricFieldParameters%numberOfAreas=decompositionFaces%numberOfFaces
      !  ALLOCATE(field%geometricFieldParameters%areas(field%geometricFieldParameters%numberOfAreas),STAT=err)
      !  IF(err/=0) CALL FlagError("Could not allocate areas.",err,error,*999)
      !  field%geometricFieldParameters%areas=0.0_DP
      !ENDIF
      NULLIFY(decompositionElements)
      CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
      field%geometricFieldParameters%numberOfVolumes=decompositionElements%numberOfElements
      ALLOCATE(field%geometricFieldParameters%volumes(field%geometricFieldParameters%numberOfVolumes),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate volumes.",err,error,*999)
      field%geometricFieldParameters%volumes=0.0_DP            
      !The field is a geometric field so it must use itself initiallly
      ALLOCATE(field%geometricFieldParameters%fieldsUsing(1),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate fields using.",err,error,*999)
      field%geometricFieldParameters%fieldsUsing(1)%ptr=>field
      field%geometricFieldParameters%numberOfFieldsUsing=1
    ELSE
      !Field is not a geometric field
      NULLIFY(field%geometricFieldParameters)
      NULLIFY(fieldGeometricField)
      CALL Field_GeometricFieldGet(field,fieldGeometricField,err,error,*999)
      !Set the geometric field so that it knows that this field is using it
      NULLIFY(geometricParameters)
      CALL Field_GeometricParametersGet(fieldGeometricField,geometricParameters,err,error,*999)
      ALLOCATE(newFieldsUsing(geometricParameters%numberOfFieldsUsing+1),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate new fields using.",err,error,*999)
      DO fieldIdx=1,geometricParameters%numberOfFieldsUsing
        newFieldsUsing(fieldIdx)%ptr=>geometricParameters%fieldsUsing(fieldIdx)%ptr
      ENDDO !fieldIdx
      newFieldsUsing(geometricParameters%numberOfFieldsUsing+1)%ptr=>field
      CALL MOVE_ALLOC(newFieldsUsing,geometricParameters%fieldsUsing)
      geometricParameters%numberOfFieldsUsing=geometricParameters%numberOfFieldsUsing+1
    ENDIF

    EXITS("Field_GeometricParametersInitialise")
    RETURN
999 IF(ALLOCATED(newFieldsUsing)) DEALLOCATE(newFieldsUsing)
    ERRORSEXITS("Field_GeometricParametersInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_GeometricParametersInitialise

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given user element number and element basis line number. \see OpenCMISS::Iron::cmfe_Field_GeometricParametersElementLineLengthGet
  SUBROUTINE Field_GeometricParametersElementLineLengthGet(field,userElementNumber,normalXiDirections,lineLength,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the line length for
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The user element number to get the line length for
    INTEGER(INTG), INTENT(IN) :: normalXiDirections(:) !<The xi normal directions to specify the line \see Constants_ElementNormalXiDirections,Constants
    REAL(DP), INTENT(OUT) :: lineLength !<On return, the line length of the chosen line
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    INTEGER(INTG) :: localElementNumber,localLineNumber,globalLineNumber
    LOGICAL :: elementExists,ghostElement
    TYPE(BasisType), POINTER :: basis
    TYPE(DecompositionType), POINTER :: decomposition    
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldGeometricParametersType), POINTER :: geometricParameters
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_GeometricParametersElementLineLengthGet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    IF(field%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
      localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" is not a geometric field."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(geometricParameters)
    CALL Field_GeometricParametersGet(field,geometricParameters,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(decompositionElements)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementCheckExists(decompositionElements,userElementNumber,elementExists,localElementNumber, &
      & ghostElement,err,error,*999)
    IF(.NOT.elementExists) THEN
      localError="The specified user element number of "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " does not exist in the domain of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(domain)
    CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    NULLIFY(domainElements)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    NULLIFY(basis)
    CALL DomainElements_ElementBasisGet(domainElements,localElementNumber,basis,err,error,*999)
    CALL Basis_LocalLineNumberGet(basis,normalXiDirections,localLineNumber,err,error,*999)
    globalLineNumber=decompositionElements%elements(localElementNumber)%elementLines(localLineNumber)
    lineLength=geometricParameters%lengths(globalLineNumber)

    EXITS("Field_GeometricParametersElementLineLengthGet")
    RETURN
999 ERRORS("Field_GeometricParametersElementLineLengthGet",err,error)
    EXITS("Field_GeometricParametersElementLineLengthGet")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersElementLineLengthGet

  !
  !================================================================================================================================
  !


  !>Gets the volume of an element geometric field for a given user element number .
  SUBROUTINE Field_GeometricParametersElementVolumeGet(field,userElementNumber,elementVolume,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the volume for
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The user element to get the volume for
    REAL(DP), INTENT(OUT) :: elementVolume !<On return, the volume of the chosen element
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    INTEGER(INTG) :: localElementNumber
    LOGICAL :: elementExists,ghostElement
   TYPE(DecompositionType), POINTER :: decomposition    
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(FieldGeometricParametersType), POINTER :: geometricParameters
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Field_GeometricParametersElementVolumeGet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    IF(field%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
      localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" is not a geometric field."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(geometricParameters)
    CALL Field_GeometricParametersGet(field,geometricParameters,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    IF(decomposition%numberOfDimensions/=3) THEN
      localError="Can not get the volume for element number "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" as the domain only has "// &
        & TRIM(NumberToVString(decomposition%numberOfDimensions,"*",err,error))// &
        & " dimensions. Three dimensions are required for volume elements."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(decompositionElements)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementCheckExists(decompositionElements,userElementNumber,elementExists,localElementNumber, &
      & ghostElement,err,error,*999)
    IF(.NOT.elementExists) THEN
      localError="The specified user element number of "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " does not exist in the domain of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    elementVolume=geometricParameters%volumes(localElementNumber)

    EXITS("Field_GeometricParametersElementVolumeGet")
    RETURN
999 ERRORS("Field_GeometricParametersElementVolumeGet",err,error)
    EXITS("Field_GeometricParametersElementVolumeGet")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersElementVolumeGet

  !
  !================================================================================================================================
  !

  !>Calculates the element volumes from the parameters of a geometric field. 
  SUBROUTINE Field_GeometricParametersElementVolumesCalculate(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to calculate the face areas for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,elementIdx,gaussPointIdx,maxNumberOfGauss,numberOfGaussPoints,order
    REAL(DP) :: elementVolume
    REAL(DP), ALLOCATABLE :: gaussPoints(:,:),gaussWeights(:)
    TYPE(BasisType), POINTER:: basis
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldGeometricParametersType), POINTER :: geometricParameters
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: interpolatedPointMetrics
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: dummyError,localError

    ENTERS("Field_GeometricParametersElementVolumesCalculate",err,error,*996)

    CALL Field_AssertIsFinished(field,err,error,*999)
    IF(field%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
      localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" is not a geometric field."
      CALL FlagError(localError,err,error,*996)
    ENDIF
    NULLIFY(geometricParameters)
    CALL Field_GeometricParametersGet(field,geometricParameters,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    IF(decomposition%numberOfDimensions==3) THEN
      !Only calculate volumes if we have three dimensional elements
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
      NULLIFY(coordinateSystem)
      CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
      NULLIFY(interpolationParameters)
      CALL FieldVariable_InterpolationParameterInitialise(fieldVariable,interpolationParameters,err,error,*999)
      NULLIFY(interpolatedPoint)
      CALL Field_InterpolatedPointInitialise(interpolationParameters,interpolatedPoint,err,error,*999)
      NULLIFY(interpolatedPointMetrics)
      CALL Field_InterpolatedPointMetricsInitialise(interpolatedPoint,interpolatedPointMetrics,err,error,*999)
      !Get basis type for the first component of the mesh defined with this geometric field
      NULLIFY(decompositionTopology)
      CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
      NULLIFY(decompositionElements)
      CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
      NULLIFY(domain)
      CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      NULLIFY(basis)
      CALL DomainElements_ElementBasisGet(domainElements,1,basis,err,error,*999)
      !Allocate Gauss points
      order=2
      maxNumberOfGauss=order*order*order
      ALLOCATE(gaussPoints(3,maxNumberOfGauss),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocated gauss points.",err,error,*999)
      ALLOCATE(gaussWeights(maxNumberOfGauss),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocated gauss weights.",err,error,*999)
      !Calculate Gauss points
      CALL Basis_GaussPointsCalculate(basis,order,3,numberOfGaussPoints,gaussPoints,gaussWeights,err,error,*999)
      !Loop over the elements      
      DO elementIdx=1,decompositionElements%numberOfElements
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementIdx,interpolationParameters,err,error,*999)
        elementVolume=0.0_DP
        DO gaussPointIdx=1,numberOfGaussPoints
          CALL Field_InterpolateXi(FIRST_PART_DERIV,gaussPoints(1:3,gaussPointIdx),interpolatedPoint,err,error,*999)
          CALL Field_InterpolatedPointMetricsCalculate(COORDINATE_JACOBIAN_VOLUME_TYPE,interpolatedPointMetrics,err,error,*999)
          elementVolume=elementVolume+InterpolatedPointMetrics%jacobian*gaussWeights(gaussPointIdx)
        ENDDO !gaussPointIdx
        geometricParameters%volumes(elementIdx)=elementVolume
      ENDDO !elementIdx
      !Finalise
      DEALLOCATE(gaussWeights)
      DEALLOCATE(gaussPoints)
      CALL Field_InterpolatedPointMetricsFinalise(interpolatedPointMetrics,err,error,*999)
      CALL Field_InterpolatedPointFinalise(interpolatedPoint,err,error,*999)
      CALL FieldVariable_InterpolationParameterFinalise(interpolationParameters,err,error,*999)
    ENDIF

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Element volumes:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of elements = ",decompositionElements%numberOfElements, &
        & err,error,*999)
      DO elementIdx=1,decompositionElements%numberOfElements
        CALL WriteStringFmtTwoValue(DIAGNOSTIC_OUTPUT_TYPE,"    Element ",elementIdx,"(I8)",": Volume = ",field% &
          & geometricFieldParameters%volumes(elementIdx),"*",err,error,*999)
      ENDDO !elementIdx
    ENDIF

    EXITS("Field_GeometricParametersElementVolumesCalculate")
    RETURN
999 IF(ALLOCATED(gaussWeights)) DEALLOCATE(gaussWeights)
    IF(ALLOCATED(gaussPoints)) DEALLOCATE(gaussPoints)
    IF(ASSOCIATED(interpolatedPointMetrics)) &
      & CALL Field_InterpolatedPointMetricsFinalise(interpolatedPointMetrics,dummyErr,dummyError,*998)
998 IF(ASSOCIATED(interpolatedPoint)) &
      & CALL Field_InterpolatedPointFinalise(interpolatedPoint,dummyErr,dummyError,*997)
997 IF(ASSOCIATED(interpolationParameters)) &
      & CALL FieldVariable_InterpolationParameterFinalise(interpolationParameters,dummyErr,dummyError,*996)
996 ERRORS("Field_GeometricParametersElementVolumesCalculate",err,error)
    EXITS("Field_GeometricParametersElementVolumesCalculate")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersElementVolumesCalculate

  !
  !================================================================================================================================
  !

  !>Calculates the line lengths from the parameters of a geometric field. Old CMISS name LINSCA
  SUBROUTINE Field_GeometricParametersLineLengthsCalculate(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to calculate the line lengths for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,iterationNumber,maximumDifferenceLine,gaussPointIdx,lineIdx
    INTEGER(INTG), PARAMETER :: linesMaximumNumberOfIterations=20
    INTEGER(INTG) :: gaussStart(4) = [ 0,1,3,6 ]
    INTEGER(INTG) :: numberOfGaussPoints=4
    REAL(DP) :: lastMaximumLengthDifference,lengthDifference,maximumLengthDifference,xi(1),gaussWeight,derivativeNorm,lineLength, &
      & oldLineLength
    REAL(DP) :: gaussPositions(10),gaussWeights(10)
    REAL(DP), PARAMETER :: lineIncrementTolerance=CONVERGENCE_TOLERANCE
    LOGICAL :: iterate,updateFieldsUsing
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionLinesType), POINTER :: decompositionLines
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(FieldGeometricParametersType), POINTER :: geometricParameters
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: dummyError,localError

    gaussPositions = [ 0.500000000000000_DP, &
      &                0.211324865405187_DP,0.788675134594813_DP, &
      &                0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
      &                0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
    gaussWeights = [ 1.000000000000000_DP, &
      &              0.500000000000000_DP,0.500000000000000_DP, &
      &              0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP, &
      &              0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]

    NULLIFY(interpolatedPoint)
    NULLIFY(interpolationParameters)

    ENTERS("Field_GeometricParametersLineLengthsCalculate",err,error,*997)

    CALL Field_AssertIsFinished(field,err,error,*999)
    IF(field%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
      localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" is not a geometric field."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(geometricParameters)
    CALL Field_GeometricParametersGet(field,geometricParameters,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(decompositionLines)
    CALL DecompositionTopology_DecompositionLinesGet(decompositionTopology,decompositionLines,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
    !Iterate to find the line lengths as the line lengths depend on the scaling factors and vise versa.
    CALL FieldVariable_InterpolationParameterInitialise(fieldVariable,interpolationParameters,err,error,*999)
    CALL Field_InterpolatedPointInitialise(interpolationParameters,interpolatedPoint,err,error,*999)
    iterate=.TRUE.
    iterationNumber=0
    lastMaximumLengthDifference=0.0_DP
    DO WHILE(iterate.AND.iterationNumber<=linesMaximumNumberOfIterations)
      maximumLengthDifference=0.0_DP
      maximumDifferenceLine=1
      !Loop over the lines
      DO lineIdx=1,decompositionLines%numberOfLines
        CALL Field_InterpolationParametersLineGet(FIELD_VALUES_SET_TYPE,lineIdx,interpolationParameters,err,error,*999)
        oldLineLength=geometricParameters%lengths(lineIdx)
        lineLength=0.0_DP
        !Integrate || dr(xi)/dt || from xi=0 to 1 to determine the arc length.
        DO gaussPointIdx=1,numberOfGaussPoints
          xi(1)=gaussPositions(gaussStart(numberOfGaussPoints)+gaussPointIdx)
          gaussWeight=gaussWeights(gaussStart(numberOfGaussPoints)+gaussPointIdx)
          CALL Field_InterpolateXi(FIRST_PART_DERIV,xi,interpolatedPoint,err,error,*999)
          CALL CoordinateSystem_DerivativeNorm(coordinateSystem,PART_DERIV_S1,interpolatedPoint,derivativeNorm,err,error,*999)
          lineLength=lineLength+gaussWeight*derivativeNorm
        ENDDO !gaussPointIdx
        geometricParameters%lengths(lineIdx)=lineLength
        lengthDifference=ABS(lineLength-oldLineLength)/(1.0_DP+oldLineLength)
        IF(lengthDifference>maximumLengthDifference) THEN
          maximumLengthDifference=lengthDifference
          maximumDifferenceLine=lineIdx
        ENDIF
      ENDDO !lineIdx
      iterate=maximumLengthDifference>lineIncrementTolerance
      IF(iterate) THEN
        IF(iterationNumber==1) THEN
          lastMaximumLengthDifference=maximumLengthDifference
        ELSE IF(maximumLengthDifference<LOOSE_TOLERANCE.AND.maximumLengthDifference>=lastMaximumLengthDifference) THEN
          !Seems to be at a numerical limit
          iterate=.FALSE.
        ELSE
          lastMaximumLengthDifference=maximumLengthDifference
        ENDIF
      ENDIF
      iterationNumber=iterationNumber+1
      IF(diagnostics2) THEN
        CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Line iteration report:",err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of iterations = ",iterationNumber,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum length difference = ",maximumLengthDifference,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Difference tolerance = ",lineIncrementTolerance,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum difference line = ",maximumDifferenceLine,err,error,*999)
      ENDIF
      IF(.NOT.iterate.OR.iterationNumber==linesMaximumNumberOfIterations) THEN
        updateFieldsUsing=.TRUE.
      ELSE
        updateFieldsUsing=.FALSE.
      ENDIF
      CALL Field_GeometricParametersScaleFactorsUpdate(field,updateFieldsUsing,err,error,*999)
    ENDDO !iterate
    CALL Field_InterpolatedPointFinalise(interpolatedPoint,err,error,*999)
    CALL FieldVariable_InterpolationParameterFinalise(interpolationParameters,err,error,*999)

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Line lengths:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of iterations = ",iterationNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum length difference = ",maximumLengthDifference,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Difference tolerance = ",lineIncrementTolerance,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum difference line = ",maximumDifferenceLine,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of lines = ",decompositionLines%numberOfLines,err,error,*999)
      DO lineIdx=1,decompositionLines%numberOfLines
        CALL WriteStringFmtTwoValue(DIAGNOSTIC_OUTPUT_TYPE,"    Line ",lineIdx,"(I8)",": Length = ", &
          & geometricParameters%lengths(lineIdx),"*",err,error,*999)
      ENDDO !lineIdx
    ENDIF

    EXITS("Field_GeometricParametersLineLengthsCalculate")
    RETURN
999 IF(ASSOCIATED(interpolatedPoint)) CALL Field_InterpolatedPointFinalise(interpolatedPoint,dummyErr,dummyError,*998)
998 IF(ASSOCIATED(interpolationParameters)) CALL FieldVariable_InterpolationParameterFinalise(interpolationParameters, &
      & dummyErr,dummyError,*997)
997 ERRORS("Field_GeometricParametersLineLengthsCalculate",err,error)
    EXITS("Field_GeometricParametersLineLengthsCalculate")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersLineLengthsCalculate

  !
  !================================================================================================================================
  !

  !>Calculates the face areas from the parameters of a geometric field.
  SUBROUTINE Field_GeometricParametersFaceAreasCalculate(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to calculate the face areas for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,gaussPointIdx,faceIdx
    INTEGER(INTG) :: gaussStart(4) = [ 0,1,3,6 ]
    INTEGER(INTG) :: numberOfGaussPoints=4
    REAL(DP) :: xi(1),gaussWeight,faceArea
    REAL(DP) :: gaussPositions(10),gaussWeights(10)
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionFacesType), POINTER :: decompositionFaces
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(FieldGeometricParametersType), POINTER :: geometricParameters
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: interpolatedPointMetrics
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: dummyError,localError

    gaussPositions = [ 0.500000000000000_DP, &
      &                0.211324865405187_DP,0.788675134594813_DP, &
      &                0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
      &                0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
    gaussWeights = [ 1.000000000000000_DP, &
      &              0.500000000000000_DP,0.500000000000000_DP, &
      &              0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP, &
      &              0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]
    
    NULLIFY(interpolatedPoint)
    NULLIFY(interpolatedPointMetrics)
    NULLIFY(interpolationParameters)

    ENTERS("Field_GeometricParametersFaceAreasCalculate",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    IF(field%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
      localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" is not a geometric field."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(geometricParameters)
    CALL Field_GeometricParametersGet(field,geometricParameters,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(decompositionFaces)
    CALL DecompositionTopology_DecompositionFacesGet(decompositionTopology,decompositionFaces,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
    CALL FieldVariable_InterpolationParameterInitialise(fieldVariable,interpolationParameters,err,error,*999)
    CALL Field_InterpolatedPointInitialise(interpolationParameters,interpolatedPoint,err,error,*999)
    CALL Field_InterpolatedPointMetricsInitialise(interpolatedPoint,interpolatedPointMetrics,err,error,*999)
    !Loop over the faces
    DO faceIdx=1,decompositionFaces%numberOfFaces
      CALL Field_InterpolationParametersFaceGet(FIELD_VALUES_SET_TYPE,faceIdx,interpolationParameters,err,error,*999)
      faceArea=0.0_DP
      DO gaussPointIdx=1,numberOfGaussPoints
        xi(1)=gaussPositions(gaussStart(numberOfGaussPoints)+gaussPointIdx)
        gaussWeight=gaussWeights(gaussStart(numberOfGaussPoints)+gaussPointIdx)
        CALL Field_InterpolateXi(FIRST_PART_DERIV,xi,interpolatedPoint,err,error,*999)
        CALL Field_InterpolatedpointMetricsCalculate(COORDINATE_JACOBIAN_AREA_TYPE,interpolatedPointMetrics,err,error,*999)
        faceArea=faceArea+gaussWeight*interpolatedPointMetrics%jacobian
      ENDDO !gaussPointIdx
      field%geometricFieldParameters%areas(faceIdx)=faceArea
    ENDDO !faceIdx
    CALL Field_InterpolatedPointMetricsFinalise(interpolatedPointMetrics,err,error,*999)
    CALL Field_InterpolatedPointFinalise(interpolatedPoint,err,error,*999)
    CALL FieldVariable_InterpolationParameterFinalise(interpolationParameters,err,error,*999)

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Face areas:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of faces = ",decompositionFaces%numberOfFaces,err,error,*999)
      DO faceIdx=1,decompositionFaces%numberOfFaces
        CALL WriteStringFmtTwoValue(DIAGNOSTIC_OUTPUT_TYPE,"    Face ",faceIdx,"(I8)",": Area = ", &
          & geometricParameters%areas(faceIdx),"*",err,error,*999)
      ENDDO !faceIdx
    ENDIF

    EXITS("Field_GeometricParametersFaceAreasCalculate")
    RETURN
999 IF(ASSOCIATED(interpolatedPointMetrics)) CALL Field_InterpolatedPointMetricsFinalise(interpolatedPointMetrics, &
      & dummyErr,dummyError,*999)
    IF(ASSOCIATED(interpolatedPoint)) CALL Field_InterpolatedPointFinalise(interpolatedPoint,dummyErr,dummyError,*999)
    IF(ASSOCIATED(interpolationParameters)) CALL FieldVariable_InterpolationParameterFinalise(interpolationParameters, &
      & dummyErr,dummyError,*999)
    ERRORSEXITS("Field_GeometricParametersFaceAreasCalculate",err,error)
    RETURN 1

  END SUBROUTINE Field_GeometricParametersFaceAreasCalculate

  !
  !================================================================================================================================
  !

  !>Update the scale factors from the geometric parameters and if updateFieldsUsing also update and fields using these geometric parameters.
  SUBROUTINE Field_GeometricParametersScaleFactorsUpdate(field,updateFieldsUsing,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update the scale factors for
    LOGICAL, INTENT(IN) :: updateFieldsUsing !<If .TRUE. then update the fields that use this fields geometric parameters.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: fieldIdx,lastFieldIdx
    TYPE(FieldType), POINTER :: field2
    TYPE(FieldGeometricParametersType), POINTER :: geometricParameters
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_GeometricParametersScaleFactorsUpdate",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(field%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
      localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" is not a geometric field."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    NULLIFY(geometricParameters)
    CALL Field_GeometricParametersGet(field,geometricParameters,err,error,*999)
    IF(updateFieldsUsing) THEN
      lastFieldIdx=geometricParameters%numberOfFieldsUsing
    ELSE
      lastFieldIdx=1 !The first field using will be the current field
    ENDIF
    DO fieldIdx=1,lastFieldIdx
      field2=>geometricParameters%fieldsUsing(fieldIdx)%ptr
      CALL Field_ScalingsCalculate(field2,err,error,*999)
    ENDDO !fieldIdx

    EXITS("Field_GeometricParametersScaleFactorsUpdate")
    RETURN
999 ERRORSEXITS("Field_GeometricParametersScaleFactorsUpdate",err,error)
    RETURN 1

  END SUBROUTINE Field_GeometricParametersScaleFactorsUpdate

  !
  !================================================================================================================================
  !

  !>Initialises a field
  SUBROUTINE Field_Initialise(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the new field to initialise. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,variableTypeIdx
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("Field_Initialise",err,error,*998)

    IF(ASSOCIATED(field)) THEN
      CALL FlagError("Field is already associated.",err,error,*998)
    ELSE
      ALLOCATE(field,STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate field.",err,error,*999)      
      field%globalNumber=0
      field%userNumber=0
      field%label=""
      field%fieldFinished=.FALSE.
      NULLIFY(field%fields)
      NULLIFY(field%region)
      field%type=FIELD_GEOMETRIC_TYPE
      field%dependentType=FIELD_INDEPENDENT_TYPE
      NULLIFY(field%decomposition)
      field%numberOfVariables=0
      NULLIFY(field%geometricField)
      NULLIFY(field%geometricFieldParameters)
      NULLIFY(field%createValuesCache)
      ALLOCATE(field%variableTypeMap(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate field variable type map.",err,error,*999)
      DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
        NULLIFY(field%variableTypeMap(variableTypeIdx)%ptr)
      ENDDO !variableTypeIdx
    ENDIF

    EXITS("Field_Initialise")
    RETURN
999 CALL Field_Finalise(field,dummyErr,dummyError,*998)
998 ERRORSEXITS("Field_Initialise",err,error)
    RETURN 1

  END SUBROUTINE Field_Initialise

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a gauss point to give an interpolated point. partialDerivativeType controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated. Old CMISS name XEXG, ZEXG
  SUBROUTINE Field_InterpolateGauss(partialDerivativeType,quadratureScheme,gaussPointNumber,interpolatedPoint, &
    & err,error,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the provided field interpolation
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme of the Gauss points \see BasisRoutines_QuadratureSchemes,BasisRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The number of the Gauss point to interpolate the field at
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint !<The pointer to the interpolated point which will contain the field interpolation information at the specified Gauss point
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: componentIdx,endComponentIdx,partialDerivativeIdx,startComponentIdx,xiIdx
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolateGauss",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolatedPoint)) CALL FlagError("Interpolated point is not associated.",err,error,*999)
    
    NULLIFY(interpolationParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(interpolatedPoint,interpolationParameters,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSE IF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    
    SELECT CASE(partialDerivativeType)
    CASE(NO_PART_DERIV)
      DO componentIdx=startComponentidx,endComponentIdx
        SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)              
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          interpolatedPoint%values(componentIdx,1)=Basis_InterpolateGauss(interpolationParameters%bases( &
            & componentIdx)%ptr,NO_PART_DERIV,quadratureScheme,gaussPointNumber,interpolationParameters% &
            & parameters(:,componentIdx),err,error)
          IF(err/=0) GOTO 999
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(gaussPointNumber,componentIdx)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(componentIdx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(componentIdx,"*",err,error))//"."
        END SELECT
        CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
          & err,error,*999)
      ENDDO !componentIdx
      interpolatedPoint%partialDerivativeType=NO_PART_DERIV
    CASE(FIRST_PART_DERIV)
      DO componentIdx=startComponentidx,endComponentIdx
        SELECT CASE(interpolationParameters%fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO xiIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfXi
            partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !xiIdx
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO xiIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfXi
            partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !xiIdx
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=Basis_InterpolateGauss(interpolationParameters%bases( &
            & componentIdx)%ptr,NO_PART_DERIV,quadratureScheme,gaussPointNumber,interpolationParameters% &
            & parameters(:,componentIdx),err,error)
          IF(err/=0) GOTO 999
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO xiIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfXi
            partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=Basis_InterpolateGauss(interpolationParameters% &
              & BASES(componentIdx)%ptr,partialDerivativeIdx,quadratureScheme,gaussPointNumber, &
              & interpolationParameters%parameters(:,componentIdx),err,error)
            IF(err/=0) GOTO 999
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !xiIdx
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & components(componentIdx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(componentIdx,"*",err,error))//"."
        END SELECT
      ENDDO !componentIdx
      interpolatedPoint%partialDerivativeType=FIRST_PART_DERIV
    CASE(SECOND_PART_DERIV)
      DO componentIdx=startComponentidx,endComponentIdx
        SELECT CASE(interpolationParameters%fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO partialDerivativeIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfPartialDerivatives
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !partialDerivativeIdx
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO partialDerivativeIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfPartialDerivatives
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !partialDerivativeIdx
        CASE(FIELD_NODE_BASED_INTERPOLATION)              
          DO partialDerivativeIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfPartialDerivatives
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=Basis_InterpolateGauss(interpolationParameters% &
              & bases(componentIdx)%ptr,partialDerivativeIdx,quadratureScheme,gaussPointNumber, &
              & interpolationParameters%parameters(:,componentIdx),err,error)
            IF(err/=0) GOTO 999
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !partialDerivativeIdx
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & components(componentIdx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(componentIdx,"*",err,error))//"."
        END SELECT
      ENDDO !componentIdx
      interpolatedPoint%partialDerivativeType=SECOND_PART_DERIV
    CASE DEFAULT
      localError="The partial derivative type of "//TRIM(NumberToVString(partialDerivativeType,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_InterpolateGauss")
    RETURN
999 ERRORSEXITS("Field_InterpolateGauss",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolateGauss

  !
  !================================================================================================================================
  !

  !>Interpolates a field to give the physical value of the field at a node. Note that as we are at a node then we do not have any xi directions and thus we can not talk about gradients of the field wrt to xi. Because derviatives of fields can be discountinuous at a node the average derivative over all the elements surrounding the node is calculated.
  SUBROUTINE Field_InterpolateNode(physicalDerivativeType,parameterSetType,componentNumber,nodeNumber,physicalPoint,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: physicalDerivativeType !<The physical derivative type of the field interpolation \see Constants_PhysicalDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: parameterSetType !<The parameter set of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number to field that contains the node 
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<The node number in the component to interpolate the field at
    TYPE(FieldPhysicalPointType), POINTER :: physicalPoint !<The pointer to the physical point for the field. On return it will contain the values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,element,elementIdx,localNodeNumber,localNodeIdx,numberOfSurroundingElements, &
      & partialDerivativeIdx,xiIdx
    REAL(DP) :: xi(3),dXdXi(3,3),dXidX(3,3),detdXdXi
    TYPE(BasisType), POINTER :: basis
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field
    TYPE(FieldInterpolatedPointType), POINTER :: fieldInterpPoint,geometricInterpPoint
    TYPE(FieldInterpolationParametersType), POINTER :: fieldInterpParameters,geometricInterpParameters
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolateNode",err,error,*999)

    IF(.NOT.ASSOCIATED(physicalPoint)) CALL FlagError("Physical point is not associated.",err,error,*999)

    NULLIFY(fieldInterpPoint)
    CALL FieldPhysicalPoint_FieldInterpolatedPointGet(physicalPoint,fieldInterpPoint,err,error,*999)
    NULLIFY(geometricInterpPoint)
    CALL FieldPhysicalPoint_GeometricInterpolatedPointGet(physicalPoint,geometricInterpPoint,err,error,*999)
    NULLIFY(fieldInterpParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(fieldInterpPoint,fieldInterpParameters,err,error,*999)
    NULLIFY(geometricInterpParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(geometricInterpPoint,geometricInterpParameters,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(fieldInterpParameters,fieldVariable,err,error,*999)
    NULLIFY(geometricVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(geometricInterpParameters,geometricVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    NULLIFY(domain)
    CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
    NULLIFY(domainNodes)
    CALL DomainTopology_DomainNodesget(domainTopology,domainNodes,err,error,*999)
    NULLIFY(domainElements)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    IF(nodeNumber<1.OR.nodeNumber>domainNodes%numberOfNodes) THEN
      localError="The specified node number of "//TRIM(NumberToVString(nodeNumber,"*",err,error))// &
        & " is invalid. The node number needs to be >= 1 and <= "// &
        & TRIM(NumberToVString(domainNodes%numberOfNodes,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF    
    physicalPoint%values=0.0_DP
    IF(physicalDerivativeType==NO_PHYSICAL_DERIV) THEN
      numberOfSurroundingElements=1
    ELSE
      numberOfSurroundingElements=domainNodes%nodes(nodeNumber)%numberOfSurroundingElements
      physicalPoint%values=0.0_DP
    ENDIF
    !Loop over the elements surrounding the node
    DO elementIdx=1,numberOfSurroundingElements
      element=domainNodes%nodes(nodeNumber)%surroundingElements(elementIdx)
      CALL Field_InterpolationParametersElementGet(parameterSetType,element,fieldInterpParameters,err,error,*999)
      NULLIFY(basis)
      CALL DomainElements_ElementBasisGet(domainElements,element,basis,err,error,*999)
      localNodeNumber=0
      DO localNodeIdx=1,basis%numberOfNodes
        IF(domainElements%ELEMENTS(element)%elementNodes(localNodeIdx)==nodeNumber) THEN
          localNodeNumber=localNodeIdx
          EXIT
        ENDIF
      ENDDO !localNodeIdx
      IF(localNodeNumber==0) THEN
        localError="Could not find the local node for node "//TRIM(NumberToVString(nodeNumber,"*",err,error))// &
          & " in element number "//TRIM(NumberToVString(element,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      CALL Basis_LocalNodeXiCalculate(basis,localNodeNumber,xi,err,error,*999)  
      SELECT CASE(physicalDerivativeType)
      CASE(NO_PHYSICAL_DERIV)
        DO componentIdx=1,fieldVariable%numberOfComponents
          SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
          CASE(FIELD_CONSTANT_INTERPOLATION)
            physicalPoint%values(componentIdx)=fieldInterpParameters%parameters(1,componentIdx)
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            physicalPoint%values(componentIdx)=fieldInterpParameters%parameters(1,componentIdx)
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            physicalPoint%values(componentIdx)=Basis_InterpolateXi(fieldInterpParameters%bases(componentIdx)%ptr,NO_PART_DERIV, &
              & xi,fieldInterpParameters%parameters(:,componentIdx),err,error)
            IF(err/=0) GOTO 999
          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The field component interpolation type of "// &
              & TRIM(NumberToVString(fieldVariable%components(componentIdx)%interpolationType,"*",err,error))// &
              & " is invalid for component index "// &
              & TRIM(NumberToVString(componentIdx,"*",err,error))//"."
          END SELECT
        ENDDO !componentIdx
        physicalPoint%physicalDerivativeType=NO_PHYSICAL_DERIV
      CASE(GRADIENT_PHYSICAL_DERIV)
        DO componentIdx=1,fieldVariable%numberOfComponents
          SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
          CASE(FIELD_CONSTANT_INTERPOLATION)
            !There is no gradient for constant interpolation
            physicalPoint%values(componentIdx)=0.0_DP                                            
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            !There is no graident for element interpolation
            physicalPoint%values(componentIdx)=0.0_DP
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,element,geometricInterpParameters,err,error,*999)
            !Now process all the first partial derivatives
            DO xiIdx=1,fieldInterpParameters%bases(componentIdx)%ptr%numberOfXi
              partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
              !Interpolate the field
              fieldInterpPoint%values(componentIdx,partialDerivativeIdx)=Basis_InterpolateXi( &
                & fieldInterpParameters%bases(componentIdx)%ptr,partialDerivativeIdx,xi, &
                & fieldInterpParameters%parameters(:,componentIdx),err,error)
              IF(err/=0) GOTO 999
              CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
                & fieldInterpPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
              geometricInterpPoint%values(componentIdx,partialDerivativeIdx)=Basis_InterpolateXi( &
                & geometricInterpParameters%bases(componentIdx)%ptr,partialDerivativeIdx,xi, &
                & geometricInterpParameters%parameters(:,componentIdx),err,error)
              IF(err/=0) GOTO 999
              CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
                & geometricInterpPoint%values(componentIdx,partialDerivativeIdx), &
                & err,error,*999)
              dXdXi(componentIdx,xiIdx)=geometricInterpPoint%values(componentIdx,partialDerivativeIdx)
            ENDDO !xiIdx
          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The field component interpolation type of "// &
              & TRIM(NumberToVString(fieldInterpParameters%fieldVariable%components(componentIdx)% &
              & interpolationType,"*",err,error))//" is invalid for component index "// &
              & TRIM(NumberToVString(componentIdx,"*",err,error))//"."
          END SELECT
        ENDDO! componentIdx
        !Form the physical derivative
        CALL Invert(dXdXi,dXidX,detdXdXi,err,error,*999)
        DO componentIdx=1,fieldVariable%numberOfComponents
          DO xiIdx=1,fieldInterpParameters%bases(componentIdx)%ptr%numberOfXi
            partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
            physicalPoint%values(componentIdx)=physicalPoint%values(componentIdx)+ &
              & fieldInterpPoint%values(componentIdx,partialDerivativeIdx)*dXidX(xiIdx,componentIdx)
          ENDDO !xiIdx
        ENDDO !componentIdx
        physicalPoint%physicalDerivativeType=GRADIENT_PHYSICAL_DERIV
      CASE DEFAULT
        localError="The physical derivative type of "// &
          & TRIM(NumberToVString(physicalDerivativeType,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ENDDO !elementIdx
    IF(physicalDerivativeType==NO_PHYSICAL_DERIV) THEN
      !Now calculate the average of the interpolated physical point
      DO componentIdx=1,fieldVariable%numberOfComponents
        SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Do nothing
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Do nothing
        CASE(FIELD_NODE_BASED_INTERPOLATION)                                      
          physicalPoint%values(componentIdx)=physicalPoint%values(componentIdx)/REAL(numberOfSurroundingElements,DP)
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "// &
            & TRIM(NumberToVString(fieldInterpParameters% &
            & fieldVariable%components(componentIdx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "// &
            & TRIM(NumberToVString(componentIdx,"*",err,error))//"."
        END SELECT
      ENDDO !componentIdx
    ENDIF

    EXITS("Field_InterpolateNode")
    RETURN
999 ERRORSEXITS("Field_InterpolateNode",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolateNode

  !
  !================================================================================================================================
  !

  !>Interpolates a field to give the physical value of the field at a node in another field. Note that as we are at a node then we do not have any xi directions and thus we can not talk about gradients of the field wrt to xi. Because derviatives of fields can be discountinuous at a node the average derivative over all the elements surrounding the node is calculated.
  SUBROUTINE Field_InterpolateFieldNode(physicalDerivativeType,parameterSetType,field,variableType,componentNumber, &
    & nodeNumber,physicalPoint,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: physicalDerivativeType !<The physical derivative type of the field interpolation \see Constants_PhysicalDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: parameterSetType !<The parameter set of the field to interpolate.
    TYPE(FieldType), POINTER :: field !<The field containing the node to interpolate at.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type containing the node to interpolate at
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number to field that contains the node to interpolate at
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<The node number in the field variable component to interpolate the field at
    TYPE(FieldPhysicalPointType), POINTER :: physicalPoint !<The pointer to the physical point for the field. On return it will contain the values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_InterpolateFieldNode",err,error,*999)

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    
    CALL Field_InterpolateFieldVariableNode(physicalDerivativeType,parameterSetType,fieldVariable,componentNumber,nodeNumber, &
      & physicalPoint,err,error,*999)
    
    EXITS("Field_InterpolateFieldNode")
    RETURN
999 ERRORSEXITS("Field_InterpolateFieldNode",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolateFieldNode

  !
  !================================================================================================================================
  !

  !>Interpolates a field variableto give the physical value of the field variable at a node in another field. Note that as we are at a node then we do not have any xi directions and thus we can not talk about gradients of the field wrt to xi. Because derviatives of fields can be discountinuous at a node the average derivative over all the elements surrounding the node is calculated.
  SUBROUTINE Field_InterpolateFieldVariableNode(physicalDerivativeType,parameterSetType,fieldVariable,componentNumber, &
    & nodeNumber,physicalPoint,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: physicalDerivativeType !<The physical derivative type of the field interpolation \see Constants_PhysicalDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: parameterSetType !<The parameter set of the field variableto interpolate.
    TYPE(FieldVariableType), POINTER :: fieldVariable !<The field variable containing the node to interpolate at.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number to field variable that contains the node to interpolate at
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<The node number in the field variable component to interpolate the field at
    TYPE(FieldPhysicalPointType), POINTER :: physicalPoint !<The pointer to the physical point for the field. On return it will contain the values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,element,elementIdx,localNodeNumber,localNodeIdx,numberOfSurroundingElements, &
      & partialDerivativeIdx,xiIdx
    REAL(DP) :: xi(3),dXdXi(3,3),dXidX(3,3),detdXdXi
    TYPE(BasisType), POINTER :: basis
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: interpField
    TYPE(FieldInterpolatedPointType), POINTER :: fieldInterpPoint,geometricInterpPoint
    TYPE(FieldInterpolationParametersType), POINTER :: fieldInterpParameters,geometricInterpParameters
    TYPE(FieldVariableType), POINTER :: interpVariable,geometricVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolateFieldVariableNode",err,error,*999)

    IF(.NOT.ASSOCIATED(physicalPoint)) CALL FlagError("Physical point is not associated.",err,error,*999)
    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    
    NULLIFY(fieldInterpPoint)
    CALL FieldPhysicalPoint_FieldInterpolatedPointGet(physicalPoint,fieldInterpPoint,err,error,*999)
    NULLIFY(geometricInterpPoint)
    CALL FieldPhysicalPoint_GeometricInterpolatedPointGet(physicalPoint,geometricInterpPoint,err,error,*999)
    NULLIFY(fieldInterpParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(fieldInterpPoint,fieldInterpParameters,err,error,*999)
    NULLIFY(geometricInterpParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(geometricInterpPoint,geometricInterpParameters,err,error,*999)
    NULLIFY(interpVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(fieldInterpParameters,interpVariable,err,error,*999)
    NULLIFY(geometricVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(geometricInterpParameters,geometricVariable,err,error,*999)
    NULLIFY(interpField)
    CALL FieldVariable_FieldGet(interpVariable,interpField,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(interpField,coordinateSystem,err,error,*999)
    NULLIFY(domain)
    CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
    NULLIFY(domainNodes)
    CALL DomainTopology_DomainNodesget(domainTopology,domainNodes,err,error,*999)
    NULLIFY(domainElements)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    IF(nodeNumber<1.OR.nodeNumber>domainNodes%numberOfNodes) THEN
      localError="The specified node number of "//TRIM(NumberToVString(nodeNumber,"*",err,error))// &
        & " is invalid. The node number needs to be >= 1 and <= "// &
        & TRIM(NumberToVString(domainNodes%numberOfNodes,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    physicalPoint%values=0.0_DP
    IF(physicalDerivativeType==NO_PHYSICAL_DERIV) THEN
      numberOfSurroundingElements=1
    ELSE
      numberOfSurroundingElements=domainNodes%nodes(nodeNumber)% &
        & numberOfSurroundingElements
      physicalPoint%VALUES=0.0_DP
    ENDIF
    !Loop over the elements surrounding the node
    DO elementIdx=1,numberOfSurroundingElements
      element=domainNodes%nodes(nodeNumber)%surroundingElements(elementIdx)
      CALL Field_InterpolationParametersElementGet(parameterSetType,element,fieldInterpParameters,err,error,*999)
      NULLIFY(basis)
      CALL DomainElements_ElementBasisGet(domainElements,element,basis,err,error,*999)
      localNodeNumber=0
      DO localNodeIdx=1,basis%numberOfNodes
        IF(domainElements%elements(element)%elementNodes(localNodeIdx)==nodeNumber) THEN
          localNodeNumber=localNodeIdx
          EXIT
        ENDIF
      ENDDO !localNodeIdx
      IF(localNodeNumber==0) THEN
        localError="Could not find the local node for node "// &
          & TRIM(NumberToVString(nodeNumber,"*",err,error))//" in element number "// &
          & TRIM(NumberToVString(element,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      CALL Basis_LocalNodeXiCalculate(basis,localNodeNumber,xi,err,error,*999)  
      SELECT CASE(physicalDerivativeType)
      CASE(NO_PHYSICAL_DERIV)
        DO componentIdx=1,interpVariable%numberOfComponents
          SELECT CASE(interpVariable%components(componentIdx)%interpolationType)
          CASE(FIELD_CONSTANT_INTERPOLATION)
            physicalPoint%values(componentIdx)=fieldInterpParameters%parameters(1,componentIdx)
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            physicalPoint%values(componentIdx)=fieldInterpParameters%parameters(1,componentIdx)
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            physicalPoint%values(componentIdx)=Basis_InterpolateXi( &
              & fieldInterpParameters%bases(componentIdx)%ptr,NO_PART_DERIV, &
              & xi,fieldInterpParameters%parameters(:,componentIdx),err,error)
            IF(err/=0) GOTO 999
          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The field component interpolation type of "// &
              & TRIM(NumberToVString(interpVariable%components(componentIdx)% &
              & interpolationType,"*",err,error))//" is invalid for component index "// &
              & TRIM(NumberToVString(componentIdx,"*",err,error))//"."
          END SELECT
        ENDDO! componentIdx
        physicalPoint%physicalDerivativeType=NO_PHYSICAL_DERIV
      CASE(GRADIENT_PHYSICAL_DERIV)
        DO componentIdx=1,interpVariable%numberOfComponents
          SELECT CASE(interpVariable%components(componentIdx)%interpolationType)
          CASE(FIELD_CONSTANT_INTERPOLATION)
            !There is no gradient for constant interpolation
            physicalPoint%values(componentIdx)=0.0_DP
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            !There is no graident for element interpolation
            physicalPoint%values(componentIdx)=0.0_DP
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,element,geometricInterpParameters,err,error,*999)
            !Now process all the first partial derivatives
            DO xiIdx=1,fieldInterpParameters%bases(componentIdx)%ptr%numberOfXi
              partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
              !Interpolate the field
              fieldInterpPoint%values(componentIdx,partialDerivativeIdx)=Basis_InterpolateXi( &
                & fieldInterpParameters%bases(componentIdx)%ptr,partialDerivativeIdx,xi, &
                & fieldInterpParameters%parameters(:,componentIdx),err,error)
              IF(err/=0) GOTO 999
              CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
                & fieldInterpPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
              geometricInterpPoint%values(componentIdx,partialDerivativeIdx) = &
                & Basis_InterpolateXi(geometricInterpParameters%bases(componentIdx)% &
                & PTR,partialDerivativeIdx,xi,geometricInterpParameters%parameters(:, &
                & componentIdx),err,error)
              IF(err/=0) GOTO 999
              CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
                & geometricInterpPoint%values(componentIdx,partialDerivativeIdx), &
                & err,error,*999)
              dXdXi(componentIdx,xiIdx)=geometricInterpPoint%values(componentIdx,partialDerivativeIdx)
            ENDDO !xiIdx
          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The field component interpolation type of "// &
              & TRIM(NumberToVString(fieldInterpParameters% &
              & fieldVariable%components(componentIdx)%interpolationType,"*",err,error))// &
              & " is invalid for component index "// &
              & TRIM(NumberToVString(componentIdx,"*",err,error))//"."
          END SELECT
        ENDDO! componentIdx
        !Form the physical derivative
        CALL Invert(dXdXi,dXidX,detdXdXi,err,error,*999)
        DO componentIdx=1,interpVariable%numberOfComponents
          DO xiIdx=1,fieldInterpParameters%bases(componentIdx)%ptr%numberOfXi
            partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
            physicalPoint%values(componentIdx)=physicalPoint%values(componentIdx)+ &
              & fieldInterpPoint%values(componentIdx,partialDerivativeIdx)*dXidX(xiIdx,componentIdx)
          ENDDO !xiIdx
        ENDDO !componentIdx
        physicalPoint%physicalDerivativeType=GRADIENT_PHYSICAL_DERIV
      CASE DEFAULT
        localError="The physical derivative type of "// &
          & TRIM(NumberToVString(physicalDerivativeType,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ENDDO !elementIdx
    IF(physicalDerivativeType==NO_PHYSICAL_DERIV) THEN
      !Now calculate the average of the interpolated physical point
      DO componentIdx=1,interpVariable%numberOfComponents
        SELECT CASE(interpVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Do nothing
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Do nothing
        CASE(FIELD_NODE_BASED_INTERPOLATION)                                      
          physicalPoint%values(componentIdx)=physicalPoint%values(componentIdx)/REAL(numberOfSurroundingElements,DP)
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "// &
            & TRIM(NumberToVString(interpVariable%components(componentIdx)% &
            & interpolationType,"*",err,error))// &
            & " is invalid for component index "// &
            & TRIM(NumberToVString(componentIdx,"*",err,error))//"."
        END SELECT
      ENDDO !componentIdx
    ENDIF

    EXITS("Field_InterpolateFieldVariableNode")
    RETURN
999 ERRORSEXITS("Field_InterpolateFieldVariableNode",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolateFieldVariableNode

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a face gauss point to give an interpolated point. partialDerivativeType controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated.
  SUBROUTINE Field_InterpolateLocalFaceGauss(partialDerivativeType,quadratureScheme,localFaceNumber, &
    & gaussPointNumber,interpolatedPoint,err,error,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the provided field interpolation
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme of the Gauss points \see BasisRoutines_QuadratureSchemes,BasisRoutines
    INTEGER(INTG), INTENT(IN) :: localFaceNumber !<The index number of the face to interpolate on
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The number of the face Gauss point to interpolate the field at
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint !<The pointer to the interpolated point which will contain the field interpolation information at the specified Gauss point
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: componentIdx,xiIdx,partialDerivativeIdx,startComponentIdx,endComponentIdx
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolateLocalFaceGauss",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolatedPoint)) CALL FlagError("Interpolated point is not associated.",err,error,*999)
    
    NULLIFY(interpolationParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(interpolatedPoint,interpolationParameters,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSEIF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    
    SELECT CASE(partialDerivativeType)
    CASE(NO_PART_DERIV)
      DO componentIdx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)              
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          interpolatedPoint%values(componentIdx,1)=Basis_InterpolateLocalFaceGauss(interpolationParameters%bases( &
            & componentIdx)%ptr,NO_PART_DERIV,quadratureScheme,localFaceNumber,gaussPointNumber, &
            & interpolationParameters%parameters(:,componentIdx),err,error)
          IF(err/=0) GOTO 999
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(componentIdx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(componentIdx,"*",err,error))//"."
        END SELECT
        CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
          & err,error,*999)
      ENDDO !componentIdx
      interpolatedPoint%partialDerivativeType=NO_PART_DERIV
    CASE(FIRST_PART_DERIV)
      DO componentIdx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO xiIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfXi
            partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !xiIdx
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO xiIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfXi
            partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !xiIdx
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=Basis_InterpolateLocalFaceGauss(interpolationParameters%bases( &
            & componentIdx)%ptr,NO_PART_DERIV,quadratureScheme,localFaceNumber,gaussPointNumber, &
            & interpolationParameters%parameters(:,componentIdx),err,error)
          IF(err/=0) GOTO 999
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO xiIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfXi
            partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=Basis_InterpolateLocalFaceGauss( &
              & interpolationParameters%bases(componentIdx)%ptr,partialDerivativeIdx,quadratureScheme, &
              & localFaceNumber,gaussPointNumber,interpolationParameters%parameters(:,componentIdx),err,error)
            IF(err/=0) GOTO 999
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !xiIdx
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(componentIdx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(componentIdx,"*",err,error))//"."
        END SELECT
      ENDDO !componentIdx
      interpolatedPoint%partialDerivativeType=FIRST_PART_DERIV
    CASE(SECOND_PART_DERIV)
      DO componentIdx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO partialDerivativeIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfPartialDerivatives
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !partialDerivativeIdx
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO partialDerivativeIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfPartialDerivatives
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !partialDerivativeIdx
        CASE(FIELD_NODE_BASED_INTERPOLATION)              
          DO partialDerivativeIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfPartialDerivatives
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=Basis_InterpolateLocalFaceGauss( &
              & interpolationParameters%bases(componentIdx)%ptr,partialDerivativeIdx,quadratureScheme, &
              & localFaceNumber,gaussPointNumber,interpolationParameters%parameters(:,componentIdx),err,error)
            IF(err/=0) GOTO 999
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !partialDerivativeIdx
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(componentIdx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(componentIdx,"*",err,error))//"."
        END SELECT
      ENDDO !componentIdx
      interpolatedPoint%partialDerivativeType=SECOND_PART_DERIV
    CASE DEFAULT
      localError="The partial derivative type of "//TRIM(NumberToVString(partialDerivativeType,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_InterpolateLocalFaceGauss")
    RETURN
999 ERRORSEXITS("Field_InterpolateLocalFaceGauss",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolateLocalFaceGauss

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a xi location to give an interpolated point. XI is the element location to be interpolated at. partialDerivativeType controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated. Old CMISS name PXI
  SUBROUTINE Field_InterpolateXi(partialDerivativeType,xi,interpolatedPoint,err,error,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the provide field interpolation
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The xiIdx'th Xi coordinate to evaluate the field at
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint !<The pointer to the interpolated point which will contain the field interpolation information at the specified Xi point
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: componentIdx,xiIdx,partialDerivativeIdx,startComponentIdx,endComponentIdx
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolateXi",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolatedPoint)) CALL FlagError("Interpolated point is not associated.",err,error,*999)
    
    NULLIFY(interpolationParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(interpolatedPoint,interpolationParameters,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSE IF(interpolationParameters%field%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    
    SELECT CASE(partialDerivativeType)
    CASE(NO_PART_DERIV)
      DO componentIdx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)              
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          interpolatedPoint%values(componentIdx,1)=Basis_InterpolateXi(interpolationParameters% &
            & bases(componentIdx)%ptr,NO_PART_DERIV,xi,interpolationParameters%parameters(:,componentIdx),err,error)
          IF(err/=0) GOTO 999
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & components(componentIdx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(componentIdx,"*",err,error))//"."
        END SELECT
        CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
          & err,error,*999)
      ENDDO !componentIdx
      interpolatedPoint%partialDerivativeType=NO_PART_DERIV
    CASE(FIRST_PART_DERIV)
      DO componentIdx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO xiIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfXi
            partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !xiIdx
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO xiIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfXi
            partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !xiIdx
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=Basis_InterpolateXi(interpolationParameters% &
            & bases(componentIdx)%ptr,NO_PART_DERIV,xi,interpolationParameters%parameters(:,componentIdx),err,error)
          IF(err/=0) GOTO 999
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO xiIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfXi
            partialDerivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx)
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=Basis_InterpolateXi(interpolationParameters% &
              & BASES(componentIdx)%ptr,partialDerivativeIdx,xi,interpolationParameters%parameters(:,componentIdx), &
              & err,error)
            IF(err/=0) GOTO 999
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !xiIdx
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(componentIdx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(componentIdx,"*",err,error))//"."
        END SELECT
      ENDDO !componentIdx
      interpolatedPoint%partialDerivativeType=FIRST_PART_DERIV
    CASE(SECOND_PART_DERIV)
      DO componentIdx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO partialDerivativeIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfPartialDerivatives
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !partialDerivativeIdx
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          interpolatedPoint%values(componentIdx,1)=interpolationParameters%parameters(1,componentIdx)
          CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,NO_PART_DERIV,interpolatedPoint%values(componentIdx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO partialDerivativeIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfPartialDerivatives
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=0.0_DP
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO !partialDerivativeIdx
        CASE(FIELD_NODE_BASED_INTERPOLATION)              
          DO partialDerivativeIdx=1,interpolationParameters%bases(componentIdx)%ptr%numberOfPartialDerivatives
            interpolatedPoint%values(componentIdx,partialDerivativeIdx)=Basis_InterpolateXi(interpolationParameters% &
              & BASES(componentIdx)%ptr,partialDerivativeIdx,xi,interpolationParameters%parameters(:,componentIdx), &
              & err,error)
            IF(err/=0) GOTO 999
            CALL CoordinateSystem_InterpolationAdjust(coordinateSystem,partialDerivativeIdx, &
              & interpolatedPoint%values(componentIdx,partialDerivativeIdx),err,error,*999)
          ENDDO! partialDerivativeIdx
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(componentIdx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(componentIdx,"*",err,error))//"."
        END SELECT
      ENDDO !componentIdx
      interpolatedPoint%partialDerivativeType=SECOND_PART_DERIV
    CASE DEFAULT
      localError="The partial derivative type of "//TRIM(NumberToVString(partialDerivativeType,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_InterpolateXi")
    RETURN
999 ERRORSEXITS("Field_InterpolateXi",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolateXi

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point and deallocates all memory.
  SUBROUTINE Field_InterpolatedPointFinalise(interpolatedPoint,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint !<A pointer to the interpolated point to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_InterpolatedPointFinalise",err,error,*999)

    IF(ASSOCIATED(interpolatedPoint)) THEN
      IF(ALLOCATED(interpolatedPoint%values)) DEALLOCATE(interpolatedPoint%values)
      DEALLOCATE(interpolatedPoint)
    ENDIF

    EXITS("Field_InterpolatedPointFinalise")
    RETURN
999 ERRORSEXITS("Field_InterpolatedPointFinalise",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolatedPointFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point for an interpolation parameters
  SUBROUTINE Field_InterpolatedPointInitialise(interpolationParameters,interpolatedPoint,err,error,*,componentType)

    !Argument variables
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters !<A pointer to the interpolation parameters to initialise the interpolated point for
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint !<On exit, A pointer to the interpolated point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: dummyErr,numberOfDimensions,numberOfComponents
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: dummyError,localError

    ENTERS("Field_InterpolatedPointInitialise",err,error,*998)

    IF(ASSOCIATED(interpolatedPoint)) CALL FlagError("Interpolated point is already associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(interpolationParameters)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)

    ALLOCATE(interpolatedPoint,STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate interpolated point.",err,error,*999)
    interpolatedPoint%interpolationParameters=>interpolationParameters
    numberOfDimensions=decomposition%numberOfDimensions
    interpolatedPoint%maximumPartialDerivativeIndex=PARTIAL_DERIVATIVE_MAXIMUM_MAP(numberOfDimensions)
    !Calculate the number of components for the interpolated point
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        numberOfComponents=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          numberOfComponents=geometricVariable%numberOfComponents
        ELSE IF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          numberOfComponents=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          numberOfComponents=fieldVariable%numberOfComponents-geometricVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE !.NOT.(PRESENT(componentType)) -default all components
      numberOfComponents=fieldVariable%numberOfComponents
    ENDIF
    ALLOCATE(interpolatedPoint%values(numberOfComponents,interpolatedPoint%maximumPartialDerivativeIndex),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate interpolated point values.",err,error,*999)
    interpolatedPoint%VALUES=0.0_DP

    EXITS("Field_InterpolatedPointInitialise")
    RETURN
999 CALL Field_InterpolatedPointFinalise(interpolatedPoint,dummyErr,dummyError,*998)
998 ERRORSEXITS("Field_InterpolatedPointInitialise",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolatedPointInitialise

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point and deallocates all memory.
  SUBROUTINE Field_InterpolatedPointsFinalise(interpolatedPoints,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointPtrType), POINTER :: interpolatedPoints(:) !<A pointer to the interpolated point to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableTypeIdx

    ENTERS("Field_InterpolatedPointsFinalise",err,error,*999)

    IF(ASSOCIATED(interpolatedPoints)) THEN
      DO variableTypeIdx=1,SIZE(interpolatedPoints,1)
        CALL Field_InterpolatedPointFinalise(interpolatedPoints(variableTypeIdx)%ptr,err,error,*999)
      ENDDO !variableTypeIdx
      DEALLOCATE(interpolatedPoints)
    ENDIF

    EXITS("Field_InterpolatedPointsFinalise")
    RETURN
999 ERRORSEXITS("Field_InterpolatedPointsFinalise",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolatedPointsFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point for an interpolation parameters
  SUBROUTINE Field_InterpolatedPointsInitialise(interpolationParameters,interpolatedPoints,err,error,*,componentType)

    !Argument variables
    TYPE(FieldInterpolationParametersPtrType), POINTER :: interpolationParameters(:) !<A pointer to the interpolation parameters to initialise the interpolated point for
    TYPE(FieldInterpolatedPointPtrType), POINTER :: interpolatedPoints(:) !<On exit, A pointer to the interpolated point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: dummyErr,variableTypeIdx
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("Field_InterpolatedPointsInitialise",err,error,*998)

    IF(ASSOCIATED(interpolatedPoints)) CALL FlagError("Interpolated point is already associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(interpolationParameters)) CALL FlagError("Interpolation parameters is not associated.",err,error,*998)
      
    ALLOCATE(interpolatedPoints(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate interpolated points.",err,error,*999)
    DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
      NULLIFY(interpolatedPoints(variableTypeIdx)%ptr)
      IF(ASSOCIATED(interpolationParameters(variableTypeIdx)%ptr)) THEN
        IF(PRESENT(componentType)) THEN
          CALL Field_InterpolatedPointInitialise(interpolationParameters(variableTypeIdx)%ptr, &
            & interpolatedPoints(variableTypeIdx)%ptr,err,error,*999,componentType)
        ELSE
          CALL Field_InterpolatedPointInitialise(interpolationParameters(variableTypeIdx)%ptr, &
            & interpolatedPoints(variableTypeIdx)%ptr,err,error,*999)
        ENDIF
      ENDIF
    ENDDO !variableTypeIdx

    EXITS("Field_InterpolatedPointsInitialise")
    RETURN
999 CALL Field_InterpolatedPointsFinalise(interpolatedPoints,dummyErr,dummyError,*998)
998 ERRORSEXITS("Field_InterpolatedPointsInitialise",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolatedPointsInitialise

  !
  !================================================================================================================================
  !

  !>Calculates the interpolated point metrics and the associated interpolated point
  SUBROUTINE Field_InterpolatedpointMetricsCalculate(jacobianType,interpolatedPointMetrics,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: interpolatedPointMetrics !<A pointer to the interpolated point metrics
    INTEGER(INTG), INTENT(IN) :: jacobianType !<The Jacobian type of the calculation \see CoordinateRoutines_JacobianTypes,CoordinateRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(FieldType), POINTER :: field
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_InterpolatedpointMetricsCalculate",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolatedPointMetrics)) CALL FlagError("Interpolated point metrics is not associated.",err,error,*999)
    
    NULLIFY(interpolatedPoint)
    CALL FieldInterpolatedPointMetrics_InterpolatedPointGet(interpolatedPointMetrics,interpolatedPoint,err,error,*999)
    NULLIFY(interpolationParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(interpolatedPoint,interpolationParameters,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    interpolatedPointMetrics%numberOfXiDimensions=interpolationParameters%numberOfXi
    IF(field%TYPE==FIELD_GEOMETRIC_TYPE.OR.field%TYPE==FIELD_FIBRE_TYPE.OR.field%TYPE==FIELD_GENERAL_TYPE &
      & .OR.field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
      NULLIFY(coordinateSystem)
      CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
      CALL CoordinateSystem_MetricsCalculate(coordinateSystem,jacobianType,interpolatedPointMetrics,err,error,*999)
    ELSE
      CALL FlagError("The field is not a geometric or fibre field.",err,error,*999)
    ENDIF

    EXITS("Field_InterpolatedpointMetricsCalculate")
    RETURN
999 ERRORSEXITS("Field_InterpolatedpointMetricsCalculate",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolatedpointMetricsCalculate

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point metrics and deallocates all memory.
  SUBROUTINE Field_InterpolatedPointMetricsFinalise(interpolatedPointMetrics,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: interpolatedPointMetrics !<A pointer to the interpolated point metrics to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_InterpolatedPointMetricsFinalise",err,error,*999)

    IF(ASSOCIATED(interpolatedPointMetrics)) THEN
      IF(ALLOCATED(interpolatedPointMetrics%GL)) DEALLOCATE(interpolatedPointMetrics%GL)
      IF(ALLOCATED(interpolatedPointMetrics%GU)) DEALLOCATE(interpolatedPointMetrics%GU)
      IF(ALLOCATED(interpolatedPointMetrics%dXdXi)) DEALLOCATE(interpolatedPointMetrics%dXdXi)
      IF(ALLOCATED(interpolatedPointMetrics%dXidX)) DEALLOCATE(interpolatedPointMetrics%dXidX)
      DEALLOCATE(interpolatedPointMetrics)
    ENDIF

    EXITS("Field_InterpolatedPointMetricsFinalise")
    RETURN
999 ERRORSEXITS("Field_InterpolatedPointMetricsFinalise",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolatedPointMetricsFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point metrics for an interpolated point.
  SUBROUTINE Field_InterpolatedPointMetricsInitialise(interpolatedPoint,interpolatedPointMetrics,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint !A pointer to the interpolated point to initliase the interpolated point metrics for
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: interpolatedPointMetrics !<On exit, a pointer to the interpolated point metrics that have been initialised
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,numberOfXiDimensions,numberOfXDimensions
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: dummyError !,localError

    ENTERS("Field_InterpolatedPointMetricsInitialise",err,error,*998)

    IF(ASSOCIATED(interpolatedPointMetrics)) CALL FlagError("Interpolated point metrics is already associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(interpolatedPoint)) CALL FlagError("Interpolated point is not associated.",err,error,*998)

    NULLIFY(interpolationParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(interpolatedPoint,interpolationParameters,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    numberOfXDimensions=coordinateSystem%numberOfDimensions
    numberOfXiDimensions=decomposition%numberOfDimensions
    !Size of interpolated point values may be greater than number of x dimensions, as FIELD_GEOMETRIC_GENERAL_TYPE
    !fields can have geometric components and then other non-geometric components, eg. for dependent fields with
    !geometric components.
    IF(numberOfXDimensions<=SIZE(interpolatedPoint%values,1)) THEN      
      ALLOCATE(interpolatedPointMetrics,STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate interpolated point metrics.",err,error,*999)
      ALLOCATE(interpolatedPointMetrics%gl(numberOfXiDimensions,numberOfXiDimensions),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate interpolated point metrics convariant tensor.",err,error,*999)
      ALLOCATE(interpolatedPointMetrics%gu(numberOfXiDimensions,numberOfXiDimensions),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate interpolated point metrics contravariant tensor.",err,error,*999)
      ALLOCATE(interpolatedPointMetrics%dXdXi(numberOfXDimensions,numberOfXiDimensions),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate interpolated point metrics dXdXi.",err,error,*999)
      ALLOCATE(interpolatedPointMetrics%dXidX(numberOfXiDimensions,numberOfXDimensions),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate interpolated point metrics dXidX.",err,error,*999)
      interpolatedPointMetrics%interpolatedPoint=>interpolatedPoint
      interpolatedPointMetrics%numberOfXDimensions=numberOfXDimensions
      interpolatedPointMetrics%numberOfXiDimensions=numberOfXiDimensions
      interpolatedPointMetrics%gl=0.0_DP
      interpolatedPointMetrics%gu=0.0_DP
      interpolatedPointMetrics%dXdXi=0.0_DP
      interpolatedPointMetrics%dXidX=0.0_DP
      interpolatedPointMetrics%jacobian=0.0_DP
      interpolatedPointMetrics%jacobianType=0
    ENDIF

    EXITS("Field_InterpolatedPointMetricsInitialise")
    RETURN
999 CALL Field_InterpolatedPointMetricsFinalise(interpolatedPointMetrics,dummyErr,dummyError,*998)
998 ERRORSEXITS("Field_InterpolatedPointMetricsInitialise",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolatedPointMetricsInitialise

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point metrics and deallocates all memory.
  SUBROUTINE Field_InterpolatedPointsMetricsFinalise(interpolatedPointsMetrics,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointMetricsPtrType), POINTER :: interpolatedPointsMetrics(:) !<A pointer to the interpolated point metrics to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableTypeIdx

    ENTERS("Field_InterpolatedPointsMetricsFinalise",err,error,*999)

    IF(ASSOCIATED(interpolatedPointsMetrics)) THEN
      DO variableTypeIdx=1,SIZE(interpolatedPointsMetrics,1)
        CALL Field_InterpolatedPointMetricsFinalise(interpolatedPointsMetrics(variableTypeIdx)%ptr,err,error,*999)
      ENDDO !variableTypeIdx
      DEALLOCATE(interpolatedPointsMetrics)
    ENDIF

    EXITS("Field_InterpolatedPointsMetricsFinalise")
    RETURN
999 ERRORSEXITS("Field_InterpolatedPointsMetricsFinalise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_InterpolatedPointsMetricsFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point metrics for an interpolated point.
  SUBROUTINE Field_InterpolatedPointsMetricsInitialise(interpolatedPoints,interpolatedPointsMetrics,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointPtrType), POINTER :: interpolatedPoints(:) !A pointer to the interpolated pointS to initliase the interpolated point metrics for
    TYPE(FieldInterpolatedPointMetricsPtrType), POINTER :: interpolatedPointsMetrics(:) !<On exit, a pointer to the interpolated point metrics that have been initialised
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,variableTypeIdx
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("Field_InterpolatedPointsMetricsInitialise",err,error,*998)

    IF(ASSOCIATED(interpolatedPointsMetrics)) CALL FlagError("Interpolated point metrics is already associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(interpolatedPoints)) CALL FlagError("Interpolation points is not associated.",err,error,*998)
      
    ALLOCATE(interpolatedPointsMetrics(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate interpolated points metrics.",err,error,*999)
    !Nullify all pointers first so that finalise does not fail on error condition half way through the next loop
    DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
      NULLIFY(interpolatedPointsMetrics(variableTypeIdx)%ptr)          
    ENDDO !variableTypeIdx
    DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
      IF(ASSOCIATED(interpolatedPoints(variableTypeIdx)%ptr)) &
        & CALL Field_InterpolatedPointMetricsInitialise(interpolatedPoints(variableTypeIdx)%ptr, &
        & interpolatedPointsMetrics(variableTypeIdx)%ptr,err,error,*999)
    ENDDO !variableTypeIdx

    EXITS("Field_InterpolatedPointsMetricsInitialise")
    RETURN
999 CALL Field_InterpolatedPointsMetricsFinalise(interpolatedPointsMetrics,dummyErr,dummyError,*998)
998 ERRORSEXITS("Field_InterpolatedPointsMetricsInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_InterpolatedPointsMetricsInitialise

  !
  !================================================================================================================================
  !

  !>Finalises the interpolation parameters and deallocates all memory
  SUBROUTINE FieldVariable_InterpolationParameterFinalise(interpolationParameters,err,error,*)

    !Argument variables
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters !<A pointer to the interpolation parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariable_InterpolationParameterFinalise",err,error,*999)

    IF(ASSOCIATED(interpolationParameters)) THEN
      IF(ALLOCATED(interpolationParameters%bases)) DEALLOCATE(interpolationParameters%bases)
      IF(ALLOCATED(interpolationParameters%numberOfParameters)) DEALLOCATE(interpolationParameters%numberOfParameters)
      IF(ALLOCATED(interpolationParameters%parameters)) DEALLOCATE(interpolationParameters%parameters)
      IF(ALLOCATED(interpolationParameters%scaleFactors)) DEALLOCATE(interpolationParameters%scaleFactors)      
      DEALLOCATE(interpolationParameters)
    ENDIF

    EXITS("FieldVariable_InterpolationParameterFinalise")
    RETURN
999 ERRORS("FieldVariable_InterpolationParameterFinalise",err,error)
    EXITS("FieldVariable_InterpolationParameterFinalise")
    RETURN 1
    
  END SUBROUTINE FieldVariable_InterpolationParameterFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the interpolation parameters for all the variables in a field.
  SUBROUTINE FieldVariable_InterpolationParameterInitialise(fieldVariable,interpolationParameters,err,error,*,componentType)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field to initialise the interpolation parameters for
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters !<On exit, a pointer to the initialised interpolation parameters. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: componentIdx,dummyErr,numberOfComponents
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldVariableType), POINTER :: geometricVariable
    TYPE(VARYING_STRING) :: dummyError,localError

    ENTERS("FieldVariable_InterpolationParameterInitialise",err,error,*998)

    IF(ASSOCIATED(interpolationParameters)) CALL FlagError("Interpolation parameters is already associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*998)

    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    ALLOCATE(interpolationParameters,STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate interpolation parameters.",err,error,*999)
    interpolationParameters%field=>field
    interpolationParameters%fieldVariable=>fieldVariable
    interpolationParameters%numberOfXi=0
    !Calculate the number of components required 
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        numberOfComponents=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          numberOfComponents=geometricVariable%numberOfComponents
        ELSEIF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          numberOfComponents=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          numberOfComponents=fieldVariable%numberOfComponents-geometricVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      numberOfComponents=fieldVariable%numberOfComponents
    ENDIF
    
    ALLOCATE(interpolationParameters%bases(numberOfComponents),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate interpolation parameters bases.",err,error,*999)
    ALLOCATE(interpolationParameters%numberOfParameters(numberOfComponents),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate interpolation parameters number of parameters.",err,error,*999)
    ALLOCATE(interpolationParameters%parameters(fieldVariable%maxNumberElementInterpolationParameters, &
      & numberOfComponents),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate interpolation parameters parameters.",err,error,*999)
    interpolationParameters%parameters=0.0_DP
    IF(field%scalings%scalingType/=FIELD_NO_SCALING) THEN
      ALLOCATE(interpolationParameters%scaleFactors(fieldVariable%maxNumberElementInterpolationParameters, &
        & numberOfComponents),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate interpolation parameters scale factors.",err,error,*999)
      interpolationParameters%scaleFactors=0.0_DP
    ENDIF
    DO componentIdx=1,numberOfComponents
      NULLIFY(interpolationParameters%bases(componentIdx)%ptr)
    ENDDO !componentIdx
    interpolationParameters%numberOfParameters=0

    EXITS("FieldVariable_InterpolationParameterInitialise")
    RETURN
999 CALL FieldVariable_InterpolationParameterFinalise(interpolationParameters,dummyErr,dummyError,*998)
998 ERRORS("FieldVariable_InterpolationParameterInitialise",err,error)
    EXITS("FieldVariable_InterpolationParameterInitialise")
    RETURN 1
    
  END SUBROUTINE FieldVariable_InterpolationParameterInitialise

  !
  !================================================================================================================================
  !

  !>Gets the interpolation parameters for a particular element. Old CMISS name XPXE, ZPZE
  SUBROUTINE Field_InterpolationParametersElementGet(parameterSetType,elementNumber,interpolationParameters,err,error,*, &
    & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parameterSetType !<The field parameter set type to get the element parameters for
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to get the element parameters for
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: componentIdx,dofIdx,elementNodeIdx,elementParameterIdx,endComponentIdx,gaussIdx,globalDerivativeIdx, &
      & localDerivativeIdx,nodeIdx, nodeScalingDOFIdx,scalingIdx,startComponentIdx,versionIdx
     REAL(DP), POINTER :: fieldParameterSetData(:),scaleFactors(:)
    TYPE(BasisType), POINTER :: basis
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(QuadratureSchemeType), POINTER :: quadratureScheme
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolationParametersElementGet",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolationParameters)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,parameterSetType,parameterSet,err,error,*999)
    NULLIFY(fieldParameterSetData)
    CALL DistributedVector_DataGet(parameterSet%parameters,fieldParameterSetData,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSE IF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating a geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating a geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    
    DO componentIdx=startComponentIdx,endComponentIdx
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      NULLIFY(basis)
      CALL DomainElements_ElementBasisGet(domainElements,elementNumber,basis,err,error,*999)
      interpolationParameters%bases(componentIdx)%ptr=>basis
      IF(componentIdx==1) THEN
        interpolationParameters%numberOfXi=basis%numberOfXi
      ELSE
        IF(basis%numberOfXi/=interpolationParameters%numberOfXi) &
          & CALL FlagError("Inconsistent number of xi directions???",err,error,*999)
      ENDIF
      SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
      CASE(FIELD_CONSTANT_INTERPOLATION)
        dofIdx=interpolationParameters%fieldVariable%components(componentIdx)%paramToDOFMap%constantParam2DOFMap
        interpolationParameters%numberOfParameters(componentIdx)=1
        interpolationParameters%parameters(1,componentIdx)=fieldParameterSetData(dofIdx)
      CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
        dofIdx=interpolationParameters%fieldVariable%components(componentIdx)%paramToDOFMap% &
          & elementParam2DOFMap%ELEMENTS(elementNumber)
        interpolationParameters%numberOfParameters(componentIdx)=1
        interpolationParameters%parameters(1,componentIdx)=fieldParameterSetData(dofIdx)
      CASE(FIELD_NODE_BASED_INTERPOLATION)
        NULLIFY(domainNodes)
        CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
        interpolationParameters%numberOfParameters(componentIdx)=basis%numberOfElementParameters
        SELECT CASE(interpolationParameters%field%scalings%scalingType)
        CASE(FIELD_NO_SCALING)
          DO elementNodeIdx=1,basis%numberOfNodes
            nodeIdx=domainElements%elements(elementNumber)%elementNodes(elementNodeIdx)
            DO localDerivativeIdx=1,basis%numberOfDerivatives(elementNodeIdx)
              globalDerivativeIdx=domainElements%elements(elementNumber)%elementDerivatives(localDerivativeIdx,elementNodeIdx)
              versionIdx=domainElements%elements(elementNumber)%elementVersions(localDerivativeIdx,elementNodeIdx)
              elementParameterIdx=basis%elementParameterIndex(localDerivativeIdx,elementNodeIdx)
              dofIdx=interpolationParameters%fieldVariable%components(componentIdx)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(globalDerivativeIdx)%versions(versionIdx)
              interpolationParameters%parameters(elementParameterIdx,componentIdx)=fieldParameterSetData(dofIdx)
            ENDDO !localDerivativeIdx
          ENDDO !elementNodeIdx
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          scalingIdx=fieldVariable%components(componentIdx)%scalingIndex
          NULLIFY(scaleFactors)
          CALL DistributedVector_DataGet(field%scalings%scalings(scalingIdx)%scaleFactors,scaleFactors,err,error,*999)
          DO elementNodeIdx=1,basis%numberOfNodes
            nodeIdx=domainElements%elements(elementNumber)%elementNodes(elementNodeIdx)
            DO localDerivativeIdx=1,basis%numberOfDerivatives(elementNodeIdx)
              globalDerivativeIdx=domainElements%elements(elementNumber)%elementDerivatives(localDerivativeIdx,elementNodeIdx)
              versionIdx=domainElements%ELEMENTS(elementNumber)%elementVersions(localDerivativeIdx,elementNodeIdx)
              elementParameterIdx=basis%elementParameterIndex(globalDerivativeIdx,elementNodeIdx)
              dofIdx=interpolationParameters%fieldVariable%components(componentIdx)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(globalDerivativeIdx)%versions(versionIdx)
              nodeScalingDOFIdx=domainNodes%nodes(nodeIdx)%derivatives(globalDerivativeIdx)%dofIndex(versionIdx)
              interpolationParameters%parameters(elementParameterIdx,componentIdx)=fieldParameterSetData(dofIdx)* &
                & scaleFactors(nodeScalingDOFIdx)
              interpolationParameters%scaleFactors(elementParameterIdx,componentIdx)=scaleFactors(nodeScalingDOFIdx)
            ENDDO !localDerivativeIdx
          ENDDO !elementNodeIdx
          CALL DistributedVector_DataRestore(interpolationParameters%field%scalings%scalings(scalingIdx)% &
            & scaleFactors,scaleFactors,err,error,*999)
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NumberToVString(field%scalings%scalingType,"*",err,error))// &
            & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)                  
        interpolationParameters%numberOfParameters(componentIdx)=interpolationParameters%fieldVariable% &
          & components(componentIdx)%paramToDOFMap% gaussPointParam2DOFMap%numberOfGridPointParameters
        NULLIFY(quadratureScheme)
        CALL Basis_QuadratureSchemeGet(basis,BASIS_DEFAULT_QUADRATURE_SCHEME,quadratureScheme,err,error,*999)
        DO gaussIdx=1,quadratureScheme%numberOfGauss
          dofIdx=interpolationParameters%fieldVariable%components(componentIdx)%paramToDOFMap% &
            & gaussPointParam2DOFMap%gaussPoints(gaussIdx,elementNumber)
          interpolationParameters%parameters(gaussIdx,componentIdx)=fieldParameterSetData(dofIdx)
        ENDDO !gaussIdx
      CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
          & components(componentIdx)%interpolationType,"*",err,error))//" is invalid for component number "// &
          & TRIM(NumberToVString(componentIdx,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ENDDO !componentIdx
    CALL CoordinateSystem_InterpolationParametersAdjust(coordinateSystem,interpolationParameters,err,error,*999)
    CALL DistributedVector_DataRestore(parameterSet%parameters,fieldParameterSetData,err,error,*999)

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",fieldVariable%variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",parameterSetType,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",elementNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",fieldVariable%numberOfComponents,err,error,*999)
      DO componentIdx=startComponentIdx,endComponentIdx
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",componentIdx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",interpolationParameters% &
          & numberOfParameters(componentIdx),err,error,*999)
        CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,interpolationParameters%numberOfParameters(componentIdx),4,4, &
          & interpolationParameters%parameters(:,componentIdx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !componentIdx
    ENDIF

    EXITS("Field_InterpolationParametersElementGet")
    RETURN
999 ERRORSEXITS("Field_InterpolationParametersElementGet",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolationParametersElementGet

  !
  !================================================================================================================================
  !

  !>Finalises the interpolation parameters and deallocates all memory
  SUBROUTINE Field_InterpolationParametersFinalise(interpolationParameters,err,error,*)

    !Argument variables
    TYPE(FieldInterpolationParametersPtrType), POINTER :: interpolationParameters(:) !<A pointer to the interpolation parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableTypeIdx

    ENTERS("Field_InterpolationParametersFinalise",err,error,*999)

    IF(ASSOCIATED(interpolationParameters)) THEN
      DO variableTypeIdx=1,SIZE(interpolationParameters,1)       
        CALL FieldVariable_InterpolationParameterFinalise(interpolationParameters(variableTypeIdx)%ptr,err,error,*999)
      ENDDO !variableTypeIdx           
      DEALLOCATE(interpolationParameters)
    ENDIF

    EXITS("Field_InterpolationParametersFinalise")
    RETURN
999 ERRORSEXITS("Field_InterpolationParametersFinalise",err,error)
    RETURN 1
  END SUBROUTINE Field_InterpolationParametersFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the interpolation parameters for all the variables in a field.
  SUBROUTINE Field_InterpolationParametersInitialise(field,interpolationParameters,err,error,*,componentType)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the interpolation parameters for
    TYPE(FieldInterpolationParametersPtrType), POINTER :: interpolationParameters(:) !<On exit, a pointer to the initialised interpolation parameters.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: dummyErr,variableTypeIdx
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("Field_InterpolationParametersInitialise",err,error,*998)

    IF(ASSOCIATED(interpolationParameters)) CALL FlagError("Interpolation parameters is already associated.",err,error,*998)
    CALL Field_AssertIsFinished(field,err,error,*998)
    
    ALLOCATE(interpolationParameters(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate the interpolation parameters.",err,error,*999)
    DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
      NULLIFY(interpolationParameters(variableTypeIdx)%ptr)
      fieldVariable=>field%variableTypeMap(variableTypeIdx)%ptr
      IF(ASSOCIATED(fieldVariable)) THEN
        IF(PRESENT(componentType)) THEN
          CALL FieldVariable_InterpolationParameterInitialise(fieldVariable,interpolationParameters(variableTypeIdx)%ptr, &
            & err,error,*999,componentType)
        ELSE
          CALL FieldVariable_InterpolationParameterInitialise(fieldVariable,interpolationParameters(variableTypeIdx)%ptr, &
            & err,error,*999)
        ENDIF
      ENDIF
    ENDDO !variableTypeIdx

    EXITS("Field_InterpolationParametersInitialise")
    RETURN
999 CALL Field_InterpolationParametersFinalise(interpolationParameters,dummyErr,dummyError,*998)
998 ERRORSEXITS("Field_InterpolationParametersInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_InterpolationParametersInitialise

  !
  !================================================================================================================================
  !

  !>Gets the interpolation parameters for a particular line. Old CMISS name XPXE, ZPZE
  SUBROUTINE Field_InterpolationParametersLineGet(parameterSetType,lineNumber,interpolationParameters,err,error,*, &
    & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parameterSetType !<The field parameter set type to get the line parameters for
    INTEGER(INTG), INTENT(IN) :: lineNumber !<The line number to get the line parameters for
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to get the interpolation parameters for
    !Local Variables
    INTEGER(INTG) :: basisDerivativeIdx,basisNodeIdx,componentIdx,derivativeIdx,dofIdx,elementParameterIdx,endComponentIdx, &
      & nodeIdx,nodeScalingDOFIdx,scalingIdx,startComponentIdx,versionIdx
    REAL(DP), POINTER :: fieldParameterSetData(:),scaleFactors(:)
    TYPE(BasisType), POINTER :: basis
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DistributedVectorType), POINTER :: scaleFactorsVector
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainLinesType), POINTER :: domainLines
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolationParametersLineGet",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolationParameters)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,parameterSetType,parameterSet,err,error,*999)
    NULLIFY(fieldParameterSetData)
    CALL DistributedVector_DataGet(parameterSet%parameters,fieldParameterSetData,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSEIF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    
    DO componentIdx=startComponentIdx,endComponentIdx
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainLines)
      CALL DomainTopology_DomainLinesGet(domainTopology,domainLines,err,error,*999)
      NULLIFY(basis)
      CALL DomainLines_LineBasisGet(domainLines,lineNumber,basis,err,error,*999)
      interpolationParameters%bases(componentIdx)%ptr=>basis
      IF(componentIdx==1) THEN
        interpolationParameters%numberOfXi=basis%numberOfXi
      ELSE
        IF(basis%numberOfXi/=interpolationParameters%numberOfXi) &
          & CALL FlagError("Inconsistent number of xi directions???",err,error,*999)
      ENDIF
      SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
      CASE(FIELD_CONSTANT_INTERPOLATION)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(FIELD_NODE_BASED_INTERPOLATION)
        NULLIFY(domainNodes)
        CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
        interpolationParameters%numberOfParameters(componentIdx)=basis%numberOfElementParameters
        SELECT CASE(field%scalings%scalingType)
        CASE(FIELD_NO_SCALING)
          DO basisNodeIdx=1,basis%numberOfNodes
            nodeIdx=domainLines%lines(lineNumber)%nodesInLine(basisNodeIdx)
            DO basisDerivativeIdx=1,basis%numberOfDerivatives(basisNodeIdx)
              derivativeIdx=domainLines%lines(lineNumber)%derivativesInLine(1,basisDerivativeIdx,basisNodeIdx)
              versionIdx=domainLines%lines(lineNumber)%derivativesInLine(2,basisDerivativeIdx,basisNodeIdx)
              elementParameterIdx=basis%elementParameterIndex(basisDerivativeIdx,basisNodeIdx)
              dofIdx=fieldVariable%components(componentIdx)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
              interpolationParameters%parameters(elementParameterIdx,componentIdx)=fieldParameterSetData(dofIdx)
            ENDDO !basisDerivativeIdx
          ENDDO !basisNodeIdx
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          scalingIdx=fieldVariable%components(componentIdx)%scalingIndex
          NULLIFY(scaleFactorsVector)
          CALL Field_ScaleFactorsVectorGet(field,scalingIdx,scaleFactorsVector,err,error,*999)
          NULLIFY(scaleFactors)
          CALL DistributedVector_DataGet(scaleFactorsVector,scaleFactors,err,error,*999)
          DO basisNodeIdx=1,basis%numberOfNodes
            nodeIdx=domainLines%lines(lineNumber)%nodesInLine(basisNodeIdx)
            DO basisDerivativeIdx=1,basis%numberOfDerivatives(basisNodeIdx)
              derivativeIdx=domainLines%lines(lineNumber)%derivativesInLine(1,basisDerivativeIdx,basisNodeIdx)
              versionIdx=domainLines%lines(lineNumber)%derivativesInLine(2,basisDerivativeIdx,basisNodeIdx)
              elementParameterIdx=basis%elementParameterIndex(basisDerivativeIdx,basisNodeIdx)
              dofIdx=fieldVariable%components(componentIdx)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
              nodeScalingDOFIdx=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%dofIndex(versionIdx)
              interpolationParameters%parameters(elementParameterIdx,componentIdx)= &
                & fieldParameterSetData(dofIdx)*scaleFactors(nodeScalingDOFIdx)
              interpolationParameters%scaleFactors(elementParameterIdx,componentIdx)=scaleFactors(nodeScalingDOFIdx)
            ENDDO !basisDerivativeIdx
          ENDDO !basisNodeIdx
          CALL DistributedVector_DataRestore(scaleFactorsVector,scaleFactors,err,error,*999)
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NumberToVString(interpolationParameters%field%scalings% &
            & scalingType,"*",err,error))//" is invalid for field number "// &
            & TRIM(NumberToVString(interpolationParameters%field%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="The interpolation type of "//TRIM(NumberToVString(interpolationParameters%fieldVariable% &
          & COMPONENTS(componentIdx)%interpolationType,"*",err,error))//" is invalid for component number "// &
          & TRIM(NumberToVString(componentIdx,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(interpolationParameters%field%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ENDDO !componentIdx
    CALL CoordinateSystem_InterpolationParametersAdjust(coordinateSystem,interpolationParameters,err,error,*999)
    CALL DistributedVector_DataRestore(parameterSet%PARAMETERS,fieldParameterSetData,err,error,*999)

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",interpolationParameters%field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",interpolationParameters%fieldVariable% &
        & variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",parameterSetType,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Line number = ",lineNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Total number of components = ", &
        & interpolationParameters%fieldVariable%numberOfComponents,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Interpolation number of components = ", &
        & endComponentIdx-startComponentIdx+1,err,error,*999)
      DO componentIdx=startComponentIdx,endComponentIdx
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",componentIdx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",interpolationParameters% &
          & numberOfParameters(componentIdx),err,error,*999)
        CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,interpolationParameters%numberOfParameters(componentIdx),4,4, &
          & interpolationParameters%parameters(:,componentIdx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !componentIdx
    ENDIF

    EXITS("Field_InterpolationParametersLineGet")
    RETURN
999 ERRORSEXITS("Field_InterpolationParametersLineGet",err,error)
    RETURN 1

  END SUBROUTINE Field_InterpolationParametersLineGet

  !
  !================================================================================================================================
  !
  !>Gets the interpolation parameters for a particular face.
  SUBROUTINE Field_InterpolationParametersFaceGet(parameterSetType,faceNumber,interpolationParameters,err,error,*, &
    & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parameterSetType !<The field parameter set type to get the face parameters for
    INTEGER(INTG), INTENT(IN) :: faceNumber !<The face number to get the face parameters for
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to get field interpolation parameters for
    !Local Variables
    INTEGER(INTG) :: basisDerivativeIdx,basisNodeIdx,componentIdx,derivativeIdx,dofIdx,elementParameterIdx,endComponentIdx, &
      & nodeIdx,nodeScalingDOFIdx,scalingIdx,startComponentIdx,versionIdx
    REAL(DP), POINTER :: fieldParameterSetData(:),scaleFactors(:)
    TYPE(BasisType), POINTER :: basis
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DistributedVectorType), POINTER :: scaleFactorsVector
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainFacesType), POINTER :: domainFaces
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolationParametersFaceGet",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolationParameters)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,parameterSetType,parameterSet,err,error,*999)
    NULLIFY(fieldParameterSetData)
    CALL DistributedVector_DataGet(parameterSet%parameters,fieldParameterSetData,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(coordinateSystem)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSEIF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    
    DO componentIdx=startComponentIdx,endComponentIdx
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainFaces)
      CALL DomainTopology_DomainFacesGet(domainTopology,domainFaces,err,error,*999)
      NULLIFY(basis)
      CALL DomainFaces_FaceBasisGet(domainFaces,faceNumber,basis,err,error,*999)
      interpolationParameters%bases(componentIdx)%ptr=>basis
      IF(componentIdx==1) THEN
        interpolationParameters%numberOfXi=basis%numberOfXi
      ELSE
        IF(basis%numberOfXi/=interpolationParameters%numberOfXi) &
          & CALL FlagError("Inconsistent number of xi directions???",err,error,*999)
      ENDIF
      SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
      CASE(FIELD_CONSTANT_INTERPOLATION)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(FIELD_NODE_BASED_INTERPOLATION)
        NULLIFY(domainNodes)
        CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
        interpolationParameters%numberOfParameters(componentIdx)=basis%numberOfElementParameters
        SELECT CASE(field%scalings%scalingType)
        CASE(FIELD_NO_SCALING)
          DO basisNodeIdx=1,basis%numberOfNodes
            nodeIdx=domainFaces%faces(faceNumber)%nodesInFace(basisNodeIdx)
            DO basisDerivativeIdx=1,basis%numberOfDerivatives(basisNodeIdx)
              derivativeIdx=domainFaces%faces(faceNumber)%derivativesInFace(1,basisDerivativeIdx,basisNodeIdx)
              versionIdx=domainFaces%faces(faceNumber)%derivativesInFace(2,basisDerivativeIdx,basisNodeIdx)
              elementParameterIdx=basis%elementParameterIndex(basisDerivativeIdx,basisNodeIdx)
              dofIdx=interpolationParameters%fieldVariable%components(componentIdx)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
              interpolationParameters%parameters(elementParameterIdx,componentIdx)=fieldParameterSetData(dofIdx)
            ENDDO !basisDerivativeIdx
          ENDDO !basisNodeIdx
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          scalingIdx=interpolationParameters%fieldVariable%components(componentIdx)%scalingIndex
          NULLIFY(scaleFactorsVector)
          CALL Field_ScaleFactorsVectorGet(field,scalingIdx,scaleFactorsVector,err,error,*999)
          NULLIFY(scaleFactors)
          CALL DistributedVector_DataGet(scaleFactorsVector,scaleFactors,err,error,*999)
          DO basisNodeIdx=1,basis%numberOfNodes
            nodeIdx=domainFaces%faces(faceNumber)%nodesInFace(basisNodeIdx)
            DO basisDerivativeIdx=1,basis%numberOfDerivatives(basisNodeIdx)
              derivativeIdx=domainFaces%faces(faceNumber)%derivativesInFace(1,basisDerivativeIdx,basisNodeIdx)
              versionIdx=domainFaces%faces(faceNumber)%derivativesInFace(2,basisDerivativeIdx,basisNodeIdx)
              elementParameterIdx=basis%elementParameterIndex(basisDerivativeIdx,basisNodeIdx)
              dofIdx=interpolationParameters%fieldVariable%components(componentIdx)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
              nodeScalingDOFIdx=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%dofIndex(versionIdx)
              interpolationParameters%parameters(elementParameterIdx,componentIdx)= &
                  & fieldParameterSetData(dofIdx)*scaleFactors(nodeScalingDOFIdx)
              interpolationParameters%scaleFactors(elementParameterIdx,componentIdx)=scaleFactors(nodeScalingDOFIdx)
            ENDDO !basisDerivativeIdx
          ENDDO !basisNodeIdx
          CALL DistributedVector_DataRestore(scaleFactorsVector,scaleFactors,err,error,*999)
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NumberToVString(field%scalings% &
            & scalingType,"*",err,error))//" is invalid for field number "// &
            & TRIM(NumberToVString(interpolationParameters%field%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="The interpolation type of "//TRIM(NumberToVString(interpolationParameters%fieldVariable% &
          & COMPONENTS(componentIdx)%interpolationType,"*",err,error))//" is invalid for component number "// &
          & TRIM(NumberToVString(componentIdx,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(interpolationParameters%field%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ENDDO !componentIdx
    CALL CoordinateSystem_InterpolationParametersAdjust(coordinateSystem,interpolationParameters,err,error,*999)
    CALL DistributedVector_DataRestore(parameterSet%PARAMETERS,fieldParameterSetData,err,error,*999)

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",interpolationParameters%field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",interpolationParameters%fieldVariable% &
        & variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",parameterSetType,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Face number = ",faceNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Total number of components = ", &
        & interpolationParameters%fieldVariable%numberOfComponents,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Interpolation number of components = ", &
        & endComponentIdx-startComponentIdx+1,err,error,*999)
      DO componentIdx=startComponentIdx,endComponentIdx
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",componentIdx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",interpolationParameters% &
          & numberOfParameters(componentIdx),err,error,*999)
        CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,interpolationParameters%numberOfParameters(componentIdx),4,4, &
          & interpolationParameters%parameters(:,componentIdx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !componentIdx
    ENDIF

    EXITS("Field_InterpolationParametersFaceGet")
    RETURN
999 ERRORSEXITS("Field_InterpolationParametersFaceGet",err,error)
    RETURN 1
    
  END SUBROUTINE Field_InterpolationParametersFaceGet

  !
  !================================================================================================================================
  !

  !>Gets the interpolation scale factors for a particular element. 
  SUBROUTINE Field_InterpolationParametersScaleFactorsElementGet(elementNumber,interpolationParameters,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to get the element scale factors for
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,derivativeIdx,derivativeNumber,dofIdx,elementParameterIdx,localNodeIdx,nodeNumber, &
      & scalingIdx,versionIdx
    REAL(DP), POINTER :: scaleFactors(:)
    TYPE(BasisType), POINTER :: basis
    TYPE(DistributedVectorType), POINTER :: scaleFactorsVector
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolationParametersScaleFactorsElementGet",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolationParameters)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    SELECT CASE(field%scalings%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not get the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      DO componentIdx=1,fieldVariable%numberOfComponents
        NULLIFY(domain)
        CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
        NULLIFY(domainTopology)
        CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
        NULLIFY(domainElements)
        CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
        NULLIFY(basis)
        CALL DomainElements_ElementBasisGet(domainElements,elementNumber,basis,err,error,*999)
        interpolationParameters%bases(componentIdx)%ptr=>basis
        SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)             
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          NULLIFY(domainNodes)
          CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
          interpolationParameters%numberOfParameters(componentIdx)=basis%numberOfElementParameters
          scalingIdx=fieldVariable%components(componentIdx)%scalingIndex
          NULLIFY(scaleFactorsVector)
          CALL Field_ScaleFactorsVectorGet(field,scalingIdx,scaleFactorsVector,err,error,*999)
          NULLIFY(scaleFactors)
          CALL DistributedVector_DataGet(scaleFactorsVector,scaleFactors,err,error,*999)
          DO localNodeIdx=1,basis%numberOfNodes
            nodeNumber=domainElements%elements(elementNumber)%elementNodes(localNodeIdx)
            DO derivativeIdx=1,basis%numberOfDerivatives(localNodeIdx)
              derivativeNumber=domainElements%elements(elementNumber)%elementDerivatives(derivativeIdx,localNodeIdx)
              versionIdx=domainElements%elements(elementNumber)%elementVersions(derivativeIdx,localNodeIdx)
              elementParameterIdx=basis%elementParameterIndex(derivativeIdx,localNodeIdx)
              dofIdx=domainNodes%nodes(nodeNumber)%derivatives(derivativeNumber)%dofIndex(versionIdx)
              interpolationParameters%scaleFactors(elementParameterIdx,componentIdx)=scaleFactors(dofIdx)
            ENDDO !derivativeIdx
          ENDDO !localNodeIdx
          CALL DistributedVector_DataRestore(scaleFactorsVector,scaleFactors,err,error,*999)
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE DEFAULT
          localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & components(componentIdx)%interpolationType,"*",err,error))//" is invalid for component number "// &
            & TRIM(NumberToVString(componentIdx,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ENDDO !componentIdx
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%scalings% &
        & scalingType,"*",err,error))//" is invalid for field number "// &
        & TRIM(NumberToVString(interpolationParameters%field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",fieldVariable%variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",elementNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",fieldVariable%numberOfComponents,err,error,*999)
      DO componentIdx=1,fieldVariable%numberOfComponents
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",componentIdx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",interpolationParameters% &
          & numberOfParameters(componentIdx),err,error,*999)
        CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,interpolationParameters%numberOfParameters(componentIdx),4,4, &
          & interpolationParameters%scaleFactors(:,componentIdx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !componentIdx
    ENDIF

    EXITS("Field_InterpolationParametersScaleFactorsElementGet")
    RETURN
999 ERRORS("Field_InterpolationParametersScaleFactorsElementGet",err,error)
    EXITS("Field_InterpolationParametersScaleFactorsElementGet")
    RETURN 1

  END SUBROUTINE Field_InterpolationParametersScaleFactorsElementGet

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for a particular node.
  SUBROUTINE Field_ParameterSetNodeScaleFactorGet(field,variableType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,scaleFactor,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofNumber,scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    LOGICAL :: ghostDof
    TYPE(DistributedVectorType), POINTER :: fieldScaleFactorsVector
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorGet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    SELECT CASE(field%scalings%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not get the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
      CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
        & dofNumber,ghostDof,err,error,*999)
      ! The field component number is used to determine which scaling index to use.
      ! The number of scaling indices are set based on the number of mesh components (not field components).
      scalingIdx=fieldVariable%components(componentNumber)%scalingIndex
      NULLIFY(fieldScaleFactorsVector)
      CALL Field_ScaleFactorsVectorGet(field,scalingIdx,fieldScaleFactorsVector,err,error,*999)
      NULLIFY(fieldScaleFactors)
      CALL DistributedVector_DataGet(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
      scaleFactor=fieldScaleFactors(dofNumber)
      CALL DistributedVector_DataRestore(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%scalings%scalingType,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetNodeScaleFactorGet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorGet",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetNodeScaleFactorGet

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes.
  SUBROUTINE Field_ParameterSetNodeScaleFactorsGet(field,variableType,meshComponentNumber,scaleFactors,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factor for all nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(DistributedVectorType), POINTER :: fieldScaleFactorsVector
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorsGet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    SELECT CASE(field%scalings%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not get the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
      !!TODO: WE SHOULDN'T BE THINKING ABOUT MESH COMPONENT NUMBERS HERE????
      !The numberOfScalingIndices is the same as the number of mesh components (not field components).  
      IF(meshComponentNumber<1.OR.meshComponentNumber>field%scalings%numberOfScalingIndices) THEN
        localError="Mesh component number "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
          & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
          & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" which has "// &
          & TRIM(NumberToVString(field%SCALINGS%numberOfScalingIndices,"*",err,error))// &
          & " components."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      scalingIdx=meshComponentNumber
      NULLIFY(fieldScaleFactorsVector)
      CALL Field_ScaleFactorsVectorGet(field,scalingIdx,fieldScaleFactorsVector,err,error,*999)
      NULLIFY(fieldScaleFactors)
      CALL DistributedVector_DataGet(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
      scaleFactors=fieldScaleFactors
      CALL DistributedVector_DataRestore(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS%scalingType,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetNodeScaleFactorsGet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorsGet",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetNodeScaleFactorsGet

  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs.
  SUBROUTINE Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<The field to get the number of scale factor dofs for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(DistributedVectorType), POINTER :: fieldScaleFactorsVector
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    SELECT CASE(field%scalings%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not get the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
      !!TODO: WE SHOULDN'T BE THINKING ABOUT MESH COMPONENT NUMBERS HERE????
      !The numberOfScalingIndices is the same as the number of mesh components (not field components).  
      IF(meshComponentNumber<1.OR.meshComponentNumber>field%scalings%numberOfScalingIndices) THEN
         localError="Mesh component number "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
          & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
          & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" which has "// &
          & TRIM(NumberToVString(field%scalings%numberOfScalingIndices,"*",err,error))// &
          & " components."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      scalingIdx=meshComponentNumber
      NULLIFY(fieldScaleFactorsVector)
      CALL Field_ScaleFactorsVectorGet(field,scalingIdx,fieldScaleFactorsVector,err,error,*999)
      NULLIFY(fieldScaleFactors)
      CALL DistributedVector_DataGet(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
      numberOfScaleFactorsDofs=SIZE(fieldScaleFactors,1)
      CALL DistributedVector_DataRestore(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%scalings%scalingType,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet")
    RETURN
999 ERRORS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet",err,error)
    EXITS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet")
    RETURN 1

  END SUBROUTINE Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for a particular node.
  SUBROUTINE Field_ParameterSetNodeScaleFactorSet(field,variableType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,scaleFactor,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofNumber,scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    LOGICAL :: ghostDof
    TYPE(DistributedVectorType), POINTER :: fieldScaleFactorsVector
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorSet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    SELECT CASE(field%SCALINGS%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not set the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
      CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
        & dofNumber,ghostDof,err,error,*999)
      ! The field component number is used to determine which scaling index to use.
      ! The number of scaling indices are set based on the number of mesh components (not field components).
      scalingIdx=fieldVariable%components(componentNumber)%scalingIndex
      NULLIFY(fieldScaleFactorsVector)
      CALL Field_ScaleFactorsVectorGet(field,scalingIdx,fieldScaleFactorsVector,err,error,*999)
      NULLIFY(fieldScaleFactors)
      CALL DistributedVector_DataGet(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
      fieldScaleFactors(dofNumber)=scaleFactor
      CALL DistributedVector_DataRestore(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%scalings%scalingType,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetNodeScaleFactorSet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorSet",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetNodeScaleFactorSet
  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes.
  SUBROUTINE Field_ParameterSetNodeScaleFactorsSet(field,variableType,meshComponentNumber,scaleFactors,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factor for all nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(DistributedVectorType), POINTER :: fieldScaleFactorsVector
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorsSet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    SELECT CASE(field%scalings%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not set the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
      !!TODO: WE SHOULDN'T BE THINKING ABOUT MESH COMPONENT NUMBERS HERE????
      !The numberOfScalingIndices is the same as the number of mesh components (not field components).  
      IF(meshComponentNumber<1.OR.meshComponentNumber>field%scalings%numberOfScalingIndices) THEN
        localError="Mesh component number "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
          & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
          & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" which has "// &
          & TRIM(NumberToVString(field%scalings%numberOfScalingIndices,"*",err,error))// &
          & " components."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      scalingIdx=meshComponentNumber
      NULLIFY(fieldScaleFactorsVector)
      CALL Field_ScaleFactorsVectorGet(field,scalingIdx,fieldScaleFactorsVector,err,error,*999)
      NULLIFY(fieldScaleFactors)
      CALL DistributedVector_DataGet(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
      IF(SIZE(fieldScaleFactors,1)>SIZE(scaleFactors,1)) THEN
        localError="The input scale factors have dimensions "//TRIM(NumberToVString(SIZE(scaleFactors),"*",err,error)) &
          & //" and does not match the expected scale factor dimensions of "// &
          & TRIM(NumberToVString(SIZE(fieldScaleFactors),"*",err,error))
        CALL FlagError(localError,err,error,*999)
      ENDIF
      fieldScaleFactors(1:SIZE(scaleFactors,1))=scaleFactors(1:SIZE(scaleFactors,1))
      CALL DistributedVector_DataRestore(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%scalings%scalingType,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetNodeScaleFactorsSet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorsSet",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetNodeScaleFactorsSet

  !
  !================================================================================================================================
  !

  !>Gets the interpolation scale factors for a particular element. 
  SUBROUTINE Field_InterpolationParametersScaleFactorsLineGet(lineNumber,interpolationParameters,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: lineNumber !<The line number to get the element scale factors for
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,derivativeIdx,derivativeNumber,dofIdx,elementParameterIdx,localNodeIdx,nodeNumber, &
      & scalingIdx,versionIdx
    REAL(DP), POINTER :: scaleFactors(:)
    TYPE(BasisType), POINTER :: basis
    TYPE(DistributedVectorType), POINTER :: scaleFactorsVector
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainLinesType), POINTER :: domainLines
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolationParametersScaleFactorsLineGet",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolationParameters)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    SELECT CASE(field%scalings%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      DO componentIdx=1,fieldVariable%numberOfComponents
        NULLIFY(domain)
        CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
        NULLIFY(domainTopology)
        CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
        NULLIFY(domainLines)
        CALL DomainTopology_DomainLinesGet(domainTopology,domainLines,err,error,*999)
        NULLIFY(basis)
        CALL DomainLines_LineBasisGet(domainLines,lineNumber,basis,err,error,*999)
        interpolationParameters%bases(componentIdx)%ptr=>basis
        IF(componentIdx==1) THEN
          interpolationParameters%numberOfXi=basis%numberOfXi
        ELSE
          IF(basis%numberOfXi/=interpolationParameters%numberOfXi) &
            & CALL FlagError("Inconsistent number of xi directions???",err,error,*999)
        ENDIF
        SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)             
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          NULLIFY(domainNodes)
          CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
          interpolationParameters%numberOfParameters(componentIdx)=basis%numberOfElementParameters
          scalingIdx=fieldVariable%components(componentIdx)%scalingIndex
          NULLIFY(scaleFactorsVector)
          CALL Field_ScaleFactorsVectorGet(field,scalingIdx,scaleFactorsVector,err,error,*999)
          NULLIFY(scaleFactors)
          CALL DistributedVector_DataGet(scaleFactorsVector,scaleFactors,err,error,*999)
          DO localNodeIdx=1,basis%numberOfNodes
            nodeNumber=domainLines%lines(lineNumber)%nodesInLine(localNodeIdx)
            DO derivativeIdx=1,basis%numberOfDerivatives(localNodeIdx)
              derivativeNumber=domainLines%lines(lineNumber)%derivativesInLine(1,derivativeIdx,localNodeIdx)
              versionIdx=domainLines%lines(lineNumber)%derivativesInLine(2,derivativeIdx,localNodeIdx)
              elementParameterIdx=basis%elementParameterIndex(derivativeIdx,localNodeIdx)
              dofIdx=domainNodes%nodes(nodeNumber)%derivatives(derivativeNumber)%dofIndex(versionIdx)
              interpolationParameters%scaleFactors(elementParameterIdx,componentIdx)=scaleFactors(dofIdx)
            ENDDO !derivativeIdx
          ENDDO !localNodeIdx
          CALL DistributedVector_DataRestore(scaleFactorsVector,scaleFactors,err,error,*999)
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE DEFAULT
          localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & components(componentIdx)%interpolationType,"*",err,error))//" is invalid for component number "// &
            & TRIM(NumberToVString(componentIdx,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(interpolationParameters%field%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ENDDO !componentIdx
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%scalings% &
        & scalingType,"*",err,error))//" is invalid for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",fieldVariable%variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Line number = ",lineNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",fieldVariable%numberOfComponents,err,error,*999)
      DO componentIdx=1,fieldVariable%numberOfComponents
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",componentIdx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",interpolationParameters% &
          & numberOfParameters(componentIdx),err,error,*999)
        CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,interpolationParameters%numberOfParameters(componentIdx),4,4, &
          & interpolationParameters%scaleFactors(:,componentIdx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !componentIdx
    ENDIF

    EXITS("Field_InterpolationParametersScaleFactorsLineGet")
    RETURN
999 ERRORS("Field_InterpolationParametersScaleFactorsLineGet",err,error)
    EXITS("Field_InterpolationParametersScaleFactorsLineGet")
    RETURN 1

  END SUBROUTINE Field_InterpolationParametersScaleFactorsLineGet

  !
  !================================================================================================================================
  !

  !>Gets the interpolation scale factors for a particular element. 
  SUBROUTINE Field_InterpolationParametersScaleFactorsFaceGet(faceNumber,interpolationParameters,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: faceNumber !<The face number to get the element scale factors for
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,derivativeIdx,derivativeNumber,dofIdx,elementParameterIdx,localNodeIdx,nodeNumber, &
      & scalingIdx,versionIdx
    REAL(DP), POINTER :: scaleFactors(:)
    TYPE(BasisType), POINTER :: basis
    TYPE(DistributedVectorType), POINTER :: scaleFactorsVector
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainFacesType), POINTER :: domainFaces
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolationParametersScaleFactorsFaceGet",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolationParameters)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    SELECT CASE(field%scalings%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      DO componentIdx=1,fieldVariable%numberOfComponents
        NULLIFY(domain)
        CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
        NULLIFY(domainTopology)
        CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
        NULLIFY(domainFaces)
        CALL DomainTopology_DomainFacesGet(domainTopology,domainFaces,err,error,*999)
        NULLIFY(basis)
        CALL DomainFaces_FaceBasisGet(domainFaces,faceNumber,basis,err,error,*999)
        interpolationParameters%bases(componentIdx)%ptr=>basis
        IF(componentIdx==1) THEN
          interpolationParameters%numberOfXi=basis%numberOfXi
        ELSE
          IF(basis%numberOfXi/=interpolationParameters%numberOfXi) &
            & CALL FlagError("Inconsistent number of xi directions???",err,error,*999)
        ENDIF
        SELECT CASE(fieldVariable%components(componentIdx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)             
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          NULLIFY(domainNodes)
          CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
          interpolationParameters%numberOfParameters(componentIdx)=basis%numberOfElementParameters
          scalingIdx=interpolationParameters%fieldVariable%components(componentIdx)%scalingIndex
          NULLIFY(scaleFactorsVector)
          CALL Field_ScaleFactorsVectorGet(field,scalingIdx,scaleFactorsVector,err,error,*999)
          NULLIFY(scaleFactors)
          CALL DistributedVector_DataGet(scaleFactorsVector,scaleFactors,err,error,*999)
          DO localNodeIdx=1,basis%numberOfNodes
            nodeNumber=domainFaces%faces(faceNumber)%nodesInFace(localNodeIdx)
            DO derivativeIdx=1,basis%numberOfDerivatives(localNodeIdx)
              derivativeNumber=domainFaces%faces(faceNumber)%derivativesInFace(1,derivativeIdx,localNodeIdx)
              versionIdx=domainFaces%faces(faceNumber)%derivativesInFace(2,derivativeIdx,localNodeIdx)
              elementParameterIdx=basis%elementParameterIndex(derivativeIdx,localNodeIdx)
              dofIdx=domainNodes%nodes(nodeNumber)%derivatives(derivativeNumber)%dofIndex(versionIdx)
              interpolationParameters%scaleFactors(elementParameterIdx,componentIdx)=scaleFactors(dofIdx)
            ENDDO !derivativeIdx
          ENDDO !localNodeIdx
          CALL DistributedVector_DataRestore(scaleFactorsVector,scaleFactors,err,error,*999)
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          interpolationParameters%numberOfParameters(componentIdx)=1
          interpolationParameters%parameters(1,componentIdx)=1.0_DP
        CASE DEFAULT
          localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & components(componentIdx)%interpolationType,"*",err,error))//" is invalid for component number "// &
            & TRIM(NumberToVString(componentIdx,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ENDDO !componentIdx
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%scalings% &
        & scalingType,"*",err,error))//" is invalid for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",fieldVariable%variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Face number = ",faceNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",fieldVariable%numberOfComponents,err,error,*999)
      DO componentIdx=1,fieldVariable%numberOfComponents
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",componentIdx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",interpolationParameters% &
          & numberOfParameters(componentIdx),err,error,*999)
        CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,interpolationParameters%numberOfParameters(componentIdx),4,4, &
          & interpolationParameters%scaleFactors(:,componentIdx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !componentIdx
    ENDIF

    EXITS("Field_InterpolationParametersScaleFactorsFaceGet")
    RETURN
999 ERRORS("Field_InterpolationParametersScaleFactorsFaceGet",err,error)
    EXITS("Field_InterpolationParametersScaleFactorsFaceGet")
    RETURN 1

  END SUBROUTINE Field_InterpolationParametersScaleFactorsFaceGet

  !
  !================================================================================================================================
  !

  !>Calculates the mappings to/from the degrees of freedom and the parameters for a field.
  SUBROUTINE Field_MappingsCalculate(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to calculate the mappings for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableIdx,componentIdx,domainTypeIdx,variableGlobalDOFSOffset,numberOfGlobalVariableDOFS, &
      & numberOfConstantDOFs,numberOfElementDOFs,numberOfNodeDOFs,numberOfGridPointDOFs,numberOfGaussPointDOFs, &
      & numberOfLocalVariableDOFS,totalNumberOfVariableDOFS,numberOfDomains,variableGlobalDOFIdx, &
      & variableLocalDOFIdx,domainIdx,domainNumber,constantDOFIdx,elementDOF,elementDOFIdx,nodeDOF,nodeDOFIdx,gridPointDOFIdx, &
      & gaussPointDOFIdx,versionIdx,dofIdx,numberOfGroupComputationNodes, &
      & myGroupComputationNodeNumber,domainTypeStop,startIdx,stopIdx,elementIdx,nodeIdx,numberOfLocal,numberOfGauss, &
      & maxNumberOfGauss,mpiIError,numberOfGlobalDofs,gaussPointIdx,numberOfDataPointDOFs,dataPointDOFIdx,dataPointIdx, &
      & localDataNumber,globalElementNumber,groupCommunicator,variableType,derivativeIdx
    INTEGER(INTG), ALLOCATABLE :: variableLocalDOFSOffsets(:),variableGhostDOFSOffsets(:), &
      & localDataParamCount(:),ghostDataParamCount(:)
    TYPE(BasisType), POINTER :: basis
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionDataPointsType), POINTER :: decompositionDataPoints
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainDofsType), POINTER :: domainDofs
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainMappingType), POINTER :: elementsMapping,dofsMapping,fieldVariableDOFSMapping
    TYPE(DomainMappingsType), POINTER :: domainMappings
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(FieldVariableComponentType), POINTER :: fieldComponent
    TYPE(QuadratureSchemeType), POINTER :: quadratureScheme
    TYPE(VARYING_STRING) :: localError
    TYPE(WorkGroupType), POINTER :: workGroup

    ENTERS("Field_MappingsCalculate",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(workGroup)
    CALL Decomposition_WorkGroupGet(decomposition,workGroup,err,error,*999)
    CALL WorkGroup_GroupCommunicatorGet(workGroup,groupCommunicator,err,error,*999)
    CALL WorkGroup_NumberOfGroupNodesGet(workGroup,numberOfGroupComputationNodes,err,error,*999)
    CALL WorkGroup_GroupNodeNumberGet(workGroup,myGroupComputationNodeNumber,err,error,*999)

    !Calculate the number of global and local degrees of freedom for the field variables and components. Each field variable
    !component has a set of DOFs so loop over the components for each variable component and count up the DOFs.
    DO variableIdx=1,field%numberOfVariables
      numberOfConstantDOFs=0
      numberOfElementDOFs=0
      numberOfNodeDOFs=0
      numberOfGridPointDOFs=0
      numberOfGaussPointDOFs=0
      numberOfDataPointDOFs=0
      numberOfLocalVariableDOFS=0
      totalNumberOfVariableDOFS=0
      numberOfGlobalVariableDOFS=0
      NULLIFY(fieldVariable)
      CALL Field_VariableIndexGet(field,variableIdx,fieldVariable,variableType,err,error,*999)
      DO componentIdx=1,fieldVariable%numberOfComponents
        fieldComponent=>fieldVariable%components(componentIdx)
        SELECT CASE(fieldComponent%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          numberOfConstantDOFs=numberOfConstantDOFs+1
          numberOfLocalVariableDOFS=numberOfLocalVariableDOFS+1
          totalNumberOfVariableDOFS=totalNumberOfVariableDOFS+1
          numberOfGlobalVariableDOFS=numberOfGlobalVariableDOFS+1
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          NULLIFY(domain)
          CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
          NULLIFY(domainTopology)
          CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
          NULLIFY(domainElements)
          CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
          numberOfElementDOFs=numberOfElementDOFs+domainElements%totalNumberOfElements
          numberOfLocalVariableDOFS=numberOfLocalVariableDOFS+domainElements%numberOfElements
          totalNumberOfVariableDOFS=totalNumberOfVariableDOFS+domainElements%totalNumberOfElements
          numberOfGlobalVariableDOFS=numberOfGlobalVariableDOFS+domainElements%numberOfGlobalElements
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          NULLIFY(domain)
          CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
          NULLIFY(domainTopology)
          CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
          NULLIFY(domainDofs)
          CALL DomainTopology_DomainDofsGet(domainTopology,domainDofs,err,error,*999)
          numberOfNodeDOFs=numberOfNodeDOFs+domainDofs%totalNumberOfDofs
          numberOfLocalVariableDOFS=numberOfLocalVariableDOFS+domainDofs%numberOfDofs
          totalNumberOfVariableDOFS=totalNumberOfVariableDOFS+domainDofs%totalNumberOfDofs
          numberOfGlobalVariableDOFS=numberOfGlobalVariableDOFS+domainDofs%numberOfGlobalDofs
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          NULLIFY(domain)
          CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
          NULLIFY(domainTopology)
          CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
          NULLIFY(domainElements)
          CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
          maxNumberOfGauss = -1
          DO elementIdx=1,domainElements%numberOfElements
            NULLIFY(basis)
            CALL DomainElements_ElementBasisGet(domainElements,elementIdx,basis,err,error,*999)
            NULLIFY(quadratureScheme)
            CALL Basis_QuadratureSchemeGet(basis,BASIS_DEFAULT_QUADRATURE_SCHEME,quadratureScheme,err,error,*999)
            numberOfGauss=quadratureScheme%numberOfGauss
            maxNumberOfGauss=MAX(maxNumberOfGauss,numberOfGauss)
          ENDDO !elementIdx
          CALL MPI_ALLREDUCE(MPI_IN_PLACE,maxNumberOfGauss,1,MPI_INTEGER,MPI_MAX,groupCommunicator,mpiIError)
          CALL MPI_ErrorCheck("MPI_ALLREDUCE",mpiIError,err,error,*999)             
          numberOfGaussPointDOFs=numberOfGaussPointDOFs+domainElements%totalNumberOfElements*maxNumberOfGauss
          numberOfLocalVariableDOFS=numberOfLocalVariableDOFS+domainElements%numberOfElements*maxNumberOfGauss
          totalNumberOfVariableDOFS=totalNumberOfVariableDOFS+domainElements%totalNumberOfElements*maxNumberOfGauss
          numberOfGlobalVariableDOFS=numberOfGlobalVariableDOFS+domainElements%numberOfGlobalElements*maxNumberOfGauss
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          ! Data points do not have domain topology or mappings, since they're the same across all mesh components
          NULLIFY(decompositionTopology)
          CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
          NULLIFY(decompositionDataPoints)
          CALL DecompositionTopology_DecompositionDataPointsGet(decompositionTopology,decompositionDataPoints,err,error,*999)
          numberOfDataPointDOFs=numberOfDataPointDOFs+decompositionDataPoints%totalNumberOfDataPoints
          numberOfLocalVariableDOFS=numberOfLocalVariableDOFS+decompositionDataPoints%numberOfDataPoints
          totalNumberOfVariableDOFS=totalNumberOfVariableDOFS+decompositionDataPoints%totalNumberOfDataPoints  
          numberOfGlobalVariableDOFS=numberOfGlobalVariableDOFS+decompositionDataPoints%numberOfGlobalDataPoints
        CASE DEFAULT
          localError="The interpolation type of "// &
            & TRIM(NumberToVString(fieldVariable%components(componentIdx)%interpolationType, &
            & "*",err,error))//" is invalid for component number "//TRIM(NumberToVString(componentIdx,"*",err,error))// &
            & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ENDDO !componentIdx
      !Allocate the DOF to parameters (nodes, elements, gauss, components etc.) maps. 
      fieldVariable%numberOfDofs=numberOfLocalVariableDOFS
      fieldVariable%totalNumberOfDofs=totalNumberOfVariableDOFS
      fieldVariable%numberOfGlobalDofs=numberOfGlobalVariableDOFS
      ALLOCATE(fieldVariable%dofToParamMap%DOFType(2,totalNumberOfVariableDOFS),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate dof to parameter map.",err,error,*999)
      fieldVariable%dofToParamMap%numberOfDofs=totalNumberOfVariableDOFS
      IF(numberOfConstantDOFs>0) THEN
        ALLOCATE(fieldVariable%dofToParamMap%constantDOF2ParamMap(numberOfConstantDOFs),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate dof to parameter constant map.",err,error,*999)
        fieldVariable%dofToParamMap%numberOfConstantDOFs=numberOfConstantDOFs
      ENDIF
      IF(numberOfElementDOFs>0) THEN
        ALLOCATE(fieldVariable%dofToParamMap%elementDOF2ParamMap(2,numberOfElementDOFs),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate dof to parameter element map.",err,error,*999)
        fieldVariable%dofToParamMap%numberOfElementDOFs=numberOfElementDOFs
      ENDIF
      IF(numberOfNodeDOFs>0) THEN
        ALLOCATE(fieldVariable%dofToParamMap%nodeDOF2ParamMap(4,numberOfNodeDOFs),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate dof to parameter node map.",err,error,*999)
        fieldVariable%dofToParamMap%numberOfNodeDOFs=numberOfNodeDOFs
      ENDIF
      IF(numberOfGridPointDOFs>0) THEN
        ALLOCATE(fieldVariable%dofToParamMap%gridPointDOF2ParamMap(2,numberOfGridPointDOFs),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate dof to parameter grid point map.",err,error,*999)
        fieldVariable%dofToParamMap%numberOfGridPointDOFs=numberOfGridPointDOFs
      ENDIF
      IF(numberOfGaussPointDOFs>0) THEN
        ALLOCATE(fieldVariable%dofToParamMap%gaussPointDOF2ParamMap(3,numberOfGaussPointDOFs),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate dof to parameter Gauss point map.",err,error,*999)
        fieldVariable%dofToParamMap%numberOfGaussPointDOFs=numberOfGaussPointDOFs
      ENDIF
      IF(numberOfDataPointDOFs>0) THEN
        ALLOCATE(fieldVariable%dofToParamMap%dataPointDOF2ParamMap(3,numberOfDataPointDOFs),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate dof to parameter Gauss point map.",err,error,*999)
        fieldVariable%dofToParamMap%numberOfDataPointDOFs=numberOfDataPointDOFs
      ENDIF
    ENDDO !variableIdx
    !Allocate the mapping arrays
    ALLOCATE(variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate variable local dofs offsets.",err,error,*999)
    ALLOCATE(variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate variable ghost dofs offsets.",err,error,*999)
    !We want to ensure that the ghost DOFs are at the end so loop over the DOFs in two passes. The first pass will process
    !the local DOFs for each variable component and the second pass will process the ghost DOFs for each variable component.
    IF(numberOfGroupComputationNodes==1) THEN
      domainTypeStop=1 !Local only
    ELSE
      domainTypeStop=2 !Local+Ghosts
    ENDIF
    !Calculate the local and global numbers and set up the mappings
    DO variableIdx=1,field%numberOfVariables
      constantDOFIdx=0
      elementDOFIdx=0
      nodeDOFIdx=0
      gridPointDOFIdx=0
      gaussPointDOFIdx=0
      dataPointDOFIdx=0
      variableLocalDOFIdx=0
      NULLIFY(fieldVariable)
      CALL Field_VariableIndexGet(field,variableIdx,fieldVariable,variableType,err,error,*999)
      NULLIFY(fieldVariableDOFSMapping)
      CALL FieldVariable_DomainMappingGet(fieldVariable,fieldVariableDOFSMapping,err,error,*999)
      IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
        CALL DomainMapping_WorkGroupSet(fieldVariableDOFSMapping,workGroup,err,error,*999)
        ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(fieldVariable%numberOfGlobalDofs),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate variable dofs mapping global to local map.",err,error,*999)
        fieldVariableDOFSMapping%numberOfGlobal=fieldVariable%numberOfGlobalDofs
      ENDIF
      !The ordering of the DOFs with respect to components is arbitrary. Allow for two orderings: The first ordering is that
      !all the DOFs from one component are processed before all the DOFs of the next component. This is known as "separated"
      !component DOF ordering. The second ordering is to process all the components for a particular parameter (e.g., node)
      !and then process all the components for the next parameter. This is known as "contiguous" component DOF ordering.
      !Continguous component ordering only works if each of the components has the same DOF structure. For this reason
      !separate component ordering is the default.
      SELECT CASE(fieldVariable%dofOrderType)
      CASE(FIELD_SEPARATED_COMPONENT_DOF_ORDER)
        !Loop over the domain types. Here domainTypeIdx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
        variableGhostDOFSOffsets=0
        DO domainTypeIdx=1,domainTypeStop
          variableGlobalDOFSOffset=0
          variableLocalDOFSOffsets=0
          DO componentIdx=1,fieldVariable%numberOfComponents
            numberOfLocal=0
            fieldComponent=>fieldVariable%components(componentIdx)
            SELECT CASE(fieldComponent%interpolationType)
            CASE(FIELD_CONSTANT_INTERPOLATION)
              !Only process the non-ghosted dofs for constant interpolation
              IF(domainTypeIdx==1) THEN
                variableLocalDOFIdx=variableLocalDOFIdx+1
                !Allocate and set up global to local domain map for variable mapping
                IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                  variableGlobalDOFIdx=1+variableGlobalDOFSOffset
                  CALL DomainGlobalMapping_Initialise(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx), &
                    & err,error,*999)
                  numberOfDomains=numberOfGroupComputationNodes !Constant is in all domains
                  ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(numberOfDomains), &
                    & STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                    & err,error,*999)
                  ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(numberOfDomains), &
                    & STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                    & err,error,*999)
                  ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(numberOfDomains), &
                    & STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                    & err,error,*999)
                  !A constant dof is mapped to all domains.
                  fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains=numberOfDomains
                  DO domainIdx=1,numberOfDomains
                    domainNumber=domainIdx-1
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                      & 1+variableLocalDOFSOffsets(domainNumber)
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)=domainNumber
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)=DOMAIN_LOCAL_INTERNAL
                  ENDDO !domainIdx
                ENDIF
                constantDOFIdx=constantDOFIdx+1
                !Setup dof to parameter map
                fieldVariable%dofToParamMap%DOFType(1,variableLocalDOFIdx)=FIELD_CONSTANT_DOF_TYPE
                fieldVariable%dofToParamMap%DOFType(2,variableLocalDOFIdx)=constantDOFIdx
                fieldVariable%dofToParamMap%constantDOF2ParamMap(constantDOFIdx)=componentIdx
                !Setup reverse parameter to dof map
                fieldComponent%paramToDOFMap%numberOfConstantParameters=1
                fieldComponent%paramToDOFMap%constantParam2DOFMap=variableLocalDOFIdx
                !Adjust the offsets
                variableGlobalDOFSOffset=variableGlobalDOFSOffset+1
                variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)+1
              ENDIF
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              NULLIFY(domain)
              CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
              NULLIFY(domainTopology)
              CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
              NULLIFY(domainElements)
              CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
              NULLIFY(domainMappings)               
              CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
              NULLIFY(elementsMapping)
              CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
              IF(domainTypeIdx==1) THEN
                !Allocate parameter to dof map for this field variable component
                dofsMapping=>elementsMapping
                ALLOCATE(fieldComponent%paramToDOFMap%elementParam2DOFMap%ELEMENTS(domainElements% &
                  & totalNumberOfElements),STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof element map.",err,error,*999)
                fieldComponent%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters= &
                  & domainElements%totalNumberOfElements
                !Handle global dofs domain mapping
                DO dofIdx=1,elementsMapping%numberOfGlobal
                  !Handle field variable mappings
                  IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                    variableGlobalDOFIdx=dofIdx+variableGlobalDOFSOffset
                    CALL DomainGlobalMapping_Initialise(fieldVariableDOFSMapping% &
                      & globalToLocalMap(variableGlobalDOFIdx),err,error,*999)
                    numberOfDomains=dofsMapping%globalToLocalMap(dofIdx)%numberOfDomains
                    ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                      & localNumber(numberOfDomains),STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                      & err,error,*999)
                    ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                      & domainNumber(numberOfDomains),STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                      & err,error,*999)
                    ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(numberOfDomains), &
                      & STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                      & err,error,*999)
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains=numberOfDomains
                    DO domainIdx=1,numberOfDomains
                      domainNumber=dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                      fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                        & dofsMapping%globalToLocalMap(dofIdx)%localNumber(domainIdx)+variableLocalDOFSOffsets(domainNumber)
                      fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)= &
                        & dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                      fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)= &
                        & dofsMapping%globalToLocalMap(dofIdx)%localType(domainIdx)
                    ENDDO !domainIdx
                  ENDIF
                ENDDO !dofIdx
                startIdx=1
                stopIdx=elementsMapping%numberOfLocal
                !Adjust the local and ghost offsets
                IF(componentIdx>1) &
                  & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)+elementsMapping%numberOfDomainLocal
                variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)+ &
                  & elementsMapping%numberOfDomainLocal+elementsMapping%numberOfDomainGhost
              ELSE
                !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                !dofs are at the end of the local dofs.
                !Adjust the ghost offsets
                IF(componentIdx>1) &
                  & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)-elementsMapping%numberOfDomainLocal
                DO dofIdx=1,elementsMapping%numberOfGlobal
                  !Adjust variable mapping local numbers
                  IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                    variableGlobalDOFIdx=dofIdx+variableGlobalDOFSOffset
                    numberOfDomains=fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains
                    DO domainIdx=1,numberOfDomains
                      domainNumber=fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)
                      IF(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)== &
                        & DOMAIN_LOCAL_GHOST) THEN
                        fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                          & fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)+ &
                          & variableGhostDOFSOffsets(domainNumber)
                      ELSE
                        fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                          & fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)+ &
                          & variableLocalDOFSOffsets(domainNumber)
                      ENDIF
                    ENDDO !domainIdx
                  ENDIF
                ENDDO !dofIdx (global)
                startIdx=elementsMapping%numberOfLocal+1
                stopIdx=elementsMapping%totalNumberOfLocal
                !Adjust the local offsets
                variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)-elementsMapping%numberOfDomainGhost
              ENDIF
              !Adjust the global offset
              variableGlobalDOFSOffset=variableGlobalDOFSOffset+elementsMapping%numberOfGlobal
              !Handle local dofs domain mapping
              DO elementIdx=startIdx,stopIdx
                variableLocalDOFIdx=variableLocalDOFIdx+1
                elementDOFIdx=elementDOFIdx+1
                !Setup dof to parameter map
                fieldVariable%dofToParamMap%DOFType(1,variableLocalDOFIdx)=FIELD_ELEMENT_DOF_TYPE
                fieldVariable%dofToParamMap%DOFType(2,variableLocalDOFIdx)=elementDOFIdx
                fieldVariable%dofToParamMap%elementDOF2ParamMap(1,elementDOFIdx)=elementIdx
                fieldVariable%dofToParamMap%elementDOF2ParamMap(2,elementDOFIdx)=componentIdx
                !Setup reverse parameter to dof map
                fieldComponent%paramToDOFMap%elementParam2DOFMap%ELEMENTS(elementIdx)=variableLocalDOFIdx
              ENDDO !elementIdx
            CASE(FIELD_NODE_BASED_INTERPOLATION)
              NULLIFY(domain)
              CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
              NULLIFY(domainTopology)
              CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
              NULLIFY(domainDofs)
              CALL DomainTopology_DomainDofsGet(domainTopology,domainDofs,err,error,*999)
              NULLIFY(domainNodes)
              CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
              NULLIFY(domainMappings)               
              CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
              NULLIFY(dofsMapping)
              CALL DomainMappings_DofsMappingGet(domainMappings,dofsMapping,err,error,*999)
              IF(domainTypeIdx==1) THEN
                ALLOCATE(fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(domainNodes%totalNumberOfNodes),STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (nodes).",err,error,*999)
                fieldComponent%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters = domainNodes%totalNumberOfNodes
                !Loop through and allocate number of derivatives for each node in the domain
                DO nodeIdx=1,domainNodes%totalNumberOfNodes
                  ALLOCATE(fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%derivatives( &
                    & domainNodes%nodes(nodeIdx)%numberOfDerivatives),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (derivatives).", &
                    & err,error,*999)
                  fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%numberOfDerivatives = & 
                    & domainNodes%nodes(nodeIdx)%numberOfDerivatives
                  DO derivativeIdx=1,domainNodes%nodes(nodeIdx)%numberOfDerivatives
                    ALLOCATE(fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%DERIVATIVES(derivativeIdx)% &
                      & VERSIONS(domainNodes%nodes(nodeIdx)%DERIVATIVES(derivativeIdx)%numberOfVersions),STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (versions).", &
                      & err,error,*999)
                    fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%DERIVATIVES(derivativeIdx)% &
                      & numberOfVersions = domainNodes%nodes(nodeIdx)%DERIVATIVES(derivativeIdx)%numberOfVersions
                  ENDDO !derivativeIdx
                ENDDO !nodeIdx
                DO dofIdx=1,dofsMapping%numberOfGlobal
                  !Handle variable mapping
                  IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                    variableGlobalDOFIdx=dofIdx+variableGlobalDOFSOffset
                    CALL DomainGlobalMapping_Initialise(fieldVariableDOFSMapping% &
                      & globalToLocalMap(variableGlobalDOFIdx),err,error,*999)
                    numberOfDomains=dofsMapping%globalToLocalMap(dofIdx)%numberOfDomains
                    ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                      & localNumber(numberOfDomains),STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                      & err,error,*999)
                    ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                      & domainNumber(numberOfDomains),STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                      & err,error,*999)
                    ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(numberOfDomains), &
                      & STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                      & err,error,*999)
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains=numberOfDomains
                    DO domainIdx=1,numberOfDomains
                      domainNumber=dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                      fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                        & dofsMapping%globalToLocalMap(dofIdx)%localNumber(domainIdx)+variableLocalDOFSOffsets(domainNumber)
                      fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)= &
                        & dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                      fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)= &
                        & dofsMapping%globalToLocalMap(dofIdx)%localType(domainIdx)
                    ENDDO !domainIdx
                  ENDIF
                ENDDO !dofIdx (global)
                startIdx=1
                stopIdx=dofsMapping%numberOfLocal
                !Adjust the local and ghost offsets
                IF(componentIdx>1) &
                  & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)+dofsMapping%numberOfDomainLocal
                variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)+ &
                  & dofsMapping%numberOfDomainLocal+dofsMapping%numberOfDomainGhost
              ELSE
                !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                !dofs are at the end of the local dofs.
                !Adjust the ghost offsets
                IF(componentIdx>1) &
                  variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)-dofsMapping%numberOfDomainLocal
                DO dofIdx=1,dofsMapping%numberOfGlobal
                  !Adjust variable mapping local numbers
                  IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                    variableGlobalDOFIdx=dofIdx+variableGlobalDOFSOffset
                    numberOfDomains=fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains
                    DO domainIdx=1,numberOfDomains
                      domainNumber=fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)
                      IF(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)== &
                        & DOMAIN_LOCAL_GHOST) THEN
                        fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                          & fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)+ &
                          & variableGhostDOFSOffsets(domainNumber)
                      ELSE
                        fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                          & fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)+ &
                          & variableLocalDOFSOffsets(domainNumber)
                      ENDIF
                    ENDDO !domainIdx
                  ENDIF
                ENDDO !dofIdx (global)
                startIdx=dofsMapping%numberOfLocal+1
                stopIdx=dofsMapping%totalNumberOfLocal
                !Adjust the local offsets
                variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)-dofsMapping%numberOfDomainGhost
              ENDIF
              !Adjust the global offset
              variableGlobalDOFSOffset=variableGlobalDOFSOffset+dofsMapping%numberOfGlobal
              !Handle local dofs domain mapping
              DO dofIdx=startIdx,stopIdx
                variableLocalDOFIdx=variableLocalDOFIdx+1
                nodeDOFIdx=nodeDOFIdx+1
                versionIdx=domainTopology%dofs%dofIndex(1,dofIdx)
                derivativeIdx=domainTopology%dofs%dofIndex(2,dofIdx)
                nodeIdx=domainTopology%dofs%dofIndex(3,dofIdx)
                !Setup dof to parameter map
                fieldVariable%dofToParamMap%DOFType(1,variableLocalDOFIdx)=FIELD_NODE_DOF_TYPE
                fieldVariable%dofToParamMap%DOFType(2,variableLocalDOFIdx)=nodeDOFIdx
                fieldVariable%dofToParamMap%nodeDOF2ParamMap(1,nodeDOFIdx)=versionIdx
                fieldVariable%dofToParamMap%nodeDOF2ParamMap(2,nodeDOFIdx)=derivativeIdx
                fieldVariable%dofToParamMap%nodeDOF2ParamMap(3,nodeDOFIdx)=nodeIdx
                fieldVariable%dofToParamMap%nodeDOF2ParamMap(4,nodeDOFIdx)=componentIdx
                !Setup reverse parameter to dof map
                fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%DERIVATIVES(derivativeIdx)% &
                  & VERSIONS(versionIdx) = variableLocalDOFIdx
              ENDDO !dofIdx
            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              NULLIFY(domain)
              CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
              NULLIFY(domainTopology)
              CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
              NULLIFY(domainElements)
              CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
              NULLIFY(domainMappings)               
              CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
              NULLIFY(elementsMapping)
              CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
              IF(domainTypeIdx==1) THEN ! domainTypeIdx==1 --> non ghosts
                !Allocate parameter to dof map for this field variable component
                dofsMapping=>elementsMapping
                ! gaussPointParam2DOFMap%gaussPoints(ng,elementIdx). The field variable dof number of ng'th Gauss point in the elementIdx'th element based parameter for this field variable component. 
                ALLOCATE(fieldComponent%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(&
                  & maxNumberOfGauss,domainElements%totalNumberOfElements),STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof Gauss point map.",err,error,*999)
                ! this might be wasteful in worst case, but should generally be ok
                fieldComponent%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters= &
                  &  domainElements%totalNumberOfElements*maxNumberOfGauss
                !Handle global dofs domain mapping
                DO dofIdx=1,elementsMapping%numberOfGlobal
                  DO gaussPointIdx=1,maxNumberOfGauss !
                    !Handle field variable mappings
                    IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                      variableGlobalDOFIdx= (dofIdx-1) * maxNumberOfGauss + gaussPointIdx + variableGlobalDOFSOffset
                      CALL DomainGlobalMapping_Initialise(fieldVariableDOFSMapping% &
                        & globalToLocalMap(variableGlobalDOFIdx),err,error,*999)
                      numberOfDomains=dofsMapping%globalToLocalMap(dofIdx)%numberOfDomains
                      ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                        & localNumber(numberOfDomains),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                        & err,error,*999)
                      ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                        & domainNumber(numberOfDomains),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                        & err,error,*999)
                      ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(numberOfDomains), &
                        & STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                        & err,error,*999)
                      fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains=numberOfDomains
                      DO domainIdx=1,numberOfDomains
                        domainNumber=dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                        ! elt local number = 1 -> gaussPointIdx local = 1..max_ngp, etc
                        fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                          & (dofsMapping%globalToLocalMap(dofIdx)%localNumber(domainIdx) - 1) * maxNumberOfGauss + gaussPointIdx  &
                          & + variableLocalDOFSOffsets(domainNumber)
                        ! domain and type same as element
                        fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)= &
                          & dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                        fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)= &
                          & dofsMapping%globalToLocalMap(dofIdx)%localType(domainIdx)
                      ENDDO !domainIdx
                    ENDIF
                  ENDDO !gaussPointIdx
                ENDDO !dofIdx
                startIdx=1
                stopIdx=elementsMapping%numberOfLocal
                !Adjust the local and ghost offsets
                IF(componentIdx>1) &
                  & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)+ &
                  & elementsMapping%numberOfDomainLocal*maxNumberOfGauss
                variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)+ &
                  & (elementsMapping%numberOfDomainLocal+elementsMapping%numberOfDomainGhost)*maxNumberOfGauss
              ELSE !domainTypeIdx==2 --> ghosts
                !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                !dofs are at the end of the local dofs.
                !Adjust the ghost offsets
                IF(componentIdx>1) &
                  variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)- &
                  & elementsMapping%numberOfDomainLocal*maxNumberOfGauss
                DO dofIdx=1,elementsMapping%numberOfGlobal
                  DO gaussPointIdx=1,maxNumberOfGauss !
                    !Adjust variable mapping local numbers
                    IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                      variableGlobalDOFIdx= (dofIdx-1) * maxNumberOfGauss + gaussPointIdx + variableGlobalDOFSOffset
                      numberOfDomains=fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains
                      DO domainIdx=1,numberOfDomains
                        domainNumber=fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)
                        IF(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)== &
                          & DOMAIN_LOCAL_GHOST) THEN
                          fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                            & fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)+ &
                            & variableGhostDOFSOffsets(domainNumber)
                        ELSE
                          fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                            & fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)+ &
                            & variableLocalDOFSOffsets(domainNumber)
                        ENDIF
                      ENDDO !domainIdx
                    ENDIF
                  ENDDO ! gaussPointIdx
                ENDDO !dofIdx (global)
                startIdx=elementsMapping%numberOfLocal+1
                stopIdx=elementsMapping%totalNumberOfLocal
                !Adjust the local offsets
                variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)- &
                  & elementsMapping%numberOfDomainGhost*maxNumberOfGauss
              ENDIF ! 2 passes for normal, ghost 
              !Adjust the global offset
              variableGlobalDOFSOffset=variableGlobalDOFSOffset+elementsMapping%numberOfGlobal*maxNumberOfGauss
              !Handle local dofs domain mapping
              DO elementIdx=startIdx,stopIdx
                DO gaussPointIdx=1,maxNumberOfGauss !
                  variableLocalDOFIdx= variableLocalDOFIdx+1
                  gaussPointDOFIdx  = gaussPointDOFIdx+1
                  !Setup dof to parameter map
                  fieldVariable%dofToParamMap%DOFType(1,variableLocalDOFIdx)=FIELD_GAUSS_POINT_DOF_TYPE
                  fieldVariable%dofToParamMap%DOFType(2,variableLocalDOFIdx)=gaussPointDOFIdx
                  fieldVariable%dofToParamMap%gaussPointDOF2ParamMap(1,gaussPointDOFIdx)=gaussPointIdx
                  fieldVariable%dofToParamMap%gaussPointDOF2ParamMap(2,gaussPointDOFIdx)=elementIdx
                  fieldVariable%dofToParamMap%gaussPointDOF2ParamMap(3,gaussPointDOFIdx)=componentIdx
                  !Setup reverse parameter to dof map
                  fieldComponent%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gaussPointIdx,elementIdx)=variableLocalDOFIdx
                ENDDO !gaussPointIdx
              ENDDO !elementIdx                       
            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              NULLIFY(domain)
              CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
              NULLIFY(decompositionTopology)
              CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
              NULLIFY(decompositionDataPoints)
              CALL DecompositionTopology_DecompositionDataPointsGet(decompositionTopology,decompositionDataPoints,err,error,*999)
              NULLIFY(domainMappings)               
              CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
              NULLIFY(elementsMapping)
              CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
              IF(domainTypeIdx==1) THEN ! domainTypeIdx==1 -> non ghosts
                !Allocate parameter to dof map for this field variable component
                !including both local and ghost data points on this computation domain.
                ALLOCATE(fieldComponent%paramToDOFMap%dataPointParam2DOFMap%dataPoints(decompositionDataPoints% &
                  & totalNumberOfDataPoints),STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof data point map.",err,error,*999)
                ! Number of data points
                fieldComponent%paramToDOFMap%dataPointParam2DOFMap%numberOfDataPointParameters= &
                  & decompositionDataPoints%totalNumberOfDataPoints 
                ALLOCATE(localDataParamCount(0:numberOfGroupComputationNodes-1),STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate data point parameter local count.",err,error,*999)
                ALLOCATE(ghostDataParamCount(0:numberOfGroupComputationNodes-1),STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate data point parameter ghost count.",err,error,*999)
                localDataParamCount=0
                ghostDataParamCount(0:numberOfGroupComputationNodes-1)=decompositionDataPoints%numberOfDomainLocal
                !Looping through global elements and data points in the elements
                variableGlobalDOFIdx=variableGlobalDOFSOffset
                DO elementIdx=1,elementsMapping%numberOfGlobal
                  DO dataPointIdx=1,decompositionDataPoints%numberOfelementDataPoints(elementIdx)
                    IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                      variableGlobalDOFIdx=variableGlobalDOFIdx+1
                      CALL DomainGlobalMapping_Initialise(fieldVariableDOFSMapping% &
                        & globalToLocalMap(variableGlobalDOFIdx),err,error,*999)
                      numberOfDomains=elementsMapping%globalToLocalMap(elementIdx)%numberOfDomains
                      ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                        & localNumber(numberOfDomains),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                        & err,error,*999)
                      ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                        & domainNumber(numberOfDomains),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                        & err,error,*999)
                      ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                        & localType(numberOfDomains),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                        & err,error,*999)
                      fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains=numberOfDomains
                      DO domainIdx=1,numberOfDomains
                        domainNumber=elementsMapping%globalToLocalMap(elementIdx)%domainNumber(domainIdx)
                        IF(elementsMapping%globalToLocalMap(elementIdx)%localType(domainIdx)== &
                          & DOMAIN_LOCAL_GHOST) THEN
                          ghostDataParamCount(domainNumber)=ghostDataParamCount(domainNumber)+1
                          fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                            & ghostDataParamCount(domainNumber)+variableLocalDOFSOffsets(domainNumber)
                        ELSE
                          localDataParamCount(domainNumber)=localDataParamCount(domainNumber)+1
                          fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                            & localDataParamCount(domainNumber)+variableLocalDOFSOffsets(domainNumber)
                        ENDIF
                        fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)= &
                          & elementsMapping%globalToLocalMap(elementIdx)%domainNumber(domainIdx)
                        fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)= &
                          & elementsMapping%globalToLocalMap(elementIdx)%localType(domainIdx)
                      ENDDO !domainIdx
                    ENDIF
                  ENDDO !dataPointIdx
                ENDDO !elementIdx 
                IF(ALLOCATED(localDataParamCount)) DEALLOCATE(localDataParamCount)
                IF(ALLOCATED(ghostDataParamCount)) DEALLOCATE(ghostDataParamCount)
                startIdx=1 !the start idx for the elements
                stopIdx=elementsMapping%numberOfLocal !the end idx for local elements
                !Adjust the local and ghost offsets
                IF(componentIdx>1) THEN
                  variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                    & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)+ &
                    & decompositionDataPoints%numberOfDomainLocal
                ENDIF
                variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)+ &
                  & decompositionDataPoints%numberOfDomainLocal+decompositionDataPoints%numberOfDomainGhost
              ELSE  ! domainTypeIdx == 2 -> ghosts
                !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                !dofs are at the end of the local dofs.
                !Adjust the ghost offsets
                IF(componentIdx>1) THEN
                  variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                    & variableGhostDOFSOffsets(0:numberOfGroupComputationNodes-1)- &
                    & decompositionDataPoints%numberOfDomainLocal
                ENDIF
                !Looping through global elements and data points in the elements
                variableGlobalDOFIdx=variableGlobalDOFSOffset
                DO elementIdx=1,elementsMapping%numberOfGlobal
                  DO dataPointIdx=1,decompositionDataPoints%numberOfelementDataPoints(elementIdx)
                    IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                      variableGlobalDOFIdx=variableGlobalDOFIdx+1
                      numberOfDomains=elementsMapping%globalToLocalMap(elementIdx)%numberOfDomains
                      DO domainIdx=1,numberOfDomains
                        domainNumber=elementsMapping%globalToLocalMap(elementIdx)%domainNumber(domainIdx)
                        IF(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)== &
                          & DOMAIN_LOCAL_GHOST) THEN
                          fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                            & fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)+ &
                            & variableGhostDOFSOffsets(domainNumber)
                        ELSE
                          fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                            & fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)+ &
                            & variableLocalDOFSOffsets(domainNumber)
                        ENDIF
                      ENDDO
                    ENDIF
                  ENDDO !dataPointIdx
                ENDDO !elementIdx 
                !Adjust the local offsets
                variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                  & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)- &
                  & decompositionDataPoints%numberOfDomainGhost
                startIdx=elementsMapping%numberOfLocal+1 !The start index for ghost elements
                stopIdx=elementsMapping%totalNumberOfLocal !The end index for local elements
              ENDIF
              !Adjust the global offset
              variableGlobalDOFSOffset=variableGlobalDOFSOffset+decompositionDataPoints%&
                & numberOfGlobalDataPoints  
              !Handle local dofs domain mapping
              DO elementIdx=startIdx,stopIdx
                globalElementNumber=elementsMapping%localToGlobalMap(elementIdx)
                DO dataPointIdx=1,decompositionDataPoints%numberOfelementDataPoints(globalElementNumber)
                  variableLocalDOFIdx=variableLocalDOFIdx+1 !reinitialise for every field variable, field variable dof idx
                  dataPointDOFIdx=dataPointDOFIdx+1 !reinitialise for every field variable, field variable data point dof idx
                  localDataNumber=decompositionDataPoints%elementDataPoints(elementIdx)%dataIndices(dataPointIdx)% &
                    & localNumber
                  !Setup dof to parameter map
                  fieldVariable%dofToParamMap%DOFType(1,variableLocalDOFIdx)=FIELD_DATA_POINT_DOF_TYPE
                  fieldVariable%dofToParamMap%DOFType(2,variableLocalDOFIdx)=dataPointDOFIdx
                  fieldVariable%dofToParamMap%dataPointDOF2ParamMap(1,dataPointDOFIdx)=localDataNumber
                  fieldVariable%dofToParamMap%dataPointDOF2ParamMap(2,dataPointDOFIdx)=elementIdx
                  fieldVariable%dofToParamMap%dataPointDOF2ParamMap(3,dataPointDOFIdx)=componentIdx
                  !Setup reverse parameter to dof map
                  fieldComponent%paramToDOFMap%dataPointParam2DOFMap%dataPoints(localDataNumber)=variableLocalDOFIdx
                ENDDO !dataPointIdx
              ENDDO !elementIdx 
            CASE DEFAULT
              localError="The interpolation type of "// &
                & TRIM(NumberToVString(fieldVariable%components(componentIdx)%interpolationType, &
                & "*",err,error))//" is invalid for component number "//TRIM(NumberToVString(componentIdx,"*",err,error))// &
                & " of variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !componentIdx
        ENDDO !domainTypeIdx
      CASE(FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER)
        !Handle the case where all components for a particular DOF parameter are processed before all the component of the next
        !parameter.
        variableLocalDOFSOffsets=0
        variableGlobalDOFSOffset=0
        variableGhostDOFSOffsets=0
        IF(fieldVariable%numberOfComponents>=1) THEN
          SELECT CASE(fieldVariable%components(1)%interpolationType)
          CASE(FIELD_CONSTANT_INTERPOLATION)
            DO componentIdx=1,fieldVariable%numberOfComponents
              fieldComponent=>fieldVariable%components(componentIdx)
              variableLocalDOFIdx=1+variableLocalDOFSOffsets(myGroupComputationNodeNumber)
              !Allocate and set up global to local domain map for variable mapping
              IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                variableGlobalDOFIdx=1+variableGlobalDOFSOffset
                CALL DomainGlobalMapping_Initialise(fieldVariableDOFSMapping% &
                  & globalToLocalMap(variableGlobalDOFIdx),err,error,*999)
                numberOfDomains=numberOfGroupComputationNodes !Constant is in all domains
                ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(numberOfDomains), &
                  & STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                  & err,error,*999)
                ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(numberOfDomains), &
                  & STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                  & err,error,*999)
                ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(numberOfDomains), &
                  & STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                  & err,error,*999)
                !A constant dof is mapped to all domains.
                fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains=numberOfDomains
                DO domainIdx=1,numberOfDomains
                  domainNumber=domainIdx-1
                  fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                    & 1+variableLocalDOFSOffsets(domainNumber)
                  fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)=domainNumber
                  fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)=DOMAIN_LOCAL_INTERNAL
                ENDDO !domainIdx
              ENDIF
              constantDOFIdx=constantDOFIdx+1
              !Setup dof to parameter map
              fieldVariable%dofToParamMap%DOFType(1,variableLocalDOFIdx)=FIELD_CONSTANT_DOF_TYPE
              fieldVariable%dofToParamMap%DOFType(2,variableLocalDOFIdx)=constantDOFIdx
              fieldVariable%dofToParamMap%constantDOF2ParamMap(constantDOFIdx)=componentIdx
              !Setup reverse parameter to dof map
              fieldComponent%paramToDOFMap%numberOfConstantParameters=1
              fieldComponent%paramToDOFMap%constantParam2DOFMap=variableLocalDOFIdx
              !Adjust the offsets
              variableGlobalDOFSOffset=variableGlobalDOFSOffset+1
              variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)+1
            ENDDO !componentIdx
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            DO componentIdx=1,fieldVariable%numberOfComponents
              fieldComponent=>fieldVariable%components(componentIdx)
              NULLIFY(domain)
              CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
              NULLIFY(domainTopology)
              CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
              NULLIFY(domainElements)
              CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
              !Allocate parameter to dof map for this field variable component
              ALLOCATE(fieldComponent%paramToDOFMap%elementParam2DOFMap%ELEMENTS(domainElements% &
                & totalNumberOfElements),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof element map.",err,error,*999)
              fieldComponent%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters= &
                & domainElements%totalNumberOfElements
            ENDDO !componentIdx
            !Handle global dofs domain mapping
            elementDOF=0
            numberOfGlobalDofs=fieldVariable%components(1)%DOMAIN%MAPPINGS%ELEMENTS%numberOfGlobal              
            DO dofIdx=1,numberOfGlobalDofs
              DO componentIdx=1,fieldVariable%numberOfComponents
                fieldComponent=>fieldVariable%components(componentIdx)
                NULLIFY(domain)
                CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
                NULLIFY(domainTopology)
                CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                NULLIFY(domainElements)
                CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
                NULLIFY(domainMappings)               
                CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
                NULLIFY(elementsMapping)
                CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
                dofsMapping=>elementsMapping
                !Handle field variable mappings
                IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                  elementDOF=elementDOF+1
                  variableGlobalDOFIdx=elementDOF+variableGlobalDOFSOffset
                  CALL DomainGlobalMapping_Initialise(fieldVariableDOFSMapping% &
                    & globalToLocalMap(variableGlobalDOFIdx),err,error,*999)
                  numberOfDomains=dofsMapping%globalToLocalMap(dofIdx)%numberOfDomains
                  ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(numberOfDomains), &
                    & STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                    & err,error,*999)
                  ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(numberOfDomains), &
                    & STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                    & err,error,*999)
                  ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(numberOfDomains), &
                    & STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                    & err,error,*999)
                  fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains=numberOfDomains
                  DO domainIdx=1,numberOfDomains
                    domainNumber=dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                      & dofsMapping%globalToLocalMap(dofIdx)%localNumber(domainIdx)+variableLocalDOFSOffsets(domainNumber)
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)= &
                      & dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)= &
                      & dofsMapping%globalToLocalMap(dofIdx)%localType(domainIdx)
                  ENDDO !domainIdx
                ENDIF
              ENDDO !componentIdx
            ENDDO !dofIdx
            !Loop over the domain types. Here domainTypeIdx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
            DO domainTypeIdx=1,domainTypeStop
              IF(domainTypeIdx==1) THEN
                startIdx=1
                stopIdx=elementsMapping%numberOfLocal
              ELSE
                startIdx=elementsMapping%numberOfLocal+1
                stopIdx=elementsMapping%totalNumberOfLocal
              ENDIF
              !Handle local dofs domain mapping
              elementDOF=0
              DO elementIdx=startIdx,stopIdx
                DO componentIdx=1,fieldVariable%numberOfComponents
                  fieldComponent=>fieldVariable%components(componentIdx)
                  elementDOF=elementDOF+1
                  variableLocalDOFIdx=elementDOF+variableLocalDOFSOffsets(myGroupComputationNodeNumber)
                  elementDOFIdx=elementDOFIdx+1
                  !Setup dof to parameter map
                  fieldVariable%dofToParamMap%DOFType(1,variableLocalDOFIdx)=FIELD_ELEMENT_DOF_TYPE
                  fieldVariable%dofToParamMap%DOFType(2,variableLocalDOFIdx)=elementDOFIdx
                  fieldVariable%dofToParamMap%elementDOF2ParamMap(1,elementDOFIdx)=elementIdx
                  fieldVariable%dofToParamMap%elementDOF2ParamMap(2,elementDOFIdx)=componentIdx
                  !Setup reverse parameter to dof map
                  fieldComponent%paramToDOFMap%elementParam2DOFMap%elements(elementIdx)=variableLocalDOFIdx
                ENDDO !componentIdx
              ENDDO !elementIdx
              !Adjust the offsets
              variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                &  variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)+ &
                & fieldVariable%numberOfComponents*elementsMapping%numberOfDomainLocal
              IF(domainTypeIdx==1) THEN
                variableGlobalDOFSOffset=variableGlobalDOFSOffset+fieldVariable%numberOfComponents* &
                  & elementsMapping%numberOfGlobal
              ENDIF
            ENDDO !domainTypeIdx
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            DO componentIdx=1,fieldVariable%numberOfComponents
              fieldComponent=>fieldVariable%components(componentIdx)
              NULLIFY(domain)
              CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
              NULLIFY(domainTopology)
              CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
              NULLIFY(domainNodes)
              CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
              ALLOCATE(fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(domainNodes%totalNumberOfNodes), &
                & STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (nodes).",err,error,*999)
              fieldComponent%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters = domainNodes%totalNumberOfNodes
              !Loop through and allocate number of derivatives for each node in the domain
              DO nodeIdx=1,domainNodes%totalNumberOfNodes
                ALLOCATE(fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%derivatives( &
                  & domainNodes%nodes(nodeIdx)%numberOfDerivatives),STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (derivatives).", &
                  & err,error,*999)
                fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%numberOfDerivatives = & 
                  & domainNodes%nodes(nodeIdx)%numberOfDerivatives
                DO derivativeIdx=1,domainNodes%nodes(nodeIdx)%numberOfDerivatives
                  ALLOCATE(fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)% &
                    & versions(domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%numberOfVersions),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (versions).", &
                    & err,error,*999)
                  fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)% &
                    numberOfVersions = domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%numberOfVersions
                ENDDO !derivativeIdx
              ENDDO !nodeIdx
            ENDDO !componentIdx
            !Handle global dofs domain mapping
            !Should the contiguous components have an inner groupping for derivatives??? i.e., loop over nodes, components then
            !derivatives????
            nodeDOF=0
            numberOfGlobalDofs=fieldVariable%components(1)%DOMAIN%MAPPINGS%DOFS%numberOfGlobal
            DO dofIdx=1,numberOfGlobalDofs
              DO componentIdx=1,fieldVariable%numberOfComponents
                fieldComponent=>fieldVariable%components(componentIdx)
                NULLIFY(domain)
                CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
                NULLIFY(domainTopology)
                CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                NULLIFY(domainDofs)
                CALL DomainTopology_DomainDofsGet(domainTopology,domainDofs,err,error,*999)
                NULLIFY(domainNodes)
                CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
                NULLIFY(domainMappings)               
                CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
                NULLIFY(dofsMapping)
                CALL DomainMappings_DofsMappingGet(domainMappings,dofsMapping,err,error,*999)
                !Handle variable mapping
                IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                  nodeDOF=nodeDOF+1
                  variableGlobalDOFIdx=nodeDOF+variableGlobalDOFSOffset
                  CALL DomainGlobalMapping_Initialise(fieldVariableDOFSMapping% &
                    & globalToLocalMap(variableGlobalDOFIdx),err,error,*999)
                  numberOfDomains=dofsMapping%globalToLocalMap(dofIdx)%numberOfDomains
                  ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                    & localNumber(numberOfDomains),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                    & err,error,*999)
                  ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                    & domainNumber(numberOfDomains),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                    & err,error,*999)
                  ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(numberOfDomains), &
                    & STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                    & err,error,*999)
                  fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains=numberOfDomains
                  DO domainIdx=1,numberOfDomains
                    domainNumber=dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                      & dofsMapping%globalToLocalMap(dofIdx)%localNumber(domainIdx)+variableLocalDOFSOffsets(domainNumber)
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)= &
                      & dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)= &
                      & dofsMapping%globalToLocalMap(dofIdx)%localType(domainIdx)
                  ENDDO !domainIdx
                ENDIF
              ENDDO !componentIdx
            ENDDO !dofIdx (global)
            !Loop over the domain types. Here domainTypeIdx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
            DO domainTypeIdx=1,domainTypeStop
              IF(domainTypeIdx==1) THEN
                startIdx=1
                stopIdx=dofsMapping%numberOfLocal
              ELSE
                startIdx=dofsMapping%numberOfLocal+1
                stopIdx=dofsMapping%totalNumberOfLocal
              ENDIF
              !Handle local dofs domain mapping
              nodeDOF=0
              DO dofIdx=startIdx,stopIdx
                DO componentIdx=1,fieldVariable%numberOfComponents
                  fieldComponent=>fieldVariable%components(componentIdx)
                  NULLIFY(domain)
                  CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
                  NULLIFY(domainTopology)
                  CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                  NULLIFY(domainDofs)
                  CALL DomainTopology_DomainDofsGet(domainTopology,domainDofs,err,error,*999)
                  nodeDOF=nodeDOF+1
                  variableLocalDOFIdx=nodeDOF+variableLocalDOFSOffsets(myGroupComputationNodeNumber)
                  nodeDOFIdx=nodeDOFIdx+1
                  versionIdx=domainDofs%dofIndex(1,dofIdx)
                  derivativeIdx=domainDofs%dofIndex(2,dofIdx)
                  nodeIdx=domainDofs%dofIndex(3,dofIdx)
                  !Setup dof to parameter map
                  fieldVariable%dofToParamMap%DOFType(1,variableLocalDOFIdx)=FIELD_NODE_DOF_TYPE
                  fieldVariable%dofToParamMap%DOFType(2,variableLocalDOFIdx)=nodeDOFIdx
                  fieldVariable%dofToParamMap%nodeDOF2ParamMap(1,nodeDOFIdx)=versionIdx
                  fieldVariable%dofToParamMap%nodeDOF2ParamMap(2,nodeDOFIdx)=derivativeIdx
                  fieldVariable%dofToParamMap%nodeDOF2ParamMap(3,nodeDOFIdx)=nodeIdx
                  fieldVariable%dofToParamMap%nodeDOF2ParamMap(4,nodeDOFIdx)=componentIdx
                  !Setup reverse parameter to dof map
                  fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)% &
                    & versions(versionIdx) = variableLocalDOFIdx
                ENDDO !componentIdx
              ENDDO !dofIdx
              !Adjust the offsets
              variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)+ &
                & fieldVariable%numberOfComponents* &
                & dofsMapping%numberOfDomainLocal
              IF(domainTypeIdx==1) THEN
                variableGlobalDOFSOffset=variableGlobalDOFSOffset+fieldVariable%numberOfComponents* &
                  & dofsMapping%numberOfGlobal
              ENDIF
            ENDDO !domainTypeIdx
          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            DO componentIdx=1,fieldVariable%numberOfComponents
              fieldComponent=>fieldVariable%components(componentIdx)
              NULLIFY(domain)
              CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
              NULLIFY(domainTopology)
              CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
              NULLIFY(domainElements)
              CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
              !>todo find a better way than assuming numberOfGauss=maxNumberOfGauss for all elements TODO
              ALLOCATE(fieldComponent%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(maxNumberOfGauss,domainElements% &
                & totalNumberOfElements),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof gauss point map (gauss points).", &
                & err,error,*999)
              fieldComponent%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters= &
                & maxNumberOfGauss*domainElements%totalNumberOfElements
            ENDDO
            !Handle global dofs domain mapping
            elementDOF=0
            numberOfGlobalDofs=fieldVariable%components(1)%DOMAIN%MAPPINGS%ELEMENTS%numberOfGlobal
            DO dofIdx=1,numberOfGlobalDofs
              DO gaussPointIdx=1,maxNumberOfGauss
                DO componentIdx=1,fieldVariable%numberOfComponents
                  fieldComponent=>fieldVariable%components(componentIdx)
                  NULLIFY(domain)
                  CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
                  NULLIFY(domainMappings)               
                  CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
                  NULLIFY(elementsMapping)
                  CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
                  dofsMapping=>elementsMapping
                  !Handle variable mapping
                  IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
                    elementDOF=elementDOF+1
                    variableGlobalDOFIdx=elementDOF+variableGlobalDOFSOffset
                    CALL DomainGlobalMapping_Initialise(fieldVariableDOFSMapping% &
                      & globalToLocalMap(variableGlobalDOFIdx),err,error,*999)
                    numberOfDomains=dofsMapping%globalToLocalMap(dofIdx)%numberOfDomains
                    ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                      & localNumber(numberOfDomains),STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                      & err,error,*999)
                    ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)% &
                      & domainNumber(numberOfDomains),STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                      & err,error,*999)
                    ALLOCATE(fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(numberOfDomains), &
                      & STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                      & err,error,*999)
                    fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%numberOfDomains=numberOfDomains
                    DO domainIdx=1,numberOfDomains
                      domainNumber=dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                      fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localNumber(domainIdx)= &
                        & dofsMapping%globalToLocalMap(dofIdx)%localNumber(domainIdx)+variableLocalDOFSOffsets(domainNumber)
                      fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%domainNumber(domainIdx)= &
                        & dofsMapping%globalToLocalMap(dofIdx)%domainNumber(domainIdx)
                      fieldVariableDOFSMapping%globalToLocalMap(variableGlobalDOFIdx)%localType(domainIdx)= &
                        & dofsMapping%globalToLocalMap(dofIdx)%localType(domainIdx)
                    ENDDO !domainIdx
                  ENDIF
                ENDDO !componentIdx
              ENDDO !gaussPointIdx
            ENDDO !dofIdx (global)
            !Loop over the domain types. Here domainTypeIdx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
            DO domainTypeIdx=1,domainTypeStop
              IF(domainTypeIdx==1) THEN
                startIdx=1
                stopIdx=dofsMapping%numberOfLocal
              ELSE
                startIdx=dofsMapping%numberOfLocal+1
                stopIdx=dofsMapping%totalNumberOfLocal
              ENDIF
              !Handle local dofs domain mapping
              elementDOF=0
              DO dofIdx=startIdx,stopIdx
                DO gaussPointIdx=1,maxNumberOfGauss
                  DO componentIdx=1,fieldVariable%numberOfComponents
                    fieldComponent=>fieldVariable%components(componentIdx)
                    NULLIFY(domain)
                    CALL FieldVariable_ComponentDomainGet(fieldVariable,componentIdx,domain,err,error,*999)
                    elementDOF=elementDOF+1                      
                    variableLocalDOFIdx=elementDOF+variableLocalDOFSOffsets(myGroupComputationNodeNumber)
                    nodeDOFIdx=nodeDOFIdx+1
                    !Setup dof to parameter map
                    fieldVariable%dofToParamMap%DOFType(1,variableLocalDOFIdx)=FIELD_GAUSS_POINT_DOF_TYPE
                    fieldVariable%dofToParamMap%DOFType(2,variableLocalDOFIdx)=nodeDOFIdx
                    fieldVariable%dofToParamMap%gaussPointDOF2ParamMap(1,nodeDOFIdx)=gaussPointIdx
                    fieldVariable%dofToParamMap%gaussPointDOF2ParamMap(2,nodeDOFIdx)=dofIdx !elementIdx
                    fieldVariable%dofToParamMap%gaussPointDOF2ParamMap(3,nodeDOFIdx)=componentIdx
                    !Setup reverse parameter to dof map
                    fieldComponent%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gaussPointIdx,dofIdx)= &
                      & variableLocalDOFIdx
                  ENDDO !componentIdx
                ENDDO !gaussPointIdx
              ENDDO !dofIdx
              !Adjust the offsets
              variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)= &
                & variableLocalDOFSOffsets(0:numberOfGroupComputationNodes-1)+ &
                & fieldVariable%numberOfComponents* &
                & dofsMapping%numberOfDomainLocal*maxNumberOfGauss
              IF(domainTypeIdx==1) THEN
                variableGlobalDOFSOffset=variableGlobalDOFSOffset+fieldVariable%numberOfComponents* &
                  & dofsMapping%numberOfGlobal*maxNumberOfGauss
              ENDIF
            ENDDO !domainTypeIdx
          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The interpolation type of "// &
              & TRIM(NumberToVString(fieldVariable%components(componentIdx)%interpolationType, &
              & "*",err,error))//" is invalid for component number 1 of variable type "//TRIM(NumberToVString( &
              & fieldVariable%variableType,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("The field must have at least one component.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The DOF order type of "//TRIM(NumberToVString(fieldVariable%dofOrderType, &
          & "*",err,error))//" is invalid for variable type "//TRIM(NumberToVString(fieldVariable% &
          & variableType,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END SELECT
      IF(ASSOCIATED(fieldVariableDOFSMapping)) THEN
        CALL DomainMapping_LocalFromGlobalCalculate(fieldVariableDOFSMapping,err,error,*999)
      ENDIF
    ENDDO !variableIdx
    IF(ALLOCATED(variableLocalDOFSOffsets)) DEALLOCATE(variableLocalDOFSOffsets)
    IF(ALLOCATED(variableGhostDOFSOffsets)) DEALLOCATE(variableGhostDOFSOffsets)

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Field DOF mappings:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field user number = ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of variables = ",field%numberOfVariables,err,error,*999)
      DO variableIdx=1,field%numberOfVariables
        NULLIFY(fieldVariable)
        CALL Field_VariableIndexGet(field,variableIdx,fieldVariable,variableType,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Variable : ",variableIdx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Variable type = ",variableType,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Number of local DOFs = ",fieldVariable% &
          & numberOfDofs,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Total number of local DOFs = ",fieldVariable% &
          & totalNumberOfDofs,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Number of global DOFs = ",fieldVariable% &
          & numberOfGlobalDofs,err,error,*999)
        CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"    DOF to parameter map:",err,error,*999)
        DO variableLocalDOFIdx=1,fieldVariable%totalNumberOfDofs
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      DOF : ",variableLocalDOFIdx,err,error,*999)
          CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,fieldVariable%dofToParamMap% &
            & DOFType(:,variableLocalDOFIdx),'("        DOF type :",2(X,I8))','(18X,2(X,I8))',err,error,*999)
        ENDDO !variableLocalDOFIdx
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of constant DOFs = ",fieldVariable% &
          & dofToParamMap%numberOfConstantDOFs,err,error,*999)
        IF(fieldVariable%dofToParamMap%numberOfConstantDOFs>0) THEN
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Constant DOFs:",err,error,*999)
          DO constantDOFIdx=1,fieldVariable%dofToParamMap%numberOfConstantDOFs
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Constant DOF : ",constantDOFIdx,err,error,*999)
            CALL WriteStringFmtValue(DIAGNOSTIC_OUTPUT_TYPE,"          DOF 2 Parameters : ", &
              & fieldVariable%dofToParamMap%constantDOF2ParamMap(constantDOFIdx),'(I8)',err,error,*999)
          ENDDO !constantDOFIdx
        ENDIF
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of element DOFs = ",fieldVariable% &
          & dofToParamMap%numberOfElementDOFs,err,error,*999)
        IF(fieldVariable%dofToParamMap%numberOfElementDOFs>0) THEN            
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Element DOFs:",err,error,*999)
          DO elementDOFIdx=1,fieldVariable%dofToParamMap%numberOfElementDOFs
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Element DOF : ",elementDOFIdx,err,error,*999)
            CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,fieldVariable%dofToParamMap% &
              & elementDOF2ParamMap(:,elementDOFIdx),'("          DOF 2 Parameters :",2(X,I8))','(28X,2(X,I8))',err,error,*999)
          ENDDO !elementDOFIdx
        ENDIF
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of nodal DOFs = ",fieldVariable% &
          & dofToParamMap%numberOfNodeDOFs,err,error,*999)
        IF(fieldVariable%dofToParamMap%numberOfNodeDOFs>0) THEN
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Nodal DOFs:",err,error,*999)
          DO nodeDOFIdx=1,fieldVariable%dofToParamMap%numberOfNodeDOFs
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Node DOF : ",nodeDOFIdx,err,error,*999)
            CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,4,4,4,fieldVariable%dofToParamMap% &
              & nodeDOF2ParamMap(:,nodeDOFIdx),'("          DOF 2 Parameters :",4(X,I8))','(28X,4(X,I8))',err,error,*999)
          ENDDO !nodeDOFIdx
        ENDIF
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of grid point DOFs = ",fieldVariable% &
          & dofToParamMap%numberOfGridPointDOFs,err,error,*999)
        IF(fieldVariable%dofToParamMap%numberOfGridPointDOFs>0) THEN
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Grid point DOFs:",err,error,*999)
          DO gridPointDOFIdx=1,fieldVariable%dofToParamMap%numberOfGridPointDOFs
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Grid point DOF : ",gridPointDOFIdx,err,error,*999)
            CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,fieldVariable%dofToParamMap% &
              & gridPointDOF2ParamMap(:,gridPointDOFIdx),'("          DOF 2 Parameters :",2(X,I8))','(28X,2(X,I8))', &
              & err,error,*999)
          ENDDO !nodeDOFIdx
        ENDIF
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of Gauss point DOFs = ",fieldVariable% &
          & dofToParamMap%numberOfGaussPointDOFs,err,error,*999)
        IF(fieldVariable%dofToParamMap%numberOfGaussPointDOFs>0) THEN
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Gauss point DOFs:",err,error,*999)
          DO gaussPointDOFIdx=1,fieldVariable%dofToParamMap%numberOfGaussPointDOFs
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Gauss point DOF : ",gaussPointDOFIdx,err,error,*999)
            CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,3,3,fieldVariable%dofToParamMap% &
              & gaussPointDOF2ParamMap(:,gaussPointDOFIdx),'("          DOF 2 Parameters :",3(X,I8))','(28X,3(X,I8))', &
              & err,error,*999)
          ENDDO !nodeDOFIdx
        ENDIF
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of data point DOFs = ",fieldVariable% &
          & dofToParamMap%numberOfDataPointDOFs,err,error,*999)
        IF(fieldVariable%dofToParamMap%numberOfDataPointDOFs>0) THEN
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      data point DOFs:",err,error,*999)
          DO dataPointDOFIdx=1,fieldVariable%dofToParamMap%numberOfDataPointDOFs
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        data point DOF : ",dataPointDOFIdx,err,error,*999)
            CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,3,3,fieldVariable%dofToParamMap% &
              & dataPointDOF2ParamMap(:,dataPointDOFIdx),'("          DOF 2 Parameters :",3(X,I8))','(28X,3(X,I8))', &
              & err,error,*999)
          ENDDO !nodeDOFIdx
        ENDIF
        CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"    Parameter to DOF map:",err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of components = ",fieldVariable% &
          & numberOfComponents,err,error,*999)
        DO componentIdx=1,fieldVariable%numberOfComponents
          fieldComponent => fieldVariable%components(componentIdx)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Component : ",componentIdx,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of constant parameters = ", &
            & fieldComponent%paramToDOFMap%numberOfConstantParameters,err,error,*999)
          IF(fieldComponent%paramToDOFMap%numberOfConstantParameters>0) THEN
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Constant DOF = ", &
              & fieldComponent%paramToDOFMap%constantParam2DOFMap,err,error,*999)
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of element parameters = ", &
            & fieldComponent%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters,err,error,*999)
          IF(fieldComponent%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters>0) THEN
            DO elementIdx=1,fieldComponent%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Element : ",elementIdx,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"            Element DOF = ", &
                & fieldComponent%paramToDOFMap%elementParam2DOFMap%ELEMENTS(elementIdx), &
                & err,error,*999)
            ENDDO !elementIdx
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of node parameters = ", &
            & fieldComponent%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters,err,error,*999)
          IF(fieldComponent%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters>0) THEN
            DO nodeIdx=1,fieldComponent%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Node : ",nodeIdx,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Number of Derivatives = ", &
                & fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%numberOfDerivatives,err,error,*999)
              DO derivativeIdx=1,fieldComponent%paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%numberOfDerivatives
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Derivative : ",derivativeIdx,err,error,*999)
                CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,fieldComponent%paramToDOFMap% &
                  & nodeParam2DOFMap%nodes(nodeIdx)%DERIVATIVES(derivativeIdx)%numberOfVersions,8,8,fieldComponent% &
                  & paramToDOFMap%nodeParam2DOFMap%nodes(nodeIdx)%DERIVATIVES(derivativeIdx)%VERSIONS(:), &
                  & '("              Version DOFs :",8(X,I8))','(23X,8(X,I8))',err,error,*999)
              ENDDO !derivativeIdx
            ENDDO !nodeIdx
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of grid point parameters = ", &
            & fieldComponent%paramToDOFMap%gridPointParam2DOFMap%numberOfGridPointParameters,err,error,*999)
          IF(fieldComponent%paramToDOFMap%gridPointParam2DOFMap%numberOfGridPointParameters>0) THEN
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of Gauss point parameters = ", &
            & fieldComponent%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters,err,error,*999)
          IF(fieldComponent%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters>0) THEN
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of data point parameters = ", &
            & fieldComponent%paramToDOFMap%dataPointParam2DOFMap%numberOfDataPointParameters,err,error,*999)
          IF(fieldComponent%paramToDOFMap%dataPointParam2DOFMap%numberOfDataPointParameters>0) THEN
          ENDIF
        ENDDO !componentIdx
      ENDDO !variableIdx
    ENDIF

    EXITS("Field_MappingsCalculate")
    RETURN
999 IF(ALLOCATED(variableLocalDOFSOffsets)) DEALLOCATE(variableLocalDOFSOffsets)
    IF(ALLOCATED(variableGhostDOFSOffsets)) DEALLOCATE(variableGhostDOFSOffsets)
    ERRORSEXITS("Field_MappingsCalculate",err,error)
    RETURN 1
    
  END SUBROUTINE Field_MappingsCalculate

  !
  !================================================================================================================================
  !

  !>Finalises the dofs to parameters mapping for a field varaible and deallocates all memory.
  SUBROUTINE Field_DofToParamMapFinalise(dofToParamMap,err,error,*)

    !Argument variables
    TYPE(FieldDOFToParamMapType) :: dofToParamMap !<The dof to parameter map to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_DofToParamMapFinalise",err,error,*999)

    IF(ALLOCATED(dofToParamMap%DOFType)) DEALLOCATE(dofToParamMap%DOFType)
    IF(ALLOCATED(dofToParamMap%constantDOF2ParamMap)) DEALLOCATE(dofToParamMap%constantDOF2ParamMap)
    IF(ALLOCATED(dofToParamMap%elementDOF2ParamMap)) DEALLOCATE(dofToParamMap%elementDOF2ParamMap)
    IF(ALLOCATED(dofToParamMap%nodeDOF2ParamMap)) DEALLOCATE(dofToParamMap%nodeDOF2ParamMap)
    IF(ALLOCATED(dofToParamMap%gridPointDOF2ParamMap)) DEALLOCATE(dofToParamMap%gridPointDOF2ParamMap)
    IF(ALLOCATED(dofToParamMap%gaussPointDOF2ParamMap)) DEALLOCATE(dofToParamMap%gaussPointDOF2ParamMap)
    IF(ALLOCATED(dofToParamMap%dataPointDOF2ParamMap)) DEALLOCATE(dofToParamMap%dataPointDOF2ParamMap)
    dofToParamMap%numberOfDofs=0
    dofToParamMap%numberOfConstantDOFs=0
    dofToParamMap%numberOfElementDOFs=0
    dofToParamMap%numberOfNodeDOFs=0
    dofToParamMap%numberOfGridPointDOFs=0
    dofToParamMap%numberOfGaussPointDOFs=0
    dofToParamMap%numberOfDataPointDOFs=0

    EXITS("Field_DofToParamMapFinalise")
    RETURN
999 ERRORSEXITS("Field_DofToParamMapFinalise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_DofToParamMapFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the dofs to parameters mappings for a field.
  SUBROUTINE Field_DofToParamMapInitialise(dofToParamMap,err,error,*)

    !Argument variables
    TYPE(FieldDOFToParamMapType) :: dofToParamMap !<The dof to parameter map to initialise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_DofToParamMapInitialise",err,error,*999)

    dofToParamMap%numberOfDofs=0
    dofToParamMap%numberOfConstantDOFs=0
    dofToParamMap%numberOfElementDOFs=0
    dofToParamMap%numberOfNodeDOFs=0
    dofToParamMap%numberOfGridPointDOFs=0
    dofToParamMap%numberOfGaussPointDOFs=0
    dofToParamMap%numberOfDataPointDOFs=0

    EXITS("Field_DofToParamMapInitialise")
    RETURN
999 ERRORSEXITS("Field_DofToParamMapInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_DofToParamMapInitialise

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for character labels. \see OpenCMISS::Iron::cmfe_Field_LabelSet
  SUBROUTINE Field_LabelSetC(field,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the type for
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_LabelSetC",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%labelLocked) THEN
      localError="The field label has been locked for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    field%label=label

    EXITS("Field_LabelSetC")
    RETURN
999 ERRORSEXITS("Field_LabelSetC",err,error)
    RETURN 1

  END SUBROUTINE Field_LabelSetC

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for varying string labels. \see OpenCMISS::Iron::cmfe_Field_LabelSet
  SUBROUTINE Field_LabelSetVS(field,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the type for
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_LabelSetVS",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%labelLocked) THEN
      localError="The field label has been locked for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    field%label=label

    EXITS("Field_LabelSetVS")
    RETURN
999 ERRORSEXITS("Field_LabelSetVS",err,error)
    RETURN 1

  END SUBROUTINE Field_LabelSetVS

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for character labels and locks it so that no further changes can be made.
  SUBROUTINE Field_LabelSetAndLockC(field,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the type for
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_LabelSetAndLockC",err,error,*999)

    CALL Field_LabelSet(field,label,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%labelLocked=.TRUE.

    EXITS("Field_LabelSetAndLockC")
    RETURN
999 ERRORSEXITS("Field_LabelSetAndLockC",err,error)
    RETURN 1

  END SUBROUTINE Field_LabelSetAndLockC

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for varying string labels and locks it so that no further changes can be made.
  SUBROUTINE Field_LabelSetAndLockVS(field,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the type for
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_LabelSetAndLockVS",err,error,*999)

    CALL Field_LabelSet(field,label,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%labelLocked=.TRUE.

    EXITS("Field_LabelSetAndLockVS")
    RETURN
999 ERRORSEXITS("Field_LabelSetAndLockVS",err,error)
    RETURN 1

  END SUBROUTINE Field_LabelSetAndLockVS

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of field components for a field variable. \see OpenCMISS::Iron::cmfe_Field_NumberOfComponentsSet
  SUBROUTINE Field_NumberOfComponentsSet(field,variableType,numberOfComponents,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the number of components
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components to be set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,newNumberOfComponents,oldNumberOfComponents,overlapNumberOfComponents,variableIdx
    INTEGER(INTG), ALLOCATABLE :: newInterpolationType(:,:),newMeshComponentNumber(:,:)
    LOGICAL, ALLOCATABLE ::newComponentLabelsLocked(:,:), newInterpolationTypeLocked(:,:), &
      & newMeshComponentNumberLocked(:,:)
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError
    TYPE(VARYING_STRING), ALLOCATABLE :: newComponentLabels(:,:)

    ENTERS("Field_NumberOfComponentsSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)

    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " is invalid. The variable type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ANY(createValuesCache%variableTypes==variableType)) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " has not been created on field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)      
    ENDIF
    IF(createValuesCache%numberOfComponentsLocked(variableType)) THEN
      localError="The number of components has been locked for variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    SELECT CASE(createValuesCache%dimension(variableType))
    CASE(FIELD_SCALAR_DIMENSION_TYPE)
      IF(numberOfComponents/=1) THEN
        localError="Scalar fields cannot have "//TRIM(NumberToVString(numberOfComponents,"*",err,error))// &
          & " components."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_VECTOR_DIMENSION_TYPE)
      IF(numberOfComponents<=0) THEN
        localError="Vector fields cannot have "//TRIM(NumberToVString(numberOfComponents,"*",err,error))// &
          & " components."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      IF(createValuesCache%numberOfComponents(variableType)/=numberOfComponents) THEN
        oldNumberOfComponents=MAXVAL(createValuesCache%numberOfComponents)
        newNumberOfComponents=numberOfComponents
        DO variableIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          IF(createValuesCache%numberOfComponents(variableIdx) > newNumberOfComponents) THEN 
            IF(variableIdx /= variableType) newNumberOfComponents=createValuesCache%numberOfComponents(variableIdx)
          ENDIF
        ENDDO !variableIdx
        overlapNumberOfComponents=MIN(oldNumberOfComponents,newNumberOfComponents)
        ALLOCATE(newComponentLabels(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new component labels.",err,error,*999)
        ALLOCATE(newComponentLabelsLocked(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new component labels locked.",err,error,*999)
        ALLOCATE(newInterpolationType(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new interpolation type.",err,error,*999)
        ALLOCATE(newInterpolationTypeLocked(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new interpolation type locked.",err,error,*999)
        ALLOCATE(newMeshComponentNumber(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new mesh component number.",err,error,*999)
        ALLOCATE(newMeshComponentNumberLocked(newNumberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new mesh component number locked.",err,error,*999)

        newComponentLabels=''
        newComponentLabelsLocked=.FALSE.
        newInterpolationType=0
        newInterpolationTypeLocked=.FALSE.
        newMeshComponentNumber=0                   
        newMeshComponentNumberLocked=.FALSE.
        newComponentLabels(1:overlapNumberOfComponents,:) = &
          & createValuesCache%componentLabels(1:overlapNumberOfComponents,:)
        newComponentLabelsLocked(1:overlapNumberOfComponents,:) = &
          & createValuesCache%componentLabelsLocked(1:overlapNumberOfComponents,:)
        newInterpolationType(1:overlapNumberOfComponents,:) = &
          & createValuesCache%interpolationTypes(1:overlapNumberOfComponents,:)
        newInterpolationTypeLocked(1:overlapNumberOfComponents,:) = &
          & createValuesCache%interpolationTypesLocked(1:overlapNumberOfComponents,:)
        newMeshComponentNumber(1:overlapNumberOfComponents,:) = &
          & createValuesCache%meshComponentNumber(1:overlapNumberOfComponents,:)
        newMeshComponentNumberLocked(1:overlapNumberOfComponents,:) = &
          & createValuesCache%meshComponentNumberLocked(1:overlapNumberOfComponents,:)
        !Update remaining terms
        IF(oldNumberOfComponents<numberOfComponents) THEN
          DO variableIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
            DO componentIdx=oldNumberOfComponents+1,numberOfComponents
              newComponentLabels(componentIdx,variableIdx)= &
                & TRIM(NumberToVString(componentIdx,"*",err,error))
              IF(err/=0) GOTO 999
            ENDDO !componentIdx
            newInterpolationType(oldNumberOfComponents+1:numberOfComponents,variableIdx) = &
              & createValuesCache%interpolationTypes(1,variableIdx)
            newMeshComponentNumber(oldNumberOfComponents+1:numberOfComponents,variableIdx) = &
              & createValuesCache%meshComponentNumber(1,variableIdx)
          ENDDO !variableIdx
        ENDIF

        CALL MOVE_ALLOC(newComponentLabels,createValuesCache%componentLabels)
        CALL MOVE_ALLOC(newComponentLabelsLocked,createValuesCache%componentLabelsLocked)
        CALL MOVE_ALLOC(newInterpolationType,createValuesCache%interpolationTypes)
        CALL MOVE_ALLOC(newInterpolationTypeLocked,createValuesCache%interpolationTypesLocked)
        CALL MOVE_ALLOC(newMeshComponentNumber,createValuesCache%meshComponentNumber)
        CALL MOVE_ALLOC(newMeshComponentNumberLocked,createValuesCache%meshComponentNumberLocked)

        createValuesCache%numberOfComponents(variableType)=numberOfComponents
      ENDIF
    CASE(FIELD_TENSOR_DIMENSION_TYPE)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="Field dimension "//TRIM(NumberToVString(createValuesCache%dimension(variableType),"*",err,error))// &
        & " is not valid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_NumberOfComponentsSet")
    RETURN
999 IF(ALLOCATED(newComponentLabels)) DEALLOCATE(newComponentLabels)
    IF(ALLOCATED(newComponentLabelsLocked)) DEALLOCATE(newComponentLabelsLocked)
    IF(ALLOCATED(newInterpolationType)) DEALLOCATE(newInterpolationType)
    IF(ALLOCATED(newInterpolationTypeLocked)) DEALLOCATE(newInterpolationTypeLocked)
    IF(ALLOCATED(newMeshComponentNumber)) DEALLOCATE(newMeshComponentNumber)
    IF(ALLOCATED(newMeshComponentNumberLocked)) DEALLOCATE(newMeshComponentNumberLocked)
    ERRORSEXITS("Field_NumberOfComponentsSet",err,error)
    RETURN 1

  END SUBROUTINE Field_NumberOfComponentsSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of field components for a field variable and locks so that no further changes can be made.
  SUBROUTINE Field_NumberOfComponentsSetAndLock(field,variableType,numberOfComponents,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the number of components
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components to be set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_NumberOfComponentsSetAndLock",err,error,*999)

    CALL Field_NumberOfComponentsSet(field,variableType,numberOfComponents,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%numberOfComponentsLocked(variableType)=.TRUE.

    EXITS("Field_NumberOfComponentsSetAndLock")
    RETURN
999 ERRORSEXITS("Field_NumberOfComponentsSetAndLock",err,error)
    RETURN 1

  END SUBROUTINE Field_NumberOfComponentsSetAndLock

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field. \see OpenCMISS::Iron::cmfe_Field_NumberOfVariablesSet
  SUBROUTINE Field_NumberOfVariablesSet(field,numberOfVariables,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the number of variables for
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables to set for the field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableIdx,variableIdx2,variableTypeIdx
    INTEGER(INTG), ALLOCATABLE :: oldVariableTypes(:)
    LOGICAL :: found
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_NumberOfVariablesSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%numberOfVariablesLocked) THEN
      localError="The number of variables has been locked field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(numberOfVariables<1.OR.numberOfVariables>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The specified number of variables of "//TRIM(NumberToVString(numberOfVariables,"*",err,error))// &
        & " is invalid. The number of variables must be >= 1 and <= "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    IF(field%numberOfVariables/=numberOfVariables) THEN
      ALLOCATE(oldVariableTypes(field%numberOfVariables),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate old variable types.",err,error,*999)
      oldVariableTypes(1:field%numberOfVariables)=createValuesCache%variableTypes(1:field%numberOfVariables)
      DEALLOCATE(createValuesCache%variableTypes)
      ALLOCATE(createValuesCache%variableTypes(numberOfVariables),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate variable types.",err,error,*999)
      createValuesCache%variableTypes=0
      IF(numberOfVariables<field%numberOfVariables) THEN
        createValuesCache%variableTypes(1:numberOfVariables)=oldVariableTypes(1:numberOfVariables)
        DO variableIdx=numberOfVariables+1,field%numberOfVariables
          variableTypeIdx=oldVariableTypes(variableIdx)
          createValuesCache%variableLabels(variableTypeIdx)=""
          createValuesCache%variableLabelsLocked(variableTypeIdx)=.FALSE.
          createValuesCache%dimension(variableTypeIdx)=0
          createValuesCache%dimensionLocked(variableTypeIdx)=.FALSE.
          createValuesCache%dataTypes(variableTypeIdx)=0
          createValuesCache%dataTypesLocked(variableTypeIdx)=.FALSE.
          createValuesCache%dofOrderTypes(variableTypeIdx)=0
          createValuesCache%dofOrderTypesLocked(variableTypeIdx)=.FALSE.
          createValuesCache%numberOfComponents(variableTypeIdx)=0
          createValuesCache%numberOfComponentsLocked(variableTypeIdx)=.FALSE.
          createValuesCache%interpolationTypes(:,variableTypeIdx)=0
          createValuesCache%interpolationTypesLocked(:,variableTypeIdx)=.FALSE.
          createValuesCache%meshComponentNumber(:,variableTypeIdx)=0
          createValuesCache%meshComponentNumberLocked(:,variableTypeIdx)=.FALSE.
        ENDDO !variableIdx
      ELSE
        createValuesCache%variableTypes(1:field%numberOfVariables)=oldVariableTypes(1:field%numberOfVariables)
        DO variableIdx=field%numberOfVariables+1,numberOfVariables
          !Find the next available variable type
          DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
            found=.FALSE.
            DO variableIdx2=1,field%numberOfVariables
              IF(createValuesCache%variableTypes(variableIdx2)==variableTypeIdx) THEN
                found=.TRUE.
                EXIT
              ENDIF
            ENDDO !variableIdx2
            IF(.NOT.found) EXIT
          ENDDO !variableTypeIdx
          IF(found) THEN
            CALL FlagError("Could not find free variable type???",err,error,*999)
          ELSE
            createValuesCache%variableTypes(variableIdx)=variableTypeIdx
            SELECT CASE(variableTypeIdx)
            CASE(FIELD_U_VARIABLE_TYPE)
              createValuesCache%variableLabels(variableTypeIdx)="U"
            CASE(FIELD_DELUDELN_VARIABLE_TYPE)
              createValuesCache%variableLabels(variableTypeIdx)="del U/del n"
            CASE(FIELD_DELUDELT_VARIABLE_TYPE)
              createValuesCache%variableLabels(variableTypeIdx)="del U/del t"
            CASE(FIELD_DEL2UDELT2_VARIABLE_TYPE)
              createValuesCache%variableLabels(variableTypeIdx)="del^2 U/del t^2"
            CASE(FIELD_V_VARIABLE_TYPE)
              createValuesCache%variableLabels(variableTypeIdx)="V"
            CASE(FIELD_DELVDELN_VARIABLE_TYPE)
              createValuesCache%variableLabels(variableTypeIdx)="del V/del n"
            CASE DEFAULT
              localError="The variable type of "//TRIM(NumberToVString(variableTypeIdx,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            createValuesCache%variableLabelsLocked(variableTypeIdx)=.FALSE.
            createValuesCache%dimension(variableTypeIdx)=createValuesCache%dimension(oldVariableTypes(1))
            createValuesCache%dimensionLocked(variableTypeIdx)=.FALSE.
            createValuesCache%dataTypes(variableTypeIdx)=createValuesCache%dataTypes(oldVariableTypes(1))
            createValuesCache%dataTypesLocked(variableTypeIdx)=.FALSE.
            createValuesCache%dofOrderTypes(variableTypeIdx)=createValuesCache%dofOrderTypes(oldVariableTypes(1))
            createValuesCache%dofOrderTypesLocked(variableTypeIdx)=.FALSE.
            createValuesCache%numberOfComponents(variableTypeIdx)=createValuesCache%numberOfComponents(oldVariableTypes(1))
            createValuesCache%numberOfComponentsLocked(variableTypeIdx)=.FALSE.
            createValuesCache%componentLabels(:,variableTypeIdx)=createValuesCache%componentLabels(:,createValuesCache% &
              & variableTypes(oldVariableTypes(1)))
            createValuesCache%componentLabelsLocked(:,variableTypeIdx)=.FALSE.
            createValuesCache%interpolationTypes(:,variableTypeIdx)=createValuesCache%interpolationTypes(:,createValuesCache% &
              & variableTypes(oldVariableTypes(1)))
            createValuesCache%interpolationTypesLocked(:,variableTypeIdx)=.FALSE.
            createValuesCache%meshComponentNumber(:,variableTypeIdx)=createValuesCache%meshComponentNumber(:,createValuesCache% &
              & variableTypes(oldVariableTypes(1)))
            createValuesCache%meshComponentNumberLocked(:,variableTypeIdx)=.FALSE.
          ENDIF
        ENDDO !variableIdx
      ENDIF
      DEALLOCATE(oldVariableTypes)
      field%numberOfVariables=numberOfVariables
    ENDIF

    EXITS("Field_NumberOfVariablesSet")
    RETURN
999 IF(ALLOCATED(oldVariableTypes)) DEALLOCATE(oldVariableTypes)
    ERRORSEXITS("Field_NumberOfVariablesSet",err,error)
    RETURN 1

  END SUBROUTINE Field_NumberOfVariablesSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field and locks so that no further changes can be made.
  SUBROUTINE Field_NumberOfVariablesSetAndLock(field,numberOfVariables,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the number of variables for
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables to set for the field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_NumberOfVariablesSetAndLock",err,error,*999)

    CALL Field_NumberOfVariablesSet(field,numberOfVariables,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    createValuesCache%numberOfVariablesLocked=.TRUE.

    EXITS("Field_NumberOfVariablesSetAndLock")
    RETURN
999 ERRORSEXITS("Field_NumberOfVariablesSetAndLock",err,error)
    RETURN 1

  END SUBROUTINE Field_NumberOfVariablesSetAndLock

  !
  !================================================================================================================================
  !

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type \todo make this call distributed vector add???
  SUBROUTINE Field_ParameterSetsAddDP0(field,variableType,alpha,fieldFromSetType,fieldToSetType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add the parameter sets for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FIELD_ROUTINE
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the add.
    INTEGER(INTG), INTENT(IN) :: fieldFromSetType !<The field parameter set identifier to add the parameters from \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldToSetType !<The field parameter set identifier to add the parameters to \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_ParameterSetsAddDP0",err,error,*999)

    CALL Field_ParameterSetsAddDP1(field,variableType,[alpha],[fieldFromSetType],fieldToSetType,err,error,*999)

    EXITS("Field_ParameterSetsAddDP0")
    RETURN
999 ERRORSEXITS("Field_ParameterSetsAddDP0",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ParameterSetsAddDP0

  !
  !================================================================================================================================
  !

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type \todo make this call distributed vector add??? 
  SUBROUTINE Field_ParameterSetsAddDP1(field,variableType,alphas,fieldFromSetTypes,fieldToSetType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add the parameter sets for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see \see FieldRoutines_VariableTypes,FieldRoutines
    REAL(DP), INTENT(IN) :: alphas(:) !<The multiplicative factor for the add.
    INTEGER(INTG), INTENT(IN) :: fieldFromSetTypes(:) !<The field parameter set identifier to add the parameters from \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldToSetType !<The field parameter set identifier to add the parameters to \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetsAddDP1",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetsAdd(fieldVariable,alphas,fieldFromSetTypes,fieldToSetType,err,error,*999)
    
    EXITS("Field_ParameterSetsAddDP1")
    RETURN
999 ERRORSEXITS("Field_ParameterSetsAddDP1",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetsAddDP1

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type for a field
  SUBROUTINE Field_ParameterSetsCopy(field,variableType,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to copy \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetsCopy",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetsCopy(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*999)

    EXITS("Field_ParameterSetsCopy")
    RETURN
999 ERRORSEXITS("Field_ParameterSetsCopy",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetsCopy

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type if they exist for a field
  SUBROUTINE Field_ParameterSetsCopyIfExists(field,variableType,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to copy \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetsCopyIfExists",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetsCopyIfExists(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*999)

    EXITS("Field_ParameterSetsCopyIfExists")
    RETURN
999 ERRORSEXITS("Field_ParameterSetsCopyIfExists",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetsCopyIfExists

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable.
  SUBROUTINE Field_ParametersToFieldParametersCopy(fromField,fromVariableType,fromParameterSetType, &
    & fromComponentNumber,toField,toVariableType,toParameterSetType,toComponentNumber,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: fromField !<A pointer to the field to copy from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    TYPE(FieldType), POINTER :: toField !<A pointer to the field to copy to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fromFieldVariable,toFieldVariable
 
    ENTERS("Field_ParametersToFieldParametersCopy",err,error,*999)

    CALL Field_AssertIsFinished(fromField,err,error,*999)
    CALL Field_AssertIsFinished(toField,err,error,*999)
    NULLIFY(fromFieldVariable)
    CALL Field_VariableGet(fromField,fromVariableTYpe,fromFieldVariable,err,error,*999)
    NULLIFY(toFieldVariable)
    CALL Field_VariableGet(toField,toVariableType,toFieldVariable,err,error,*999)

    CALL FieldVariable_ParametersToFieldVariableParametersCopy(fromFieldVariable,fromParameterSetType, &
      & fromComponentNumber,toFieldVariable,toParameterSetType,toComponentNumber,err,error,*999)
    
    EXITS("Field_ParametersToFieldParametersCopy")
    RETURN
999 ERRORSEXITS("Field_ParametersToFieldParametersCopy",err,error)
    RETURN 1

  END SUBROUTINE Field_ParametersToFieldParametersCopy

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddConstant
  SUBROUTINE Field_ParameterSetAddConstantIntg(field,variableType,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddConstantIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddConstant(fieldVariable,fieldSetType,componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetAddConstantIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddConstantIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddConstantIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddConstant
  SUBROUTINE Field_ParameterSetAddConstantSP(field,variableType,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddConstantSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddConstant(fieldVariable,fieldSetType,componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetAddConstantSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddConstantSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddConstantSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddConstant
  SUBROUTINE Field_ParameterSetAddConstantDP(field,variableType,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddConstantDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddConstant(fieldVariable,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddConstantDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddConstantDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddConstantDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddConstant
  SUBROUTINE Field_ParameterSetAddConstantL(field,variableType,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddConstantL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddConstant(fieldVariable,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddConstantL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddConstantL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddConstantL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE Field_ParameterSetAddLocalDOFIntg(field,variableType,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetAddLocalDOFIntg",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalDOF(fieldVariable,fieldSetType,dofNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetAddLocalDOFIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalDOFIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalDOFIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE Field_ParameterSetAddLocalDOFSP(field,variableType,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetAddLocalDOFSP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalDOF(fieldVariable,fieldSetType,dofNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddLocalDOFSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalDOFSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalDOFSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE Field_ParameterSetAddLocalDOFDP(field,variableType,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddLocalDOFDP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalDOF(fieldVariable,fieldSetType,dofNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddLocalDOFDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalDOFDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalDOFDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE Field_ParameterSetAddLocalDOFL(field,variableType,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddLocalDOFL",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalDOF(fieldVariable,fieldSetType,dofNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddLocalDOFL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalDOFL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalDOFL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular user element of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddElement
  SUBROUTINE Field_ParameterSetAddElementIntg(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddElementIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddElementIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddElementIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddElementIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular user element of the field variable component.\see OpenCMISS::Iron::cmfe_Field_ParameterSetAddElement 
  SUBROUTINE Field_ParameterSetAddElementSP(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddElementSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddElementSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddElementSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddElementSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular user element of the field variable component.\see OpenCMISS::Iron::cmfe_Field_ParameterSetAddElement 
  SUBROUTINE Field_ParameterSetAddElementDP(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddElementDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddElementDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddElementDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddElementDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular user element of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddElement
  SUBROUTINE Field_ParameterSetAddElementL(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetAddElementL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddElementL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddElementL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddElementL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointIntg(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddGaussPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddGaussPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointSP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetAddGaussPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddGaussPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddGaussPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetAddGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointL(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddGaussPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddGaussPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE Field_ParameterSetAddLocalElementIntg(field,variableType,fieldSetType,localNumberElement,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddLocalElementIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalElement(fieldVariable,fieldSetType,localNumberElement,componentNumber, &
      & value,err,error,*999)

    EXITS("Field_ParameterSetAddLocalElementIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalElementIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalElementIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE Field_ParameterSetAddLocalElementSP(field,variableType,fieldSetType,localNumberElement,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddLocalElementSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalElement(fieldVariable,fieldSetType,localNumberElement,componentNumber, &
      & value,err,error,*999)
 
    EXITS("Field_ParameterSetAddLocalElementSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalElementSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalElementSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE Field_ParameterSetAddLocalElementDP(field,variableType,fieldSetType,localNumberElement,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddLocalElementDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalElement(fieldVariable,fieldSetType,localNumberElement,componentNumber, &
      & value,err,error,*999)

    EXITS("Field_ParameterSetAddLocalElementDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalElementDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalElementDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE Field_ParameterSetAddLocalElementL(field,variableType,fieldSetType,localNumberElement,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddLocalElementL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalElement(fieldVariable,fieldSetType,localNumberElement,componentNumber, &
      & value,err,error,*999)

    EXITS("Field_ParameterSetAddLocalElementL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalElementL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalElementL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddNode
  SUBROUTINE Field_ParameterSetAddNodeIntg(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddNodeIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddNodeIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddNodeIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddNode
  SUBROUTINE Field_ParameterSetAddNodeSP(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddNodeSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddNodeSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddNodeSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddNodeSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddNode
  SUBROUTINE Field_ParameterSetAddNodeDP(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetAddNodeDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetAddNodeDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddNodeDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddNodeDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddNode
  SUBROUTINE Field_ParameterSetAddNodeL(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetAddNodeL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddNodeL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddNodeL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddNodeL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE Field_ParameterSetAddLocalNodeIntg(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddLocalNodeIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & localNodeNumber,componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetAddLocalNodeIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalNodeIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE Field_ParameterSetAddLocalNodeSP(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddLocalNodeSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & localNodeNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddLocalNodeSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalNodeSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalNodeSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE Field_ParameterSetAddLocalNodeDP(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddLocalNodeDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & localNodeNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddLocalNodeDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalNodeDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalNodeDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE Field_ParameterSetAddLocalNodeL(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetAddLocalNodeL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetAddLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & localNodeNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetAddLocalNodeL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddLocalNodeL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddLocalNodeL

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable. If the field parameter set has already been
  !>created then an error will be raised. \see OpenCMISS::Iron::cmfe_Field_ParameterSetCreate
  SUBROUTINE Field_ParameterSetCreate(field,variableType,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to create the parameter set for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The variable type to create the parameter set for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetCreate",err,error,*999)

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetCreate(fieldVariable,fieldSetType,err,error,*999)
 
    EXITS("Field_ParameterSetCreate")
    RETURN
999 ERRORSEXITS("Field_ParameterSetCreate",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetCreate

  !
  !================================================================================================================================
  !

  !>Checks whether a field parameter set has been created
  SUBROUTINE Field_ParameterSetCreated(field,variableType,fieldSetType,parameterSetCreated,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to check the parameter set creation for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    LOGICAL, INTENT(OUT) :: parameterSetCreated !<On return, .TRUE. if the parameter set has been created, .FALSE, if not.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetCreated",err,error,*999)

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetCreated(fieldVariable,fieldSetType,parameterSetCreated,err,error,*999)

    EXITS("Field_ParameterSetCreated")
    RETURN
999 ERRORSEXITS("Field_ParameterSetCreated",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetCreated

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type fieldSetType for a field variable if it does not already exist,
  !>otherwise it will do nothing.
  SUBROUTINE Field_ParameterSetEnsureCreated(field,variableType,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to create the parameter set for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The variable type to create the parameter set for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetEnsureCreated",err,error,*999)

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetEnsureCreated(fieldVariable,fieldSetType,err,error,*999)

    EXITS("Field_ParameterSetEnsureCreated")
    RETURN
999 ERRORSEXITS("Field_ParameterSetEnsureCreated",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ParameterSetEnsureCreated

  !
  !================================================================================================================================
  !

  !>Destroys the parameter set of type set type for a field variable and deallocates all memory. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDestroy
  SUBROUTINE Field_ParameterSetDestroy(field,variableType,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to destroy a parameter set for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to destroy the parameter set for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetDestroy",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetDestroy(fieldVariable,fieldSetType,err,error,*999)
    
    EXITS("Field_ParameterSetDestroy")
    RETURN
999 ERRORSEXITS("Field_ParameterSetDestroy",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetDestroy

  !
  !================================================================================================================================
  !

  !>Finalises the parameter set for a field and deallocates all memory.
  SUBROUTINE Field_ParameterSetFinalise(fieldParameterSet,err,error,*)

    !Argument variables
    TYPE(FieldParameterSetType), POINTER :: fieldParameterSet !<A pointer to the field parameter set to destroy
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_ParameterSetFinalise",err,error,*999)

    IF(ASSOCIATED(fieldParameterSet)) THEN
      IF(ASSOCIATED(fieldParameterSet%parameters)) CALL DistributedVector_Destroy(fieldParameterSet%parameters,err,error,*999)
      DEALLOCATE(fieldParameterSet)
    ENDIF

    EXITS("Field_ParameterSetFinalise")
    RETURN
999 ERRORSEXITS("Field_ParameterSetFinalise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ParameterSetFinalise

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field integer parameter set array. The pointer must be restored with a call to FieldRoutines::Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a FieldRoutines::Field_ParameterSetUpdate call must be used to change any values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet
  SUBROUTINE Field_ParameterSetDataGetIntg(field,variableType,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the parameter set data for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), POINTER :: parameters(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
   TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetDataGetIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetDataGet(fieldVariable,fieldSetType,parameters,err,error,*999)

    EXITS("Field_ParameterSetDataGetIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetDataGetIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetDataGetIntg

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field single precision parameter set array. The pointer must be restored with a call to FieldRoutines::Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a FieldRoutines::Field_ParameterSetUpdate call must be used to change any values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet
  SUBROUTINE Field_ParameterSetDataGetSP(field,variableType,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the parameter set data for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(SP), POINTER :: parameters(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetDataGetSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetDataGet(fieldVariable,fieldSetType,parameters,err,error,*999)

    EXITS("Field_ParameterSetDataGetSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetDataGetSP",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ParameterSetDataGetSP

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field double precision parameter set array. The pointer must be restored with a call to FieldRoutines::Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a FieldRoutines::Field_ParameterSetUpdate call must be used to change any values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet
  SUBROUTINE Field_ParameterSetDataGetDP(field,variableType,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the parameter set data for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(DP), POINTER :: parameters(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetDataGetDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetDataGet(fieldVariable,fieldSetType,parameters,err,error,*999)

    EXITS("Field_ParameterSetDataGetDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetDataGetDP",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ParameterSetDataGetDP

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field logical parameter set array. The pointer must be restored with a call to FieldRoutines::Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a FieldRoutines::Field_ParameterSetUpdate call must be used to change any values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet
  SUBROUTINE Field_ParameterSetDataGetL(field,variableType,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the parameter set data for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    LOGICAL, POINTER :: parameters(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetDataGetL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetDataGet(fieldVariable,fieldSetType,parameters,err,error,*999)
 
    EXITS("Field_ParameterSetDataGetL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetDataGetL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetDataGetL

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable integer parameter set array that was obtained with FieldRoutines::Field_ParameterSetDataGet. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore
  SUBROUTINE Field_ParameterSetDataRestoreIntg(field,variableType,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: variableType !<The field varaible type to restore the parameter set data for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), POINTER :: parameters(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetDataRestoreIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetDataRestore(fieldVariable,fieldSetType,parameters,err,error,*999)

    EXITS("Field_ParameterSetDataRestoreIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetDataRestoreIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetDataRestoreIntg

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable single precision parameter set array that was obtained with FieldRoutines::Field_ParameterSetDataGet. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore
  SUBROUTINE Field_ParameterSetDataRestoreSP(field,variableType,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: variableType !<The field varaible type to restore the parameter set data for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(SP), POINTER :: parameters(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetDataRestoreSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetDataRestore(fieldVariable,fieldSetType,parameters,err,error,*999)
 
    EXITS("Field_ParameterSetDataRestoreSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetDataRestoreSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetDataRestoreSP

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable double precision parameter set array that was obtained with FieldRoutines::Field_ParameterSetDataGet. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore
  SUBROUTINE Field_ParameterSetDataRestoreDP(field,variableType,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: variableType !<The field varaible type to restore the parameter set data for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(DP), POINTER :: parameters(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetDataRestoreDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetDataRestore(fieldVariable,fieldSetType,parameters,err,error,*999)

    EXITS("Field_ParameterSetDataRestoreDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetDataRestoreDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetDataRestoreDP

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable logical parameter set array that was obtained with FieldRoutines::Field_ParameterSetDataGet. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore
  SUBROUTINE Field_ParameterSetDataRestoreL(field,variableType,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: variableType !<The field varaible type to restore the parameter set data for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    LOGICAL, POINTER :: parameters(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetDataRestoreL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetDataRestore(fieldVariable,fieldSetType,parameters,err,error,*999)
     
    EXITS("Field_ParameterSetDataRestoreL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetDataRestoreL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetDataRestoreL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetConstant
  SUBROUTINE Field_ParameterSetGetConstantIntg(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetConstantIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetConstant(fieldVariable,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetConstantIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetConstantIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetConstantIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetConstant
  SUBROUTINE Field_ParameterSetGetConstantSP(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetConstantSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetConstant(fieldVariable,fieldSetType,componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetGetConstantSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetConstantSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetConstantSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetConstant
  SUBROUTINE Field_ParameterSetGetConstantDP(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetConstantDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetConstant(fieldVariable,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetConstantDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetConstantDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetConstantDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetConstant
  SUBROUTINE Field_ParameterSetGetConstantL(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetConstantL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetConstant(fieldVariable,fieldSetType,componentNumber,VALUE,err,error,*999)
 
    EXITS("Field_ParameterSetGetConstantL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetConstantL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetConstantL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointIntg(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetDataPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetDataPoint(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetGetDataPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetDataPointIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointSP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetDataPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetDataPoint(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetDataPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetDataPointSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointDP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetDataPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetDataPoint(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetDataPointDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointL(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetDataPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetDataPoint(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetDataPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetDataPointL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetElement
  SUBROUTINE Field_ParameterSetGetElementIntg(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetElementIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetElementIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetElementIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetElementIntg

  !
  !================================================================================================================================
  !


  !>Returns from the given parameter set a single precision value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetElement
  SUBROUTINE Field_ParameterSetGetElementSP(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetElementSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetElementSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetElementSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetElementSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetElement
  SUBROUTINE Field_ParameterSetGetElementDP(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetElementDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetElementDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetElementDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetElementDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetElement
  SUBROUTINE Field_ParameterSetGetElementL(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetElementL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetGetElementL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetElementL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetElementL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified gauss point of a user element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetGaussPoint
  SUBROUTINE Field_ParameterSetGetGaussPointIntg(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetGaussPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("Field_ParameterSetGetGaussPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetGaussPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetGaussPointIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified gauss point of a user element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetGaussPoint
  SUBROUTINE Field_ParameterSetGetGaussPointSP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetGaussPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("Field_ParameterSetGetGaussPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetGaussPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetGaussPointSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified gauss point of a user element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetGaussPoint
  SUBROUTINE Field_ParameterSetGetGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetGaussPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("Field_ParameterSetGetGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetGaussPointDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified gauss point of a user element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetGaussPoint
  SUBROUTINE Field_ParameterSetGetGaussPointL(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetGaussPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("Field_ParameterSetGetGaussPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetGaussPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetGaussPointL

  !
  !================================================================================================================================
  !

  !>Returns the parameter set integer value for a specified local dof of the field variable.
  SUBROUTINE Field_ParameterSetGetLocalDOFIntg(field,variableType,fieldSetType,localDOFNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localDOFNumber !<The dof number to get
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value of the specified local dof.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetGetLocalDOFIntg",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalDOF(fieldVariable,fieldSetType,localDOFNumber,VALUE,err,error,*999)
 
    EXITS("Field_ParameterSetGetLocalDOFIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalDOFIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalDOFIntg

  !
  !================================================================================================================================
  !

  !>Returns the parameter set single precision value for a particular local dof of the field variable.
  SUBROUTINE Field_ParameterSetGetLocalDOFSP(field,variableType,fieldSetType,localDOFNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localDOFNumber !<The dof number to get
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value of the specified dof
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalDOFSP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalDOF(fieldVariable,fieldSetType,localDOFNumber,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetLocalDOFSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalDOFSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalDOFSP

  !
  !================================================================================================================================
  !

  !>Returns the parameter set double precision value for a particular local dof of the field variable.
  SUBROUTINE Field_ParameterSetGetLocalDOFDP(field,variableType,fieldSetType,localDOFNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localDOFNumber !<The dof number to get
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value of the specified dof
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalDOFDP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalDOF(fieldVariable,fieldSetType,localDOFNumber,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetLocalDOFDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalDOFDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalDOFDP

  !
  !================================================================================================================================
  !

  !>Returns the parameter set logical value for a particular local dof of the field variable.
  SUBROUTINE Field_ParameterSetGetLocalDOFL(field,variableType,fieldSetType,localDOFNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localDOFNumber !<The dof number to get
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value of the specified dof.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalDOFL",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalDOF(fieldVariable,fieldSetType,localDOFNumber,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetLocalDOFL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalDOFL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalDOFL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local element of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalElementIntg(field,variableType,fieldSetType,localElementNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalElementIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalElement(fieldVariable,fieldSetType,localElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("Field_ParameterSetGetLocalElementIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElementIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalElementIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local element of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalElementSP(field,variableType,fieldSetType,localElementNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalElementSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalElement(fieldVariable,fieldSetType,localElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("Field_ParameterSetGetLocalElementSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElementSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalElementSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local element of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalElementDP(field,variableType,fieldSetType,localElementNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalElementDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalElement(fieldVariable,fieldSetType,localElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("Field_ParameterSetGetLocalElementDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElementDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalElementDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local element of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalElementL(field,variableType,fieldSetType,localElementNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
   TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalElementL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalElement(fieldVariable,fieldSetType,localElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("Field_ParameterSetGetLocalElementL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElementL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalElementL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified gauss point of a local element of a field variable component. 
  SUBROUTINE Field_ParameterSetGetLocalGaussPointIntg(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalGaussPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
      & componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetGetLocalGaussPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalGaussPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalGaussPointIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified gauss point of a local element of a field variable component. 
  SUBROUTINE Field_ParameterSetGetLocalGaussPointSP(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalGaussPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetLocalGaussPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalGaussPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalGaussPointSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified gauss point of a local element of a field variable component. 
  SUBROUTINE Field_ParameterSetGetLocalGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalGaussPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetLocalGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalGaussPointDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified gauss point of a local element of a field variable component. 
  SUBROUTINE Field_ParameterSetGetLocalGaussPointL(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalGaussPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetLocalGaussPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalGaussPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalGaussPointL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalNodeIntg(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalNodeIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetLocalNodeIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalNodeIntg
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalNodeSP(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalNodeSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetLocalNodeSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNodeSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalNodeSP
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalNodeDP(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalNodeDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
      & componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetGetLocalNodeDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNodeDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalNodeDP
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalNodeL(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalNodeL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetLocalNodeL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNodeL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalNodeL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetNode
  SUBROUTINE Field_ParameterSetGetNodeIntg(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetNodeIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetNodeIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetNodeIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetNode
  SUBROUTINE Field_ParameterSetGetNodeSP(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetNodeSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetNodeSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetNodeSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetNodeSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetNode
  SUBROUTINE Field_ParameterSetGetNodeDP(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetNodeDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetNodeDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetNodeDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetNodeDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetNode
  SUBROUTINE Field_ParameterSetGetNodeL(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetNodeL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGetNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetGetNodeL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetNodeL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetNodeL

 !
  !================================================================================================================================
  !

  !>Initialises the parameter set for a field.
  SUBROUTINE Field_ParameterSetInitialise(fieldParameterSet,err,error,*)

    !Argument variables
    TYPE(FieldParameterSetType), POINTER :: fieldParameterSet !<The field parameter set to initialise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_ParameterSetInitialise",err,error,*999)

    IF(ASSOCIATED(fieldParameterSet)) THEN
      fieldParameterSet%setIndex=0
      fieldParameterSet%setType=0
    ELSE
      CALL FlagError("Field parameter set is not associated",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetInitialise")
    RETURN
999 ERRORSEXITS("Field_ParameterSetInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ParameterSetInitialise

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetInterpolateGauss
  SUBROUTINE Field_ParameterSetInterpolateGaussDP0(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
    & quadratureScheme,gaussPoint,values,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to interpolate. \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for. \see Basis_QuadratureSchemes,BasisRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPoint !<The Gauss point to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    REAL(DP) :: tempValues(SIZE(values,1),1)

    ENTERS("Field_ParameterSetInterpolateGaussDP0",err,error,*999)

    CALL Field_ParameterSetInterpolateGaussDP1(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadratureScheme,[gaussPoint],tempValues,err,error,*999)
    values(1:SIZE(values,1))=tempValues(1:SIZE(values,1),1)

    EXITS("Field_ParameterSetInterpolateGaussDP0")
    RETURN
999 ERRORSEXITS("Field_ParameterSetInterpolateGaussDP0",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateGaussDP0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values. If no Gauss points are specified then all Gauss points are interpolated. \see OpenCMISS::Iron::cmfe_Field_ParameterSetInterpolateGauss
  SUBROUTINE Field_ParameterSetInterpolateGaussDP1(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
    & quadSchemeType,gaussPoints,values,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to interpolate. \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The derivative number of the field to interpolate.  \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadSchemeType !<The quadrature scheme to interpolate the field for.  \see Basis_QuadratureSchemes,BasisRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPoints(:) !<gaussPoints(gaussPointIdx). The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,gaussPointIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetInterpolateGaussDP1",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetInterpolateGaussDP1(fieldVariable,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadSchemeType,gaussPoints,values,err,error,*999)

    EXITS("Field_ParameterSetInterpolateGaussDP1")
    RETURN
999 ERRORS("Field_ParameterSetInterpolateGaussDP1",err,error)
    EXITS("Field_ParameterSetInterpolateGaussDP1")
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateGaussDP1

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetInterpolateXi
  SUBROUTINE Field_ParameterSetInterpolateXiDP0(field,variableType,fieldSetType,partialDerivativeType,userElementNumber,xi, &
    & values,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to interpolate. \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The derivative number of the field to interpolate.  \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The set of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    REAL(DP) :: tempXi(SIZE(xi,1),1),tempValues(SIZE(values,1),1)

    ENTERS("Field_ParameterSetInterpolateXiDP0",err,error,*999)

    tempXi(1:SIZE(xi,1),1)=xi(1:SIZE(xi,1))
    CALL Field_ParameterSetInterpolateXiDP1(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & tempXi,tempValues,err,error,*999)
    values(1:SIZE(values,1))=tempValues(1:SIZE(values,1),1)

    EXITS("Field_ParameterSetInterpolateXiDP0")
    RETURN
999 ERRORSEXITS("Field_ParameterSetInterpolateXiDP0",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateXiDP0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetInterpolateXI
  SUBROUTINE Field_ParameterSetInterpolateXiDP1(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
    & xi,values,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to interpolate. \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative number of the field to interpolate. \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    REAL(DP), INTENT(IN) :: xi(:,:) !<xi(xiIdx,xiPointIdx). The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,xiPointIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetInterpolateXiDP1",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetInterpolateXiDP1(fieldVariable,fieldSetType,partialDerivativeType,userElementNumber, &
      & xi,values,err,error,*999)

    EXITS("Field_ParameterSetInterpolateXiDP1")
    RETURN
999 ERRORSEXITS("Field_ParameterSetInterpolateXiDP1",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateXiDP1

  !
  !================================================================================================================================
  !

  !>Outputs the parameter set for a field variable.
  SUBROUTINE Field_ParameterSetOutput(id,field,variableType,fieldSetType,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ID !<The ID of the output stream
    TYPE(FieldType), POINTER :: field !<A pointer to the field to output the parameter set for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to output the parameter set for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to output \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetOutput",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetOutput(id,fieldVariable,fieldSetType,err,error,*999)

    EXITS("Field_ParameterSetOutput")
    RETURN
999 ERRORSEXITS("Field_ParameterSetOutput",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetOutput

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateConstant
  SUBROUTINE Field_ParameterSetUpdateConstantIntg(field,variableType,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    INTEGER, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateConstantIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateConstant(fieldVariable,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateConstantIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateConstantIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateConstantIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateConstant
  SUBROUTINE Field_ParameterSetUpdateConstantSP(field,variableType,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
   TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateConstantSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateConstant(fieldVariable,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateConstantSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateConstantSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateConstantSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateConstant
  SUBROUTINE Field_ParameterSetUpdateConstantDP(field,variableType,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateConstantDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateConstant(fieldVariable,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateConstantDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateConstantDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateConstantDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateConstant
  SUBROUTINE Field_ParameterSetUpdateConstantL(field,variableType,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
   TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateConstantL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateConstant(fieldVariable,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateConstantL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateConstantL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateConstantL

  !
  !================================================================================================================================
  !

  !>Update the given parameter set an integer value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointIntg(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateDataPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateDataPoint(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user data point number "// &
        & TRIM(NumberToVString(userDataPointNumber,"*",err,error))//" as it is a ghost data point."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateDataPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateDataPointIntg

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointSP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, & 
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateDataPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateDataPoint(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user data point number "// &
        & TRIM(NumberToVString(userDataPointNumber,"*",err,error))//" as it is a ghost data point."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateDataPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateDataPointSP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointDP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateDataPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateDataPoint(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)
 
    EXITS("Field_ParameterSetUpdateDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateDataPointDP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointL(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateDataPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateDataPoint(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("Field_ParameterSetUpdateDataPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateDataPointL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular user element of the field variable component. \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE Field_ParameterSetUpdateElementIntg(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetUpdateElementIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("Field_ParameterSetUpdateElementIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateElementIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateElementIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular user element of the field variable component.  \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE Field_ParameterSetUpdateElementSP(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetUpdateElementSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("Field_ParameterSetUpdateElementSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateElementSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateElementSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular user element of the field variable component.  \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE Field_ParameterSetUpdateElementDP(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateElementDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("Field_ParameterSetUpdateElementDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateElementDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateElementDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular user element of the field variable component. \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE Field_ParameterSetUpdateElementL(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateElementL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateElement(fieldVariable,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("Field_ParameterSetUpdateElementL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateElementL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateElementL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular data point of the field variable component.  \see cmfe_Field_ParameterSetUpdateElementDataPoint
  SUBROUTINE Field_ParameterSetUpdateElementDataPointIntg(field,variableType,fieldSetType,userElementNumber,dataPointIndex, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number the data point is projected on
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point projected on the element
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetUpdateElementDataPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateElementDataPoint(fieldVariable,fieldSetType,userElementNumber,dataPointIndex, &
      & componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetUpdateElementDataPointIntg")
    RETURN
999 ERRORS("Field_ParameterSetUpdateElementDataPointIntg",err,error)
    EXITS("Field_ParameterSetUpdateElementDataPointIntg")
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateElementDataPointIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular data point of the field variable component.  \see cmfe_Field_ParameterSetUpdateElementDataPoint
  SUBROUTINE Field_ParameterSetUpdateElementDataPointSP(field,variableType,fieldSetType,userElementNumber,dataPointIndex, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number the data point is projected on
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point projected on the element
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetUpdateElementDataPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateElementDataPoint(fieldVariable,fieldSetType,userElementNumber,dataPointIndex, &
      & componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetUpdateElementDataPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateElementDataPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateElementDataPointSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular data point of the field variable component.  \see cmfe_Field_ParameterSetUpdateElementDataPoint
  SUBROUTINE Field_ParameterSetUpdateElementDataPointDP(field,variableType,fieldSetType,userElementNumber,dataPointIndex, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number the data point is projected on
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point projected on the element
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetUpdateElementDataPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateElementDataPoint(fieldVariable,fieldSetType,userElementNumber,dataPointIndex, &
      & componentNumber,value,err,error,*999)
 
    EXITS("Field_ParameterSetUpdateElementDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateElementDataPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateElementDataPointDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular data point of the field variable component.  \see cmfe_Field_ParameterSetUpdateElementDataPoint
  SUBROUTINE Field_ParameterSetUpdateElementDataPointL(field,variableType,fieldSetType,userElementNumber,dataPointIndex, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number the data point is projected on
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point projected on the element
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateElementDataPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateElementDataPoint(fieldVariable,fieldSetType,userElementNumber,dataPointIndex, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateElementDataPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateElementDataPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateElementDataPointL

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateFinish
  SUBROUTINE Field_ParameterSetUpdateFinish(field,variableType,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to finish the update for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateFinish",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateFinish(fieldVariable,fieldSetType,err,error,*999)

    EXITS("Field_ParameterSetUpdateFinish")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateFinish",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateFinish

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given integer value for a particular gauss point of the field variable component.  \see cmfe_Field_ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointIntg(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateGaussPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateGaussPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointIntg

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given single precision value for a particular gauss point of the field variable component.  \see cmfe_Field_ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointSP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetUpdateGaussPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateGaussPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointSP

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given double precision value for a particular gauss point of the field variable component.  \see cmfe_Field_ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateGaussPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointDP

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given logical value for a particular gauss point of the field variable component.  \see cmfe_Field__ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointL(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateGaussPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateGaussPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointL

  !
  !================================================================================================================================
  !

  !>Update the given parameter set an integer value for the specified local data point of a field variable component. 
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointIntg(field,variableType,fieldSetType,dataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalDataPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalDataPoint(fieldVariable,fieldSetType,dataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDataPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointIntg

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified local data point of a field variable component. 
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointSP(field,variableType,fieldSetType,dataPointNumber,componentNumber,VALUE, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalDataPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalDataPoint(fieldVariable,fieldSetType,dataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDataPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointSP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified local data point of a field variable component. 
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointDP(field,variableType,fieldSetType,dataPointNumber,componentNumber,VALUE, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalDataPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalDataPoint(fieldVariable,fieldSetType,dataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointDP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified local data point of a field variable component. 
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointL(field,variableType,fieldSetType,dataPointNumber,componentNumber,VALUE, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalDataPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalDataPoint(fieldVariable,fieldSetType,dataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDataPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local dof of the field variable.
  SUBROUTINE Field_ParameterSetUpdateLocalDOFIntg(field,variableType,fieldSetType,dofNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalDOFIntg",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalDOF(fieldVariable,fieldSetType,dofNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDOFIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDOFIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDOFIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local dof of the field variable.
  SUBROUTINE Field_ParameterSetUpdateLocalDOFSP(field,variableType,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalDOFSP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalDOF(fieldVariable,fieldSetType,dofNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDOFSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDOFSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDOFSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local dof of the field variable.
  SUBROUTINE Field_ParameterSetUpdateLocalDOFDP(field,variableType,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalDOFDP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalDOF(fieldVariable,fieldSetType,dofNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDOFDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDOFDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDOFDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local dof of the field variable.
  SUBROUTINE Field_ParameterSetUpdateLocalDOFL(field,variableType,fieldSetType,dofNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetUpdateLocalDOFL",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalDOF(fieldVariable,fieldSetType,dofNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDOFL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDOFL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDOFL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local element of the field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalElementIntg(field,variableType,fieldSetType,localNumberElement, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalElementIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,fieldSetType,localNumberElement,componentNumber, &
      & value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalElementIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalElementIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalElementIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local element of the field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalElementSP(field,variableType,fieldSetType,localNumberElement,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalElementSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,fieldSetType,localNumberElement,componentNumber, &
      & value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalElementSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalElementSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalElementSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local element of the field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalElementDP(field,variableType,fieldSetType,localNumberElement,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalElementDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,fieldSetType,localNumberElement,componentNumber, &
      & value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalElementDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalElementDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalElementDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local element of the field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalElementL(field,variableType,fieldSetType,localNumberElement,componentNumber, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalElementL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalElement(fieldVariable,fieldSetType,localNumberElement,componentNumber, &
      & value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalElementL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalElementL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalElementL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular gauss point of the field variable component using the local element index. 
  SUBROUTINE Field_ParameterSetUpdateLocalGaussPointIntg(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalGaussPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalGaussPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalGaussPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalGaussPointIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular gauss point of the field variable component using the local element index. 
  SUBROUTINE Field_ParameterSetUpdateLocalGaussPointSP(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalGaussPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalGaussPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalGaussPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalGaussPointSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular gauss point of the field variable component using the local element index. 
  SUBROUTINE Field_ParameterSetUpdateLocalGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalGaussPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalGaussPointDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular gauss point of the field variable component using the local element index. 
  SUBROUTINE Field_ParameterSetUpdateLocalGaussPointL(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalGaussPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalGaussPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalGaussPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalGaussPointL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalNodeIntg(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalNodeIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalNodeIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalNodeIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalNodeSP(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalNodeSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalNodeSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalNodeSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalNodeSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalNodeDP(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalNodeDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalNodeDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalNodeDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalNodeDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalNodeL(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalNodeL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateLocalNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
      & componentNumber,value,err,error,*999)
    
    EXITS("Field_ParameterSetUpdateLocalNodeL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalNodeL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalNodeL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateNode
  SUBROUTINE Field_ParameterSetUpdateNodeIntg(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateNodeIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateNodeIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateNodeIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateNode
  SUBROUTINE Field_ParameterSetUpdateNodeSP(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateNodeSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateNodeSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateNodeSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateNodeSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateNode
  SUBROUTINE Field_ParameterSetUpdateNodeDP(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateNodeDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateNodeDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateNodeDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateNodeDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateNode
  SUBROUTINE Field_ParameterSetUpdateNodeL(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateNodeL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateNode(fieldVariable,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("Field_ParameterSetUpdateNodeL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateNodeL",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ParameterSetUpdateNodeL

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateStart
  SUBROUTINE Field_ParameterSetUpdateStart(field,variableType,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to start the update for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to update \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateStart",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetUpdateStart(fieldVariable,fieldSetType,err,error,*999)

    EXITS("Field_ParameterSetUpdateStart")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateStart",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateStart

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set distributed vector. 
  SUBROUTINE Field_ParameterSetVectorGet(field,variableType,fieldSetType,distributedVector,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the parameter set vector from
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    TYPE(DistributedVectorType), POINTER :: distributedVector !<On return, a pointer to the field parameter set distributed vector. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetVectorGet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetVectorGet(fieldVariable,fieldSetType,distributedVector,err,error,*999)

    EXITS("Field_ParameterSetVectorGet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetVectorGet",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetVectorGet

  !
  !================================================================================================================================
  !

  !>Finalises the parameter sets for a field and deallocates all memory.
  SUBROUTINE Field_ParameterSetsFinalise(fieldVariable,err,error,*)

    !Argument variables
    TYPE(FieldVariableType) :: fieldVariable !<A pointer to the field variable to finalise the parameter sets for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: parameterSetIdx

    ENTERS("Field_ParameterSetsFinalise",err,error,*999)

    IF(ASSOCIATED(fieldVariable%parameterSets%setType)) DEALLOCATE(fieldVariable%parameterSets%setType)
    IF(ASSOCIATED(fieldVariable%parameterSets%parameterSets)) THEN
      DO parameterSetIdx=1,SIZE(fieldVariable%parameterSets%parameterSets,1)
        CALL Field_ParameterSetFinalise(fieldVariable%parameterSets%parameterSets(parameterSetIdx)%ptr,err,error,*999)
      ENDDO !parameterSetIdx
      DEALLOCATE(fieldVariable%parameterSets%parameterSets)
    ENDIF
    fieldVariable%parameterSets%numberOfParameterSets=0

    EXITS("Field_ParameterSetsFinalise")
    RETURN
999 ERRORSEXITS("Field_ParameterSetsFinalise",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetsFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the parameter sets for a field.
  SUBROUTINE Field_ParametersSetsInitialise(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the variable parameter sets for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error
    !Local Variables
    INTEGER(INTG) :: dummyErr,parameterSetIdx,variableIdx
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("Field_ParametersSetsInitialise",err,error,*998)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*998)
    
    DO variableIdx=1,field%numberOfVariables        
      field%variables(variableIdx)%parameterSets%fieldVariable=>field%variables(variableIdx)
      field%variables(variableIdx)%parameterSets%numberOfParameterSets=0
      NULLIFY(field%variables(variableIdx)%parameterSets%parameterSets)
      ALLOCATE(field%variables(variableIdx)%parameterSets%setType(FIELD_NUMBER_OF_SET_TYPES),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate field parameter sets set types.",err,error,*999)
      DO parameterSetIdx=1,FIELD_NUMBER_OF_SET_TYPES
        NULLIFY(field%variables(variableIdx)%parameterSets%setType(parameterSetIdx)%ptr)
      ENDDO !parameterSetIdx
      !Create a field values parameter set
      CALL Field_ParameterSetCreate(field,field%variables(variableIdx)%variableType,FIELD_VALUES_SET_TYPE,err,error,*999)
    ENDDO !variableIdx

    EXITS("Field_ParametersSetsInitialise")
    RETURN
999 DO variableIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
      IF(ASSOCIATED(field%variableTypeMap(variableIdx)%ptr)) &
        & CALL Field_ParameterSetsFinalise(field%variableTypeMap(variableIdx)%ptr,dummyErr,dummyError,*998)
    ENDDO !variableIdx
998 ERRORSEXITS("Field_ParametersSetsInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ParametersSetsInitialise

  !
  !================================================================================================================================
  !

  !>Finalises the physical point and deallocates all memory.
  SUBROUTINE Field_PhysicalPointFinalise(physicalPoint,err,error,*)

    !Argument variables
    TYPE(FieldPhysicalPointType), POINTER :: physicalPoint !<A pointer to the physical point to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_PhysicalPointFinalise",err,error,*999)

    IF(ASSOCIATED(physicalPoint)) THEN
      IF(ALLOCATED(physicalPoint%values)) DEALLOCATE(physicalPoint%values)
      DEALLOCATE(physicalPoint)
    ENDIF

    EXITS("Field_PhysicalPointFinalise")
    RETURN
999 ERRORSEXITS("Field_PhysicalPointFinalise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_PhysicalPointFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the physical point for interpolated points
  SUBROUTINE Field_PhysicalPointInitialise(fieldInterpPoint,geometricInterpPoint,physicalPoint, &
    & err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointType), POINTER :: fieldInterpPoint !<A pointer to the field interpolation point to initialise the physical point for
    TYPE(FieldInterpolatedPointType), POINTER :: geometricInterpPoint !<A pointer to the geometric field interpolated point to initialise the physical point for
    TYPE(FieldPhysicalPointType), POINTER :: physicalPoint !<On exit, A pointer to the physical point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldInterpolationParametersType), POINTER :: fieldInterpParameters,geometricInterpParameters
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("Field_PhysicalPointInitialise",err,error,*998)

    IF(ASSOCIATED(physicalPoint)) CALL FlagError("Physical point is already associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(fieldInterpPoint)) CALL FlagError("Field interpolated point is not associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(geometricInterpPoint)) CALL FlagError("Geometric interpolated point is not associated.",err,error,*998)

    NULLIFY(fieldInterpParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(fieldInterpPoint,fieldInterpParameters,err,error,*999)
    NULLIFY(geometricInterpParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(geometricInterpPoint,geometricInterpParameters,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(fieldInterpParameters,fieldVariable,err,error,*999)
    NULLIFY(geometricVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(geometricInterpParameters,geometricVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(geometricField)
    CALL FieldVariable_FieldGet(geometricVariable,geometricField,err,error,*999)
    IF(.NOT.ASSOCIATED(field%geometricField,geometricField)) &
      & CALL FlagError("The field geometric field and the specified geometric field are not associated.",err,error,*999)

    ALLOCATE(physicalPoint,STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate physical point.",err,error,*999)
    physicalPoint%fieldInterpolatedPoint=>fieldInterpPoint
    physicalPoint%geometricInterpolatedPoint=>geometricInterpPoint
    physicalPoint%physicalDerivativeType=0
    ALLOCATE(physicalPoint%values(fieldVariable%numberOfComponents),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate physical point values.",err,error,*999)
    physicalPoint%values=0.0_DP

    EXITS("Field_PhysicalPointInitialise")
    RETURN
999 CALL Field_PhysicalPointFinalise(physicalPoint,dummyErr,dummyError,*998)
998 ERRORSEXITS("Field_PhysicalPointInitialise",err,error)
    RETURN 1

  END SUBROUTINE Field_PhysicalPointInitialise

  !
  !================================================================================================================================
  !

  !>Finalises the physical points and deallocates all memory.
  SUBROUTINE Field_PhysicalPointsFinalise(physicalPoints,err,error,*)

    !Argument variables
    TYPE(FieldPhysicalPointPtrType), POINTER :: physicalPoints(:) !<A pointer to the physical points to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableTypeIdx

    ENTERS("Field_PhysicalPointsFinalise",err,error,*999)

    IF(ASSOCIATED(physicalPoints)) THEN
      DO variableTypeIdx=1,SIZE(physicalPoints,1)
        CALL Field_PhysicalPointFinalise(physicalPoints(variableTypeIdx)%ptr,err,error,*999)
      ENDDO !variableTypeIdx
      DEALLOCATE(physicalPoints)
    ENDIF

    EXITS("Field_PhysicalPointsFinalise")
    RETURN
999 ERRORSEXITS("Field_PhysicalPointsFinalise",err,error)
    RETURN 1

  END SUBROUTINE Field_PhysicalPointsFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the physical point for an interpolation parameters
  SUBROUTINE Field_PhysicalPointsInitialise(fieldInterpPoints,geometricInterpPoints,physicalPoints,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointPtrType), POINTER :: fieldInterpPoints(:) !<A pointer to the field interpolated points to initialise the physical points for
    TYPE(FieldInterpolatedPointPtrType), POINTER :: geometricInterpPoints(:) !<A pointer to the geometric interpolated points to initialise the physical points for
    TYPE(FieldPhysicalPointPtrType), POINTER :: physicalPoints(:) !<On exit, A pointer to the physical points that has been initialised. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,variableTypeIdx
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("Field_PhysicalPointsInitialise",err,error,*998)

    IF(ASSOCIATED(physicalPoints)) CALL FlagError("Physical points is already associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(fieldInterpPoints)) CALL FlagError("Field interpolated points is not associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(geometricInterpPoints)) CALL FlagError("Geometric interpolated points is not associated.",err,error,*998)
    
    ALLOCATE(physicalPoints(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate physical points.",err,error,*999)
    DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
      NULLIFY(physicalPoints(variableTypeIdx)%ptr)
      IF(ASSOCIATED(fieldInterpPoints(variableTypeIdx)%ptr).AND.ASSOCIATED(geometricInterpPoints(variableTypeIdx)%ptr)) &
        & CALL Field_PhysicalPointInitialise(fieldInterpPoints(variableTypeIdx)%ptr,geometricInterpPoints(variableTypeIdx)%ptr, &
        & physicalPoints(variableTypeIdx)%ptr,err,error,*999)
    ENDDO !variableTypeIdx

    EXITS("Field_PhysicalPointsInitialise")
    RETURN
999 CALL Field_PhysicalPointsFinalise(physicalPoints,dummyErr,dummyError,*998)
998 ERRORSEXITS("Field_PhysicalPointsInitialise",err,error)
    RETURN 1

  END SUBROUTINE Field_PhysicalPointsInitialise

  !
  !================================================================================================================================
  !

  !>Computes the geometric position, normal and tangent vectors at a interpolated point metrics in a field. 
  SUBROUTINE Field_PositionNormalTangentsCalculateIntPtMetric(interpolatedPointMetrics,reverseNormal,position,normal,tangents, &
    & err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointMetricsType), POINTER, INTENT(IN) :: interpolatedPointMetrics !<A pointer to the interpolated point metric information to calculate the position etc. for
    LOGICAL, INTENT(IN) :: reverseNormal !<Reverse normal diretion if .TRUE.
    REAL(DP), INTENT(OUT) :: position(:) !<position(coordinateIdx), on exit the geometric position of the node
    REAL(DP), INTENT(OUT) :: normal(:) !<normal(coordinateIdx), on exit the normal vector
    REAL(DP), INTENT(OUT) :: tangents(:,:) !<tangents(coordinateIdx,tangentIdx), on exit the tangent vectors for the tangentIdx'th tangent at the node. There are numberOfXi-1 tangent vectors.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: coordinateIdx,numberOfXDimensions,numberOfXiDimensions,xiIdx
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_PositionNormalTangentsCalculateIntPtMetric",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolatedPointMetrics)) CALL FlagError("Interpolated point metrics is not associated.",err,error,*999)
    
    numberOfXDimensions=interpolatedPointMetrics%numberOfXDimensions
    numberOfXiDimensions=interpolatedPointMetrics%numberOfXiDimensions
    IF(SIZE(position,1)<numberOfXDimensions) THEN
      localError="The size of position of "//TRIM(NumberToVString(SIZE(position,1),"*",err,error))// &
        & " is too small. The size must be >= "//TRIM(NumberToVString(numberOfXDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)          
    ENDIF
    IF(SIZE(normal,1)<numberOfXDimensions) THEN
      localError="The size of normal of "//TRIM(NumberToVString(SIZE(normal,1),"*",err,error))// &
        & " is too small. The size must be >= "//TRIM(NumberToVString(numberOfXDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(tangents,1)<numberOfXDimensions) THEN
      localError="The size of the 1st dimension of tangents of "// &
        & TRIM(NumberToVString(SIZE(tangents,1),"*",err,error))//" is too small. The size must be >= "// &
        & TRIM(NumberToVString(numberOfXDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(tangents,2)<numberOfXiDimensions) THEN
      localError="The size of the 2nd dimension of tangents of "// &
        & TRIM(NumberToVString(SIZE(tangents,2),"*",err,error))//" is too small. The size must be >= "// &
        & TRIM(NumberToVString(numberOfXiDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(interpolatedPoint)
    CALL FieldInterpolatedPointMetrics_InterpolatedPointGet(interpolatedPointMetrics,interpolatedPoint,err,error,*999)

    position(1:numberOfXDimensions)=interpolatedPoint%values(1:numberOfXDimensions,NO_PART_DERIV)
    normal(1:numberOfXDimensions)=0.0_DP
    SELECT CASE(numberOfXiDimensions)
    CASE(1) !For lines
      normal(1:numberOfXDimensions)=0.0_DP
      DO coordinateIdx=1,numberOfXDimensions
        tangents(coordinateIdx,1)=interpolatedPointMetrics%dXdXi(coordinateIdx,1)
      ENDDO !coordinateIdx 
      CALL Normalise(tangents(1:numberOfXDimensions,1),tangents(1:numberOfXDimensions,1),err,error,*999)
      SELECT CASE(numberOfXDimensions)
      CASE(2)
        normal(1)=-tangents(2,1)
        normal(2)=tangents(1,1)
      CASE(3)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="The number of coordinate dimensions of "//TRIM(NumberToVString(numberOfXDimensions,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(2) !For faces
      DO xiIdx=1,numberOfXiDimensions
        DO coordinateIdx=1,numberOfXDimensions
          tangents(coordinateIdx,xiIdx)=interpolatedPointMetrics%dXdXi(coordinateIdx,xiIdx)
        ENDDO !coordinateIdx
        CALL Normalise(tangents(1:numberOfXDimensions,xiIdx),tangents(1:numberOfXDimensions,xiIdx),err,error,*999)
      ENDDO !xiIdx
      CALL CrossProduct(tangents(1:numberOfXDimensions,1),tangents(1:numberOfXDimensions,2),normal,err,error,*999)
    CASE DEFAULT
      localError="The interpolated metrics must be for lines/faces, dimension of " &
        & //TRIM(NumberToVString(numberOfXiDimensions,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)    
    END SELECT
    IF(reverseNormal) normal(1:numberOfXDimensions)=-normal(1:numberOfXDimensions)

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolated point metrics data:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of X dimensions = ",numberOfXDimensions,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of Xi dimensions = ",numberOfXiDimensions,err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfXDimensions,3,3,position, &
        & '("  Position    :",3(X,E13.6))','(15X,3(X,E13.6))',err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfXDimensions,3,3,normal, &
        & '("  Normal      :",3(X,E13.6))','(15X,3(X,E13.6))',err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Tangents:",err,error,*999)
      DO xiIdx=1,numberOfXiDimensions
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Tangent : ",xiIdx,err,error,*999)
        CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfXDimensions,3,3,tangents(:,xiIdx), &
          & '("      Tangent :",3(X,E13.6))','(15X,3(X,E13.6))',err,error,*999)        
      ENDDO !xiIdx
    ENDIF

    EXITS("Field_PositionNormalTangentsCalculateIntPtMetric")
    RETURN
999 ERRORS("Field_PositionNormalTangentsCalculateIntPtMetric",err,error)
    EXITS("Field_PositionNormalTangentsCalculateIntPtMetric")
    RETURN 1

  END SUBROUTINE Field_PositionNormalTangentsCalculateIntPtMetric

  !
  !================================================================================================================================
  !

  !>Computes the geometric position, normal and tangent vectors at a node in a field. If the node is internal to the mesh the normal and tangents are zero.
  SUBROUTINE Field_PositionNormalTangentsCalculateNode(field,variableType,componentNumber,localNodeNumber, &
    & position,normal,tangents,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER, INTENT(IN) :: field !<A pointer to the field to interpolate the geometric information for
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the node to compute the geometric information for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the node to compute the geometric information for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to compute the geometric information for
    REAL(DP), INTENT(OUT) :: position(:) !<position(coordinateIdx), on exit the geometric position of the node
    REAL(DP), INTENT(OUT) :: normal(:) !<normal(coordinateIdx), on exit the normal vector. If the node is internal the normal vector is zero.
    REAL(DP), INTENT(OUT) :: tangents(:,:) !<tangents(coordinateIdx,tangentIdx), on exit the tangent vectors for the tangentIdx'th tangent at the node. There are up to numberOfXi tangent vectors.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: basisFamilyType,componentIdx,derivativeIdx,element,elementIdx,index,indexMatch,interpolationType, &
      & localElementNumber,localNode,localNodeIdx,nodePositionIdx,numberOfAdjacentElements,numberOfDimensions, &
      & numberOfElements,numberOfNodesXiC(4),numberOfSurroundingElements,numberOfXi,numberOfXiCoordinates,tangentIdx, &
      & tangentXiIdx,xiCoordIdx,xiIdx
    REAL(DP) :: dXdXi(3,3),vector1(3),vector2(3),xi(3)
    LOGICAL :: boundaryNode
    TYPE(BasisType), POINTER :: basis
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementType), POINTER :: domainElement
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodeType), POINTER :: domainNode
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DecompositionElementType), POINTER :: decompositionElement
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(FieldType), POINTER :: geometricField
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_PositionNormalTangentsCalculateNode",err,error,*999)

   CALL Field_AssertIsFinished(field,err,error,*999)
    
    NULLIFY(geometricField)
    CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    NULLIFY(geometricVariable)
    CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
    CALL FieldVariable_NumberOfComponentsGet(geometricVariable,numberOfDimensions,err,error,*999)
    IF(SIZE(position,1)<numberOfDimensions) THEN
      localError="The size of the supplied position array of "//TRIM(NumberToVString(SIZE(position,1), &
        & "*",err,error))//" is too small. The size of the supplied array must be >= "// &
        & TRIM(NumberToVString(numberOfDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(normal,1)<numberOfDimensions) THEN
      localError="The size of the supplied normal array of "//TRIM(NumberToVString(SIZE(normal,1), &
        & "*",err,error))//" is too small. The size of the supplied array must be >= "// &
        & TRIM(NumberToVString(numberOfDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(tangents,1)<numberOfDimensions) THEN
      localError="The first dimension of the supplied tangent array of "// &
        & TRIM(NumberToVString(SIZE(tangents,1),"*",err,error))// &
        & " is too small. The first dimension of the supplied array must be >= "// &
        & TRIM(NumberToVString(numberOfDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF       
    NULLIFY(domain)
    CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(decompositionElements)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL FieldVariable_ComponentInterpolationGet(fieldVariable,componentNumber,interpolationType,err,error,*999)
    SELECT CASE(interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      localError="Cannot compute the normal at a node for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" for variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " which has constant interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      localError="Cannot compute the normal at a node for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" for variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" which has element based&
        & interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)      
      NULLIFY(domainNodes)
      CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
      IF(localNodeNumber<1.OR.localNodeNumber>domainNodes%numberOfNodes) THEN
        localError="The local node number of "//TRIM(NumberToVString(localNodeNumber,"*",err,error))// &
          & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
          & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(field%userNumber,"*",err,error))//". The local node number must be > 0 and <="// &
          & TRIM(NumberToVString(domainNodes%numberOfNodes,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      NULLIFY(domainNode)
      CALL DomainNodes_NodeGet(domainNodes,localNodeNumber,domainNode,err,error,*999)
      !Normal & tangent will be calculated as averages in all surrounding elements. This is
      !because there could be discontinuity in the surface gradients across elements.
      position(1:numberOfDimensions)=0.0_DP
      dXdXi=0.0_DP
      normal(1:numberOfDimensions)=0.0_DP
      tangents(1:numberOfDimensions,:)=0.0_DP
      NULLIFY(interpolationParameters)
      CALL FieldVariable_InterpolationParameterInitialise(geometricVariable,interpolationParameters,err,error,*999)
      NULLIFY(interpolatedPoint)
      CALL Field_InterpolatedPointInitialise(interpolationParameters,interpolatedPoint,err,error,*999)
      CALL DomainNode_BoundaryNodeGet(domainNode,boundaryNode,err,error,*999)
      CALL DomainNode_NumberOfSurroundingElementsGet(domainNode,numberOfSurroundingElements,err,error,*999)
      numberOfElements=0
      DO elementIdx=1,numberOfSurroundingElements
        CALL DomainNode_SurroundingElementGet(domainNode,elementIdx,localElementNumber,err,error,*999)
        NULLIFY(domainElement)
        CALL DomainElements_ElementGet(domainElements,localElementNumber,domainElement,err,error,*999)
        NULLIFY(decompositionElement)
        CALL DecompositionElements_ElementGet(decompositionElements,localElementNumber,decompositionElement,err,error,*999)
        NULLIFY(basis)
        CALL DomainElement_BasisGet(domainElement,basis,err,error,*999)
        CALL Basis_NumberOfXiGet(basis,numberOfXi,err,error,*999)
        CALL Basis_NumberOfXiCoordinatesGet(basis,numberOfXiCoordinates,err,error,*999)
        CALL Basis_TypeGet(basis,basisFamilyType,err,error,*999)
        !Find local node number in the basis
        CALL DomainElement_NodeLocalNodeGet(domainElement,localNodeNumber,localNode,err,error,*999)
        !Find the xi position of the node in the element. In most cases this will be 0,1.0 etc
        ! but in some cases the geometric field may not contain this node in which case xi can be
        ! arbitrary
        CALL Basis_LocalNodeXiCalculate(basis,localNode,xi,err,error,*999)
        !Interpolate the geometric field at the xi position.
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,localElementNumber,interpolationParameters, &
          & err,error,*999)
        CALL Field_InterpolateXi(FIRST_PART_DERIV,xi(1:numberOfXi),interpolatedPoint,err,error,*999)
        !Grab the position. This shouldn't vary between elements so do it once only
        IF(elementIdx==1) position(1:numberOfDimensions)=interpolatedPoint%values(1:numberOfDimensions,NO_PART_DERIV)
        !Get dXdXi
        !\todo: What if the surrounding elements have different number of xi? then dXdXi will be different in size.
        !       Which one do we return in that case?
        DO componentIdx=1,numberOfDimensions
          DO xiIdx=1,numberOfXi
            derivativeIdx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xiIdx) !2,4,7
            dXdXi(componentIdx,xiIdx)=interpolatedPoint%values(componentIdx,derivativeIdx) !dx/dxi
          ENDDO !xiIdx
        ENDDO !componentIdx
        !Calculate the tangents and normal vectors
        IF(boundaryNode) THEN
          SELECT CASE(basisFamilyType)
          CASE(BASIS_LAGRANGE_HERMITE_TP_TYPE)            
            !Calculate tangents from dXdXi: which xi corresponds to normal direction?
            CALL Basis_NumberOfNodesXiCGet(basis,numberOfNodesXiC,err,error,*999)
            DO xiCoordIdx=-numberOfXiCoordinates,numberOfXiCoordinates
              CALL DecompositionElement_NumberAdjacentGet(decompositionElement,ABS(xiCoordIdx),numberOfAdjacentElements, &
                & err,error,*999)
              IF(numberOfAdjacentElements==0) THEN
                IF(xiCoordIdx>0) THEN
                  indexMatch=numberOfNodesXiC(ABS(xiCoordIdx))
                ELSE IF(xiCoordIdx<0) THEN
                  indexMatch=1
                ENDIF
                CALL Basis_NodePositionIndexGet(basis,localNode,ABS(xiCoordIdx),nodePositionIdx,err,error,*999)
                IF(nodePositionIdx==indexMatch) THEN
                  !1D/2D/3D: tangents and normal
                  SELECT CASE(numberOfXi)
                  CASE(1)
                    !There are no tangents.
                    vector1(1:numberOfDimensions)=dXdXi(1:numberOfDimensions,1)
                    CALL Normalise(vector1(1:numberOfDimensions),vector1(1:numberOfDimensions),err,error,*999)
                    normal(1:numberOfDimensions)=normal(1:numberOfDimensions)+vector1(1:numberOfDimensions)
                  CASE(2)
                    !One tangent vector, one normal vector
                    tangentXiIdx=OTHER_XI_DIRECTIONS2(ABS(xiCoordIdx))
                    vector1(1:numberOfDimensions)=dXdXi(1:numberOfDimensions,tangentXiIdx)
                    CALL Normalise(vector1(1:numberOfDimensions),vector1(1:numberOfDimensions),err,error,*999)
                    tangents(1:numberOfDimensions,1)=tangents(1:numberOfDimensions,1)+vector1(1:numberOfDimensions)
                    !Normal is the other component in dXdXi (correct?) Ensure the direction is outward
                    vector1(1:numberOfDimensions)=dXdXi(1:numberOfDimensions,ABS(xiCoordIdx))
                    IF(xiCoordIdx<0) vector1=-vector1
                    CALL Normalise(vector1(1:numberOfDimensions),vector1(1:numberOfDimensions),err,error,*999)
                    normal(1:numberOfDimensions)=normal(1:numberOfDimensions)+vector1(1:numberOfDimensions)
                  CASE(3)
                    !Two tangent vectors, one normal vector
                    tangents=0.0_DP
                    tangentXiIdx=OTHER_XI_DIRECTIONS3(ABS(xiCoordIdx),2,1)
                    vector1(1:numberOfDimensions)=dXdXi(1:numberOfDimensions,1)
                    CALL Normalise(vector1(1:numberOfDimensions),vector1(1:numberOfDimensions),err,error,*999)
                    tangents(1:numberOfDimensions,1)=tangents(1:numberOfDimensions,1)+vector1(1:numberOfDimensions)
                    tangentXiIdx=OTHER_XI_DIRECTIONS3(ABS(xiCoordIdx),3,1)
                    vector2(1:numberOfDimensions)=dXdXi(1:numberOfDimensions,tangentXiIdx)
                    CALL Normalise(vector2(1:numberOfDimensions),vector2(1:numberOfDimensions),err,error,*999)
                    tangents(1:numberOfDimensions,2)=tangents(1:numberOfDimensions,2)+vector2(1:numberOfDimensions)
                    !Calculate the normal vector
                    CALL CrossProduct(vector1(1:numberOfDimensions),vector2(1:numberOfDimensions), &
                      & vector1(1:numberOfDimensions),err,error,*999)
                    !Yes below is compicated, but that's what it takes to get the normals pointing outwards
                    IF(xiCoordIdx<0) vector1=-vector1
                    IF(ABS(xiCoordIdx)==2) vector1=-vector1
                    normal(1:numberOfDimensions)=normal(1:numberOfDimensions)+vector1(1:numberOfDimensions)
                  CASE DEFAULT
                    !Should never happen anyway
                  END SELECT
                  numberOfElements=numberOfElements+1
                ENDIF
              ENDIF
            ENDDO !xiCoordIdx
          CASE(BASIS_SIMPLEX_TYPE)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(BASIS_SERENDIPITY_TYPE)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(BASIS_AUXILLIARY_TYPE)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(BASIS_B_SPLINE_TP_TYPE)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(BASIS_EXTENDED_LAGRANGE_TP_TYPE)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The basis type of "//TRIM(NumberToVString(basis%type,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          !Node is internal to the mesh. Assign zero normal and compute tangents only
          DO tangentIdx=1,numberOfXi
            vector1(1:numberOfDimensions)=dXdXi(1:numberOfDimensions,tangentIdx)
            CALL Normalise(vector1(1:numberOfDimensions),vector1(1:numberOfDimensions),err,error,*999)
            tangents(1:numberOfDimensions,tangentIdx)=tangents(1:numberOfDimensions,tangentIdx)+vector1(1:numberOfDimensions)
          ENDDO !tangentIdx
          numberOfElements=numberOfElements+1
        ENDIF
      ENDDO !elementIdx
      
      !Normalise the normal vector
      IF(numberOfElements>0) normal(1:numberOfDimensions)=normal(1:numberOfDimensions)/REAL(numberOfElements,DP)
      CALL Normalise(normal(1:numberOfDimensions),normal(1:numberOfDimensions),err,error,*999)
      !Normalise the tangent vectors
      DO tangentIdx=1,numberOfXi-1
        IF(numberOfElements>0) &
          & tangents(1:numberOfDimensions,tangentIdx)=tangents(1:numberOfDimensions,tangentIdx)/REAL(numberOfElements,DP)
        CALL Normalise(tangents(1:numberOfDimensions,tangentIdx),tangents(1:numberOfDimensions,tangentIdx),err,error,*999)
      ENDDO !tangentIdx
      
      CALL Field_InterpolatedPointFinalise(interpolatedPoint,err,error,*999)
      CALL FieldVariable_InterpolationParameterFinalise(interpolationParameters,err,error,*999)

    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      localError="Cannot compute the normal at a node for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" for variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " which has grid point based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      localError="Cannot compute the normal at a node for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" for variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " which has Gauss point based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      localError="Cannot compute the normal at a node for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" for variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " which has data point based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE DEFAULT
      localError="The interpolation type of "//TRIM(NumberToVString &
        & (fieldVariable%components(componentNumber)%interpolationType,"*",err,error))// &
        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*", &
        & err,error))//" for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
 
    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Field normal at a node:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number      = ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Variable type     = ",variableType,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Component number  = ",componentNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Local node number = ",localNodeNumber,err,error,*999)
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,3,3,position, &
        & '("  Position          :",3(X,E13.6))','(21X,3(X,E13.6))',err,error,*999)      
      CALL WriteStringVector(DIAGNOSTIC_OUTPUT_TYPE,1,1,numberOfDimensions,3,3,normal, &
        & '("  Normal            :",3(X,E13.6))','(21X,3(X,E13.6))',err,error,*999)      
    ENDIF

    EXITS("Field_PositionNormalTangentsCalculateNode")
    RETURN
999 ERRORS("Field_PositionNormalTangentsCalculateNode",err,error)
    EXITS("Field_PositionNormalTangentsCalculateNode")
    RETURN 1

  END SUBROUTINE Field_PositionNormalTangentsCalculateNode

  !
  !================================================================================================================================
  !

  !>Finalises the scaling for a field scaling index and deallocates all memory.
  SUBROUTINE Field_ScalingFinalise(field,scalingIndex,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to finalise the scalings for
    INTEGER(INTG), INTENT(IN) :: scalingIndex !<The scaling index to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
 
    ENTERS("Field_ScalingFinalise",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(scalingIndex<1.OR.scalingIndex>field%scalings%numberOfScalingIndices) THEN
      localError="The specified scaling index of "//TRIM(NumberToVString(scalingIndex,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & ". The scaling index should be >= 1 and <= "// &
        & TRIM(NumberToVString(field%scalings%numberOfScalingIndices,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)      
    ENDIF
    IF(.NOT.ALLOCATED(field%scalings%scalings)) THEN
      localError="The field scalings is not allocated for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(ASSOCIATED(field%scalings%scalings(scalingIndex)%scaleFactors)) &
      & CALL DistributedVector_Destroy(field%scalings%scalings(scalingIndex)%scaleFactors,err,error,*999)

    EXITS("Field_ScalingFinalise")
    RETURN
999 ERRORSEXITS("Field_ScalingFinalise",err,error)
    RETURN 1

  END SUBROUTINE Field_ScalingFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the scalings for a field scaling index corresponding to a mesh component index.
  SUBROUTINE Field_ScalingInitialise(field,scalingIndex,meshComponentNumber,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the scaling for
    INTEGER(INTG), INTENT(IN) :: scalingIndex !<The scaling index to initialise
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to initialise for the scaling
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainMappingType), POINTER :: dofsMapping
    TYPE(DomainMappingsType), POINTER :: domainMappings
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ScalingInitialise",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(scalingIndex<1.OR.scalingIndex>field%scalings%numberOfScalingIndices) THEN
      localError="The scaling index of "//TRIM(NumberToVString(scalingIndex,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " which has "//TRIM(NumberToVString(field%SCALINGS%numberOfScalingIndices,"*",err,error))// &
        & " scaling indices."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    IF(meshComponentNumber<1.OR.meshComponentNumber>decomposition%numberOfComponents) THEN
      localError="The mesh component number of "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " which is associated with a mesh which has "//TRIM(NumberToVString(decomposition%numberOfComponents,"*",err,error))// &
        & " mesh components."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(domain)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    NULLIFY(domainElements)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    NULLIFY(domainNodes)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    field%scalings%scalings(scalingIndex)%meshComponentNumber=meshComponentNumber
    field%scalings%scalings(scalingIndex)%maxNumberOfElementParameters=domainElements%maximumNumberOfElementParameters
    field%scalings%scalings(scalingIndex)%maximumNumberOfDerivatives=domainNodes%maximumNumberOfDerivatives
    NULLIFY(field%scalings%scalings(scalingIndex)%scaleFactors)
    SELECT CASE(field%scalings%scalingType)
    CASE(FIELD_NO_SCALING)
      !Do nothing
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      !ALLOCATE(field%scalings%scalings(scalingIndex)%scaleFactors(field%scalings%scalings(scalingIndex)% &
      !  & maximumNumberOfDerivatives,domainNodes%totalNumberOfNodes),STAT=err)
      !IF(err/=0) CALL FlagError("Could not allocate scale factors",err,error,*999)
      !field%scalings%scalings(scalingIndex)%scaleFactors=1.0_DP
      NULLIFY(domainMappings)
      CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)
      NULLIFY(dofsMapping)
      CALL DomainMappings_DOFSMappingGet(domainMappings,dofsMapping,err,error,*999)
      CALL DistributedVector_CreateStart(dofsMapping,field%scalings%scalings(scalingIndex)%scaleFactors,err,error,*999)
      CALL DistributedVector_DataTypeSet(field%scalings%scalings(scalingIndex)%scaleFactors,DISTRIBUTED_MATRIX_VECTOR_DP_TYPE, &
        & err,error,*999)
      CALL DistributedVector_CreateFinish(field%scalings%scalings(scalingIndex)%scaleFactors,err,error,*999)
      IF(field%TYPE==FIELD_GEOMETRIC_TYPE) THEN
        !Initialise the scalings to 1.0 for a geometric field. Other field types will be setup in Field_ScalingsCalculate
        CALL DistributedVector_AllValuesSet(field%scalings%scalings(scalingIndex)%scaleFactors,1.0_DP,err,error,*999)
      ENDIF
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%scalings%scalingType,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ScalingInitialise")
    RETURN
999 ERRORSEXITS("Field_ScalingInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ScalingInitialise

  !
  !================================================================================================================================
  !

  !>Calculates the scale factors from the geometric field associated with the field.
  SUBROUTINE Field_ScalingsCalculate(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to calculate the scalings for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: meshComponentNumber,xiDirection,xiIdx1,xiIdx2,versionIdx,derivativeIdx,derivativeIdx2,firstNodeIdx, &
      & lineXiDirection,localNodeLineIdx,adjacentLocalNodeLineIdx,nodeLineIdx,nodeIdx,numberOfNodes,numberOfNodeDerivatives, &
      & numberOfNodeLines,numberOfVersions,partialDerivativeIdx,partialDerivativeIdx1,partialDerivativeIdx2, &
      & partialDerivativeIdx3,dofIdx,dofIdx1,dofIdx2,dofIdx3,scalingIdx
    REAL(DP) :: length1,length2,meanLength,temp,numberOfLineVersions1,numberOfLineVersions2,value
    REAL(DP), POINTER :: scaleFactors(:)
    LOGICAL :: found
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionLinesType), POINTER :: decompositionLines
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainLinesType), POINTER :: domainLines
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: geometricField
    TYPE(FieldGeometricParametersType), POINTER :: geometricParameters
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ScalingsCalculate",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)

    NULLIFY(geometricField)
    CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
    SELECT CASE(field%scalings%scalingType)
    CASE(FIELD_NO_SCALING)
      !Do nothing
      NULLIFY(domain)
    CASE(FIELD_UNIT_SCALING)
      DO scalingIdx=1,field%scalings%numberOfScalingIndices
        CALL DistributedVector_AllValuesSet(field%scalings%scalings(scalingIdx)%scaleFactors,1.0_DP,err,error,*999)
        CALL DistributedVector_UpdateStart(field%scalings%scalings(scalingIdx)%scaleFactors,err,error,*999)
        CALL DistributedVector_UpdateFinish(field%scalings%scalings(scalingIdx)%scaleFactors,err,error,*999)
      ENDDO !scalingIdx
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(field,decomposition,err,error,*999)
      NULLIFY(decompositionTopology)
      CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
      NULLIFY(decompositionLines)
      IF(decomposition%calculateLines) &
        & CALL DecompositionTopology_DecompositionLinesGet(decompositionTopology,decompositionLines,err,error,*999)
      NULLIFY(geometricParameters)
      CALL Field_GeometricParametersGet(geometricField,geometricParameters,err,error,*999)
      DO scalingIdx=1,field%scalings%numberOfScalingIndices
        meshComponentNumber=field%scalings%scalings(scalingIdx)%meshComponentNumber
        NULLIFY(domain)
        CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
        NULLIFY(domainTopology)
        CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
        NULLIFY(domainNodes)
        CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
        NULLIFY(decompositionTopology)
        NULLIFY(decompositionLines)
        NULLIFY(domainLines)
        IF(decomposition%calculateLines) THEN
          CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
          CALL DecompositionTopology_DecompositionLinesGet(decompositionTopology,decompositionLines,err,error,*999)
          CALL DomainTopology_DomainLinesGet(domainTopology,domainLines,err,error,*999)
        ENDIF
        NULLIFY(scaleFactors)
        CALL DistributedVector_DataGet(field%scalings%scalings(scalingIdx)%scaleFactors,scaleFactors,err,error,*999)
        CALL DomainNodes_NumberOfNodesGet(domainNodes,numberOfNodes,err,error,*999)
        DO nodeIdx=1,numberOfNodes
          CALL DomainNodes_NodeNumberOfDerivativesGet(domainNodes,nodeIdx,numberOfNodeDerivatives,err,error,*999)
          DO derivativeIdx=1,numberOfNodeDerivatives
            CALL DomainNodes_DerivativeNumberOfVersionsGet(domainNodes,derivativeIdx,nodeIdx,numberOfVersions,err,error,*999)
            CALL DomainNodes_DerivativePartialIndexGet(domainNodes,derivativeIdx,nodeIdx,partialDerivativeIdx,err,error,*999)
            SELECT CASE(partialDerivativeIdx)
            CASE(NO_PART_DERIV)
              DO versionIdx=1,numberOfVersions
!!TODO: this needs to be fixed when dof indicies are removed.
                dofIdx=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%dofIndex(versionIdx)
                CALL DistributedVector_ValuesSet(field%scalings%scalings(scalingIdx)%scaleFactors,dofIdx,1.0_DP,err,error,*999)
              ENDDO !verionsIdx
            CASE(PART_DERIV_S1,PART_DERIV_S2,PART_DERIV_S3)
              IF(decomposition%calculateLines) THEN
                IF(partialDerivativeIdx==PART_DERIV_S1) THEN
                  xiDirection=1
                ELSE IF(partialDerivativeIdx==PART_DERIV_S2) THEN
                  xiDirection=2
                ELSE
                  xiDirection=3
                ENDIF
                length1 = 0.0_DP
                length2 = 0.0_DP
                numberOfLineVersions1 = 0.0_DP
                numberOfLineVersions2 = 0.0_DP
                DO versionIdx=1,numberOfVersions
                  !Find a line of the correct Xi direction going through this node
                  CALL DomainNodes_NodeNumberOfLinesGet(domainNodes,nodeIdx,numberOfNodeLines,err,error,*999)
                  found=.FALSE.                  
                  DO nodeLineIdx=1,numberOfNodeLines
                    CALL DomainNodes_NodeLineNumberGet(domainNodes,nodeLineIdx,nodeIdx,localNodeLineIdx,err,error,*999)
                    CALL DecompositionLines_LineXiDirectionGet(decompositionLines,localNodeLineIdx,lineXiDirection,err,error,*999)
                    IF(lineXiDirection==xiDirection) THEN
                      found=.TRUE.
                      EXIT
                    ENDIF
                  ENDDO !nodeLineIdx
                  IF(.NOT.found) THEN
                    localError="Could not find a line in the Xi "//TRIM(NumberToVString(xiDirection,"*",err,error))// &
                      & " direction going through node number "//TRIM(NumberToVString(nodeIdx,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                  CALL DomainLines_LineNodeNumberGet(domainLines,1,localNodeLineIdx,firstNodeIdx,err,error,*999)
                  IF(firstNodeIdx==nodeIdx) THEN !Current node at the beginning of the line
                    CALL DecompositionLines_LineAdjacentLineNumberGet(decompositionLines,DECOMPOSITION_MINUS_XI_DIRECTION, &
                      & localNodeLineIdx,adjacentLocalNodeLineIdx,err,error,*999)
                  ELSE !Current node at the end of the line
                    CALL DecompositionLines_LineAdjacentLineNumberGet(decompositionLines,DECOMPOSITION_PLUS_XI_DIRECTION, &
                      & localNodeLineIdx,adjacentLocalNodeLineIdx,err,error,*999)
                  ENDIF
                  !Average line lengths for the different versions (division by the number of lines is done after all the
                  !line lengths are added together)                    
                  length1=length1+geometricParameters%lengths(localNodeLineIdx)
                  numberOfLineVersions1=numberOfLineVersions1+1
                  IF(adjacentLocalNodeLineIdx/=0) THEN !Adjacent node and therefore lines exist
                    length2=length2+geometricParameters%lengths(adjacentLocalNodeLineIdx)
                    numberOfLineVersions2=numberOfLineVersions2+1
                  ENDIF
                ENDDO !versionIdx
                !Division by the numer of version for this node derivative, completing the calculation for the average line lengths
                length1 = length1/numberOfLineVersions1
                IF(adjacentLocalNodeLineIdx==0) THEN !No adjacent node ie end of mesh 
                  meanLength=length1
                ELSE !Adjacent node and therefore lines exist
                  length2 = length2/numberOfLineVersions2
                  SELECT CASE(field%scalings%scalingType)
                  CASE(FIELD_ARITHMETIC_MEAN_SCALING)
                    meanLength=(length1+length2)/2.0_DP
                  CASE(FIELD_GEOMETRIC_MEAN_SCALING)
                    meanLength=SQRT(length1*length2)
                  CASE(FIELD_HARMONIC_MEAN_SCALING)
                    temp=length1*length2
                    IF(ABS(temp)>ZERO_TOLERANCE) THEN
                      meanLength=2.0_DP*temp/(length1+length2)
                    ELSE
                      meanLength=0.0_DP
                    ENDIF
                  CASE DEFAULT
                    localError="The scaling type of "//TRIM(NumberToVString(field%scalings%scalingType,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                ENDIF
                DO versionIdx=1,numberOfVersions
!!TODO: this needs to be fixed when dof indicies are removed.
                 dofIdx=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%dofIndex(versionIdx)
                  CALL DistributedVector_ValuesSet(field%scalings%scalings(scalingIdx)%scaleFactors,dofIdx,meanLength, &
                    & err,error,*999)
                ENDDO !versionIdx
              ENDIF
            CASE(PART_DERIV_S1_S2,PART_DERIV_S1_S3,PART_DERIV_S2_S3,PART_DERIV_S1_S2_S3)
              DO versionIdx=1,numberOfVersions
!!TODO: this needs to be fixed when dof indicies are removed.
                dofIdx=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%dofIndex(versionIdx)
                IF(partialDerivativeIdx==PART_DERIV_S1_S2) THEN
                  xiIdx1=1
                  partialDerivativeIdx1=PART_DERIV_S1
                  xiIdx2=2
                  partialDerivativeIdx2=PART_DERIV_S2
                ELSE IF(partialDerivativeIdx==PART_DERIV_S1_S3) THEN
                  xiIdx1=1
                  partialDerivativeIdx1=PART_DERIV_S1
                  xiIdx2=3
                  partialDerivativeIdx2=PART_DERIV_S3
                ELSE IF(partialDerivativeIdx==PART_DERIV_S2_S3) THEN
                  xiIdx1=2
                  partialDerivativeIdx1=PART_DERIV_S2
                  xiIdx2=3
                  partialDerivativeIdx2=PART_DERIV_S3
                ELSE
                  xiIdx1=1
                  partialDerivativeIdx1=PART_DERIV_S1
                  xiIdx2=2
                  partialDerivativeIdx2=PART_DERIV_S2
                ENDIF
!!TODO: Shouldn't have to search for the derivativeIdx directions. Store them somewhere.
                !Find the first direction derivativeIdx
                found=.FALSE.
                DO derivativeIdx2=1,numberOfNodeDerivatives
                  CALL DomainNodes_DerivativePartialIndexGet(domainNodes,derivativeIdx2,nodeIdx,partialDerivativeIdx3, &
                    & err,error,*999)
                 IF(partialDerivativeIdx3==partialDerivativeIdx1) THEN
!!TODO: this needs to be fixed when dof indicies are removed.
                    dofIdx1=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx2)%dofIndex(versionIdx)
                    found=.TRUE.
                    EXIT
                  ENDIF
                ENDDO !derivativeIdx2
                IF(.NOT.found) THEN
                  localError="Could not find the first partial derivative in the s"// &
                    & TRIM(NumberToVString(xiIdx1,"*",err,error))//" direction index for "//&
                    & "local node number "//TRIM(NumberToVString(nodeIdx,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
                !Find the second direction derivativeIdx
                found=.FALSE.
                DO derivativeIdx2=1,numberOfNodeDerivatives
                  CALL DomainNodes_DerivativePartialIndexGet(domainNodes,derivativeIdx2,nodeIdx,partialDerivativeIdx3, &
                    & err,error,*999)
                  IF(partialDerivativeIdx3==partialDerivativeIdx2) THEN
!!TODO: this needs to be fixed when dof indicies are removed.
                    dofIdx2=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx2)%dofIndex(versionIdx)
                    found=.TRUE.
                    EXIT
                  ENDIF
                ENDDO !derivativeIdx2
                IF(.NOT.found) THEN
                  localError="Could not find the first partial derivative in the s"// &
                    & TRIM(NumberToVString(xiIdx2,"*",err,error))//" direction index for "//&
                    & "local node number "//TRIM(NumberToVString(nodeIdx,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
                IF(partialDerivativeIdx==PART_DERIV_S1_S2_S3) THEN
                  !Find the third direction derivativeIdx
                  found=.FALSE.
                  DO derivativeIdx2=1,numberOfNodeDerivatives
                   CALL DomainNodes_DerivativePartialIndexGet(domainNodes,derivativeIdx2,nodeIdx,partialDerivativeIdx3, &
                    & err,error,*999)
                   IF(partialDerivativeIdx3==PART_DERIV_S3) THEN
!!TODO: this needs to be fixed when dof indicies are removed.
                      dofIdx3=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx2)%dofIndex(versionIdx)
                      found=.TRUE.
                      EXIT
                    ENDIF
                  ENDDO !derivativeIdx2
                  IF(.NOT.found) THEN
                    localError="Could not find the first partial derivative in the s3 direction index for "//&
                      & "local node number "//TRIM(NumberToVString(nodeIdx,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                  CALL DistributedVector_ValuesSet(field%scalings%scalings(scalingIdx)%scaleFactors,dofIdx, &
                    scaleFactors(dofIdx1)*scaleFactors(dofIdx2)*scaleFactors(dofIdx3),err,error,*999)
                ELSE
                  CALL DistributedVector_ValuesSet(field%scalings%scalings(scalingIdx)%scaleFactors,dofIdx, &
                    & scaleFactors(dofIdx1)*scaleFactors(dofIdx2),err,error,*999)
                ENDIF
              ENDDO !versionIdx
            CASE DEFAULT
              localError="The partial derivative index of "//TRIM(NumberToVString(partialDerivativeIdx,"*", &
                & err,error))//" for derivative number "//TRIM(NumberToVString(derivativeIdx,"*",err,error))// &
                & " of local node number "//TRIM(NumberToVString(nodeIdx,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !derivativeIdx
        ENDDO !nodeIdx
        CALL DistributedVector_UpdateStart(field%scalings%scalings(scalingIdx)%scaleFactors,err,error,*999)
        CALL DistributedVector_UpdateFinish(field%scalings%scalings(scalingIdx)%scaleFactors,err,error,*999)
      ENDDO !scalingIdx
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%scalings%scalingType,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
 
    IF(diagnostics1) THEN
      IF(field%scalings%scalingType /= FIELD_NO_SCALING) THEN
        CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Scale Factors:",err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"Scaling Type = ",field%scalings%scalingType,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"Number of scaling indices = ",field%scalings%numberOfScalingIndices, &
          & err,error,*999)
        DO scalingIdx=1,field%scalings%numberOfScalingIndices
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Scaling index : ",scalingIdx,err,error,*999)
          meshComponentNumber=field%scalings%scalings(scalingIdx)%meshComponentNumber
          NULLIFY(domain)
          CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
          NULLIFY(domainTopology)
          CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
          NULLIFY(domainNodes)
          CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Scale Factors for nodes in the domain:",err,error,*999)
          CALL DomainNodes_NumberOfNodesGet(domainNodes,numberOfNodes,err,error,*999)
          DO nodeIdx=1,numberOfNodes
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Node : ",nodeIdx,err,error,*999)
            CALL DomainNodes_NodeNumberOfDerivativesGet(domainNodes,nodeIdx,numberOfNodeDerivatives,err,error,*999)
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Number of Derivatives = ",numberOfNodeDerivatives,err,error,*999)
            DO derivativeIdx=1,numberOfNodeDerivatives
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Derivative : ",derivativeIdx,err,error,*999)
              CALL DomainNodes_DerivativeNumberOfVersionsGet(domainNodes,derivativeIdx,nodeIdx,numberOfVersions,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of Versions = ",numberOfVersions,err,error,*999)
              DO versionIdx=1,numberOfVersions
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Version : ",versionIdx,err,error,*999)
!!TODO: this needs to be fixed when dof indicies are removed.
                dofIdx=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%dofIndex(versionIdx)
                CALL DistributedVector_ValuesGet(field%scalings%scalings(scalingIdx)%scaleFactors,dofIdx,value,err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Scale Factor : ",value,err,error,*999)
              ENDDO !versionIdx
            ENDDO !derivativeIdx
          ENDDO !nodeIdx
        ENDDO !scalingIdx
      ENDIF
    ENDIF

    EXITS("Field_ScalingsCalculate")
    RETURN
999 ERRORSEXITS("Field_ScalingsCalculate",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ScalingsCalculate

  !
  !================================================================================================================================
  !

  !>Finalises the scalings for a field and deallocates all memory.
  SUBROUTINE Field_ScalingsFinalise(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to finalise the scalings for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx

    ENTERS("Field_ScalingsFinalise",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      DO scalingIdx=1,field%scalings%numberOfScalingIndices
        CALL Field_ScalingFinalise(field,scalingIdx,err,error,*999)
      ENDDO !scalingIdx
      IF(ALLOCATED(field%scalings%scalings)) DEALLOCATE(field%scalings%scalings)
    ENDIF

    EXITS("Field_ScalingsFinalise")
    RETURN
999 ERRORSEXITS("Field_ScalingsFinalise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ScalingsFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the scaling parameters sets for a field.
  SUBROUTINE Field_ScalingsInitialise(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the scalings for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,dummyErr,meshComponentNumber,numberOfMeshComponents,scalingIdx,variableIdx,variableType
    INTEGER(INTG), ALLOCATABLE :: meshComponents(:),meshComponentsMap(:)
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(ListType), POINTER :: meshComponentsList
    TYPE(VARYING_STRING) :: dummyError

    NULLIFY(meshComponentsList)

    ENTERS("Field_ScalingsInitialise",err,error,*997)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*997)

    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    
    !Calculate the mesh component numbers involved in the field
    CALL List_CreateStart(meshComponentsList,err,error,*999)
    CALL List_DataTypeSet(meshComponentsList,LIST_INTG_TYPE,err,error,*999)
    CALL List_InitialSizeSet(meshComponentsList,decomposition%numberOfComponents,err,error,*999)
    CALL List_CreateFinish(meshComponentsList,err,error,*999)
    DO variableIdx=1,field%numberOfVariables
      NULLIFY(fieldVariable)
      CALL Field_VariableIndexGet(field,variableIdx,fieldVariable,variableType,err,error,*999)
      DO componentIdx=1,fieldVariable%numberOfComponents
        CALL FieldVariable_ComponentMeshComponentGet(fieldVariable,componentIdx,meshComponentNumber,err,error,*999)
        CALL List_ItemAdd(meshComponentsList,meshComponentNumber,err,error,*999)
      ENDDO !componentIdx
    ENDDO !variableIdx
    CALL List_RemoveDuplicates(meshComponentsList,err,error,*999)
    CALL List_DetachAndDestroy(meshComponentsList,numberOfMeshComponents,meshComponents,err,error,*999)
    ALLOCATE(meshComponentsMap(decomposition%numberOfComponents),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate mesh components map.",err,error,*999)
    meshComponentsMap=0
    DO componentIdx=1,numberOfMeshComponents
      meshComponentsMap(meshComponents(componentIdx))=componentIdx
    ENDDO !componentIdx
    !Allocate the scaling indices and initialise them
    field%scalings%numberOfScalingIndices=numberOfMeshComponents
    ALLOCATE(field%scalings%scalings(field%scalings%numberOfScalingIndices),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate field scalings.",err,error,*999)
    DO scalingIdx=1,field%scalings%numberOfScalingIndices
      CALL Field_ScalingInitialise(field,scalingIdx,meshComponents(scalingIdx),err,error,*999)
    ENDDO !scalingIdx
    !Set the scaling index for all the field variable components
    DO variableIdx=1,field%numberOfVariables
      NULLIFY(fieldVariable)
      CALL Field_VariableIndexGet(field,variableIdx,fieldVariable,variableType,err,error,*999)
      DO componentIdx=1,fieldVariable%numberOfComponents
        fieldVariable%components(componentIdx)%scalingIndex= &
          & meshComponentsMap(fieldVariable%components(componentIdx)%meshComponentNumber)
      ENDDO !componentIdx
    ENDDO !variableIdx
    DEALLOCATE(meshComponents)
    IF(field%type/=FIELD_GEOMETRIC_TYPE) CALL Field_ScalingsCalculate(field,err,error,*999)

    EXITS("Field_ScalingsInitialise")
    RETURN
999 IF(ALLOCATED(meshComponents)) DEALLOCATE(meshComponents)
    IF(ASSOCIATED(meshComponentsList)) CALL List_Destroy(meshComponentsList,dummyErr,dummyError,*998)
998 CALL Field_ScalingsFinalise(field,dummyErr,dummyError,*997)
997 ERRORSEXITS("Field_ScalingsInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ScalingsInitialise

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field. \see OpenCMISS::Iron::cmfe_FieldScalingTypeSet
  SUBROUTINE Field_ScalingTypeSet(field,scalingType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the scaling type for
    INTEGER(INTG), INTENT(IN) :: scalingType !<The scaling type to set \see FieldRoutines_ScalingTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ScalingTypeSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(field%createValuesCache%scalingTypeLocked) THEN
      localError="The field scaling type has been locked for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    SELECT CASE(scalingType)
    CASE(FIELD_NO_SCALING)
      field%scalings%scalingType=FIELD_NO_SCALING
    CASE(FIELD_UNIT_SCALING)
      field%scalings%scalingType=FIELD_UNIT_SCALING
    CASE(FIELD_ARC_LENGTH_SCALING)
      field%scalings%scalingType=FIELD_ARC_LENGTH_SCALING
    CASE(FIELD_ARITHMETIC_MEAN_SCALING)
      field%scalings%scalingType=FIELD_ARITHMETIC_MEAN_SCALING
    CASE(FIELD_GEOMETRIC_MEAN_SCALING)
      field%scalings%scalingType=FIELD_GEOMETRIC_MEAN_SCALING
    CASE(FIELD_HARMONIC_MEAN_SCALING)
      field%scalings%scalingType=FIELD_HARMONIC_MEAN_SCALING
    CASE DEFAULT
      localError="The specified scaling type of "//TRIM(NumberToVString(scalingType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ScalingTypeSet")
    RETURN
999 ERRORSEXITS("Field_ScalingTypeSet",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ScalingTypeSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field and locks it so that no further changes can be made.
  SUBROUTINE Field_ScalingTypeSetAndLock(field,scalingType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the scaling type for
    INTEGER(INTG), INTENT(IN) :: scalingType !<The scaling type to set \see FieldRoutines_ScalingTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_ScalingTypeSetAndLock",err,error,*999)

    CALL Field_ScalingTypeSet(field,scalingType,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%scalingTypeLocked=.TRUE.

    EXITS("Field_ScalingTypeSetAndLock")
    RETURN
999 ERRORSEXITS("Field_ScalingTypeSetAndLock",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ScalingTypeSetAndLock

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field. \see OpenCMISS::Iron::cmfe_FieldTypeSet
  SUBROUTINE Field_TypeSet(field,TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: TYPE !<The field type to set \see FieldRoutines_FieldTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_TypeSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%typeLocked) THEN
      localError="The field type has been locked for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    SELECT CASE(TYPE)
    CASE(FIELD_GEOMETRIC_TYPE)
      field%type=FIELD_GEOMETRIC_TYPE
      field%geometricField=>field
    CASE(FIELD_FIBRE_TYPE)
      field%type=FIELD_FIBRE_TYPE
      NULLIFY(field%geometricField)
    CASE(FIELD_GENERAL_TYPE)
      field%type=FIELD_GENERAL_TYPE
      NULLIFY(field%geometricField)
    CASE(FIELD_MATERIAL_TYPE)
      field%type=FIELD_MATERIAL_TYPE
      NULLIFY(field%geometricField)
    CASE(FIELD_GEOMETRIC_GENERAL_TYPE)
      field%type=FIELD_GEOMETRIC_GENERAL_TYPE
      NULLIFY(field%geometricField)
    CASE DEFAULT
      localError="The specified field type of "//TRIM(NumberToVString(type,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_TypeSet")
    RETURN
999 ERRORSEXITS("Field_TypeSet",err,error)
    RETURN 1
    
  END SUBROUTINE Field_TypeSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field and locks it so that no further changes can be made.
  SUBROUTINE Field_TypeSetAndLock(field,type,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: type !<The field type to set \see FieldRoutines_FieldTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_TypeSetAndLock",err,error,*999)

    CALL Field_TypeSet(field,type,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%typeLocked=.TRUE.

    EXITS("Field_TypeSetAndLock")
    RETURN
999 ERRORSEXITS("Field_TypeSetAndLock",err,error)
    RETURN 1
    
  END SUBROUTINE Field_TypeSetAndLock

  !
  !================================================================================================================================
  !

  !>Finalises a field variable and deallocates all memory.
  SUBROUTINE Field_VariableFinalise(fieldVariable,err,error,*)

    !Argument variables
    TYPE(FieldVariableType) :: fieldVariable !<The field variable to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_VariableFinalise",err,error,*999)

    fieldVariable%variableLabel=""
    CALL FieldVariable_ComponentsFinalise(fieldVariable,err,error,*999)
    CALL DomainMapping_Finalise(fieldVariable%domainMapping,err,error,*999)
    CALL Field_DofToParamMapFinalise(fieldVariable%dofToParamMap,err,error,*999)
    CALL Field_ParameterSetsFinalise(fieldVariable,err,error,*999)
    
    EXITS("Field_VariableFinalise")
    RETURN
999 ERRORSEXITS("Field_VariableFinalise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariableFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a field variable.
  SUBROUTINE Field_VariableInitialise(field,variableNumber,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the variable for
    INTEGER(INTG), INTENT(IN) :: variableNumber !<The variable number of the field to initialise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,dummyErr,variableType
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: dummyError,localError

    ENTERS("Field_VariableInitialise",err,error,*998)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*998)
    
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(variableNumber<1.OR.variableNumber>field%numberOfVariables) THEN
      localError="Variable number "//TRIM(NumberToVString(variableNumber,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" which has "// &
        & TRIM(NumberToVString(field%numberOfVariables,"*",err,error))//" variables."
      CALL FlagError(localError,err,error,*998)
    ENDIF
      
    NULLIFY(field%variables(variableNumber)%field)
    NULLIFY(field%variables(variableNumber)%region)
    NULLIFY(field%variables(variableNumber)%domainMapping)
!!TODO this should be done via a field_parameter_sets_initialise call
    NULLIFY(field%variables(variableNumber)%parameterSets%setType)
    NULLIFY(field%variables(variableNumber)%parameterSets%parameterSets)
    field%variables(variableNumber)%variableNumber=variableNumber
    variableType=createValuesCache%variableTypes(variableNumber)
    IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN      
      localError="A field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " for variable number "//TRIM(NumberToVString(variableNumber,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " is invalid. The number must be >= 1 and <= "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*998)
    ENDIF
    field%variables(variableNumber)%variableType=createValuesCache%variableTypes(variableNumber)
    field%variableTypeMap(field%variables(variableNumber)%variableType)%ptr=>field%variables(variableNumber)
    fieldVariable=>field%variableTypeMap(field%variables(variableNumber)%variableType)%ptr
    fieldVariable%variableLabel=""
    fieldVariable%variableLabel=createValuesCache%variableLabels(variableType)
    fieldVariable%field=>field
    fieldVariable%region=>field%region
    fieldVariable%dimension=field%createValuesCache%dimension(variableType)
    fieldVariable%dataType=createValuesCache%dataTypes(variableType)
    fieldVariable%dofOrderType=createValuesCache%dofOrderTypes(variableType)
    IF(createValuesCache%numberOfComponents(variableType)<=0) THEN
      localError="The number of components of "// &
        & TRIM(NumberToVString(createValuesCache%numberOfComponents(variableType),"*",err,error))// &
        & " for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " is invalid. The number must be > 0."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    fieldVariable%numberOfComponents=createValuesCache%numberOfComponents(variableType)
    CALL FieldVariable_ComponentsInitialise(field,variableType,err,error,*999)
    fieldVariable%maxNumberElementInterpolationParameters=-1
    fieldVariable%maxNumberNodeInterpolationParameters=-1
    DO componentIdx=1,fieldVariable%numberOfComponents
      IF(fieldVariable%components(componentIdx)%maxNumberElementInterpolationParameters> &
        & fieldVariable%maxNumberElementInterpolationParameters) fieldVariable% &
        & maxNumberElementInterpolationParameters=fieldVariable%components(componentIdx)% &
        & maxNumberElementInterpolationParameters
      IF(fieldVariable%components(componentIdx)%maxNumberNodeInterpolationParameters> &
        & fieldVariable%maxNumberNodeInterpolationParameters) fieldVariable% &
        & maxNumberNodeInterpolationParameters=fieldVariable%components(componentIdx)% &
        & maxNumberNodeInterpolationParameters
    ENDDO !componentIdx
    fieldVariable%numberOfDofs=0
    fieldVariable%totalNumberOfDofs=0
    fieldVariable%numberOfGlobalDofs=0
    CALL DomainMapping_Initialise(fieldVariable%domainMapping,err,error,*999)
    CALL Field_DofToParamMapInitialise(fieldVariable%dofToParamMap,err,error,*999)

    EXITS("Field_VariableInitialise")
    RETURN
999 CALL Field_VariableFinalise(fieldVariable,dummyErr,dummyError,*998)
998 ERRORSEXITS("Field_VariableInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariableInitialise

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels. \see OpenCMISS::Iron::cmfe_Field_VariableLabelSet
  SUBROUTINE Field_VariableLabelSetC(field,variableType,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_VariableLabelSetC",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)    
    IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " is invalid. The variable type must be >= 1 and <= "// &              
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ANY(field%createValuesCache%variableTypes==variableType)) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " has not been created on field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(createValuesCache%variableLabelsLocked(variableType)) THEN
      localError="The field variable label has been locked for for variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    createValuesCache%variableLabels(variableType)=label

    EXITS("Field_VariableLabelSetC")
    RETURN
999 ERRORSEXITS("Field_VariableLabelSetC",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariableLabelSetC

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels. \see OpenCMISS::Iron::cmfe_Field_VariableLabelSet
  SUBROUTINE Field_VariableLabelSetVS(field,variableType,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_VariableLabelSetVS",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)    
    IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " is invalid. The variable type must be >= 1 and <= "// &              
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ANY(field%createValuesCache%variableTypes==variableType)) THEN
      localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " has not been created on field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(createValuesCache%variableLabelsLocked(variableType)) THEN
      localError="The field variable label has been locked for for variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    createValuesCache%variableLabels(variableType)=label

    EXITS("Field_VariableLabelSetVS")
    RETURN
999 ERRORSEXITS("Field_VariableLabelSetVS",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariableLabelSetVS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels and locks so that no further changes can be made.
  SUBROUTINE Field_VariableLabelSetAndLockC(field,variableType,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_VariableLabelSetAndLockC",err,error,*999)

    CALL Field_VariableLabelSet(field,variableType,label,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%variableLabelsLocked(variableType)=.TRUE.

    EXITS("Field_VariableLabelSetAndLockC")
    RETURN
999 ERRORSEXITS("Field_VariableLabelSetAndLockC",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariableLabelSetAndLockC

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels and locks so that no further changes can be made.
  SUBROUTINE Field_VariableLabelSetAndLockVS(field,variableType,label,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type \see FieldRoutines_VariableTypes,FieldRoutines 
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_VariableLabelSetAndLockVS",err,error,*999)

    CALL Field_VariableLabelSet(field,variableType,label,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%variableLabelsLocked(variableType)=.TRUE.

    EXITS("Field_VariableLabelSetAndLockVS")
    RETURN
999 ERRORSEXITS("Field_VariableLabelSetAndLockVS",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariableLabelSetAndLockVS

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field. \see OpenCMISS::Iron::cmfe_Field_VariableTypesSet
  SUBROUTINE Field_VariableTypesSet0(field,variableType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    
    ENTERS("Field_VariableTypesSet0",err,error,*999)

    CALL Field_VariableTypesSet1(field,[variableType],err,error,*999)

    EXITS("Field_VariableTypesSet0")
    RETURN
999 ERRORSEXITS("Field_VariableTypesSet0",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariableTypesSet0

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field. \see OpenCMISS::Iron::cmfe_Field_VariableTypesSet
  SUBROUTINE Field_VariableTypesSet1(field,variableTypes,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variableIdx). The field variable type for the variableIdx'th field variable to set 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: numberOfComponents,oldVariableType,variableIdx,variableIdx2,variableType
    INTEGER(INTG) :: oldDimension(FIELD_NUMBER_OF_VARIABLE_TYPES),oldDataTypes(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & oldDOFOrderTypes(FIELD_NUMBER_OF_VARIABLE_TYPES),oldNumberOfComponents(FIELD_NUMBER_OF_VARIABLE_TYPES)
    INTEGER(INTG), ALLOCATABLE :: oldVariableTypes(:),oldInterpolationType(:,:),oldMeshComponentNumber(:,:)
    LOGICAL :: oldDimensionLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),oldDataTypesLocked(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & oldDOFOrderTypesLocked(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & oldNumberOfComponentsLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),oldLabelsLocked(FIELD_NUMBER_OF_VARIABLE_TYPES)
    LOGICAL, ALLOCATABLE :: oldInterpolationTypeLocked(:,:),oldMeshComponentNumberLocked(:,:)
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError,oldLabels(FIELD_NUMBER_OF_VARIABLE_TYPES)

    ENTERS("Field_VariableTypesSet1",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)   
    IF(createValuesCache%variableTypesLocked) THEN
      localError="The field variable types has been locked for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(variableTypes,1)/=field%numberOfVariables) THEN
      localError="Invalid variable types. The size of the specified variable types array is "// &
        & TRIM(NumberToVString(SIZE(variableTypes,1),"*",err,error))// &
        & " and the number of variables for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " is "//TRIM(NumberToVString(field%numberOfVariables,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    DO variableIdx=1,field%numberOfVariables
      variableType=variableTypes(variableIdx)
      !Check that the variable type is in range
      IF(variableType<1.OR.variableType>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
          & " at position number "//TRIM(NumberToVString(variableIdx,"*",err,error))// &
          & " is invalid. The variable type must be >= 1 and <= "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)                  
      ENDIF
      !Check that the variable type is not repeated
      DO variableIdx2=variableIdx+1,field%numberOfVariables
        IF(variableTypes(variableIdx2)==variableType) THEN
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " occurs at position number "//TRIM(NumberToVString(variableIdx,"*",err,error))// &
            & " and position number "//TRIM(NumberToVString(variableIdx2,"*",err,error))// &
            & ". The variable types must be unique."
          CALL FlagError(localError,err,error,*999)                    
        ENDIF
      ENDDO !variableIdx2
    ENDDO !variableIdx
    numberOfComponents=SIZE(createValuesCache%interpolationTypes,1)
    ALLOCATE(oldVariableTypes(field%numberOfVariables),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate old variable types.",err,error,*999)
    ALLOCATE(oldInterpolationType(numberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate old interpolation type.",err,error,*999)
    ALLOCATE(oldInterpolationTypeLocked(numberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate old interpolation type locked.",err,error,*999)
    ALLOCATE(oldMeshComponentNumber(numberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate old mesh component number.",err,error,*999)
    ALLOCATE(oldMeshComponentNumberLocked(numberOfComponents,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate old mesh component number locked.",err,error,*999)
    oldVariableTypes(1:field%numberOfVariables)=createValuesCache%variableTypes(1:field%numberOfVariables)
    oldLabels=createValuesCache%variableLabels
    oldLabelsLocked=createValuesCache%variableLabelsLocked
    oldDimension=createValuesCache%dimension
    oldDimensionLocked=createValuesCache%dimensionLocked
    oldDataTypes=createValuesCache%dataTypes
    oldDataTypesLocked=createValuesCache%dataTypesLocked
    oldDOFOrderTypes=createValuesCache%dofOrderTypes
    oldDOFOrderTypesLocked=createValuesCache%dofOrderTypesLocked
    oldNumberOfComponents=createValuesCache%numberOfComponents
    oldNumberOfComponentsLocked=createValuesCache%numberOfComponentsLocked
    oldInterpolationType(1:numberOfComponents,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
      & createValuesCache%interpolationTypes(1:numberOfComponents,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
    oldInterpolationTypeLocked(1:numberOfComponents,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
      & createValuesCache%interpolationTypesLocked(1:numberOfComponents,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
    oldMeshComponentNumber(1:numberOfComponents,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
      & createValuesCache%meshComponentNumber(1:numberOfComponents,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
    oldMeshComponentNumberLocked(1:numberOfComponents,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
      & createValuesCache%meshComponentNumberLocked(1:numberOfComponents,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
    createValuesCache%variableTypes=0
    createValuesCache%variableLabels=""
    createValuesCache%variableLabelsLocked=.FALSE.
    createValuesCache%dimension=0
    createValuesCache%dimensionLocked=.FALSE.
    createValuesCache%dataTypes=0
    createValuesCache%dataTypesLocked=.FALSE.
    createValuesCache%dofOrderTypes=0
    createValuesCache%dofOrderTypesLocked=.FALSE.
    createValuesCache%numberOfComponents=0
    createValuesCache%numberOfComponentsLocked=.FALSE.
    createValuesCache%interpolationTypes=0
    createValuesCache%interpolationTypesLocked=.FALSE.
    createValuesCache%meshComponentNumber=0
    createValuesCache%meshComponentNumberLocked=.FALSE.
    DO variableIdx=1,field%numberOfVariables                
      variableType=variableTypes(variableIdx)
      oldVariableType=oldVariableTypes(variableIdx)
      createValuesCache%variableLabels(variableType)=oldLabels(oldVariableType)
      createValuesCache%variableLabelsLocked(variableType)=oldLabelsLocked(oldVariableType)
      createValuesCache%dimension(variableType)=oldDimension(oldVariableType)
      createValuesCache%dimensionLocked(variableType)=oldDimensionLocked(oldVariableType)
      createValuesCache%dataTypes(variableType)=oldDataTypes(oldVariableType)
      createValuesCache%dataTypesLocked(variableType)=oldDataTypesLocked(oldVariableType)
      createValuesCache%dofOrderTypes(variableType)=oldDOFOrderTypes(oldVariableType)
      createValuesCache%dofOrderTypesLocked(variableType)=oldDOFOrderTypesLocked(oldVariableType)
      createValuesCache%numberOfComponents(variableType)=oldNumberOfComponents(oldVariableType)
      createValuesCache%numberOfComponentsLocked(variableType)=oldNumberOfComponentsLocked(oldVariableType)
      createValuesCache%interpolationTypes(:,variableType)=oldInterpolationType(:,oldVariableType)
      createValuesCache%interpolationTypesLocked(:,variableType)=oldInterpolationTypeLocked(:,oldVariableType)
      createValuesCache%meshComponentNumber(:,variableType)=oldMeshComponentNumber(:,oldVariableType)
      createValuesCache%meshComponentNumberLocked(:,variableType)=oldMeshComponentNumberLocked(:,oldVariableType)
    ENDDO !variableIdx
    createValuesCache%variableTypes(1:SIZE(variableTypes,1))=variableTypes(1:SIZE(variableTypes,1))
    DEALLOCATE(oldVariableTypes)
    DEALLOCATE(oldInterpolationType)
    DEALLOCATE(oldInterpolationTypeLocked)
    DEALLOCATE(oldMeshComponentNumber)
    DEALLOCATE(oldMeshComponentNumberLocked)              

    EXITS("Field_VariableTypesSet1")
    RETURN
999 IF(ALLOCATED(oldVariableTypes)) DEALLOCATE(oldVariableTypes)
    IF(ALLOCATED(oldInterpolationType)) DEALLOCATE(oldInterpolationType)
    IF(ALLOCATED(oldInterpolationTypeLocked)) DEALLOCATE(oldInterpolationTypeLocked)
    IF(ALLOCATED(oldMeshComponentNumber)) DEALLOCATE(oldMeshComponentNumber)
    IF(ALLOCATED(oldMeshComponentNumberLocked)) DEALLOCATE(oldMeshComponentNumberLocked)
    ERRORSEXITS("Field_VariableTypesSet1",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariableTypesSet1

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable type for a field and locks it so that no further changes can be made.
  SUBROUTINE Field_VariableTypesSetAndLock0(field,variableType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set and lock
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
 
    ENTERS("Field_VariableTypesSetAndLock0",err,error,*999)

    CALL Field_VariableTypesSetAndLock1(field,[variableType],err,error,*999)

    EXITS("Field_VariableTypesSetAndLock0")
    RETURN
999 ERRORSEXITS("Field_VariableTypesSetAndLock0",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariableTypesSetAndLock0
  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field and locks it so that no further changes can be made.
  SUBROUTINE Field_VariableTypesSetAndLock1(field,variableTypes,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variableIdx). The field variable type for the variableIdx'th field variable to set 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_VariableTypesSetAndLock1",err,error,*999)

    CALL Field_VariableTypesSet(field,variableTypes,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    
    createValuesCache%variableTypesLocked=.TRUE.

    EXITS("Field_VariableTypesSetAndLock1")
    RETURN
999 ERRORSEXITS("Field_VariableTypesSetAndLock1",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariableTypesSetAndLock1

  !
  !================================================================================================================================
  !

  !>Checks for a valid setup of the field variables
  SUBROUTINE Field_VariablesCheck(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to check the variables for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableIdx,variableIdx2,variableType,variableType2
    LOGICAL :: duplicates
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_VariablesCheck",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    !Check the number of field variables
    IF(field%numberOfVariables<=0) THEN
      localError="Invalid field setup. The field has "//TRIM(NumberToVString(field%numberOfVariables,"*",err,error))// &
        & " variables and should have > 0 variables."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    !Check that the variable types are unique. Just do an exhaustive check. It is expensive but the list should be short.
    duplicates=.FALSE.
    firstVariable: DO variableIdx=1,field%numberOfVariables
      variableType=createValuesCache%variableTypes(variableIdx)
      secondVariable: DO variableIdx2=variableIdx+1,field%numberOfVariables
        variableType2=createValuesCache%variableTypes(variableIdx2)
        IF(variableType==variableType2) THEN
          duplicates=.TRUE.
          EXIT firstVariable
        ENDIF
      ENDDO secondVariable !variableIdx2
    ENDDO firstVariable !variableIdx
    IF(duplicates) THEN
      localError="Invalid variable types. Two or more variables have variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("Field_VariablesCheck")
    RETURN
999 ERRORSEXITS("Field_VariablesCheck",err,error)
    RETURN 1

  END SUBROUTINE Field_VariablesCheck

  !
  !================================================================================================================================
  !

  !>Finalises the field variables for a field and deallocates all memory.
  SUBROUTINE Field_VariablesFinalise(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to finalise the variables for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableIdx

    ENTERS("Field_VariablesFinalise",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(ALLOCATED(field%variables)) THEN
        DO variableIdx=1,SIZE(field%variables,1)
          CALL Field_VariableFinalise(field%variables(variableIdx),err,error,*999)
        ENDDO !variableIdx
        DEALLOCATE(field%variables)
      ENDIF
      field%numberOfVariables=0
    ENDIF

    EXITS("Field_VariablesFinalise")
    RETURN
999 ERRORSEXITS("Field_VariablesFinalise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariablesFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the field variables.
  SUBROUTINE Field_VariablesInitialise(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the variables for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableIdx

    ENTERS("Field_VariablesInitialise",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(ALLOCATED(field%variables)) CALL FlagError("Field already has associated variables.",err,error,*999)
    
    ALLOCATE(field%variables(field%numberOfVariables),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate new field variables.",err,error,*999)
    DO variableIdx=1,field%numberOfVariables
      CALL Field_VariableInitialise(field,variableIdx,err,error,*999)
    ENDDO !variableIdx

    EXITS("Field_VariablesInitialise")
    RETURN
999 ERRORSEXITS("Field_VariablesInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_VariablesInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a field variable component and deallocates all memory.
  SUBROUTINE FieldVariable_ComponentFinalise(fieldVariableComponent,err,error,*)

    !Argument variables
    TYPE(FieldVariableComponentType) :: fieldVariableComponent !<The field variable component to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariable_ComponentFinalise",err,error,*999)

    fieldVariableComponent%componentLabel=""
    CALL FieldVariableComponent_ParameterToDofMapFinalise(fieldVariableComponent,err,error,*999)

    EXITS("FieldVariable_ComponentFinalise")
    RETURN
999 ERRORSEXITS("FieldVariable_ComponentFinalise",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ComponentFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a field variable component.
  SUBROUTINE FieldVariable_ComponentInitialise(fieldVariable,componentNumber,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to initialise the component for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number of the field variable component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: derivativeIdx,dummyErr,elementIdx,globalElementNumber,maxNumberOfGauss,meshComponentNumber,nodeIdx, &
      & numberOfGauss,numberOfParameters,variableType
    TYPE(BasisType), POINTER :: basis
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionDataPointsType), POINTER :: decompositionDataPoints
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(FieldType), POINTER :: field
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(QuadratureSchemeType), POINTER :: quadratureScheme
    TYPE(VARYING_STRING) :: dummyError,localError

    ENTERS("FieldVariable_ComponentInitialise",err,error,*998)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*998)
    CALL FieldVariable_AssertComponentNumberOK(fieldVariable,componentNumber,err,error,*998)

    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    variableType=fieldVariable%variableType
    fieldVariable%components(componentNumber)%componentNumber=componentNumber
    fieldVariable%components(componentNumber)%fieldVariable=>fieldVariable
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    meshComponentNumber=createValuesCache%meshComponentNumber(componentNumber,variableType)
    IF(meshComponentNumber<1.OR.meshComponentNumber>decomposition%numberOfComponents) THEN
      localError="The mesh component number of "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
        & " for field component "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & " is invalid. The component number must be between 1 and "// &
        & TRIM(NumberToVString(decomposition%numberOfComponents,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    fieldVariable%components(componentNumber)%meshComponentNumber=meshComponentNumber
    fieldVariable%components(componentNumber)%domain=>decomposition%domain(meshComponentNumber)%ptr
    fieldVariable%components(componentNumber)%componentLabel=""
    fieldVariable%components(componentNumber)%componentLabel=createValuesCache%componentLabels(componentNumber,variableType)
    fieldVariable%components(componentNumber)%interpolationType=createValuesCache%interpolationTypes(componentNumber,variableType)
    NULLIFY(domain)
    CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    NULLIFY(domainElements)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    NULLIFY(domainNodes)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    SELECT CASE(fieldVariable%components(componentNumber)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      fieldVariable%components(componentNumber)%maxNumberElementInterpolationParameters=1
      fieldVariable%components(componentNumber)%maxNumberNodeInterpolationParameters=0
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      fieldVariable%components(componentNumber)%maxNumberElementInterpolationParameters=1
      fieldVariable%components(componentNumber)%maxNumberNodeInterpolationParameters=0
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      fieldVariable%components(componentNumber)%maxNumberElementInterpolationParameters=-1
      DO elementIdx=1,domainElements%totalNumberOfElements
        NULLIFY(basis)
        CALL DomainElements_ElementBasisGet(domainElements,elementIdx,basis,err,error,*999)
        IF(basis%numberOfElementParameters>fieldVariable%components(componentNumber)% &
          & maxNumberElementInterpolationParameters) fieldVariable%components(componentNumber)% &
          & maxNumberElementInterpolationParameters=basis%numberOfElementParameters
      ENDDO !elementIdx
      fieldVariable%components(componentNumber)%maxNumberNodeInterpolationParameters=-1
      DO nodeIdx=1,domainNodes%totalNumberOfNodes
        numberOfParameters=0
        DO derivativeIdx=1,domainNodes%nodes(nodeIdx)%numberOfDerivatives
          numberOfParameters=numberOfParameters+domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%numberOfVersions
        ENDDO !derivativeIdx
        IF(numberOfParameters>fieldVariable%components(componentNumber)%maxNumberNodeInterpolationParameters) &
          & fieldVariable%components(componentNumber)%maxNumberNodeInterpolationParameters=numberOfParameters
      ENDDO !nodeIdx
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)             
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      maxNumberOfGauss = -1
      DO elementIdx=1,domainElements%totalNumberOfElements
        NULLIFY(basis)
        CALL DomainElements_ElementBasisGet(domainElements,elementIdx,basis,err,error,*999)
        NULLIFY(quadratureScheme)
        CALL Basis_QuadratureSchemeGet(basis,BASIS_DEFAULT_QUADRATURE_SCHEME,quadratureScheme,err,error,*999)
        numberOfGauss=quadratureScheme%numberOfGauss
        IF(numberOfGauss>maxNumberOfGauss) maxNumberOfGauss=numberOfGauss
      ENDDO
      fieldVariable%components(componentNumber)%maxNumberElementInterpolationParameters = maxNumberOfGauss
      fieldVariable%components(componentNumber)%maxNumberNodeInterpolationParameters = 0
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      NULLIFY(decompositionTopology)
      CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
      NULLIFY(decompositionElements)
      CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
      NULLIFY(decompositionDataPoints)
      CALL DecompositionTopology_DecompositionDataPointsGet(decompositionTopology,decompositionDataPoints,err,error,*999)
      fieldVariable%components(componentNumber)%maxNumberElementInterpolationParameters=-1
      DO elementIdx=1,domainElements%totalNumberOfElements
        globalElementNumber=decompositionElements%elements(elementIdx)%globalNumber
        IF(decompositionDataPoints%numberOfElementDataPoints(globalElementNumber)> &
          & fieldVariable%components(componentNumber)%maxNumberElementInterpolationParameters) THEN
          fieldVariable%components(componentNumber)%maxNumberElementInterpolationParameters= &
            &  decompositionDataPoints%numberOfElementDataPoints(globalElementNumber)
        ENDIF
      ENDDO !elementIdx
      fieldVariable%components(componentNumber)%maxNumberNodeInterpolationParameters=0
    CASE DEFAULT
      localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
        & COMPONENTS(componentNumber)%interpolationType,"*",err,error))// &
        & " for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" is invalid."
    END SELECT
    CALL FieldVariableComponent_ParameterToDofMapInitialise(fieldVariable%components(componentNumber),err,error,*999)

    EXITS("FieldVariable_ComponentInitialise")
    RETURN
999 CALL FieldVariable_ComponentFinalise(fieldVariable%components(componentNumber),dummyErr,dummyError,*998)
998 ERRORSEXITS("FieldVariable_ComponentInitialise",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ComponentInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a field variable component parameter to dof map and deallocates all memory.
  SUBROUTINE FieldVariableComponent_ParameterToDofMapFinalise(fieldVariableComponent,err,error,*)

    !Argument variables
    TYPE(FieldVariableComponentType) :: fieldVariableComponent !<The field variable component to finialise the parameter to dof map for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariableComponent_ParameterToDofMapFinalise",err,error,*999)

    IF(ALLOCATED(fieldVariableComponent%paramToDOFMap%nodeParam2DOFMap%NODES))  &
      & DEALLOCATE(fieldVariableComponent%paramToDOFMap%nodeParam2DOFMap%NODES)
    IF(ALLOCATED(fieldVariableComponent%paramToDOFMap%elementParam2DOFMap%ELEMENTS))  &
      & DEALLOCATE(fieldVariableComponent%paramToDOFMap%elementParam2DOFMap%ELEMENTS)
    IF(ALLOCATED(fieldVariableComponent%paramToDOFMap%gridPointParam2DOFMap%gridPoints))  &
      & DEALLOCATE(fieldVariableComponent%paramToDOFMap%gridPointParam2DOFMap%gridPoints)
    IF(ALLOCATED(fieldVariableComponent%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints))  &
      & DEALLOCATE(fieldVariableComponent%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints)
    IF(ALLOCATED(fieldVariableComponent%paramToDOFMap%dataPointParam2DOFMap%dataPoints))  &
      & DEALLOCATE(fieldVariableComponent%paramToDOFMap%dataPointParam2DOFMap%dataPoints)
    fieldVariableComponent%paramToDOFMap%numberOfConstantParameters=0
    fieldVariableComponent%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters=0
    fieldVariableComponent%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters=0
    fieldVariableComponent%paramToDOFMap%gridPointParam2DOFMap%numberOfGridPointParameters=0
    fieldVariableComponent%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters=0
    fieldVariableComponent%paramToDOFMap%dataPointParam2DOFMap%numberOfDataPointParameters=0

    EXITS("FieldVariableComponent_ParameterToDofMapFinalise")
    RETURN
999 ERRORS("FieldVariableComponent_ParameterToDofMapFinalise",err,error)
    EXITS("FieldVariableComponent_ParameterToDofMapFinalise")
    RETURN 1

  END SUBROUTINE FieldVariableComponent_ParameterToDofMapFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a field variable component parameter to dof map.
  SUBROUTINE FieldVariableComponent_ParameterToDofMapInitialise(fieldVariableComponent,err,error,*)

    !Argument variables
    TYPE(FieldVariableComponentType) :: fieldVariableComponent !<The field variable component to initialise the parameter to dof map for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariableComponent_ParameterToDofMapInitialise",err,error,*999)

    fieldVariableComponent%paramToDOFMap%numberOfConstantParameters=0
    fieldVariableComponent%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters=0
    fieldVariableComponent%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters=0
    fieldVariableComponent%paramToDOFMap%gridPointParam2DOFMap%numberOfGridPointParameters=0
    fieldVariableComponent%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters=0
    fieldVariableComponent%paramToDOFMap%dataPointParam2DOFMap%numberOfDataPointParameters=0

    EXITS("FieldVariableComponent_ParameterToDofMapInitialise")
    RETURN
999 ERRORS("FieldVariableComponent_ParameterToDofMapInitialise",err,error)
    EXITS("FieldVariableComponent_ParameterToDofMapInitialise")
    RETURN 1

  END SUBROUTINE FieldVariableComponent_ParameterToDofMapInitialise

  !
  !================================================================================================================================
  !

  !>Finalises the field variable components for a field variable and deallocates all memory.
  SUBROUTINE FieldVariable_ComponentsFinalise(fieldVariable,err,error,*)

    !Argument variables
    TYPE(FieldVariableType) :: fieldVariable !<The field variable to finalise the field variable components for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx

    ENTERS("FieldVariable_ComponentsFinalise",err,error,*999)

    IF(ALLOCATED(fieldVariable%components)) THEN
      DO componentIdx=1,SIZE(fieldVariable%components,1)
        CALL FieldVariable_ComponentFinalise(fieldVariable%components(componentIdx),err,error,*999)
      ENDDO !componentIdx
      DEALLOCATE(fieldVariable%components)
    ENDIF
    fieldVariable%numberOfComponents=0

    EXITS("FieldVariable_ComponentsFinalise")
    RETURN
999 ERRORSEXITS("FieldVariable_ComponentsFinalise",err,error)
    RETURN 1
    
  END SUBROUTINE FieldVariable_ComponentsFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the field components.
  SUBROUTINE FieldVariable_ComponentsInitialise(field,variableType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to initialise the field variable components for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to initialise the field variable components for \see FieldRoutines_VariableTypes,FieldRoutines 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,dummyErr
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache 
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("FieldVariable_ComponentsInitialise",err,error,*998)

    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*998)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*998)
    IF(ALLOCATED(fieldVariable%components)) CALL FlagError("Field variable already has allocated components.",err,error,*998)

    ALLOCATE(fieldVariable%components(fieldVariable%numberOfComponents),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate field variable components.",err,error,*999)
    DO componentIdx=1,fieldVariable%numberOfComponents
      CALL FieldVariable_ComponentInitialise(fieldVariable,componentIdx,err,error,*999)
    ENDDO !componentIdx

    EXITS("FieldVariable_ComponentsInitialise")
    RETURN
999 CALL FieldVariable_ComponentsFinalise(fieldVariable,dummyErr,dummyError,*998)
998 ERRORSEXITS("FieldVariable_ComponentsInitialise",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ComponentsInitialise

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a constant integer value. 
  SUBROUTINE FieldVariable_ComponentValuesInitialiseIntg(fieldVariable,fieldSetType,componentNumber,initValue,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to initialise the values for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to initialise \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to initialise
    INTEGER(INTG), INTENT(IN) :: initValue !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: elementIdx,derivativeIdx,versionIdx,fieldDOF,nodeIdx,partialDerivativeIndex,gaussPointIdx, &
      & maxNumberOfGaussPoints
    INTEGER(INTG), POINTER :: fieldVariableParameters(:)
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ComponentValuesInitialiseIntg",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    !Check the component number
    CALL FieldVariable_AssertComponentNumberOK(fieldVariable,componentNumber,err,error,*999)
    !Get the parameters values
    CALL DistributedVector_DataGet(parameterSet%parameters,fieldVariableParameters,err,error,*999)
    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
    !and not worry about updating the field parameter set.
    SELECT CASE(fieldVariable%components(componentNumber)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap%constantParam2DOFMap
      fieldVariableParameters(fieldDOF)=initValue
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      DO elementIdx=1,domainElements%totalNumberOfElements
        fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap%elementParam2DOFMap%elements(elementIdx)
        fieldVariableParameters(fieldDOF)=initValue
      ENDDO !elementIdx
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainNodes)
      CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
      DO nodeIdx=1,domainNodes%totalNumberOfNodes
        DO derivativeIdx=1,domainNodes%nodes(nodeIdx)%numberOfDerivatives
          DO versionIdx=1,domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%numberOfVersions
            fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap% &
              & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
            partialDerivativeIndex=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%partialDerivativeIndex
            SELECT CASE(partialDerivativeIndex)
            CASE(NO_PART_DERIV)
              fieldVariableParameters(fieldDOF)=initValue
            CASE(PART_DERIV_S1)
              fieldVariableParameters(fieldDOF)=1_INTG
            CASE(PART_DERIV_S1_S1)
              fieldVariableParameters(fieldDOF)=0_INTG
            CASE(PART_DERIV_S2)
              fieldVariableParameters(fieldDOF)=1_INTG
            CASE(PART_DERIV_S2_S2)
              fieldVariableParameters(fieldDOF)=0_INTG
            CASE(PART_DERIV_S1_S2)
              fieldVariableParameters(fieldDOF)=0_INTG
            CASE(PART_DERIV_S3)
              fieldVariableParameters(fieldDOF)=1_INTG
            CASE(PART_DERIV_S3_S3)
              fieldVariableParameters(fieldDOF)=0_INTG
            CASE(PART_DERIV_S1_S3)
              fieldVariableParameters(fieldDOF)=0_INTG
            CASE(PART_DERIV_S2_S3)
              fieldVariableParameters(fieldDOF)=0_INTG
            CASE(PART_DERIV_S1_S2_S3)
              fieldVariableParameters(fieldDOF)=0_INTG
            CASE DEFAULT
              localError="The partial derivative index of "// &
                & TRIM(NumberToVString(partialDerivativeIndex,"*",err,error))//" for node number "// &
                & TRIM(NumberToVString(nodeIdx,"*",err,error))//" and derivative number "// &
                & TRIM(NumberToVString(derivativeIdx,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !versionIdx
        ENDDO !derivativeIdx
      ENDDO !nodeIdx
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      maxNumberOfGaussPoints=SIZE(fieldVariable%components(componentNumber)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
      DO elementIdx=1,domainElements%totalNumberOfElements
        DO gaussPointIdx=1,maxNumberOfGaussPoints ! could be just element's gaussPointIdx
          fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap% &
            & gaussPointParam2DOFMap%gaussPoints(gaussPointIdx,elementIdx)
          fieldVariableParameters(fieldDOF)=initValue
        ENDDO !gaussPointIdx
      ENDDO !elementIdx
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
        & components(componentNumber)%interpolationType,"*",err,error))// &
        & " is invalid for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" for field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    !Restore the  parameter set 
    CALL DistributedVector_DataRestore(parameterSet%parameters,fieldVariableParameters,err,error,*999)

    EXITS("FieldVariable_ComponentValuesInitialiseIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ComponentValuesInitialiseIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ComponentValuesInitialiseIntg

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a constant single precision real value. 
  SUBROUTINE FieldVariable_ComponentValuesInitialiseSP(fieldVariable,fieldSetType,componentNumber,initValue,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to initialise the values for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to initialise \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to initialise
    REAL(SP), INTENT(IN) :: initValue !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: elementIdx,derivativeIdx,versionIdx,fieldDOF,nodeIdx,partialDerivativeIndex,gaussPointIdx, &
      & maxNumberOfGaussPoints
    REAL(SP), POINTER :: fieldVariableParameters(:)
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ComponentValuesInitialiseSP",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    !Check the component number
    CALL FieldVariable_AssertComponentNumberOK(fieldVariable,componentNumber,err,error,*999)
    !Get the parameters values
    CALL DistributedVector_DataGet(parameterSet%parameters,fieldVariableParameters,err,error,*999)
    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
    !and not worry about updating the field parameter set.
    SELECT CASE(fieldVariable%components(componentNumber)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap%constantParam2DOFMap
      fieldVariableParameters(fieldDOF)=initValue
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      DO elementIdx=1,domainElements%totalNumberOfElements
        fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap%elementParam2DOFMap%elements(elementIdx)
        fieldVariableParameters(fieldDOF)=initValue
      ENDDO !elementIdx
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainNodes)
      CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
      DO nodeIdx=1,domainNodes%totalNumberOfNodes
        DO derivativeIdx=1,domainNodes%nodes(nodeIdx)%numberOfDerivatives
          DO versionIdx=1,domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%numberOfVersions
            fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap% &
              & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
            partialDerivativeIndex=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%partialDerivativeIndex
            SELECT CASE(partialDerivativeIndex)
            CASE(NO_PART_DERIV)
              fieldVariableParameters(fieldDOF)=initValue
            CASE(PART_DERIV_S1)
              fieldVariableParameters(fieldDOF)=1.0_SP
            CASE(PART_DERIV_S1_S1)
              fieldVariableParameters(fieldDOF)=0.0_SP
            CASE(PART_DERIV_S2)
              fieldVariableParameters(fieldDOF)=1.0_SP
            CASE(PART_DERIV_S2_S2)
              fieldVariableParameters(fieldDOF)=0.0_SP
            CASE(PART_DERIV_S1_S2)
              fieldVariableParameters(fieldDOF)=0.0_SP
            CASE(PART_DERIV_S3)
              fieldVariableParameters(fieldDOF)=1.0_SP
            CASE(PART_DERIV_S3_S3)
              fieldVariableParameters(fieldDOF)=0.0_SP
            CASE(PART_DERIV_S1_S3)
              fieldVariableParameters(fieldDOF)=0.0_SP
            CASE(PART_DERIV_S2_S3)
              fieldVariableParameters(fieldDOF)=0.0_SP
            CASE(PART_DERIV_S1_S2_S3)
              fieldVariableParameters(fieldDOF)=0.0_SP
            CASE DEFAULT
              localError="The partial derivative index of "// &
                & TRIM(NumberToVString(partialDerivativeIndex,"*",err,error))//" for node number "// &
                & TRIM(NumberToVString(nodeIdx,"*",err,error))//" and derivative number "// &
                & TRIM(NumberToVString(derivativeIdx,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !versionIdx
        ENDDO !derivativeIdx
      ENDDO !nodeIdx
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      maxNumberOfGaussPoints=SIZE(fieldVariable%components(componentNumber)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
      DO elementIdx=1,domainElements%totalNumberOfElements
        DO gaussPointIdx=1,maxNumberOfGaussPoints ! could be just element's gaussPointIdx
          fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap% &
            & gaussPointParam2DOFMap%gaussPoints(gaussPointIdx,elementIdx)
          fieldVariableParameters(fieldDOF)=initValue
        ENDDO !gaussPointIdx
      ENDDO !elementIdx
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
        & components(componentNumber)%interpolationType,"*",err,error))// &
        & " is invalid for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" for field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    !Restore the  parameter set 
    CALL DistributedVector_DataRestore(parameterSet%parameters,fieldVariableParameters,err,error,*999)

    EXITS("FieldVariable_ComponentValuesInitialiseSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ComponentValuesInitialiseSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ComponentValuesInitialiseSP

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a constant double precision real value. 
  SUBROUTINE FieldVariable_ComponentValuesInitialiseDP(fieldVariable,fieldSetType,componentNumber,initValue,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to initialise the values for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to initialise \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to initialise
    REAL(DP), INTENT(IN) :: initValue !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: elementIdx,derivativeIdx,versionIdx,fieldDOF,nodeIdx,partialDerivativeIndex,gaussPointIdx, &
      & maxNumberOfGaussPoints
    REAL(DP), POINTER :: fieldVariableParameters(:)
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ComponentValuesInitialiseDP",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    !Check the component number
    CALL FieldVariable_AssertComponentNumberOK(fieldVariable,componentNumber,err,error,*999)
    !Get the parameters values
    CALL DistributedVector_DataGet(parameterSet%parameters,fieldVariableParameters,err,error,*999)
    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
    !and not worry about updating the field parameter set.
    SELECT CASE(fieldVariable%components(componentNumber)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap%constantParam2DOFMap
      fieldVariableParameters(fieldDOF)=initValue
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      DO elementIdx=1,domainElements%totalNumberOfElements
        fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap%elementParam2DOFMap%elements(elementIdx)
        fieldVariableParameters(fieldDOF)=initValue
      ENDDO !elementIdx
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainNodes)
      CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
      DO nodeIdx=1,domainNodes%totalNumberOfNodes
        DO derivativeIdx=1,domainNodes%nodes(nodeIdx)%numberOfDerivatives
          DO versionIdx=1,domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%numberOfVersions
            fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap% &
              & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
            partialDerivativeIndex=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%partialDerivativeIndex
            SELECT CASE(partialDerivativeIndex)
            CASE(NO_PART_DERIV)
              fieldVariableParameters(fieldDOF)=initValue
            CASE(PART_DERIV_S1)
              fieldVariableParameters(fieldDOF)=1.0_DP
            CASE(PART_DERIV_S1_S1)
              fieldVariableParameters(fieldDOF)=0.0_DP
            CASE(PART_DERIV_S2)
              fieldVariableParameters(fieldDOF)=1.0_DP
            CASE(PART_DERIV_S2_S2)
              fieldVariableParameters(fieldDOF)=0.0_DP
            CASE(PART_DERIV_S1_S2)
              fieldVariableParameters(fieldDOF)=0.0_DP
            CASE(PART_DERIV_S3)
              fieldVariableParameters(fieldDOF)=1.0_DP
            CASE(PART_DERIV_S3_S3)
              fieldVariableParameters(fieldDOF)=0.0_DP
            CASE(PART_DERIV_S1_S3)
              fieldVariableParameters(fieldDOF)=0.0_DP
            CASE(PART_DERIV_S2_S3)
              fieldVariableParameters(fieldDOF)=0.0_DP
            CASE(PART_DERIV_S1_S2_S3)
              fieldVariableParameters(fieldDOF)=0.0_DP
            CASE DEFAULT
              localError="The partial derivative index of "// &
                & TRIM(NumberToVString(partialDerivativeIndex,"*",err,error))//" for node number "// &
                & TRIM(NumberToVString(nodeIdx,"*",err,error))//" and derivative number "// &
                & TRIM(NumberToVString(derivativeIdx,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !versionIdx
        ENDDO !derivativeIdx
      ENDDO !nodeIdx
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      maxNumberOfGaussPoints=SIZE(fieldVariable%components(componentNumber)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
      DO elementIdx=1,domainElements%totalNumberOfElements
        DO gaussPointIdx=1,maxNumberOfGaussPoints ! could be just element's gaussPointIdx
          fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap% &
            & gaussPointParam2DOFMap%gaussPoints(gaussPointIdx,elementIdx)
          fieldVariableParameters(fieldDOF)=initValue
        ENDDO !gaussPointIdx
      ENDDO !elementIdx
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
        & components(componentNumber)%interpolationType,"*",err,error))// &
        & " is invalid for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" for field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    !Restore the  parameter set 
    CALL DistributedVector_DataRestore(parameterSet%parameters,fieldVariableParameters,err,error,*999)

    EXITS("FieldVariable_ComponentValuesInitialiseDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ComponentValuesInitialiseDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ComponentValuesInitialiseDP

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a constant logical value. 
  SUBROUTINE FieldVariable_ComponentValuesInitialiseL(fieldVariable,fieldSetType,componentNumber,initValue,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to initialise the values for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to initialise \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to initialise
    LOGICAL, INTENT(IN) :: initValue !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: elementIdx,derivativeIdx,versionIdx,fieldDOF,nodeIdx,partialDerivativeIndex,gaussPointIdx, &
      & maxNumberOfGaussPoints
    LOGICAL, POINTER :: fieldVariableParameters(:)
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ComponentValuesInitialiseDP",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    !Check the component number
    CALL FieldVariable_AssertComponentNumberOK(fieldVariable,componentNumber,err,error,*999)
    !Get the parameters values
    CALL DistributedVector_DataGet(parameterSet%parameters,fieldVariableParameters,err,error,*999)
    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
    !and not worry about updating the field parameter set.
    SELECT CASE(fieldVariable%components(componentNumber)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap%constantParam2DOFMap
      fieldVariableParameters(fieldDOF)=initValue
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      DO elementIdx=1,domainElements%totalNumberOfElements
        fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap%elementParam2DOFMap%elements(elementIdx)
        fieldVariableParameters(fieldDOF)=initValue
      ENDDO !elementIdx
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainNodes)
      CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
      DO nodeIdx=1,domainNodes%totalNumberOfNodes
        DO derivativeIdx=1,domainNodes%nodes(nodeIdx)%numberOfDerivatives
          DO versionIdx=1,domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%numberOfVersions
            fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap% &
              & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
            partialDerivativeIndex=domainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%partialDerivativeIndex
            SELECT CASE(partialDerivativeIndex)
            CASE(NO_PART_DERIV)
              fieldVariableParameters(fieldDOF)=initValue
            CASE(PART_DERIV_S1)
              fieldVariableParameters(fieldDOF)=.TRUE.
            CASE(PART_DERIV_S1_S1)
              fieldVariableParameters(fieldDOF)=.FALSE.
            CASE(PART_DERIV_S2)
              fieldVariableParameters(fieldDOF)=.TRUE.
            CASE(PART_DERIV_S2_S2)
              fieldVariableParameters(fieldDOF)=.FALSE.
            CASE(PART_DERIV_S1_S2)
              fieldVariableParameters(fieldDOF)=.FALSE.
            CASE(PART_DERIV_S3)
              fieldVariableParameters(fieldDOF)=.TRUE.
            CASE(PART_DERIV_S3_S3)
              fieldVariableParameters(fieldDOF)=.FALSE.
            CASE(PART_DERIV_S1_S3)
              fieldVariableParameters(fieldDOF)=.FALSE.
            CASE(PART_DERIV_S2_S3)
              fieldVariableParameters(fieldDOF)=.FALSE.
            CASE(PART_DERIV_S1_S2_S3)
              fieldVariableParameters(fieldDOF)=.FALSE.
            CASE DEFAULT
              localError="The partial derivative index of "// &
                & TRIM(NumberToVString(partialDerivativeIndex,"*",err,error))//" for node number "// &
                & TRIM(NumberToVString(nodeIdx,"*",err,error))//" and derivative number "// &
                & TRIM(NumberToVString(derivativeIdx,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !versionIdx
        ENDDO !derivativeIdx
      ENDDO !nodeIdx
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,componentNumber,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      maxNumberOfGaussPoints=SIZE(fieldVariable%components(componentNumber)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
      DO elementIdx=1,domainElements%totalNumberOfElements
        DO gaussPointIdx=1,maxNumberOfGaussPoints ! could be just element's gaussPointIdx
          fieldDOF=fieldVariable%components(componentNumber)%paramToDOFMap% &
            & gaussPointParam2DOFMap%gaussPoints(gaussPointIdx,elementIdx)
          fieldVariableParameters(fieldDOF)=initValue
        ENDDO !gaussPointIdx
      ENDDO !elementIdx
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
        & components(componentNumber)%interpolationType,"*",err,error))// &
        & " is invalid for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" for field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    !Restore the  parameter set 
    CALL DistributedVector_DataRestore(parameterSet%parameters,fieldVariableParameters,err,error,*999)

    EXITS("FieldVariable_ComponentValuesInitialiseL")
    RETURN
999 ERRORSEXITS("FieldVariable_ComponentValuesInitialiseL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ComponentValuesInitialiseL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddConstantIntg(fieldVariable,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add to
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetAddConstantIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)    
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddConstantIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddConstantIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddConstantIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddConstantSP(fieldVariable,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add to
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetAddConstantSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetAddConstantSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddConstantSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddConstantSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddConstantDP(fieldVariable,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add to
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetAddConstantDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetAddConstantDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddConstantDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddConstantDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddConstantL(fieldVariable,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add to
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetAddConstantL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddConstantL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddConstantL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddConstantL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetAddLocalDOFIntg(fieldVariable,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: globalDOFNumber
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddLocalDOFIntg",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
    !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
    !not being set.
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(dofNumber<1.OR.dofNumber>domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid. It must be >0 and <= "//TRIM(NumberToVString(domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    globalDOFNumber=domainMapping%localToGlobalMap(dofNumber)
    IF(domainMapping%globalToLocalMap(globalDOFNumber)%localType(1)==DOMAIN_LOCAL_GHOST) THEN
      localError="The field dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid as it is a ghost dof for this domain."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,dofNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddLocalDOFIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddLocalDOFIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalDOFIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetAddLocalDOFSP(fieldVariable,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: globalDOFNumber
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddLocalDOFSP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
    !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
    !not being set.
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(dofNumber<1.OR.dofNumber>domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid. It must be >0 and <= "//TRIM(NumberToVString(domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
    ENDIF
    globalDOFNumber=domainMapping%localToGlobalMap(dofNumber)
    IF(domainMapping%globalToLocalMap(globalDOFNumber)%localType(1)==DOMAIN_LOCAL_GHOST) THEN
      localError="The field dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid as it is a ghost dof for this domain."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,dofNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddLocalDOFSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddLocalDOFSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalDOFSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetAddLocalDOFDP(fieldVariable,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: globalDOFNumber
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddLocalDOFDP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
    !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
    !not being set.
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(dofNumber<1.OR.dofNumber>fieldVariable%domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid. It must be >0 and <= "//TRIM(NumberToVString(domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
    ENDIF
    globalDOFNumber=domainMapping%localToGlobalMap(dofNumber)
    IF(domainMapping%globalToLocalMap(globalDOFNumber)%localType(1)==DOMAIN_LOCAL_GHOST) THEN
      localError="The field dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid as it is a ghost dof for this domain."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,dofNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddLocalDOFDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddLocalDOFDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalDOFDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetAddLocalDOFL(fieldVariable,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: globalDOFNumber
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddLocalDOFL",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
    !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
    !not being set.
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(dofNumber<1.OR.dofNumber>domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid. It must be >0 and <= "//TRIM(NumberToVString(domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    globalDOFNumber=domainMapping%localToGlobalMap(dofNumber)
    IF(domainMapping%globalToLocalMap(globalDOFNumber)%localType(1)==DOMAIN_LOCAL_GHOST) THEN
      localError="The field dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid as it is a ghost dof for this domain."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,dofNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddLocalDOFL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddLocalDOFL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalDOFL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular user element of the field variable component. 
  SUBROUTINE FieldVariable_ParameterSetAddElementIntg(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddElementIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add element for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddElementIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddElementIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddElementIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular user element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddElementSP(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddElementSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add element for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddElementSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddElementSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddElementSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular user element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddElementDP(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddElementDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add element for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddElementDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddElementDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddElementDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular user element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddElementL(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
     TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddElementL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add element for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddElementL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddElementL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddElementL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular Gauss point of a user element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddGaussPointIntg(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddGaussPointIntg",err,error,*999)

   CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by Gauss point for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddGaussPointIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddGaussPointIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddGaussPointIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular Gauss point of a user element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddGaussPointSP(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddGaussPointSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by Gauss point for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddGaussPointSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddGaussPointSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddGaussPointSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular Gauss point of a user element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddGaussPointDP(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddGaussPointDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by Gauss point for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddGaussPointDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddGaussPointDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular Gauss point of a user element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddGaussPointL(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddGaussPointL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by Gauss point for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddGaussPointL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddGaussPointL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddGaussPointL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddLocalElementIntg(fieldVariable,fieldSetType,localElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetAddLocalElementIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddLocalElementIntg")
    RETURN
999 ERRORS("FieldVariable_ParameterSetAddLocalElementIntg",err,error)
    EXITS("FieldVariable_ParameterSetAddLocalElementIntg")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalElementIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddLocalElementSP(fieldVariable,fieldSetType,localElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetAddLocalElementSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddLocalElementSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddLocalElementSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalElementSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddLocalElementDP(fieldVariable,fieldSetType,localElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetAddLocalElementDP",err,error,*999)
    
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddLocalElementDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddLocalElementDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalElementDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddLocalElementL(fieldVariable,fieldSetType,localElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetAddLocalElementL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddLocalElementL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddLocalElementL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalElementL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular user node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddNodeIntg(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddNodeIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by node for user node number "//TRIM(NumberToVString(userNodeNumber,"*",err,error))// &
        & " as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)


    EXITS("FieldVariable_ParameterSetAddNodeIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddNodeIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular user node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddNodeSP(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddNodeSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by node for user node number "//TRIM(NumberToVString(userNodeNumber,"*",err,error))// &
        & " as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddNodeSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddNodeSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddNodeSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular user node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddNodeDP(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddNodeDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by node for user node number "//TRIM(NumberToVString(userNodeNumber,"*",err,error))// &
        & " as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddNodeDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddNodeDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddNodeDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular user node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddNodeL(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetAddNodeL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by node for user node number "//TRIM(NumberToVString(userNodeNumber,"*",err,error))// &
        & " as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddNodeL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddNodeL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddNodeL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddLocalNodeIntg(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetAddLocalNodeIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetAddLocalNodeIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddLocalNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalNodeIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddLocalNodeSP(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetAddLocalNodeSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddLocalNodeSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddLocalNodeSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalNodeSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddLocalNodeDP(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetAddLocalNodeDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetAddLocalNodeDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddLocalNodeDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalNodeDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetAddLocalNodeL(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetAddLocalNodeL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetAddLocalNodeL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetAddLocalNodeL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetAddLocalNodeL

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable. If the field parameter set has already been
  !>created then an error will be raised.
  SUBROUTINE FieldVariable_ParameterSetCreate(fieldVariable,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to create the parameter set for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,parameterSetIdx
    TYPE(FieldParameterSetType), POINTER :: newParameterSet
    TYPE(FieldParameterSetPtrType), POINTER :: newParameterSets(:)
    TYPE(VARYING_STRING) :: localError,dummyError

    NULLIFY(newParameterSet)
    NULLIFY(newParameterSets)

    ENTERS("FieldVariable_ParameterSetCreate",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    IF(.NOT.ASSOCIATED(fieldVariable%parameterSets%setType)) THEN
      localError="The parameter sets set types is not associated for the field variable type "// &
        & NumberToVString(fieldVariable%variableType,"*",err,error)
      IF(ASSOCIATED(fieldVariable%field)) THEN
        localError=localError//" of field number "//NumberToVString(fieldVariable%field%userNumber,"*",err,error)
      ENDIF
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(fieldSetType<1.OR.fieldSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
       localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
        & " is invalid. The field parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(ASSOCIATED(fieldVariable%parameterSets%setType(fieldSetType)%ptr)) THEN
      localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
        & " has already been created for variable type of "// &
        & NumberToVString(fieldVariable%variableType,"*",err,error)
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//NumberToVString(fieldVariable%field%userNumber,"*",err,error)
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    ALLOCATE(newParameterSet,STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate new parameter set.",err,error,*999)
    CALL Field_ParameterSetInitialise(newParameterSet,err,error,*999)
    
    newParameterSet%setIndex=fieldVariable%parameterSets%numberOfParameterSets+1
    newParameterSet%setType=fieldSetType
    NULLIFY(newParameterSet%parameters)
    CALL DistributedVector_CreateStart(fieldVariable%domainMapping,newParameterSet%parameters,err,error,*999)
    SELECT CASE(fieldVariable%dataType)
    CASE(FIELD_INTG_TYPE)
      CALL DistributedVector_DataTypeSet(newParameterSet%parameters,DISTRIBUTED_MATRIX_VECTOR_INTG_TYPE,err,error,*999)
    CASE(FIELD_SP_TYPE)
      CALL DistributedVector_DataTypeSet(newParameterSet%parameters,DISTRIBUTED_MATRIX_VECTOR_SP_TYPE,err,error,*999)
    CASE(FIELD_DP_TYPE)
      CALL DistributedVector_DataTypeSet(newParameterSet%parameters,DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
    CASE(FIELD_L_TYPE)
      CALL DistributedVector_DataTypeSet(newParameterSet%parameters,DISTRIBUTED_MATRIX_VECTOR_L_TYPE,err,error,*999)
    CASE DEFAULT
      localError="The field data type of "//TRIM(NumberToVString(fieldVariable%dataType,"*",err,error))// &
        & " is invalid for variable type of "//NumberToVString(fieldVariable%variableType,"*",err,error)
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//NumberToVString(fieldVariable%field%userNumber,"*",err,error)
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    CALL DistributedVector_CreateFinish(newParameterSet%parameters,err,error,*999)
    SELECT CASE(fieldVariable%dataType)
    CASE(FIELD_INTG_TYPE)
      CALL DistributedVector_AllValuesSet(newParameterSet%parameters,0_INTG,err,error,*999)
    CASE(FIELD_SP_TYPE)
      CALL DistributedVector_AllValuesSet(newParameterSet%parameters,0.0_SP,err,error,*999)
    CASE(FIELD_DP_TYPE)
      CALL DistributedVector_AllValuesSet(newParameterSet%parameters,0.0_DP,err,error,*999)
    CASE(FIELD_L_TYPE)
      CALL DistributedVector_AllValuesSet(newParameterSet%parameters,.FALSE.,err,error,*999)
    END SELECT
    !Add the new parameter set to the list of parameter sets
    ALLOCATE(newParameterSets(fieldVariable%parameterSets%numberOfParameterSets+1),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate new parameter sets.",err,error,*999)
    IF(ASSOCIATED(fieldVariable%parameterSets%parameterSets)) THEN
      DO parameterSetIdx=1,fieldVariable%parameterSets%numberOfParameterSets
        newParameterSets(parameterSetIdx)%ptr=>fieldVariable%parameterSets%parameterSets(parameterSetIdx)%ptr
      ENDDO !parameterSetIdx
      DEALLOCATE(fieldVariable%parameterSets%parameterSets)
    ENDIF
    newParameterSets(fieldVariable%parameterSets%numberOfParameterSets+1)%ptr=>newParameterSet
    ALLOCATE(fieldVariable%parameterSets%parameterSets(fieldVariable%parameterSets%numberOfParameterSets+1),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate field parameter sets parameter sets.",err,error,*999)
    DO parameterSetIdx=1,fieldVariable%parameterSets%numberOfParameterSets+1
      fieldVariable%parameterSets%parameterSets(parameterSetIdx)%ptr=>newParameterSets(parameterSetIdx)%ptr
    ENDDO !parameterSetIdx
    DEALLOCATE(newParameterSets)
    fieldVariable%parameterSets%numberOfParameterSets=fieldVariable%parameterSets%numberOfParameterSets+1
    fieldVariable%parameterSets%setType(fieldSetType)%ptr=>newParameterSet
    
    EXITS("FieldVariable_ParameterSetCreate")
    RETURN
999 CALL Field_ParameterSetFinalise(newParameterSet,dummyErr,dummyError,*998)
998 IF(ASSOCIATED(newParameterSets)) DEALLOCATE(newParameterSets)
    ERRORSEXITS("FieldVariable_ParameterSetCreate",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetCreate

  !
  !================================================================================================================================
  !

  !>Checks whether a field variable parameter set has been created
  SUBROUTINE FieldVariable_ParameterSetCreated(fieldVariable,fieldSetType,parameterSetCreated,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    LOGICAL, INTENT(OUT) :: parameterSetCreated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetCreated",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    !Check the set type input
    IF(fieldSetType<1.OR.fieldSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
        & " is invalid. The field parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ASSOCIATED(fieldVariable%parameterSets%setType)) THEN
      localError="The parameter sets set types is not associated for the field variable type "// &
        & NumberToVString(fieldVariable%variableType,"*",err,error)
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//NumberToVString(fieldVariable%field%userNumber,"*",err,error)
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    !Check if this set type has been created
    parameterSetCreated=ASSOCIATED(fieldVariable%parameterSets%setType(fieldSetType)%ptr)

    EXITS("FieldVariable_ParameterSetCreated")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetCreated",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetCreated

  !
  !================================================================================================================================
  !

  !>Destroys the parameter set of type set type for a field variable and deallocates all memory. \see OpenCMISS::Iron::cmfe_FieldParameterSetDestroy
  SUBROUTINE FieldVariable_ParameterSetDestroy(fieldVariable,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field varible to destroy a parameter set for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: parameterSetIdx,setIndex
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldParameterSetPtrType), POINTER :: newParameterSets(:)

    NULLIFY(newParameterSets)

    ENTERS("FieldVariable_ParameterSetDestroy",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    setIndex=parameterSet%setIndex
    ALLOCATE(newParameterSets(fieldVariable%parameterSets%numberOfParameterSets-1),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate new parameter sets.",err,error,*999)
    DO parameterSetIdx=1,fieldVariable%parameterSets%numberOfParameterSets
      IF(parameterSetIdx<setIndex) THEN
        newParameterSets(parameterSetIdx)%ptr=>fieldVariable%parameterSets%parameterSets(parameterSetIdx)%ptr
      ELSE IF(parameterSetIdx>setIndex) THEN
        newParameterSets(parameterSetIdx-1)%ptr=>fieldVariable%parameterSets%parameterSets(parameterSetIdx)%ptr
        newParameterSets(parameterSetIdx-1)%ptr%setIndex=newParameterSets(parameterSetIdx-1)%ptr%setIndex-1
      ENDIF
    ENDDO !parameterSetIdx
    DEALLOCATE(fieldVariable%parameterSets%parameterSets)
    fieldVariable%parameterSets%parameterSets=>newParameterSets
    fieldVariable%parameterSets%numberOfParameterSets=fieldVariable%parameterSets%numberOfParameterSets-1
    NULLIFY(fieldVariable%parameterSets%setType(fieldSetType)%ptr)
    CALL Field_ParameterSetFinalise(parameterSet,err,error,*999)

    EXITS("FieldVariable_ParameterSetDestroy")
    RETURN
999 IF(ASSOCIATED(newParameterSets)) DEALLOCATE(newParameterSets)
    ERRORSEXITS("FieldVariable_ParameterSetDestroy",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetDestroy

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field variable integer parameter set array. The pointer must be restored with a call to FieldRoutines::FieldVariable_ParameterSetDataRestore call. Note: the values can be used for read operations but a FieldRoutines::FieldVariable_ParameterSetUpdate call must be used to change any values.
  SUBROUTINE FieldVariable_ParameterSetDataGetIntg(fieldVariable,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), POINTER :: parameters(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetDataGetIntg",err,error,*998)

    IF(ASSOCIATED(parameters)) CALL FlagError("Parameters is already associated.",err,error,*998)
    
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL DistributedVector_DataGet(parameterSet%parameters,parameters,err,error,*999)

    EXITS("FieldVariable_ParameterSetDataGetIntg")
    RETURN
999 NULLIFY(parameters)
998 ERRORSEXITS("FieldVariable_ParameterSetDataGetIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetDataGetIntg

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field variable single precision parameter set array. The pointer must be restored with a call to FieldRoutines::FieldVariable_ParameterSetDataRestore call. Note: the values can be used for read operations but a FieldRoutines::FieldVariable_ParameterSetUpdate call must be used to change any values.
  SUBROUTINE FieldVariable_ParameterSetDataGetSP(fieldVariable,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(SP), POINTER :: parameters(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetDataGetSP",err,error,*998)

    IF(ASSOCIATED(parameters)) CALL FlagError("Parameters is already associated.",err,error,*998)
    
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL DistributedVector_DataGet(parameterSet%parameters,parameters,err,error,*999)

    EXITS("FieldVariable_ParameterSetDataGetSP")
    RETURN
999 NULLIFY(parameters)
998 ERRORSEXITS("FieldVariable_ParameterSetDataGetSP",err,error)
    RETURN 1
    
  END SUBROUTINE FieldVariable_ParameterSetDataGetSP

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field variable double precision parameter set array. The pointer must be restored with a call to FieldRoutines::FieldVariable_ParameterSetDataRestore call. Note: the values can be used for read operations but a FieldRoutines::FieldVariable_ParameterSetUpdate call must be used to change any values.
  SUBROUTINE FieldVariable_ParameterSetDataGetDP(fieldVariable,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(DP), POINTER :: parameters(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    
    ENTERS("FieldVariable_ParameterSetDataGetDP",err,error,*999)

    IF(ASSOCIATED(parameters)) CALL FlagError("Parameters is already associated.",err,error,*998)
    
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL DistributedVector_DataGet(parameterSet%parameters,parameters,err,error,*999)

    EXITS("FieldVariable_ParameterSetDataGetDP")
    RETURN
999 NULLIFY(parameters)
998 ERRORSEXITS("FieldVariable_ParameterSetDataGetDP",err,error)
    RETURN 1
    
  END SUBROUTINE FieldVariable_ParameterSetDataGetDP

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field variable logical parameter set array. The pointer must be restored with a call to FieldRoutines::FieldVariable_ParameterSetDataRestore call. Note: the values can be used for read operations but a FieldRoutines::FieldVariable_ParameterSetUpdate call must be used to change any values.
  SUBROUTINE FieldVariable_ParameterSetDataGetL(fieldVariable,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    LOGICAL, POINTER :: parameters(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetDataGetL",err,error,*998)

    IF(ASSOCIATED(parameters)) CALL FlagError("Parameters is already associated.",err,error,*998)
    
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL DistributedVector_DataGet(parameterSet%parameters,parameters,err,error,*999) 

    EXITS("FieldVariable_ParameterSetDataGetL")
    RETURN
999 NULLIFY(parameters)
998 ERRORSEXITS("FieldVariable_ParameterSetDataGetL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetDataGetL

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable integer parameter set array that was obtained with FieldRoutines::FieldVariable_ParameterSetDataGet.
  SUBROUTINE FieldVariable_ParameterSetDataRestoreIntg(fieldVariable,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), POINTER :: parameters(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetDataRestoreIntg",err,error,*999)

    IF(.NOT.ASSOCIATED(parameters)) CALL FlagError("Parameters is not associated.",err,error,*999)
    
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)    
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL DistributedVector_DataRestore(parameterSet%parameters,parameters,err,error,*999)

    EXITS("FieldVariable_ParameterSetDataRestoreIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetDataRestoreIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetDataRestoreIntg

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable single precision parameter set array that was obtained with FieldRoutines::FieldVariable_ParameterSetDataGet.
  SUBROUTINE FieldVariable_ParameterSetDataRestoreSP(fieldVariable,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(SP), POINTER :: parameters(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetDataRestoreSP",err,error,*999)

    IF(.NOT.ASSOCIATED(parameters)) CALL FlagError("Parameters is not associated.",err,error,*999)
    
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)    
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL DistributedVector_DataRestore(parameterSet%parameters,parameters,err,error,*999)

    EXITS("FieldVariable_ParameterSetDataRestoreSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetDataRestoreSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetDataRestoreSP

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable double precision parameter set array that was obtained with FieldRoutines::FieldVariable_ParameterSetDataGet.
  SUBROUTINE FieldVariable_ParameterSetDataRestoreDP(fieldVariable,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(DP), POINTER :: parameters(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetDataRestoreDP",err,error,*999)

    IF(.NOT.ASSOCIATED(parameters)) CALL FlagError("Parameters is not associated.",err,error,*999)
    
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL DistributedVector_DataRestore(parameterSet%parameters,parameters,err,error,*999)

    EXITS("FieldVariable_ParameterSetDataRestoreDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetDataRestoreDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetDataRestoreDP

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable logical parameter set array that was obtained with FieldRoutines::FieldVariable_ParameterSetDataGet.
  SUBROUTINE FieldVariable_ParameterSetDataRestoreL(fieldVariable,fieldSetType,parameters,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    LOGICAL, POINTER :: parameters(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetDataRestoreL",err,error,*999)

    IF(.NOT.ASSOCIATED(parameters)) CALL FlagError("Parameters is not associated.",err,error,*999)
    
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL DistributedVector_DataRestore(parameterSet%parameters,parameters,err,error,*999)

    EXITS("FieldVariable_ParameterSetDataRestoreL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetDataRestoreL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetDataRestoreL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetConstantIntg(fieldVariable,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetConstantIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetGetConstantIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetConstantIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetConstantIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetConstant
  SUBROUTINE FieldVariable_ParameterSetGetConstantSP(fieldVariable,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetConstantSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetConstantSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetConstantSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetConstantSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetConstantDP(fieldVariable,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetConstantDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetGetConstantDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetConstantDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetConstantDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetConstantL(fieldVariable,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetConstantL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetGetConstantL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetConstantL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetConstantL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified data point of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetDataPointIntg(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetDataPointIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetDataPointIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetDataPointIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetDataPointIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetGetDataPointSP(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetDataPointSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)


    EXITS("FieldVariable_ParameterSetGetDataPointSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetDataPointSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetDataPointSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetDataPointDP(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetDataPointDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetDataPointDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetDataPointDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetDataPointDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetGetDataPointL(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetDataPointL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetDataPointL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetDataPointL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetDataPointL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetElementIntg(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetElementIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetElementIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetElementIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetElementIntg

  !
  !================================================================================================================================
  !


  !>Returns from the given parameter set a single precision value for the specified element of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetElementSP(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetElementSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetGetElementSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetElementSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetElementSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetElementDP(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetElementDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetElementDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetElementDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetElementDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetElementL(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetElementL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetElementL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetElementL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetElementL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified gauss point of a user element of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetGetGaussPointIntg(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetGaussPointIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetGaussPointIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetGaussPointIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetGaussPointIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified gauss point of a user element of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetGaussPointSP(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetGaussPointSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetGaussPointSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetGaussPointSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetGaussPointSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified gauss point of a user element of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetGetGaussPointDP(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetGaussPointDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetGaussPointDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetGaussPointDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified gauss point of a user element of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetGetGaussPointL(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variableto get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetGaussPointL",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetGaussPointL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetGaussPointL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetGaussPointL

   !
  !================================================================================================================================
  !

  !>Returns the parameter set integer value for a specified local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetGetLocalDOFIntg(fieldVariable,fieldSetType,localDOFNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localDOFNumber !<The dof number to get
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value of the specified local dof.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetGetLocalDOFIntg",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(localDOFNumber<1.OR.localDOFNumber>domainMapping%totalNumberOfLocal) THEN
      localError="The field local dof number of "//TRIM(NumberToVString(localDOFNumber,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDOFNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetLocalDOFIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetLocalDOFIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalDOFIntg

  !
  !================================================================================================================================
  !

  !>Returns the parameter set single precision value for a particular local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetGetLocalDOFSP(fieldVariable,fieldSetType,localDOFNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localDOFNumber !<The dof number to get
    REAL(SP), INTENT(OUT) :: value !<On return, the value of the specified dof
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
   TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetGetLocalDOFSP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(localDOFNumber<1.OR.localDOFNumber>domainMapping%totalNumberOfLocal) THEN
      localError="The field local dof number of "//TRIM(NumberToVString(localDOFNumber,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDOFNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetLocalDOFSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetLocalDOFSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalDOFSP

  !
  !================================================================================================================================
  !

  !>Returns the parameter set double precision value for a particular local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetGetLocalDOFDP(fieldVariable,fieldSetType,localDOFNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localDOFNumber !<The dof number to get
    REAL(DP), INTENT(OUT) :: value !<On return, the value of the specified dof
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetGetLocalDOFDP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(localDOFNumber<1.OR.localDOFNumber>domainMapping%totalNumberOfLocal) THEN
      localError="The field local dof number of "//TRIM(NumberToVString(localDOFNumber,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDOFNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetLocalDOFDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetLocalDOFDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalDOFDP

  !
  !================================================================================================================================
  !

  !>Returns the parameter set logical value for a particular local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetGetLocalDOFL(fieldVariable,fieldSetType,localDOFNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localDOFNumber !<The dof number to get
    LOGICAL, INTENT(OUT) :: value !<On return, the value of the specified dof.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetGetLocalDOFL",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(localDOFNumber<1.OR.localDOFNumber>domainMapping%totalNumberOfLocal) THEN
      localError="The field local dof number of "//TRIM(NumberToVString(localDOFNumber,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDOFNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetLocalDOFL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetLocalDOFL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalDOFL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local element of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetLocalElementIntg(fieldVariable,fieldSetType,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
     INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetGetLocalElementIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetLocalElementIntg")
    RETURN
999 ERRORS("FieldVariable_ParameterSetGetLocalElementIntg",err,error)
    EXITS("FieldVariable_ParameterSetGetLocalElementIntg")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalElementIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local element of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetLocalElementSP(fieldVariable,fieldSetType,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetLocalElementSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetLocalElementSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetLocalElementSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalElementSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local element of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetLocalElementDP(fieldVariable,fieldSetType,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetLocalElementDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetGetLocalElementDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetLocalElementDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalElementDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local element of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetLocalElementL(fieldVariable,fieldSetType,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetLocalElementL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetLocalElementL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetLocalElementL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalElementL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified gauss point of a local element of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetGetLocalGaussPointIntg(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetLocalGaussPointIntg",err,error,*999)

    CALL FieldVariable_AssertIsIntgData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)     

    EXITS("FieldVariable_ParameterSetGetLocalGaussPointIntg")
    RETURN
999 ERRORS("FieldVariable_ParameterSetGetLocalGaussPointIntg",err,error)
    EXITS("FieldVariable_ParameterSetGetLocalGaussPointIntg")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalGaussPointIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified gauss point of a local element of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetGetLocalGaussPointSP(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetLocalGaussPointSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)     

    EXITS("FieldVariable_ParameterSetGetLocalGaussPointSP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetGetLocalGaussPointSP",err,error)
    EXITS("FieldVariable_ParameterSetGetLocalGaussPointSP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalGaussPointSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified gauss point of a local element of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetGetLocalGaussPointDP(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetLocalGaussPointDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)     

    EXITS("FieldVariable_ParameterSetGetLocalGaussPointDP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetGetLocalGaussPointDP",err,error)
    EXITS("FieldVariable_ParameterSetGetLocalGaussPointDP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalGaussPointDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified gauss point of a local element of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetGetLocalGaussPointL(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetLocalGaussPointL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)     

    EXITS("FieldVariable_ParameterSetGetLocalGaussPointL")
    RETURN
999 ERRORS("FieldVariable_ParameterSetGetLocalGaussPointL",err,error)
    EXITS("FieldVariable_ParameterSetGetLocalGaussPointL")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalGaussPointL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE FieldVariable_ParameterSetGetLocalNodeIntg(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetLocalNodeIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetLocalNodeIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetLocalNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalNodeIntg
  !
  
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE FieldVariable_ParameterSetGetLocalNodeSP(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetGetLocalNodeSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetLocalNodeSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetLocalNodeSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalNodeSP
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE FieldVariable_ParameterSetGetLocalNodeDP(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetLocalNodeDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetLocalNodeDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetLocalNodeDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalNodeDP
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE FieldVariable_ParameterSetGetLocalNodeL(fieldVariable,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetLocalNodeL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetLocalNodeL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetLocalNodeL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetLocalNodeL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified local node, derivative and version of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetNodeIntg(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field varible to get the value for
   INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetNodeIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetNodeIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetNodeIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local node, derivative and version of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetNodeSP(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetNodeSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetNodeSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetNodeSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetNodeSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local node, derivative and version of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetGetNodeDP(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetGetNodeDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetNodeDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetNodeDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetNodeDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local node, derivative and version of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetGetNodeL(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetGetNodeL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetGetNodeL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetGetNodeL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetGetNodeL

  !
  !================================================================================================================================
  !

  !>Outputs the parameter set for a field variable.
  SUBROUTINE FieldVariable_ParameterSetOutput(id,fieldVariable,fieldSetType,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: id !<The ID of the output stream
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to output the parameter set for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to output
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetOutput",err,error,*999)

    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL DistributedVector_Output(id,parameterSet%parameters,err,error,*999)

    EXITS("FieldVariable_ParameterSetOutput")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetOutput",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetOutput

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type for a field variable 
  SUBROUTINE FieldVariable_ParameterSetsCopy(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldType), POINTER :: field
    TYPE(FieldParameterSetType), POINTER :: fromParameterSet,toParameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetsCopy",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    IF(parameterFromSetType<=0.OR.parameterFromSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(parameterToSetType<=0.OR.parameterToSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    fromParameterSet=>fieldVariable%parameterSets%setType(parameterFromSetType)%ptr
    IF(ASSOCIATED(fromParameterSet)) THEN
      toParameterSet=>fieldVariable%parameterSets%setType(parameterToSetType)%ptr
      IF(ASSOCIATED(toParameterSet)) THEN
        !Do not need to do an update here as each rank already has the values.
        CALL DistributedVector_Copy(fromParameterSet%parameters,toParameterSet%parameters,alpha,err,error,*999)
      ELSE
        field=>fieldVariable%field
        IF(.NOT.ASSOCIATED(field)) THEN
          localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
            & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%variableType,"",err,error))// &
            & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
        ELSE
          localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
            & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%variableType,"",err,error))//"."
        ENDIF
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      field=>fieldVariable%field
      IF(.NOT.ASSOCIATED(field)) THEN
        localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
          & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%variableType,"",err,error))// &
          & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      ELSE
        localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
          & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%variableType,"",err,error))//"."
      ENDIF
      CALL FlagError(localError,err,error,*999)      
    ENDIF

    EXITS("FieldVariable_ParameterSetsCopy")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetsCopy",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetsCopy

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type if they exist for a field variable 
  SUBROUTINE FieldVariable_ParameterSetsCopyIfExists(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FieldRoutines_ParameterSetTypes,FieldRoutines
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: fromParameterSet,toParameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetsCopyIfExists",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    IF(parameterFromSetType<=0.OR.parameterFromSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(parameterToSetType<=0.OR.parameterToSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    fromParameterSet=>fieldVariable%parameterSets%setType(parameterFromSetType)%ptr
    IF(ASSOCIATED(fromParameterSet)) THEN
      toParameterSet=>fieldVariable%parameterSets%setType(parameterToSetType)%ptr
      IF(ASSOCIATED(toParameterSet)) THEN
        !Do not need to do an update here as each rank already has the values.
        CALL DistributedVector_Copy(fromParameterSet%parameters,toParameterSet%parameters,alpha,err,error,*999)
      ENDIF
    ENDIF

    EXITS("FieldVariable_ParameterSetsCopyIfExists")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetsCopyIfExists",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetsCopyIfExists

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type fieldSetType for a field variable if it does not already exist,
  !>otherwise it will do nothing.
  SUBROUTINE FieldVariable_ParameterSetEnsureCreated(fieldVariable,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field to create the parameter set for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    LOGICAL :: parameterSetCreated

    ENTERS("FieldVariable_ParameterSetEnsureCreated",err,error,*999)

    CALL FieldVariable_ParameterSetCreated(fieldVariable,fieldSetType,parameterSetCreated,err,error,*999)
    IF(.NOT.parameterSetCreated) CALL FieldVariable_ParameterSetCreate(fieldVariable,fieldSetType,err,error,*999)

    EXITS("FieldVariable_ParameterSetEnsureCreated")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetEnsureCreated",err,error)
    RETURN 1
    
  END SUBROUTINE FieldVariable_ParameterSetEnsureCreated

  !
  !================================================================================================================================
  !

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type \todo make this call distributed vector add???
  SUBROUTINE FieldVariable_ParameterSetsAddDP0(fieldVariable,alpha,fieldFromSetType,fieldToSetType,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add the parameter sets for
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the add.
    INTEGER(INTG), INTENT(IN) :: fieldFromSetType !<The field parameter set identifier to add the parameters from \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldToSetType !<The field parameter set identifier to add the parameters to \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariable_ParameterSetsAddDP0",err,error,*999)

    CALL FieldVariable_ParameterSetsAddDP1(fieldVariable,[alpha],[fieldFromSetType],fieldToSetType,err,error,*999)

    EXITS("FieldVariable_ParameterSetsAddDP0")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetsAddDP0",err,error)
    RETURN 1
    
  END SUBROUTINE FieldVariable_ParameterSetsAddDP0

  !
  !================================================================================================================================
  !

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type \todo make this call distributed vector add??? 
  SUBROUTINE FieldVariable_ParameterSetsAddDP1(fieldVariable,alphas,fieldFromSetTypes,fieldToSetType,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add the parameter sets for
    REAL(DP), INTENT(IN) :: alphas(:) !<The multiplicative factor for the add.
    INTEGER(INTG), INTENT(IN) :: fieldFromSetTypes(:) !<The field parameter set identifier to add the parameters from \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fieldToSetType !<The field parameter set identifier to add the parameters to \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,parameterSetIdx
    REAL(DP) :: toValue
    TYPE(RealDPPtrType) :: fieldFromParameters(SIZE(fieldFromSetTypes,1))
    TYPE(FieldParameterSetType), POINTER :: fieldToParameterSet
    TYPE(FieldParameterSetPtrType) :: fieldFromParameterSets(SIZE(fieldFromSetTypes,1))
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetsAddDP1",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    
    IF(SIZE(alphas,1)/=SIZE(fieldFromSetTypes,1)) THEN
      localError="The size of the alpha array of "//TRIM(NumberToVString(SIZE(alphas,1),"*",err,error))// &
        & " does not match the size of the from set type array of "// &
        & TRIM(NumberToVString(SIZE(fieldFromSetTypes,1),"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    !Get the to parameter set
    NULLIFY(fieldToParameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldToSetType,fieldToParameterSet,err,error,*999)
    !Get the from parameter sets and their data
    DO parameterSetIdx=1,SIZE(fieldFromSetTypes,1)
      NULLIFY(fieldFromParameterSets(parameterSetIdx)%ptr)
      CALL FieldVariable_ParameterSetGet(fieldVariable,fieldFromSetTypes(parameterSetIdx), &
        & fieldFromParameterSets(parameterSetIdx)%ptr,err,error,*999)
      NULLIFY(fieldFromParameters(parameterSetIdx)%ptr)
      CALL DistributedVector_DataGet(fieldFromParameterSets(parameterSetIdx)%ptr%parameters, &
        & fieldFromParameters(parameterSetIdx)%ptr,err,error,*999)
    ENDDO !parameterSetIdx
    !Do not need to do an update here as each rank already has the values.
    !Add the field dofs
    DO dofIdx=1,fieldVariable%totalNumberOfDofs
      toValue=0.0_DP
      DO parameterSetIdx=1,SIZE(fieldFromSetTypes,1)
        toValue=toValue+alphas(parameterSetIdx)*fieldFromParameters(parameterSetIdx)%ptr(dofIdx)
      ENDDO !parameterSetIdx
      CALL DistributedVector_ValuesAdd(fieldToParameterSet%parameters,dofIdx,toValue,err,error,*999)
    ENDDO !dofIdx
    !Restore the from parameter set transfer
    DO parameterSetIdx=1,SIZE(fieldFromSetTypes,1)
      CALL DistributedVector_DataRestore(fieldFromParameterSets(parameterSetIdx)%ptr%parameters, &
        & fieldFromParameters(parameterSetIdx)%ptr,err,error,*999)
    ENDDO !parameterSetIdx

    EXITS("FieldVariable_ParameterSetsAddDP1")

    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetsAddDP1",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetsAddDP1

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values.
  SUBROUTINE FieldVariable_ParameterSetInterpolateGaussDP0(fieldVariable,fieldSetType,partialDerivativeType,userElementNumber, &
    & quadratureScheme,gaussPoint,values,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to interpolate.
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for. \see Basis_QuadratureSchemes,BasisRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPoint !<The Gauss point to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    REAL(DP) :: tempValues(SIZE(values,1),1)

    ENTERS("FieldVariable_ParameterSetInterpolateGaussDP0",err,error,*999)

    CALL FieldVariable_ParameterSetInterpolateGaussDP1(fieldVariable,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadratureScheme,[gaussPoint],tempValues,err,error,*999)
    values(1:SIZE(values,1))=tempValues(1:SIZE(values,1),1)

    EXITS("FieldVariable_ParameterSetInterpolateGaussDP0")
    RETURN
999 ERRORS("FieldVariable_ParameterSetInterpolateGaussDP0",err,error)
    EXITS("FieldVariable_ParameterSetInterpolateGaussDP0")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetInterpolateGaussDP0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values. If no Gauss points are specified then all Gauss points are interpolated.
  SUBROUTINE FieldVariable_ParameterSetInterpolateGaussDP1(fieldVariable,fieldSetType,partialDerivativeType,userElementNumber, &
    & quadSchemeType,gaussPoints,values,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to interpolate.
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The derivative number of the field to interpolate.  \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadSchemeType !<The quadrature scheme to interpolate the field for.  \see Basis_QuadratureSchemes,BasisRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPoints(:) !<gaussPoints(gaussPointIdx). The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,gaussPointIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    INTEGER(INTG) :: gaussPointIdx,localElementNumber,numberOfComponents
    LOGICAL :: ghostElement
    TYPE(BasisType), POINTER :: basis
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint
    TYPE(QuadratureSchemeType), POINTER :: quadratureScheme
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetInterpolateGaussDP1",err,error,*999)

    CALL FieldVariable_NumberOfComponentsGet(fieldVariable,numberOfComponents,err,error,*999)
    IF(SIZE(values,1)<numberOfComponents) THEN
      localError="The number of the coordinate values to return the interpolated field to is invalid. "// &
        & "The supplied size is "//TRIM(NumberToVString(SIZE(values,1),"*",err,error))//" and should be >= "// &
        & TRIM(NumberToVString(numberOfComponents,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(decompositionElements)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_LocalNumberGet(decompositionElements,userElementNumber,localElementNumber,ghostElement, &
      & err,error,*999)
    NULLIFY(domain)
    CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    NULLIFY(domainElements)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    !Get the basis for the decomposition domain. We will have to assume that the quadrature scheme will be the
    !same for all component bases.
    NULLIFY(basis)
    CALL DomainElements_ElementBasisGet(domainElements,localElementNumber,basis,err,error,*999)
    NULLIFY(quadratureScheme)
    CALL Basis_QuadratureSchemeGet(basis,quadSchemeType,quadratureScheme,err,error,*999)
    NULLIFY(interpolationParameters)
    CALL FieldVariable_InterpolationParameterInitialise(fieldVariable,interpolationParameters,err,error,*999)
    NULLIFY(interpolatedPoint)
    CALL Field_InterpolatedPointInitialise(interpolationParameters,interpolatedPoint,err,error,*999)
    CALL Field_InterpolationParametersElementGet(fieldSetType,localElementNumber,interpolationParameters,err,error,*999)
    IF(SIZE(gaussPoints,1)==0) THEN !Interpolate all Gauss points
      IF(SIZE(values,2)<quadratureScheme%numberOfGauss) THEN
        localError="The size of the second dimension of the specified values array of "// &
          & TRIM(NumberToVString(SIZE(values,2),"*",err,error))// &
          & " does not match the number of Gauss points of "// &
          & TRIM(NumberToVString(quadratureScheme%numberOfGauss,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      DO gaussPointIdx=1,quadratureScheme%numberOfGauss
        CALL Field_InterpolateGauss(partialDerivativeType,quadSchemeType,gaussPointIdx,interpolatedPoint,err,error,*999)
        values(1:numberOfComponents,gaussPointIdx)=interpolatedPoint%values(1:numberOfComponents,partialDerivativeType)
      ENDDO !gaussPointIdx
    ELSE
      IF(SIZE(values,2)/=SIZE(gaussPoints,1)) THEN
        localError="The specified number of Gauss points of "//TRIM(NumberToVString(SIZE(gaussPoints,1),"*",err,error))// &
          & " does not match the size of the supplied values array of "// &
          & TRIM(NumberToVString(SIZE(values,2),"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      DO gaussPointIdx=1,SIZE(gaussPoints,1)
        IF(gaussPoints(gaussPointIdx)<1.OR.gaussPoints(gaussPointIdx)>quadratureScheme%numberOfGauss) THEN
          localError="The specified Gauss point number of "// & 
            & TRIM(NumberToVString(gaussPoints(gaussPointIdx),"*",err,error))// &
            & " at Gauss point index "//TRIM(NumberToVString(gaussPointIdx,"*",err,error))// &
            & " is invalid. The Gauss point number should be >= 1 and <= "// &
            & TRIM(NumberToVString(quadratureScheme%numberOfGauss,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
        CALL Field_InterpolateGauss(partialDerivativeType,quadSchemeType,gaussPoints(gaussPointIdx),interpolatedPoint, &
          & err,error,*999)
        values(1:numberOfComponents,gaussPointIdx)=interpolatedPoint%values(1:numberOfComponents,partialDerivativeType)
      ENDDO !gaussPointIdx
    ENDIF
    !Finalise the interpolated point and parameters
    CALL Field_InterpolatedPointFinalise(interpolatedPoint,err,error,*999)
    CALL FieldVariable_InterpolationParameterFinalise(interpolationParameters,err,error,*999)

    EXITS("FieldVariable_ParameterSetInterpolateGaussDP1")
    RETURN
999 ERRORS("FieldVariable_ParameterSetInterpolateGaussDP1",err,error)
    EXITS("FieldVariable_ParameterSetInterpolateGaussDP1")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetInterpolateGaussDP1

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values.
  SUBROUTINE FieldVariable_ParameterSetInterpolateXiDP0(fieldVariable,fieldSetType,partialDerivativeType,userElementNumber,xi, &
    & values,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to interpolate.
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The derivative number of the field to interpolate.  \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The set of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    REAL(DP) :: tempXi(SIZE(xi,1),1),tempValues(SIZE(values,1),1)

    ENTERS("FieldVariable_ParameterSetInterpolateXiDP0",err,error,*999)

    tempXi(1:SIZE(xi,1),1)=xi(1:SIZE(xi,1))
    CALL FieldVariable_ParameterSetInterpolateXiDP1(fieldVariable,fieldSetType,partialDerivativeType,userElementNumber, &
      & tempXi,tempValues,err,error,*999)
    values(1:SIZE(values,1))=tempValues(1:SIZE(values,1),1)

    EXITS("FieldVariable_ParameterSetInterpolateXiDP0")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetInterpolateXiDP0",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetInterpolateXiDP0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values.
  SUBROUTINE FieldVariable_ParameterSetInterpolateXiDP1(fieldVariable,fieldSetType,partialDerivativeType,userElementNumber, &
    & xi,values,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to interpolate.
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative number of the field to interpolate. \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    REAL(DP), INTENT(IN) :: xi(:,:) !<xi(xiIdx,xiPointIdx). The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,xiPointIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    INTEGER(INTG) :: localElementNumber,numberOfComponents,xiPointsIdx
    LOGICAL :: ghostElement
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(FieldType), POINTER :: field
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetInterpolateXiDP1",err,error,*999)

    CALL FieldVariable_NumberOfComponentsGet(fieldVariable,numberOfComponents,err,error,*999)
    IF(SIZE(values,1)<numberOfComponents) THEN
      localError="The number of the coordinate values to return the interpolated field to is invalid. "// &
        & "The supplied size is "//TRIM(NumberToVString(SIZE(values,1),"*",err,error))//" and should be >= "// &
        & TRIM(NumberToVString(numberOfComponents,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(values,2)/=SIZE(xi,2)) THEN
      localError="The specified number of xi points of "//TRIM(NumberToVString(SIZE(xi,2),"*",err,error))// &
        & " does not match the size of the supplied values array of "// &
        & TRIM(NumberToVString(SIZE(values,2),"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(decompositionElements)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_LocalNumberGet(decompositionElements,userElementNumber,localElementNumber,ghostElement, &
      & err,error,*999)
    NULLIFY(interpolationParameters)
    CALL FieldVariable_InterpolationParameterInitialise(fieldVariable,interpolationParameters,err,error,*999)
    NULLIFY(interpolatedPoint)
    CALL Field_InterpolatedPointInitialise(interpolationParameters,interpolatedPoint,err,error,*999)
    CALL Field_InterpolationParametersElementGet(fieldSetType,localElementNumber,interpolationParameters,err,error,*999)
    DO xiPointsIdx=1,SIZE(xi,2)
      CALL Field_InterpolateXi(partialDerivativeType,xi(:,xiPointsIdx),interpolatedPoint,err,error,*999)
      values(1:numberOfComponents,xiPointsIdx)=interpolatedPoint%values(1:numberOfComponents,partialDerivativeType)
    ENDDO !xiPointsIdx
    !Finalise the interpolated point and parameters
    CALL Field_InterpolatedPointFinalise(interpolatedPoint,err,error,*999)
    CALL FieldVariable_InterpolationParameterFinalise(interpolationParameters,err,error,*999)

    EXITS("FieldVariable_ParameterSetInterpolateXiDP1")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetInterpolateXiDP1",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetInterpolateXiDP1

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the constant of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateConstantIntg(fieldVariable,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    INTEGER, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateConstantIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateConstantIntg")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateConstantIntg",err,error)
    EXITS("FieldVariable_ParameterSetUpdateConstantIntg")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateConstantIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateConstantSP(fieldVariable,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateConstantSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)  

    EXITS("FieldVariable_ParameterSetUpdateConstantSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateConstantSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateConstantSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateConstantDP(fieldVariable,fieldSetType,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetUpdateConstantDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateConstantDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateConstantDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateConstantDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateConstantL(fieldVariable,fieldSetType,componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateConstantL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(fieldVariable,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateConstantL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateConstantL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateConstantL

  !
  !================================================================================================================================
  !

  !>Update the given parameter set an integer value for the specified data point of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateDataPointIntg(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateDataPointIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user data point number "// &
        & TRIM(NumberToVString(userDataPointNumber,"*",err,error))//" as it is a ghost data point."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateDataPointIntg")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateDataPointIntg",err,error)
    EXITS("FieldVariable_ParameterSetUpdateDataPointIntg")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateDataPointIntg

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateDataPointSP(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value, & 
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateDataPointSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user data point number "// &
        & TRIM(NumberToVString(userDataPointNumber,"*",err,error))//" as it is a ghost data point."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateDataPointSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateDataPointSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateDataPointSP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateDataPointDP(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to Update the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateDataPointDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user data point number "// &
        & TRIM(NumberToVString(userDataPointNumber,"*",err,error))//" as it is a ghost data point."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateDataPointDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateDataPointDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateDataPointDP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetUpdateDataPointL(fieldVariable,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to Update the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateDataPointL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user data point number "// &
        & TRIM(NumberToVString(userDataPointNumber,"*",err,error))//" as it is a ghost data point."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateDataPointL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateDataPointL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateDataPointL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular user element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateElementIntg(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateElementIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by element for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateElementIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateElementIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateElementIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular user element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateElementSP(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateElementSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by element for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateElementSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateElementSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateElementSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular user element of the field variable component. 
  SUBROUTINE FieldVariable_ParameterSetUpdateElementDP(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateElementDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by element for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateElementDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateElementDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateElementDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular user element of the field variable component. 
  SUBROUTINE FieldVariable_ParameterSetUpdateElementL(fieldVariable,fieldSetType,userElementNumber,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateElementL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(fieldVariable,userElementNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by element for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateElementL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateElementL",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateElementL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular data point of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateElementDataPointIntg(fieldVariable,fieldSetType,userElementNumber,dataPointIndex, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number the data point is projected on
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point projected on the element
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateElementDataPointIntg",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDataDOFGet(fieldVariable,userElementNumber,dataPointIndex,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user element "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateElementDataPointIntg")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateElementDataPointIntg",err,error)
    EXITS("FieldVariable_ParameterSetUpdateElementDataPointIntg")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateElementDataPointIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular data point of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateElementDataPointSP(fieldVariable,fieldSetType,userElementNumber,dataPointIndex, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number the data point is projected on
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point projected on the element
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateElementDataPointSP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDataDOFGet(fieldVariable,userElementNumber,dataPointIndex,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user element "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateElementDataPointSP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateElementDataPointSP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateElementDataPointSP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateElementDataPointSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular data point of the field variable component. 
  SUBROUTINE FieldVariable_ParameterSetUpdateElementDataPointDP(fieldVariable,fieldSetType,userElementNumber,dataPointIndex, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number the data point is projected on
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point projected on the element
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateElementDataPointDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDataDOFGet(fieldVariable,userElementNumber,dataPointIndex,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user element "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateElementDataPointDP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateElementDataPointDP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateElementDataPointDP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateElementDataPointDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular data point of the field variable component. 
  SUBROUTINE FieldVariable_ParameterSetUpdateElementDataPointL(fieldVariable,fieldSetType,userElementNumber,dataPointIndex, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number the data point is projected on
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point projected on the element
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateElementDataPointL",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDataDOFGet(fieldVariable,userElementNumber,dataPointIndex,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user element "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateElementDataPointL")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateElementDataPointL",err,error)
    EXITS("FieldVariable_ParameterSetUpdateElementDataPointL")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateElementDataPointL

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable.
  SUBROUTINE FieldVariable_ParameterSetUpdateFinish(fieldVariable,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to finish the update for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldType), POINTER :: field
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetUpdateFinish",err,error,*999)

    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL DistributedVector_UpdateFinish(parameterSet%parameters,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    IF(field%type==FIELD_GEOMETRIC_TYPE.AND.fieldSetType==FIELD_VALUES_SET_TYPE) THEN
      !Geometric field values have changed so update the geometric parameters (e.g., lines etc.)
      CALL Field_GeometricParametersCalculate(field,err,error,*999)
    ENDIF

    EXITS("FieldVariable_ParameterSetUpdateFinish")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateFinish",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateFinish

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given integer value for a particular gauss point of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateGaussPointIntg(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateGaussPointIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by Gauss point for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateGaussPointIntg")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateGaussPointIntg",err,error)
    EXITS("FieldVariable_ParameterSetUpdateGaussPointIntg")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateGaussPointIntg

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given single precision value for a particular gauss point of the field variable component. 
  SUBROUTINE FieldVariable_ParameterSetUpdateGaussPointSP(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateGaussPointSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by Gauss point for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateGaussPointSP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateGaussPointSP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateGaussPointSP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateGaussPointSP

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given double precision value for a particular gauss point of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateGaussPointDP(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateGaussPointDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by Gauss point for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateGaussPointDP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateGaussPointDP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateGaussPointDP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateGaussPointDP

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given logical value for a particular gauss point of the field variable component. 
  SUBROUTINE FieldVariable_ParameterSetUpdateGaussPointL(fieldVariable,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateGaussPointL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by Gauss point for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateGaussPointL")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateGaussPointL",err,error)
    EXITS("FieldVariable_ParameterSetUpdateGaussPointL")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateGaussPointL

  !
  !================================================================================================================================
  !

  !>Update the given parameter set an integer value for the specified local data point of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalDataPointIntg(fieldVariable,fieldSetType,dataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateLocalDataPointIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalDataPointDOFGet(fieldVariable,dataPointNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalDataPointIntg")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalDataPointIntg",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalDataPointIntg")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalDataPointIntg

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified local data point of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalDataPointSP(fieldVariable,fieldSetType,dataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateLocalDataPointSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalDataPointDOFGet(fieldVariable,dataPointNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalDataPointSP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalDataPointSP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalDataPointSP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalDataPointSP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified local data point of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalDataPointDP(fieldVariable,fieldSetType,dataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetUpdateLocalDataPointDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalDataPointDOFGet(fieldVariable,dataPointNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalDataPointDP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalDataPointDP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalDataPointDP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalDataPointDP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified local data point of a field variable component. 
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalDataPointL(fieldVariable,fieldSetType,dataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update the value for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateLocalDataPointL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalDataPointDOFGet(fieldVariable,dataPointNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalDataPointL")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalDataPointL",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalDataPointL")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalDataPointL
  
  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalDOFIntg(fieldVariable,fieldSetType,dofNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateLocalDOFIntg",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(dofNumber<1.OR.dofNumber>domainMapping%numberOfLocal) THEN
      localError="The field local dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%numberOfLocal,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,dofNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalDOFIntg")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalDOFIntg",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalDOFIntg")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalDOFIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalDOFSP(fieldVariable,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateLocalDOFSP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(dofNumber<1.OR.dofNumber>domainMapping%numberOfLocal) THEN
      localError="The field local dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%numberOfLocal,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,dofNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalDOFSP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalDOFSP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalDOFSP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalDOFSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalDOFDP(fieldVariable,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateLocalDOFDP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(dofNumber<1.OR.dofNumber>domainMapping%numberOfLocal) THEN
      localError="The field local dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%numberOfLocal,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,dofNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalDOFDP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalDOFDP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalDOFDP")
    RETURN 1
    
  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalDOFDP
  
  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local dof of the field variable.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalDOFL(fieldVariable,fieldSetType,dofNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: dofNumber !<The dof number to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateLocalDOFL",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    IF(dofNumber<1.OR.dofNumber>domainMapping%numberOfLocal) THEN
      localError="The field local dof number of "//TRIM(NumberToVString(dofNumber,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%numberOfLocal,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(fieldVariable%variableType,"*",err,error))
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//TRIM(NumberToVString(fieldVariable%field%userNumber,"*",err,error))
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,dofNumber,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalDOFL")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalDOFL",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalDOFL")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalDOFL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalElementIntg(fieldVariable,fieldSetType,localNumberElement, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field varible to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateLocalElementIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localNumberElement,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalElementIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateLocalElementIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalElementIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalElementSP(fieldVariable,fieldSetType,localNumberElement,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateLocalElementSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localNumberElement,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalElementSP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalElementSP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalElementSP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalElementSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalElementDP(fieldVariable,fieldSetType,localNumberElement,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateLocalElementDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localNumberElement,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalElementDP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalElementDP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalElementDP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalElementDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local element of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalElementL(fieldVariable,fieldSetType,localNumberElement,componentNumber, &
    & value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: localNumberElement !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetUpdateLocalElementL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localNumberElement,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalElementL")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalElementL",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalElementL")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalElementL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular gauss point of the field variable component using the local element index. 
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalGaussPointIntg(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetUpdateLocalGaussPointIntg",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,localElementNumber,componentNumber,localDof, &
      & err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetUpdateLocalGaussPointIntg")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalGaussPointIntg",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalGaussPointIntg")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalGaussPointIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular gauss point of the field variable component using the local element index. 
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalGaussPointSP(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variaable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateLocalGaussPointSP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,localElementNumber,componentNumber,localDof, &
      & err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetUpdateLocalGaussPointSP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalGaussPointSP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalGaussPointSP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalGaussPointSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular gauss point of the field variable component using the local element index. 
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalGaussPointDP(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateLocalGaussPointDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,localElementNumber,componentNumber,localDof, &
      & err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetUpdateLocalGaussPointDP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalGaussPointDP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalGaussPointDP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalGaussPointDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular gauss point of the field variable component using the local element index. 
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalGaussPointL(fieldVariable,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateLocalGaussPointL",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,localElementNumber,componentNumber,localDof, &
      & err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)    

    EXITS("FieldVariable_ParameterSetUpdateLocalGaussPointL")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalGaussPointL",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalGaussPointL")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalGaussPointL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalNodeIntg(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
 
    ENTERS("FieldVariable_ParameterSetUpdateLocalNodeIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalNodeIntg")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalNodeIntg",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalNodeIntg")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalNodeIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalNodeSP(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVarable_ParameterSetUpdateLocalNodeSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalNodeSP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalNodeSP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalNodeSP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalNodeSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalNodeDP(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateLocalNodeDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalNodeDP")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalNodeDP",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalNodeDP")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalNodeDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateLocalNodeL(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & localNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("Field_ParameterSetUpdateLocalNodeL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateLocalNodeL")
    RETURN
999 ERRORS("FieldVariable_ParameterSetUpdateLocalNodeL",err,error)
    EXITS("FieldVariable_ParameterSetUpdateLocalNodeL")
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateLocalNodeL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular user node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateNodeIntg(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateNodeIntg",err,error,*999)

    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by node for user node number "// &
        & TRIM(NumberToVString(userNodeNumber,"*",err,error))//" as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateNodeIntg")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateNodeIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular user node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateNodeSP(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateNodeSP",err,error,*999)

    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by node for user node number "// &
        & TRIM(NumberToVString(userNodeNumber,"*",err,error))//" as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateNodeSP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateNodeSP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateNodeSP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular user node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateNodeDP(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateNodeDP",err,error,*999)

    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by node for user node number "// &
        & TRIM(NumberToVString(userNodeNumber,"*",err,error))//" as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateNodeDP")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateNodeDP",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateNodeDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular user node, derivative and version of the field variable component.
  SUBROUTINE FieldVariable_ParameterSetUpdateNodeL(fieldVariable,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to update
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to finish the update for \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetUpdateNodeL",err,error,*999)

    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by node for user node number "// &
        & TRIM(NumberToVString(userNodeNumber,"*",err,error))//" as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateNodeL")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateNodeL",err,error)
    RETURN 1
    
  END SUBROUTINE FieldVariable_ParameterSetUpdateNodeL

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable.
  SUBROUTINE FieldVariable_ParameterSetUpdateStart(fieldVariable,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to start the update for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to update \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetUpdateStart",err,error,*999)

    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)

    CALL DistributedVector_UpdateStart(parameterSet%parameters,err,error,*999)

    EXITS("FieldVariable_ParameterSetUpdateStart")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetUpdateStart",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetUpdateStart

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field variable parameter set distributed vector. 
  SUBROUTINE FieldVariable_ParameterSetVectorGet(fieldVariable,fieldSetType,distributedVector,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to get the parameter set vector from
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FieldRoutines_ParameterSetTypes,FieldRoutines
    TYPE(DistributedVectorType), POINTER :: distributedVector !<On return, a pointer to the field parameter set distributed vector. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet

    ENTERS("FieldVariable_ParameterSetVectorGet",err,error,*999)

    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    NULLIFY(distributedVector)
    CALL FieldParameterSet_ParametersGet(parameterSet,distributedVector,err,error,*999)

    EXITS("FieldVariable_ParameterSetVectorGet")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetVectorGet",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetVectorGet

  ! 
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable.
  SUBROUTINE FieldVariable_ParametersToFieldVariableParametersCopy(fromFieldVariable,fromParameterSetType, &
    & fromComponentNumber,toFieldVariable,toParameterSetType,toComponentNumber,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fromFieldVariable !<A pointer to the field variable to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    TYPE(FieldVariableType), POINTER :: toFieldVariable !<A pointer to the field variable to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to \see FieldRoutines_ParameterSetTypes,FieldRoutines
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: elementIdx,derivativeIdx,versionIdx,localDOF,nodeIdx,valueIntg,gaussPointIdx
    INTEGER(INTG), POINTER :: fromParameterDataIntg(:)
    REAL(SP) :: valueSP
    REAL(SP), POINTER :: fromParameterDataSP(:)
    REAL(DP) :: valueDP
    REAL(DP), POINTER :: fromParameterDataDP(:)
    LOGICAL :: valueL
    LOGICAL, POINTER :: fromParameterDataL(:)
    TYPE(DomainType), POINTER :: fromDomain,toDomain
    TYPE(DomainElementsType), POINTER :: fromDomainElements
    TYPE(DomainNodesType), POINTER :: fromDomainNodes
    TYPE(DomainTopologyType), POINTER :: fromDomainTopology
    TYPE(VARYING_STRING) :: localError

    NULLIFY(fromParameterDataIntg)
    NULLIFY(fromParameterDataSP)
    NULLIFY(fromParameterDataDP)
    NULLIFY(fromParameterDataL)

    ENTERS("FieldVariable_ParametersToFieldVariableParametersCopy",err,error,*995)

    IF(.NOT.ASSOCIATED(fromFieldVariable)) CALL FlagError("From field variable is not associated.",err,error,*995)
    IF(.NOT.ASSOCIATED(toFieldVariable)) CALL FlagError("To field variable is not associated.",err,error,*995)
    NULLIFY(fromDomain)
    CALL FieldVariable_ComponentDomainGet(fromFieldVariable,fromComponentNumber,fromDomain,err,error,*995)
    NULLIFY(toDomain)
    CALL FieldVariable_ComponentDomainGet(toFieldVariable,toComponentNumber,toDomain,err,error,*995)
    IF(.NOT.ASSOCIATED(fromDomain,toDomain)) THEN
      CALL FlagError("The from field variable component domain is not associated with the "// &
        & "to field variable component domain.",err,error,*995)
    ENDIF
    IF(fromFieldVariable%components(fromComponentNumber)%interpolationType/= &
      & toFieldVariable%components(toComponentNumber)%interpolationType) THEN
      localError="The from field variable component interpolation type of "// &
        & TRIM(NumberToVString(fromFieldVariable%components(fromComponentNumber)%interpolationType,"*",err,error))// &
        & " does not match the to variable component interpolation type of "// &
        & TRIM(NumberToVString(toFieldVariable%components(toComponentNumber)%interpolationType,"*",err,error))//"."
      CALL FlagError(localError,err,error,*995)
    ENDIF
    IF(fromFieldVariable%dataType/=toFieldVariable%dataType) THEN
      localError="The from field variable data type of "// &
        & TRIM(NumberToVString(fromFieldVariable%dataType,"*",err,error))// &
        & " does not match the to variable data type of "// &
        & TRIM(NumberToVString(toFieldVariable%dataType,"*",err,error))//"."
      CALL FlagError(localError,err,error,*995)
    ENDIF
    
    SELECT CASE(fromFieldVariable%components(fromComponentNumber)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      SELECT CASE(fromFieldVariable%dataType)
      CASE(FIELD_INTG_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataIntg,err,error,*999)
        localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap%constantParam2DOFMap
        valueIntg=fromParameterDataIntg(localDOF)
        CALL FieldVariable_ParameterSetUpdateConstant(toFieldVariable,toParameterSetType,toComponentNumber,valueIntg, &
          & err,error,*999)
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataIntg,err,error,*999)
      CASE(FIELD_SP_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataSP,err,error,*999)
        localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap%constantParam2DOFMap
        valueSP=fromParameterDataSP(localDOF)
        CALL FieldVariable_ParameterSetUpdateConstant(toFieldVariable,toParameterSetType,toComponentNumber,valueSP,err,error,*999)
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataSP,err,error,*999)
      CASE(FIELD_DP_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataDP,err,error,*999)
        localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap%constantParam2DOFMap
        valueDP=fromParameterDataDP(localDOF)
        CALL FieldVariable_ParameterSetUpdateConstant(toFieldVariable,toParameterSetType,toComponentNumber,valueDP,err,error,*999)
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataDP,err,error,*999)
      CASE(FIELD_L_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataL,err,error,*999)
        localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap%constantParam2DOFMap
        valueL=fromParameterDataL(localDOF)
        CALL FieldVariable_ParameterSetUpdateConstant(toFieldVariable,toParameterSetType,toComponentNumber,valueL,err,error,*999)
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataL,err,error,*999)
      CASE DEFAULT
        localError="The from field variable data type of "//TRIM(NumberToVString(fromFieldVariable%dataType,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      NULLIFY(fromDomainTopology)
      CALL Domain_DomainTopologyGet(fromDomain,fromDomainTopology,err,error,*999)
      NULLIFY(fromDomainElements)
      CALL DomainTopology_DomainElementsGet(fromDomainTopology,fromDomainElements,err,error,*999)
      SELECT CASE(fromFieldVariable%dataType)
      CASE(FIELD_INTG_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataIntg,err,error,*999)
        DO elementIdx=1,fromDomainElements%totalNumberOfElements
          localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap%elementParam2DOFMap%elements(elementIdx)
          valueIntg=fromParameterDataIntg(localDOF)
          CALL FieldVariable_ParameterSetUpdateLocalElement(toFieldVariable,toParameterSetType,elementIdx,toComponentNumber, &
            & valueIntg,err,error,*999)
        ENDDO !elementIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataIntg,err,error,*999)
      CASE(FIELD_SP_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataSP,err,error,*999)
        DO elementIdx=1,fromDomainElements%totalNumberOfElements
          localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap%elementParam2DOFMap%elements(elementIdx)
          valueSP=fromParameterDataSP(localDOF)
          CALL FieldVariable_ParameterSetUpdateLocalElement(toFieldVariable,toParameterSetType,elementIdx,toComponentNumber, &
            & valueSP,err,error,*999)
        ENDDO !elementIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataSP,err,error,*999)
      CASE(FIELD_DP_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataDP,err,error,*999)
        DO elementIdx=1,fromDomainElements%totalNumberOfElements
          localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap%elementParam2DOFMap%elements(elementIdx)
          valueDP=fromParameterDataDP(localDOF)
          CALL FieldVariable_ParameterSetUpdateLocalElement(toFieldVariable,toParameterSetType,elementIdx,toComponentNumber, &
            & valueDP,err,error,*999)
        ENDDO !elementIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataDP,err,error,*999)
      CASE(FIELD_L_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataL,err,error,*999)
        DO elementIdx=1,fromDomainElements%totalNumberOfElements
          localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap%elementParam2DOFMap%elements(elementIdx)
          valueL=fromParameterDataL(localDOF)
          CALL FieldVariable_ParameterSetUpdateLocalElement(toFieldVariable,toParameterSetType,elementIdx,toComponentNumber, &
            & valueL,err,error,*999)
        ENDDO !elementIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataL,err,error,*999)
      CASE DEFAULT
        localError="The from field variable data type of "//TRIM(NumberToVString(fromFieldVariable%dataType,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      NULLIFY(fromDomainTopology)
      CALL Domain_DomainTopologyGet(fromDomain,fromDomainTopology,err,error,*999)
      NULLIFY(fromDomainNodes)
      CALL DomainTopology_DomainNodesGet(fromDomainTopology,fromDomainNodes,err,error,*999)
      SELECT CASE(fromFieldVariable%dataType)
      CASE(FIELD_INTG_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataIntg,err,error,*999)
        DO nodeIdx=1,fromDomainNodes%totalNumberOfNodes
          DO derivativeIdx=1,fromDomainNodes%nodes(nodeIdx)%numberOfDerivatives
            DO versionIdx=1,fromDomainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%numberOfVersions
              localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
              valueIntg=fromParameterDataIntg(localDOF)
              CALL FieldVariable_ParameterSetUpdateLocalNode(toFieldVariable,toParameterSetType,versionIdx,derivativeIdx, &
                & nodeIdx,toComponentNumber,valueIntg,err,error,*999)
            ENDDO !versionIdx
          ENDDO !derivativeIdx
        ENDDO !nodeIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataIntg,err,error,*999)
      CASE(FIELD_SP_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataSP,err,error,*999)
        DO nodeIdx=1,fromDomainNodes%totalNumberOfNodes
          DO derivativeIdx=1,fromDomainNodes%nodes(nodeIdx)%numberOfDerivatives
            DO versionIdx=1,fromDomainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%numberOfVersions
              localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
              valueSP=fromParameterDataSP(localDOF)
              CALL FieldVariable_ParameterSetUpdateLocalNode(toFieldVariable,toParameterSetType,versionIdx,derivativeIdx, &
                & nodeIdx,toComponentNumber,valueSP,err,error,*999)
            ENDDO !versionIdx
          ENDDO !derivativeIdx
        ENDDO !nodeIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataSP,err,error,*999)
      CASE(FIELD_DP_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataDP,err,error,*999)
        DO nodeIdx=1,fromDomainNodes%totalNumberOfNodes
          DO derivativeIdx=1,fromDomainNodes%nodes(nodeIdx)%numberOfDerivatives
            DO versionIdx=1,fromDomainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%numberOfVersions
              localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
              valueDP=fromParameterDataDP(localDOF)
              CALL FieldVariable_ParameterSetUpdateLocalNode(toFieldVariable,toParameterSetType,versionIdx,derivativeIdx, &
                & nodeIdx,toComponentNumber,valueDP,err,error,*999)
            ENDDO !versionIdx
          ENDDO !derivativeIdx
        ENDDO !nodeIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataDP,err,error,*999)
      CASE(FIELD_L_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataL,err,error,*999)
        DO nodeIdx=1,fromDomainNodes%totalNumberOfNodes
          DO derivativeIdx=1,fromDomainNodes%nodes(nodeIdx)%numberOfDerivatives
            DO versionIdx=1,fromDomainNodes%nodes(nodeIdx)%derivatives(derivativeIdx)%numberOfVersions
              localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(nodeIdx)%derivatives(derivativeIdx)%versions(versionIdx)
              valueL=fromParameterDataL(localDOF)
              CALL FieldVariable_ParameterSetUpdateLocalNode(toFieldVariable,toParameterSetType,versionIdx,derivativeIdx, &
                & nodeIdx,toComponentNumber,valueL,err,error,*999)
            ENDDO !versionIdx
          ENDDO !derivativeIdx
        ENDDO !nodeIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataL,err,error,*999)
      CASE DEFAULT
        localError="The from field variable data type of "//TRIM(NumberToVString(fromFieldVariable%dataType,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implmented.",err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      NULLIFY(fromDomainTopology)
      CALL Domain_DomainTopologyGet(fromDomain,fromDomainTopology,err,error,*999)
      NULLIFY(fromDomainElements)
      CALL DomainTopology_DomainElementsGet(fromDomainTopology,fromDomainElements,err,error,*999)
      SELECT CASE(fromFieldVariable%dataType)
      CASE(FIELD_INTG_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataIntg,err,error,*999)
        DO elementIdx=1,fromDomainElements%totalNumberOfElements
          DO gaussPointIdx=1,SIZE(fromFieldVariable%components(fromComponentNumber)%paramToDOFMap% &
            & gaussPointParam2DOFMap%gaussPoints,1)
            localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gaussPointIdx,elementIdx)
            valueIntg=fromParameterDataIntg(localDOF)
            CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(toFieldVariable,toParameterSetType,gaussPointIdx, &
              & elementIdx,toComponentNumber,valueIntg,err,error,*999)
          ENDDO !gaussPointIdx
        ENDDO !elementIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataIntg,err,error,*999)
      CASE(FIELD_SP_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataSP,err,error,*999)
        DO elementIdx=1,fromDomainElements%totalNumberOfElements
          DO gaussPointIdx=1,SIZE(fromFieldVariable%components(fromComponentNumber)% &
            & paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
            localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gaussPointIdx,elementIdx)
            valueSP=fromParameterDataSP(localDOF)
            CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(toFieldVariable,toParameterSetType,gaussPointIdx, &
              & elementIdx,toComponentNumber,valueSP,err,error,*999)
          ENDDO !gaussPointIdx
        ENDDO !elementIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataSP,err,error,*999)
      CASE(FIELD_DP_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataDP,err,error,*999)
        DO elementIdx=1,fromDomainElements%totalNumberOfElements
          DO gaussPointIdx=1,SIZE(fromFieldVariable%components(fromComponentNumber)% &
            & paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
            localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gaussPointIdx,elementIdx)
            valueDP=fromParameterDataDP(localDOF)
            CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(toFieldVariable,toParameterSetType,gaussPointIdx, &
              & elementIdx,toComponentNumber,valueDP,err,error,*999)
          ENDDO !gaussPointIdx
        ENDDO !elementIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataDP,err,error,*999)
      CASE(FIELD_L_TYPE)
        CALL FieldVariable_ParameterSetDataGet(fromFieldVariable,fromParameterSetType,fromParameterDataL,err,error,*999)
        DO elementIdx=1,fromDomainElements%totalNumberOfElements
          DO gaussPointIdx=1,SIZE(fromFieldVariable%components(fromComponentNumber)% &
            & paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
            localDOF=fromFieldVariable%components(fromComponentNumber)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gaussPointIdx,elementIdx)
            valueL=fromParameterDataL(localDOF)
            CALL FieldVariable_ParameterSetUpdateLocalGaussPoint(toFieldVariable,toParameterSetType,gaussPointIdx, &
              & elementIdx,toComponentNumber,valueL,err,error,*999)
          ENDDO !gaussPointIdx
        ENDDO !elementIdx
        CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataL,err,error,*999)
      CASE DEFAULT
        CALL FlagError("Invalid data type or not implemented.",err,error,*999)
      END SELECT
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The from field variable component interpolation type of "// &
        & TRIM(NumberToVString(fromFieldVariable%components(fromComponentNumber)% &
        & interpolationType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FieldVariable_ParametersToFieldVariableParametersCopy")
    RETURN
999 IF(ASSOCIATED(fromParameterDataIntg)) &
      & CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataIntg,err,error,*998)
998 IF(ASSOCIATED(fromParameterDataSP)) &
      & CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataSP,err,error,*997)
997 IF(ASSOCIATED(fromParameterDataDP)) &
      & CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataDP,err,error,*996)
996 IF(ASSOCIATED(fromParameterDataL)) &
      & CALL FieldVariable_ParameterSetDataRestore(fromFieldVariable,fromParameterSetType,fromParameterDataDP,err,error,*995)
995 ERRORS("FieldVariable_ParametersToFieldVariableParametersCopy",err,error)    
    EXITS("FieldVariable_ParametersToFieldVariableParametersCopy")    
    RETURN 1

  END SUBROUTINE FieldVariable_ParametersToFieldVariableParametersCopy

  !
  !================================================================================================================================
  !

  !>Starts the creation of in a field variables list. 
  SUBROUTINE FieldVariablesList_CreateStart(fieldVariablesList,err,error,*)

    !Argument variables
    TYPE(FieldVariablesListType), POINTER :: fieldVariablesList !<A pointer to the field variables list to start the creation of. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariablesList_CreateStart",err,error,*999)

    CALL FieldVariablesList_Initialise(fieldVariablesList,err,error,*999)
    
    EXITS("FieldVariablesList_CreateStart")
    RETURN
999 ERRORSEXITS("FieldVariablesList_CreateStart",err,error)
    RETURN 1

  END SUBROUTINE FieldVariablesList_CreateStart

  !
  !================================================================================================================================
  !

  !>Finishes the creation of in a field variables list. 
  SUBROUTINE FieldVariablesList_CreateFinish(fieldVariablesList,err,error,*)

    !Argument variables
    TYPE(FieldVariablesListType), POINTER :: fieldVariablesList !<A pointer to the field variables list to finish creating. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariablesList_CreateFinish",err,error,*999)

#ifdef WITH_PRECHECKS    
    IF(.NOT.ASSOCIATED(fieldVariablesList)) CALL FlagError("Field variables list is not associated.",err,error,*999)
#endif    

    !Do nothing for now
    
    EXITS("FieldVariablesList_CreateFinish")
    RETURN
999 ERRORSEXITS("FieldVariablesList_CreateFinish",err,error)
    RETURN 1

  END SUBROUTINE FieldVariablesList_CreateFinish

  !
  !================================================================================================================================
  !

  !>Destroys a field variables list. 
  SUBROUTINE FieldVariablesList_Destroy(fieldVariablesList,err,error,*)

    !Argument variables
    TYPE(FieldVariablesListType), POINTER :: fieldVariablesList !<A pointer to the field variables list to destroy. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariablesList_Destroy",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariablesList)) CALL FlagError("Field variables list is not associated.",err,error,*999)

    CALL FieldVariablesList_Finalise(fieldVariablesList,err,error,*999)
    
    EXITS("FieldVariablesList_Destroy")
    RETURN
999 ERRORSEXITS("FieldVariablesList_Destroy",err,error)
    RETURN 1

  END SUBROUTINE FieldVariablesList_Destroy

  !
  !================================================================================================================================
  !

  !>Finalises a field variables list and deallocates all memory
  SUBROUTINE FieldVariablesList_Finalise(fieldVariablesList,err,error,*)

    !Argument variables
    TYPE(FieldVariablesListType), POINTER :: fieldVariablesList !<A pointer to the field variables list to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariablesList_Finalise",err,error,*999)

    IF(ASSOCIATED(fieldVariablesList)) THEN
      IF(ALLOCATED(fieldVariablesList%variables)) DEALLOCATE(fieldVariablesList%variables)
      DEALLOCATE(fieldVariablesList)
    ENDIF
   
    EXITS("FieldVariablesList_Finalise")
    RETURN
999 ERRORSEXITS("FieldVariablesList_Finalise",err,error)
    RETURN 1

  END SUBROUTINE FieldVariablesList_Finalise

  !
  !================================================================================================================================
  !

  !>Starts the creation of in a field variables list. 
  SUBROUTINE FieldVariablesList_Initialise(fieldVariablesList,err,error,*)

    !Argument variables
    TYPE(FieldVariablesListType), POINTER :: fieldVariablesList !<A pointer to the field variables list to create. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("FieldVariablesList_Initialise",err,error,*998)

#ifdef WITH_PRECHECKS    
    IF(ASSOCIATED(fieldVariablesList)) CALL FlagError("Field variables list is already associated.",err,error,*998)
#endif    
    
    ALLOCATE(fieldVariablesList,STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate field variables list.",err,error,*999)
    fieldVariablesList%numberOfVariables=0
    
    EXITS("FieldVariablesList_Initialise")
    RETURN
999 CALL FieldVariablesList_Finalise(fieldVariablesList,dummyErr,dummyError,*998)
998 ERRORSEXITS("FieldVariablesList_Initialise",err,error)
    RETURN 1

  END SUBROUTINE FieldVariablesList_Initialise

  !
  !================================================================================================================================
  !

  !>Gets the number of variables in a field variables list. 
  SUBROUTINE FieldVariablesList_NumberOfVariablesGet(fieldVariablesList,numberOfVariables,err,error,*)

    !Argument variables
    TYPE(FieldVariablesListType), POINTER :: fieldVariablesList !<A pointer to the field variables list to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On exit, the number of variables in the field variables list.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariablesList_NumberOfVariablesGet",err,error,*999)

#ifdef WITH_PRECHECKS    
    IF(.NOT.ASSOCIATED(fieldVariablesList)) CALL FlagError("Field variables list is not associated.",err,error,*999)
#endif    
    
    numberOfVariables=fieldVariablesList%numberOfVariables
    
    EXITS("FieldVariablesList_NumberOfVariablesGet")
    RETURN
999  ERRORSEXITS("FieldVariablesList_NumberOfVariablesGet",err,error)
    RETURN 1

  END SUBROUTINE FieldVariablesList_NumberOfVariablesGet

  !
  !================================================================================================================================
  !

  !>Adds a field variable to a field variables list. 
  SUBROUTINE FieldVariablesList_VariableAdd(fieldVariablesList,fieldVariable,err,error,*)

    !Argument variables
    TYPE(FieldVariablesListType), POINTER :: fieldVariablesList !<A pointer to the field variables list to add the field variable to.
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to add to the field variables list.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableIdx
    LOGICAL :: variableFound
    TYPE(FieldVariablePtrType), ALLOCATABLE :: newVariablesList(:)

    ENTERS("FieldVariablesList_VariableAdd",err,error,*999)

#ifdef WITH_PRECHECKS    
    IF(.NOT.ASSOCIATED(fieldVariablesList)) CALL FlagError("Field variables list is not associated.",err,error,*999)
    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("The field variable to add is not associated.",err,error,*999)
#endif    

    ALLOCATE(newVariablesList(fieldVariablesList%numberOfVariables+1),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate new variables list.",err,error,*999)
    variableFound=.FALSE.
    DO variableIdx=1,fieldVariablesList%numberOfVariables
      IF(ASSOCIATED(fieldVariable,fieldVariablesList%variables(variableIdx)%ptr)) THEN
        variableFound=.TRUE.
        EXIT
      ELSE
        newVariablesList(variableIdx)%ptr=>fieldVariablesList%variables(variableIdx)%ptr
      ENDIF
    ENDDO !variableIdx
    IF(variableFound) THEN
      IF(ALLOCATED(newVariablesList)) DEALLOCATE(newVariablesList)
    ELSE
      newVariablesList(fieldVariablesList%numberOfVariables+1)%ptr=>fieldVariable
      CALL MOVE_ALLOC(newVariablesList,fieldVariablesList%variables)
      fieldVariablesList%numberOfVariables=fieldVariablesList%numberOfVariables+1
    ENDIF

    EXITS("FieldVariablesList_VariableAdd")
    RETURN
999 IF(ALLOCATED(newVariablesList)) DEALLOCATE(newVariablesList)
    ERRORSEXITS("FieldVariablesList_VariableAdd",err,error)
    RETURN 1

  END SUBROUTINE FieldVariablesList_VariableAdd

  !
  !================================================================================================================================
  !

  !>Gets a field variable at the specified variable position index in a field variables list. 
  SUBROUTINE FieldVariablesList_VariableGet(fieldVariablesList,variablePositionIdx,fieldVariable,err,error,*)

    !Argument variables
    TYPE(FieldVariablesListType), POINTER :: fieldVariablesList !<A pointer to the field variables list to get the field variable for
    INTEGER(INTG), INTENT(IN) :: variablePositionIdx !<The variable position index in the list of field variables to get.
    TYPE(FieldVariableType), POINTER :: fieldVariable !<On exit, A pointer to the specified field variable in the field variables list. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
#ifdef WITH_CHECKS
    TYPE(VARYING_STRING) :: localError
#endif    

    ENTERS("FieldVariablesList_VariableGet",err,error,*998)

#ifdef WITH_PRECHECKS    
    IF(ASSOCIATED(fieldVariable)) CALL FlagError("The field variable is already associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(fieldVariablesList)) CALL FlagError("Field variables list is not associated.",err,error,*999)
    IF(variablePositionIdx<0.OR.variablePositionIdx>fieldVariablesList%numberOfVariables) THEN
      localError="The specified variable position index of "//TRIM(NumberToVString(variablePositionIdx,"*",err,error))// &
        & " is invalid. The variable position index should be >= 1 and <= "// &
        & TRIM(NumberToVString(fieldVariablesList%numberOfVariables,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ALLOCATED(fieldVariablesList%variables)) &
      & CALL FlagError("The field variables list variables array is not allocated.",err,error,*999)
#endif    
    
    fieldVariable=>fieldVariablesList%variables(variablePositionIdx)%ptr

#ifdef WITH_POSTCHECKS
    IF(.NOT.ASSOCIATED(fieldVariable)) THEN
      localError="The field variable at position index "//TRIM(NumberToVString(variablePositionIdx,"*",err,error))// &
        & " in the field variables list is not associated."
      CALL FlagError(localError,err,error,*999)
    ENDIF
#endif

    EXITS("FieldVariablesList_VariableGet")
    RETURN
999 NULLIFY(fieldVariable)
998 ERRORSEXITS("FieldVariablesList_VariableGet",err,error)
    RETURN 1

  END SUBROUTINE FieldVariablesList_VariableGet

  !
  !================================================================================================================================
  !

  !>Checks if fieldVariable is in the fieldVariablesList. If the fieldVariable is in the list then variableIdx will return the index position of that fieldVariable in the list. If the fieldVariable is not in the list the variableIdx will be zero on exit. 
  SUBROUTINE FieldVariablesList_VariableInListCheck(fieldVariablesList,fieldVariable,variablePositionIdx,err,error,*)

    !Argument variables
    TYPE(FieldVariablesListType), POINTER :: fieldVariablesList !<A pointer to the field variables list to check if the field variable is in the list
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to check the field variables list for
    INTEGER(INTG), INTENT(OUT) :: variablePositionIdx !<On exit, the variable position index of the field varible in the field variables list if it exists and 0 if it doesn't
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableIdx
    LOGICAL :: variableFound
    TYPE(FieldVariablePtrType), ALLOCATABLE :: newVariablesList(:)

    ENTERS("FieldVariablesList_VariableInListCheck",err,error,*999)

    variablePositionIdx=0
#ifdef WITH_PRECHECKS    
    IF(.NOT.ASSOCIATED(fieldVariablesList)) CALL FlagError("Field variables list is not associated.",err,error,*999)
    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("The field variable to add is not associated.",err,error,*999)
#endif    

    DO variableIdx=1,fieldVariablesList%numberOfVariables
      IF(ASSOCIATED(fieldVariable,fieldVariablesList%variables(variableIdx)%ptr)) THEN
        variablePositionIdx=variableIdx
        EXIT
      ENDIF
    ENDDO !variableIdx
 
    EXITS("FieldVariablesList_VariableInListCheck")
    RETURN
999 ERRORSEXITS("FieldVariablesList_VariableInListCheck",err,error)
    RETURN 1

  END SUBROUTINE FieldVariablesList_VariableInListCheck

  !
  !================================================================================================================================
  !

  !>Adds a field to a fields list
  SUBROUTINE Fields_AddField(fields,field,err,error,*)

    !Argument variables
    TYPE(FieldsType), POINTER :: fields !<A pointer to the fields to add a field to
    TYPE(FieldType), POINTER :: field !<The field to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: fieldIdx
    TYPE(FieldPtrType), ALLOCATABLE :: newFields(:)

    ENTERS("Fields_AddField",err,error,*999)
    
    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(.NOT.ASSOCIATED(fields)) THEN
      ALLOCATE(fields,STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate fields.",err,error,*999)
      CALL Fields_InitialiseGeneric(fields,err,error,*999)      
    ENDIF
    ALLOCATE(newFields(fields%numberOfFields+1),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate new fields.",err,error,*999)
    IF(fields%numberOfFields>0) THEN
      IF(ASSOCIATED(fields%region)) THEN
        IF(ASSOCIATED(field%region)) THEN
          IF(.NOT.ASSOCIATED(fields%region,field%region)) &
            & CALL FlagError("The specified field does not have the same region as the specified fields.",err,error,*999)
        ELSE IF(ASSOCIATED(field%interface)) THEN
          CALL FlagError("Can not add a field from an interface to fields that are from a region.",err,error,*999)
        ELSE
          CALL FlagError("Field does not have an associated region or interface.",err,error,*999)
        ENDIF
      ELSE IF(ASSOCIATED(fields%interface)) THEN
        IF(ASSOCIATED(field%interface)) THEN
          IF(.NOT.ASSOCIATED(fields%interface,field%interface)) &
            & CALL FlagError("The specified field does not have the same interface as the specified fields.",err,error,*999)
        ELSE IF(ASSOCIATED(field%region)) THEN
          CALL FlagError("Can not add a field from a region to fields that are from an interface.",err,error,*999)
        ELSE
          CALL FlagError("Field does not have an associated region or interface.",err,error,*999)
        ENDIF                    
      ELSE
        CALL FlagError("Fields does not have a region or interface.",err,error,*999)
      ENDIF
    ELSE
      IF(ASSOCIATED(field%region)) THEN
        fields%region=>field%region
      ELSE IF(ASSOCIATED(field%INTERFACE)) THEN
        fields%interface=>field%interface
      ELSE 
        CALL FlagError("Field does not have an associated region or interface.",err,error,*999)
      ENDIF
    ENDIF
    DO fieldIdx=1,fields%numberOfFields
      newFields(fieldIdx)%ptr=>fields%fields(fieldIdx)%ptr
    ENDDO !fieldIdx
    newFields(fields%numberOfFields+1)%ptr=>field
    CALL MOVE_ALLOC(newFields,fields%fields)
    fields%numberOfFields=fields%numberOfFields+1
    
    EXITS("Fields_AddField")
    RETURN
999 ERRORSEXITS("Fields_AddField",err,error)
    RETURN 1
    
  END SUBROUTINE Fields_AddField

  !
  !================================================================================================================================
  !

  !>Finalises the fields and deallocates all memory.
  SUBROUTINE Fields_Finalise(fields,err,error,*)

    !Argument variables
    TYPE(FieldsType), POINTER :: fields !<A pointer to the fields to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldType), POINTER :: field

    ENTERS("Fields_Finalise",err,error,*999)

    IF(ASSOCIATED(fields)) THEN
      DO WHILE(fields%numberOfFields>0)
        field=>fields%fields(1)%ptr
        CALL Field_Destroy(field,err,error,*999)
      ENDDO !fieldIdx
      DEALLOCATE(fields)
    ENDIF

    EXITS("Fields_Finalise")
    RETURN
999 ERRORSEXITS("Fields_Finalise",err,error)
    RETURN 1
    
  END SUBROUTINE Fields_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises the fields.
  SUBROUTINE Fields_InitialiseGeneric(fields,err,error,*)

    !Argument variables
    TYPE(FieldsType), POINTER :: fields !<A pointer to the fields to initialise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Fields_InitialiseGeneric",err,error,*999)

    IF(.NOT.ASSOCIATED(fields)) CALL FlagError("Fields is not associated.",err,error,*999)
    
    NULLIFY(fields%region)
    NULLIFY(fields%interface)
    fields%numberOfFields=0

    EXITS("Fields_InitialiseGeneric")
    RETURN
999 ERRORSEXITS("Fields_InitialiseGeneric",err,error)
    RETURN 1
    
  END SUBROUTINE Fields_InitialiseGeneric

  !
  !================================================================================================================================
  !

  !>Initialises the fields for the given interface.
  SUBROUTINE Fields_InitialiseInterface(INTERFACE,err,error,*)

    !Argument variables
    TYPE(InterfaceType), POINTER :: interface !<A pointer to the interface to initialise the fields for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Fields_InitialiseInterface",err,error,*999)

    IF(.NOT.ASSOCIATED(interface)) CALL FlagError("Interface is not associated.",err,error,*999)
    IF(ASSOCIATED(interface%fields)) CALL FlagError("Interface already has fields associated.",err,error,*999)
      
    ALLOCATE(interface%fields,STAT=err)
    IF(err/=0) CALL FlagError("Interface fields could not be allocated.",err,error,*999)
    CALL Fields_InitialiseGeneric(interface%fields,err,error,*999)
    interface%fields%interface=>interface

    EXITS("Fields_InitialiseInterface")
    RETURN
999 ERRORSEXITS("Fields_InitialiseInterface",err,error)
    RETURN 1
      
  END SUBROUTINE Fields_InitialiseInterface

  !
  !================================================================================================================================
  !

  !>Initialises the fields for the given region.
  SUBROUTINE Fields_InitialiseRegion(region,err,error,*)

    !Argument variables
    TYPE(RegionType), POINTER :: region !<A pointer to the region to initialise the fields for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    
    ENTERS("Fields_InitialiseRegion",err,error,*999)

    IF(.NOT.ASSOCIATED(region)) CALL FlagError("Region is not associated.",err,error,*999)
    IF(ASSOCIATED(region%fields)) CALL FlagError("Region already has fields associated.",err,error,*999)
        
    ALLOCATE(region%fields,STAT=err)
    IF(err/=0) CALL FlagError("Region fields could not be allocated.",err,error,*999)
    CALL Fields_InitialiseGeneric(region%fields,err,error,*999)
    region%fields%region=>region

    EXITS("Fields_InitialiseRegion")
    RETURN
999 ERRORSEXITS("Fields_InitialiseRegion",err,error)
    RETURN 1
    
  END SUBROUTINE Fields_InitialiseRegion

  !
  !================================================================================================================================
  !
  
  !> Interpolates data from one field/mesh to another
  SUBROUTINE MeshEmbedding_PushData(meshEmbedding,parentField,parentComponent,childField,childComponent,err,error,*)
    TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: meshEmbedding !<The mesh embedding object
    TYPE(FieldType), POINTER :: parentField      !<Field for the parent nodes
    TYPE(FieldType), POINTER :: childField       !<Field for the child nodes
    INTEGER(INTG), INTENT(IN) :: parentComponent  !<Component of the parent field, must be nodally based
    INTEGER(INTG), INTENT(IN) ::  childComponent  !<Component of the child  field, must be nodally based
    INTEGER(INTG), INTENT(OUT) :: err              !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error     !<The error string    
    !Local variables
    INTEGER(INTG) :: elementIdx,nodeIdx,localNodeIdx,version
    REAL(DP) :: interpVal, WT
    REAL(DP),ALLOCATABLE :: parentValues(:)
    TYPE(BasisType), POINTER :: basis
    TYPE(MeshElementType), POINTER :: element
     
    ENTERS("MeshEmbedding_PushData",err,error,*999)
    
    version=1
    DO elementIdx=1,meshEmbedding%PARENT_MESH%numberOfElements
      element=>meshEmbedding%PARENT_MESH%topology(1)%ptr%elements%elements(elementIdx)
      basis=>element%basis
      ALLOCATE(parentValues(basis%numberOfNodes))
      
      DO localNodeIdx=1,basis%numberOfNodes
        ! Version variable added and initialized above
        CALL Field_ParameterSetGetNode(parentField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,version,1,& ! TODO: FROM INPUT
          &  element%globalElementNodes(localNodeIdx),parentComponent,parentValues(localNodeIdx),err,error,*999)   ! global no?
      ENDDO !localNodeIdx      
      
      DO nodeIdx=1,meshEmbedding%CHILD_NODE_XI_POSITION(elementIdx)%NUMBER_OF_NODES
        interpVal = 0.0
        DO localNodeIdx=1,basis%numberOfNodes
          CALL Basis_EvaluateXi(basis,localNodeIdx,NO_PART_DERIV,meshEmbedding%CHILD_NODE_XI_POSITION(elementIdx)% &
            & XI_COORDS(:,nodeIdx),WT,err,error,*999)
          interpVal = interpVal + WT * parentValues(nodeIdx)
        ENDDO !localNodeIdx
        
        ! store in field
        ! Version variable added and initialized above
        CALL Field_ParameterSetUpdateNode(childField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,version,1,& ! TODO: FROM INPUT
          &  meshEmbedding%CHILD_NODE_XI_POSITION(elementIdx)%NODE_NUMBERS(nodeIdx),childComponent,interpVal,err,error,*999) 
      ENDDO !nodeIdx
      DEALLOCATE(parentValues)
    ENDDO !elementIdx
    
    EXITS("MeshEmbedding_PushData")
    RETURN
999 ERRORSEXITS("MeshEmbedding_PushData",err,error)
    RETURN 1
    
  END SUBROUTINE MeshEmbedding_PushData

  !  
  !================================================================================================================================
  !  

  SUBROUTINE MeshEmbedding_PullGaussPointData(meshEmbedding,parentField,parentComponent,childField,childComponent,&
    & err,error,*)
    
    TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: meshEmbedding !<The mesh embedding object
    TYPE(FieldType), POINTER :: parentField      !<Field for the parent nodes
    TYPE(FieldType), POINTER :: childField       !<Field for the child nodes
    INTEGER(INTG), INTENT(IN) :: parentComponent  !<Component of the parent field, must be nodally based
    INTEGER(INTG), INTENT(IN) ::  childComponent  !<Component of the child  field, must be nodally based
    INTEGER(INTG), INTENT(OUT) :: err              !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error     !<The error string    
    !Local variables
    INTEGER(INTG) :: elementIdx,gaussPointIdx,localNodeIdx,numberOfGauss,version
    REAL(DP) :: interpVal, WT, VAL
    TYPE(BasisType), POINTER :: basis
    TYPE(MeshElementType), POINTER :: element
    TYPE(MeshElementsType), POINTER :: elements
   
    ENTERS("MeshEmbedding_PullGaussPointData",err,error,*999)
    
    elements=>meshEmbedding%CHILD_MESH%topology(1)%ptr%elements
    basis=>meshEmbedding%CHILD_MESH%topology(1)%ptr%elements%elements(1)%basis
    version = 1
    DO elementIdx=1,meshEmbedding%PARENT_MESH%numberOfElements    
      numberOfGauss = basis%quadrature%quadratureSchemeMap(BASIS_DEFAULT_QUADRATURE_SCHEME)%ptr%numberOfGauss
      DO gaussPointIdx=1,numberOfGauss
        element=>elements%elements(meshEmbedding%GAUSS_POINT_XI_POSITION(gaussPointIdx,elementIdx)%ELEMENT_NUMBER)
        basis=>element%basis
        DO localNodeIdx=1,basis%numberOfNodes
          ! Version variable added and initialized above
          CALL Field_ParameterSetGetNode(childField,FIELD_U_VARIABLE_TYPE,FIELD_valueS_SET_TYPE,version,1,& ! TODO: FROM INPUT
            &  element%globalElementNodes(localNodeIdx),childComponent,VAL ,err,error,*999)   ! global no?
          CALL Basis_EvaluateXi(basis,localNodeIdx,NO_PART_DERIV,meshEmbedding%GAUSS_POINT_XI_POSITION(gaussPointIdx,elementIdx)% &
            & CHILD_XI_COORD,WT,err,error,*999) 
          interpVal = interpVal + WT * VAL
        ENDDO !localNodeIdx
        ! store in gauss point parent field 
        CALL Field_ParameterSetUpdateGaussPoint(parentField,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,gaussPointIdx, &
          & elementIdx, parentComponent, interpVal,err,error,*999) ! TODO: var type/par set from input
      ENDDO !gaussPointIdx
    ENDDO !elementIdx
    
    EXITS("MeshEmbedding_PullGaussPointData")
    RETURN
999 ERRORSEXITS("MeshEmbedding_PullGaussPointData",err,error)
    RETURN 1
    
  END SUBROUTINE MeshEmbedding_PullGaussPointData

  !
  !================================================================================================================================
  !
  
  !>Returns from the given parameter set a double precision value for the specified gauss point of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetGaussPoint
  SUBROUTINE Field_ParameterSetGetGaussPointCoord(meshEmbedding,componentNumber,numberOfGauss,coordValue, &
    & err,error,*)
    
    TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: meshEmbedding !<The mesh embedding object
    INTEGER(INTG), INTENT(IN) :: componentNumber  !<Component
    INTEGER(INTG), INTENT(OUT) :: numberOfGauss
    REAL(DP), INTENT(OUT) :: coordValue(:)
    INTEGER(INTG), INTENT(OUT) :: err              !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error     !<The error string    
    !Local variables
    INTEGER(INTG) :: gaussPointIdx
    TYPE(BasisType), POINTER :: basis
     TYPE(MeshElementsType), POINTER :: elements
   
    ENTERS("Field_ParameterSetGetGaussPointCoord",err,error,*999)
    
    elements=>meshEmbedding%PARENT_MESH%TOPOLOGY(1)%ptr%elements
    basis=>meshEmbedding%PARENT_MESH%TOPOLOGY(1)%ptr%elements%elements(1)%basis
    numberOfGauss = basis%quadrature%quadratureSchemeMap(BASIS_DEFAULT_QUADRATURE_SCHEME)%ptr%numberOfGauss
    
    DO gaussPointIdx = 1,numberOfGauss
      coordValue(gaussPointIdx) = basis%quadrature%quadratureSchemeMap(BASIS_DEFAULT_QUADRATURE_SCHEME)%ptr%&
        &gaussPositions(componentNumber,gaussPointIdx)
    ENDDO
    
    EXITS("Field_ParameterSetGetGaussPointCoord")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetGaussPointCoord",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ParameterSetGetGaussPointCoord

  !
  !===============================================================================================================================
  !

END MODULE FieldRoutines
