!> \file
!> \author Chris Bradley
!> \brief This module handles all field related routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s): Chris Bradley
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!> This module handles all field related routines.
MODULE FIELD_ROUTINES

  USE BaseRoutines
  USE BasisRoutines
  USE BasisAccessRoutines
  USE ComputationRoutines
  USE ComputationAccessRoutines
  USE Constants
  USE COORDINATE_ROUTINES
  USE CmissMPI
  USE DecompositionRoutines
  USE DecompositionAccessRoutines
  USE DistributedMatrixVector
  USE DomainMappings
  USE FieldAccessRoutines
  USE Kinds
  USE INPUT_OUTPUT
  USE ISO_VARYING_STRING
  USE Lists
  USE Maths
#ifndef NOMPIMOD
  USE MPI
#endif
  USE Strings
  USE Types

#include "macros.h"  

  IMPLICIT NONE

#ifdef NOMPIMOD
#include "mpif.h"
#endif

  PRIVATE

  !Module parameters

  !> \addtogroup FIELD_ROUTINES_DependentTypes FIELD_ROUTINES::DependentTypes
  !> \brief Depedent field parameter types
  !> \see FIELD_ROUTINES,OPENCMISS_FieldDependentTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_INDEPENDENT_TYPE=1 !<Independent field type \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEPENDENT_TYPE=2 !<Dependent field type \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_DimensionTypes FIELD_ROUTINES::DimensionTypes
  !> \brief Field dimension parameter types
  !> \see FIELD_ROUTINES,OPENCMISS_FieldDimensionTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_SCALAR_DIMENSION_TYPE=1 !<Scalar field \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_VECTOR_DIMENSION_TYPE=2 !<Vector field \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_TENSOR_DIMENSION_TYPE=3 !<Tensor field \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_FieldTypes FIELD_ROUTINES::FieldTypes
  !> \brief Field type parameters
  !> \see FIELD_ROUTINES,OPENCMISS_FieldTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_TYPE=1 !<Geometric field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_FIBRE_TYPE=2 !<Fibre field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GENERAL_TYPE=3 !<General field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_MATERIAL_TYPE=4 !<Material field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_GENERAL_TYPE=5 !<Geometric general field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_DofTypes FIELD_ROUTINES::DofTypes
  !> \brief Field dof type parameters
  !> \see FIELD_ROUTINES
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_CONSTANT_DOF_TYPE=1 !<The dof is from a field variable component with constant interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ELEMENT_DOF_TYPE=2 !<The dof is from a field variable component with element based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_NODE_DOF_TYPE=3 !<The dof is from a field variable component with node based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GRID_POINT_DOF_TYPE=4 !<The dof is from a field variable component with grid point based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GAUSS_POINT_DOF_TYPE=5 !<The dof is from a field variable component with Gauss point based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DATA_POINT_DOF_TYPE=6 !<The dof is from a field variable component with Gauss point based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  !>@}
  !> \addtogroup FIELD_ROUTINES_DOFOrderTypes FIELD_ROUTINES::DOFOrderTypes
  !> \brief Field DOF order types
  !> \see FIELD_ROUTINES,OPENCMISS_FieldDOFOrderTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_SEPARATED_COMPONENT_DOF_ORDER=1 !<Field variable component dofs are not contiguous \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER=2 !<Field variable component dofs are contiguous \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_ScalingTypes FIELD_ROUTINES::ScalingTypes
  !> \brief Field scaling type parameters
  !> \see FIELD_ROUTINES,OPENCMISS_FieldScalingTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_NO_SCALING=0 !<The field is not scaled \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_UNIT_SCALING=1 !<The field has unit scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ARC_LENGTH_SCALING=2 !<The field has arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ARITHMETIC_MEAN_SCALING=3 !<The field has arithmetic mean of the arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_MEAN_SCALING=4 !<The field has geometric mean of the arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_HARMONIC_MEAN_SCALING=5 !<The field has harmonic mean of the arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_InterpolationComponentsTypes FIELD_ROUTINES::InterpolationComponentsTypes
  !> \brief Field interpolation components types
  !> \see FIELD_ROUTINES
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_ALL_COMPONENTS_TYPE=1 !<The field is interpolated for all components \see FIELD_ROUTINES_InterpolationComponentsTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_COMPONENTS_TYPE=2 !<The field is interpolated for geometric components \see FIELD_ROUTINES_InterpolationComponentsTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_NONGEOMETRIC_COMPONENTS_TYPE=3 !<The field is interpolated for non-geometric components \see FIELD_ROUTINES_InterpolationComponentsTypes,FIELD_ROUTINES
  !>@}

  !Module types

  !Module variables

  !Interfaces

  INTERFACE Field_ComponentInterpolationCheck
    MODULE PROCEDURE FIELD_COMPONENT_INTERPOLATION_CHECK
  END INTERFACE Field_ComponentInterpolationCheck

  INTERFACE Field_ComponentInterpolationSet  
    MODULE PROCEDURE FIELD_COMPONENT_INTERPOLATION_SET
  END INTERFACE Field_ComponentInterpolationSet

  INTERFACE Field_ComponentInterpolationSetAndLock
    MODULE PROCEDURE FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK
  END INTERFACE Field_ComponentInterpolationSetAndLock

  !>Gets the label for a field variable component.
  INTERFACE FIELD_COMPONENT_LABEL_GET
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_GET_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_GET_VS
  END INTERFACE FIELD_COMPONENT_LABEL_GET

  !>Gets the label for a field variable component.
  INTERFACE Field_ComponentLabelGet
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_GET_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_GET_VS
  END INTERFACE Field_ComponentLabelGet

  !>Sets/changes the label for a field variable component.
  INTERFACE FIELD_COMPONENT_LABEL_SET
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_VS
  END INTERFACE FIELD_COMPONENT_LABEL_SET

  !>Sets/changes the label for a field variable component.
  INTERFACE Field_ComponentLabelSet
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_VS
  END INTERFACE Field_ComponentLabelSet

  !>Sets/changes the label for a field variable component and locks so that no further changes can be made.
  INTERFACE FIELD_COMPONENT_LABEL_SET_AND_LOCK
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS
  END INTERFACE FIELD_COMPONENT_LABEL_SET_AND_LOCK

  !>Sets/changes the label for a field variable component and locks so that no further changes can be made.
  INTERFACE Field_ComponentLabelSetAndLock
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS
  END INTERFACE Field_ComponentLabelSetAndLock

  INTERFACE Field_ComponentMeshComponentCheck
    MODULE PROCEDURE FIELD_COMPONENT_MESH_COMPONENT_CHECK
  END INTERFACE Field_ComponentMeshComponentCheck

  INTERFACE Field_ComponentMeshComponentGet
    MODULE PROCEDURE FIELD_COMPONENT_MESH_COMPONENT_GET
  END INTERFACE Field_ComponentMeshComponentGet

  INTERFACE Field_ComponentMeshComponentSet
    MODULE PROCEDURE FIELD_COMPONENT_MESH_COMPONENT_SET
  END INTERFACE Field_ComponentMeshComponentSet

  INTERFACE Field_ComponentMeshComponentSetAndLock
    MODULE PROCEDURE FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK
  END INTERFACE Field_ComponentMeshComponentSetAndLock

  !>Initialises the values of parameter set of a field variable component to a constant value.
  INTERFACE FIELD_COMPONENT_VALUES_INITIALISE
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_INTG
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_SP
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_DP
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_L
  END INTERFACE FIELD_COMPONENT_VALUES_INITIALISE

  !>Initialises the values of parameter set of a field variable component to a constant value.
  INTERFACE Field_ComponentValuesInitialise
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_INTG
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_SP
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_DP
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_L
  END INTERFACE Field_ComponentValuesInitialise

  INTERFACE Field_CreateFinish
    MODULE PROCEDURE FIELD_CREATE_FINISH
  END INTERFACE Field_CreateFinish

  !>Starts the process of creating a field
  INTERFACE FIELD_CREATE_START
    MODULE PROCEDURE FIELD_CREATE_START_INTERFACE
    MODULE PROCEDURE FIELD_CREATE_START_REGION
  END INTERFACE FIELD_CREATE_START

  !>Starts the process of creating a field
  INTERFACE Field_CreateStart
    MODULE PROCEDURE FIELD_CREATE_START_INTERFACE
    MODULE PROCEDURE FIELD_CREATE_START_REGION
  END INTERFACE Field_CreateStart

  INTERFACE Field_Destroy
    MODULE PROCEDURE FIELD_DESTROY
  END INTERFACE Field_Destroy

  INTERFACE Field_DataTypeCheck
    MODULE PROCEDURE FIELD_DATA_TYPE_CHECK
  END INTERFACE Field_DataTypeCheck

  INTERFACE Field_DataTypeGet
    MODULE PROCEDURE FIELD_DATA_TYPE_GET
  END INTERFACE Field_DataTypeGet

  INTERFACE Field_DataTypeSet
    MODULE PROCEDURE FIELD_DATA_TYPE_SET
  END INTERFACE Field_DataTypeSet

  INTERFACE Field_DataTypeSetAndLock
    MODULE PROCEDURE FIELD_DATA_TYPE_SET_AND_LOCK
  END INTERFACE Field_DataTypeSetAndLock

  INTERFACE Field_DependentTypeCheck
    MODULE PROCEDURE FIELD_DEPENDENT_TYPE_CHECK
  END INTERFACE Field_DependentTypeCheck

  INTERFACE Field_DependentTypeGet
    MODULE PROCEDURE FIELD_DEPENDENT_TYPE_GET
  END INTERFACE Field_DependentTypeGet

  INTERFACE Field_DependentTypeSet
    MODULE PROCEDURE FIELD_DEPENDENT_TYPE_SET
  END INTERFACE Field_DependentTypeSet

  INTERFACE Field_DependentTypeSetAndLock
    MODULE PROCEDURE FIELD_DEPENDENT_TYPE_SET_AND_LOCK
  END INTERFACE Field_DependentTypeSetAndLock

  INTERFACE Field_DimensionCheck
    MODULE PROCEDURE FIELD_DIMENSION_CHECK
  END INTERFACE Field_DimensionCheck

  INTERFACE Field_DimensionGet
    MODULE PROCEDURE FIELD_DIMENSION_GET
  END INTERFACE Field_DimensionGet

  INTERFACE Field_DimensionSet
    MODULE PROCEDURE FIELD_DIMENSION_SET
  END INTERFACE Field_DimensionSet

  INTERFACE Field_DimensionSetAndLock
    MODULE PROCEDURE FIELD_DIMENSION_SET_AND_LOCK
  END INTERFACE Field_DimensionSetAndLock

  INTERFACE Field_DOFOrderTypeCheck
    MODULE PROCEDURE FIELD_DOF_ORDER_TYPE_CHECK
  END INTERFACE Field_DOFOrderTypeCheck

  INTERFACE Field_DOFOrderTypeGet
    MODULE PROCEDURE FIELD_DOF_ORDER_TYPE_GET
  END INTERFACE Field_DOFOrderTypeGet

  INTERFACE Field_DOFOrderTypeSet
    MODULE PROCEDURE FIELD_DOF_ORDER_TYPE_SET
  END INTERFACE Field_DOFOrderTypeSet

  INTERFACE Field_DOFOrderTypeSetAndLock
    MODULE PROCEDURE FIELD_DOF_ORDER_TYPE_SET_AND_LOCK
  END INTERFACE Field_DOFOrderTypeSetAndLock

  INTERFACE Field_GeometricFieldSet
    MODULE PROCEDURE FIELD_GEOMETRIC_FIELD_SET
  END INTERFACE Field_GeometricFieldSet

  INTERFACE Field_GeometricFieldSetAndLock
    MODULE PROCEDURE FIELD_GEOMETRIC_FIELD_SET_AND_LOCK
  END INTERFACE Field_GeometricFieldSetAndLock

  INTERFACE Field_InterpolateGauss
    MODULE PROCEDURE FIELD_INTERPOLATE_GAUSS
  END INTERFACE Field_InterpolateGauss

  INTERFACE Field_InterpolateXi
    MODULE PROCEDURE FIELD_INTERPOLATE_XI
  END INTERFACE Field_InterpolateXi

  INTERFACE Field_InterpolateNode
    MODULE PROCEDURE FIELD_INTERPOLATE_NODE
  END INTERFACE Field_InterpolateNode

  INTERFACE Field_InterpolateFieldNode
    MODULE PROCEDURE FIELD_INTERPOLATE_FIELD_NODE
  END INTERFACE Field_InterpolateFieldNode

  INTERFACE Field_InterpolateLocalFaceGauss
    MODULE PROCEDURE FIELD_INTERPOLATE_LOCAL_FACE_GAUSS
  END INTERFACE Field_InterpolateLocalFaceGauss

  INTERFACE Field_InterpolatedPointMetricsCalculate
    MODULE PROCEDURE FIELD_INTERPOLATED_POINT_METRICS_CALCULATE
  END INTERFACE Field_InterpolatedPointMetricsCalculate

  INTERFACE Field_InterpolatedPointsFinalise
    MODULE PROCEDURE FIELD_INTERPOLATED_POINTS_FINALISE
  END INTERFACE Field_InterpolatedPointsFinalise

  INTERFACE Field_InterpolatedPointsInitialise
    MODULE PROCEDURE FIELD_INTERPOLATED_POINTS_INITIALISE
  END INTERFACE Field_InterpolatedPointsInitialise

  INTERFACE Field_InterpolationParametersElementGet
    MODULE PROCEDURE FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET
  END INTERFACE Field_InterpolationParametersElementGet

  INTERFACE Field_InterpolationParametersFinalise
    MODULE PROCEDURE FIELD_INTERPOLATION_PARAMETERS_FINALISE
  END INTERFACE Field_InterpolationParametersFinalise

  INTERFACE Field_InterpolationParametersInitialise
    MODULE PROCEDURE FIELD_INTERPOLATION_PARAMETERS_INITIALISE
  END INTERFACE Field_InterpolationParametersInitialise

  INTERFACE Field_InterpolationParametersFaceGet
    MODULE PROCEDURE FIELD_INTERPOLATION_PARAMETERS_FACE_GET
  END INTERFACE Field_InterpolationParametersFaceGet

  INTERFACE Field_InterpolationParametersLineGet
    MODULE PROCEDURE FIELD_INTERPOLATION_PARAMETERS_LINE_GET
  END INTERFACE Field_InterpolationParametersLineGet

  !>Gets the label for a field.
  INTERFACE FIELD_LABEL_GET
    MODULE PROCEDURE FIELD_LABEL_GET_C
    MODULE PROCEDURE FIELD_LABEL_GET_VS
  END INTERFACE FIELD_LABEL_GET

  !>Gets the label for a field.
  INTERFACE Field_LabelGet
    MODULE PROCEDURE FIELD_LABEL_GET_C
    MODULE PROCEDURE FIELD_LABEL_GET_VS
  END INTERFACE Field_LabelGet

  !>Sets/changes the label for a field.
  INTERFACE FIELD_LABEL_SET
    MODULE PROCEDURE FIELD_LABEL_SET_C
    MODULE PROCEDURE FIELD_LABEL_SET_VS
  END INTERFACE FIELD_LABEL_SET

  !>Sets/changes the label for a field.
  INTERFACE Field_LabelSet
    MODULE PROCEDURE FIELD_LABEL_SET_C
    MODULE PROCEDURE FIELD_LABEL_SET_VS
  END INTERFACE Field_LabelSet

  !>Sets/changes the label for a field and locks so that no further changes can be made.
  INTERFACE FIELD_LABEL_SET_AND_LOCK
    MODULE PROCEDURE FIELD_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_LABEL_SET_AND_LOCK_VS
  END INTERFACE FIELD_LABEL_SET_AND_LOCK

  !>Sets/changes the label for a field and locks so that no further changes can be made.
  INTERFACE Field_LabelSetAndLock
    MODULE PROCEDURE FIELD_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_LABEL_SET_AND_LOCK_VS
  END INTERFACE Field_LabelSetAndLock

  INTERFACE Field_DecompositionSet
    MODULE PROCEDURE FIELD_MESH_DECOMPOSITION_SET
  END INTERFACE Field_DecompositionSet

  INTERFACE Field_DecompositionSetAndLock
    MODULE PROCEDURE FIELD_MESH_DECOMPOSITION_SET_AND_LOCK
  END INTERFACE Field_DecompositionSetAndLock

  INTERFACE FIELD_NUMBER_OF_COMPONENTS_CHECK
    MODULE PROCEDURE Field_NumberOfComponentsCheck
  END INTERFACE FIELD_NUMBER_OF_COMPONENTS_CHECK

  INTERFACE FIELD_NUMBER_OF_COMPONENTS_GET
    MODULE PROCEDURE Field_NumberOfComponentsGet
  END INTERFACE FIELD_NUMBER_OF_COMPONENTS_GET

  INTERFACE Field_NumberOfComponentsSet
    MODULE PROCEDURE FIELD_NUMBER_OF_COMPONENTS_SET
  END INTERFACE Field_NumberOfComponentsSet

  INTERFACE Field_NumberOfComponentsSetAndLock
    MODULE PROCEDURE FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK
  END INTERFACE Field_NumberOfComponentsSetAndLock

  INTERFACE Field_NumberOfVariablesCheck
    MODULE PROCEDURE FIELD_NUMBER_OF_VARIABLES_CHECK
  END INTERFACE Field_NumberOfVariablesCheck

  INTERFACE Field_NumberOfVariablesSet
    MODULE PROCEDURE FIELD_NUMBER_OF_VARIABLES_SET
  END INTERFACE Field_NumberOfVariablesSet

  INTERFACE Field_NumberOfVariablesSetAndLock
    MODULE PROCEDURE FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK
  END INTERFACE Field_NumberOfVariablesSetAndLock

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type.
  INTERFACE FIELD_PARAMETER_SETS_ADD
    MODULE PROCEDURE FIELD_PARAMETER_SETS_ADD_DP
    MODULE PROCEDURE FIELD_PARAMETER_SETS_ADD_DP1
  END INTERFACE FIELD_PARAMETER_SETS_ADD

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type.
  INTERFACE Field_ParameterSetsAdd
    MODULE PROCEDURE FIELD_PARAMETER_SETS_ADD_DP
    MODULE PROCEDURE FIELD_PARAMETER_SETS_ADD_DP1
  END INTERFACE Field_ParameterSetsAdd

  INTERFACE FIELD_PARAMETER_SETS_COPY
    MODULE PROCEDURE Field_ParameterSetsCopy
  END INTERFACE FIELD_PARAMETER_SETS_COPY

  INTERFACE Field_ParameterSetDestroy
    MODULE PROCEDURE FIELD_PARAMETER_SET_DESTROY
  END INTERFACE Field_ParameterSetDestroy

  INTERFACE FIELD_PARAMETER_SET_GET
    MODULE PROCEDURE Field_ParameterSetGet
  END INTERFACE FIELD_PARAMETER_SET_GET

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_CONSTANT
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_CONSTANT

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE Field_ParameterSetAddConstant
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_L
  END INTERFACE Field_ParameterSetAddConstant

  !>Adds the given value to the given parameter set for a particular local dof of the field variable.
  INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_DOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_DOF

  !>Adds the given value to the given parameter set for a particular local dof of the field variable.
  INTERFACE Field_ParameterSetAddLocalDOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L
  END INTERFACE Field_ParameterSetAddLocalDOF

  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_ELEMENT

  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE Field_ParameterSetAddElement
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_L
  END INTERFACE Field_ParameterSetAddElement

  !>Adds the given value to the given parameter set for a particular Gauss point of a user element of the field variable component.
  INTERFACE Field_ParameterSetAddGaussPoint
    MODULE PROCEDURE Field_ParameterSetAddGaussPointIntg
    MODULE PROCEDURE Field_ParameterSetAddGaussPointSP
    MODULE PROCEDURE Field_ParameterSetAddGaussPointDP
    MODULE PROCEDURE Field_ParameterSetAddGaussPointL
  END INTERFACE Field_ParameterSetAddGaussPoint

  !>Adds the given value to the given parameter set for a particular local element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT

  !>Adds the given value to the given parameter set for a particular local element of the field variable component.
  INTERFACE Field_ParameterSetAddLocalElement
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L
  END INTERFACE Field_ParameterSetAddLocalElement

  !>Adds the given value to the given parameter set for a particular user node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_NODE

  !>Adds the given value to the given parameter set for a particular user node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetAddNode
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_L
  END INTERFACE Field_ParameterSetAddNode

  !>Adds the given value to the given parameter set for a particular local node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_NODE

  !>Adds the given value to the given parameter set for a particular local node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetAddLocalNode
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L
  END INTERFACE Field_ParameterSetAddLocalNode

  INTERFACE FIELD_PARAMETER_SET_CREATE
    MODULE PROCEDURE Field_ParameterSetCreate
  END INTERFACE FIELD_PARAMETER_SET_CREATE

  INTERFACE FIELD_PARAMETER_SET_CREATED
    MODULE PROCEDURE Field_ParameterSetCreated
  END INTERFACE FIELD_PARAMETER_SET_CREATED

  !>Returns a pointer to the specified field parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_PARAMETER_SET_UPDATE call must be used to change any values.
  INTERFACE FIELD_PARAMETER_SET_DATA_GET
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_L
  END INTERFACE FIELD_PARAMETER_SET_DATA_GET

  !>Returns a pointer to the specified field parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_PARAMETER_SET_UPDATE call must be used to change any values.
  INTERFACE Field_ParameterSetDataGet
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_L
  END INTERFACE Field_ParameterSetDataGet

  !>Restores the specified field variable parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET.
  INTERFACE FIELD_PARAMETER_SET_DATA_RESTORE
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_L
  END INTERFACE FIELD_PARAMETER_SET_DATA_RESTORE

  !>Restores the specified field variable parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET.
  INTERFACE Field_ParameterSetDataRestore
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_L
  END INTERFACE Field_ParameterSetDataRestore

  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE FIELD_PARAMETER_SET_GET_CONSTANT
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_L
  END INTERFACE FIELD_PARAMETER_SET_GET_CONSTANT

  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE Field_ParameterSetGetConstant
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_L
  END INTERFACE Field_ParameterSetGetConstant

  !>Returns from the given parameter set a value for the specified data point of a field variable component.
  INTERFACE Field_ParameterSetGetDataPoint
    MODULE PROCEDURE Field_ParameterSetGetDataPointIntg
    MODULE PROCEDURE Field_ParameterSetGetDataPointSp
    MODULE PROCEDURE Field_ParameterSetGetDataPointDp
    MODULE PROCEDURE Field_ParameterSetGetDataPointL
  END INTERFACE Field_ParameterSetGetDataPoint

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE FIELD_PARAMETER_SET_GET_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_L
  END INTERFACE FIELD_PARAMETER_SET_GET_ELEMENT

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE Field_ParameterSetGetElement
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_L
  END INTERFACE Field_ParameterSetGetElement

  !>Returns the given parameter set value for a particular local dof of the field variable.
  INTERFACE FIELD_PARAMETER_SET_GET_LOCAL_DOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_L
  END INTERFACE FIELD_PARAMETER_SET_GET_LOCAL_DOF

  !>Returns the given parameter set value for a particular local dof of the field variable.
  INTERFACE Field_ParameterSetGetLocalDOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_L
  END INTERFACE Field_ParameterSetGetLocalDOF

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE FIELD_PARAMETER_SET_GET_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_L
  END INTERFACE FIELD_PARAMETER_SET_GET_NODE

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetNode
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_L
  END INTERFACE Field_ParameterSetGetNode

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetLocalNode
    MODULE PROCEDURE Field_ParameterSetGetLocalNodeIntg
    MODULE PROCEDURE Field_ParameterSetGetLocalNodeSP
    MODULE PROCEDURE Field_ParameterSetGetLocalNodeDP
    MODULE PROCEDURE Field_ParameterSetGetLocalNodeL
  END INTERFACE Field_ParameterSetGetLocalNode

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetLocalElement
    MODULE PROCEDURE Field_ParameterSetGetLocalElementIntg
    MODULE PROCEDURE Field_ParameterSetGetLocalElementSP
    MODULE PROCEDURE Field_ParameterSetGetLocalElementDP
    MODULE PROCEDURE Field_ParameterSetGetLocalElementL
  END INTERFACE Field_ParameterSetGetLocalElement

  !>Returns from the given parameter set a value for the specified user element and Gauss point of a field variable component.  TODO: sp/int/l versions
  INTERFACE Field_ParameterSetGetGaussPoint
    MODULE PROCEDURE Field_ParameterSetGetGaussPointDP
  END INTERFACE Field_ParameterSetGetGaussPoint

  !>Returns from the given parameter set a value for the specified user element and Gauss point of a field variable component.  TODO: sp/int/l versions
  INTERFACE FIELD_PARAMETER_SET_GET_GAUSS_POINT
    MODULE PROCEDURE Field_ParameterSetGetGaussPointDP
  END INTERFACE FIELD_PARAMETER_SET_GET_GAUSS_POINT

  !>Returns from the given parameter set a value for the specified local element and Gauss point of a field variable component.  TODO: sp/int/l versions
  INTERFACE Field_ParameterSetGetLocalGaussPoint
    MODULE PROCEDURE Field_ParameterSetGetLocalGaussPointDP
  END INTERFACE Field_ParameterSetGetLocalGaussPoint

  INTERFACE Field_ParameterSetOutput
    MODULE PROCEDURE FIELD_PARAMETER_SET_OUTPUT
  END INTERFACE Field_ParameterSetOutput

  INTERFACE Field_ParameterSetUpdateFinish
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_FINISH
  END INTERFACE Field_ParameterSetUpdateFinish

  INTERFACE Field_ParameterSetUpdateStart
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_START
  END INTERFACE Field_ParameterSetUpdateStart

  !>Returns from the given parameter set a value for the specified user element and Gauss point of a field variable component.  TOD  !>Updates the given parameter set with the given value for the constant of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_CONSTANT
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_CONSTANT

  !>Returns from the given parameter set a value for the specified user element and Gauss point of a field variable component.  TOD  !>Updates the given parameter set with the given value for the constant of the field variable component.
  INTERFACE Field_ParameterSetUpdateConstant
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_L
  END INTERFACE Field_ParameterSetUpdateConstant

  !>Updates the given parameter set a value for the specified data point of a field variable component.
  INTERFACE Field_ParameterSetUpdateDataPoint
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointSp
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointDp
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointL
  END INTERFACE Field_ParameterSetUpdateDataPoint

  !>Updates the given parameter set a value for the specified local data point of a field variable component.
  INTERFACE Field_ParameterSetUpdateLocalDataPoint
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointSp
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointDp
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointL
  END INTERFACE Field_ParameterSetUpdateLocalDataPoint

  !>Updates the given parameter set with the given value for a particular local dof of the field variable.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF

  !>Updates the given parameter set with the given value for a particular local dof of the field variable.
  INTERFACE Field_ParameterSetUpdateLocalDOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L
  END INTERFACE Field_ParameterSetUpdateLocalDOF

  !>Updates the given parameter set with the given values for all local dofs of the field variable.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS

  !>Updates the given parameter set with the given values for all local dofs of the field variable.
  INTERFACE Field_ParameterSetUpdateLocalDOFS
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP
  END INTERFACE Field_ParameterSetUpdateLocalDOFS

  !>Updates the given parameter set with the given value for a particular user element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_ELEMENT

  !>Updates the given parameter set with the given value for a particular user element of the field variable component.
  INTERFACE Field_ParameterSetUpdateElement
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_L
  END INTERFACE Field_ParameterSetUpdateElement

  !>Updates the given parameter set with the given value for a particular local element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT
    MODULE PROCEDURE Field_ParameterSetUpdateLocalElementIntg
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT

  !>Updates the given parameter set with the given value for a particular local element of the field variable component.
  INTERFACE Field_ParameterSetUpdateLocalElement
    MODULE PROCEDURE Field_ParameterSetUpdateLocalElementIntg
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L
  END INTERFACE Field_ParameterSetUpdateLocalElement

  !>Updates the given parameter set with the given value for a particular user node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_NODE

  !>Updates the given parameter set with the given value for a particular user node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetUpdateNode
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_L
  END INTERFACE Field_ParameterSetUpdateNode

  !>Updates the given parameter set with the given value for a particular local node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE

  !>Updates the given parameter set with the given value for a particular local node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetUpdateLocalNode
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L
  END INTERFACE Field_ParameterSetUpdateLocalNode

  !>Updates the given parameter set with the given value for a particular element and gauss point of the field variable component. 
  INTERFACE Field_ParameterSetUpdateGaussPoint
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointSP
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointDP
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointL
  END INTERFACE Field_ParameterSetUpdateGaussPoint

  !>Updates the given parameter set with the given value for a particular element and gauss point of the field variable component. 
  INTERFACE FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointSP
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointDP
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointL
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT

  !>Updates the given parameter set with the given value for a particular local element and gauss point of the field variable component. 
  INTERFACE Field_ParameterSetUpdateLocalGaussPoint
    MODULE PROCEDURE Field_ParameterSetUpdateLocalGaussPointDP
  END INTERFACE Field_ParameterSetUpdateLocalGaussPoint

  !>Updates the given parameter set with the given value for a particular element and data point of the field variable component. TODO: sp/int/l versions
  INTERFACE Field_ParameterSetUpdateElementDataPoint
    MODULE PROCEDURE Field_ParameterSetUpdateElementDataPointDP
  END INTERFACE Field_ParameterSetUpdateElementDataPoint

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative. \todo Update FieldInterpolatedPointType to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE Field_ParameterSetInterpolateXi
    MODULE PROCEDURE Field_ParameterSetInterpolateXiDP0
    MODULE PROCEDURE Field_ParameterSetInterpolateXiDP1
  END INTERFACE Field_ParameterSetInterpolateXi

  !>Interpolates the given parameter set at the specified gauss point number for the specified element and derviative. \todo Update FieldInterpolatedPointType to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE Field_ParameterSetInterpolateGauss
    MODULE PROCEDURE Field_ParameterSetInterpolateGaussDP0
    MODULE PROCEDURE Field_ParameterSetInterpolateGaussDP1
  END INTERFACE Field_ParameterSetInterpolateGauss

  INTERFACE Field_ParameterSetVectorGet
    MODULE PROCEDURE FIELD_PARAMETER_SET_VECTOR_GET
  END INTERFACE Field_ParameterSetVectorGet

  INTERFACE Field_PhysicalPointsFinalise
    MODULE PROCEDURE FIELD_PHYSICAL_POINTS_FINALISE
  END INTERFACE Field_PhysicalPointsFinalise

  INTERFACE Field_PhysicalPointsInitialise
    MODULE PROCEDURE FIELD_PHYSICAL_POINTS_INITIALISE
  END INTERFACE Field_PhysicalPointsInitialise

  INTERFACE Field_ScalingTypeCheck
    MODULE PROCEDURE FIELD_SCALING_TYPE_CHECK
  END INTERFACE Field_ScalingTypeCheck

  INTERFACE Field_ScalingTypeGet
    MODULE PROCEDURE FIELD_SCALING_TYPE_GET
  END INTERFACE Field_ScalingTypeGet

  INTERFACE Field_ScalingTypeSet
    MODULE PROCEDURE FIELD_SCALING_TYPE_SET
  END INTERFACE Field_ScalingTypeSet

  INTERFACE Field_ScalingTypeSetAndLock
    MODULE PROCEDURE FIELD_SCALING_TYPE_SET_AND_LOCK
  END INTERFACE Field_ScalingTypeSetAndLock

  INTERFACE Field_TypeCheck
    MODULE PROCEDURE FIELD_TYPE_CHECK
  END INTERFACE Field_TypeCheck

  INTERFACE Field_TypeGet
    MODULE PROCEDURE FIELD_TYPE_GET
  END INTERFACE Field_TypeGet

  INTERFACE Field_TypeSet
    MODULE PROCEDURE FIELD_TYPE_SET
  END INTERFACE Field_TypeSet

  INTERFACE Field_TypeSetAndLock
    MODULE PROCEDURE FIELD_TYPE_SET_AND_LOCK
  END INTERFACE Field_TypeSetAndLock

  !>Gets the label for a field variable type.
  INTERFACE FIELD_VARIABLE_LABEL_GET
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_GET_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_GET_VS
  END INTERFACE FIELD_VARIABLE_LABEL_GET

  !>Gets the label for a field variable type.
  INTERFACE Field_VariableLabelGet
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_GET_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_GET_VS
  END INTERFACE Field_VariableLabelGet

  !>Sets/changes the label for a field variable type.
  INTERFACE FIELD_VARIABLE_LABEL_SET
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_VS
  END INTERFACE FIELD_VARIABLE_LABEL_SET

  !>Sets/changes the label for a field variable type.
  INTERFACE Field_VariableLabelSet
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_VS
  END INTERFACE Field_VariableLabelSet

  !>Sets/changes the label for a field variable type and locks so that no further changes can be made.
  INTERFACE FIELD_VARIABLE_LABEL_SET_AND_LOCK
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS
  END INTERFACE FIELD_VARIABLE_LABEL_SET_AND_LOCK

  !>Sets/changes the label for a field variable type and locks so that no further changes can be made.
  INTERFACE Field_VariableLabelSetAndLock
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS
  END INTERFACE Field_VariableLabelSetAndLock

  INTERFACE Field_VariableTypeCheck
    MODULE PROCEDURE FIELD_VARIABLE_TYPE_CHECK
  END INTERFACE Field_VariableTypeCheck

  INTERFACE Field_VariableTypesCheck
    MODULE PROCEDURE FIELD_VARIABLE_TYPES_CHECK
  END INTERFACE Field_VariableTypesCheck

  INTERFACE Field_VariableTypesGet
    MODULE PROCEDURE FIELD_VARIABLE_TYPES_GET
  END INTERFACE Field_VariableTypesGet

  INTERFACE Field_VariableTypesSet
    MODULE PROCEDURE FIELD_VARIABLE_TYPES_SET
  END INTERFACE Field_VariableTypesSet

  INTERFACE Field_VariableTypesSetAndLock
    MODULE PROCEDURE FIELD_VARIABLE_TYPES_SET_AND_LOCK
  END INTERFACE Field_VariableTypesSetAndLock

  !>Initialises the fields.
  INTERFACE Fields_Initialise
    MODULE PROCEDURE FIELDS_INITIALISE_INTERFACE
    MODULE PROCEDURE FIELDS_INITIALISE_REGION
  END INTERFACE Fields_Initialise

  PUBLIC FIELD_INDEPENDENT_TYPE,FIELD_DEPENDENT_TYPE

  PUBLIC FIELD_SCALAR_DIMENSION_TYPE,FIELD_VECTOR_DIMENSION_TYPE,FIELD_TENSOR_DIMENSION_TYPE

  PUBLIC FIELD_GEOMETRIC_TYPE,FIELD_FIBRE_TYPE,FIELD_GENERAL_TYPE,FIELD_MATERIAL_TYPE,FIELD_GEOMETRIC_GENERAL_TYPE
  PUBLIC FIELD_CONSTANT_DOF_TYPE,FIELD_ELEMENT_DOF_TYPE,FIELD_NODE_DOF_TYPE,FIELD_GRID_POINT_DOF_TYPE,FIELD_GAUSS_POINT_DOF_TYPE, &
    & FIELD_DATA_POINT_DOF_TYPE

  PUBLIC FIELD_SEPARATED_COMPONENT_DOF_ORDER,FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER

  PUBLIC FIELD_NO_SCALING,FIELD_UNIT_SCALING,FIELD_ARC_LENGTH_SCALING,FIELD_HARMONIC_MEAN_SCALING,FIELD_ARITHMETIC_MEAN_SCALING, &
    & FIELD_GEOMETRIC_MEAN_SCALING

  PUBLIC FIELD_ALL_COMPONENTS_TYPE,FIELD_GEOMETRIC_COMPONENTS_TYPE,FIELD_NONGEOMETRIC_COMPONENTS_TYPE

  PUBLIC FIELD_COMPONENT_DOF_GET_CONSTANT,FIELD_COMPONENT_DOF_GET_USER_ELEMENT,FIELD_COMPONENT_DOF_GET_USER_NODE, &
    & Field_componentDofGetUserDataPoint

  PUBLIC FIELD_COMPONENT_INTERPOLATION_CHECK,FIELD_COMPONENT_INTERPOLATION_SET,FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK

  PUBLIC Field_ComponentInterpolationCheck,Field_ComponentInterpolationSet,Field_ComponentInterpolationSetAndLock

  PUBLIC FIELD_COMPONENT_LABEL_GET,FIELD_COMPONENT_LABEL_SET,FIELD_COMPONENT_LABEL_SET_AND_LOCK

  PUBLIC Field_ComponentLabelGet,Field_ComponentLabelSet,Field_ComponentLabelSetAndLock

  PUBLIC FIELD_COMPONENT_MESH_COMPONENT_CHECK,FIELD_COMPONENT_MESH_COMPONENT_GET,FIELD_COMPONENT_MESH_COMPONENT_SET, &
    & FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK

  PUBLIC Field_ComponentMeshComponentCheck,Field_ComponentMeshComponentGet,Field_ComponentMeshComponentSet, &
    & Field_ComponentMeshComponentSetAndLock

  PUBLIC FIELD_COMPONENT_VALUES_INITIALISE

  PUBLIC Field_ComponentValuesInitialise

  PUBLIC FIELD_CREATE_FINISH,FIELD_CREATE_START

  PUBLIC Field_CreateFinish,Field_CreateStart

  PUBLIC Field_DataProjectionSet

  PUBLIC FIELD_DATA_TYPE_CHECK,FIELD_DATA_TYPE_GET,FIELD_DATA_TYPE_SET,FIELD_DATA_TYPE_SET_AND_LOCK

  PUBLIC Field_DataTypeCheck,Field_DataTypeGet,Field_DataTypeSet,Field_DataTypeSetAndLock

  PUBLIC Field_Destroy

  PUBLIC FIELD_DEPENDENT_TYPE_CHECK,FIELD_DEPENDENT_TYPE_GET,FIELD_DEPENDENT_TYPE_SET,FIELD_DEPENDENT_TYPE_SET_AND_LOCK

  PUBLIC Field_DependentTypeCheck,Field_DependentTypeGet,Field_DependentTypeSet,Field_DependentTypeSetAndLock

  PUBLIC FIELD_DIMENSION_CHECK,FIELD_DIMENSION_GET,FIELD_DIMENSION_SET,FIELD_DIMENSION_SET_AND_LOCK

  PUBLIC Field_DimensionCheck,Field_DimensionGet,Field_DimensionSet,Field_DimensionSetAndLock

  PUBLIC FIELD_DOF_ORDER_TYPE_CHECK,FIELD_DOF_ORDER_TYPE_GET,FIELD_DOF_ORDER_TYPE_SET,FIELD_DOF_ORDER_TYPE_SET_AND_LOCK

  PUBLIC Field_DOFOrderTypeCheck,Field_DOFOrderTypeGet,Field_DOFOrderTypeSet,Field_DOFOrderTypeSetAndLock

  PUBLIC Field_GeometricGeneralFieldGet

  PUBLIC FIELD_GEOMETRIC_FIELD_GET,FIELD_GEOMETRIC_FIELD_SET,FIELD_GEOMETRIC_FIELD_SET_AND_LOCK

  PUBLIC Field_GeometricFieldGet,Field_GeometricFieldSet,Field_GeometricFieldSetAndLock

  PUBLIC Field_GeometricParametersElementLineLengthGet, Field_GeometricParametersElementVolumeGet

  PUBLIC FIELD_INTERPOLATE_GAUSS,FIELD_INTERPOLATE_XI,FIELD_INTERPOLATE_NODE,FIELD_INTERPOLATE_FIELD_NODE, &
    & FIELD_INTERPOLATE_LOCAL_FACE_GAUSS

  PUBLIC Field_InterpolateGauss,Field_InterpolateXi,Field_InterpolateNode,Field_InterpolateFieldNode,Field_InterpolateLocalFaceGauss

  PUBLIC Field_PositionNormalTangentsCalculateIntPtMetric,Field_PositionNormalTangentsCalculateNode

  PUBLIC FIELD_INTERPOLATED_POINT_METRICS_CALCULATE

  PUBLIC Field_InterpolatedPointMetricsCalculate,Field_InterpolatedPointsMetricsFinalise,Field_InterpolatedPointsMetricsInitialise

  PUBLIC FIELD_INTERPOLATED_POINTS_FINALISE,FIELD_INTERPOLATED_POINTS_INITIALISE

  PUBLIC Field_InterpolatedPointsFinalise,Field_InterpolatedPointsInitialise

  PUBLIC FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET,FIELD_INTERPOLATION_PARAMETERS_FINALISE, &
    & FIELD_INTERPOLATION_PARAMETERS_INITIALISE,FIELD_INTERPOLATION_PARAMETERS_LINE_GET, &
    & FIELD_INTERPOLATION_PARAMETERS_FACE_GET

  PUBLIC Field_InterpolationParametersFinalise,Field_InterpolationParametersInitialise

  PUBLIC Field_InterpolationParametersElementGet,Field_InterpolationParametersFaceGet,Field_InterpolationParametersLineGet

  PUBLIC Field_InterpolationParametersScaleFactorsElementGet,Field_InterpolationParametersScaleFactorsLineGet, &
    & Field_InterpolationParametersScaleFactorsFaceGet

  PUBLIC FIELD_LABEL_GET,FIELD_LABEL_SET,FIELD_LABEL_SET_AND_LOCK

  PUBLIC Field_LabelGet,Field_LabelSet,Field_LabelSetAndLock

  PUBLIC FIELD_MESH_DECOMPOSITION_GET,FIELD_MESH_DECOMPOSITION_SET,FIELD_MESH_DECOMPOSITION_SET_AND_LOCK

  PUBLIC Field_DecompositionSet,Field_DecompositionSetAndLock

  PUBLIC FIELD_NUMBER_OF_COMPONENTS_CHECK,FIELD_NUMBER_OF_COMPONENTS_GET,FIELD_NUMBER_OF_COMPONENTS_SET, &
    & FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK

  PUBLIC Field_NumberOfComponentsCheck,Field_NumberOfComponentsGet,Field_NumberOfComponentsSet,Field_NumberOfComponentsSetAndLock

  PUBLIC FIELD_NUMBER_OF_VARIABLES_CHECK,FIELD_NUMBER_OF_VARIABLES_GET,FIELD_NUMBER_OF_VARIABLES_SET, &
    & FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK

  PUBLIC Field_NumberOfVariablesCheck,Field_NumberOfVariablesGet,Field_NumberOfVariablesSet,Field_NumberOfVariablesSetAndLock

  PUBLIC FIELD_PARAMETER_SETS_ADD

  PUBLIC Field_ParameterSetsAdd

  PUBLIC FIELD_PARAMETER_SETS_COPY

  PUBLIC Field_ParameterSetsCopy

  PUBLIC Field_ParameterSetsCopyIfExists

  PUBLIC FIELD_PARAMETER_SET_DESTROY

  PUBLIC Field_ParameterSetDestroy

  PUBLIC Field_ParametersToFieldParametersCopy

  PUBLIC FIELD_PARAMETER_SET_GET

  PUBLIC Field_ParameterSetGet

  PUBLIC FIELD_PARAMETER_SET_ADD_CONSTANT,FIELD_PARAMETER_SET_ADD_LOCAL_DOF,FIELD_PARAMETER_SET_ADD_ELEMENT, &
    & FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT,FIELD_PARAMETER_SET_ADD_NODE,FIELD_PARAMETER_SET_ADD_LOCAL_NODE

  PUBLIC Field_ParameterSetAddConstant,Field_ParameterSetAddLocalDOF,Field_ParameterSetAddElement, &
    & Field_ParameterSetAddGaussPoint,Field_ParameterSetAddLocalElement,Field_ParameterSetAddNode, &
    & Field_ParameterSetAddLocalNode

  PUBLIC FIELD_PARAMETER_SET_CREATE

  PUBLIC Field_ParameterSetCreate

  PUBLIC FIELD_PARAMETER_SET_CREATED

  PUBLIC Field_ParameterSetEnsureCreated,Field_ParameterSetCreated

  PUBLIC FIELD_PARAMETER_SET_DATA_GET,FIELD_PARAMETER_SET_DATA_RESTORE

  PUBLIC Field_ParameterSetDataGet,Field_ParameterSetDataRestore

  PUBLIC FIELD_PARAMETER_SET_GET_CONSTANT,FIELD_PARAMETER_SET_GET_ELEMENT, &
    & FIELD_PARAMETER_SET_GET_LOCAL_DOF,FIELD_PARAMETER_SET_GET_NODE, &
    & FIELD_PARAMETER_SET_GET_GAUSS_POINT

  PUBLIC Field_ParameterSetGetConstant,Field_ParameterSetGetDataPoint,Field_ParameterSetGetElement, &
    & Field_ParameterSetGetLocalElement,Field_ParameterSetGetLocalDOF,Field_ParameterSetGetNode, &
    & Field_ParameterSetGetLocalNode,Field_ParameterSetGetGaussPoint,Field_ParameterSetGetLocalGaussPoint

  PUBLIC FIELD_PARAMETER_SET_OUTPUT

  PUBLIC Field_ParameterSetOutput

  PUBLIC FIELD_PARAMETER_SET_UPDATE_FINISH,FIELD_PARAMETER_SET_UPDATE_START

  PUBLIC Field_ParameterSetUpdateFinish,Field_ParameterSetUpdateStart

  PUBLIC FIELD_PARAMETER_SET_UPDATE_CONSTANT,FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF,FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS, &
    & FIELD_PARAMETER_SET_UPDATE_ELEMENT,FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT,FIELD_PARAMETER_SET_UPDATE_NODE, &
    & FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE,FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT

  PUBLIC Field_ParameterSetUpdateConstant, &
    & Field_ParameterSetUpdateDataPoint,Field_ParameterSetUpdateLocalDataPoint, &
    & Field_ParameterSetUpdateElement,Field_ParameterSetUpdateLocalElement,Field_ParameterSetUpdateElementDataPoint, &
    & Field_ParameterSetUpdateGaussPoint,Field_ParameterSetUpdateLocalGaussPoint, &
    & Field_ParameterSetUpdateLocalDOF,Field_ParameterSetUpdateLocalDOFS, &
    & Field_ParameterSetUpdateNode,Field_ParameterSetUpdateLocalNode

  PUBLIC Field_ParameterSetNodeScaleFactorGet,Field_ParameterSetNodeScaleFactorSet, &
    & Field_ParameterSetNodeScaleFactorsGet,Field_ParameterSetNodeScaleFactorsSet, &
    & Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  PUBLIC Field_ParameterSetInterpolateXi

  PUBLIC Field_ParameterSetInterpolateGauss

  PUBLIC Field_ParameterSetVectorGet,FIELD_PARAMETER_SET_VECTOR_GET

  PUBLIC FIELD_PHYSICAL_POINTS_FINALISE,FIELD_PHYSICAL_POINTS_INITIALISE

  PUBLIC Field_PhysicalPointsFinalise,Field_PhysicalPointsInitialise

  PUBLIC FIELD_SCALING_TYPE_CHECK,FIELD_SCALING_TYPE_GET,FIELD_SCALING_TYPE_SET,FIELD_SCALING_TYPE_SET_AND_LOCK

  PUBLIC Field_ScalingTypeCheck,Field_ScalingTypeGet,Field_ScalingTypeSet,Field_ScalingTypeSetAndLock

  PUBLIC FIELD_TYPE_CHECK,FIELD_TYPE_GET,FIELD_TYPE_SET,FIELD_TYPE_SET_AND_LOCK

  PUBLIC Field_TypeCheck,Field_TypeGet,Field_TypeSet,Field_TypeSetAndLock

  PUBLIC FIELD_VARIABLE_LABEL_GET,FIELD_VARIABLE_LABEL_SET,FIELD_VARIABLE_LABEL_SET_AND_LOCK

  PUBLIC Field_VariableLabelGet,Field_VariableLabelSet,Field_VariableLabelSetAndLock

  PUBLIC FIELD_VARIABLE_TYPE_CHECK

  PUBLIC Field_VariableTypeCheck

  PUBLIC FIELD_VARIABLE_TYPES_CHECK,FIELD_VARIABLE_TYPES_GET,FIELD_VARIABLE_TYPES_SET,FIELD_VARIABLE_TYPES_SET_AND_LOCK

  PUBLIC Field_VariableTypesCheck,Field_VariableTypesGet,Field_VariableTypesSet,Field_VariableTypesSetAndLock

  PUBLIC FieldVariable_ParameterSetCreate

  PUBLIC FieldVariable_ParameterSetEnsureCreated,FieldVariable_ParameterSetCreated

  PUBLIC FieldVariable_ParameterSetGet

  PUBLIC FieldVariable_ParameterSetsCopy

  PUBLIC FieldVariable_ParameterSetsCopyIfExists

  PUBLIC Fields_Finalise,Fields_Initialise

  PUBLIC MESH_EMBEDDING_PUSH_DATA, MESH_EMBEDDING_PULL_GAUSS_POINT_DATA, FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD

CONTAINS

  !
  !================================================================================================================================
  !

  !>Checks the interpolation type for a field variable component.
  SUBROUTINE FIELD_COMPONENT_INTERPOLATION_CHECK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to check the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component to check
    INTEGER(INTG), INTENT(IN) :: INTERPOLATION_TYPE !<The interpolation type of the field variable component to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_INTERPOLATION_CHECK",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%numberOfComponents) THEN
      SELECT CASE(INTERPOLATION_TYPE)
      CASE(FIELD_CONSTANT_INTERPOLATION)
        IF(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType/=FIELD_CONSTANT_INTERPOLATION) THEN
          localError="Invalid interpolation type. The interpolation type for component number "// &
            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
            & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
            & TRIM(NumberToVString(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
            & " which is not constant interpolation."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
        IF(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType/=FIELD_ELEMENT_BASED_INTERPOLATION) THEN
          localError="Invalid interpolation type. The interpolation type for component number "// &
            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
            & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
            & TRIM(NumberToVString(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
            & " which is not element based interpolation."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NODE_BASED_INTERPOLATION)
        IF(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType/=FIELD_NODE_BASED_INTERPOLATION) THEN
          localError="Invalid interpolation type. The interpolation type for component number "// &
            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
            & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
            & TRIM(NumberToVString(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
            & " which is not node based interpolation."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
        IF(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType/=FIELD_GRID_POINT_BASED_INTERPOLATION) THEN
          localError="Invalid interpolation type. The interpolation type for component number "// &
            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
            & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
            & TRIM(NumberToVString(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
            & " which is not grid point based interpolation."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
        IF(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType/=FIELD_GAUSS_POINT_BASED_INTERPOLATION) THEN
          localError="Invalid interpolation type. The interpolation type for component number "// &
            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
            & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
            & TRIM(NumberToVString(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
            & " which is not Gauss point based interpolation."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
        IF(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType/=FIELD_DATA_POINT_BASED_INTERPOLATION) THEN
          localError="Invalid interpolation type. The interpolation type for component number "// &
            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
            & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
            & TRIM(NumberToVString(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
            & " which is not data point based interpolation."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The specified interpolation type of "//TRIM(NumberToVString(INTERPOLATION_TYPE,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      localError="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" which has "// &
        & TRIM(NumberToVString(FIELD_VARIABLE%numberOfComponents,"*",err,error))// &
        & " components."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_INTERPOLATION_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_INTERPOLATION_CHECK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_INTERPOLATION_CHECK

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component. \see OpenCMISS::Iron::cmfe_Field_ComponentInterpolationSet
  SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component to set
    INTEGER(INTG), INTENT(IN) :: INTERPOLATION_TYPE !<The interpolation type to set \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_INTERPOLATION_SET",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    IF(ASSOCIATED(FIELD%createValuesCache)) THEN          
      IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        IF(ANY(FIELD%createValuesCache%variableTypes==VARIABLE_TYPE)) THEN
          IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD%createValuesCache%numberOfComponents(VARIABLE_TYPE)) THEN
            IF(FIELD%createValuesCache%interpolationTypesLocked(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
              localError="The interpolation type has been locked for component number "// &
                & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))//" of variable type "// &
                & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
                & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
              CALL FlagError(localError,err,error,*999)
            ELSE
              SELECT CASE(INTERPOLATION_TYPE)                
              CASE(FIELD_CONSTANT_INTERPOLATION)
                FIELD%createValuesCache%interpolationTypes(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                FIELD%createValuesCache%interpolationTypes(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                FIELD%createValuesCache%interpolationTypes(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                FIELD%createValuesCache%interpolationTypes(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                FIELD%createValuesCache%interpolationTypes(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                FIELD%createValuesCache%interpolationTypes(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
              CASE DEFAULT
                localError="The specified interpolation type of "// &
                  & TRIM(NumberToVString(INTERPOLATION_TYPE,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          ELSE
            localError="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
              & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
              & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" which has "// &
              & TRIM(NumberToVString(FIELD%createValuesCache%numberOfComponents(VARIABLE_TYPE),"*",err,error))// &
              & " components."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="Field create values cache is not associated for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_INTERPOLATION_SET")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_INTERPOLATION_SET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component and locks so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component to set
    INTEGER(INTG), INTENT(IN) :: INTERPOLATION_TYPE !<The interpolation type to set \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK",err,error,*999)

    CALL FIELD_COMPONENT_INTERPOLATION_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,err,error,*999)
    IF(ASSOCIATED(FIELD%createValuesCache)) THEN
      FIELD%createValuesCache%interpolationTypesLocked(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
    ELSE
      localError="Field create values cache is not associated for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Returns the dof numbers for a field variable component that corresponds to the specified constant
  SUBROUTINE FIELD_COMPONENT_DOF_GET_CONSTANT(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LOCAL_DOF,GLOBAL_DOF,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: LOCAL_DOF !<On exit, the local dof corresponding to the constant
    INTEGER(INTG), INTENT(OUT) :: GLOBAL_DOF !<On exit, the global dof corresponding to the constant
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_COMPONENT_DOF_GET_CONSTANT",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_ConstantDofGet(FIELD_VARIABLE,COMPONENT_NUMBER,LOCAL_DOF,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    GLOBAL_DOF=domainMapping%localToGlobalMap(LOCAL_DOF)

    EXITS("FIELD_COMPONENT_DOF_GET_CONSTANT")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_DOF_GET_CONSTANT",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_DOF_GET_CONSTANT

  !
  !================================================================================================================================
  !

  !>Returns the dof numbers for a field component that corresponds to the specified user data point.
  SUBROUTINE Field_componentDofGetUserDataPoint(field,variableType,userDataPointNumber,componentNumber,localDof, &
    & globalDof,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The user data point number to get the dof for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: localDof !<On exit, the local dof corresponding to the user data point
    INTEGER(INTG), INTENT(OUT) :: globalDof !<On exit, the global dof corresponding to the user data point
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    LOGICAL :: ghostDof
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_componentDofGetUserDataPoint",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_UserDataPointDofGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDOf,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(fieldVariable,domainMapping,err,error,*999)
    globalDof=domainMapping%localToGlobalMap(localDof)

    EXITS("Field_componentDofGetUserDataPoint")
    RETURN
999 ERRORSEXITS("Field_componentDofGetUserDataPoint",err,error)
    RETURN 1

  END SUBROUTINE Field_componentDofGetUserDataPoint

  !
  !================================================================================================================================
  !

  !>Returns the dof numbers for a field component that corresponds to the specified user element.
  SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_ELEMENT(FIELD,VARIABLE_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,LOCAL_DOF, &
    & GLOBAL_DOF,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to get the dof for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: LOCAL_DOF !<On exit, the local dof corresponding to the user element
    INTEGER(INTG), INTENT(OUT) :: GLOBAL_DOF !<On exit, the global dof corresponding to the user element
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    LOGICAL :: GHOST_DOF
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_COMPONENT_DOF_GET_USER_ELEMENT",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_UserElementDofGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,LOCAL_DOF,GHOST_DOF,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    GLOBAL_DOF=domainMapping%localToGlobalMap(LOCAL_DOF)

    EXITS("FIELD_COMPONENT_DOF_GET_USER_ELEMENT")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_DOF_GET_USER_ELEMENT",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_ELEMENT

  !
  !================================================================================================================================
  !
  !>Returns the dof numbers for a field component that corresponds to the specified user node and derivative.
  SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_NODE(FIELD,VARIABLE_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER, & 
    & COMPONENT_NUMBER,LOCAL_DOF,GLOBAL_DOF,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The version number to get the dof for
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The derivative number to get the dof for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to get the dof for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: LOCAL_DOF !<On exit, the local dof corresponding to the user node
    INTEGER(INTG), INTENT(OUT) :: GLOBAL_DOF !<On exit, the global dof corresponding to the user node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    LOGICAL :: GHOST_DOF
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_COMPONENT_DOF_GET_USER_NODE",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_UserNodeDofGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & LOCAL_DOF,GHOST_DOF,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    GLOBAL_DOF=domainMapping%localToGlobalMap(LOCAL_DOF)

    EXITS("FIELD_COMPONENT_DOF_GET_USER_NODE")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_DOF_GET_USER_NODE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_NODE

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable component for character labels. \see OpenCMISS::Iron::cmfe_FieldComponentLabelGet
  SUBROUTINE FIELD_COMPONENT_LABEL_GET_C(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    CHARACTER(LEN=*), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: C_LENGTH,VS_LENGTH
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_LABEL_GET_C",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%numberOfComponents) THEN
      C_LENGTH=LEN(LABEL)
      VS_LENGTH=LEN_TRIM(FIELD_VARIABLE%components(COMPONENT_NUMBER)%componentLabel)
      IF(C_LENGTH>VS_LENGTH) THEN
        LABEL=CHAR(LEN_TRIM(FIELD_VARIABLE%components(COMPONENT_NUMBER)%componentLabel))
      ELSE
        LABEL=CHAR(FIELD_VARIABLE%components(COMPONENT_NUMBER)%componentLabel,C_LENGTH)
      ENDIF
    ELSE
      localError="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" which has "// &
        & TRIM(NumberToVString(FIELD_VARIABLE%numberOfComponents,"*",err,error))// &
        & " components."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_GET_C")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_GET_C",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_LABEL_GET_C

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable component for varying string labels. \see OpenCMISS::Iron::cmfe_FieldComponentLabelGet
  SUBROUTINE FIELD_COMPONENT_LABEL_GET_VS(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    TYPE(VARYING_STRING), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_LABEL_GET_VS",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%numberOfComponents) THEN
      LABEL=FIELD_VARIABLE%components(COMPONENT_NUMBER)%componentLabel
    ELSE
      localError="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" which has "// &
        & TRIM(NumberToVString(FIELD_VARIABLE%numberOfComponents,"*",err,error))// &
        & " components."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_GET_VS")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_GET_VS",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_LABEL_GET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable component for character labels. \see OpenCMISS::Iron::cmfe_FieldComponentLabelSet
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_C(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_LABEL_SET_C",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    IF(ASSOCIATED(FIELD%createValuesCache)) THEN
      IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        IF(ANY(FIELD%createValuesCache%variableTypes==VARIABLE_TYPE)) THEN              
          IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD%createValuesCache%numberOfComponents(VARIABLE_TYPE)) THEN
            IF(FIELD%createValuesCache%componentLabelsLocked(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
              localError="The component label has been locked for component number "// &
                & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))//" of variable type "// &
                & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
                & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
              CALL FlagError(localError,err,error,*999)
            ELSE
              FIELD%createValuesCache%componentLabels(COMPONENT_NUMBER,VARIABLE_TYPE)=LABEL
            ENDIF
          ELSE
            localError="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
              & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
              & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" which has "// &
              & TRIM(NumberToVString(FIELD%createValuesCache%numberOfComponents(VARIABLE_TYPE),"*",err,error))// &
              & " components."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="Field create values cache is not associated for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_SET_C")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_SET_C",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable component for varying string labels. \see OpenCMISS::Iron::cmfe_FieldComponentLabelSet
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_VS(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_LABEL_SET_VS",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    IF(ASSOCIATED(FIELD%createValuesCache)) THEN
      IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        IF(ANY(FIELD%createValuesCache%variableTypes==VARIABLE_TYPE)) THEN              
          IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD%createValuesCache%numberOfComponents(VARIABLE_TYPE)) THEN
            IF(FIELD%createValuesCache%componentLabelsLocked(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
              localError="The component label has been locked for component number "// &
                & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))//" of variable type "// &
                & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
                & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
              CALL FlagError(localError,err,error,*999)
            ELSE
              FIELD%createValuesCache%componentLabels(COMPONENT_NUMBER,VARIABLE_TYPE)=LABEL
            ENDIF
          ELSE
            localError="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
              & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
              & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" which has "// &
              & TRIM(NumberToVString(FIELD%createValuesCache%numberOfComponents(VARIABLE_TYPE),"*",err,error))// &
              & " components."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="Field create values cache is not associated for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_SET_VS")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_SET_VS",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_C(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_C",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,err,error,*999)
    IF(ASSOCIATED(FIELD%createValuesCache)) THEN
      FIELD%createValuesCache%componentLabelsLocked(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
    ELSE
      localError="Field create values cache is not associated for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_C")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_C",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,err,error,*999)
    IF(ASSOCIATED(FIELD%createValuesCache)) THEN
      FIELD%createValuesCache%componentLabelsLocked(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
    ELSE
      localError="Field create values cache is not associated for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS

  !
  !================================================================================================================================
  !

  !>Check the mesh component number for a field variable component.
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_CHECK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to check the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check the field variable component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to check the field variable component for
    INTEGER(INTG), INTENT(IN) :: MESH_COMPONENT !<The mesh component to check for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_MESH_COMPONENT_CHECK",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%numberOfComponents) THEN
      IF(FIELD_VARIABLE%components(COMPONENT_NUMBER)%meshComponentNumber/=MESH_COMPONENT) THEN
        localError="Invalid mesh component number. The mesh component number for component number "// &
          & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
          & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
          & " which is does correspond to the specified mesh component number of "// &
          & TRIM(NumberToVString(MESH_COMPONENT,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" which has "// &
        & TRIM(NumberToVString(FIELD_VARIABLE%numberOfComponents,"*",err,error))// &
        & " components."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_MESH_COMPONENT_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_MESH_COMPONENT_CHECK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the mesh component number for a field variable component. \see cmfe_Field_ComponentMeshComponentGet
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_GET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the field variable component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the field variable component for
    INTEGER(INTG), INTENT(OUT) :: MESH_COMPONENT !<On return, the mesh component to get for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_MESH_COMPONENT_GET",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%numberOfComponents) THEN
      MESH_COMPONENT=FIELD_VARIABLE%components(COMPONENT_NUMBER)%meshComponentNumber
    ELSE
      localError="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" which has "// &
        & TRIM(NumberToVString(FIELD_VARIABLE%numberOfComponents,"*",err,error))// &
        & " components."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_MESH_COMPONENT_GET")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_MESH_COMPONENT_GET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component. \see OpenCMISS::Iron::cmfe_FieldComponentMeshComponentSet
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,meshComponentNumber,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set the mesh component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component to set for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(MeshType), POINTER :: mesh
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_MESH_COMPONENT_SET",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(mesh)
    CALL Decomposition_MeshGet(decomposition,mesh,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      IF(ANY(createValuesCache%variableTypes==VARIABLE_TYPE)) THEN
        IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=createValuesCache%numberOfComponents(VARIABLE_TYPE)) THEN
          IF(createValuesCache%meshComponentNumberLocked(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
            localError="The mesh component has been locked for component number "// &
              & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))//" of variable type "// &
              & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
            CALL FlagError(localError,err,error,*999)
          ELSE
            SELECT CASE(createValuesCache%interpolationTypes(COMPONENT_NUMBER,VARIABLE_TYPE))
              ! Should set anyway in case user changes interpolation(?) Needed by finite elasticity / material field - Sander  
              !                      CASE(FIELD_CONSTANT_INTERPOLATION)
              !                        localError="Can not set a mesh component for field component number "// &
              !                          & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
              !                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
              !                          & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
              !                          & " which has constant interpolation."
              !                        CALL FlagError(localError,err,error,*999)
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION,FIELD_NODE_BASED_INTERPOLATION,FIELD_GRID_POINT_BASED_INTERPOLATION, &
              & FIELD_GAUSS_POINT_BASED_INTERPOLATION, FIELD_CONSTANT_INTERPOLATION,FIELD_DATA_POINT_BASED_INTERPOLATION)
              IF(meshComponentNumber>0.AND.meshComponentNumber<=decomposition%numberOfComponents) THEN
                createValuesCache%meshComponentNumber(COMPONENT_NUMBER,VARIABLE_TYPE)=meshComponentNumber
              ELSE
                localError="Mesh component number "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
                  & " is invalid. The component number must be between 1 and "// &
                  & TRIM(NumberToVString(decomposition%numberOfComponents,"*",err,error))// &
                  & " for decomposition number "//TRIM(NumberToVString(decomposition%userNumber,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            CASE DEFAULT
              localError="The interpolation type "//TRIM(NumberToVString(createValuesCache% &
                & interpolationTypes(COMPONENT_NUMBER,VARIABLE_TYPE),"*",err,error))// &
                & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
                & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
                & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ELSE
          localError="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
            & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" which has "// &
            & TRIM(NumberToVString(FIELD%createValuesCache%numberOfComponents(VARIABLE_TYPE),"*",err,error))// &
            & " components."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
          & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " is invalid. The field variable type must be > 1 and <= "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_MESH_COMPONENT_SET")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_MESH_COMPONENT_SET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component and locks it so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,meshComponentNumber,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set the mesh component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component to set for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK",err,error,*999)

    CALL FIELD_COMPONENT_MESH_COMPONENT_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,meshComponentNumber,err,error,*999)
    IF(ASSOCIATED(FIELD%createValuesCache)) THEN
      FIELD%createValuesCache%meshComponentNumberLocked(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
    ELSE
      localError="Field create values cache is not associated for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK")
    RETURN
999 ERRORS("FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK",err,error)
    EXITS("FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK")
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a constant integer value. \see OpenCMISS::Iron::cmfe_Field_ComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    INTEGER(INTG), INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: element_idx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx,gauss_point_idx,MAX_NGP
    INTEGER(INTG), POINTER :: FIELD_PARAMETERS(:)
    TYPE(DomainType), POINTER :: COMPONENT_DOMAIN
    TYPE(DomainTopologyType), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DomainElementsType), POINTER :: DOMAIN_ELEMENTS
    TYPE(DomainNodesType), POINTER :: DOMAIN_NODES
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_INTG",err,error,*999)

    NULLIFY(FIELD_PARAMETERS)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    !Check the component number
    CALL FieldVariable_AssertComponentNumberOK(FIELD_VARIABLE,COMPONENT_NUMBER,err,error,*999)
    !Get the parameters values
    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,err,error,*999)
    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
    !and not worry about updating the field parameter set.
    SELECT CASE(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap%constantParam2DOFMap
      FIELD_PARAMETERS(field_dof)=VALUE
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_ELEMENTS)
      CALL DomainTopology_DomainElementsGet(DOMAIN_TOPOLOGY,DOMAIN_ELEMENTS,err,error,*999)
      DO element_idx=1,DOMAIN_ELEMENTS%totalNumberOfElements
        field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap%elementParam2DOFMap%ELEMENTS(element_idx)
        FIELD_PARAMETERS(field_dof)=VALUE
      ENDDO !element_idx
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_NODES)
      CALL DomainTopology_DomainNodesGet(DOMAIN_TOPOLOGY,DOMAIN_NODES,err,error,*999)
      DO node_idx=1,DOMAIN_NODES%totalNumberOfNodes
        DO derivative_idx=1,DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
          DO version_idx=1,DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
            field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap% &
              & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
            partial_deriv_idx=DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%partialDerivativeIndex
            SELECT CASE(partial_deriv_idx)
            CASE(NO_PART_DERIV)
              FIELD_PARAMETERS(field_dof)=VALUE
            CASE(PART_DERIV_S1)
              FIELD_PARAMETERS(field_dof)=1_INTG
            CASE(PART_DERIV_S1_S1)
              FIELD_PARAMETERS(field_dof)=0_INTG
            CASE(PART_DERIV_S2)
              FIELD_PARAMETERS(field_dof)=1_INTG
            CASE(PART_DERIV_S2_S2)
              FIELD_PARAMETERS(field_dof)=0_INTG
            CASE(PART_DERIV_S1_S2)
              FIELD_PARAMETERS(field_dof)=0_INTG
            CASE(PART_DERIV_S3)
              FIELD_PARAMETERS(field_dof)=1_INTG
            CASE(PART_DERIV_S3_S3)
              FIELD_PARAMETERS(field_dof)=0_INTG
            CASE(PART_DERIV_S1_S3)
              FIELD_PARAMETERS(field_dof)=0_INTG
            CASE(PART_DERIV_S2_S3)
              FIELD_PARAMETERS(field_dof)=0_INTG
            CASE(PART_DERIV_S1_S2_S3)
              FIELD_PARAMETERS(field_dof)=0_INTG
            CASE DEFAULT
              localError="The partial derivative index of "// &
                & TRIM(NumberToVString(partial_deriv_idx,"*",err,error))//" for node number "// &
                & TRIM(NumberToVString(node_idx,"*",err,error))//" and derivative number "// &
                & TRIM(NumberToVString(derivative_idx,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !version_idx
        ENDDO !derivative_idx
      ENDDO !node_idx
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_ELEMENTS)
      CALL DomainTopology_DomainElementsGet(DOMAIN_TOPOLOGY,DOMAIN_ELEMENTS,err,error,*999)
      !gaussPointParam2DOFMap%gaussPoints(gauss_point_idx,element_idx)=variable_local_ny
      MAX_NGP=SIZE(FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap% &
        & gaussPointParam2DOFMap%gaussPoints,1)
      DO element_idx=1,DOMAIN_ELEMENTS%totalNumberOfElements
        DO gauss_point_idx=1,MAX_NGP ! could be just element's gauss_point_idx
          field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap% &
            & gaussPointParam2DOFMap%gaussPoints(gauss_point_idx,element_idx)
          FIELD_PARAMETERS(field_dof)=VALUE
        ENDDO !gauss_point_idx
      ENDDO !element_idx
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
        & COMPONENTS(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
        & " is invalid for component number "// &
        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    !Restore the  parameter set 
    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,err,error,*999)

    EXITS("FIELD_COMPONENT_VALUES_INITIALISE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_VALUES_INITIALISE_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_INTG

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value. \see OpenCMISS::Iron::cmfe_Field_ComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intiialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    REAL(SP), INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: element_idx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx,gauss_point_idx,MAX_NGP
    REAL(SP), POINTER :: FIELD_PARAMETERS(:)
    TYPE(DomainType), POINTER :: COMPONENT_DOMAIN
    TYPE(DomainTopologyType), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DomainElementsType), POINTER :: DOMAIN_ELEMENTS
    TYPE(DomainNodesType), POINTER :: DOMAIN_NODES
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_SP",err,error,*999)

    NULLIFY(FIELD_PARAMETERS)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    !Check the component number
    CALL FieldVariable_AssertComponentNumberOK(FIELD_VARIABLE,COMPONENT_NUMBER,err,error,*999)
    !Get the parameters values
    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,err,error,*999)
    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
    !and not worry about updating the field parameter set.
    SELECT CASE(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap%constantParam2DOFMap
      FIELD_PARAMETERS(field_dof)=VALUE
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_ELEMENTS)
      CALL DomainTopology_DomainElementsGet(DOMAIN_TOPOLOGY,DOMAIN_ELEMENTS,err,error,*999)
      DO element_idx=1,DOMAIN_ELEMENTS%totalNumberOfElements
        field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap% &
          & elementParam2DOFMap%ELEMENTS(element_idx)
        FIELD_PARAMETERS(field_dof)=VALUE
      ENDDO !element_idx
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_NODES)
      CALL DomainTopology_DomainNodesGet(DOMAIN_TOPOLOGY,DOMAIN_NODES,err,error,*999)
      DO node_idx=1,DOMAIN_NODES%totalNumberOfNodes
        DO derivative_idx=1,DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
          DO version_idx=1,DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
            field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap% &
              & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
            partial_deriv_idx=DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%partialDerivativeIndex
            SELECT CASE(partial_deriv_idx)
            CASE(NO_PART_DERIV)
              FIELD_PARAMETERS(field_dof)=VALUE
            CASE(PART_DERIV_S1)
              FIELD_PARAMETERS(field_dof)=1.0_SP
            CASE(PART_DERIV_S1_S1)
              FIELD_PARAMETERS(field_dof)=0.0_SP
            CASE(PART_DERIV_S2)
              FIELD_PARAMETERS(field_dof)=1.0_SP
            CASE(PART_DERIV_S2_S2)
              FIELD_PARAMETERS(field_dof)=0.0_SP
            CASE(PART_DERIV_S1_S2)
              FIELD_PARAMETERS(field_dof)=0.0_SP
            CASE(PART_DERIV_S3)
              FIELD_PARAMETERS(field_dof)=1.0_SP
            CASE(PART_DERIV_S3_S3)
              FIELD_PARAMETERS(field_dof)=0.0_SP
            CASE(PART_DERIV_S1_S3)
              FIELD_PARAMETERS(field_dof)=0.0_SP
            CASE(PART_DERIV_S2_S3)
              FIELD_PARAMETERS(field_dof)=0.0_SP
            CASE(PART_DERIV_S1_S2_S3)
              FIELD_PARAMETERS(field_dof)=0.0_SP
            CASE DEFAULT
              localError="The partial derivative index of "// &
                & TRIM(NumberToVString(partial_deriv_idx,"*",err,error))//" for node number "// &
                & TRIM(NumberToVString(node_idx,"*",err,error))//" and derivative number "// &
                & TRIM(NumberToVString(derivative_idx,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !version_idx
        ENDDO !derivative_idx
      ENDDO !node_idx
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_ELEMENTS)
      CALL DomainTopology_DomainElementsGet(DOMAIN_TOPOLOGY,DOMAIN_ELEMENTS,err,error,*999)
      !gaussPointParam2DOFMap%gaussPoints(gauss_point_idx,element_idx)=variable_local_ny
      MAX_NGP=SIZE(FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
      DO element_idx=1,DOMAIN_ELEMENTS%totalNumberOfElements
        DO gauss_point_idx=1,MAX_NGP ! could be just element's gauss_point_idx
          field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap% &
            & gaussPointParam2DOFMap%gaussPoints(gauss_point_idx,element_idx)
          FIELD_PARAMETERS(field_dof)=VALUE
        ENDDO !gauss_point_idx
      ENDDO !element_idx
    CASE DEFAULT
      localError="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
        & COMPONENTS(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
        & " is invalid for component number "// &
        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    !Restore the  parameter set 
    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,err,error,*999)

    EXITS("FIELD_COMPONENT_VALUES_INITIALISE_SP")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_VALUES_INITIALISE_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_SP

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value. \see OpenCMISS::Iron::cmfe_Field_ComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intiialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    REAL(DP), INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: elementIdx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx,gauss_point_idx,MAX_NGP, &
      & dataPointIdx,localDataPointNumber
    REAL(DP), POINTER :: FIELD_PARAMETERS(:)
    TYPE(DomainType), POINTER :: COMPONENT_DOMAIN
    TYPE(DomainTopologyType), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DomainElementsType), POINTER :: DOMAIN_ELEMENTS
    TYPE(DomainNodesType), POINTER :: DOMAIN_NODES
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionDataPointsType), POINTER :: decompositionData
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_DP",err,error,*999)

    NULLIFY(FIELD_PARAMETERS)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    !Check the component number
    CALL FieldVariable_AssertComponentNumberOK(FIELD_VARIABLE,COMPONENT_NUMBER,err,error,*999)
    !Get the parameters values
    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,err,error,*999)
    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
    !and not worry about updating the field parameter set.
    SELECT CASE(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap%constantParam2DOFMap
      FIELD_PARAMETERS(field_dof)=VALUE
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_ELEMENTS)
      CALL DomainTopology_DomainElementsGet(DOMAIN_TOPOLOGY,DOMAIN_ELEMENTS,err,error,*999)
      DO elementIdx=1,DOMAIN_ELEMENTS%totalNumberOfElements
        field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap%elementParam2DOFMap%ELEMENTS(elementIdx)
        FIELD_PARAMETERS(field_dof)=VALUE
      ENDDO !elementIdx
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_NODES)
      CALL DomainTopology_DomainNodesGet(DOMAIN_TOPOLOGY,DOMAIN_NODES,err,error,*999)
      DO node_idx=1,DOMAIN_NODES%totalNumberOfNodes
        DO derivative_idx=1,DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
          DO version_idx=1,DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
            field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap% &
              & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
            partial_deriv_idx= DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%partialDerivativeIndex
            SELECT CASE(partial_deriv_idx)
            CASE(NO_PART_DERIV)
              FIELD_PARAMETERS(field_dof)=VALUE
            CASE(PART_DERIV_S1)
              FIELD_PARAMETERS(field_dof)=1.0_DP
            CASE(PART_DERIV_S1_S1)
              FIELD_PARAMETERS(field_dof)=0.0_DP
            CASE(PART_DERIV_S2)
              FIELD_PARAMETERS(field_dof)=1.0_DP
            CASE(PART_DERIV_S2_S2)
              FIELD_PARAMETERS(field_dof)=0.0_DP
            CASE(PART_DERIV_S1_S2)
              FIELD_PARAMETERS(field_dof)=0.0_DP
            CASE(PART_DERIV_S3)
              FIELD_PARAMETERS(field_dof)=1.0_DP
            CASE(PART_DERIV_S3_S3)
              FIELD_PARAMETERS(field_dof)=0.0_DP
            CASE(PART_DERIV_S1_S3)
              FIELD_PARAMETERS(field_dof)=0.0_DP
            CASE(PART_DERIV_S2_S3)
              FIELD_PARAMETERS(field_dof)=0.0_DP
            CASE(PART_DERIV_S1_S2_S3)
              FIELD_PARAMETERS(field_dof)=0.0_DP
            CASE DEFAULT
              localError="The partial derivative index of "// &
                & TRIM(NumberToVString(partial_deriv_idx,"*",err,error))//" for node number "// &
                & TRIM(NumberToVString(node_idx,"*",err,error))//" and derivative number "// &
                & TRIM(NumberToVString(derivative_idx,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !version_idx
        ENDDO !derivative_idx
      ENDDO !node_idx
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_ELEMENTS)
      CALL DomainTopology_DomainElementsGet(DOMAIN_TOPOLOGY,DOMAIN_ELEMENTS,err,error,*999)
      !gaussPointParam2DOFMap%gaussPoints(gauss_point_idx,elementIdx)=variable_local_ny
      MAX_NGP=SIZE(FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
      DO elementIdx=1,DOMAIN_ELEMENTS%totalNumberOfElements
        DO gauss_point_idx=1,MAX_NGP ! could be just element's gauss_point_idx
          field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap% &
            & gaussPointParam2DOFMap%gaussPoints(gauss_point_idx,elementIdx)
          FIELD_PARAMETERS(field_dof)=VALUE
        ENDDO !gauss_point_idx
      ENDDO !elementIdx
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_ELEMENTS)
      CALL DomainTopology_DomainElementsGet(DOMAIN_TOPOLOGY,DOMAIN_ELEMENTS,err,error,*999)
      NULLIFY(decomposition)
      CALL Domain_DecompositionGet(COMPONENT_DOMAIN,decomposition,err,error,*999)
      NULLIFY(decompositionTopology)
      CALL Decomposition_DecompositionTopologyget(decomposition,decompositionTopology,err,error,*999)
      NULLIFY(decompositionData)
      CALL DecompositionTopology_DecompositionDataPointsGet(decompositionTopology,decompositionData,err,error,*999)
      DO elementIdx=1,DOMAIN_ELEMENTS%totalNumberOfElements
        DO dataPointIdx=1,decompositionData%elementDataPoints(elementIdx)%numberOfProjectedData
          localDataPointNumber=decompositionData%elementDataPoints(elementIdx)%dataIndices(dataPointIdx)%localNumber
          field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap%dataPointParam2DOFMap% &
            & dataPoints(localDataPointNumber)
          FIELD_PARAMETERS(field_dof)=VALUE
        ENDDO !dataPointIdx                             
      ENDDO !elementIdx
    CASE DEFAULT
      localError="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
        & COMPONENTS(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
        & " is invalid for component number "// &
        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    !Restore the  parameter set 
    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,err,error,*999)

    EXITS("FIELD_COMPONENT_VALUES_INITIALISE_DP")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_VALUES_INITIALISE_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_DP

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value. \see OpenCMISS::Iron::cmfe_Field_ComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intiialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    LOGICAL, INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: element_idx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx
    LOGICAL, POINTER :: FIELD_PARAMETERS(:)
    TYPE(DomainType), POINTER :: COMPONENT_DOMAIN
    TYPE(DomainTopologyType), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DomainElementsType), POINTER :: DOMAIN_ELEMENTS
    TYPE(DomainNodesType), POINTER :: DOMAIN_NODES
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_L",err,error,*999)


    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    !Check the component number
    CALL FieldVariable_AssertComponentNumberOK(FIELD_VARIABLE,COMPONENT_NUMBER,err,error,*999)
    !Get the parameters values
    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,err,error,*999)
    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
    !and not worry about updating the field parameter set.
    SELECT CASE(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap%constantParam2DOFMap
      FIELD_PARAMETERS(field_dof)=VALUE
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_ELEMENTS)
      CALL DomainTopology_DomainElementsGet(DOMAIN_TOPOLOGY,DOMAIN_ELEMENTS,err,error,*999)
      DO element_idx=1,DOMAIN_ELEMENTS%totalNumberOfElements
        field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap% &
          & elementParam2DOFMap%ELEMENTS(element_idx)
        FIELD_PARAMETERS(field_dof)=VALUE
      ENDDO !element_idx
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      NULLIFY(COMPONENT_DOMAIN)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,COMPONENT_DOMAIN,err,error,*999)
      NULLIFY(DOMAIN_TOPOLOGY)
      CALL Domain_DomainTopologyGet(COMPONENT_DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
      NULLIFY(DOMAIN_NODES)
      CALL DomainTopology_DomainNodesGet(DOMAIN_TOPOLOGY,DOMAIN_NODES,err,error,*999)
      DO node_idx=1,DOMAIN_NODES%totalNumberOfNodes
        DO derivative_idx=1,DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
          DO version_idx=1,DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
            field_dof=FIELD_VARIABLE%components(COMPONENT_NUMBER)%paramToDOFMap% &
              & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
            partial_deriv_idx=DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%partialDerivativeIndex
            SELECT CASE(partial_deriv_idx)
            CASE(NO_PART_DERIV)
              FIELD_PARAMETERS(field_dof)=VALUE
            CASE(PART_DERIV_S1)
              FIELD_PARAMETERS(field_dof)=.TRUE.
            CASE(PART_DERIV_S1_S1)
              FIELD_PARAMETERS(field_dof)=.FALSE.
            CASE(PART_DERIV_S2)
              FIELD_PARAMETERS(field_dof)=.TRUE.
            CASE(PART_DERIV_S2_S2)
              FIELD_PARAMETERS(field_dof)=.FALSE.
            CASE(PART_DERIV_S1_S2)
              FIELD_PARAMETERS(field_dof)=.FALSE.
            CASE(PART_DERIV_S3)
              FIELD_PARAMETERS(field_dof)=.TRUE.
            CASE(PART_DERIV_S3_S3)
              FIELD_PARAMETERS(field_dof)=.FALSE.
            CASE(PART_DERIV_S1_S3)
              FIELD_PARAMETERS(field_dof)=.FALSE.
            CASE(PART_DERIV_S2_S3)
              FIELD_PARAMETERS(field_dof)=.FALSE.
            CASE(PART_DERIV_S1_S2_S3)
              FIELD_PARAMETERS(field_dof)=.FALSE.
            CASE DEFAULT
              localError="The partial derivative index of "// &
                & TRIM(NumberToVString(partial_deriv_idx,"*",err,error))//" for node number "// &
                & TRIM(NumberToVString(node_idx,"*",err,error))//" and derivative number "// &
                & TRIM(NumberToVString(derivative_idx,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !version_idx
        ENDDO !derivative_idx
      ENDDO !node_idx
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
        & COMPONENTS(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
        & " is invalid for component number "// &
        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    !Restore the  parameter set 
    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,err,error,*999)

    EXITS("FIELD_COMPONENT_VALUES_INITIALISE_L")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_VALUES_INITIALISE_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_L

  !
  !================================================================================================================================
  !

  !>Checks the data type for a field variable.
  SUBROUTINE FIELD_DATA_TYPE_CHECK(FIELD,VARIABLE_TYPE,DATA_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to check the data type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DATA_TYPE !<The data type of the field variable to check \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_DATA_TYPE_CHECK",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    SELECT CASE(DATA_TYPE)              
    CASE(FIELD_INTG_TYPE)
      IF(FIELD_VARIABLE%dataType/=FIELD_INTG_TYPE) THEN
        localError="Invalid data type. The data type for variable type "// &
          & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD_VARIABLE%dataType,"*",err,error))// &
          & " which is not an integer data type."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_SP_TYPE)
      IF(FIELD_VARIABLE%dataType/=FIELD_SP_TYPE) THEN
        localError="Invalid data type. The data type for variable type "// &
          & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD_VARIABLE%dataType,"*",err,error))// &
          & " which is not a single precision data type."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_DP_TYPE)
      IF(FIELD_VARIABLE%dataType/=FIELD_DP_TYPE) THEN
        localError="Invalid data type. The data type for variable type "// &
          & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD_VARIABLE%dataType,"*",err,error))// &
          & " which is not a double precision data type."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_L_TYPE)
      IF(FIELD_VARIABLE%dataType/=FIELD_L_TYPE) THEN
        localError="Invalid data type. The data type for variable type "// &
          & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD_VARIABLE%dataType,"*",err,error))// &
          & " which is not a logical data type."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE DEFAULT
      localError="The specified data type of "//TRIM(NumberToVString(DATA_TYPE,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FIELD_DATA_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_DATA_TYPE_CHECK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DATA_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the data type for a field variable. \see OpenCMISS::Iron::cmfe_Field_DataTypeGet
  SUBROUTINE FIELD_DATA_TYPE_GET(FIELD,VARIABLE_TYPE,DATA_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the data type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: DATA_TYPE !<On return, the data type of the field variable \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_DATA_TYPE_GET",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)

    DATA_TYPE=FIELD_VARIABLE%dataType

    EXITS("FIELD_DATA_TYPE_GET")
    RETURN
999 ERRORSEXITS("FIELD_DATA_TYPE_GET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DATA_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable. \see OpenCMISS::Iron::cmfe_Field_DataTypeSet
  SUBROUTINE FIELD_DATA_TYPE_SET(FIELD,VARIABLE_TYPE,DATA_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DATA_TYPE !<The data type to set \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_DATA_TYPE_SET",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    IF(ASSOCIATED(FIELD%createValuesCache)) THEN          
      IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN            
        IF(ANY(FIELD%createValuesCache%variableTypes==VARIABLE_TYPE)) THEN
          IF(FIELD%createValuesCache%dataTypesLocked(VARIABLE_TYPE)) THEN
            localError="The data type has been locked for variable type "// &
              & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
            CALL FlagError(localError,err,error,*999)
          ELSE
            SELECT CASE(DATA_TYPE)                
            CASE(FIELD_INTG_TYPE)
              FIELD%createValuesCache%dataTypes(VARIABLE_TYPE)=FIELD_INTG_TYPE
            CASE(FIELD_SP_TYPE)
              FIELD%createValuesCache%dataTypes(VARIABLE_TYPE)=FIELD_SP_TYPE
            CASE(FIELD_DP_TYPE)
              FIELD%createValuesCache%dataTypes(VARIABLE_TYPE)=FIELD_DP_TYPE
            CASE(FIELD_L_TYPE)
              FIELD%createValuesCache%dataTypes(VARIABLE_TYPE)=FIELD_L_TYPE
            CASE DEFAULT
              localError="The specified data type of "//TRIM(NumberToVString(DATA_TYPE,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ELSE
          localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field create values cache is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_DATA_TYPE_SET")
    RETURN
999 ERRORSEXITS("FIELD_DATA_TYPE_SET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DATA_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable and locks it so that no further changes can be made.
  SUBROUTINE FIELD_DATA_TYPE_SET_AND_LOCK(FIELD,VARIABLE_TYPE,DATA_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DATA_TYPE !<The data type to set \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_DATA_TYPE_SET_AND_LOCK",err,error,*999)

    CALL FIELD_DATA_TYPE_SET(FIELD,VARIABLE_TYPE,DATA_TYPE,err,error,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%createValuesCache)) THEN
        FIELD%createValuesCache%dataTypesLocked(VARIABLE_TYPE)=.TRUE.
      ELSE
        localError="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_DATA_TYPE_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_DATA_TYPE_SET_AND_LOCK",err,error)
    RETURN 1
  END SUBROUTINE FIELD_DATA_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks the DOF order type for a field variable.
  SUBROUTINE FIELD_DOF_ORDER_TYPE_CHECK(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to check the DOF order type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_ORDER_TYPE !<The DOF order type of the field variable to check \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_DOF_ORDER_TYPE_CHECK",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    SELECT CASE(DOF_ORDER_TYPE)              
    CASE(FIELD_SEPARATED_COMPONENT_DOF_ORDER)
      IF(FIELD_VARIABLE%dofOrderType/=FIELD_SEPARATED_COMPONENT_DOF_ORDER) THEN
        localError="Invalid DOF order type. The DOF order type for variable type "// &
          & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD_VARIABLE%dataType,"*",err,error))// &
          & " which is not a separated component DOF order type."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER)
      IF(FIELD_VARIABLE%dofOrderType/=FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER) THEN
        localError="Invalid DOF order type. The DOF order type for variable type "// &
          & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD_VARIABLE%dataType,"*",err,error))// &
          & " which is not a contiguous component DOF order type."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE DEFAULT
      localError="The specified DOF order type of "//TRIM(NumberToVString(DOF_ORDER_TYPE,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FIELD_DOF_ORDER_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_DOF_ORDER_TYPE_CHECK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DOF_ORDER_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the DOF order type for a field variable. \see OpenCMISS::Iron::cmfe_Field_DOFOrderTypeGet
  SUBROUTINE FIELD_DOF_ORDER_TYPE_GET(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the DOF order type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: DOF_ORDER_TYPE !<On return, the DOF order type of the field variable \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_DOF_ORDER_TYPE_GET",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)

    DOF_ORDER_TYPE=FIELD_VARIABLE%dofOrderType

    EXITS("FIELD_DOF_ORDER_TYPE_GET")
    RETURN
999 ERRORSEXITS("FIELD_DOF_ORDER_TYPE_GET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DOF_ORDER_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable. Note: for contiguous component DOF ordering all the components of the field variable must have the same interpolation type.
  SUBROUTINE FIELD_DOF_ORDER_TYPE_SET(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the DOF order type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_ORDER_TYPE !<The DOF order type to set \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx
    LOGICAL :: SAME_INTERPOLATION,SAME_MESH_COMPONENT
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_DOF_ORDER_TYPE_SET",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    IF(ASSOCIATED(FIELD%createValuesCache)) THEN          
      IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN            
        IF(ANY(FIELD%createValuesCache%variableTypes==VARIABLE_TYPE)) THEN
          IF(FIELD%createValuesCache%dofOrderTypesLocked(VARIABLE_TYPE)) THEN
            localError="The DOF order type has been locked for variable type "// &
              & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
            CALL FlagError(localError,err,error,*999)
          ELSE
            SELECT CASE(DOF_ORDER_TYPE)                
            CASE(FIELD_SEPARATED_COMPONENT_DOF_ORDER)
              FIELD%createValuesCache%dofOrderTypes(VARIABLE_TYPE)=FIELD_SEPARATED_COMPONENT_DOF_ORDER
            CASE(FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER)
              SAME_INTERPOLATION=.TRUE.
              SAME_MESH_COMPONENT=.TRUE.
              DO component_idx=2,FIELD%createValuesCache%numberOfComponents(VARIABLE_TYPE)
                IF(FIELD%createValuesCache%interpolationTypes(component_idx,VARIABLE_TYPE)/= &
                  & FIELD%createValuesCache%interpolationTypes(1,VARIABLE_TYPE)) THEN
                  SAME_INTERPOLATION=.FALSE.
                  EXIT
                ENDIF
                IF(FIELD%createValuesCache%meshComponentNumber(component_idx,VARIABLE_TYPE)/= &
                  & FIELD%createValuesCache%meshComponentNumber(1,VARIABLE_TYPE)) THEN
                  SAME_MESH_COMPONENT=.FALSE.
                  EXIT
                ENDIF
              ENDDO !component_idx
              IF(SAME_INTERPOLATION.AND.SAME_MESH_COMPONENT) THEN
                FIELD%createValuesCache%dofOrderTypes(VARIABLE_TYPE)=FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER
              ELSE
                CALL FlagError("Invalid field variable component set. For continguous component DOF "// &
                  & "ordering the field variable components must have the same interpolation type and mesh components.", &
                  & err,error,*999)
              ENDIF
            CASE DEFAULT
              localError="The specified DOF order type of "//TRIM(NumberToVString(DOF_ORDER_TYPE,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ELSE
          localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field create values cache is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_DOF_ORDER_TYPE_SET")
    RETURN
999 ERRORSEXITS("FIELD_DOF_ORDER_TYPE_SET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DOF_ORDER_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable and locks it so that no further changes can be made.
  SUBROUTINE FIELD_DOF_ORDER_TYPE_SET_AND_LOCK(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the DOF order for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_ORDER_TYPE !<The DOF order type to set \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_DOF_ORDER_TYPE_SET_AND_LOCK",err,error,*999)

    CALL FIELD_DOF_ORDER_TYPE_SET(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,err,error,*999)
    IF(ASSOCIATED(FIELD%createValuesCache)) THEN
      FIELD%createValuesCache%dofOrderTypesLocked(VARIABLE_TYPE)=.TRUE.
    ELSE
      localError="Field create values cache is not associated for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_DOF_ORDER_TYPE_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_DOF_ORDER_TYPE_SET_AND_LOCK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DOF_ORDER_TYPE_SET_AND_LOCK

  !

  !================================================================================================================================
  !

  !>Finalises a field variable component and deallocates all memory.
  SUBROUTINE FIELD_VARIABLE_COMPONENT_FINALISE(FIELD_VARIABLE_COMPONENT,err,error,*)

    !Argument variables
    TYPE(FieldVariableComponentType) :: FIELD_VARIABLE_COMPONENT !<The field variable component to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_VARIABLE_COMPONENT_FINALISE",err,error,*999)

    FIELD_VARIABLE_COMPONENT%componentLabel=""
    CALL FieldVariableComponent_ParameterToDofMapFinalise(FIELD_VARIABLE_COMPONENT,err,error,*999)

    EXITS("FIELD_VARIABLE_COMPONENT_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_COMPONENT_FINALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_VARIABLE_COMPONENT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises a field variable component.
  SUBROUTINE FIELD_VARIABLE_COMPONENT_INITIALISE(FIELD_VARIABLE,COMPONENT_NUMBER,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE !<A pointer to the field variable to initialise the component for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: COMP_NUMBER,derivativeIdx,DUMMY_ERR,ne,VARIABLE_TYPE, NGP, MAXINTERP,globalElementNumber,nodeIdx,numParameters
    TYPE(BasisType), POINTER :: basis
    TYPE(DecompositionType), POINTER :: DECOMPOSITION
    TYPE(DecompositionDataPointsType), POINTER :: decompositionDataPoints
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: DOMAIN
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(FieldType), POINTER :: FIELD
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    ENTERS("FIELD_VARIABLE_COMPONENT_INITIALISE",err,error,*998)

    IF(.NOT.ASSOCIATED(FIELD_VARIABLE)) CALL FlagError("Field variable is not associated.",err,error,*998)
    CALL FieldVariable_AssertComponentNumberOK(FIELD_VARIABLE,COMPONENT_NUMBER,err,error,*998)

    NULLIFY(FIELD)
    CALL FieldVariable_FieldGet(FIELD_VARIABLE,FIELD,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    VARIABLE_TYPE=FIELD_VARIABLE%variableType
    CALL FieldVariable_AssertComponentNumberOK(FIELD_VARIABLE,COMPONENT_NUMBER,err,error,*999)
    FIELD_VARIABLE%components(COMPONENT_NUMBER)%componentNumber=COMPONENT_NUMBER
    FIELD_VARIABLE%components(COMPONENT_NUMBER)%fieldVariable=>FIELD_VARIABLE
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    COMP_NUMBER=createValuesCache%meshComponentNumber(COMPONENT_NUMBER,VARIABLE_TYPE)
    IF(COMP_NUMBER<1.OR.COMP_NUMBER>decomposition%numberOfComponents) THEN
      localError="The mesh component number of "//TRIM(NumberToVString(COMP_NUMBER,"*",err,error))// &
        & " for field component "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
        & " is invalid. The component number must be between 1 and "// &
        & TRIM(NumberToVString(decomposition%numberOfComponents,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    FIELD_VARIABLE%components(COMPONENT_NUMBER)%meshComponentNumber=COMP_NUMBER
    FIELD_VARIABLE%components(COMPONENT_NUMBER)%DOMAIN=>DECOMPOSITION%DOMAIN(COMP_NUMBER)%ptr
    FIELD_VARIABLE%components(COMPONENT_NUMBER)%componentLabel=""
    FIELD_VARIABLE%components(COMPONENT_NUMBER)%componentLabel= &
      & createValuesCache%componentLabels(COMPONENT_NUMBER,VARIABLE_TYPE)
    FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType= &
      createValuesCache%interpolationTypes(COMPONENT_NUMBER,VARIABLE_TYPE)
    NULLIFY(domain)
    CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,domain,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    NULLIFY(domainElements)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    NULLIFY(domainNodes)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    SELECT CASE(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=1
      FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=1
      FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=-1
      DO ne=1,domainelements%totalNumberOfElements
        NULLIFY(basis)
        CALL DomainElements_BasisGet(domainElements,ne,basis,err,error,*999)
        IF(BASIS%numberOfElementParameters>FIELD_VARIABLE%components(COMPONENT_NUMBER)% &
          & maxNumberElementInterpolationParameters) FIELD_VARIABLE%components(COMPONENT_NUMBER)% &
          & maxNumberElementInterpolationParameters=BASIS%numberOfElementParameters
      ENDDO !ne
      FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=-1
      DO nodeIdx=1,domainNodes%totalNumberOfNodes
        numParameters=0
        DO derivativeIdx=1,domainNodes%nodes(nodeIdx)%numberOfDerivatives
          numParameters=numParameters+domainNodes%nodes(nodeIdx)%DERIVATIVES(derivativeIdx)%numberOfVersions
        ENDDO !derivativeIdx
        IF(numParameters>FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters) &
          & FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=numParameters
      ENDDO !nodeIdx
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)             
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION) ! ?
      MAXINTERP = -1
      DO ne=1,domainElements%totalNumberOfElements
        NULLIFY(basis)
        CALL DomainElements_BasisGet(domainElements,ne,basis,err,error,*999)
        NGP = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%ptr%NUMBER_OF_GAUSS
        IF(NGP > MAXINTERP) MAXINTERP = NGP
      ENDDO
      FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters = MAXINTERP
      FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters = 0
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      NULLIFY(decomposition)
      CALL Domain_DecompositionGet(domain,decomposition,err,error,*999)
      NULLIFY(decompositionTopology)
      CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
      NULLIFY(decompositionElements)
      CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
      NULLIFY(decompositionDataPoints)
      CALL DecompositionTopology_DecompositionDataPointsGet(decompositionTopology,decompositionDataPoints,err,error,*999)
      FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=-1
      DO ne=1,domainElements%totalNumberOfElements
        globalElementNumber=decompositionElements%ELEMENTS(ne)%globalNumber
        IF(decompositionDataPoints%numberOfElementDataPoints(globalElementNumber)> &
          & FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters) THEN
          FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters= &
            &  decompositionDataPoints%numberOfElementDataPoints(globalElementNumber)
        ENDIF
      ENDDO
      FIELD_VARIABLE%components(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
    CASE DEFAULT
      localError="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
        & COMPONENTS(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
        & " for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is invalid."
    END SELECT
    CALL FieldVariableComponent_ParameterToDofMapInitialise(FIELD_VARIABLE%components(COMPONENT_NUMBER),err,error,*999)

    EXITS("FIELD_VARIABLE_COMPONENT_INITIALISE")
    RETURN
999 CALL FIELD_VARIABLE_COMPONENT_FINALISE(FIELD_VARIABLE%components(COMPONENT_NUMBER),DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_VARIABLE_COMPONENT_INITIALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_VARIABLE_COMPONENT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises a field variable component parameter to dof map and deallocates all memory.
  SUBROUTINE FieldVariableComponent_ParameterToDofMapFinalise(FIELD_VARIABLE_COMPONENT,err,error,*)

    !Argument variables
    TYPE(FieldVariableComponentType) :: FIELD_VARIABLE_COMPONENT !<The field variable component to finialise the parameter to dof map for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariableComponent_ParameterToDofMapFinalise",err,error,*999)

    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%paramToDOFMap%nodeParam2DOFMap%NODES))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%paramToDOFMap%nodeParam2DOFMap%NODES)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%paramToDOFMap%elementParam2DOFMap%ELEMENTS))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%paramToDOFMap%elementParam2DOFMap%ELEMENTS)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%paramToDOFMap%gridPointParam2DOFMap%gridPoints))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%paramToDOFMap%gridPointParam2DOFMap%gridPoints)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%paramToDOFMap%dataPointParam2DOFMap%dataPoints))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%paramToDOFMap%dataPointParam2DOFMap%dataPoints)
    FIELD_VARIABLE_COMPONENT%paramToDOFMap%numberOfConstantParameters=0
    FIELD_VARIABLE_COMPONENT%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters=0
    FIELD_VARIABLE_COMPONENT%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters=0
    FIELD_VARIABLE_COMPONENT%paramToDOFMap%gridPointParam2DOFMap%numberOfGridPointParameters=0
    FIELD_VARIABLE_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters=0
    FIELD_VARIABLE_COMPONENT%paramToDOFMap%dataPointParam2DOFMap%numberOfDataPointParameters=0

    EXITS("FieldVariableComponent_ParameterToDofMapFinalise")
    RETURN
999 ERRORS("FieldVariableComponent_ParameterToDofMapFinalise",err,error)
    EXITS("FieldVariableComponent_ParameterToDofMapFinalise")
    RETURN 1

  END SUBROUTINE FieldVariableComponent_ParameterToDofMapFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a field variable component parameter to dof map.
  SUBROUTINE FieldVariableComponent_ParameterToDofMapInitialise(FIELD_VARIABLE_COMPONENT,err,error,*)

    !Argument variables
    TYPE(FieldVariableComponentType) :: FIELD_VARIABLE_COMPONENT !<The field variable component to initialise the parameter to dof map for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FieldVariableComponent_ParameterToDofMapInitialise",err,error,*999)

    FIELD_VARIABLE_COMPONENT%paramToDOFMap%numberOfConstantParameters=0
    FIELD_VARIABLE_COMPONENT%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters=0
    FIELD_VARIABLE_COMPONENT%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters=0
    FIELD_VARIABLE_COMPONENT%paramToDOFMap%gridPointParam2DOFMap%numberOfGridPointParameters=0
    FIELD_VARIABLE_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters=0
    FIELD_VARIABLE_COMPONENT%paramToDOFMap%dataPointParam2DOFMap%numberOfDataPointParameters=0

    EXITS("FieldVariableComponent_ParameterToDofMapInitialise")
    RETURN
999 ERRORS("FieldVariableComponent_ParameterToDofMapInitialise",err,error)
    EXITS("FieldVariableComponent_ParameterToDofMapInitialise")
    RETURN 1

  END SUBROUTINE FieldVariableComponent_ParameterToDofMapInitialise

  !
  !================================================================================================================================
  !

  !>Finalises the field variable components for a field variable and deallocates all memory.
  SUBROUTINE FIELD_VARIABLE_COMPONENTS_FINALISE(FIELD_VARIABLE,err,error,*)

    !Argument variables
    TYPE(FieldVariableType) :: FIELD_VARIABLE !<The field variable to finalise the field variable components for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx

    ENTERS("FIELD_VARIABLE_COMPONENTS_FINALISE",err,error,*999)

    IF(ALLOCATED(FIELD_VARIABLE%COMPONENTS)) THEN
      DO component_idx=1,SIZE(FIELD_VARIABLE%COMPONENTS,1)
        CALL FIELD_VARIABLE_COMPONENT_FINALISE(FIELD_VARIABLE%components(component_idx),err,error,*999)
      ENDDO !component_idx
      DEALLOCATE(FIELD_VARIABLE%COMPONENTS)
    ENDIF
    FIELD_VARIABLE%numberOfComponents=0

    EXITS("FIELD_VARIABLE_COMPONENTS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_COMPONENTS_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_COMPONENTS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the field components.
  SUBROUTINE FIELD_VARIABLE_COMPONENTS_INITIALISE(FIELD,VARIABLE_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the field variable components for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to initialise the field variable components for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,dummyErr
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache 
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("FIELD_VARIABLE_COMPONENTS_INITIALISE",err,error,*998)

    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*998)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*998)
    IF(ALLOCATED(FIELD_VARIABLE%COMPONENTS)) CALL FlagError("Field variable already has allocated components.",err,error,*998)

    ALLOCATE(FIELD_VARIABLE%components(FIELD_VARIABLE%numberOfComponents),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate field variable components.",err,error,*999)
    DO component_idx=1,FIELD_VARIABLE%numberOfComponents
      CALL FIELD_VARIABLE_COMPONENT_INITIALISE(FIELD_VARIABLE,component_idx,err,error,*999)
    ENDDO !component_idx

    EXITS("FIELD_VARIABLE_COMPONENTS_INITIALISE")
    RETURN
999 CALL FIELD_VARIABLE_COMPONENTS_FINALISE(FIELD_VARIABLE,dummyErr,dummyError,*998)
998 ERRORSEXITS("FIELD_VARIABLE_COMPONENTS_INITIALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_VARIABLE_COMPONENTS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field. \see OpenCMISS::Iron::cmfe_Field_CreateFinish
  SUBROUTINE FIELD_CREATE_FINISH(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,parameterSetIdx,scalingIdx,variableIdx
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: geometricField

    ENTERS("FIELD_CREATE_FINISH",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    !Check field has a decomposition associated
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    !Check for field validity
    CALL FieldVariablesCheck(field,err,error,*999)
    !Initialise the components
    CALL FIELD_VARIABLES_INITIALISE(FIELD,err,error,*999)
    !Check geometric field
    NULLIFY(geometricField)
    CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
    CALL FIELD_CREATE_VALUES_CACHE_FINALISE(FIELD%createValuesCache,err,error,*999)
    FIELD%fieldFinished=.TRUE.
    !Calculate dof mappings
    CALL FIELD_MAPPINGS_CALCULATE(FIELD,err,error,*999)
    !Set up the geometric parameters
    CALL FIELD_GEOMETRIC_PARAMETERS_INITIALISE(FIELD,err,error,*999)
    !Initialise the scalings
    CALL FIELD_SCALINGS_INITIALISE(FIELD,err,error,*999)
    !Initialise the field parameter sets 
    CALL FIELD_PARAMETER_SETS_INITIALISE(FIELD,err,error,*999)

    IF(DIAGNOSTICS1) THEN
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"",FIELD%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"Field number : ",FIELD%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Global number = ",FIELD%globalNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  User number = ",FIELD%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Label = ",FIELD%LABEL,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Dependent type = ",FIELD%DEPENDENT_TYPE,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field type = ",FIELD%TYPE,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of variables = ",FIELD%numberOfVariables,err,error,*999)
      IF(DIAGNOSTICS2) THEN
        DO variableIdx=1,FIELD%numberOfVariables
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Variable : ",variableIdx,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Variable Type = ",variableIdx,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Variable Label = ",FIELD%variables(variableIdx)%variableLabel, &
            & err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Dimension = ",FIELD%variables(variableIdx)%DIMENSION, &
            & err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Data type = ",FIELD%variables(variableIdx)%dataType, &
            & err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      DOF order type = ",FIELD%variables(variableIdx)%dofOrderType, &
            & err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Max num element interpolation parameters = ",FIELD% &
            & VARIABLES(variableIdx)%maxNumberElementInterpolationParameters,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Max num node interpolation parameters = ",FIELD% &
            & VARIABLES(variableIdx)%maxNumberNodeInterpolationParameters,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of DOFs = ",FIELD%variables(variableIdx)% &
            & numberOfDofs,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Total number of DOFs = ",FIELD%variables(variableIdx)% &
            & totalNumberOfDofs,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of global DOFs = ",FIELD%variables(variableIdx)% &
            & numberOfGlobalDofs,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of components = ",FIELD%variables(variableIdx)% &
            & numberOfComponents,err,error,*999)
          IF(DIAGNOSTICS3) THEN
            DO componentIdx=1,FIELD%variables(variableIdx)%numberOfComponents
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Component : ",componentIdx,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Component label = ",FIELD%variables(variableIdx)% &
                COMPONENTS(componentIdx)%componentLabel,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Interpolation type = ",FIELD%variables(variableIdx)% &
                COMPONENTS(componentIdx)%interpolationType,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Mesh component number = ",FIELD%variables(variableIdx)% &
                COMPONENTS(componentIdx)%meshComponentNumber,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Scaling index = ",FIELD%variables(variableIdx)% &
                COMPONENTS(componentIdx)%scalingIndex,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Max num element interpolation parameters = ",FIELD% &
                & VARIABLES(variableIdx)%components(componentIdx)%maxNumberElementInterpolationParameters,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Max num node interpolation parameters = ",FIELD% &
                & VARIABLES(variableIdx)%components(componentIdx)%maxNumberNodeInterpolationParameters,err,error,*999)         
            ENDDO !componentIdx
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameter sets = ",FIELD%variables(variableIdx)% &
            & parameterSets%numberOfParameterSets,err,error,*999)
          IF(DIAGNOSTICS3) THEN
            DO parameterSetIdx=1,FIELD%variables(variableIdx)%parameterSets%numberOfParameterSets
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Parameter set index : ",parameterSetIdx,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Set type : ",FIELD%variables(variableIdx)% &
                & parameterSets%parameterSets(parameterSetIdx)%ptr%setType,err,error,*999)
            ENDDO !parameterSetIdx
          ENDIF
        ENDDO !variableIdx
      ENDIF
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Scaling type = ",FIELD%SCALINGS%scalingType,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of scaling indices = ",FIELD%SCALINGS%numberOfScalingIndices, &
        & err,error,*999)
      IF(DIAGNOSTICS2) THEN
        DO scalingIdx=1,FIELD%SCALINGS%numberOfScalingIndices
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Scaling index : ",scalingIdx,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Mesh component number : ",FIELD%SCALINGS%SCALINGS(scalingIdx)% &
            & meshComponentNumber,err,error,*999)
        ENDDO !scalingIdx
      ENDIF
    ENDIF

    EXITS("FIELD_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("FIELD_CREATE_FINISH",err,error)
    RETURN 1

  END SUBROUTINE FIELD_CREATE_FINISH

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field.
  SUBROUTINE FIELD_CREATE_START_GENERIC(FIELDS,USER_NUMBER,FIELD,err,error,*)

    !Argument variables
    TYPE(FieldsType), POINTER :: FIELDS !<A pointer to the fields
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number for the field to create
    TYPE(FieldType), POINTER :: FIELD !<On return, a pointer to the field. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: field_no
    TYPE(FieldType), POINTER :: NEW_FIELD
    TYPE(FieldPtrType), POINTER :: NEW_FIELDS(:)

    NULLIFY(NEW_FIELD)
    NULLIFY(NEW_FIELDS)

    ENTERS("FIELD_CREATE_START_GENERIC",err,error,*998)

    IF(ASSOCIATED(FIELDS)) THEN
      IF(ASSOCIATED(FIELD)) THEN
        CALL FlagError("Field is already associated.",err,error,*998)
      ELSE
        !Set default field properties
        CALL FIELD_INITIALISE(NEW_FIELD,err,error,*999)
        NEW_FIELD%globalNumber=FIELDS%numberOfFields+1
        NEW_FIELD%userNumber=USER_NUMBER
        NEW_FIELD%LABEL="Field "//TRIM(NumberToVString(USER_NUMBER,"*",err,error))
        IF(err/=0) GOTO 999
        NEW_FIELD%FIELDS=>FIELDS
        NULLIFY(NEW_FIELD%REGION)
        NULLIFY(NEW_FIELD%INTERFACE)
        NEW_FIELD%geometricField=>NEW_FIELD
        NEW_FIELD%numberOfVariables=1
        NEW_FIELD%SCALINGS%scalingType=FIELD_ARITHMETIC_MEAN_SCALING
        NEW_FIELD%SCALINGS%numberOfScalingIndices=0
        NULLIFY(NEW_FIELD%createValuesCache)
        !Add new field into list of fields 
        ALLOCATE(NEW_FIELDS(FIELDS%numberOfFields+1),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new fields.",err,error,*999)
        DO field_no=1,FIELDS%numberOfFields
          NEW_FIELDS(field_no)%ptr=>FIELDS%FIELDS(field_no)%ptr
        ENDDO !field_no
        NEW_FIELDS(FIELDS%numberOfFields+1)%ptr=>NEW_FIELD
        IF(ASSOCIATED(FIELDS%FIELDS)) DEALLOCATE(FIELDS%FIELDS)
        FIELDS%FIELDS=>NEW_FIELDS
        FIELDS%numberOfFields=FIELDS%numberOfFields+1
        FIELD=>NEW_FIELD
      ENDIF
    ELSE
      CALL FlagError("Fields is not associated.",err,error,*998)
    ENDIF

    EXITS("FIELD_CREATE_START_GENERIC")
    RETURN
999 IF(ASSOCIATED(NEW_FIELD)) DEALLOCATE(NEW_FIELD)
    IF(ASSOCIATED(NEW_FIELDS)) DEALLOCATE(NEW_FIELDS)
    NULLIFY(FIELD)
998 ERRORSEXITS("FIELD_CREATE_START_GENERIC",err,error)
    RETURN 1

  END SUBROUTINE FIELD_CREATE_START_GENERIC

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field defined by a user number in the specified interface. \see OpenCMISS::Iron::cmfe_FieldCreateStart
  !>Default values set for the FIELD's attributes are:
  !>- DEPENDENT_TYPE: 1 (FIELD_INDEPENDENT_TYPE)
  !>- DIMENSION: 2 (FIELD_VECTOR_DIMENSION_TYPE)
  !>- TYPE: 1 (FIELD_GEOMETRIC_TYPE)
  !>- NUMBER_OF_VARIABLES: 1
  !>- GEOMETRIC_FIELD: itself
  !>- SCALINGS%scalingType: 3 (FIELD_ARITHMETIC_MEAN_SCALING)
  !>\todo Add in FIELD_INITIALISE
  SUBROUTINE FIELD_CREATE_START_INTERFACE(USER_NUMBER,INTERFACE,FIELD,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number for the field
    TYPE(InterfaceType), POINTER :: INTERFACE !<A pointer to the interface in which to create the field
    TYPE(FieldType), POINTER :: FIELD !<On return, a pointer to the field being created. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError    

    ENTERS("FIELD_CREATE_START_INTERFACE",err,error,*999)

    IF(ASSOCIATED(INTERFACE)) THEN
      IF(ASSOCIATED(FIELD)) THEN
        CALL FlagError("Field is already associated.",err,error,*999)
      ELSE
        NULLIFY(FIELD)
        CALL FIELD_USER_NUMBER_FIND(USER_NUMBER,INTERFACE,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          localError="Field number "//TRIM(NumberToVString(USER_NUMBER,"*",err,error))// &
            & " has already been created on interface number "//TRIM(NumberToVString(INTERFACE%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ELSE
          CALL FIELD_CREATE_START_GENERIC(INTERFACE%FIELDS,USER_NUMBER,FIELD,err,error,*999)
          FIELD%INTERFACE=>INTERFACE
          CALL FIELD_CREATE_VALUES_CACHE_INITIALISE(FIELD,err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Interface is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_CREATE_START_INTERFACE")
    RETURN
999 ERRORSEXITS("FIELD_CREATE_START_INTERFACE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_CREATE_START_INTERFACE

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field defined by a user number in the specified region. \see OpenCMISS::Iron::cmfe_FieldCreateStart
  !>Default values set for the FIELD's attributes are:
  !>- DEPENDENT_TYPE: 1 (FIELD_INDEPENDENT_TYPE)
  !>- DIMENSION: 2 (FIELD_VECTOR_DIMENSION_TYPE)
  !>- TYPE: 1 (FIELD_GEOMETRIC_TYPE)
  !>- NUMBER_OF_VARIABLES: 1
  !>- GEOMETRIC_FIELD: itself
  !>- SCALINGS%scalingType: 3 (FIELD_ARITHMETIC_MEAN_SCALING)
  !>\todo Add in FIELD_INITIALISE
  SUBROUTINE FIELD_CREATE_START_REGION(USER_NUMBER,REGION,FIELD,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number for the field
    TYPE(RegionType), POINTER :: REGION !<A pointer to the region in which to create the field
    TYPE(FieldType), POINTER :: FIELD !<On return, a pointer to the field being created
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_CREATE_START_REGION",err,error,*999)

    IF(ASSOCIATED(REGION)) THEN
      IF(ASSOCIATED(FIELD)) THEN
        CALL FlagError("Field is already associated.",err,error,*999)
      ELSE
        NULLIFY(FIELD)
        CALL FIELD_USER_NUMBER_FIND(USER_NUMBER,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          localError="Field number "//TRIM(NumberToVString(USER_NUMBER,"*",err,error))// &
            & " has already been created on region number "//TRIM(NumberToVString(REGION%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ELSE
          CALL FIELD_CREATE_START_GENERIC(REGION%FIELDS,USER_NUMBER,FIELD,err,error,*999)
          FIELD%REGION=>REGION
          CALL FIELD_CREATE_VALUES_CACHE_INITIALISE(FIELD,err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Region is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_CREATE_START_REGION")
    RETURN
999 ERRORSEXITS("FIELD_CREATE_START_REGION",err,error)
    RETURN 1

  END SUBROUTINE FIELD_CREATE_START_REGION

  !
  !================================================================================================================================
  !

  !>Finalise the create values cache for a field.
  SUBROUTINE FIELD_CREATE_VALUES_CACHE_FINALISE(CREATE_VALUES_CACHE,err,error,*)

    !Argument variables
    TYPE(FieldCreateValuesCacheType), POINTER :: CREATE_VALUES_CACHE !<A pointer to the create values cache to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,variable_idx

    ENTERS("FIELD_CREATE_VALUES_CACHE_FINALISE",err,error,*999)

    IF(ASSOCIATED(CREATE_VALUES_CACHE)) THEN
      IF(ALLOCATED(CREATE_VALUES_CACHE%variableTypes)) DEALLOCATE(CREATE_VALUES_CACHE%variableTypes)
      IF(ALLOCATED(CREATE_VALUES_CACHE%variableLabels)) THEN
        DO variable_idx=1,SIZE(CREATE_VALUES_CACHE%variableLabels,1)
          CREATE_VALUES_CACHE%variableLabels(variable_idx)=""
        ENDDO !variable_idx
        DEALLOCATE(CREATE_VALUES_CACHE%variableLabels)
      ENDIF
      IF(ALLOCATED(CREATE_VALUES_CACHE%variableLabelsLocked)) DEALLOCATE(CREATE_VALUES_CACHE%variableLabelsLocked)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DIMENSION)) DEALLOCATE(CREATE_VALUES_CACHE%DIMENSION)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DIMENSION_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%DIMENSION_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%dataTypes)) DEALLOCATE(CREATE_VALUES_CACHE%dataTypes)
      IF(ALLOCATED(CREATE_VALUES_CACHE%dataTypesLocked)) DEALLOCATE(CREATE_VALUES_CACHE%dataTypesLocked)
      IF(ALLOCATED(CREATE_VALUES_CACHE%dofOrderTypes)) DEALLOCATE(CREATE_VALUES_CACHE%dofOrderTypes)
      IF(ALLOCATED(CREATE_VALUES_CACHE%dofOrderTypesLocked)) DEALLOCATE(CREATE_VALUES_CACHE%dofOrderTypesLocked)
      IF(ALLOCATED(CREATE_VALUES_CACHE%numberOfComponents)) DEALLOCATE(CREATE_VALUES_CACHE%numberOfComponents)
      IF(ALLOCATED(CREATE_VALUES_CACHE%numberOfComponentsLocked)) DEALLOCATE(CREATE_VALUES_CACHE%numberOfComponentsLocked)
      IF(ALLOCATED(CREATE_VALUES_CACHE%componentLabels)) THEN
        DO variable_idx=1,SIZE(CREATE_VALUES_CACHE%componentLabels,2)
          DO component_idx=1,SIZE(CREATE_VALUES_CACHE%componentLabels,1)
            CREATE_VALUES_CACHE%componentLabels(component_idx,variable_idx)=""
          ENDDO !component_idx
        ENDDO !variable_idx
        DEALLOCATE(CREATE_VALUES_CACHE%componentLabels)
      ENDIF
      IF(ALLOCATED(CREATE_VALUES_CACHE%componentLabelsLocked)) DEALLOCATE(CREATE_VALUES_CACHE%componentLabelsLocked)
      IF(ALLOCATED(CREATE_VALUES_CACHE%interpolationTypes)) DEALLOCATE(CREATE_VALUES_CACHE%interpolationTypes)
      IF(ALLOCATED(CREATE_VALUES_CACHE%interpolationTypesLocked)) DEALLOCATE(CREATE_VALUES_CACHE%interpolationTypesLocked)
      IF(ALLOCATED(CREATE_VALUES_CACHE%meshComponentNumber)) DEALLOCATE(CREATE_VALUES_CACHE%meshComponentNumber)
      IF(ALLOCATED(CREATE_VALUES_CACHE%meshComponentNumberLocked)) DEALLOCATE(CREATE_VALUES_CACHE%meshComponentNumberLocked)
      DEALLOCATE(CREATE_VALUES_CACHE)
    ENDIF

    EXITS("FIELD_CREATE_VALUES_CACHE_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_CREATE_VALUES_CACHE_FINALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_CREATE_VALUES_CACHE_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the create values cache for a field.
  SUBROUTINE FIELD_CREATE_VALUES_CACHE_INITIALISE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the create values cache for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    INTEGER(INTG) :: DUMMY_ERR,NUMBER_OF_COMPONENTS,component_idx,variable_idx
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    ENTERS("FIELD_CREATE_VALUES_CACHE_INITIALISE",err,error,*998)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%createValuesCache)) THEN
        CALL FlagError("Create values cache is already associated.",err,error,*998)
      ELSE
        ALLOCATE(FIELD%createValuesCache,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate create values cache.",err,error,*999)
        SELECT CASE(FIELD%TYPE)
        CASE(FIELD_GEOMETRIC_TYPE,FIELD_FIBRE_TYPE,FIELD_GEOMETRIC_GENERAL_TYPE)
          NULLIFY(COORDINATE_SYSTEM)
          CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,err,error,*999)
          NUMBER_OF_COMPONENTS=COORDINATE_SYSTEM%numberOfDimensions
        CASE(FIELD_GENERAL_TYPE,FIELD_MATERIAL_TYPE)
          NUMBER_OF_COMPONENTS=1
        CASE DEFAULT
          localError="The field type of "//TRIM(NumberToVString(FIELD%TYPE,"*",err,error))//" is invalid for field number "// &
            & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
        ALLOCATE(FIELD%createValuesCache%variableTypes(FIELD%numberOfVariables),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache variable types.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%variableLabels(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache variable labels.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%variableLabelsLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache variable labels locked.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%DIMENSION(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache dimension.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%DIMENSION_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache dimension locked.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%dataTypes(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache data types.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%dataTypesLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache data types locked.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%dofOrderTypes(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache DOF order types.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%dofOrderTypesLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache DOF order types locked.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%numberOfComponents(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache number of components.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%numberOfComponentsLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache number of components locked.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%componentLabels(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache component labels.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%componentLabelsLocked(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache component labels locked.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%interpolationTypes(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache interpolation type.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%interpolationTypesLocked(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache interpolation type locked.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%meshComponentNumber(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache mesh component type.",err,error,*999)
        ALLOCATE(FIELD%createValuesCache%meshComponentNumberLocked(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES), &
          & STAT=err)
        IF(err/=0) CALL FlagError("Could not allocated create values cache mesh component type locked.",err,error,*999)
        FIELD%createValuesCache%LABEL_LOCKED=.FALSE.
        FIELD%createValuesCache%DECOMPOSITION_LOCKED=.FALSE.
        FIELD%createValuesCache%DEPENDENT_TYPE_LOCKED=.FALSE.
        FIELD%createValuesCache%DIMENSION_LOCKED=.FALSE.
        FIELD%createValuesCache%numberOfVariablesLocked=.FALSE.
        FIELD%createValuesCache%geometricFieldLocked=.FALSE.
        FIELD%createValuesCache%scalingTypeLocked=.FALSE.
        FIELD%createValuesCache%TYPE_LOCKED=.FALSE.
        FIELD%createValuesCache%variableTypes=0
        FIELD%createValuesCache%variableTypesLocked=.FALSE.
        FIELD%createValuesCache%variableLabels=""
        FIELD%createValuesCache%variableLabelsLocked=.FALSE.
        FIELD%createValuesCache%DIMENSION=0
        FIELD%createValuesCache%DIMENSION_LOCKED=.FALSE.
        FIELD%createValuesCache%dataTypes=0
        FIELD%createValuesCache%dataTypesLocked=.FALSE.
        FIELD%createValuesCache%dofOrderTypes=0
        FIELD%createValuesCache%dofOrderTypesLocked=.FALSE.
        FIELD%createValuesCache%numberOfComponents=0
        FIELD%createValuesCache%numberOfComponentsLocked=.FALSE.
        FIELD%createValuesCache%componentLabels=""
        FIELD%createValuesCache%componentLabelsLocked=.FALSE.
        FIELD%createValuesCache%interpolationTypes=0
        FIELD%createValuesCache%interpolationTypesLocked=.FALSE.
        FIELD%createValuesCache%meshComponentNumber=0
        FIELD%createValuesCache%meshComponentNumberLocked=.FALSE.
        FIELD%createValuesCache%DataProjectionLocked=.FALSE.
        DO variable_idx=1,FIELD%numberOfVariables
          FIELD%createValuesCache%variableTypes(variable_idx)=variable_idx
          SELECT CASE(variable_idx)
          CASE(FIELD_U_VARIABLE_TYPE)
            SELECT CASE(FIELD%TYPE)
            CASE(FIELD_GEOMETRIC_TYPE)
              FIELD%createValuesCache%variableLabels(variable_idx)="Coordinate"
            CASE(FIELD_FIBRE_TYPE)
              FIELD%createValuesCache%variableLabels(variable_idx)="Fibre"
            CASE(FIELD_MATERIAL_TYPE)
              FIELD%createValuesCache%variableLabels(variable_idx)="Material"              
            CASE(FIELD_GENERAL_TYPE)
              FIELD%createValuesCache%variableLabels(variable_idx)="U"
            CASE(FIELD_GEOMETRIC_GENERAL_TYPE)
              FIELD%createValuesCache%variableLabels(variable_idx)="U"
            CASE DEFAULT
              localError="The field type of "//TRIM(NumberToVString(FIELD%TYPE,"*",err,error))// &
                & " is invalid for field number "// &
                & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          CASE(FIELD_DELUDELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U/del n"
          CASE(FIELD_DELUDELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U/del t"
          CASE(FIELD_DEL2UDELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 U/del t^2"
          CASE(FIELD_V_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="V"
          CASE(FIELD_DELVDELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del V/del n"
          CASE(FIELD_DELVDELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del V/del t"
          CASE(FIELD_DEL2VDELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 V/del t^2"
          CASE(FIELD_U1_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="U1"
          CASE(FIELD_DELU1DELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U1/del n"
          CASE(FIELD_DELU1DELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U1/del t"
          CASE(FIELD_DEL2U1DELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 U1/del t^2"
          CASE(FIELD_U2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="U2"
          CASE(FIELD_DELU2DELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U2/del n"
          CASE(FIELD_DELU2DELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U2/del t"
          CASE(FIELD_DEL2U2DELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 U2/del t^2"
          CASE(FIELD_U3_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="U3"
          CASE(FIELD_DELU3DELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U3/del n"
          CASE(FIELD_DELU3DELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U3/del t"
          CASE(FIELD_DEL2U3DELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 U3/del t^2"
          CASE(FIELD_U4_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="U4"
          CASE(FIELD_DELU4DELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U4/del n"
          CASE(FIELD_DELU4DELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U4/del t"
          CASE(FIELD_DEL2U4DELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 U4/del t^2"
          CASE(FIELD_U5_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="U5"
          CASE(FIELD_DELU5DELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U5/del n"
          CASE(FIELD_DELU5DELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U5/del t"
          CASE(FIELD_DEL2U5DELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 U5/del t^2"
          CASE(FIELD_U6_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="U6"
          CASE(FIELD_DELU6DELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U6/del n"
          CASE(FIELD_DELU6DELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U6/del t"
          CASE(FIELD_DEL2U6DELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 U6/del t^2"
          CASE(FIELD_U7_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="U7"
          CASE(FIELD_DELU7DELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U7/del n"
          CASE(FIELD_DELU7DELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U7/del t"
          CASE(FIELD_DEL2U7DELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 U7/del t^2"
          CASE(FIELD_U8_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="U8"
          CASE(FIELD_DELU8DELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U8/del n"
          CASE(FIELD_DELU8DELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U8/del t"
          CASE(FIELD_DEL2U8DELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 U8/del t^2"
          CASE(FIELD_U9_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="U9"
          CASE(FIELD_DELU9DELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U9/del n"
          CASE(FIELD_DELU9DELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U9/del t"
          CASE(FIELD_DEL2U9DELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 U/9del t^2"
          CASE(FIELD_U10_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="U10"
          CASE(FIELD_DELU10DELN_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U10/del n"
          CASE(FIELD_DELU10DELT_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del U10/del t"
          CASE(FIELD_DEL2U10DELT2_VARIABLE_TYPE)
            FIELD%createValuesCache%variableLabels(variable_idx)="del^2 U10/del t^2"
          CASE DEFAULT
            localError="The variable type of "//TRIM(NumberToVString(variable_idx,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
          FIELD%createValuesCache%DIMENSION(variable_idx)=FIELD_VECTOR_DIMENSION_TYPE
          FIELD%createValuesCache%dataTypes(variable_idx)=FIELD_DP_TYPE
          FIELD%createValuesCache%dofOrderTypes(variable_idx)=FIELD_SEPARATED_COMPONENT_DOF_ORDER
          FIELD%createValuesCache%numberOfComponents(variable_idx)=NUMBER_OF_COMPONENTS
          DO component_idx=1,NUMBER_OF_COMPONENTS
            FIELD%createValuesCache%componentLabels(component_idx,variable_idx)= &
              & TRIM(NumberToVString(component_idx,"*",err,error))
            IF(err/=0) GOTO 999
            FIELD%createValuesCache%interpolationTypes(component_idx,variable_idx)=FIELD_NODE_BASED_INTERPOLATION
            FIELD%createValuesCache%meshComponentNumber(component_idx,variable_idx)=1
          ENDDO !component_idx
        ENDDO !variable_idx
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*998)
    ENDIF

    EXITS("FIELD_CREATE_VALUES_CACHE_INITIALISE")
    RETURN
999 CALL FIELD_CREATE_VALUES_CACHE_FINALISE(FIELD%createValuesCache,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_CREATE_VALUES_CACHE_INITIALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_CREATE_VALUES_CACHE_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets a geometric general field for a field if there is any (eg. the dependent field for a finite elasticity equation),
  !>otherwise the normal geometric field is returned if present.
  !>If no geometric field is found then an error is raised.
  SUBROUTINE Field_GeometricGeneralFieldGet(field,geometricField,generalFound,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER, INTENT(IN) :: field !<A pointer to the field to get the geometric field for
    TYPE(FieldType), POINTER, INTENT(OUT) :: geometricField !<On return, a pointer to the geometric field. Must not be associated on entry.
    LOGICAL, INTENT(OUT) :: generalFound !<On return, true if we found a geometric general field, otherwise false.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: fieldIdx
    TYPE(FieldType), POINTER :: otherField
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_GeometricGeneralFieldGet",err,error,*999)

    NULLIFY(geometricField)

    ! Check input parameters
    IF(ASSOCIATED(field)) THEN
      IF(field%fieldFinished) THEN
        IF(.NOT.ASSOCIATED(field%fields)) THEN
          CALL FlagError("Field fields are not associated.",err,error,*999)
        END IF
      ELSE
        localError="Field number "//TRIM(number_to_vstring(field%userNumber,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    END IF
    IF(ASSOCIATED(geometricField)) THEN
      CALL FlagError("Geometric field is already associated.",err,error,*999)
    END IF

    generalFound=.FALSE.
    ! Find the geometric general field associated with this field
    DO fieldIdx=1,field%fields%numberOfFields
      otherField=>field%fields%fields(fieldIdx)%ptr
      IF(ASSOCIATED(otherField)) THEN
        IF(otherField%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          geometricField=>otherField
          generalFound=.TRUE.
        END IF
      ELSE
        CALL FlagError("Field number "//TRIM(number_to_vstring(fieldIdx,"*",err,error))// &
          & " is not associated.",err,error,*999)
      END IF
    END DO

    IF(.NOT.generalFound) THEN
      ! We couldn't find a geometric general field.
      ! Just return the undeformed geometric field.
      IF(ASSOCIATED(field%geometricField)) THEN
        geometricField=>field%geometricField
      ELSE
        CALL FlagError("Geometric general field not found and geometric field is not associated.",err,error,*999)
      END IF
    END IF

    EXITS("Field_GeometricGeneralFieldGet")
    RETURN
999 ERRORSEXITS("Field_GeometricGeneralFieldGet",err,error)
    RETURN 1

  END SUBROUTINE Field_GeometricGeneralFieldGet

  !
  !================================================================================================================================
  !

  !>Checks the dependent type for a field.
  SUBROUTINE FIELD_DEPENDENT_TYPE_CHECK(FIELD,DEPENDENT_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to check the dependent type for
    INTEGER(INTG), INTENT(IN) :: DEPENDENT_TYPE !<The dependent type to check \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_DEPENDENT_TYPE_CHECK",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    SELECT CASE(DEPENDENT_TYPE)
    CASE(FIELD_INDEPENDENT_TYPE)
      IF(FIELD%DEPENDENT_TYPE/=FIELD_INDEPENDENT_TYPE) THEN
        localError="Invalid dependent type. The dependent type of field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD%DEPENDENT_TYPE,"*",err,error))// &
          & " which is not an independent field."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_DEPENDENT_TYPE)
      IF(FIELD%DEPENDENT_TYPE/=FIELD_DEPENDENT_TYPE) THEN
        localError="Invalid dependent type. The dependent type of field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD%DEPENDENT_TYPE,"*",err,error))// &
          & " which is not a dependent field."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE DEFAULT
      localError="The specified dependent type of "//TRIM(NumberToVString(DEPENDENT_TYPE,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FIELD_DEPENDENT_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_DEPENDENT_TYPE_CHECK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DEPENDENT_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the dependent type for a field. \see OpenCMISS::Iron::cmfe_Field_DependentTypeGet
  SUBROUTINE FIELD_DEPENDENT_TYPE_GET(FIELD,DEPENDENT_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the dependent type for
    INTEGER(INTG), INTENT(OUT) :: DEPENDENT_TYPE !<On return, the dependent type to get \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_DEPENDENT_TYPE_GET",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)

    DEPENDENT_TYPE=FIELD%DEPENDENT_TYPE

    EXITS("FIELD_DEPENDENT_TYPE_GET")
    RETURN
999 ERRORSEXITS("FIELD_DEPENDENT_TYPE_GET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DEPENDENT_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field. \see OpenCMISS::Iron::cmfe_Field_DependentTypeSet
  SUBROUTINE FIELD_DEPENDENT_TYPE_SET(FIELD,DEPENDENT_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the dependent type for
    INTEGER(INTG), INTENT(IN) :: DEPENDENT_TYPE !<The dependent type to set/change \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_DEPENDENT_TYPE_SET",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%DEPENDENT_TYPE_LOCKED) THEN
      localError="The dependent type has been locked for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    SELECT CASE(DEPENDENT_TYPE)
    CASE(FIELD_INDEPENDENT_TYPE)
      FIELD%DEPENDENT_TYPE=FIELD_INDEPENDENT_TYPE
    CASE(FIELD_DEPENDENT_TYPE)
      FIELD%DEPENDENT_TYPE=FIELD_DEPENDENT_TYPE
    CASE DEFAULT
      localError="The supplied dependent type of "//TRIM(NumberToVString(DEPENDENT_TYPE,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FIELD_DEPENDENT_TYPE_SET")
    RETURN
999 ERRORSEXITS("FIELD_DEPENDENT_TYPE_SET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DEPENDENT_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field and locks so that no further changes are possible.
  SUBROUTINE FIELD_DEPENDENT_TYPE_SET_AND_LOCK(FIELD,DEPENDENT_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the dependent type for
    INTEGER(INTG), INTENT(IN) :: DEPENDENT_TYPE !<The dependent type to set/change \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache 

    ENTERS("FIELD_DEPENDENT_TYPE_SET_AND_LOCK",err,error,*999)

    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    CALL FIELD_DEPENDENT_TYPE_SET(FIELD,DEPENDENT_TYPE,err,error,*999)

    createValuesCache%DEPENDENT_TYPE_LOCKED=.TRUE.

    EXITS("FIELD_DEPENDENT_TYPE_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_DEPENDENT_TYPE_SET_AND_LOCK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DEPENDENT_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Destroys a field. \see OpenCMISS::Iron::cmfe_Field_Destroy
  SUBROUTINE FIELD_DESTROY(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to destroy
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx,field_position,field_position2
    TYPE(FieldType), POINTER :: FIELD2,GEOMETRIC_FIELD
    TYPE(FieldsType), POINTER :: FIELDS
    TYPE(FieldPtrType), POINTER :: NEW_FIELDS(:),newFieldsUsing(:)

    NULLIFY(NEW_FIELDS)
    NULLIFY(newFieldsUsing)

    ENTERS("FIELD_DESTROY",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      FIELDS=>FIELD%FIELDS
      IF(ASSOCIATED(FIELDS)) THEN
        field_position=FIELD%globalNumber
        GEOMETRIC_FIELD=>FIELD%geometricField
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          IF(ASSOCIATED(GEOMETRIC_FIELD%geometricFieldParameters)) THEN
            !Delete this field from the list of fields using the geometric field.
            field_position2=0
            DO field_idx=1,GEOMETRIC_FIELD%geometricFieldParameters%numberOfFieldsUsing
              FIELD2=>GEOMETRIC_FIELD%geometricFieldParameters%fieldsUsing(field_idx)%ptr
              IF(FIELD2%userNumber==FIELD%userNumber) THEN
                field_position2=field_idx
                EXIT
              ENDIF
            ENDDO !field_idx
            IF(field_position2/=0) THEN
              ALLOCATE(newFieldsUsing(GEOMETRIC_FIELD%geometricFieldParameters%numberOfFieldsUsing+1),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate new fields using.",err,error,*999)
              DO field_idx=1,GEOMETRIC_FIELD%geometricFieldParameters%numberOfFieldsUsing
                IF(field_idx<field_position2) THEN
                  newFieldsUsing(field_idx)%ptr=>GEOMETRIC_FIELD%geometricFieldParameters%fieldsUsing(field_idx)%ptr
                ELSE IF(field_idx>field_position2) THEN
                  newFieldsUsing(field_idx-1)%ptr=>GEOMETRIC_FIELD%geometricFieldParameters%fieldsUsing(field_idx)%ptr
                ENDIF
              ENDDO !field_idx
              GEOMETRIC_FIELD%geometricFieldParameters%numberOfFieldsUsing=GEOMETRIC_FIELD%geometricFieldParameters% &
                & numberOfFieldsUsing-1
              IF(ASSOCIATED(GEOMETRIC_FIELD%geometricFieldParameters%fieldsUsing)) &
                & DEALLOCATE(GEOMETRIC_FIELD%geometricFieldParameters%fieldsUsing)
              GEOMETRIC_FIELD%geometricFieldParameters%fieldsUsing=>newFieldsUsing
            ELSE
              !??? Error
            ENDIF
          ENDIF
        ENDIF
        CALL FIELD_FINALISE(FIELD,err,error,*999)
        IF(FIELDS%numberOfFields>1) THEN
          ALLOCATE(NEW_FIELDS(FIELDS%numberOfFields-1),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate new fields.",err,error,*999)
          DO field_idx=1,FIELDS%numberOfFields
            IF(field_idx<field_position) THEN
              NEW_FIELDS(field_idx)%ptr=>FIELDS%FIELDS(field_idx)%ptr
            ELSE IF(field_idx>field_position) THEN
              FIELDS%FIELDS(field_idx)%ptr%globalNumber=FIELDS%FIELDS(field_idx)%ptr%globalNumber-1
              NEW_FIELDS(field_idx-1)%ptr=>FIELDS%FIELDS(field_idx)%ptr
            ENDIF
          ENDDO !field_no
          DEALLOCATE(FIELDS%FIELDS)
          FIELDS%FIELDS=>NEW_FIELDS
          FIELDS%numberOfFields=FIELDS%numberOfFields-1
        ELSE
          DEALLOCATE(FIELDS%FIELDS)
          FIELDS%numberOfFields=0
        ENDIF
      ELSE
        CALL FlagError("Field fields is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_DESTROY")
    RETURN
999 IF(ASSOCIATED(NEW_FIELDS)) DEALLOCATE(NEW_FIELDS)
    IF(ASSOCIATED(newFieldsUsing)) DEALLOCATE(newFieldsUsing)
    ERRORSEXITS("FIELD_DESTROY",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DESTROY

  !
  !================================================================================================================================
  !

  !>Checks the field dimension for a field variable.
  SUBROUTINE FIELD_DIMENSION_CHECK(FIELD,VARIABLE_TYPE,DIMENSION_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to check the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: DIMENSION_TYPE !<The field dimension to check \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_DIMENSION_CHECK",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    SELECT CASE(DIMENSION_TYPE)
    CASE(FIELD_SCALAR_DIMENSION_TYPE)
      IF(FIELD_VARIABLE%DIMENSION/=FIELD_SCALAR_DIMENSION_TYPE) THEN
        localError="Invalid dimension type. The dimension type for variable type "// &
          & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD_VARIABLE%DIMENSION,"*",err,error))// &
          & " which is not a scalar field."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_VECTOR_DIMENSION_TYPE)
      IF(FIELD_VARIABLE%DIMENSION/=FIELD_VECTOR_DIMENSION_TYPE) THEN
        localError="Invalid dimension type. The dimension type for variable type "// &
          & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD_VARIABLE%DIMENSION,"*",err,error))// &
          & " which is not a vector field."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_TENSOR_DIMENSION_TYPE) 
      IF(FIELD_VARIABLE%DIMENSION/=FIELD_TENSOR_DIMENSION_TYPE) THEN
        localError="Invalid dimension type. The dimension type for variable type "// &
          & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(FIELD_VARIABLE%DIMENSION,"*",err,error))// &
          & " which is not a tensor field."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE DEFAULT
      localError="The specified dimension type of "//TRIM(NumberToVString(DIMENSION_TYPE,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FIELD_DIMENSION_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_DIMENSION_CHECK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DIMENSION_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the field dimension for a field variable. \see OpenCMISS::Iron::cmfe_Field_DimensionGet
  SUBROUTINE FIELD_DIMENSION_GET(FIELD,VARIABLE_TYPE,DIMENSION,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(OUT) :: DIMENSION !<On return, the field dimension to get \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_DIMENSION_GET",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)

    DIMENSION=FIELD_VARIABLE%DIMENSION

    EXITS("FIELD_DIMENSION_GET")
    RETURN
999 ERRORSEXITS("FIELD_DIMENSION_GET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DIMENSION_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field dimension for a field variable.
  SUBROUTINE FIELD_DIMENSION_SET(FIELD,VARIABLE_TYPE,FIELD_DIMENSION,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_DIMENSION !<The field dimension to set/change \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: NUMBER_OF_COMPONENTS,NEW_NUMBER_OF_COMPONENTS,variable_idx
    INTEGER(INTG), ALLOCATABLE :: NEW_INTERPOLATION_TYPE(:,:),NEW_meshComponentNumber(:,:)
    LOGICAL, ALLOCATABLE :: NEW_componentLabelsLocked(:,:),NEW_INTERPOLATION_TYPE_LOCKED(:,:), &
      & NEW_meshComponentNumberLocked(:,:)
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError
    TYPE(VARYING_STRING), ALLOCATABLE :: NEW_componentLabels(:,:)

    ENTERS("FIELD_DIMENSION_SET",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      IF(ANY(createValuesCache%variableTypes==VARIABLE_TYPE)) THEN
        IF(createValuesCache%DIMENSION_LOCKED(VARIABLE_TYPE)) THEN
          localError="The field dimension has been locked for for variable type "// &
            & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
          CALL FlagError(localError,err,error,*999)
        ELSE
          SELECT CASE(FIELD_DIMENSION)
          CASE(FIELD_SCALAR_DIMENSION_TYPE)
            IF(createValuesCache%numberOfComponents(VARIABLE_TYPE)/=1) THEN
              NUMBER_OF_COMPONENTS=SIZE(createValuesCache%interpolationTypes,1)
              NEW_NUMBER_OF_COMPONENTS=1
              !Here, new number of components always >= old_number_of_components
              DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
                IF (createValuesCache%numberOfComponents(variable_idx) > NEW_NUMBER_OF_COMPONENTS) THEN 
                  IF (variable_idx /= VARIABLE_TYPE) THEN
                    NEW_NUMBER_OF_COMPONENTS=createValuesCache%numberOfComponents(variable_idx)
                  ENDIF
                ENDIF
              ENDDO
              ALLOCATE(NEW_componentLabels(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate new component labels.",err,error,*999)
              ALLOCATE(NEW_componentLabelsLocked(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate new component labels locked.",err,error,*999)
              ALLOCATE(NEW_INTERPOLATION_TYPE(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate new interpolation type.",err,error,*999)
              ALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate new interpolation type locked.",err,error,*999)
              ALLOCATE(NEW_meshComponentNumber(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate new mesh component number.",err,error,*999)
              ALLOCATE(NEW_meshComponentNumberLocked(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate new mesh component number locked.",err,error,*999)
              NEW_componentLabels(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                & createValuesCache%componentLabels(1:NEW_NUMBER_OF_COMPONENTS,:)
              NEW_componentLabelsLocked(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                & createValuesCache%componentLabelsLocked(1:NEW_NUMBER_OF_COMPONENTS,:)
              NEW_INTERPOLATION_TYPE(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                & createValuesCache%interpolationTypes(1:NEW_NUMBER_OF_COMPONENTS,:)
              NEW_INTERPOLATION_TYPE_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                & createValuesCache%interpolationTypesLocked(1:NEW_NUMBER_OF_COMPONENTS,:)
              NEW_meshComponentNumber(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                & createValuesCache%meshComponentNumber(1:NEW_NUMBER_OF_COMPONENTS,:)
              NEW_meshComponentNumberLocked(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                & createValuesCache%meshComponentNumberLocked(1:NEW_NUMBER_OF_COMPONENTS,:)

              CALL MOVE_ALLOC(NEW_componentLabels,createValuesCache%componentLabels)
              CALL MOVE_ALLOC(NEW_componentLabelsLocked,createValuesCache%componentLabelsLocked)
              CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE,createValuesCache%interpolationTypes)
              CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE_LOCKED,createValuesCache%interpolationTypesLocked)
              CALL MOVE_ALLOC(NEW_meshComponentNumber,createValuesCache%meshComponentNumber)
              CALL MOVE_ALLOC(NEW_meshComponentNumberLocked,createValuesCache%meshComponentNumberLocked)

              createValuesCache%numberOfComponents(VARIABLE_TYPE)=1
            ENDIF
            createValuesCache%DIMENSION(VARIABLE_TYPE)=FIELD_SCALAR_DIMENSION_TYPE
          CASE(FIELD_VECTOR_DIMENSION_TYPE)
            createValuesCache%DIMENSION(VARIABLE_TYPE)=FIELD_VECTOR_DIMENSION_TYPE
          CASE(FIELD_TENSOR_DIMENSION_TYPE)
            createValuesCache%DIMENSION(VARIABLE_TYPE)=FIELD_TENSOR_DIMENSION_TYPE
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The specified field dimension of "//TRIM(NumberToVString(FIELD_DIMENSION,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ENDIF
      ELSE
        localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
          & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " is invalid. The variable type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_DIMENSION_SET")
    RETURN
999 IF(ALLOCATED(NEW_componentLabels)) DEALLOCATE(NEW_componentLabels)
    IF(ALLOCATED(NEW_componentLabelsLocked)) DEALLOCATE(NEW_componentLabelsLocked)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE)) DEALLOCATE(NEW_INTERPOLATION_TYPE)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE_LOCKED)) DEALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED)
    IF(ALLOCATED(NEW_meshComponentNumber)) DEALLOCATE(NEW_meshComponentNumber)
    IF(ALLOCATED(NEW_meshComponentNumberLocked)) DEALLOCATE(NEW_meshComponentNumberLocked)
    ERRORSEXITS("FIELD_DIMENSION_SET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DIMENSION_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field dimension for a field variable  and locks so that no further changes can be made.
  SUBROUTINE FIELD_DIMENSION_SET_AND_LOCK(FIELD,VARIABLE_TYPE,FIELD_DIMENSION,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_DIMENSION !<The field dimension to set/change \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("FIELD_DIMENSION_SET_AND_LOCK",err,error,*999)

    CALL FIELD_DIMENSION_SET(FIELD,VARIABLE_TYPE,FIELD_DIMENSION,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)

    createValuesCache%DIMENSION_LOCKED(VARIABLE_TYPE)=.TRUE.

    EXITS("FIELD_DIMENSION_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_DIMENSION_SET_AND_LOCK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_DIMENSION_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Finalises a field and deallocates all memory.
  SUBROUTINE FIELD_FINALISE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_FINALISE",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      FIELD%LABEL=""
      CALL FIELD_SCALINGS_FINALISE(FIELD,err,error,*999)
      CALL FIELD_VARIABLES_FINALISE(FIELD,err,error,*999)
      CALL FIELD_CREATE_VALUES_CACHE_FINALISE(FIELD%createValuesCache,err,error,*999)
      CALL FIELD_GEOMETRIC_PARAMETERS_FINALISE(FIELD%geometricFieldParameters,err,error,*999)
      IF(ALLOCATED(FIELD%variableTypeMap)) DEALLOCATE(FIELD%variableTypeMap)
      DEALLOCATE(FIELD)     
    ENDIF

    EXITS("FIELD_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_FINALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises a field
  SUBROUTINE FIELD_INITIALISE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the new field to initialise. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,variable_type_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("FIELD_INITIALISE",err,error,*998)

    IF(ASSOCIATED(FIELD)) THEN
      CALL FlagError("Field is already associated.",err,error,*998)
    ELSE
      ALLOCATE(FIELD,STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate field.",err,error,*999)      
      FIELD%globalNumber=0
      FIELD%userNumber=0
      FIELD%LABEL=""
      FIELD%fieldFinished=.FALSE.
      NULLIFY(FIELD%FIELDS)
      NULLIFY(FIELD%REGION)
      FIELD%TYPE=FIELD_GEOMETRIC_TYPE
      FIELD%DEPENDENT_TYPE=FIELD_INDEPENDENT_TYPE
      NULLIFY(FIELD%DECOMPOSITION)
      FIELD%numberOfVariables=0
      NULLIFY(FIELD%geometricField)
      NULLIFY(FIELD%geometricFieldParameters)
      NULLIFY(FIELD%createValuesCache)
      ALLOCATE(FIELD%variableTypeMap(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate field variable type map.",err,error,*999)
      DO variable_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
        NULLIFY(FIELD%variableTypeMap(variable_type_idx)%ptr)
      ENDDO !variable_type_idx
    ENDIF

    EXITS("FIELD_INITIALISE")
    RETURN
999 CALL FIELD_FINALISE(FIELD,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INITIALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INITIALISE

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a gauss point to give an interpolated point. partialDerivativeType controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated. Old CMISS name XEXG, ZEXG
  SUBROUTINE FIELD_INTERPOLATE_GAUSS(partialDerivativeType,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATED_POINT, &
    & err,error,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the provided field interpolation
    INTEGER(INTG), INTENT(IN) :: QUADRATURE_SCHEME !<The quadrature scheme of the Gauss points \see BASIS_ROUTINES_QuadratureSchemes,BASIS_ROUTINES
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINT_NUMBER !<The number of the Gauss point to interpolate the field at
    TYPE(FieldInterpolatedPointType), POINTER :: INTERPOLATED_POINT !<The pointer to the interpolated point which will contain the field interpolation information at the specified Gauss point
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,ni,nu
    INTEGER(INTG) :: startComponentIdx,endComponentIdx
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_INTERPOLATE_GAUSS",err,error,*999)

    IF(.NOT.ASSOCIATED(INTERPOLATED_POINT)) CALL FlagError("Interpolated point is not associated.",err,error,*999)
    NULLIFY(INTERPOLATION_PARAMETERS)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(INTERPOLATED_POINT,INTERPOLATION_PARAMETERS,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(COORDINATE_SYSTEM)
    CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSEIF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    SELECT CASE(partialDerivativeType)
    CASE(NO_PART_DERIV)
      DO component_idx=startComponentidx,endComponentIdx
        SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)              
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
            & component_idx)%ptr,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
            & PARAMETERS(:,component_idx),err,error)
          IF(err/=0) GOTO 999
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(GAUSS_POINT_NUMBER, &
            & component_idx)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",err,error))//"."
        END SELECT
        CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
          & err,error,*999)
      ENDDO! component_idx
      INTERPOLATED_POINT%partialDerivativeType=NO_PART_DERIV
    CASE(FIRST_PART_DERIV)
      DO component_idx=startComponentidx,endComponentIdx
        SELECT CASE(INTERPOLATION_PARAMETERS%fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
            nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !ni
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
            nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !ni
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
            & component_idx)%ptr,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
            & PARAMETERS(:,component_idx),err,error)
          IF(err/=0) GOTO 999
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
            nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
            INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
              & BASES(component_idx)%ptr,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
              & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
            IF(err/=0) GOTO 999
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !ni
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",err,error))//"."
        END SELECT
      ENDDO! component_idx
      INTERPOLATED_POINT%partialDerivativeType=FIRST_PART_DERIV
    CASE(SECOND_PART_DERIV)
      DO component_idx=startComponentidx,endComponentIdx
        SELECT CASE(INTERPOLATION_PARAMETERS%fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfPartialDerivatives
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !nu
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfPartialDerivatives
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !nu
        CASE(FIELD_NODE_BASED_INTERPOLATION)              
          DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfPartialDerivatives
            INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
              & BASES(component_idx)%ptr,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
              & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
            IF(err/=0) GOTO 999
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO! nu
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",err,error))//"."
        END SELECT
      ENDDO !component_idx
      INTERPOLATED_POINT%partialDerivativeType=SECOND_PART_DERIV
    CASE DEFAULT
      localError="The partial derivative type of "//TRIM(NumberToVString(partialDerivativeType,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FIELD_INTERPOLATE_GAUSS")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATE_GAUSS",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATE_GAUSS

  !
  !================================================================================================================================
  !

  !>Interpolates a field to give the physical value of the field at a node. Note that as we are at a node then we do not have any xi directions and thus we can not talk about gradients of the field wrt to xi. Because derviatives of fields can be discountinuous at a node the average derivative over all the elements surrounding the node is calculated.
  SUBROUTINE FIELD_INTERPOLATE_NODE(physicalDerivativeType,PARAMETER_SET_TYPE,COMPONENT_NUMBER,NODE_NUMBER, &
    & PHYSICAL_POINT,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: physicalDerivativeType !<The physical derivative type of the field interpolation \see CONSTANTS_PhysicalDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The parameter set of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The component number to field that contains the node 
    INTEGER(INTG), INTENT(IN) :: NODE_NUMBER !<The node number in the component to interpolate the field at
    TYPE(FieldPhysicalPointType), POINTER :: PHYSICAL_POINT !<The pointer to the physical point for the field. On return it will contain the values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,element,elem_idx,LOCAL_NODE_NUMBER,local_node_idx,numberOfSurroundingElements, &
      & partial_deriv_idx,xi_idx
    REAL(DP) :: XI(3),DX_DXI(3,3),DXI_DX(3,3),DET_DX_DXI
    TYPE(BasisType), POINTER :: BASIS
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(DomainType), POINTER :: DOMAIN
    TYPE(DomainElementsType), POINTER :: ELEM_TOPOLOGY
    TYPE(DomainNodesType), POINTER :: DOMAIN_NODES
    TYPE(DomainTopologyType), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FieldType), POINTER :: FIELD
    TYPE(FieldInterpolatedPointType), POINTER :: FIELD_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT
    TYPE(FieldInterpolationParametersType), POINTER :: FIELD_INTERPOLATION_PARAMETERS,GEOMETRIC_INTERPOLATION_PARAMETERS
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE,GEOMETRIC_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_INTERPOLATE_NODE",err,error,*999)

    IF(ASSOCIATED(PHYSICAL_POINT)) THEN
      FIELD_INTERPOLATED_POINT=>PHYSICAL_POINT%fieldInterpolatedPoint
      IF(ASSOCIATED(FIELD_INTERPOLATED_POINT)) THEN
        GEOMETRIC_INTERPOLATED_POINT=>PHYSICAL_POINT%geometricInterpolatedPoint
        IF(ASSOCIATED(GEOMETRIC_INTERPOLATED_POINT)) THEN
          FIELD_INTERPOLATION_PARAMETERS=>FIELD_INTERPOLATED_POINT%interpolationParameters
          IF(ASSOCIATED(FIELD_INTERPOLATION_PARAMETERS)) THEN
            GEOMETRIC_INTERPOLATION_PARAMETERS=>GEOMETRIC_INTERPOLATED_POINT%interpolationParameters
            IF(ASSOCIATED(GEOMETRIC_INTERPOLATION_PARAMETERS)) THEN
              FIELD_VARIABLE=>FIELD_INTERPOLATION_PARAMETERS%fieldVariable
              IF(ASSOCIATED(FIELD_VARIABLE)) THEN
                GEOMETRIC_VARIABLE=>GEOMETRIC_INTERPOLATION_PARAMETERS%fieldVariable
                IF(ASSOCIATED(GEOMETRIC_VARIABLE)) THEN
                  FIELD=>FIELD_VARIABLE%FIELD
                  IF(ASSOCIATED(FIELD)) THEN            
                    CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,err,error,*999)            
                    IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%numberOfComponents) THEN
                      DOMAIN=>FIELD_VARIABLE%components(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        NULLIFY(DOMAIN_TOPOLOGY)
                        CALL Domain_DomainTopologyGet(DOMAIN,DOMAIN_TOPOLOGY,err,error,*999)
                        NULLIFY(DOMAIN_NODES)
                        CALL DomainTopology_DomainNodesget(DOMAIN_TOPOLOGY,DOMAIN_NODES,err,error,*999)
                        NULLIFY(ELEM_TOPOLOGY)
                        CALL DomainTopology_DomainElementsGet(DOMAIN_TOPOLOGY,ELEM_TOPOLOGY,err,error,*999)
                        IF(NODE_NUMBER>0.AND.NODE_NUMBER<=DOMAIN_NODES%numberOfNodes) THEN
                          PHYSICAL_POINT%VALUES=0.0_DP
                          IF(physicalDerivativeType==NO_PHYSICAL_DERIV) THEN
                            numberOfSurroundingElements=1
                          ELSE
                            numberOfSurroundingElements=DOMAIN_NODES%nodes(NODE_NUMBER)%numberOfSurroundingElements
                            PHYSICAL_POINT%VALUES=0.0_DP
                          ENDIF
                          !Loop over the elements surrounding the node
                          DO elem_idx=1,numberOfSurroundingElements
                            element=DOMAIN_NODES%nodes(NODE_NUMBER)%surroundingElements(elem_idx)
                            CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(PARAMETER_SET_TYPE,element, &
                              & FIELD_INTERPOLATION_PARAMETERS,err,error,*999)
                            NULLIFY(BASIS)
                            CALL DomainElements_BasisGet(ELEM_TOPOLOGY,element,BASIS,err,error,*999)
                            LOCAL_NODE_NUMBER=0
                            DO local_node_idx=1,BASIS%numberOfNodes
                              IF(ELEM_TOPOLOGY%ELEMENTS(element)%elementNodes(local_node_idx)==NODE_NUMBER) THEN
                                LOCAL_NODE_NUMBER=local_node_idx
                                EXIT
                              ENDIF
                            ENDDO
                            IF(LOCAL_NODE_NUMBER/=0) THEN
                              CALL BASIS_LOCAL_NODE_XI_CALCULATE(BASIS,LOCAL_NODE_NUMBER,XI,err,error,*999)  
                              SELECT CASE(physicalDerivativeType)
                              CASE(NO_PHYSICAL_DERIV)
                                DO component_idx=1,FIELD_VARIABLE%numberOfComponents
                                  SELECT CASE(FIELD_VARIABLE%components(component_idx)%interpolationType)
                                  CASE(FIELD_CONSTANT_INTERPOLATION)
                                    PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                      & PARAMETERS(1,component_idx)
                                  CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                    PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                      & PARAMETERS(1,component_idx)
                                  CASE(FIELD_NODE_BASED_INTERPOLATION)
                                    PHYSICAL_POINT%VALUES(component_idx)=BASIS_INTERPOLATE_XI( &
                                      & FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr,NO_PART_DERIV, &
                                      & XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
                                    IF(err/=0) GOTO 999
                                  CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                    CALL FlagError("Not implemented.",err,error,*999)
                                  CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                    CALL FlagError("Not implemented.",err,error,*999)
                                  CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                    CALL FlagError("Not implemented.",err,error,*999)
                                  CASE DEFAULT
                                    localError="The field component interpolation type of "// &
                                      & TRIM(NumberToVString(FIELD_VARIABLE%components(component_idx)% &
                                      & interpolationType,"*",err,error))//" is invalid for component index "// &
                                      & TRIM(NumberToVString(component_idx,"*",err,error))//"."
                                  END SELECT
                                ENDDO! component_idx
                                PHYSICAL_POINT%physicalDerivativeType=NO_PHYSICAL_DERIV
                              CASE(GRADIENT_PHYSICAL_DERIV)
                                DO component_idx=1,FIELD_VARIABLE%numberOfComponents
                                  SELECT CASE(FIELD_VARIABLE%components(component_idx)%interpolationType)
                                  CASE(FIELD_CONSTANT_INTERPOLATION)
                                    !There is no gradient for constant interpolation
                                    PHYSICAL_POINT%VALUES(component_idx)=0.0_DP                                            
                                  CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                    !There is no graident for element interpolation
                                    PHYSICAL_POINT%VALUES(component_idx)=0.0_DP
                                  CASE(FIELD_NODE_BASED_INTERPOLATION)
                                    CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,element, &
                                      & GEOMETRIC_INTERPOLATION_PARAMETERS,err,error,*999)
                                    !Now process all the first partial derivatives
                                    DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
                                      partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                      !Interpolate the field
                                      FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                        & BASIS_INTERPOLATE_XI(FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr, &
                                        & partial_deriv_idx,XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                        & component_idx),err,error)
                                      IF(err/=0) GOTO 999
                                      CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                        & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx),err,error,*999)
                                      GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                        & BASIS_INTERPOLATE_XI(GEOMETRIC_INTERPOLATION_PARAMETERS%BASES(component_idx)% &
                                        & PTR,partial_deriv_idx,XI,GEOMETRIC_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                        & component_idx),err,error)
                                      IF(err/=0) GOTO 999
                                      CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                        & GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx), &
                                        & err,error,*999)
                                      DX_DXI(component_idx,xi_idx)=GEOMETRIC_INTERPOLATED_POINT% &
                                        & VALUES(component_idx,partial_deriv_idx)
                                    ENDDO !xi_idx
                                  CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                    CALL FlagError("Not implemented.",err,error,*999)
                                  CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                    CALL FlagError("Not implemented.",err,error,*999)
                                  CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                    CALL FlagError("Not implemented.",err,error,*999)
                                  CASE DEFAULT
                                    localError="The field component interpolation type of "// &
                                      & TRIM(NumberToVString(FIELD_INTERPOLATION_PARAMETERS% &
                                      & fieldVariable%components(component_idx)%interpolationType,"*",err,error))// &
                                      & " is invalid for component index "// &
                                      & TRIM(NumberToVString(component_idx,"*",err,error))//"."
                                  END SELECT
                                ENDDO! component_idx
                                !Form the physical derivative
                                CALL INVERT(DX_DXI,DXI_DX,DET_DX_DXI,err,error,*999)
                                DO component_idx=1,FIELD_VARIABLE%numberOfComponents
                                  DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
                                    partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                    PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)+ &
                                      & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx)* &
                                      & DXI_DX(xi_idx,component_idx)
                                  ENDDO !xi_idx
                                ENDDO !component_idx
                                PHYSICAL_POINT%physicalDerivativeType=GRADIENT_PHYSICAL_DERIV
                              CASE DEFAULT
                                localError="The physical derivative type of "// &
                                  & TRIM(NumberToVString(physicalDerivativeType,"*",err,error))//" is invalid."
                                CALL FlagError(localError,err,error,*999)
                              END SELECT
                            ELSE
                              localError="Could not find the local node for node "// &
                                & TRIM(NumberToVString(NODE_NUMBER,"*",err,error))//" in element number "// &
                                & TRIM(NumberToVString(element,"*",err,error))//"."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDDO !elem_idx
                          IF(physicalDerivativeType==NO_PHYSICAL_DERIV) THEN
                            !Now calculate the average of the interpolated physical point
                            DO component_idx=1,FIELD_VARIABLE%numberOfComponents
                              SELECT CASE(FIELD_VARIABLE%components(component_idx)%interpolationType)
                              CASE(FIELD_CONSTANT_INTERPOLATION)
                                !Do nothing
                              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                !Do nothing
                              CASE(FIELD_NODE_BASED_INTERPOLATION)                                      
                                PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)/ &
                                  & REAL(numberOfSurroundingElements,DP)
                              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                CALL FlagError("Not implemented.",err,error,*999)
                              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                CALL FlagError("Not implemented.",err,error,*999)
                              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                CALL FlagError("Not implemented.",err,error,*999)
                              CASE DEFAULT
                                localError="The field component interpolation type of "// &
                                  & TRIM(NumberToVString(FIELD_INTERPOLATION_PARAMETERS% &
                                  & fieldVariable%components(component_idx)%interpolationType,"*",err,error))// &
                                  & " is invalid for component index "// &
                                  & TRIM(NumberToVString(component_idx,"*",err,error))//"."
                              END SELECT
                            ENDDO !component_idx
                          ENDIF
                        ELSE
                          localError="The specified node number of "//TRIM(NumberToVString(NODE_NUMBER,"*",err,error))// &
                            & " is invalid. The node number needs to be > 0 and <= "// &
                            & TRIM(NumberToVString(DOMAIN_NODES%numberOfNodes,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",err,error,*999)          
                      ENDIF
                    ELSE
                      localError="The specified component number of "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
                        & " is invalid. The component number must be > 0 and <= "// &
                        & TRIM(NumberToVString(FIELD_VARIABLE%numberOfComponents,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The field variable field is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The geometric interpolation parameters field variable is not associated.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The field interpolation parameters field variable is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Geometric interpolated point interpolation parameters is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Field interpolated point interpolation parameters is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Physical point geometric interpolated point is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Physical point field interpolated point is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Physical point is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_INTERPOLATE_NODE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATE_NODE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATE_NODE

  !
  !================================================================================================================================
  !

  !>Interpolates a field to give the physical value of the field at a node in another field. Note that as we are at a node then we do not have any xi directions and thus we can not talk about gradients of the field wrt to xi. Because derviatives of fields can be discountinuous at a node the average derivative over all the elements surrounding the node is calculated.
  SUBROUTINE FIELD_INTERPOLATE_FIELD_NODE(physicalDerivativeType,PARAMETER_SET_TYPE,FIELD,VARIABLE_TYPE,COMPONENT_NUMBER, &
    & NODE_NUMBER,PHYSICAL_POINT,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: physicalDerivativeType !<The physical derivative type of the field interpolation \see CONSTANTS_PhysicalDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The parameter set of the field to interpolate.
    TYPE(FieldType), POINTER :: FIELD !<The field containing the node to interpolate at.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The variable type containing the node to interpolate at
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The component number to field that contains the node to interpolate at
    INTEGER(INTG), INTENT(IN) :: NODE_NUMBER !<The node number in the field variable component to interpolate the field at
    TYPE(FieldPhysicalPointType), POINTER :: PHYSICAL_POINT !<The pointer to the physical point for the field. On return it will contain the values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,element,elem_idx,LOCAL_NODE_NUMBER,local_node_idx,numberOfSurroundingElements, &
      & partial_deriv_idx,xi_idx
    REAL(DP) :: XI(3),DX_DXI(3,3),DXI_DX(3,3),DET_DX_DXI
    TYPE(BasisType), POINTER :: BASIS
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(DomainType), POINTER :: DOMAIN
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: INTERP_FIELD
    TYPE(FieldInterpolatedPointType), POINTER :: FIELD_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT
    TYPE(FieldInterpolationParametersType), POINTER :: FIELD_INTERPOLATION_PARAMETERS,GEOMETRIC_INTERPOLATION_PARAMETERS
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE,INTERP_VARIABLE,GEOMETRIC_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_INTERPOLATE_FIELD_NODE",err,error,*999)

    IF(ASSOCIATED(PHYSICAL_POINT)) THEN
      FIELD_INTERPOLATED_POINT=>PHYSICAL_POINT%fieldInterpolatedPoint
      IF(ASSOCIATED(FIELD_INTERPOLATED_POINT)) THEN
        GEOMETRIC_INTERPOLATED_POINT=>PHYSICAL_POINT%geometricInterpolatedPoint
        IF(ASSOCIATED(GEOMETRIC_INTERPOLATED_POINT)) THEN
          FIELD_INTERPOLATION_PARAMETERS=>FIELD_INTERPOLATED_POINT%interpolationParameters
          IF(ASSOCIATED(FIELD_INTERPOLATION_PARAMETERS)) THEN
            GEOMETRIC_INTERPOLATION_PARAMETERS=>GEOMETRIC_INTERPOLATED_POINT%interpolationParameters
            IF(ASSOCIATED(GEOMETRIC_INTERPOLATION_PARAMETERS)) THEN
              INTERP_VARIABLE=>FIELD_INTERPOLATION_PARAMETERS%fieldVariable
              IF(ASSOCIATED(INTERP_VARIABLE)) THEN
                GEOMETRIC_VARIABLE=>GEOMETRIC_INTERPOLATION_PARAMETERS%fieldVariable
                IF(ASSOCIATED(GEOMETRIC_VARIABLE)) THEN
                  INTERP_FIELD=>INTERP_VARIABLE%FIELD
                  IF(ASSOCIATED(INTERP_FIELD)) THEN
                    NULLIFY(COORDINATE_SYSTEM)
                    CALL FIELD_COORDINATE_SYSTEM_GET(INTERP_FIELD,COORDINATE_SYSTEM,err,error,*999)
                    IF(ASSOCIATED(FIELD)) THEN
                      NULLIFY(FIELD_VARIABLE)
                      CALL Field_VariableGet(FIELD,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
                      IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%numberOfComponents) THEN
                        DOMAIN=>FIELD_VARIABLE%components(COMPONENT_NUMBER)%DOMAIN
                        IF(ASSOCIATED(DOMAIN)) THEN
                          NULLIFY(domainTopology)
                          CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
                          NULLIFY(domainNodes)
                          CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
                          NULLIFY(domainElements)
                          CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
                          IF(NODE_NUMBER>0.AND.NODE_NUMBER<=domainNodes%numberOfNodes) THEN
                            PHYSICAL_POINT%VALUES=0.0_DP
                            IF(physicalDerivativeType==NO_PHYSICAL_DERIV) THEN
                              numberOfSurroundingElements=1
                            ELSE
                              numberOfSurroundingElements=domainNodes%nodes(NODE_NUMBER)% &
                                & numberOfSurroundingElements
                              PHYSICAL_POINT%VALUES=0.0_DP
                            ENDIF
                            !Loop over the elements surrounding the node
                            DO elem_idx=1,numberOfSurroundingElements
                              element=domainNodes%nodes(NODE_NUMBER)%surroundingElements(elem_idx)
                              CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(PARAMETER_SET_TYPE,element, &
                                & FIELD_INTERPOLATION_PARAMETERS,err,error,*999)
                              NULLIFY(basis)
                              CALL DomainElements_BasisGet(domainElements,element,basis,err,error,*999)
                              LOCAL_NODE_NUMBER=0
                              DO local_node_idx=1,BASIS%numberOfNodes
                                IF(domainElements%ELEMENTS(element)%elementNodes(local_node_idx)==NODE_NUMBER) THEN
                                  LOCAL_NODE_NUMBER=local_node_idx
                                  EXIT
                                ENDIF
                              ENDDO
                              IF(LOCAL_NODE_NUMBER/=0) THEN
                                CALL BASIS_LOCAL_NODE_XI_CALCULATE(BASIS,LOCAL_NODE_NUMBER,XI,err,error,*999)  
                                SELECT CASE(physicalDerivativeType)
                                CASE(NO_PHYSICAL_DERIV)
                                  DO component_idx=1,INTERP_VARIABLE%numberOfComponents
                                    SELECT CASE(INTERP_VARIABLE%components(component_idx)%interpolationType)
                                    CASE(FIELD_CONSTANT_INTERPOLATION)
                                      PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                        & PARAMETERS(1,component_idx)
                                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                      PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                        & PARAMETERS(1,component_idx)
                                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                                      PHYSICAL_POINT%VALUES(component_idx)=BASIS_INTERPOLATE_XI( &
                                        & FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr,NO_PART_DERIV, &
                                        & XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
                                      IF(err/=0) GOTO 999
                                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                      CALL FlagError("Not implemented.",err,error,*999)
                                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                      CALL FlagError("Not implemented.",err,error,*999)
                                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                      CALL FlagError("Not implemented.",err,error,*999)
                                    CASE DEFAULT
                                      localError="The field component interpolation type of "// &
                                        & TRIM(NumberToVString(INTERP_VARIABLE%components(component_idx)% &
                                        & interpolationType,"*",err,error))//" is invalid for component index "// &
                                        & TRIM(NumberToVString(component_idx,"*",err,error))//"."
                                    END SELECT
                                  ENDDO! component_idx
                                  PHYSICAL_POINT%physicalDerivativeType=NO_PHYSICAL_DERIV
                                CASE(GRADIENT_PHYSICAL_DERIV)
                                  DO component_idx=1,INTERP_VARIABLE%numberOfComponents
                                    SELECT CASE(INTERP_VARIABLE%components(component_idx)%interpolationType)
                                    CASE(FIELD_CONSTANT_INTERPOLATION)
                                      !There is no gradient for constant interpolation
                                      PHYSICAL_POINT%VALUES(component_idx)=0.0_DP
                                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                      !There is no graident for element interpolation
                                      PHYSICAL_POINT%VALUES(component_idx)=0.0_DP
                                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                                      CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,element, &
                                        & GEOMETRIC_INTERPOLATION_PARAMETERS,err,error,*999)
                                      !Now process all the first partial derivatives
                                      DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
                                        partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                        !Interpolate the field
                                        FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                          & BASIS_INTERPOLATE_XI(FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr, &
                                          & partial_deriv_idx,XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                          & component_idx),err,error)
                                        IF(err/=0) GOTO 999
                                        CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                          & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx),err,error,*999)
                                        GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                          & BASIS_INTERPOLATE_XI(GEOMETRIC_INTERPOLATION_PARAMETERS%BASES(component_idx)% &
                                          & PTR,partial_deriv_idx,XI,GEOMETRIC_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                          & component_idx),err,error)
                                        IF(err/=0) GOTO 999
                                        CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                          & GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx), &
                                          & err,error,*999)
                                        DX_DXI(component_idx,xi_idx)=GEOMETRIC_INTERPOLATED_POINT% &
                                          & VALUES(component_idx,partial_deriv_idx)
                                      ENDDO !xi_idx
                                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                      CALL FlagError("Not implemented.",err,error,*999)
                                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                      CALL FlagError("Not implemented.",err,error,*999)
                                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                      CALL FlagError("Not implemented.",err,error,*999)
                                    CASE DEFAULT
                                      localError="The field component interpolation type of "// &
                                        & TRIM(NumberToVString(FIELD_INTERPOLATION_PARAMETERS% &
                                        & fieldVariable%components(component_idx)%interpolationType,"*",err,error))// &
                                        & " is invalid for component index "// &
                                        & TRIM(NumberToVString(component_idx,"*",err,error))//"."
                                    END SELECT
                                  ENDDO! component_idx
                                  !Form the physical derivative
                                  CALL INVERT(DX_DXI,DXI_DX,DET_DX_DXI,err,error,*999)
                                  DO component_idx=1,INTERP_VARIABLE%numberOfComponents
                                    DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
                                      partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                      PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)+ &
                                        & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx)* &
                                        & DXI_DX(xi_idx,component_idx)
                                    ENDDO !xi_idx
                                  ENDDO !component_idx
                                  PHYSICAL_POINT%physicalDerivativeType=GRADIENT_PHYSICAL_DERIV
                                CASE DEFAULT
                                  localError="The physical derivative type of "// &
                                    & TRIM(NumberToVString(physicalDerivativeType,"*",err,error))//" is invalid."
                                  CALL FlagError(localError,err,error,*999)
                                END SELECT
                              ELSE
                                localError="Could not find the local node for node "// &
                                  & TRIM(NumberToVString(NODE_NUMBER,"*",err,error))//" in element number "// &
                                  & TRIM(NumberToVString(element,"*",err,error))//"."
                                CALL FlagError(localError,err,error,*999)
                              ENDIF
                            ENDDO !elem_idx
                            IF(physicalDerivativeType==NO_PHYSICAL_DERIV) THEN
                              !Now calculate the average of the interpolated physical point
                              DO component_idx=1,INTERP_VARIABLE%numberOfComponents
                                SELECT CASE(INTERP_VARIABLE%components(component_idx)%interpolationType)
                                CASE(FIELD_CONSTANT_INTERPOLATION)
                                  !Do nothing
                                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                  !Do nothing
                                CASE(FIELD_NODE_BASED_INTERPOLATION)                                      
                                  PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)/ &
                                    & REAL(numberOfSurroundingElements,DP)
                                CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                  CALL FlagError("Not implemented.",err,error,*999)
                                CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                  CALL FlagError("Not implemented.",err,error,*999)
                                CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                  CALL FlagError("Not implemented.",err,error,*999)
                                CASE DEFAULT
                                  localError="The field component interpolation type of "// &
                                    & TRIM(NumberToVString(INTERP_VARIABLE%components(component_idx)% &
                                    & interpolationType,"*",err,error))// &
                                    & " is invalid for component index "// &
                                    & TRIM(NumberToVString(component_idx,"*",err,error))//"."
                                END SELECT
                              ENDDO !component_idx
                            ENDIF
                          ELSE
                            localError="The specified node number of "//TRIM(NumberToVString(NODE_NUMBER,"*",err,error))// &
                              & " is invalid. The node number needs to be > 0 and <= "// &
                              & TRIM(NumberToVString(domainNodes%numberOfNodes,"*",err,error))//"."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain is not associated.",err,error,*999)          
                        ENDIF
                      ELSE
                        localError="The specified component number of "// &
                          & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
                          & " is invalid. The component number must be > 0 and <= "// &
                          & TRIM(NumberToVString(FIELD_VARIABLE%numberOfComponents,"*",err,error))//"."
                        CALL FlagError(localError,err,error,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Field is not associated.",err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The field variable field is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The geometric interpolation parameters field variable is not associated.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The field interpolation parameters field variable is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Geometric interpolated point interpolation parameters is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Field interpolated point interpolation parameters is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Physical point geometric interpolated point is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Physical point field interpolated point is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Physical point is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_INTERPOLATE_FIELD_NODE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATE_FIELD_NODE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATE_FIELD_NODE

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a face gauss point to give an interpolated point. partialDerivativeType controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated.
  SUBROUTINE FIELD_INTERPOLATE_LOCAL_FACE_GAUSS(partialDerivativeType,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER, &
    & GAUSS_POINT_NUMBER,INTERPOLATED_POINT,err,error,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the provided field interpolation
    INTEGER(INTG), INTENT(IN) :: QUADRATURE_SCHEME !<The quadrature scheme of the Gauss points \see BASIS_ROUTINES_QuadratureSchemes,BASIS_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_FACE_NUMBER !<The index number of the face to interpolate on
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINT_NUMBER !<The number of the face Gauss point to interpolate the field at
    TYPE(FieldInterpolatedPointType), POINTER :: INTERPOLATED_POINT !<The pointer to the interpolated point which will contain the field interpolation information at the specified Gauss point
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,ni,nu,startComponentIdx,endComponentIdx
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_INTERPOLATE_LOCAL_FACE_GAUSS",err,error,*999)

    IF(.NOT.ASSOCIATED(INTERPOLATED_POINT)) CALL FlagError("Interpolated point is not associated.",err,error,*999)
    NULLIFY(INTERPOLATION_PARAMETERS)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(INTERPOLATED_POINT,INTERPOLATION_PARAMETERS,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(COORDINATE_SYSTEM)
    CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSEIF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    SELECT CASE(partialDerivativeType)
    CASE(NO_PART_DERIV)
      DO component_idx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)              
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          !                 INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
          !                   & component_idx)%ptr,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
          !                   & PARAMETERS(:,component_idx),err,error)
          INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
            & component_idx)%ptr,NO_PART_DERIV,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
            & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
          IF(err/=0) GOTO 999
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",err,error))//"."
        END SELECT
        CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
          & err,error,*999)
      ENDDO! component_idx
      INTERPOLATED_POINT%partialDerivativeType=NO_PART_DERIV
    CASE(FIRST_PART_DERIV)
      DO component_idx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
            nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !ni
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
            nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !ni
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          !                 INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
          !                   & component_idx)%ptr,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
          !                   & PARAMETERS(:,component_idx),err,error)
          INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
            & component_idx)%ptr,NO_PART_DERIV,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
            & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
          IF(err/=0) GOTO 999
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
            nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
            !                   INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
            !                     & BASES(component_idx)%ptr,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
            !                     & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
            INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
              & component_idx)%ptr,nu,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
              & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
            IF(err/=0) GOTO 999
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !ni
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",err,error))//"."
        END SELECT
      ENDDO! component_idx
      INTERPOLATED_POINT%partialDerivativeType=FIRST_PART_DERIV
    CASE(SECOND_PART_DERIV)
      DO component_idx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfPartialDerivatives
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !nu
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfPartialDerivatives
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !nu
        CASE(FIELD_NODE_BASED_INTERPOLATION)              
          DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfPartialDerivatives
            !                   INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
            !                     & BASES(component_idx)%ptr,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
            !                     & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
            INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
              & component_idx)%ptr,nu,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
              & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
            IF(err/=0) GOTO 999
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO! nu
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",err,error))//"."
        END SELECT
      ENDDO !component_idx
      INTERPOLATED_POINT%partialDerivativeType=SECOND_PART_DERIV
    CASE DEFAULT
      localError="The partial derivative type of "//TRIM(NumberToVString(partialDerivativeType,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FIELD_INTERPOLATE_LOCAL_FACE_GAUSS")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATE_LOCAL_FACE_GAUSS",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATE_LOCAL_FACE_GAUSS

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a xi location to give an interpolated point. XI is the element location to be interpolated at. partialDerivativeType controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated. Old CMISS name PXI
  SUBROUTINE FIELD_INTERPOLATE_XI(partialDerivativeType,XI,INTERPOLATED_POINT,err,error,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the provide field interpolation
    REAL(DP), INTENT(IN) :: XI(:) !<XI(ni). The ni'th Xi coordinate to evaluate the field at
    TYPE(FieldInterpolatedPointType), POINTER :: INTERPOLATED_POINT !<The pointer to the interpolated point which will contain the field interpolation information at the specified Xi point
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,ni,nu,startComponentIdx,endComponentIdx
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_INTERPOLATE_XI",err,error,*999)

    IF(.NOT.ASSOCIATED(INTERPOLATED_POINT)) CALL FlagError("Interpolated point is not associated.",err,error,*999)
    NULLIFY(INTERPOLATION_PARAMETERS)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(INTERPOLATED_POINT,INTERPOLATION_PARAMETERS,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
!!TODO: Fix this check. You can have less Xi directions than the mesh number of dimensions e.g., interpolating a line
    !IF(SIZE(XI,1)>=INTERPOLATION_PARAMETERS%FIELD%DECOMPOSITION%MESH%numberOfDimensions) THEN
    NULLIFY(COORDINATE_SYSTEM)
    CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    SELECT CASE(partialDerivativeType)
    CASE(NO_PART_DERIV)
      DO component_idx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)              
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
            & BASES(component_idx)%ptr,NO_PART_DERIV,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
          IF(err/=0) GOTO 999
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",err,error))//"."
        END SELECT
        CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
          & err,error,*999)
      ENDDO !component_idx
      INTERPOLATED_POINT%partialDerivativeType=NO_PART_DERIV
    CASE(FIRST_PART_DERIV)
      DO component_idx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
            nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !ni
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
            nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !ni
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
            & BASES(component_idx)%ptr,NO_PART_DERIV,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),err,error)
          IF(err/=0) GOTO 999
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process all the first partial derivatives
          DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfXi
            nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
            INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
              & BASES(component_idx)%ptr,nu,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx), &
              & err,error)
            IF(err/=0) GOTO 999
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !ni
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",err,error))//"."
        END SELECT
      ENDDO !component_idx
      INTERPOLATED_POINT%partialDerivativeType=FIRST_PART_DERIV
    CASE(SECOND_PART_DERIV)
      DO component_idx=startComponentIdx,endComponentIdx
        SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfPartialDerivatives
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !nu
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          !Handle the first case of no partial derivative
          INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
          CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
            & err,error,*999)
          !Now process the rest of partial derivatives
          DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfPartialDerivatives
            INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO !nu
        CASE(FIELD_NODE_BASED_INTERPOLATION)              
          DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr%numberOfPartialDerivatives
            INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
              & BASES(component_idx)%ptr,nu,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx), &
              & err,error)
            IF(err/=0) GOTO 999
            CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
              & err,error,*999)
          ENDDO! nu
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))// &
            & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",err,error))//"."
        END SELECT
      ENDDO !component_idx
      INTERPOLATED_POINT%partialDerivativeType=SECOND_PART_DERIV
    CASE DEFAULT
      localError="The partial derivative type of "//TRIM(NumberToVString(partialDerivativeType,"*",err,error))// &
        & " is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    !ELSE
    !  localError="Invalid number of Xi directions. The supplied Xi has "// &
    !    & TRIM(NumberToVString(SIZE(XI,1),"*",err,error))//" directions and the required number of directions is "// &
    !    & TRIM(NumberToVString(INTERPOLATED_POINT%interpolationParameters%FIELD%DECOMPOSITION%MESH%numberOfDimensions, &
    !    & "*",err,error))
    !  CALL FlagError(localError,err,error,*999)
    !ENDIF

    EXITS("FIELD_INTERPOLATE_XI")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATE_XI",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATE_XI

  !
  !================================================================================================================================
  !

  !>Computes the geometric position, normal and tangent vectors at a interpolated point metrics in a field. 
  SUBROUTINE Field_PositionNormalTangentsCalculateIntPtMetric(interpolatedPointMetrics,reverseNormal,position,normal,tangents, &
    & err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointMetricsType), POINTER, INTENT(IN) :: interpolatedPointMetrics !<A pointer to the interpolated point metric information to calculate the position etc. for
    LOGICAL, INTENT(IN) :: reverseNormal !<Reverse normal diretion if .TRUE.
    REAL(DP), INTENT(OUT) :: position(:) !<position(coordinate_idx), on exit the geometric position of the node
    REAL(DP), INTENT(OUT) :: normal(:) !<normal(coordinate_idx), on exit the normal vector
    REAL(DP), INTENT(OUT) :: tangents(:,:) !<tangents(coordinate_idx,tangent_idx), on exit the tangent vectors for the tangent_idx'th tangent at the node. There are number_of_xi-1 tangent vectors.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: coordinateIdx,numberOfXDimensions,numberOfXiDimensions,xiIdx
    TYPE(FieldInterpolatedPointType), POINTER :: interpolatedPoint
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_PositionNormalTangentsCalculateIntPtMetric",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolatedPointMetrics)) CALL FlagError("Interpolated point metrics is not associated.",err,error,*999)
    numberOfXDimensions=interpolatedPointMetrics%numberOfXDimensions
    numberOfXiDimensions=interpolatedPointMetrics%numberOfXiDimensions
    IF(SIZE(position,1)<numberOfXDimensions) THEN
      localError="The size of position of "//TRIM(NumberToVString(SIZE(position,1),"*",err,error))// &
        & " is too small. The size must be >= "//TRIM(NumberToVString(numberOfXDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)          
    ENDIF
    IF(SIZE(normal,1)<numberOfXDimensions) THEN
      localError="The size of normal of "//TRIM(NumberToVString(SIZE(normal,1),"*",err,error))// &
        & " is too small. The size must be >= "//TRIM(NumberToVString(numberOfXDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(tangents,1)<numberOfXDimensions) THEN
      localError="The size of the 1st dimension of tangents of "// &
        & TRIM(NumberToVString(SIZE(tangents,1),"*",err,error))//" is too small. The size must be >= "// &
        & TRIM(NumberToVString(numberOfXDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(tangents,2)<numberOfXiDimensions) THEN
      localError="The size of the 2nd dimension of tangents of "// &
        & TRIM(NumberToVString(SIZE(tangents,2),"*",err,error))//" is too small. The size must be >= "// &
        & TRIM(NumberToVString(numberOfXiDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    interpolatedPoint=>interpolatedPointMetrics%interpolatedPoint
    IF(.NOT.ASSOCIATED(interpolatedPoint)) &
      & CALL FlagError("Interpolated point metrics interpolated point is not associated.",err,error,*999)

    position(1:numberOfXDimensions)=interpolatedPoint%values(1:numberOfXDimensions,NO_PART_DERIV)
    normal(1:numberOfXDimensions)=0.0_DP
    SELECT CASE(numberOfXiDimensions)
    CASE(1) !For lines
      normal(1:numberOfXDimensions)=0.0_DP
      DO coordinateIdx=1,numberOfXDimensions
        tangents(coordinateIdx,1)=interpolatedPointMetrics%dXdXi(coordinateIdx,1)
      ENDDO !coordinateIdx 
      CALL Normalise(tangents(1:numberOfXDimensions,1),tangents(1:numberOfXDimensions,1),err,error,*999)
      SELECT CASE(numberOfXDimensions)
      CASE(2)
        normal(1)=-tangents(2,1)
        normal(2)=tangents(1,1)
      CASE(3)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="The number of coordinate dimensions of "//TRIM(NumberToVString(numberOfXDimensions,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(2) !For faces
      DO xiIdx=1,numberOfXiDimensions
        DO coordinateIdx=1,numberOfXDimensions
          tangents(coordinateIdx,xiIdx)=interpolatedPointMetrics%dXdXi(coordinateIdx,xiIdx)
        ENDDO !coordinateIdx
        CALL Normalise(tangents(1:numberOfXDimensions,xiIdx),tangents(1:numberOfXDimensions,xiIdx),err,error,*999)
      ENDDO !xiIdx
      CALL CrossProduct(tangents(1:numberOfXDimensions,1),tangents(1:numberOfXDimensions,2),normal,err,error,*999)
    CASE DEFAULT
      localError="The interpolated metrics must be for lines/faces, dimension of " &
        & //TRIM(NumberToVString(numberOfXiDimensions,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)    
    END SELECT
    IF(reverseNormal) normal(1:numberOfXDimensions)=-normal(1:numberOfXDimensions)

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolated point metrics data:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of X dimensions = ",numberOfXDimensions,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of Xi dimensions = ",numberOfXiDimensions,err,error,*999)
      CALL WriteStringVector(GENERAL_OUTPUT_TYPE,1,1,numberOfXDimensions,3,3,position, &
        & '("  Position    :",3(X,E13.6))','(15X,3(X,E13.6))',err,error,*999)
      CALL WriteStringVector(GENERAL_OUTPUT_TYPE,1,1,numberOfXDimensions,3,3,normal, &
        & '("  Normal      :",3(X,E13.6))','(15X,3(X,E13.6))',err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Tangents:",err,error,*999)
      DO xiIdx=1,numberOfXiDimensions
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Tangent : ",xiIdx,err,error,*999)
        CALL WriteStringVector(GENERAL_OUTPUT_TYPE,1,1,numberOfXDimensions,3,3,tangents(:,xiIdx), &
          & '("      Tangent :",3(X,E13.6))','(15X,3(X,E13.6))',err,error,*999)        
      ENDDO !xiIdx
    ENDIF

    EXITS("Field_PositionNormalTangentsCalculateIntPtMetric")
    RETURN
999 ERRORS("Field_PositionNormalTangentsCalculateIntPtMetric",err,error)
    EXITS("Field_PositionNormalTangentsCalculateIntPtMetric")
    RETURN 1

  END SUBROUTINE Field_PositionNormalTangentsCalculateIntPtMetric

  !
  !================================================================================================================================
  !

  !>Computes the geometric position, normal and tangent vectors at a node in a field. If the node is internal to the mesh the normal and tangents are zero.
  SUBROUTINE Field_PositionNormalTangentsCalculateNode(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LOCAL_NODE_NUMBER, &
    & POSITION,NORMAL,TANGENTS,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER, INTENT(IN) :: FIELD !<A pointer to the field to interpolate the geometric information for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The variable type of the node to compute the geometric information for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The component number of the node to compute the geometric information for
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to compute the geometric information for
    REAL(DP), INTENT(OUT) :: POSITION(:) !<POSITION(coordinate_idx), on exit the geometric position of the node
    REAL(DP), INTENT(OUT) :: NORMAL(:) !<NORMAL(coordinate_idx), on exit the normal vector
    REAL(DP), INTENT(OUT) :: TANGENTS(:,:) !<TANGENTS(coordinate_idx,tangent_idx), on exit the tangent vectors for the tangent_idx'th tangent at the node. There are number_of_xi-1 tangent vectors.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: DIMS,INDEX_MATCH
    INTEGER(INTG) :: nic,component_idx,derivative_idx,xi_idx,element,element_idx,local_node,local_node_idx
    REAL(DP) :: XI(3), VEC(3), DXDXI(3,3), NORMVEC(3) ! Note VEC, DXDXI sizes are fixed, but it doesn't matter so much
    INTEGER(INTG) :: tangent_idx,tangent_xi_idx
    TYPE(BasisType), POINTER :: BASIS
    TYPE(DomainType), POINTER :: DOMAIN
    TYPE(DomainElementsType), POINTER :: DOMAIN_ELEMENTS
    TYPE(DomainNodesType), POINTER :: DOMAIN_NODES
    TYPE(DomainTopologyType), POINTER :: TOPOLOGY
    TYPE(DecompositionType), POINTER :: DECOMPOSITION
    TYPE(DecompositionTopologyType), POINTER :: DECOMP_TOPOLOGY
    TYPE(DecompositionElementsType), POINTER :: DECOMP_ELEMENTS
    TYPE(FieldType), POINTER :: GEOMETRIC_FIELD
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(FieldInterpolationParametersPtrType), POINTER :: INTERPOLATION_PARAMETERS(:)
    TYPE(FieldInterpolatedPointPtrType), POINTER :: INTERPOLATED_POINTS(:)
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_PositionNormalTangentsCalculateNode",err,error,*999)

    NULLIFY(FIELD_VARIABLE)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(GEOMETRIC_FIELD)
    CALL Field_GeometricFieldGet(field,GEOMETRIC_FIELD,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    DIMS=GEOMETRIC_FIELD%variables(1)%numberOfComponents !\TODO: clean this up
    !               DIMS=FIELD_VARIABLE%numberOfComponents !\TODO: clean this up
    IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=DIMS) THEN
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(FIELD_VARIABLE,COMPONENT_NUMBER,domain,err,error,*999)
      NULLIFY(TOPOLOGY)
      CALL Domain_DomainTopologyGet(DOMAIN,TOPOLOGY,err,error,*999)
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(field,decomposition,err,error,*999)
      NULLIFY(DECOMP_TOPOLOGY)
      CALL Decomposition_DecompositionTopologyGet(decomposition,DECOMP_TOPOLOGY,err,error,*999)
      NULLIFY(DECOMP_ELEMENTS)
      CALL DecompositionTopology_DecompositionElementsGet(DECOMP_TOPOLOGY,DECOMP_ELEMENTS,err,error,*999)
      IF(SIZE(POSITION,1)>=DIMS) THEN
        IF(SIZE(NORMAL,1)>=DIMS) THEN
          IF(SIZE(TANGENTS,1)>=DIMS) THEN
            IF(SIZE(DXDXI,1)>=DIMS) THEN
              SELECT CASE(FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                localError="Cannot compute the normal at a node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))//" for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
                  & " which has constant interpolation."
                CALL FlagError(localError,err,error,*999)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                localError="Cannot compute the normal at a node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))//" for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" which has element based&
                  & interpolation."
                CALL FlagError(localError,err,error,*999)
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                NULLIFY(DOMAIN_ELEMENTS)
                CALL DomainTopology_DomainElementsGet(TOPOLOGY,DOMAIN_ELEMENTS,err,error,*999)
                NULLIFY(DOMAIN_NODES)
                CALL DomainTopology_DomainNodesGet(TOPOLOGY,DOMAIN_NODES,err,error,*999)
                IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=DOMAIN_NODES%numberOfNodes) THEN
                  !Normal & tangent will be calculated as averages in all surrounding elements. This is
                  !because there could be discontinuity in the surface gradients across elements.
                  POSITION(1:DIMS)=0.0_DP
                  DXDXI=0.0_DP
                  NORMAL(1:DIMS)=0.0_DP
                  CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(GEOMETRIC_FIELD, &
                    & INTERPOLATION_PARAMETERS,err,error,*999)
                  CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS, &
                    & INTERPOLATED_POINTS,err,error,*999)
                  DO element_idx=1,DOMAIN_NODES%nodes(LOCAL_NODE_NUMBER)%numberOfSurroundingElements
                    element=DOMAIN_NODES%nodes(LOCAL_NODE_NUMBER)%surroundingElements(element_idx)
                    NULLIFY(basis)
                    CALL DomainElements_BasisGet(DOMAIN_ELEMENTS,element,basis,err,error,*999)
                    !Find local node number in the basis
                    local_node=0
                    DO local_node_idx=1,BASIS%numberOfNodes
                      IF(DOMAIN_ELEMENTS%ELEMENTS(element)%elementNodes(local_node_idx)== &
                        & LOCAL_NODE_NUMBER) THEN
                        local_node=local_node_idx
                        EXIT
                      ENDIF
                    ENDDO !local_node_idx
                    !Find the xi position of the node in the element. In most cases this will be 0,1.0 etc
                    ! but in some cases the geometric field may not contain this node in which case xi can be
                    ! arbitrary
                    CALL BASIS_LOCAL_NODE_XI_CALCULATE(BASIS,local_node,XI,err,error,*999)
                    !Interpolate the geometric field at the xi position.
                    CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,element, &
                      & INTERPOLATION_PARAMETERS(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
                    CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,XI(1:BASIS%numberOfXi), &
                      & INTERPOLATED_POINTS(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
                    !Grab the position. This shouldn't vary between elements so do it once only
                    IF(element_idx==1) POSITION(1:DIMS)=INTERPOLATED_POINTS(FIELD_U_VARIABLE_TYPE)% &
                      & PTR%VALUES(1:DIMS,NO_PART_DERIV)
                    !Get DXDXI
                    !\todo: What if the surrounding elements have different number of xi? then DXDXI will be different in size.
                    !       Which one do we return in that case?
                    DO component_idx=1,DIMS
                      DO xi_idx=1,BASIS%numberOfXi
                        derivative_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx) !2,4,7
                        DXDXI(component_idx,xi_idx)=INTERPOLATED_POINTS(FIELD_U_VARIABLE_TYPE)%ptr% &
                          & VALUES(component_idx,derivative_idx) !dx/dxi
                      ENDDO
                    ENDDO
                    !Calculate the tangents and normal vectors
                    IF(DOMAIN_NODES%nodes(LOCAL_NODE_NUMBER)%boundaryNode) THEN
                      SELECT CASE(BASIS%TYPE)
                      CASE(BASIS_LAGRANGE_HERMITE_TP_TYPE)
                        DO nic=-BASIS%numberOfXiCoordinates,BASIS%numberOfXiCoordinates
                          IF(DECOMP_ELEMENTS%ELEMENTS(element)%adjacentElements(ABS(nic))% &
                            & numberOfAdjacentElements==0) THEN
                            IF(nic>0) THEN
                              INDEX_MATCH=BASIS%numberOfNodesXiC(ABS(nic))
                            ELSEIF(nic<0) THEN
                              INDEX_MATCH=1
                            ENDIF
                            IF(BASIS%nodePositionIndex(local_node,ABS(nic))==INDEX_MATCH) THEN
                              !1D/2D/3D: tangents and normal
                              SELECT CASE(BASIS%numberOfXi)
                              CASE(1)
                                !There are no tangents. We can provide a normal, but no need to sum
                                !and average, since in a 1D mesh, a boundary node won't be share
                                !with other elements.
                                NORMAL(1:DIMS)=DXDXI(1:DIMS,1)
                              CASE(2)
                                !One tangent vector, one normal vector
                                TANGENTS=0.0_DP
                                tangent_xi_idx=OTHER_XI_DIRECTIONS2(ABS(nic))
                                VEC(1:DIMS)=DXDXI(1:DIMS,tangent_xi_idx)
                                CALL Normalise(VEC(1:DIMS),VEC(1:DIMS),err,error,*999)
                                TANGENTS(1:DIMS,1)=TANGENTS(1:DIMS,1)+ &
                                  & VEC(1:DIMS)
                                !Normal is the other component in DXDXI (correct?) Ensure the
                                !direction is outward
                                VEC(1:DIMS)=DXDXI(1:DIMS,ABS(nic))
                                IF(nic<0) VEC=-VEC
                                CALL Normalise(VEC(1:DIMS),NORMVEC(1:DIMS),err,error,*999)
                                NORMAL(1:DIMS)=NORMAL(1:DIMS)+ NORMVEC(1:DIMS)
                              CASE(3)
                                !Two tangent vectors, one normal vector
                                TANGENTS=0.0_DP
                                DO tangent_idx=1,2
                                  tangent_xi_idx=OTHER_XI_DIRECTIONS3(ABS(nic),tangent_idx+1,1)
                                  VEC(1:DIMS)=DXDXI(1:DIMS,tangent_xi_idx)
                                  CALL Normalise(VEC(1:DIMS),VEC(1:DIMS),err,error,*999)
                                  TANGENTS(1:DIMS,tangent_idx)= &
                                    & TANGENTS(1:DIMS,tangent_idx)+VEC(1:DIMS)
                                ENDDO
                                !Calculate the normal vector
                                CALL CrossProduct(TANGENTS(1:DIMS,1),TANGENTS(1:DIMS,2), &
                                  & VEC(1:DIMS),err,error,*999)
                                !Yes below is compicated, but that's what it takes to get the normals pointing outwards
                                IF(nic<0) VEC=-VEC
                                IF(ABS(nic)==2) VEC=-VEC
                                NORMAL(1:DIMS)=NORMAL(1:DIMS)+VEC(1:DIMS)
                              CASE DEFAULT
                                !Should never happen anyway
                              END SELECT
                            ENDIF
                          ENDIF
                        ENDDO !nic
                      CASE(BASIS_SIMPLEX_TYPE)
                        CALL FlagError("Not implemented.",err,error,*999)
                        !                                               DO nic=1,BASIS%numberOfXiCoordinates
                        !                                                 IF(DOMAIN_ELEMENTS%ELEMENTS(element)%adjacentElements(nic)% &
                        !                                                   & numberOfAdjacentElements==0) THEN
                        !                                                   IF(BASIS%nodePositionIndex(local_node,nic)==1) THEN
                        !                                                     !Area coordinates
                        !                                                     SELECT CASE(BASIS%NUMBER-OF_XI)
                        !                                                     CASE(1)
                        !                                                       
                        !                                                     CASE(2)
                        !                                                       
                        !                                                     CASE(3)
                        !                                                       
                        !                                                     CASE DEFAULT
                        !                                                       !Will never happen anyway
                        !                                                     END SELECT
                        !                                                   ENDIF
                        !                                                 ENDIF
                        !                                               ENDDO !nic
                      CASE(BASIS_SERENDIPITY_TYPE)
                        CALL FlagError("Not implemented.",err,error,*999)
                      CASE(BASIS_AUXILLIARY_TYPE)
                        CALL FlagError("Not implemented.",err,error,*999)
                      CASE(BASIS_B_SPLINE_TP_TYPE)
                        CALL FlagError("Not implemented.",err,error,*999)
                      CASE(BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE)
                        CALL FlagError("Not implemented.",err,error,*999)
                      CASE(BASIS_EXTENDED_LAGRANGE_TP_TYPE)
                        CALL FlagError("Not implemented.",err,error,*999)
                      CASE DEFAULT
                        localError="The basis type of "//TRIM(NumberToVString(BASIS%TYPE, &
                          & "*",err,error))//" is invalid."
                        CALL FlagError(localError,err,error,*999)
                      END SELECT
                    ELSE
                      !Node is internal to the mesh. Assign zero normal and tangents
                      !Actually, they were already assigned to be zero at the start so do nothing.
                    ENDIF
                    !Calculate tangents from DXDXI: which xi corresponds to normal direction?
                  ENDDO !element_idx
                  CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINTS,err,error,*999)
                  CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,err,error,*999)

                  !Normalise the normal vector
                  CALL Normalise(NORMAL(1:DIMS),NORMAL(1:DIMS),err,error,*999)
                  !Normalise the tangent vectors
                  DO tangent_idx=1,BASIS%numberOfXi-1
                    CALL Normalise(TANGENTS(1:DIMS,tangent_idx),TANGENTS(1:DIMS,tangent_idx), &
                      & err,error,*999)
                  ENDDO
                ELSE
                  localError="The local node number of "// &
                    & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",err,error))// &
                    & " is invalid for component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))//" of variable type "// &
                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
                    & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
                    & ". The local node number must be > 0 and <="// &
                    & TRIM(NumberToVString(DOMAIN_NODES%numberOfNodes,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                localError="Cannot compute the normal at a node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))//" for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
                  & " which has grid point based interpolation."
                CALL FlagError(localError,err,error,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                localError="Cannot compute the normal at a node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))//" for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
                  & " which has Gauss point based interpolation."
                CALL FlagError(localError,err,error,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                localError="Cannot compute the normal at a node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))//" for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
                  & " which has data point based interpolation."
                CALL FlagError(localError,err,error,*999)
              CASE DEFAULT
                localError="The interpolation type of "//TRIM(NumberToVString &
                  & (FIELD_VARIABLE%components(COMPONENT_NUMBER)%interpolationType,"*",err,error))// &
                  & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*", &
                  & err,error))//" for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              localError="The first dimension of the supplied dx/dxi array of "// &
                & TRIM(NumberToVString(SIZE(DXDXI,1),"*",err,error))// &
                & " is too small. The first dimension of the supplied array must be >= "// &
                & TRIM(NumberToVString(DIMS,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The first dimension of the supplied tangent array of "// &
              & TRIM(NumberToVString(SIZE(TANGENTS,1),"*",err,error))// &
              & " is too small. The first dimension of the supplied array must be >= "// &
              & TRIM(NumberToVString(DIMS,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The size of the supplied normal array of "//TRIM(NumberToVString(SIZE(NORMAL,1), &
            & "*",err,error))//" is too small. The size of the supplied array must be >= "// &
            & TRIM(NumberToVString(DIMS,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="The size of the supplied position array of "//TRIM(NumberToVString(SIZE(POSITION,1), &
          & "*",err,error))//" is too small. The size of the supplied array must be >= "// &
          & TRIM(NumberToVString(DIMS,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="The field component number of "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",err,error))// &
        & " for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
        & " is invalid. The component number must be > 0 and <= "// &
        & TRIM(NumberToVString(FIELD_VARIABLE%numberOfComponents,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Field normal at a node:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number      = ",FIELD%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Variable type     = ",VARIABLE_TYPE,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Component number  = ",COMPONENT_NUMBER,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Local node number = ",LOCAL_NODE_NUMBER,err,error,*999)
      CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,DIMS,3,3,POSITION, &
        & '("  Position          :",3(X,E13.6))','(21X,3(X,E13.6))',err,error,*999)      
      CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,DIMS,3,3,NORMAL, &
        & '("  Normal            :",3(X,E13.6))','(21X,3(X,E13.6))',err,error,*999)      
    ENDIF

    EXITS("Field_PositionNormalTangentsCalculateNode")
    RETURN
999 ERRORS("Field_PositionNormalTangentsCalculateNode",err,error)
    EXITS("Field_PositionNormalTangentsCalculateNode")
    RETURN 1

  END SUBROUTINE Field_PositionNormalTangentsCalculateNode

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point and deallocates all memory.
  SUBROUTINE FIELD_INTERPOLATED_POINT_FINALISE(INTERPOLATED_POINT,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointType), POINTER :: INTERPOLATED_POINT !<A pointer to the interpolated point to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_INTERPOLATED_POINT_FINALISE",err,error,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
      IF(ALLOCATED(INTERPOLATED_POINT%VALUES)) DEALLOCATE(INTERPOLATED_POINT%VALUES)
      DEALLOCATE(INTERPOLATED_POINT)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINT_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATED_POINT_FINALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATED_POINT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point for an interpolation parameters
  SUBROUTINE FIELD_INTERPOLATED_POINT_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINT,err,error,*,componentType)

    !Argument variables
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS !<A pointer to the interpolation parameters to initialise the interpolated point for
    TYPE(FieldInterpolatedPointType), POINTER :: INTERPOLATED_POINT !<On exit, A pointer to the interpolated point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,numberOfDimensions,numberOfComponents
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    ENTERS("FIELD_INTERPOLATED_POINT_INITIALISE",err,error,*999)

    IF(.NOT.ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    IF(ASSOCIATED(INTERPOLATED_POINT)) CALL FlagError("Interpolated point is already associated.",err,error,*998)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)

    ALLOCATE(INTERPOLATED_POINT,STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate interpolated point",err,error,*999)
    INTERPOLATED_POINT%interpolationParameters=>INTERPOLATION_PARAMETERS
    numberOfDimensions=decomposition%numberOfDimensions
    INTERPOLATED_POINT%maximumPartialDerivativeIndex=PARTIAL_DERIVATIVE_MAXIMUM_MAP(numberOfDimensions)
    !Calculate the number of components for the interpolated point
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        numberOfComponents=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          numberOfComponents=geometricVariable%numberOfComponents
        ELSEIF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          numberOfComponents=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          numberOfComponents=fieldVariable%numberOfComponents-geometricVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE !.NOT.(PRESENT(componentType)) -default all components
      numberOfComponents=fieldVariable%numberOfComponents
    ENDIF
    ALLOCATE(INTERPOLATED_POINT%VALUES(numberOfComponents,INTERPOLATED_POINT%maximumPartialDerivativeIndex),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate interpolated point values.",err,error,*999)
    INTERPOLATED_POINT%VALUES=0.0_DP

    EXITS("FIELD_INTERPOLATED_POINT_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATED_POINT_FINALISE(INTERPOLATED_POINT,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INTERPOLATED_POINT_INITIALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATED_POINT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point and deallocates all memory.
  SUBROUTINE FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINTS,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointPtrType), POINTER :: INTERPOLATED_POINTS(:) !<A pointer to the interpolated point to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    ENTERS("FIELD_INTERPOLATED_POINTS_FINALISE",err,error,*999)

    IF(ASSOCIATED(INTERPOLATED_POINTS)) THEN
      DO var_type_idx=1,SIZE(INTERPOLATED_POINTS,1)
        CALL FIELD_INTERPOLATED_POINT_FINALISE(INTERPOLATED_POINTS(var_type_idx)%ptr,err,error,*999)
      ENDDO !var_type_idx
      DEALLOCATE(INTERPOLATED_POINTS)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINTS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATED_POINTS_FINALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATED_POINTS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point for an interpolation parameters
  SUBROUTINE FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINTS,err,error,*,componentType)

    !Argument variables
    TYPE(FieldInterpolationParametersPtrType), POINTER :: INTERPOLATION_PARAMETERS(:) !<A pointer to the interpolation parameters to initialise the interpolated point for
    TYPE(FieldInterpolatedPointPtrType), POINTER :: INTERPOLATED_POINTS(:) !<On exit, A pointer to the interpolated point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,var_type_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("FIELD_INTERPOLATED_POINTS_INITIALISE",err,error,*998)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(ASSOCIATED(INTERPOLATED_POINTS)) THEN
        CALL FlagError("Interpolated point is already associated.",err,error,*998)
      ELSE
        ALLOCATE(INTERPOLATED_POINTS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate interpolated points",err,error,*999)
        DO var_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          NULLIFY(INTERPOLATED_POINTS(var_type_idx)%ptr)
          IF(ASSOCIATED(INTERPOLATION_PARAMETERS(var_type_idx)%ptr)) THEN
            IF(PRESENT(componentType)) THEN
              CALL FIELD_INTERPOLATED_POINT_INITIALISE(INTERPOLATION_PARAMETERS(var_type_idx)%ptr, &
                & INTERPOLATED_POINTS(var_type_idx)%ptr,err,error,*999,componentType)
            ELSE
              CALL FIELD_INTERPOLATED_POINT_INITIALISE(INTERPOLATION_PARAMETERS(var_type_idx)%ptr, &
                & INTERPOLATED_POINTS(var_type_idx)%ptr,err,error,*999)
            ENDIF
          ENDIF
        ENDDO !var_type_idx
      ENDIF
    ELSE
      CALL FlagError("Interpolation parameters is not associated.",err,error,*998)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINTS_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINTS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INTERPOLATED_POINTS_INITIALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATED_POINTS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Calculates the interpolated point metrics and the associated interpolated point
  SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_CALCULATE(jacobianType,INTERPOLATED_POINT_METRICS,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: INTERPOLATED_POINT_METRICS !<A pointer to the interpolated point metrics
    INTEGER(INTG), INTENT(IN) :: jacobianType !<The Jacobian type of the calculation \see COORDINATE_ROUTINES_JacobianTypes,COORDINATE_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(FieldType), POINTER :: FIELD
    TYPE(FieldInterpolatedPointType), POINTER :: INTERPOLATED_POINT
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("FIELD_INTERPOLATED_POINT_METRICS_CALCULATE",err,error,*999)

    IF(.NOT.ASSOCIATED(INTERPOLATED_POINT_METRICS)) CALL FlagError("Interpolated point metrics is not associated.",err,error,*999)
    NULLIFY(INTERPOLATED_POINT)
    CALL FieldInterpolatedPointMetrics_InterpolatedPointGet(INTERPOLATED_POINT_METRICS,INTERPOLATED_POINT,err,error,*999)
    NULLIFY(INTERPOLATION_PARAMETERS)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(INTERPOLATED_POINT,INTERPOLATION_PARAMETERS,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    INTERPOLATED_POINT_METRICS%numberOfXiDimensions=INTERPOLATION_PARAMETERS%numberOfXi
    IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE.OR.FIELD%TYPE==FIELD_FIBRE_TYPE.OR.FIELD%TYPE==FIELD_GENERAL_TYPE &
      & .OR.FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
      NULLIFY(COORDINATE_SYSTEM)
      CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,err,error,*999)
      CALL COORDINATE_METRICS_CALCULATE(COORDINATE_SYSTEM,jacobianType,INTERPOLATED_POINT_METRICS,err,error,*999)
    ELSE
      CALL FlagError("The field is not a geometric or fibre field.",err,error,*999)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINT_METRICS_CALCULATE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATED_POINT_METRICS_CALCULATE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point metrics and deallocates all memory.
  SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_FINALISE(INTERPOLATED_POINT_METRICS,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: INTERPOLATED_POINT_METRICS !<A pointer to the interpolated point metrics to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_INTERPOLATED_POINT_METRICS_FINALISE",err,error,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) THEN
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%GL)) DEALLOCATE(INTERPOLATED_POINT_METRICS%GL)
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%GU)) DEALLOCATE(INTERPOLATED_POINT_METRICS%GU)
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%dXdXi)) DEALLOCATE(INTERPOLATED_POINT_METRICS%dXdXi)
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%dXidX)) DEALLOCATE(INTERPOLATED_POINT_METRICS%dXidX)
      DEALLOCATE(INTERPOLATED_POINT_METRICS)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINT_METRICS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATED_POINT_METRICS_FINALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point metrics for an interpolated point.
  SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_INITIALISE(INTERPOLATED_POINT,INTERPOLATED_POINT_METRICS,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointType), POINTER :: INTERPOLATED_POINT !A pointer to the interpolated point to initliase the interpolated point metrics for
    TYPE(FieldInterpolatedPointMetricsType), POINTER :: INTERPOLATED_POINT_METRICS !<On exit, a pointer to the interpolated point metrics that have been initialised
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: numberOfXiDimensions,numberOfXDimensions
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field
    TYPE(FieldInterpolationParametersType), POINTER :: interpolationParameters
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: DUMMY_ERROR !,localError

    ENTERS("FIELD_INTERPOLATED_POINT_METRICS_INITIALISE",err,error,*998)

    IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) CALL FlagError("Interpolated point metrics is already associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(INTERPOLATED_POINT)) CALL FlagError("Interpolated point is not associated.",err,error,*999)

    NULLIFY(interpolationParameters)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(INTERPOLATED_POINT,interpolationParameters,err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(interpolationParameters,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(COORDINATE_SYSTEM)
    CALL FIELD_COORDINATE_SYSTEM_GET(field,COORDINATE_SYSTEM,err,error,*999)
    numberOfXDimensions=COORDINATE_SYSTEM%numberOfDimensions
    numberOfXiDimensions=decomposition%numberOfDimensions
    !Size of interpolated point values may be greater than number of x dimensions, as FIELD_GEOMETRIC_GENERAL_TYPE
    !fields can have geometric components and then other non-geometric components, eg. for dependent fields with
    !geometric components.
    IF(numberOfXDimensions<=SIZE(INTERPOLATED_POINT%VALUES,1)) THEN
      ALLOCATE(INTERPOLATED_POINT_METRICS,STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate interpolated point metrics.",err,error,*999)
      ALLOCATE(INTERPOLATED_POINT_METRICS%GL(numberOfXiDimensions,numberOfXiDimensions),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate interpolated point metrics convariant tensor.",err,error,*999)
      ALLOCATE(INTERPOLATED_POINT_METRICS%GU(numberOfXiDimensions,numberOfXiDimensions),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate interpolated point metrics contravariant tensor.",err,error,*999)
      ALLOCATE(INTERPOLATED_POINT_METRICS%dXdXi(numberOfXDimensions,numberOfXiDimensions),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate interpolated point metrics dX_dXi.",err,error,*999)
      ALLOCATE(INTERPOLATED_POINT_METRICS%dXidX(numberOfXiDimensions,numberOfXDimensions),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate interpolated point metrics dXi_dX.",err,error,*999)
      INTERPOLATED_POINT_METRICS%interpolatedPoint=>INTERPOLATED_POINT
      INTERPOLATED_POINT_METRICS%numberOfXDimensions=numberOfXDimensions
      INTERPOLATED_POINT_METRICS%numberOfXiDimensions=numberOfXiDimensions
      INTERPOLATED_POINT_METRICS%GL=0.0_DP
      INTERPOLATED_POINT_METRICS%GU=0.0_DP
      INTERPOLATED_POINT_METRICS%dXdXi=0.0_DP
      INTERPOLATED_POINT_METRICS%dXidX=0.0_DP
      INTERPOLATED_POINT_METRICS%jacobian=0.0_DP
      INTERPOLATED_POINT_METRICS%jacobianType=0
      !For now don't flag an error if the number of xi dimensions doesn't match the number of x dimensions.
      !Simply do not allocate the metrics information.
      !        ELSE
      !          localError="The number of coordinate dimensions ("//TRIM(NumberToVString(numberOfXDimensions,"*",err,error))// &
      !            & ") does not match the number of components of the interpolated point ("// &
      !            & TRIM(NumberToVString(SIZE(INTERPOLATED_POINT%VALUES,1),"*",err,error))//")."
      !          CALL FlagError(localError,err,error,*998)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINT_METRICS_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATED_POINT_METRICS_FINALISE(INTERPOLATED_POINT_METRICS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INTERPOLATED_POINT_METRICS_INITIALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point metrics and deallocates all memory.
  SUBROUTINE Field_InterpolatedPointsMetricsFinalise(INTERPOLATED_POINTS_METRICS,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointMetricsPtrType), POINTER :: INTERPOLATED_POINTS_METRICS(:) !<A pointer to the interpolated point metrics to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    ENTERS("Field_InterpolatedPointsMetricsFinalise",err,error,*999)

    IF(ASSOCIATED(INTERPOLATED_POINTS_METRICS)) THEN
      DO var_type_idx=1,SIZE(INTERPOLATED_POINTS_METRICS,1)
        CALL FIELD_INTERPOLATED_POINT_METRICS_FINALISE(INTERPOLATED_POINTS_METRICS(var_type_idx)%ptr,err,error,*999)
      ENDDO !var_type_idx
      DEALLOCATE(INTERPOLATED_POINTS_METRICS)
    ENDIF

    EXITS("Field_InterpolatedPointsMetricsFinalise")
    RETURN
999 ERRORSEXITS("Field_InterpolatedPointsMetricsFinalise",err,error)
    RETURN 1
  END SUBROUTINE Field_InterpolatedPointsMetricsFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point metrics for an interpolated point.
  SUBROUTINE Field_InterpolatedPointsMetricsInitialise(INTERPOLATED_POINTS,INTERPOLATED_POINTS_METRICS,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointPtrType), POINTER :: INTERPOLATED_POINTS(:) !A pointer to the interpolated pointS to initliase the interpolated point metrics for
    TYPE(FieldInterpolatedPointMetricsPtrType), POINTER :: INTERPOLATED_POINTS_METRICS(:) !<On exit, a pointer to the interpolated point metrics that have been initialised
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableTypeIdx,DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("Field_InterpolatedPointsMetricsInitialise",err,error,*999)

    IF(ASSOCIATED(INTERPOLATED_POINTS)) THEN
      IF(ASSOCIATED(INTERPOLATED_POINTS_METRICS)) THEN
        CALL FlagError("Interpolated point metrics is already associated.",err,error,*998)
      ELSE
        ALLOCATE(INTERPOLATED_POINTS_METRICS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate interpolated points metrics.",err,error,*999)
        !Nullify all pointers first so that finalise does not fail on error condition half way through the next loop
        DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          NULLIFY(INTERPOLATED_POINTS_METRICS(variableTypeIdx)%ptr)          
        ENDDO !variableTypeIdx
        DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          IF(ASSOCIATED(INTERPOLATED_POINTS(variableTypeIdx)%ptr)) &
            & CALL FIELD_INTERPOLATED_POINT_METRICS_INITIALISE(INTERPOLATED_POINTS(variableTypeIdx)%ptr, &
            & INTERPOLATED_POINTS_METRICS(variableTypeIdx)%ptr,err,error,*999)
        ENDDO !variableTypeIdx
      ENDIF
    ELSE
      CALL FlagError("Interpolation points is not associated.",err,error,*998)
    ENDIF

    EXITS("Field_InterpolatedPointsMetricsInitialise")
    RETURN
999 CALL Field_InterpolatedPointsMetricsFinalise(INTERPOLATED_POINTS_METRICS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("Field_InterpolatedPointsMetricsInitialise",err,error)
    RETURN 1
  END SUBROUTINE Field_InterpolatedPointsMetricsInitialise

  !
  !================================================================================================================================
  !

  !>Finalises the interpolation parameters and deallocates all memory
  SUBROUTINE FIELD_INTERPOLATION_PARAMETER_FINALISE(INTERPOLATION_PARAMETERS,err,error,*)

    !Argument variables
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS !<A pointer to the interpolation parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_INTERPOLATION_PARAMETER_FINALISE",err,error,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%BASES)) DEALLOCATE(INTERPOLATION_PARAMETERS%BASES)
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%numberOfParameters)) DEALLOCATE(INTERPOLATION_PARAMETERS%numberOfParameters)
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%PARAMETERS)) DEALLOCATE(INTERPOLATION_PARAMETERS%PARAMETERS)
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%scaleFactors)) DEALLOCATE(INTERPOLATION_PARAMETERS%scaleFactors)      
      DEALLOCATE(INTERPOLATION_PARAMETERS)
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETER_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETER_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETER_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolation parameters for all the variables in a field.
  SUBROUTINE FIELD_INTERPOLATION_PARAMETER_INITIALISE(FIELD_VARIABLE,INTERPOLATION_PARAMETERS,err,error,*,componentType)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE !<A pointer to the field to initialise the interpolation parameters for
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS !<On exit, a pointer to the initialised interpolation parameters. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,DUMMY_ERR,numberOfComponents

    TYPE(FieldType), POINTER :: FIELD
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    ENTERS("FIELD_INTERPOLATION_PARAMETER_INITIALISE",err,error,*998)

    IF(ASSOCIATED(FIELD_VARIABLE)) THEN
      FIELD=>FIELD_VARIABLE%FIELD
      IF(ASSOCIATED(FIELD)) THEN
        IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
          CALL FlagError("Interpolation parameters is already associated.",err,error,*998)
        ELSE
          ALLOCATE(INTERPOLATION_PARAMETERS,STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate an interpolation parameter.",err,error,*999)
          INTERPOLATION_PARAMETERS%FIELD=>FIELD
          INTERPOLATION_PARAMETERS%fieldVariable=>FIELD_VARIABLE
          INTERPOLATION_PARAMETERS%numberOfXi=0
          !Calculate the number of components required 
          IF(PRESENT(componentType)) THEN
            SELECT CASE(componentType)
            CASE(FIELD_ALL_COMPONENTS_TYPE)
              numberOfComponents=INTERPOLATION_PARAMETERS%fieldVariable%numberOfComponents
            CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD%geometricField%variableTypeMap(FIELD_U_VARIABLE_TYPE)%ptr% &
                  & numberOfComponents
              ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%fieldVariable%numberOfComponents
              ELSE
                localError="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",err,error))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%fieldVariable%numberOfComponents-INTERPOLATION_PARAMETERS% &
                  & FIELD%geometricField%variableTypeMap(FIELD_U_VARIABLE_TYPE)%ptr%numberOfComponents
              ELSE
                localError="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",err,error))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            CASE DEFAULT
              localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE
            numberOfComponents=INTERPOLATION_PARAMETERS%fieldVariable%numberOfComponents
          ENDIF
          ALLOCATE(INTERPOLATION_PARAMETERS%BASES(numberOfComponents),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate bases.",err,error,*999)
          ALLOCATE(INTERPOLATION_PARAMETERS%numberOfParameters(numberOfComponents),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate interpolation type.",err,error,*999)
          ALLOCATE(INTERPOLATION_PARAMETERS%PARAMETERS(FIELD_VARIABLE%maxNumberElementInterpolationParameters, &
            & numberOfComponents),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate parameters.",err,error,*999)
          INTERPOLATION_PARAMETERS%PARAMETERS=0.0_DP
          IF(FIELD%SCALINGS%scalingType/=FIELD_NO_SCALING) THEN
            ALLOCATE(INTERPOLATION_PARAMETERS%scaleFactors(FIELD_VARIABLE%maxNumberElementInterpolationParameters, &
              & numberOfComponents),STAT=err)
            IF(err/=0) CALL FlagError("Could not allocate scale factors.",err,error,*999)
            INTERPOLATION_PARAMETERS%scaleFactors=0.0_DP
          ENDIF
          DO component_idx=1,numberOfComponents
            NULLIFY(INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr)
          ENDDO !component_idx
          INTERPOLATION_PARAMETERS%numberOfParameters=0
        ENDIF
      ELSE
        CALL FlagError("Field variable field is not associated.",err,error,*998)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*998)
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETER_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATION_PARAMETER_FINALISE(INTERPOLATION_PARAMETERS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETER_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETER_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the interpolation parameters for a particular element. Old CMISS name XPXE, ZPZE
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(PARAMETER_SET_TYPE,ELEMENT_NUMBER,INTERPOLATION_PARAMETERS,err,error,*, &
    & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The field parameter set type to get the element parameters for
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER !<The element number to get the element parameters for
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,local_derivative_idx,version_idx,global_derivative_idx,element_node_idx,node_idx, &
      & element_parameter_idx,gaussIdx,dof_idx,node_scaling_dof_idx,scaling_idx,startComponentIdx,endComponentIdx
    REAL(DP), POINTER :: FIELD_PARAMETER_SET_DATA(:),SCALE_FACTORS(:)
    TYPE(BasisType), POINTER :: BASIS
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET",err,error,*999)

    IF(.NOT.ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(fieldVariable,PARAMETER_SET_TYPE,PARAMETER_SET,err,error,*999)
    NULLIFY(FIELD_PARAMETER_SET_DATA)
    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(COORDINATE_SYSTEM)
    CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSE IF(field%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%TYPE,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%TYPE,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    DO component_idx=startComponentIdx,endComponentIdx
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,component_idx,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      IF(ELEMENT_NUMBER>0.AND.ELEMENT_NUMBER<=domainElements%totalNumberOfElements) THEN
        NULLIFY(basis)
        CALL DomainElements_BasisGet(domainElements,ELEMENT_NUMBER,basis,err,error,*999)
        INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr=>BASIS
        IF(component_idx==1) THEN
          INTERPOLATION_PARAMETERS%numberOfXi=BASIS%numberOfXi
        ELSE
          IF(BASIS%numberOfXi/=INTERPOLATION_PARAMETERS%numberOfXi) &
            & CALL FlagError("Inconsistent number of xi directions???",err,error,*999)
        ENDIF
        SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          dof_idx=INTERPOLATION_PARAMETERS%fieldVariable%components(component_idx)%paramToDOFMap%constantParam2DOFMap
          INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
          INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          dof_idx=INTERPOLATION_PARAMETERS%fieldVariable%components(component_idx)%paramToDOFMap% &
            & elementParam2DOFMap%ELEMENTS(ELEMENT_NUMBER)
          INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
          INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          NULLIFY(domainNodes)
          CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
          INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=BASIS%numberOfElementParameters
          SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%scalingType)
          CASE(FIELD_NO_SCALING)
            DO element_node_idx=1,BASIS%numberOfNodes
              node_idx=domainElements%ELEMENTS(ELEMENT_NUMBER)%elementNodes(element_node_idx)
              DO local_derivative_idx=1,BASIS%numberOfDerivatives(element_node_idx)
                global_derivative_idx=domainElements%ELEMENTS(ELEMENT_NUMBER)%elementDerivatives( &
                  & local_derivative_idx,element_node_idx)
                version_idx=domainElements%ELEMENTS(ELEMENT_NUMBER)%elementVersions(local_derivative_idx, &
                  & element_node_idx)
                element_parameter_idx=BASIS%elementParameterIndex(local_derivative_idx,element_node_idx)
                dof_idx=INTERPOLATION_PARAMETERS%fieldVariable%components(component_idx)%paramToDOFMap% &
                  & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(global_derivative_idx)%VERSIONS(version_idx)
                INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
              ENDDO !local_derivative_idx
            ENDDO !element_node_idx
          CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
            scaling_idx=fieldVariable%components(component_idx)%scalingIndex
            NULLIFY(SCALE_FACTORS)
            CALL DistributedVector_DataGet(field%SCALINGS%SCALINGS(scaling_idx)%scaleFactors,SCALE_FACTORS,err,error,*999)
            DO element_node_idx=1,BASIS%numberOfNodes
              node_idx=domainElements%ELEMENTS(ELEMENT_NUMBER)%elementNodes(element_node_idx)
              DO local_derivative_idx=1,BASIS%numberOfDerivatives(element_node_idx)
                global_derivative_idx=domainElements%ELEMENTS(ELEMENT_NUMBER)%elementDerivatives( & 
                  & local_derivative_idx,element_node_idx)
                version_idx=domainElements%ELEMENTS(ELEMENT_NUMBER)%elementVersions( &
                  & local_derivative_idx,element_node_idx)
                element_parameter_idx=BASIS%elementParameterIndex(global_derivative_idx,element_node_idx)
                dof_idx=INTERPOLATION_PARAMETERS%fieldVariable%components(component_idx)%paramToDOFMap% &
                  & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(global_derivative_idx)%VERSIONS(version_idx)
                node_scaling_dof_idx= &
                  & domainNodes%nodes(node_idx)%DERIVATIVES(global_derivative_idx)%dofIndex(version_idx)
                !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%scaleFactors(element_parameter_idx,ELEMENT_NUMBER)
                !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%scaleFactors(global_derivative_idx,node_idx)
                INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA( &
                  & dof_idx)*SCALE_FACTORS(node_scaling_dof_idx)
                INTERPOLATION_PARAMETERS%scaleFactors(element_parameter_idx,component_idx)=SCALE_FACTORS( &
                  & node_scaling_dof_idx)
              ENDDO !local_derivative_idx
            ENDDO !element_node_idx
            CALL DistributedVector_DataRestore(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
              & scaleFactors,SCALE_FACTORS,err,error,*999)
          CASE(FIELD_ARC_LENGTH_SCALING)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS% &
              & scalingType,"*",err,error))//" is invalid for field number "// &
              & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)                  
          INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=INTERPOLATION_PARAMETERS%fieldVariable% &
            & COMPONENTS(component_idx)%paramToDOFMap% gaussPointParam2DOFMap%numberOfGridPointParameters
          DO gaussIdx=1,BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%ptr%NUMBER_OF_GAUSS
            dof_idx=INTERPOLATION_PARAMETERS%fieldVariable%components(component_idx)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gaussIdx,ELEMENT_NUMBER)
            INTERPOLATION_PARAMETERS%PARAMETERS(gaussIdx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
          ENDDO !gaussIdx
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))//" is invalid for component number "// &
            & TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE
        localError="The element number of "//TRIM(NumberToVString(ELEMENT_NUMBER,"*",err,error))// &
          & " is invalid. The number must be between 1 and "// &
          & TRIM(NumberToVString(domainElements%totalNumberOfElements,"*",err,error))// &
          & " for component number "//TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ENDDO !component_idx
    CALL COORDINATE_INTERPOLATION_PARAMETERS_ADJUST(COORDINATE_SYSTEM,INTERPOLATION_PARAMETERS,err,error,*999)
    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,err,error,*999)

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",fieldVariable%variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",PARAMETER_SET_TYPE,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",ELEMENT_NUMBER,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",fieldVariable%numberOfComponents,err,error,*999)
      DO component_idx=startComponentIdx,endComponentIdx
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & numberOfParameters(component_idx),err,error,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%numberOfParameters(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET

  !
  !================================================================================================================================
  !

  !>Finalises the interpolation parameters and deallocates all memory
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,err,error,*)

    !Argument variables
    TYPE(FieldInterpolationParametersPtrType), POINTER :: INTERPOLATION_PARAMETERS(:) !<A pointer to the interpolation parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    ENTERS("FIELD_INTERPOLATION_PARAMETERS_FINALISE",err,error,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      DO var_type_idx=1,SIZE(INTERPOLATION_PARAMETERS,1)       
        CALL FIELD_INTERPOLATION_PARAMETER_FINALISE(INTERPOLATION_PARAMETERS(var_type_idx)%ptr,err,error,*999)
      ENDDO !var_type_idx           
      DEALLOCATE(INTERPOLATION_PARAMETERS)
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETERS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETERS_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolation parameters for all the variables in a field.
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATION_PARAMETERS,err,error,*,componentType)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the interpolation parameters for
    TYPE(FieldInterpolationParametersPtrType), POINTER :: INTERPOLATION_PARAMETERS(:) !<On exit, a pointer to the initialised interpolation parameters.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,var_type_idx
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    ENTERS("FIELD_INTERPOLATION_PARAMETERS_INITIALISE",err,error,*998)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
          CALL FlagError("Interpolation parameters is already associated.",err,error,*998)
        ELSE
          ALLOCATE(INTERPOLATION_PARAMETERS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate the interpolation parameters.",err,error,*999)
          DO var_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
            NULLIFY(INTERPOLATION_PARAMETERS(var_type_idx)%ptr)
            FIELD_VARIABLE=>FIELD%variableTypeMap(var_type_idx)%ptr
            IF(PRESENT(componentType)) THEN
              IF(ASSOCIATED(FIELD_VARIABLE)) CALL FIELD_INTERPOLATION_PARAMETER_INITIALISE(FIELD_VARIABLE, &
                & INTERPOLATION_PARAMETERS(var_type_idx)%ptr,err,error,*999,componentType)
            ELSE
              IF(ASSOCIATED(FIELD_VARIABLE)) CALL FIELD_INTERPOLATION_PARAMETER_INITIALISE(FIELD_VARIABLE, &
                & INTERPOLATION_PARAMETERS(var_type_idx)%ptr,err,error,*999)
            ENDIF
          ENDDO !var_type_idx
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*998)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*998)
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETERS_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETERS_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the interpolation parameters for a particular line. Old CMISS name XPXE, ZPZE
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_LINE_GET(PARAMETER_SET_TYPE,LINE_NUMBER,INTERPOLATION_PARAMETERS,err,error,*, &
    & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The field parameter set type to get the line parameters for
    INTEGER(INTG), INTENT(IN) :: LINE_NUMBER !<The line number to get the line parameters for
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to get the interpolation parameters for
    !Local Variables
    INTEGER(INTG) :: component_idx,basis_derivative_idx,derivative_idx,basis_node_idx,version_idx,node_idx,element_parameter_idx, &
      & dof_idx,node_scaling_dof_idx,scaling_idx,startComponentIdx,endComponentIdx
    REAL(DP), POINTER :: FIELD_PARAMETER_SET_DATA(:),SCALE_FACTORS(:)
    TYPE(BasisType), POINTER :: BASIS
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(DistributedVectorType), POINTER :: scaleFactorsVector
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainLinesType), POINTER :: domainLines
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: FIELD,geometricField
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_INTERPOLATION_PARAMETERS_LINE_GET",err,error,*999)

    IF(.NOT.ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(fieldVariable,PARAMETER_SET_TYPE,PARAMETER_SET,err,error,*999)
    NULLIFY(FIELD_PARAMETER_SET_DATA)
    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(COORDINATE_SYSTEM)
    CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSEIF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    DO component_idx=startComponentIdx,endComponentIdx
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,component_idx,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainLines)
      CALL DomainTopology_DomainLinesGet(domainTopology,domainLines,err,error,*999)
      IF(LINE_NUMBER>0.AND.LINE_NUMBER<=domainLines%numberOfLines) THEN
        NULLIFY(basis)
        CALL DomainLines_BasisGet(domainLines,LINE_NUMBER,basis,err,error,*999)
        INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr=>BASIS
        IF(component_idx==1) THEN
          INTERPOLATION_PARAMETERS%numberOfXi=BASIS%numberOfXi
        ELSE
          IF(BASIS%numberOfXi/=INTERPOLATION_PARAMETERS%numberOfXi) &
            & CALL FlagError("Inconsistent number of xi directions???",err,error,*999)
        ENDIF
        SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          NULLIFY(domainNodes)
          CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
          INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=BASIS%numberOfElementParameters
          SELECT CASE(field%SCALINGS%scalingType)
          CASE(FIELD_NO_SCALING)
            DO basis_node_idx=1,BASIS%numberOfNodes
              node_idx=domainLines%LINES(LINE_NUMBER)%nodesInLine(basis_node_idx)
              DO basis_derivative_idx=1,BASIS%numberOfDerivatives(basis_node_idx)
                derivative_idx=domainLines%LINES(LINE_NUMBER)%derivativesInLine(1,basis_derivative_idx,basis_node_idx)
                version_idx=domainLines%LINES(LINE_NUMBER)%derivativesInLine(2,basis_derivative_idx,basis_node_idx)
                element_parameter_idx=BASIS%elementParameterIndex(basis_derivative_idx,basis_node_idx)
                dof_idx=fieldVariable%components(component_idx)%paramToDOFMap% &
                  & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
              ENDDO !basis_derivative_idx
            ENDDO !basis_node_idx
          CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
            scaling_idx=fieldVariable%components(component_idx)%scalingIndex
            NULLIFY(scaleFactorsVector)
            CALL Field_ScaleFactorsVectorGet(field,scaling_idx,scaleFactorsVector,err,error,*999)
            NULLIFY(SCALE_FACTORS)
            CALL DistributedVector_DataGet(scaleFactorsVector,SCALE_FACTORS,err,error,*999)
            DO basis_node_idx=1,BASIS%numberOfNodes
              node_idx=domainLines%LINES(LINE_NUMBER)%nodesInLine(basis_node_idx)
              DO basis_derivative_idx=1,BASIS%numberOfDerivatives(basis_node_idx)
                derivative_idx=domainLines%LINES(LINE_NUMBER)%derivativesInLine(1,basis_derivative_idx,basis_node_idx)
                version_idx=domainLines%LINES(LINE_NUMBER)%derivativesInLine(2,basis_derivative_idx,basis_node_idx)
                element_parameter_idx=BASIS%elementParameterIndex(basis_derivative_idx,basis_node_idx)
                dof_idx=fieldVariable%components(component_idx)%paramToDOFMap% &
                  & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                node_scaling_dof_idx= &
                  & domainNodes%nodes(node_idx)%DERIVATIVES(derivative_idx)%dofIndex(version_idx)
                !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%scaleFactors(derivative_idx,node_idx)
                INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)= &
                  & FIELD_PARAMETER_SET_DATA(dof_idx)*SCALE_FACTORS(node_scaling_dof_idx)
                INTERPOLATION_PARAMETERS%scaleFactors(element_parameter_idx,component_idx)= &
                  & SCALE_FACTORS(node_scaling_dof_idx)
              ENDDO !basis_derivative_idx
            ENDDO !basis_node_idx
            CALL DistributedVector_DataRestore(scaleFactorsVector,SCALE_FACTORS,err,error,*999)
          CASE(FIELD_ARC_LENGTH_SCALING)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The scaling type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
              & scalingType,"*",err,error))//" is invalid for field number "// &
              & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))//" is invalid for component number "// &
            & TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE
        localError="The line number of "//TRIM(NumberToVString(LINE_NUMBER,"*",err,error))// &
          & " is invalid. The number must be between 1 and "// &
          & TRIM(NumberToVString(domainLines%numberOfLines,"*",err,error))// &
          & " for component number "//TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)

      ENDIF
    ENDDO !component_idx
    CALL COORDINATE_INTERPOLATION_PARAMETERS_ADJUST(COORDINATE_SYSTEM,INTERPOLATION_PARAMETERS,err,error,*999)
    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,err,error,*999)

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%fieldVariable% &
        & variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",PARAMETER_SET_TYPE,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Line number = ",LINE_NUMBER,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Total number of components = ", &
        & INTERPOLATION_PARAMETERS%fieldVariable%numberOfComponents,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Interpolation number of components = ", &
        & endComponentIdx-startComponentIdx+1,err,error,*999)
      DO component_idx=startComponentIdx,endComponentIdx
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & numberOfParameters(component_idx),err,error,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%numberOfParameters(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETERS_LINE_GET")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETERS_LINE_GET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_LINE_GET

  !
  !================================================================================================================================
  !
  !>Gets the interpolation parameters for a particular face.
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FACE_GET(PARAMETER_SET_TYPE,FACE_NUMBER,INTERPOLATION_PARAMETERS,err,error,*, &
    & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The field parameter set type to get the face parameters for
    INTEGER(INTG), INTENT(IN) :: FACE_NUMBER !<The face number to get the face parameters for
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to get field interpolation parameters for
    !Local Variables
    INTEGER(INTG) :: component_idx,basis_derivative_idx,derivative_idx,version_idx,basis_node_idx,node_idx,element_parameter_idx, &
      & dof_idx,node_scaling_dof_idx,scaling_idx,startComponentIdx,endComponentIdx
    REAL(DP), POINTER :: FIELD_PARAMETER_SET_DATA(:),SCALE_FACTORS(:)
    TYPE(BasisType), POINTER :: BASIS
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(DistributedVectorType), POINTER :: scaleFactorsVector
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainFacesType), POINTER :: domainFaces
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: FIELD,geometricField
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_INTERPOLATION_PARAMETERS_FACE_GET",err,error,*999)

    IF(.NOT.ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(fieldVariable,PARAMETER_SET_TYPE,PARAMETER_SET,err,error,*999)
    NULLIFY(FIELD_PARAMETER_SET_DATA)
    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(COORDINATE_SYSTEM)
    CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,err,error,*999)
    IF(PRESENT(componentType)) THEN
      SELECT CASE(componentType)
      CASE(FIELD_ALL_COMPONENTS_TYPE)
        startComponentIdx=1
        endComponentIdx=fieldVariable%numberOfComponents
      CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=1
          endComponentIdx=geometricVariable%numberOfComponents
        ELSEIF(field%type==FIELD_GEOMETRIC_TYPE) THEN
          startComponentIdx=1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
        IF(field%type==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          NULLIFY(geometricField)
          CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
          NULLIFY(geometricVariable)
          CALL Field_VariableGet(geometricField,FIELD_U_VARIABLE_TYPE,geometricVariable,err,error,*999)
          startComponentIdx=geometricVariable%numberOfComponents+1
          endComponentIdx=fieldVariable%numberOfComponents
        ELSE
          localError="Field type "//TRIM(NumberToVString(field%type,"*",err,error))// &
            & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",err,error))//" is not valid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      startComponentIdx=1
      endComponentIdx=fieldVariable%numberOfComponents
    ENDIF
    DO component_idx=startComponentIdx,endComponentIdx
      NULLIFY(domain)
      CALL FieldVariable_ComponentDomainGet(fieldVariable,component_idx,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainFaces)
      CALL DomainTopology_DomainFacesGet(domainTopology,domainFaces,err,error,*999)
      IF(FACE_NUMBER>0.AND.FACE_NUMBER<=domainFaces%numberOfFaces) THEN
        NULLIFY(basis)
        CALL DomainFaces_BasisGet(domainFaces,FACE_NUMBER,basis,err,error,*999)
        INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr=>BASIS
        IF(component_idx==1) THEN
          INTERPOLATION_PARAMETERS%numberOfXi=BASIS%numberOfXi
        ELSE
          IF(BASIS%numberOfXi/=INTERPOLATION_PARAMETERS%numberOfXi) &
            & CALL FlagError("Inconsistent number of xi directions???",err,error,*999)
        ENDIF
        SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
        CASE(FIELD_CONSTANT_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_NODE_BASED_INTERPOLATION)
          NULLIFY(domainNodes)
          CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
          INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=BASIS%numberOfElementParameters
          SELECT CASE(field%SCALINGS%scalingType)
          CASE(FIELD_NO_SCALING)
            DO basis_node_idx=1,BASIS%numberOfNodes
              node_idx=domainFaces%FACES(FACE_NUMBER)%nodesInFace(basis_node_idx)
              DO basis_derivative_idx=1,BASIS%numberOfDerivatives(basis_node_idx)
                derivative_idx=domainFaces%FACES(FACE_NUMBER)%derivativesInFace(1,basis_derivative_idx,basis_node_idx)
                version_idx=domainFaces%FACES(FACE_NUMBER)%derivativesInFace(2,basis_derivative_idx,basis_node_idx)
                element_parameter_idx=BASIS%elementParameterIndex(basis_derivative_idx,basis_node_idx)
                dof_idx=INTERPOLATION_PARAMETERS%fieldVariable%components(component_idx)%paramToDOFMap% &
                  & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
              ENDDO !basis_derivative_idx
            ENDDO !basis_node_idx
          CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
            scaling_idx=INTERPOLATION_PARAMETERS%fieldVariable%components(component_idx)%scalingIndex
            NULLIFY(scaleFactorsVector)
            CALL Field_ScaleFactorsVectorGet(field,scaling_idx,scaleFactorsVector,err,error,*999)
            NULLIFY(SCALE_FACTORS)
            CALL DistributedVector_DataGet(scaleFactorsVector,SCALE_FACTORS,err,error,*999)
            DO basis_node_idx=1,BASIS%numberOfNodes
              node_idx=domainFaces%FACES(FACE_NUMBER)%nodesInFace(basis_node_idx)
              DO basis_derivative_idx=1,BASIS%numberOfDerivatives(basis_node_idx)
                derivative_idx=domainFaces%FACES(FACE_NUMBER)%derivativesInFace(1,basis_derivative_idx,basis_node_idx)
                version_idx=domainFaces%FACES(FACE_NUMBER)%derivativesInFace(2,basis_derivative_idx,basis_node_idx)
                element_parameter_idx=BASIS%elementParameterIndex(basis_derivative_idx,basis_node_idx)
                dof_idx=INTERPOLATION_PARAMETERS%fieldVariable%components(component_idx)%paramToDOFMap% &
                  & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                node_scaling_dof_idx= &
                  & domainNodes%nodes(node_idx)%DERIVATIVES(derivative_idx)%dofIndex(version_idx)
                !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%scaleFactors(derivative_idx,node_idx)
                INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)= &
                  & FIELD_PARAMETER_SET_DATA(dof_idx)*SCALE_FACTORS(node_scaling_dof_idx)
                INTERPOLATION_PARAMETERS%scaleFactors(element_parameter_idx,component_idx)= &
                  & SCALE_FACTORS(node_scaling_dof_idx)
              ENDDO !basis_derivative_idx
            ENDDO !basis_node_idx
            CALL DistributedVector_DataRestore(scaleFactorsVector,SCALE_FACTORS,err,error,*999)
          CASE(FIELD_ARC_LENGTH_SCALING)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS% &
              & scalingType,"*",err,error))//" is invalid for field number "// &
              & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%fieldVariable% &
            & COMPONENTS(component_idx)%interpolationType,"*",err,error))//" is invalid for component number "// &
            & TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE
        localError="The face number of "//TRIM(NumberToVString(FACE_NUMBER,"*",err,error))// &
          & " is invalid. The number must be between 1 and "// &
          & TRIM(NumberToVString(domainFaces%numberOfFaces,"*",err,error))// &
          & " for component number "//TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ENDDO !component_idx
    CALL COORDINATE_INTERPOLATION_PARAMETERS_ADJUST(COORDINATE_SYSTEM,INTERPOLATION_PARAMETERS,err,error,*999)
    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,err,error,*999)

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%fieldVariable% &
        & variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",PARAMETER_SET_TYPE,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Face number = ",FACE_NUMBER,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Total number of components = ", &
        & INTERPOLATION_PARAMETERS%fieldVariable%numberOfComponents,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Interpolation number of components = ", &
        & endComponentIdx-startComponentIdx+1,err,error,*999)
      DO component_idx=startComponentIdx,endComponentIdx
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & numberOfParameters(component_idx),err,error,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%numberOfParameters(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETERS_FACE_GET")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETERS_FACE_GET",err,error)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FACE_GET

  !
  !================================================================================================================================
  !

  !>Gets the interpolation scale factors for a particular element. 
  SUBROUTINE Field_InterpolationParametersScaleFactorsElementGet(ELEMENT_NUMBER,INTERPOLATION_PARAMETERS,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER !<The element number to get the element scale factors for
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,mk,nk,nn,np,ns,ny,scaling_idx,nv
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    TYPE(BasisType), POINTER :: BASIS
    TYPE(DistributedVectorType), POINTER :: scaleFactorsVector
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolationParametersScaleFactorsElementGet",err,error,*999)

    IF(.NOT.ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    SELECT CASE(field%SCALINGS%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not get the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      DO component_idx=1,fieldVariable%numberOfComponents
        NULLIFY(domain)
        CALL FieldVariable_ComponentDomainGet(fieldVariable,component_idx,domain,err,error,*999)
        NULLIFY(domainTopology)
        CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
        NULLIFY(domainElements)
        CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
        IF(ELEMENT_NUMBER>0.AND.ELEMENT_NUMBER<=domainElements%totalNumberOfElements) THEN
          NULLIFY(basis)
          CALL DomainElements_BasisGet(domainElements,ELEMENT_NUMBER,basis,err,error,*999)
          INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr=>BASIS
          SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
          CASE(FIELD_CONSTANT_INTERPOLATION)             
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            NULLIFY(domainNodes)
            CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=BASIS%numberOfElementParameters
            scaling_idx=fieldVariable%components(component_idx)%scalingIndex
            NULLIFY(scaleFactorsVector)
            CALL Field_ScaleFactorsVectorGet(field,scaling_idx,scaleFactorsVector,err,error,*999)
            NULLIFY(SCALE_FACTORS)
            CALL DistributedVector_DataGet(scaleFactorsVector,SCALE_FACTORS,err,error,*999)
            DO nn=1,BASIS%numberOfNodes
              np=domainElements%ELEMENTS(ELEMENT_NUMBER)%elementNodes(nn)
              DO mk=1,BASIS%numberOfDerivatives(nn)
                nk=domainElements%ELEMENTS(ELEMENT_NUMBER)%elementDerivatives(mk,nn)
                nv=domainElements%ELEMENTS(ELEMENT_NUMBER)%elementVersions(mk,nn)
                ns=BASIS%elementParameterIndex(mk,nn)
                ny=domainNodes%nodes(np)%DERIVATIVES(nk)%dofIndex(nv)
                INTERPOLATION_PARAMETERS%scaleFactors(ns,component_idx)=SCALE_FACTORS(ny)
              ENDDO !mk
            ENDDO !nn
            CALL DistributedVector_DataRestore(scaleFactorsVector,SCALE_FACTORS,err,error,*999)
          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE DEFAULT
            localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
              & COMPONENTS(component_idx)%interpolationType,"*",err,error))//" is invalid for component number "// &
              & TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
              & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          localError="The element number of "//TRIM(NumberToVString(ELEMENT_NUMBER,"*",err,error))// &
            & " is invalid. The number must be between 1 and "// &
            & TRIM(NumberToVString(domainElements%totalNumberOfElements,"*",err,error))// &
            & " for component number "//TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ENDDO !component_idx
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS% &
        & scalingType,"*",err,error))//" is invalid for field number "// &
        & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",fieldVariable%variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",ELEMENT_NUMBER,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",fieldVariable%numberOfComponents,err,error,*999)
      DO component_idx=1,fieldVariable%numberOfComponents
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & numberOfParameters(component_idx),err,error,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%numberOfParameters(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%scaleFactors(:,component_idx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("Field_InterpolationParametersScaleFactorsElementGet")
    RETURN
999 ERRORS("Field_InterpolationParametersScaleFactorsElementGet",err,error)
    EXITS("Field_InterpolationParametersScaleFactorsElementGet")
    RETURN 1

  END SUBROUTINE Field_InterpolationParametersScaleFactorsElementGet

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for a particular node.
  SUBROUTINE Field_ParameterSetNodeScaleFactorGet(field,variableType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,scaleFactor,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofNumber,scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    LOGICAL :: ghostDof
    TYPE(DistributedVectorType), POINTER :: fieldScaleFactorsVector
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorGet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    SELECT CASE(field%SCALINGS%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not get the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
      CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
        & dofNumber,ghostDof,err,error,*999)
      ! The field component number is used to determine which scaling index to use.
      ! The number of scaling indices are set based on the number of mesh components (not field components).
      scalingIdx=fieldVariable%components(componentNumber)%scalingIndex
      NULLIFY(fieldScaleFactorsVector)
      CALL Field_ScaleFactorsVectorGet(field,scalingIdx,fieldScaleFactorsVector,err,error,*999)
      NULLIFY(fieldScaleFactors)
      CALL DistributedVector_DataGet(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
      scaleFactor=fieldScaleFactors(dofNumber)
      CALL DistributedVector_DataRestore(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS%scalingType,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetNodeScaleFactorGet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorGet",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetNodeScaleFactorGet

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes.
  SUBROUTINE Field_ParameterSetNodeScaleFactorsGet(field,variableType,meshComponentNumber,scaleFactors,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factor for all nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(DistributedVectorType), POINTER :: fieldScaleFactorsVector
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorsGet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    SELECT CASE(field%SCALINGS%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not get the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
      !The numberOfScalingIndices is the same as the number of mesh components (not field components).  
      IF(meshComponentNumber>=1.AND.meshComponentNumber<=field%SCALINGS%numberOfScalingIndices) THEN
        scalingIdx=meshComponentNumber
        NULLIFY(fieldScaleFactorsVector)
        CALL Field_ScaleFactorsVectorGet(field,scalingIdx,fieldScaleFactorsVector,err,error,*999)
        NULLIFY(fieldScaleFactors)
        CALL DistributedVector_DataGet(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
        scaleFactors=fieldScaleFactors
        CALL DistributedVector_DataRestore(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
      ELSE
        localError="Mesh component number "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
          & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
          & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" which has "// &
          & TRIM(NumberToVString(field%SCALINGS%numberOfScalingIndices,"*",err,error))// &
          & " components."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS%scalingType,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetNodeScaleFactorsGet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorsGet",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetNodeScaleFactorsGet

  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs.
  SUBROUTINE Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<The field to get the number of scale factor dofs for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(DistributedVectorType), POINTER :: fieldScaleFactorsVector
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    SELECT CASE(field%SCALINGS%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not get the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
      !The numberOfScalingIndices is the same as the number of mesh components (not field components).  
      IF(meshComponentNumber>=1.AND.meshComponentNumber<=field%SCALINGS%numberOfScalingIndices) THEN
        scalingIdx=meshComponentNumber
        NULLIFY(fieldScaleFactorsVector)
        CALL Field_ScaleFactorsVectorGet(field,scalingIdx,fieldScaleFactorsVector,err,error,*999)
        NULLIFY(fieldScaleFactors)
        CALL DistributedVector_DataGet(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
        numberOfScaleFactorsDofs=SIZE(fieldScaleFactors,1)
        CALL DistributedVector_DataRestore(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
      ELSE
        localError="Mesh component number "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
          & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
          & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" which has "// &
          & TRIM(NumberToVString(field%SCALINGS%numberOfScalingIndices,"*",err,error))// &
          & " components."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS%scalingType,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet")
    RETURN
999 ERRORS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet",err,error)
    EXITS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet")
    RETURN 1

  END SUBROUTINE Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for a particular node.
  SUBROUTINE Field_ParameterSetNodeScaleFactorSet(field,variableType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,scaleFactor,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofNumber,scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    LOGICAL :: ghostDof
    TYPE(DistributedVectorType), POINTER :: fieldScaleFactorsVector
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorSet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    SELECT CASE(field%SCALINGS%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not set the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
      CALL FieldVariable_UserNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,userNodeNumber,componentNumber, &
        & dofNumber,ghostDof,err,error,*999)
      ! The field component number is used to determine which scaling index to use.
      ! The number of scaling indices are set based on the number of mesh components (not field components).
      scalingIdx=fieldVariable%components(componentNumber)%scalingIndex
      NULLIFY(fieldScaleFactorsVector)
      CALL Field_ScaleFactorsVectorGet(field,scalingIdx,fieldScaleFactorsVector,err,error,*999)
      NULLIFY(fieldScaleFactors)
      CALL DistributedVector_DataGet(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
      fieldScaleFactors(dofNumber)=scaleFactor
      CALL DistributedVector_DataRestore(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS%scalingType,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetNodeScaleFactorSet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorSet",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetNodeScaleFactorSet
  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes.
  SUBROUTINE Field_ParameterSetNodeScaleFactorsSet(field,variableType,meshComponentNumber,scaleFactors,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factor for all nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(DistributedVectorType), POINTER :: fieldScaleFactorsVector
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorsSet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    SELECT CASE(field%SCALINGS%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not set the scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
      !The numberOfScalingIndices is the same as the number of mesh components (not field components).  
      IF(meshComponentNumber>=1.AND.meshComponentNumber<=field%SCALINGS%numberOfScalingIndices) THEN
        scalingIdx=meshComponentNumber
        NULLIFY(fieldScaleFactorsVector)
        CALL Field_ScaleFactorsVectorGet(field,scalingIdx,fieldScaleFactorsVector,err,error,*999)
        NULLIFY(fieldScaleFactors)
        CALL DistributedVector_DataGet(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
        IF(SIZE(fieldScaleFactors,1)<=SIZE(scaleFactors,1)) THEN
          fieldScaleFactors(1:SIZE(scaleFactors,1)) = scaleFactors(1:SIZE(scaleFactors,1))
        ELSE
          localError="The input scale factors have dimensions "//TRIM(NumberToVString(SIZE(scaleFactors),"*",err,error)) &
            & //" and does not match the expected scale factor dimensions of "// &
            & TRIM(NumberToVString(SIZE(fieldScaleFactors),"*",err,error))
          CALL FlagError(localError,err,error,*999)
        ENDIF
        CALL DistributedVector_DataRestore(fieldScaleFactorsVector,fieldScaleFactors,err,error,*999)
      ELSE
        localError="Mesh component number "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
          & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
          & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" which has "// &
          & TRIM(NumberToVString(field%SCALINGS%numberOfScalingIndices,"*",err,error))// &
          & " components."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS%scalingType,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetNodeScaleFactorsSet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorsSet",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetNodeScaleFactorsSet

  !
  !================================================================================================================================
  !

  !>Gets the interpolation scale factors for a particular element. 
  SUBROUTINE Field_InterpolationParametersScaleFactorsLineGet(LINE_NUMBER,INTERPOLATION_PARAMETERS,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: LINE_NUMBER !<The line number to get the element scale factors for
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,mk,nk,nn,np,ns,ny,scaling_idx,nv
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    TYPE(BasisType), POINTER :: BASIS
    TYPE(DistributedVectorType), POINTER :: scaleFactorsVector
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainLinesType), POINTER :: domainLines
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolationParametersScaleFactorsLineGet",err,error,*999)

    IF(.NOT.ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    SELECT CASE(field%SCALINGS%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      DO component_idx=1,fieldVariable%numberOfComponents
        NULLIFY(domain)
        CALL FieldVariable_ComponentDomainGet(fieldVariable,component_idx,domain,err,error,*999)
        NULLIFY(domainTopology)
        CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
        NULLIFY(domainLines)
        CALL DomainTopology_DomainLinesGet(domainTopology,domainLines,err,error,*999)
        IF(LINE_NUMBER>0.AND.LINE_NUMBER<=domainLines%numberOfLines) THEN
          NULLIFY(basis)
          CALL DomainLines_BasisGet(domainLines,LINE_NUMBER,basis,err,error,*999)
          INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr=>BASIS
          IF(component_idx==1) THEN
            INTERPOLATION_PARAMETERS%numberOfXi=BASIS%numberOfXi
          ELSE
            IF(BASIS%numberOfXi/=INTERPOLATION_PARAMETERS%numberOfXi) &
              & CALL FlagError("Inconsistent number of xi directions???",err,error,*999)
          ENDIF
          SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
          CASE(FIELD_CONSTANT_INTERPOLATION)             
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            NULLIFY(domainNodes)
            CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=BASIS%numberOfElementParameters
            scaling_idx=fieldVariable%components(component_idx)%scalingIndex
            NULLIFY(scaleFactorsVector)
            CALL Field_ScaleFactorsVectorGet(field,scaling_idx,scaleFactorsVector,err,error,*999)
            NULLIFY(SCALE_FACTORS)
            CALL DistributedVector_DataGet(scaleFactorsVector,SCALE_FACTORS,err,error,*999)
            DO nn=1,BASIS%numberOfNodes
              np=domainLines%LINES(LINE_NUMBER)%nodesInLine(nn)
              DO mk=1,BASIS%numberOfDerivatives(nn)
                nk=domainLines%LINES(LINE_NUMBER)%derivativesInLine(1,mk,nn)
                nv=domainLines%LINES(LINE_NUMBER)%derivativesInLine(2,mk,nn)
                ns=BASIS%elementParameterIndex(mk,nn)
                ny=domainNodes%nodes(np)%DERIVATIVES(nk)%dofIndex(nv)
                INTERPOLATION_PARAMETERS%scaleFactors(ns,component_idx)=SCALE_FACTORS(ny)
              ENDDO !mk
            ENDDO !nn
            CALL DistributedVector_DataRestore(scaleFactorsVector,SCALE_FACTORS,err,error,*999)
          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE DEFAULT
            localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
              & COMPONENTS(component_idx)%interpolationType,"*",err,error))//" is invalid for component number "// &
              & TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
              & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          localError="The line number of "//TRIM(NumberToVString(LINE_NUMBER,"*",err,error))// &
            & " is invalid. The number must be between 1 and "// &
            & TRIM(NumberToVString(domainLines%numberOfLines,"*",err,error))// &
            & " for component number "//TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ENDDO !component_idx
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS% &
        & scalingType,"*",err,error))//" is invalid for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",fieldVariable%variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Line number = ",LINE_NUMBER,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",fieldVariable%numberOfComponents,err,error,*999)
      DO component_idx=1,fieldVariable%numberOfComponents
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & numberOfParameters(component_idx),err,error,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%numberOfParameters(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%scaleFactors(:,component_idx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("Field_InterpolationParametersScaleFactorsLineGet")
    RETURN
999 ERRORS("Field_InterpolationParametersScaleFactorsLineGet",err,error)
    EXITS("Field_InterpolationParametersScaleFactorsLineGet")
    RETURN 1

  END SUBROUTINE Field_InterpolationParametersScaleFactorsLineGet

  !
  !================================================================================================================================
  !

  !>Gets the interpolation scale factors for a particular element. 
  SUBROUTINE Field_InterpolationParametersScaleFactorsFaceGet(FACE_NUMBER,INTERPOLATION_PARAMETERS,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: FACE_NUMBER !<The face number to get the element scale factors for
    TYPE(FieldInterpolationParametersType), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,mk,nk,nn,np,ns,ny,scaling_idx,nv
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    TYPE(BasisType), POINTER :: BASIS
    TYPE(DistributedVectorType), POINTER :: scaleFactorsVector
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainFacesType), POINTER :: domainFaces
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldType), POINTER :: field
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_InterpolationParametersScaleFactorsFaceGet",err,error,*999)

    IF(.NOT.ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FlagError("Interpolation parameters is not associated.",err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    SELECT CASE(field%SCALINGS%scalingType)
    CASE(FIELD_NO_SCALING)
      CALL FlagError("Can not scale factors for a field with no scaling.",err,error,*999)
    CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
      DO component_idx=1,fieldVariable%numberOfComponents
        NULLIFY(domain)
        CALL FieldVariable_ComponentDomainGet(fieldVariable,component_idx,domain,err,error,*999)
        NULLIFY(domainTopology)
        CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
        NULLIFY(domainFaces)
        CALL DomainTopology_DomainFacesGet(domainTopology,domainFaces,err,error,*999)
        IF(FACE_NUMBER>0.AND.FACE_NUMBER<=domainFaces%numberOfFaces) THEN
          NULLIFY(basis)
          CALL DomainFaces_BasisGet(domainFaces,FACE_NUMBER,basis,err,error,*999)
          INTERPOLATION_PARAMETERS%BASES(component_idx)%ptr=>BASIS
          IF(component_idx==1) THEN
            INTERPOLATION_PARAMETERS%numberOfXi=BASIS%numberOfXi
          ELSE
            IF(BASIS%numberOfXi/=INTERPOLATION_PARAMETERS%numberOfXi) &
              & CALL FlagError("Inconsistent number of xi directions???",err,error,*999)
          ENDIF
          SELECT CASE(fieldVariable%components(component_idx)%interpolationType)
          CASE(FIELD_CONSTANT_INTERPOLATION)             
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            NULLIFY(domainNodes)
            CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=BASIS%numberOfElementParameters
            scaling_idx=INTERPOLATION_PARAMETERS%fieldVariable%components(component_idx)%scalingIndex
            NULLIFY(scaleFactorsVector)
            CALL Field_ScaleFactorsVectorGet(field,scaling_idx,scaleFactorsVector,err,error,*999)
            NULLIFY(SCALE_FACTORS)
            CALL DistributedVector_DataGet(scaleFactorsVector,SCALE_FACTORS,err,error,*999)
            DO nn=1,BASIS%numberOfNodes
              np=domainFaces%FACES(FACE_NUMBER)%nodesInFace(nn)
              DO mk=1,BASIS%numberOfDerivatives(nn)
                nk=domainFaces%FACES(FACE_NUMBER)%derivativesInFace(1,mk,nn)
                nv=domainFaces%FACES(FACE_NUMBER)%derivativesInFace(2,mk,nn)
                ns=BASIS%elementParameterIndex(mk,nn)
                ny=domainNodes%nodes(np)%DERIVATIVES(nk)%dofIndex(nv)
                INTERPOLATION_PARAMETERS%scaleFactors(ns,component_idx)=SCALE_FACTORS(ny)
              ENDDO !mk
            ENDDO !nn
            CALL DistributedVector_DataRestore(scaleFactorsVector,SCALE_FACTORS,err,error,*999)
          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
            INTERPOLATION_PARAMETERS%numberOfParameters(component_idx)=1
            INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
          CASE DEFAULT
            localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable% &
              & COMPONENTS(component_idx)%interpolationType,"*",err,error))//" is invalid for component number "// &
              & TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
              & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          localError="The face number of "//TRIM(NumberToVString(FACE_NUMBER,"*",err,error))// &
            & " is invalid. The number must be between 1 and "// &
            & TRIM(NumberToVString(domainFaces%numberOfFaces,"*",err,error))// &
            & " for component number "//TRIM(NumberToVString(component_idx,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ENDDO !component_idx
    CASE(FIELD_ARC_LENGTH_SCALING)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS% &
        & scalingType,"*",err,error))//" is invalid for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",field%userNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",fieldVariable%variableNumber,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Face number = ",FACE_NUMBER,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",fieldVariable%numberOfComponents,err,error,*999)
      DO component_idx=1,fieldVariable%numberOfComponents
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & numberOfParameters(component_idx),err,error,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%numberOfParameters(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%scaleFactors(:,component_idx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & err,error,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("Field_InterpolationParametersScaleFactorsFaceGet")
    RETURN
999 ERRORS("Field_InterpolationParametersScaleFactorsFaceGet",err,error)
    EXITS("Field_InterpolationParametersScaleFactorsFaceGet")
    RETURN 1

  END SUBROUTINE Field_InterpolationParametersScaleFactorsFaceGet

  !
  !================================================================================================================================
  !

  !>Finalises the physical point and deallocates all memory.
  SUBROUTINE FIELD_PHYSICAL_POINT_FINALISE(PHYSICAL_POINT,err,error,*)

    !Argument variables
    TYPE(FieldPhysicalPointType), POINTER :: PHYSICAL_POINT !<A pointer to the physical point to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_PHYSICAL_POINT_FINALISE",err,error,*999)

    IF(ASSOCIATED(PHYSICAL_POINT)) THEN
      IF(ALLOCATED(PHYSICAL_POINT%VALUES)) DEALLOCATE(PHYSICAL_POINT%VALUES)
      DEALLOCATE(PHYSICAL_POINT)
    ENDIF

    EXITS("FIELD_PHYSICAL_POINT_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_PHYSICAL_POINT_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_PHYSICAL_POINT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the physical point for interpolated points
  SUBROUTINE FIELD_PHYSICAL_POINT_INITIALISE(FIELD_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT,PHYSICAL_POINT, &
    & err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointType), POINTER :: FIELD_INTERPOLATED_POINT !<A pointer to the field interpolation point to initialise the physical point for
    TYPE(FieldInterpolatedPointType), POINTER :: GEOMETRIC_INTERPOLATED_POINT !<A pointer to the geometric field interpolated point to initialise the physical point for
    TYPE(FieldPhysicalPointType), POINTER :: PHYSICAL_POINT !<On exit, A pointer to the physical point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(FieldType), POINTER :: FIELD,GEOMETRIC_FIELD
    TYPE(FieldInterpolationParametersType), POINTER :: FIELD_INTERPOLATION_PARAMETERS,GEOMETRIC_INTERPOLATION_PARAMETERS
    TYPE(FieldVariableType), POINTER :: fieldVariable,geometricVariable
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("FIELD_PHYSICAL_POINT_INITIALISE",err,error,*998)

    IF(ASSOCIATED(PHYSICAL_POINT)) CALL FlagError("Physical point is already associated.",err,error,*998)
    IF(.NOT.ASSOCIATED(FIELD_INTERPOLATED_POINT)) CALL FlagError("Field interpolated point is not associated.",err,error,*999)
    IF(.NOT.ASSOCIATED(GEOMETRIC_INTERPOLATED_POINT)) &
      & CALL FlagError("Geometric interpolated point is not associated.",err,error,*999)

    NULLIFY(FIELD_INTERPOLATION_PARAMETERS)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(FIELD_INTERPOLATED_POINT,FIELD_INTERPOLATION_PARAMETERS,err,error,*999)
    NULLIFY(GEOMETRIC_INTERPOLATION_PARAMETERS)
    CALL FieldInterpolatedPoint_InterpolationParametersGet(GEOMETRIC_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATION_PARAMETERS, &
      & err,error,*999)
    NULLIFY(fieldVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(FIELD_INTERPOLATION_PARAMETERS,fieldVariable,err,error,*999)
    NULLIFY(geometricVariable)
    CALL FieldInterpolationParameters_FieldVariableGet(GEOMETRIC_INTERPOLATION_PARAMETERS,geometricVariable,err,error,*999)
    NULLIFY(field)
    CALL FieldVariable_FieldGet(fieldVariable,field,err,error,*999)
    NULLIFY(GEOMETRIC_FIELD)
    CALL FieldVariable_FieldGet(geometricVariable,GEOMETRIC_FIELD,err,error,*999)
    IF(.NOT.ASSOCIATED(FIELD%geometricField,GEOMETRIC_FIELD)) THEN
      CALL FlagError("The field geometric field and the specified geometric field are not associated.",err,error,*999)
    ENDIF

    ALLOCATE(PHYSICAL_POINT,STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate physical point",err,error,*999)
    PHYSICAL_POINT%fieldInterpolatedPoint=>FIELD_INTERPOLATED_POINT
    PHYSICAL_POINT%geometricInterpolatedPoint=>GEOMETRIC_INTERPOLATED_POINT
    PHYSICAL_POINT%physicalDerivativeType=0
    ALLOCATE(PHYSICAL_POINT%VALUES(FIELD_INTERPOLATION_PARAMETERS%fieldVariable%numberOfComponents),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate physical point values.",err,error,*999)
    PHYSICAL_POINT%VALUES=0.0_DP

    EXITS("FIELD_PHYSICAL_POINT_INITIALISE")
    RETURN
999 CALL FIELD_PHYSICAL_POINT_FINALISE(PHYSICAL_POINT,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_PHYSICAL_POINT_INITIALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PHYSICAL_POINT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the physical points and deallocates all memory.
  SUBROUTINE FIELD_PHYSICAL_POINTS_FINALISE(PHYSICAL_POINTS,err,error,*)

    !Argument variables
    TYPE(FieldPhysicalPointPtrType), POINTER :: PHYSICAL_POINTS(:) !<A pointer to the physical points to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    ENTERS("FIELD_PHYSICAL_POINTS_FINALISE",err,error,*999)

    IF(ASSOCIATED(PHYSICAL_POINTS)) THEN
      DO var_type_idx=1,SIZE(PHYSICAL_POINTS,1)
        CALL FIELD_PHYSICAL_POINT_FINALISE(PHYSICAL_POINTS(var_type_idx)%ptr,err,error,*999)
      ENDDO !var_type_idx
      DEALLOCATE(PHYSICAL_POINTS)
    ENDIF

    EXITS("FIELD_PHYSICAL_POINTS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_PHYSICAL_POINTS_FINALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PHYSICAL_POINTS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the physical point for an interpolation parameters
  SUBROUTINE FIELD_PHYSICAL_POINTS_INITIALISE(FIELD_INTERPOLATED_POINTS,GEOMETRIC_INTERPOLATED_POINTS, &
    & PHYSICAL_POINTS,err,error,*)

    !Argument variables
    TYPE(FieldInterpolatedPointPtrType), POINTER :: FIELD_INTERPOLATED_POINTS(:) !<A pointer to the field interpolated points to initialise the physical points for
    TYPE(FieldInterpolatedPointPtrType), POINTER :: GEOMETRIC_INTERPOLATED_POINTS(:) !<A pointer to the geometric interpolated points to initialise the physical points for
    TYPE(FieldPhysicalPointPtrType), POINTER :: PHYSICAL_POINTS(:) !<On exit, A pointer to the physical points that has been initialised. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,var_type_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("FIELD_PHYSICAL_POINTS_INITIALISE",err,error,*998)

    IF(ASSOCIATED(FIELD_INTERPOLATED_POINTS)) THEN
      IF(ASSOCIATED(GEOMETRIC_INTERPOLATED_POINTS)) THEN
        IF(ASSOCIATED(PHYSICAL_POINTS)) THEN
          CALL FlagError("Physical points is already associated.",err,error,*998)
        ELSE
          ALLOCATE(PHYSICAL_POINTS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate physical points.",err,error,*999)
          DO var_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES

            NULLIFY(PHYSICAL_POINTS(var_type_idx)%ptr)
            IF(ASSOCIATED(FIELD_INTERPOLATED_POINTS(var_type_idx)%ptr).AND. &
              & ASSOCIATED(GEOMETRIC_INTERPOLATED_POINTS(var_type_idx)%ptr)) &
              & CALL FIELD_PHYSICAL_POINT_INITIALISE(FIELD_INTERPOLATED_POINTS(var_type_idx)%ptr, &
              & GEOMETRIC_INTERPOLATED_POINTS(var_type_idx)%ptr,PHYSICAL_POINTS(var_type_idx)%ptr,err,error,*999)
          ENDDO !var_type_idx
        ENDIF
      ELSE
        CALL FlagError("Geometric interpolated points is not associated.",err,error,*998)
      ENDIF
    ELSE
      CALL FlagError("Field interpolated points is not associated.",err,error,*998)
    ENDIF

    EXITS("FIELD_PHYSICAL_POINTS_INITIALISE")
    RETURN
999 CALL FIELD_PHYSICAL_POINTS_FINALISE(PHYSICAL_POINTS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_PHYSICAL_POINTS_INITIALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PHYSICAL_POINTS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Calculates the mappings to/from the degrees of freedom and the parameters for a field.
  SUBROUTINE FIELD_MAPPINGS_CALCULATE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to calculate the mappings for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx,component_idx,domain_type_idx,VARIABLE_GLOBAL_DOFS_OFFSET,NUMBER_OF_GLOBAL_VARIABLE_DOFS, &
      & numberOfConstantDOFs,numberOfElementDOFs,numberOfNodeDOFs,numberOfGridPointDOFs,numberOfGaussPointDOFs, &
      & NUMBER_OF_LOCAL_VARIABLE_DOFS,TOTAL_NUMBER_OF_VARIABLE_DOFS,NUMBER_OF_DOMAINS,variable_global_ny, &
      & variable_local_ny,domain_idx,domain_no,constant_nyy,element_ny,element_nyy,node_ny,node_nyy,grid_point_nyy, &
      & Gauss_point_nyy,version_idx,derivative_idx,ny,numberOfGroupComputationNodes, &
      & myGroupComputationNodeNumber,domain_type_stop,start_idx,stop_idx,element_idx,node_idx,NUMBER_OF_LOCAL, NGP, MAX_NGP, &
      & gp,MPI_IERROR,numberOfGlobalDofs,gauss_point_idx,numberOfDataPointDOFs,data_point_nyy,dataPointIdx,elementIdx, &
      & localDataNumber,globalElementNumber,groupCommunicator
    INTEGER(INTG), ALLOCATABLE :: VARIABLE_LOCAL_DOFS_OFFSETS(:),VARIABLE_GHOST_DOFS_OFFSETS(:), &
      & localDataParamCount(:),ghostDataParamCount(:)
    TYPE(BasisType), POINTER :: BASIS
    TYPE(DecompositionType), POINTER :: DECOMPOSITION
    TYPE(DecompositionDataPointsType), POINTER :: decompositionDataPoints
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainDofsType), POINTER :: domainDofs
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainMappingType), POINTER :: elementsMapping,DOFS_MAPPING,FIELD_VARIABLE_DOFS_MAPPING
    TYPE(DomainMappingsType), POINTER :: domainMappings
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldVariableComponentType), POINTER :: FIELD_COMPONENT
    TYPE(VARYING_STRING) :: localError
    TYPE(WorkGroupType), POINTER :: workGroup

    ENTERS("FIELD_MAPPINGS_CALCULATE",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(field,decomposition,err,error,*999)
      NULLIFY(workGroup)
      CALL Decomposition_WorkGroupGet(decomposition,workGroup,err,error,*999)
      CALL WorkGroup_GroupCommunicatorGet(workGroup,groupCommunicator,err,error,*999)
      CALL WorkGroup_NumberOfGroupNodesGet(workGroup,numberOfGroupComputationNodes,err,error,*999)
      CALL WorkGroup_GroupNodeNumberGet(workGroup,myGroupComputationNodeNumber,err,error,*999)

      !Calculate the number of global and local degrees of freedom for the field variables and components. Each field variable
      !component has a set of DOFs so loop over the components for each variable component and count up the DOFs.
      DO variable_idx=1,FIELD%numberOfVariables
        numberOfConstantDOFs=0
        numberOfElementDOFs=0
        numberOfNodeDOFs=0
        numberOfGridPointDOFs=0
        numberOfGaussPointDOFs=0
        numberOfDataPointDOFs=0
        NUMBER_OF_LOCAL_VARIABLE_DOFS=0
        TOTAL_NUMBER_OF_VARIABLE_DOFS=0
        NUMBER_OF_GLOBAL_VARIABLE_DOFS=0
        DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
          FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
          SELECT CASE(FIELD_COMPONENT%interpolationType)
          CASE(FIELD_CONSTANT_INTERPOLATION)
            numberOfConstantDOFs=numberOfConstantDOFs+1
            NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+1
            TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+1
            NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+1
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            DOMAIN=>FIELD_COMPONENT%DOMAIN
            NULLIFY(domainTopology)
            CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
            NULLIFY(domainElements)
            CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
            numberOfElementDOFs=numberOfElementDOFs+domainElements%totalNumberOfElements
            NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+domainElements%numberOfElements
            TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+domainElements%totalNumberOfElements
            NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+domainElements%numberOfGlobalElements
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            DOMAIN=>FIELD_COMPONENT%DOMAIN
            NULLIFY(domainTopology)
            CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
            NULLIFY(domainDofs)
            CALL DomainTopology_DomainDofsGet(domainTopology,domainDofs,err,error,*999)
            numberOfNodeDOFs=numberOfNodeDOFs+domainDofs%totalNumberOfDofs
            NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+domainDofs%numberOfDofs
            TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+domainDofs%totalNumberOfDofs
            NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+domainDofs%numberOfGlobalDofs
          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            DOMAIN=>FIELD_COMPONENT%DOMAIN
            NULLIFY(domainTopology)
            CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
            NULLIFY(domainElements)
            CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
            MAX_NGP = -1
            DO element_idx=1,domainElements%numberOfElements
              NULLIFY(basis)
              CALL DomainElements_BasisGet(domainElements,element_idx,basis,err,error,*999)
              NGP=BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%ptr%NUMBER_OF_GAUSS
              MAX_NGP=MAX(MAX_NGP,NGP)
            ENDDO !element_idx
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,MAX_NGP,1,MPI_INTEGER,MPI_MAX,groupCommunicator,MPI_IERROR)
            CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,err,error,*999)             
            numberOfGaussPointDOFs=numberOfGaussPointDOFs+domainElements%totalNumberOfElements*MAX_NGP
            NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+domainElements%numberOfElements*MAX_NGP
            TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+domainElements%totalNumberOfElements*MAX_NGP
            NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+domainElements%numberOfGlobalElements*MAX_NGP
          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
            ! Data points do not have domain topology or mappings, since they're the same across all mesh components
            NULLIFY(decompositionTopology)
            CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
            NULLIFY(decompositionDataPoints)
            CALL DecompositionTopology_DecompositionDataPointsGet(decompositionTopology,decompositionDataPoints,err,error,*999)
            numberOfDataPointDOFs=numberOfDataPointDOFs+decompositionDataPoints%totalNumberOfDataPoints
            NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+decompositionDataPoints%numberOfDataPoints
            TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+decompositionDataPoints%totalNumberOfDataPoints  
            NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+decompositionDataPoints%numberOfGlobalDataPoints
          CASE DEFAULT
            localError="The interpolation type of "// &
              & TRIM(NumberToVString(FIELD%variables(variable_idx)%components(component_idx)%interpolationType, &
              & "*",err,error))//" is invalid for component number "//TRIM(NumberToVString(component_idx,"*",err,error))// &
              & " of variable type  "//TRIM(NumberToVString(FIELD%variables(variable_idx)%variableType,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ENDDO !component_idx
        !Allocate the DOF to parameters (nodes, elements, gauss, components etc.) maps. 
        FIELD%variables(variable_idx)%numberOfDofs=NUMBER_OF_LOCAL_VARIABLE_DOFS
        FIELD%variables(variable_idx)%totalNumberOfDofs=TOTAL_NUMBER_OF_VARIABLE_DOFS
        FIELD%variables(variable_idx)%numberOfGlobalDofs=NUMBER_OF_GLOBAL_VARIABLE_DOFS
        ALLOCATE(FIELD%variables(variable_idx)%dofToParamMap%DOFType(2,TOTAL_NUMBER_OF_VARIABLE_DOFS),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate dof to parameter map.",err,error,*999)
        FIELD%variables(variable_idx)%dofToParamMap%numberOfDofs=TOTAL_NUMBER_OF_VARIABLE_DOFS
        IF(numberOfConstantDOFs>0) THEN
          ALLOCATE(FIELD%variables(variable_idx)%dofToParamMap%constantDOF2ParamMap(numberOfConstantDOFs),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate dof to parameter constant map.",err,error,*999)
          FIELD%variables(variable_idx)%dofToParamMap%numberOfConstantDOFs=numberOfConstantDOFs
        ENDIF
        IF(numberOfElementDOFs>0) THEN
          ALLOCATE(FIELD%variables(variable_idx)%dofToParamMap%elementDOF2ParamMap(2,numberOfElementDOFs),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate dof to parameter element map.",err,error,*999)
          FIELD%variables(variable_idx)%dofToParamMap%numberOfElementDOFs=numberOfElementDOFs
        ENDIF
        IF(numberOfNodeDOFs>0) THEN
          ALLOCATE(FIELD%variables(variable_idx)%dofToParamMap%nodeDOF2ParamMap(4,numberOfNodeDOFs),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate dof to parameter node map.",err,error,*999)
          FIELD%variables(variable_idx)%dofToParamMap%numberOfNodeDOFs=numberOfNodeDOFs
        ENDIF
        IF(numberOfGridPointDOFs>0) THEN
          ALLOCATE(FIELD%variables(variable_idx)%dofToParamMap%gridPointDOF2ParamMap(2,numberOfGridPointDOFs),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate dof to parameter grid point map.",err,error,*999)
          FIELD%variables(variable_idx)%dofToParamMap%numberOfGridPointDOFs=numberOfGridPointDOFs
        ENDIF
        IF(numberOfGaussPointDOFs>0) THEN
          ALLOCATE(FIELD%variables(variable_idx)%dofToParamMap%gaussPointDOF2ParamMap(3,numberOfGaussPointDOFs),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate dof to parameter Gauss point map.",err,error,*999)
          FIELD%variables(variable_idx)%dofToParamMap%numberOfGaussPointDOFs=numberOfGaussPointDOFs
        ENDIF
        IF(numberOfDataPointDOFs>0) THEN
          ALLOCATE(FIELD%variables(variable_idx)%dofToParamMap%dataPointDOF2ParamMap(3,numberOfDataPointDOFs),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate dof to parameter Gauss point map.",err,error,*999)
          FIELD%variables(variable_idx)%dofToParamMap%numberOfDataPointDOFs=numberOfDataPointDOFs
        ENDIF
      ENDDO !variable_idx
      !Allocate the mapping arrays
      ALLOCATE(VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate variable local dofs offsets.",err,error,*999)
      ALLOCATE(VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate variable ghost dofs offsets.",err,error,*999)
      !We want to ensure that the ghost DOFs are at the end so loop over the DOFs in two passes. The first pass will process
      !the local DOFs for each variable component and the second pass will process the ghost DOFs for each variable component.
      IF(numberOfGroupComputationNodes==1) THEN
        domain_type_stop=1 !Local only
      ELSE
        domain_type_stop=2 !Local+Ghosts
      ENDIF
      !Calculate the local and global numbers and set up the mappings
      DO variable_idx=1,FIELD%numberOfVariables
        constant_nyy=0
        element_nyy=0
        node_nyy=0
        grid_point_nyy=0
        Gauss_point_nyy=0
        data_point_nyy=0
        variable_local_ny=0
        FIELD_VARIABLE_DOFS_MAPPING=>FIELD%variables(variable_idx)%domainMapping
        IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
          CALL DomainMapping_WorkGroupSet(FIELD_VARIABLE_DOFS_MAPPING,workGroup,err,error,*999)
          ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(FIELD%variables(variable_idx)%numberOfGlobalDofs),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate variable dofs mapping global to local map.",err,error,*999)
          FIELD_VARIABLE_DOFS_MAPPING%numberOfGlobal=FIELD%variables(variable_idx)%numberOfGlobalDofs
        ENDIF
        !The ordering of the DOFs with respect to components is arbitrary. Allow for two orderings: The first ordering is that
        !all the DOFs from one component are processed before all the DOFs of the next component. This is known as "separated"
        !component DOF ordering. The second ordering is to process all the components for a particular parameter (e.g., node)
        !and then process all the components for the next parameter. This is known as "contiguous" component DOF ordering.
        !Continguous component ordering only works if each of the components has the same DOF structure. For this reason
        !separate component ordering is the default.
        SELECT CASE(FIELD%variables(variable_idx)%dofOrderType)
        CASE(FIELD_SEPARATED_COMPONENT_DOF_ORDER)
          !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
          VARIABLE_GHOST_DOFS_OFFSETS=0
          DO domain_type_idx=1,domain_type_stop
            VARIABLE_GLOBAL_DOFS_OFFSET=0
            VARIABLE_LOCAL_DOFS_OFFSETS=0
            DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
              NUMBER_OF_LOCAL=0
              FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
              SELECT CASE(FIELD_COMPONENT%interpolationType)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Only process the non-ghosted dofs for constant interpolation
                IF(domain_type_idx==1) THEN
                  variable_local_ny=variable_local_ny+1
                  !Allocate and set up global to local domain map for variable mapping
                  IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                    variable_global_ny=1+VARIABLE_GLOBAL_DOFS_OFFSET
                    CALL DomainGlobalMapping_Initialise(FIELD_VARIABLE_DOFS_MAPPING% &
                      & globalToLocalMap(variable_global_ny),err,error,*999)
                    NUMBER_OF_DOMAINS=numberOfGroupComputationNodes !Constant is in all domains
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(NUMBER_OF_DOMAINS), &
                      & STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                      & err,error,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(NUMBER_OF_DOMAINS), &
                      & STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                      & err,error,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(NUMBER_OF_DOMAINS), &
                      & STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                      & err,error,*999)
                    !A constant dof is mapped to all domains.
                    FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains=NUMBER_OF_DOMAINS
                    DO domain_idx=1,NUMBER_OF_DOMAINS
                      domain_no=domain_idx-1
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                        & 1+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)=domain_no
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)= &
                        & DOMAIN_LOCAL_INTERNAL
                    ENDDO !domain_idx
                  ENDIF
                  constant_nyy=constant_nyy+1
                  !Setup dof to parameter map
                  FIELD%variables(variable_idx)%dofToParamMap%DOFType(1,variable_local_ny)=FIELD_CONSTANT_DOF_TYPE
                  FIELD%variables(variable_idx)%dofToParamMap%DOFType(2,variable_local_ny)=constant_nyy
                  FIELD%variables(variable_idx)%dofToParamMap%constantDOF2ParamMap(constant_nyy)=component_idx
                  !Setup reverse parameter to dof map
                  FIELD_COMPONENT%paramToDOFMap%numberOfConstantParameters=1
                  FIELD_COMPONENT%paramToDOFMap%constantParam2DOFMap=variable_local_ny
                  !Adjust the offsets
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+1
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+1
                ENDIF
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                NULLIFY(domainTopology)
                CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                NULLIFY(domainElements)
                CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
                NULLIFY(domainMappings)               
                CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
                NULLIFY(elementsMapping)
                CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
                IF(domain_type_idx==1) THEN
                  !Allocate parameter to dof map for this field variable component
                  DOFS_MAPPING=>elementsMapping
                  ALLOCATE(FIELD_COMPONENT%paramToDOFMap%elementParam2DOFMap%ELEMENTS(domainElements% &
                    & totalNumberOfElements),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof element map.",err,error,*999)
                  FIELD_COMPONENT%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters= &
                    & domainElements%totalNumberOfElements
                  !Handle global dofs domain mapping
                  DO ny=1,elementsMapping%numberOfGlobal
                    !Handle field variable mappings
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      CALL DomainGlobalMapping_Initialise(FIELD_VARIABLE_DOFS_MAPPING% &
                        & globalToLocalMap(variable_global_ny),err,error,*999)
                      NUMBER_OF_DOMAINS=DOFS_MAPPING%globalToLocalMap(ny)%numberOfDomains
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                        & localNumber(NUMBER_OF_DOMAINS),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                        & err,error,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                        & domainNumber(NUMBER_OF_DOMAINS),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                        & err,error,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(NUMBER_OF_DOMAINS), &
                        & STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                        & err,error,*999)
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains=NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                          & DOFS_MAPPING%globalToLocalMap(ny)%localNumber(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)= &
                          & DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)= &
                          & DOFS_MAPPING%globalToLocalMap(ny)%localType(domain_idx)
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !ny
                  start_idx=1
                  stop_idx=elementsMapping%numberOfLocal
                  !Adjust the local and ghost offsets
                  IF(component_idx>1) &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+elementsMapping%numberOfDomainLocal
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+ &
                    & elementsMapping%numberOfDomainLocal+elementsMapping%numberOfDomainGhost
                ELSE
                  !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                  !dofs are at the end of the local dofs.
                  !Adjust the ghost offsets
                  IF(component_idx>1) &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)-elementsMapping%numberOfDomainLocal
                  DO ny=1,elementsMapping%numberOfGlobal
                    !Adjust variable mapping local numbers
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      NUMBER_OF_DOMAINS=FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)
                        IF(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)== &
                          & DOMAIN_LOCAL_GHOST) THEN
                          FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                            & FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)+ &
                            & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                        ELSE
                          FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                            & FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)+ &
                            & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        ENDIF
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !ny (global)
                  start_idx=elementsMapping%numberOfLocal+1
                  stop_idx=elementsMapping%totalNumberOfLocal
                  !Adjust the local offsets
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)-elementsMapping%numberOfDomainGhost
                ENDIF
                !Adjust the global offset
                VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+elementsMapping%numberOfGlobal
                !Handle local dofs domain mapping
                DO element_idx=start_idx,stop_idx
                  variable_local_ny=variable_local_ny+1
                  element_nyy=element_nyy+1
                  !Setup dof to parameter map
                  FIELD%variables(variable_idx)%dofToParamMap%DOFType(1,variable_local_ny)=FIELD_ELEMENT_DOF_TYPE
                  FIELD%variables(variable_idx)%dofToParamMap%DOFType(2,variable_local_ny)=element_nyy
                  FIELD%variables(variable_idx)%dofToParamMap%elementDOF2ParamMap(1,element_nyy)=element_idx
                  FIELD%variables(variable_idx)%dofToParamMap%elementDOF2ParamMap(2,element_nyy)=component_idx
                  !Setup reverse parameter to dof map
                  FIELD_COMPONENT%paramToDOFMap%elementParam2DOFMap%ELEMENTS(element_idx)=variable_local_ny
                ENDDO !element_idx
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                NULLIFY(domainTopology)
                CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                NULLIFY(domainDofs)
                CALL DomainTopology_DomainDofsGet(domainTopology,domainDofs,err,error,*999)
                NULLIFY(domainNodes)
                CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
                NULLIFY(domainMappings)               
                CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
                NULLIFY(DOFS_MAPPING)
                CALL DomainMappings_DofsMappingGet(domainMappings,DOFS_MAPPING,err,error,*999)
                IF(domain_type_idx==1) THEN
                  ALLOCATE(FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(domainNodes%totalNumberOfNodes),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (nodes).",err,error,*999)
                  FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters = domainNodes%totalNumberOfNodes
                  !Loop through and allocate number of derivatives for each node in the domain
                  DO node_idx=1,domainNodes%totalNumberOfNodes
                    ALLOCATE(FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES( &
                      & domainNodes%nodes(node_idx)%numberOfDerivatives),STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (derivatives).", &
                      & err,error,*999)
                    FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%numberOfDerivatives = & 
                      & domainNodes%nodes(node_idx)%numberOfDerivatives
                    DO derivative_idx=1,domainNodes%nodes(node_idx)%numberOfDerivatives
                      ALLOCATE(FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)% &
                        & VERSIONS(domainNodes%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (versions).", &
                        & err,error,*999)
                      FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)% &
                        & numberOfVersions = domainNodes%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                    ENDDO !derivative_idx
                  ENDDO !node_idx
                  DO ny=1,DOFS_MAPPING%numberOfGlobal
                    !Handle variable mapping
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      CALL DomainGlobalMapping_Initialise(FIELD_VARIABLE_DOFS_MAPPING% &
                        & globalToLocalMap(variable_global_ny),err,error,*999)
                      NUMBER_OF_DOMAINS=DOFS_MAPPING%globalToLocalMap(ny)%numberOfDomains
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                        & localNumber(NUMBER_OF_DOMAINS),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                        & err,error,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                        & domainNumber(NUMBER_OF_DOMAINS),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                        & err,error,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(NUMBER_OF_DOMAINS), &
                        & STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                        & err,error,*999)
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains=NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                          & DOFS_MAPPING%globalToLocalMap(ny)%localNumber(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)= &
                          & DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)= &
                          & DOFS_MAPPING%globalToLocalMap(ny)%localType(domain_idx)
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !ny (global)
                  start_idx=1
                  stop_idx=DOFS_MAPPING%numberOfLocal
                  !Adjust the local and ghost offsets
                  IF(component_idx>1) &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+DOFS_MAPPING%numberOfDomainLocal
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+ &
                    & DOFS_MAPPING%numberOfDomainLocal+DOFS_MAPPING%numberOfDomainGhost
                ELSE
                  !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                  !dofs are at the end of the local dofs.
                  !Adjust the ghost offsets
                  IF(component_idx>1) &
                    VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)-DOFS_MAPPING%numberOfDomainLocal
                  DO ny=1,DOFS_MAPPING%numberOfGlobal
                    !Adjust variable mapping local numbers
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      NUMBER_OF_DOMAINS=FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)
                        IF(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)== &
                          & DOMAIN_LOCAL_GHOST) THEN
                          FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                            & FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)+ &
                            & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                        ELSE
                          FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                            & FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)+ &
                            & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        ENDIF
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !ny (global)
                  start_idx=DOFS_MAPPING%numberOfLocal+1
                  stop_idx=DOFS_MAPPING%totalNumberOfLocal
                  !Adjust the local offsets
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)-DOFS_MAPPING%numberOfDomainGhost
                ENDIF
                !Adjust the global offset
                VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+DOFS_MAPPING%numberOfGlobal
                !Handle local dofs domain mapping
                DO ny=start_idx,stop_idx
                  variable_local_ny=variable_local_ny+1
                  node_nyy=node_nyy+1
                  version_idx=DOMAIN%TOPOLOGY%DOFS%dofIndex(1,ny)
                  derivative_idx=DOMAIN%TOPOLOGY%DOFS%dofIndex(2,ny)
                  node_idx=DOMAIN%TOPOLOGY%DOFS%dofIndex(3,ny)
                  !Setup dof to parameter map
                  FIELD%variables(variable_idx)%dofToParamMap%DOFType(1,variable_local_ny)=FIELD_NODE_DOF_TYPE
                  FIELD%variables(variable_idx)%dofToParamMap%DOFType(2,variable_local_ny)=node_nyy
                  FIELD%variables(variable_idx)%dofToParamMap%nodeDOF2ParamMap(1,node_nyy)=version_idx
                  FIELD%variables(variable_idx)%dofToParamMap%nodeDOF2ParamMap(2,node_nyy)=derivative_idx
                  FIELD%variables(variable_idx)%dofToParamMap%nodeDOF2ParamMap(3,node_nyy)=node_idx
                  FIELD%variables(variable_idx)%dofToParamMap%nodeDOF2ParamMap(4,node_nyy)=component_idx
                  !Setup reverse parameter to dof map
                  FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)% &
                    & VERSIONS(version_idx) = variable_local_ny
                ENDDO !ny
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                NULLIFY(domainTopology)
                CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                NULLIFY(domainElements)
                CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
                NULLIFY(domainMappings)               
                CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
                NULLIFY(elementsMapping)
                CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
                IF(domain_type_idx==1) THEN ! domain_type_idx==1 --> non ghosts
                  !Allocate parameter to dof map for this field variable component
                  DOFS_MAPPING=>elementsMapping
                  ! gaussPointParam2DOFMap%gaussPoints(ng,element_idx). The field variable dof number of ng'th Gauss point in the element_idx'th element based parameter for this field variable component. 
                  ALLOCATE(FIELD_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(&
                    & MAX_NGP,domainElements%totalNumberOfElements),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof Gauss point map.",err,error,*999)
                  ! this might be wasteful in worst case, but should generally be ok
                  FIELD_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters= &
                    &  domainElements%totalNumberOfElements*MAX_NGP
                  !Handle global dofs domain mapping
                  DO ny=1,elementsMapping%numberOfGlobal
                    DO gp=1,MAX_NGP !
                      !Handle field variable mappings
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny= (ny-1) * MAX_NGP + gp + VARIABLE_GLOBAL_DOFS_OFFSET
                        CALL DomainGlobalMapping_Initialise(FIELD_VARIABLE_DOFS_MAPPING% &
                          & globalToLocalMap(variable_global_ny),err,error,*999)
                        NUMBER_OF_DOMAINS=DOFS_MAPPING%globalToLocalMap(ny)%numberOfDomains
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                          & localNumber(NUMBER_OF_DOMAINS),STAT=err)
                        IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                          & err,error,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                          & domainNumber(NUMBER_OF_DOMAINS),STAT=err)
                        IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                          & err,error,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(NUMBER_OF_DOMAINS), &
                          & STAT=err)
                        IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                          & err,error,*999)
                        FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains=NUMBER_OF_DOMAINS
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                          ! elt local number = 1 -> gp local = 1..max_ngp, etc
                          FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                            & (DOFS_MAPPING%globalToLocalMap(ny)%localNumber(domain_idx) - 1) * MAX_NGP + gp  &
                            & + VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          ! domain and type same as element
                          FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)= &
                            & DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                          FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)= &
                            & DOFS_MAPPING%globalToLocalMap(ny)%localType(domain_idx)
                        ENDDO !domain_idx
                      ENDIF
                    ENDDO ! gp
                  ENDDO !ny
                  start_idx=1
                  stop_idx=elementsMapping%numberOfLocal
                  !Adjust the local and ghost offsets
                  IF(component_idx>1) &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+ &
                    & elementsMapping%numberOfDomainLocal*MAX_NGP
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+ &
                    & (elementsMapping%numberOfDomainLocal+elementsMapping%numberOfDomainGhost)*MAX_NGP
                ELSE !domain_type_idx==2 --> ghosts
                  !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                  !dofs are at the end of the local dofs.
                  !Adjust the ghost offsets
                  IF(component_idx>1) &
                    VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)- &
                    & elementsMapping%numberOfDomainLocal*MAX_NGP
                  DO ny=1,elementsMapping%numberOfGlobal
                    DO gp=1,MAX_NGP !
                      !Adjust variable mapping local numbers
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny= (ny-1) * MAX_NGP + gp + VARIABLE_GLOBAL_DOFS_OFFSET
                        NUMBER_OF_DOMAINS=FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)
                          IF(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)== &
                            & DOMAIN_LOCAL_GHOST) THEN
                            FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)+ &
                              & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                          ELSE
                            FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)+ &
                              & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          ENDIF
                        ENDDO !domain_idx
                      ENDIF
                    ENDDO ! gp
                  ENDDO !ny (global)
                  start_idx=elementsMapping%numberOfLocal+1
                  stop_idx=elementsMapping%totalNumberOfLocal
                  !Adjust the local offsets
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)- &
                    & elementsMapping%numberOfDomainGhost*MAX_NGP
                ENDIF ! 2 passes for normal, ghost 
                !Adjust the global offset
                VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+elementsMapping%numberOfGlobal*MAX_NGP
                !Handle local dofs domain mapping
                DO element_idx=start_idx,stop_idx
                  DO gp=1,MAX_NGP !
                    variable_local_ny= variable_local_ny+1
                    Gauss_point_nyy  = Gauss_point_nyy+1
                    !Setup dof to parameter map
                    FIELD%variables(variable_idx)%dofToParamMap%DOFType(1,variable_local_ny)=FIELD_GAUSS_POINT_DOF_TYPE
                    FIELD%variables(variable_idx)%dofToParamMap%DOFType(2,variable_local_ny)=Gauss_point_nyy
                    FIELD%variables(variable_idx)%dofToParamMap%gaussPointDOF2ParamMap(1,Gauss_point_nyy)=gp
                    FIELD%variables(variable_idx)%dofToParamMap%gaussPointDOF2ParamMap(2,Gauss_point_nyy)=element_idx
                    FIELD%variables(variable_idx)%dofToParamMap%gaussPointDOF2ParamMap(3,Gauss_point_nyy)=component_idx
                    !Setup reverse parameter to dof map
                    FIELD_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gp,element_idx)=variable_local_ny
                  ENDDO !gp
                ENDDO !element_idx                       
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                domain=>FIELD_COMPONENT%DOMAIN
                NULLIFY(decompositionTopology)
                CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
                NULLIFY(decompositionDataPoints)
                CALL DecompositionTopology_DecompositionDataPointsGet(decompositionTopology,decompositionDataPoints,err,error,*999)
                NULLIFY(domainMappings)               
                CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
                NULLIFY(elementsMapping)
                CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
                IF(domain_type_idx==1) THEN ! domain_type_idx==1 -> non ghosts
                  !Allocate parameter to dof map for this field variable component
                  !including both local and ghost data points on this computation domain.
                  ALLOCATE(FIELD_COMPONENT%paramToDOFMap%dataPointParam2DOFMap%dataPoints(decompositionDataPoints% &
                    & totalNumberOfDataPoints),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof data point map.",err,error,*999)
                  ! Number of data points
                  FIELD_COMPONENT%paramToDOFMap%dataPointParam2DOFMap%numberOfDataPointParameters= &
                    & decompositionDataPoints%totalNumberOfDataPoints 
                  ALLOCATE(localDataParamCount(0:numberOfGroupComputationNodes-1),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate data point parameter local count.",err,error,*999)
                  ALLOCATE(ghostDataParamCount(0:numberOfGroupComputationNodes-1),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate data point parameter ghost count.",err,error,*999)
                  localDataParamCount=0
                  ghostDataParamCount(0:numberOfGroupComputationNodes-1)=decompositionDataPoints%numberOfDomainLocal
                  !Looping through global elements and data points in the elements
                  variable_global_ny=VARIABLE_GLOBAL_DOFS_OFFSET
                  DO elementIdx=1,elementsMapping%numberOfGlobal
                    DO dataPointIdx=1,decompositionDataPoints%numberOfelementDataPoints(elementIdx)
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny=variable_global_ny+1
                        CALL DomainGlobalMapping_Initialise(FIELD_VARIABLE_DOFS_MAPPING% &
                          & globalToLocalMap(variable_global_ny),err,error,*999)
                        NUMBER_OF_DOMAINS=elementsMapping%globalToLocalMap(elementIdx)%numberOfDomains
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                          & localNumber(NUMBER_OF_DOMAINS),STAT=err)
                        IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                          & err,error,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                          & domainNumber(NUMBER_OF_DOMAINS),STAT=err)
                        IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                          & err,error,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                          & localType(NUMBER_OF_DOMAINS),STAT=err)
                        IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                          & err,error,*999)
                        FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains=NUMBER_OF_DOMAINS
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=elementsMapping%globalToLocalMap(elementIdx)%domainNumber(domain_idx)
                          IF(elementsMapping%globalToLocalMap(elementIdx)%localType(domain_idx)== &
                            & DOMAIN_LOCAL_GHOST) THEN
                            ghostDataParamCount(domain_no)=ghostDataParamCount(domain_no)+1
                            FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                              & ghostDataParamCount(domain_no)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          ELSE
                            localDataParamCount(domain_no)=localDataParamCount(domain_no)+1
                            FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                              & localDataParamCount(domain_no)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          ENDIF
                          FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)= &
                            & elementsMapping%globalToLocalMap(elementIdx)%domainNumber(domain_idx)
                          FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)= &
                            & elementsMapping%globalToLocalMap(elementIdx)%localType(domain_idx)
                        ENDDO !domain_idx
                      ENDIF
                    ENDDO !dataPointIdx
                  ENDDO !elementIdx 
                  IF(ALLOCATED(localDataParamCount)) DEALLOCATE(localDataParamCount)
                  IF(ALLOCATED(ghostDataParamCount)) DEALLOCATE(ghostDataParamCount)
                  start_idx=1 !the start idx for the elements
                  stop_idx=elementsMapping%numberOfLocal !the end idx for local elements
                  !Adjust the local and ghost offsets
                  IF(component_idx>1) THEN
                    VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+ &
                      & decompositionDataPoints%numberOfDomainLocal
                  ENDIF
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+ &
                    & decompositionDataPoints%numberOfDomainLocal+decompositionDataPoints%numberOfDomainGhost
                ELSE  ! domain_type_idx == 2 -> ghosts
                  !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                  !dofs are at the end of the local dofs.
                  !Adjust the ghost offsets
                  IF(component_idx>1) THEN
                    VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)- &
                      & decompositionDataPoints%numberOfDomainLocal
                  ENDIF
                  !Looping through global elements and data points in the elements
                  variable_global_ny=VARIABLE_GLOBAL_DOFS_OFFSET
                  DO elementIdx=1,elementsMapping%numberOfGlobal
                    DO dataPointIdx=1,decompositionDataPoints%numberOfelementDataPoints(elementIdx)
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny=variable_global_ny+1
                        NUMBER_OF_DOMAINS=elementsMapping%globalToLocalMap(elementIdx)%numberOfDomains
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=elementsMapping%globalToLocalMap(elementIdx)%domainNumber(domain_idx)
                          IF(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)== &
                            & DOMAIN_LOCAL_GHOST) THEN
                            FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)+ &
                              & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                          ELSE
                            FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)+ &
                              & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          ENDIF
                        ENDDO
                      ENDIF
                    ENDDO !dataPointIdx
                  ENDDO !elementIdx 
                  !Adjust the local offsets
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)- &
                    & decompositionDataPoints%numberOfDomainGhost
                  start_idx=elementsMapping%numberOfLocal+1 !The start index for ghost elements
                  stop_idx=elementsMapping%totalNumberOfLocal !The end index for local elements
                ENDIF
                !Adjust the global offset
                VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+decompositionDataPoints%&
                  & numberOfGlobalDataPoints  
                !Handle local dofs domain mapping
                DO elementIdx=start_idx,stop_idx
                  globalElementNumber=elementsMapping%localToGlobalMap(elementIdx)
                  DO dataPointIdx=1,decompositionDataPoints%numberOfelementDataPoints(globalElementNumber)
                    variable_local_ny=variable_local_ny+1 !reinitialise for every field variable, field variable dof idx
                    data_point_nyy=data_point_nyy+1 !reinitialise for every field variable, field variable data point dof idx
                    localDataNumber=decompositionDataPoints%elementDataPoints(elementIdx)%dataIndices(dataPointIdx)% &
                      & localNumber
                    !Setup dof to parameter map
                    FIELD%variables(variable_idx)%dofToParamMap%DOFType(1,variable_local_ny)=FIELD_DATA_POINT_DOF_TYPE
                    FIELD%variables(variable_idx)%dofToParamMap%DOFType(2,variable_local_ny)=data_point_nyy
                    FIELD%variables(variable_idx)%dofToParamMap%dataPointDOF2ParamMap(1,data_point_nyy)=localDataNumber
                    FIELD%variables(variable_idx)%dofToParamMap%dataPointDOF2ParamMap(2,data_point_nyy)=elementIdx
                    FIELD%variables(variable_idx)%dofToParamMap%dataPointDOF2ParamMap(3,data_point_nyy)=component_idx
                    !Setup reverse parameter to dof map
                    FIELD_COMPONENT%paramToDOFMap%dataPointParam2DOFMap%dataPoints(localDataNumber)=variable_local_ny
                  ENDDO !dataPointIdx
                ENDDO !elementIdx 
              CASE DEFAULT
                localError="The interpolation type of "// &
                  & TRIM(NumberToVString(FIELD%variables(variable_idx)%components(component_idx)%interpolationType, &
                  & "*",err,error))//" is invalid for component number "//TRIM(NumberToVString(component_idx,"*",err,error))// &
                  & " of variable type "//TRIM(NumberToVString(FIELD%variables(variable_idx)%variableType,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDDO !component_idx
          ENDDO !domain_type_idx
        CASE(FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER)
          !Handle the case where all components for a particular DOF parameter are processed before all the component of the next
          !parameter.
          VARIABLE_LOCAL_DOFS_OFFSETS=0
          VARIABLE_GLOBAL_DOFS_OFFSET=0
          VARIABLE_GHOST_DOFS_OFFSETS=0
          IF(FIELD%variables(variable_idx)%numberOfComponents>=1) THEN
            SELECT CASE(FIELD%variables(variable_idx)%components(1)%interpolationType)
            CASE(FIELD_CONSTANT_INTERPOLATION)
              DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
                FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
                variable_local_ny=1+VARIABLE_LOCAL_DOFS_OFFSETS(myGroupComputationNodeNumber)
                !Allocate and set up global to local domain map for variable mapping
                IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                  variable_global_ny=1+VARIABLE_GLOBAL_DOFS_OFFSET
                  CALL DomainGlobalMapping_Initialise(FIELD_VARIABLE_DOFS_MAPPING% &
                    & globalToLocalMap(variable_global_ny),err,error,*999)
                  NUMBER_OF_DOMAINS=numberOfGroupComputationNodes !Constant is in all domains
                  ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(NUMBER_OF_DOMAINS), &
                    & STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                    & err,error,*999)
                  ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(NUMBER_OF_DOMAINS), &
                    & STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                    & err,error,*999)
                  ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(NUMBER_OF_DOMAINS), &
                    & STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                    & err,error,*999)
                  !A constant dof is mapped to all domains.
                  FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains=NUMBER_OF_DOMAINS
                  DO domain_idx=1,NUMBER_OF_DOMAINS
                    domain_no=domain_idx-1
                    FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                      & 1+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                    FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)=domain_no
                    FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)=DOMAIN_LOCAL_INTERNAL
                  ENDDO !domain_idx
                ENDIF
                constant_nyy=constant_nyy+1
                !Setup dof to parameter map
                FIELD%variables(variable_idx)%dofToParamMap%DOFType(1,variable_local_ny)=FIELD_CONSTANT_DOF_TYPE
                FIELD%variables(variable_idx)%dofToParamMap%DOFType(2,variable_local_ny)=constant_nyy
                FIELD%variables(variable_idx)%dofToParamMap%constantDOF2ParamMap(constant_nyy)=component_idx
                !Setup reverse parameter to dof map
                FIELD_COMPONENT%paramToDOFMap%numberOfConstantParameters=1
                FIELD_COMPONENT%paramToDOFMap%constantParam2DOFMap=variable_local_ny
                !Adjust the offsets
                VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+1
                VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                  & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+1
              ENDDO !component_idx
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
                FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                NULLIFY(domainTopology)
                CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                NULLIFY(domainElements)
                CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
                !Allocate parameter to dof map for this field variable component
                ALLOCATE(FIELD_COMPONENT%paramToDOFMap%elementParam2DOFMap%ELEMENTS(domainElements% &
                  & totalNumberOfElements),STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof element map.",err,error,*999)
                FIELD_COMPONENT%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters= &
                  & domainElements%totalNumberOfElements
              ENDDO !component_idx
              !Handle global dofs domain mapping
              element_ny=0
              numberOfGlobalDofs=FIELD%variables(variable_idx)%components(1)%DOMAIN%MAPPINGS%ELEMENTS%numberOfGlobal              
              DO ny=1,numberOfGlobalDofs
                DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
                  FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
                  DOMAIN=>FIELD_COMPONENT%DOMAIN
                  NULLIFY(domainTopology)
                  CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                  NULLIFY(domainElements)
                  CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
                  NULLIFY(domainMappings)               
                  CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
                  NULLIFY(elementsMapping)
                  CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
                  DOFS_MAPPING=>elementsMapping
                  !Handle field variable mappings
                  IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                    element_ny=element_ny+1
                    variable_global_ny=element_ny+VARIABLE_GLOBAL_DOFS_OFFSET
                    CALL DomainGlobalMapping_Initialise(FIELD_VARIABLE_DOFS_MAPPING% &
                      & globalToLocalMap(variable_global_ny),err,error,*999)
                    NUMBER_OF_DOMAINS=DOFS_MAPPING%globalToLocalMap(ny)%numberOfDomains
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(NUMBER_OF_DOMAINS), &
                      & STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                      & err,error,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(NUMBER_OF_DOMAINS), &
                      & STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                      & err,error,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(NUMBER_OF_DOMAINS), &
                      & STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                      & err,error,*999)
                    FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains=NUMBER_OF_DOMAINS
                    DO domain_idx=1,NUMBER_OF_DOMAINS
                      domain_no=DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                        & DOFS_MAPPING%globalToLocalMap(ny)%localNumber(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)= &
                        & DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)= &
                        & DOFS_MAPPING%globalToLocalMap(ny)%localType(domain_idx)
                    ENDDO !domain_idx
                  ENDIF
                ENDDO !component_idx
              ENDDO !ny
              !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
              DO domain_type_idx=1,domain_type_stop
                IF(domain_type_idx==1) THEN
                  start_idx=1
                  stop_idx=elementsMapping%numberOfLocal
                ELSE
                  start_idx=elementsMapping%numberOfLocal+1
                  stop_idx=elementsMapping%totalNumberOfLocal
                ENDIF
                !Handle local dofs domain mapping
                element_ny=0
                DO element_idx=start_idx,stop_idx
                  DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
                    FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
                    element_ny=element_ny+1
                    variable_local_ny=element_ny+VARIABLE_LOCAL_DOFS_OFFSETS(myGroupComputationNodeNumber)
                    element_nyy=element_nyy+1
                    !Setup dof to parameter map
                    FIELD%variables(variable_idx)%dofToParamMap%DOFType(1,variable_local_ny)=FIELD_ELEMENT_DOF_TYPE
                    FIELD%variables(variable_idx)%dofToParamMap%DOFType(2,variable_local_ny)=element_nyy
                    FIELD%variables(variable_idx)%dofToParamMap%elementDOF2ParamMap(1,element_nyy)=element_idx
                    FIELD%variables(variable_idx)%dofToParamMap%elementDOF2ParamMap(2,element_nyy)=component_idx
                    !Setup reverse parameter to dof map
                    FIELD_COMPONENT%paramToDOFMap%elementParam2DOFMap%ELEMENTS(element_idx)=variable_local_ny
                  ENDDO !component_idx
                ENDDO !element_idx
                !Adjust the offsets
                VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                  &  VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+ &
                  & FIELD%variables(variable_idx)%numberOfComponents* &
                  & elementsMapping%numberOfDomainLocal
                IF(domain_type_idx==1) THEN
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+FIELD%variables(variable_idx)%numberOfComponents* &
                    & elementsMapping%numberOfGlobal
                ENDIF
              ENDDO !domain_type_idx
            CASE(FIELD_NODE_BASED_INTERPOLATION)
              DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
                FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                NULLIFY(domainTopology)
                CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                NULLIFY(domainNodes)
                CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
                ALLOCATE(FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(domainNodes%totalNumberOfNodes), &
                  & STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (nodes).",err,error,*999)
                FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters = &
                  & domainNodes%totalNumberOfNodes
                !Loop through and allocate number of derivatives for each node in the domain
                DO node_idx=1,domainNodes%totalNumberOfNodes
                  ALLOCATE(FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES( &
                    & domainNodes%nodes(node_idx)%numberOfDerivatives),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (derivatives).", &
                    & err,error,*999)
                  FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%numberOfDerivatives = & 
                    & domainNodes%nodes(node_idx)%numberOfDerivatives
                  DO derivative_idx=1,domainNodes%nodes(node_idx)%numberOfDerivatives
                    ALLOCATE(FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)% &
                      & VERSIONS(domainNodes%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions),STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof node map (versions).", &
                      & err,error,*999)
                    FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)% &
                      numberOfVersions = domainNodes%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                  ENDDO !derivative_idx
                ENDDO !node_idx
              ENDDO !component_idx
              !Handle global dofs domain mapping
              !Should the contiguous components have an inner groupping for derivatives??? i.e., loop over nodes, components then
              !derivatives????
              node_ny=0
              numberOfGlobalDofs=FIELD%variables(variable_idx)%components(1)%DOMAIN%MAPPINGS%DOFS%numberOfGlobal
              DO ny=1,numberOfGlobalDofs
                DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
                  FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
                  DOMAIN=>FIELD_COMPONENT%DOMAIN
                  NULLIFY(domainTopology)
                  CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                  NULLIFY(domainDofs)
                  CALL DomainTopology_DomainDofsGet(domainTopology,domainDofs,err,error,*999)
                  NULLIFY(domainNodes)
                  CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
                  NULLIFY(domainMappings)               
                  CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
                  NULLIFY(DOFS_MAPPING)
                  CALL DomainMappings_DofsMappingGet(domainMappings,DOFS_MAPPING,err,error,*999)
                  !Handle variable mapping
                  IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                    node_ny=node_ny+1
                    variable_global_ny=node_ny+VARIABLE_GLOBAL_DOFS_OFFSET
                    CALL DomainGlobalMapping_Initialise(FIELD_VARIABLE_DOFS_MAPPING% &
                      & globalToLocalMap(variable_global_ny),err,error,*999)
                    NUMBER_OF_DOMAINS=DOFS_MAPPING%globalToLocalMap(ny)%numberOfDomains
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                      & localNumber(NUMBER_OF_DOMAINS),STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                      & err,error,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                      & domainNumber(NUMBER_OF_DOMAINS),STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                      & err,error,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(NUMBER_OF_DOMAINS), &
                      & STAT=err)
                    IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                      & err,error,*999)
                    FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains=NUMBER_OF_DOMAINS
                    DO domain_idx=1,NUMBER_OF_DOMAINS
                      domain_no=DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                        & DOFS_MAPPING%globalToLocalMap(ny)%localNumber(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)= &
                        & DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)= &
                        & DOFS_MAPPING%globalToLocalMap(ny)%localType(domain_idx)
                    ENDDO !domain_idx
                  ENDIF
                ENDDO !component_idx
              ENDDO !ny (global)
              !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
              DO domain_type_idx=1,domain_type_stop
                IF(domain_type_idx==1) THEN
                  start_idx=1
                  stop_idx=DOFS_MAPPING%numberOfLocal
                ELSE
                  start_idx=DOFS_MAPPING%numberOfLocal+1
                  stop_idx=DOFS_MAPPING%totalNumberOfLocal
                ENDIF
                !Handle local dofs domain mapping
                node_ny=0
                DO ny=start_idx,stop_idx
                  DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
                    FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
                    DOMAIN=>FIELD_COMPONENT%DOMAIN
                    NULLIFY(domainTopology)
                    CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                    NULLIFY(domainDofs)
                    CALL DomainTopology_DomainDofsGet(domainTopology,domainDofs,err,error,*999)
                    node_ny=node_ny+1
                    variable_local_ny=node_ny+VARIABLE_LOCAL_DOFS_OFFSETS(myGroupComputationNodeNumber)
                    node_nyy=node_nyy+1
                    version_idx=domainDofs%dofIndex(1,ny)
                    derivative_idx=domainDofs%dofIndex(2,ny)
                    node_idx=domainDofs%dofIndex(3,ny)
                    !Setup dof to parameter map
                    FIELD%variables(variable_idx)%dofToParamMap%DOFType(1,variable_local_ny)=FIELD_NODE_DOF_TYPE
                    FIELD%variables(variable_idx)%dofToParamMap%DOFType(2,variable_local_ny)=node_nyy
                    FIELD%variables(variable_idx)%dofToParamMap%nodeDOF2ParamMap(1,node_nyy)=version_idx
                    FIELD%variables(variable_idx)%dofToParamMap%nodeDOF2ParamMap(2,node_nyy)=derivative_idx
                    FIELD%variables(variable_idx)%dofToParamMap%nodeDOF2ParamMap(3,node_nyy)=node_idx
                    FIELD%variables(variable_idx)%dofToParamMap%nodeDOF2ParamMap(4,node_nyy)=component_idx
                    !Setup reverse parameter to dof map
                    FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)% &
                      & VERSIONS(version_idx) = variable_local_ny
                  ENDDO !component_idx
                ENDDO !ny
                !Adjust the offsets
                VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                  & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+ &
                  & FIELD%variables(variable_idx)%numberOfComponents* &
                  & DOFS_MAPPING%numberOfDomainLocal
                IF(domain_type_idx==1) THEN
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+FIELD%variables(variable_idx)%numberOfComponents* &
                    & DOFS_MAPPING%numberOfGlobal
                ENDIF
              ENDDO !domain_type_idx
            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
                FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                NULLIFY(domainTopology)
                CALL Domain_DomainTopologyGet(DOMAIN,domainTopology,err,error,*999)
                NULLIFY(domainElements)
                CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
                !>todo find a better way than assuming NGP=MAX_NGP for all elements TODO
                ALLOCATE(FIELD_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(MAX_NGP,domainElements% &
                  & totalNumberOfElements),STAT=err)
                IF(err/=0) CALL FlagError("Could not allocate field component parameter to dof gauss point map (gauss points).", &
                  & err,error,*999)
                FIELD_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters= &
                  & MAX_NGP*domainElements%totalNumberOfElements
              ENDDO
              !Handle global dofs domain mapping
              element_ny=0
              numberOfGlobalDofs=FIELD%variables(variable_idx)%components(1)%DOMAIN%MAPPINGS%ELEMENTS%numberOfGlobal
              DO ny=1,numberOfGlobalDofs
                DO gauss_point_idx=1,MAX_NGP
                  DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
                    FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
                    DOMAIN=>FIELD_COMPONENT%DOMAIN
                    NULLIFY(domainMappings)               
                    CALL Domain_DomainMappingsGet(domain,domainMappings,err,error,*999)                
                    NULLIFY(elementsMapping)
                    CALL DomainMappings_ElementsMappingGet(domainMappings,elementsMapping,err,error,*999)
                    DOFS_MAPPING=>elementsMapping
                    !Handle variable mapping
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      element_ny=element_ny+1
                      variable_global_ny=element_ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      CALL DomainGlobalMapping_Initialise(FIELD_VARIABLE_DOFS_MAPPING% &
                        & globalToLocalMap(variable_global_ny),err,error,*999)
                      NUMBER_OF_DOMAINS=DOFS_MAPPING%globalToLocalMap(ny)%numberOfDomains
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                        & localNumber(NUMBER_OF_DOMAINS),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                        & err,error,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)% &
                        & domainNumber(NUMBER_OF_DOMAINS),STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                        & err,error,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(NUMBER_OF_DOMAINS), &
                        & STAT=err)
                      IF(err/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                        & err,error,*999)
                      FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%numberOfDomains=NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localNumber(domain_idx)= &
                          & DOFS_MAPPING%globalToLocalMap(ny)%localNumber(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%domainNumber(domain_idx)= &
                          & DOFS_MAPPING%globalToLocalMap(ny)%domainNumber(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%globalToLocalMap(variable_global_ny)%localType(domain_idx)= &
                          & DOFS_MAPPING%globalToLocalMap(ny)%localType(domain_idx)
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !component_idx
                ENDDO !gauss_point_idx
              ENDDO !ny (global)
              !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
              DO domain_type_idx=1,domain_type_stop
                IF(domain_type_idx==1) THEN
                  start_idx=1
                  stop_idx=DOFS_MAPPING%numberOfLocal
                ELSE
                  start_idx=DOFS_MAPPING%numberOfLocal+1
                  stop_idx=DOFS_MAPPING%totalNumberOfLocal
                ENDIF
                !Handle local dofs domain mapping
                element_ny=0
                DO ny=start_idx,stop_idx
                  DO gauss_point_idx=1,MAX_NGP
                    DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
                      FIELD_COMPONENT=>FIELD%variables(variable_idx)%components(component_idx)
                      DOMAIN=>FIELD_COMPONENT%DOMAIN
                      element_ny=element_ny+1                      
                      variable_local_ny=element_ny+VARIABLE_LOCAL_DOFS_OFFSETS(myGroupComputationNodeNumber)
                      node_nyy=node_nyy+1
                      !Setup dof to parameter map
                      FIELD%variables(variable_idx)%dofToParamMap%DOFType(1,variable_local_ny)=FIELD_GAUSS_POINT_DOF_TYPE
                      FIELD%variables(variable_idx)%dofToParamMap%DOFType(2,variable_local_ny)=node_nyy
                      FIELD%variables(variable_idx)%dofToParamMap%gaussPointDOF2ParamMap(1,node_nyy)=gauss_point_idx
                      FIELD%variables(variable_idx)%dofToParamMap%gaussPointDOF2ParamMap(2,node_nyy)=ny !element_idx
                      FIELD%variables(variable_idx)%dofToParamMap%gaussPointDOF2ParamMap(3,node_nyy)=component_idx
                      !Setup reverse parameter to dof map
                      FIELD_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%gaussPoints(gauss_point_idx,ny)= &
                        & variable_local_ny
                    ENDDO !component_idx
                  ENDDO !gauss_point_idx
                ENDDO !ny
                !Adjust the offsets
                VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)= &
                  & VARIABLE_LOCAL_DOFS_OFFSETS(0:numberOfGroupComputationNodes-1)+ &
                  & FIELD%variables(variable_idx)%numberOfComponents* &
                  & DOFS_MAPPING%numberOfDomainLocal*MAX_NGP
                IF(domain_type_idx==1) THEN
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+FIELD%variables(variable_idx)%numberOfComponents* &
                    & DOFS_MAPPING%numberOfGlobal*MAX_NGP
                ENDIF
              ENDDO !domain_type_idx
            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The interpolation type of "// &
                & TRIM(NumberToVString(FIELD%variables(variable_idx)%components(component_idx)%interpolationType, &
                & "*",err,error))//" is invalid for component number 1 of variable type "//TRIM(NumberToVString( &
                & FIELD%variables(variable_idx)%variableType,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE
            CALL FlagError("The field must have at least one component.",err,error,*999)
          ENDIF
        CASE DEFAULT
          localError="The DOF order type of "//TRIM(NumberToVString(FIELD%variables(variable_idx)%dofOrderType, &
            & "*",err,error))//" is invalid for variable type "//TRIM(NumberToVString(FIELD%variables(variable_idx)% &
            & variableType,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
        IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
          CALL DomainMapping_LocalFromGlobalCalculate(FIELD_VARIABLE_DOFS_MAPPING,err,error,*999)
        ENDIF
      ENDDO !variable_idx
      IF(ALLOCATED(VARIABLE_LOCAL_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_LOCAL_DOFS_OFFSETS)
      IF(ALLOCATED(VARIABLE_GHOST_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_GHOST_DOFS_OFFSETS)

      IF(DIAGNOSTICS1) THEN
        CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Field DOF mappings:",err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field user number = ",FIELD%userNumber,err,error,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of variables = ",FIELD%numberOfVariables,err,error,*999)
        DO variable_idx=1,FIELD%numberOfVariables
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Variable : ",variable_idx,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Variable type = ",FIELD%variables(variable_idx)%variableType, &
            & err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Number of local DOFs = ",FIELD%variables(variable_idx)% &
            & numberOfDofs,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Total number of local DOFs = ",FIELD%variables(variable_idx)% &
            & totalNumberOfDofs,err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Number of global DOFs = ",FIELD%variables(variable_idx)% &
            & numberOfGlobalDofs,err,error,*999)
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"    DOF to parameter map:",err,error,*999)
          DO variable_local_ny=1,FIELD%variables(variable_idx)%totalNumberOfDofs
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      DOF : ",variable_local_ny,err,error,*999)
            CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,FIELD%variables(variable_idx)%dofToParamMap% &
              & DOFType(:,variable_local_ny),'("        DOF type :",2(X,I8))','(18X,2(X,I8))',err,error,*999)
          ENDDO !variable_local_ny
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of constant DOFs = ",FIELD%variables(variable_idx)% &
            & dofToParamMap%numberOfConstantDOFs,err,error,*999)
          IF(FIELD%variables(variable_idx)%dofToParamMap%numberOfConstantDOFs>0) THEN
            CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Constant DOFs:",err,error,*999)
            DO constant_nyy=1,FIELD%variables(variable_idx)%dofToParamMap%numberOfConstantDOFs
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Constant DOF : ",constant_nyy,err,error,*999)
              CALL WRITE_STRING_FMT_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          DOF 2 Parameters : ", &
                & FIELD%variables(variable_idx)%dofToParamMap%constantDOF2ParamMap(constant_nyy),'(I8)',err,error,*999)
            ENDDO !constant_nyy
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of element DOFs = ",FIELD%variables(variable_idx)% &
            & dofToParamMap%numberOfElementDOFs,err,error,*999)
          IF(FIELD%variables(variable_idx)%dofToParamMap%numberOfElementDOFs>0) THEN            
            CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Element DOFs:",err,error,*999)
            DO element_nyy=1,FIELD%variables(variable_idx)%dofToParamMap%numberOfElementDOFs
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Element DOF : ",element_nyy,err,error,*999)
              CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,FIELD%variables(variable_idx)%dofToParamMap% &
                & elementDOF2ParamMap(:,element_nyy),'("          DOF 2 Parameters :",2(X,I8))','(28X,2(X,I8))',err,error,*999)
            ENDDO !element_nyy
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of nodal DOFs = ",FIELD%variables(variable_idx)% &
            & dofToParamMap%numberOfNodeDOFs,err,error,*999)
          IF(FIELD%variables(variable_idx)%dofToParamMap%numberOfNodeDOFs>0) THEN
            CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Nodal DOFs:",err,error,*999)
            DO node_nyy=1,FIELD%variables(variable_idx)%dofToParamMap%numberOfNodeDOFs
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Node DOF : ",node_nyy,err,error,*999)
              CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,4,4,4,FIELD%variables(variable_idx)%dofToParamMap% &
                & nodeDOF2ParamMap(:,node_nyy),'("          DOF 2 Parameters :",4(X,I8))','(28X,4(X,I8))',err,error,*999)
            ENDDO !node_nyy
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of grid point DOFs = ",FIELD%variables(variable_idx)% &
            & dofToParamMap%numberOfGridPointDOFs,err,error,*999)
          IF(FIELD%variables(variable_idx)%dofToParamMap%numberOfGridPointDOFs>0) THEN
            CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Grid point DOFs:",err,error,*999)
            DO grid_point_nyy=1,FIELD%variables(variable_idx)%dofToParamMap%numberOfGridPointDOFs
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Grid point DOF : ",grid_point_nyy,err,error,*999)
              CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,FIELD%variables(variable_idx)%dofToParamMap% &
                & gridPointDOF2ParamMap(:,grid_point_nyy),'("          DOF 2 Parameters :",2(X,I8))','(28X,2(X,I8))', &
                & err,error,*999)
            ENDDO !node_nyy
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of Gauss point DOFs = ",FIELD%variables(variable_idx)% &
            & dofToParamMap%numberOfGaussPointDOFs,err,error,*999)
          IF(FIELD%variables(variable_idx)%dofToParamMap%numberOfGaussPointDOFs>0) THEN
            CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Gauss point DOFs:",err,error,*999)
            DO Gauss_point_nyy=1,FIELD%variables(variable_idx)%dofToParamMap%numberOfGaussPointDOFs
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Gauss point DOF : ",Gauss_point_nyy,err,error,*999)
              CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,3,3,FIELD%variables(variable_idx)%dofToParamMap% &
                & gaussPointDOF2ParamMap(:,Gauss_point_nyy),'("          DOF 2 Parameters :",3(X,I8))','(28X,3(X,I8))', &
                & err,error,*999)
            ENDDO !node_nyy
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of data point DOFs = ",FIELD%variables(variable_idx)% &
            & dofToParamMap%numberOfDataPointDOFs,err,error,*999)
          IF(FIELD%variables(variable_idx)%dofToParamMap%numberOfDataPointDOFs>0) THEN
            CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      data point DOFs:",err,error,*999)
            DO data_point_nyy=1,FIELD%variables(variable_idx)%dofToParamMap%numberOfDataPointDOFs
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        data point DOF : ",data_point_nyy,err,error,*999)
              CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,3,3,FIELD%variables(variable_idx)%dofToParamMap% &
                & dataPointDOF2ParamMap(:,data_point_nyy),'("          DOF 2 Parameters :",3(X,I8))','(28X,3(X,I8))', &
                & err,error,*999)
            ENDDO !node_nyy
          ENDIF
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"    Parameter to DOF map:",err,error,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of components = ",FIELD%variables(variable_idx)% &
            & numberOfComponents,err,error,*999)
          DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
            FIELD_COMPONENT => FIELD%variables(variable_idx)%components(component_idx)
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Component : ",component_idx,err,error,*999)
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of constant parameters = ", &
              & FIELD_COMPONENT%paramToDOFMap%numberOfConstantParameters,err,error,*999)
            IF(FIELD_COMPONENT%paramToDOFMap%numberOfConstantParameters>0) THEN
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Constant DOF = ", &
                & FIELD_COMPONENT%paramToDOFMap%constantParam2DOFMap,err,error,*999)
            ENDIF
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of element parameters = ", &
              & FIELD_COMPONENT%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters,err,error,*999)
            IF(FIELD_COMPONENT%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters>0) THEN
              DO element_idx=1,FIELD_COMPONENT%paramToDOFMap%elementParam2DOFMap%numberOfElementParameters
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Element : ",element_idx,err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"            Element DOF = ", &
                  & FIELD_COMPONENT%paramToDOFMap%elementParam2DOFMap%ELEMENTS(element_idx), &
                  & err,error,*999)
              ENDDO !element_idx
            ENDIF
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of node parameters = ", &
              & FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters,err,error,*999)
            IF(FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters>0) THEN
              DO node_idx=1,FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%numberOfNodeParameters
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Node : ",node_idx,err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Number of Derivatives = ", &
                  & FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%numberOfDerivatives,err,error,*999)
                DO derivative_idx=1,FIELD_COMPONENT%paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%numberOfDerivatives
                  CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Derivative : ",derivative_idx,err,error,*999)
                  CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,FIELD_COMPONENT%paramToDOFMap% &
                    & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions,8,8,FIELD_COMPONENT% &
                    & paramToDOFMap%nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(:), &
                    & '("              Version DOFs :",8(X,I8))','(23X,8(X,I8))',err,error,*999)
                ENDDO !derivative_idx
              ENDDO !node_idx
            ENDIF
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of grid point parameters = ", &
              & FIELD_COMPONENT%paramToDOFMap%gridPointParam2DOFMap%numberOfGridPointParameters,err,error,*999)
            IF(FIELD_COMPONENT%paramToDOFMap%gridPointParam2DOFMap%numberOfGridPointParameters>0) THEN
            ENDIF
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of Gauss point parameters = ", &
              & FIELD_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters,err,error,*999)
            IF(FIELD_COMPONENT%paramToDOFMap%gaussPointParam2DOFMap%numberOfGridPointParameters>0) THEN
            ENDIF
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of data point parameters = ", &
              & FIELD_COMPONENT%paramToDOFMap%dataPointParam2DOFMap%numberOfDataPointParameters,err,error,*999)
            IF(FIELD_COMPONENT%paramToDOFMap%dataPointParam2DOFMap%numberOfDataPointParameters>0) THEN
            ENDIF
          ENDDO !component_idx
        ENDDO !variable_idx
      ENDIF

    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_MAPPINGS_CALCULATE")
    RETURN
999 IF(ALLOCATED(VARIABLE_LOCAL_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_LOCAL_DOFS_OFFSETS)
    IF(ALLOCATED(VARIABLE_GHOST_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_GHOST_DOFS_OFFSETS)
    ERRORSEXITS("FIELD_MAPPINGS_CALCULATE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_MAPPINGS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the dofs to parameters mapping for a field varaible and deallocates all memory.
  SUBROUTINE Field_DofToParamMapFinalise(dofToParamMap,err,error,*)

    !Argument variables
    TYPE(FieldDOFToParamMapType) :: dofToParamMap !<The dof to parameter map to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_DofToParamMapFinalise",err,error,*999)

    IF(ALLOCATED(dofToParamMap%DOFType)) DEALLOCATE(dofToParamMap%DOFType)
    IF(ALLOCATED(dofToParamMap%constantDOF2ParamMap)) DEALLOCATE(dofToParamMap%constantDOF2ParamMap)
    IF(ALLOCATED(dofToParamMap%elementDOF2ParamMap)) DEALLOCATE(dofToParamMap%elementDOF2ParamMap)
    IF(ALLOCATED(dofToParamMap%nodeDOF2ParamMap)) DEALLOCATE(dofToParamMap%nodeDOF2ParamMap)
    IF(ALLOCATED(dofToParamMap%gridPointDOF2ParamMap)) DEALLOCATE(dofToParamMap%gridPointDOF2ParamMap)
    IF(ALLOCATED(dofToParamMap%gaussPointDOF2ParamMap)) DEALLOCATE(dofToParamMap%gaussPointDOF2ParamMap)
    IF(ALLOCATED(dofToParamMap%dataPointDOF2ParamMap)) DEALLOCATE(dofToParamMap%dataPointDOF2ParamMap)
    dofToParamMap%numberOfDofs=0
    dofToParamMap%numberOfConstantDOFs=0
    dofToParamMap%numberOfElementDOFs=0
    dofToParamMap%numberOfNodeDOFs=0
    dofToParamMap%numberOfGridPointDOFs=0
    dofToParamMap%numberOfGaussPointDOFs=0
    dofToParamMap%numberOfDataPointDOFs=0

    EXITS("Field_DofToParamMapFinalise")
    RETURN
999 ERRORSEXITS("Field_DofToParamMapFinalise",err,error)
    RETURN 1
  END SUBROUTINE Field_DofToParamMapFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the dofs to parameters mappings for a field.
  SUBROUTINE Field_DofToParamMapInitialise(dofToParamMap,err,error,*)

    !Argument variables
    TYPE(FieldDOFToParamMapType) :: dofToParamMap !<The dof to parameter map to initialise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Field_DofToParamMapInitialise",err,error,*999)

    dofToParamMap%numberOfDofs=0
    dofToParamMap%numberOfConstantDOFs=0
    dofToParamMap%numberOfElementDOFs=0
    dofToParamMap%numberOfNodeDOFs=0
    dofToParamMap%numberOfGridPointDOFs=0
    dofToParamMap%numberOfGaussPointDOFs=0
    dofToParamMap%numberOfDataPointDOFs=0

    EXITS("Field_DofToParamMapInitialise")
    RETURN
999 ERRORSEXITS("Field_DofToParamMapInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Field_DofToParamMapInitialise

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field. \see OpenCMISS::Iron::cmfe_Field_GeometricFieldSet
  SUBROUTINE FIELD_GEOMETRIC_FIELD_SET(FIELD,GEOMETRIC_FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the geometric field for
    TYPE(FieldType), POINTER :: GEOMETRIC_FIELD !<A pointer to the geometric field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_GEOMETRIC_FIELD_SET",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%geometricFieldLocked) THEN
      localError="The geometric field has been locked for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(ASSOCIATED(FIELD%geometricField)) THEN
      localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
        & " already has a geometric field associated."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(ASSOCIATED(FIELD%DECOMPOSITION)) THEN
      IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
        IF(GEOMETRIC_FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(GEOMETRIC_FIELD%fieldFinished) THEN
            IF(FIELD%DECOMPOSITION%MESH%userNumber==GEOMETRIC_FIELD%DECOMPOSITION%MESH%userNumber) THEN
              SELECT CASE(FIELD%TYPE)
              CASE(FIELD_FIBRE_TYPE,FIELD_GENERAL_TYPE,FIELD_MATERIAL_TYPE,FIELD_GEOMETRIC_GENERAL_TYPE)
                FIELD%geometricField=>GEOMETRIC_FIELD
              CASE(FIELD_GEOMETRIC_TYPE)
                CALL FlagError("Can not set the geometric field for a geometric field.",err,error,*999)
              CASE DEFAULT
                localError="The field type "//TRIM(NumberToVString(FIELD%TYPE,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              localError="The specified field is decomposed on mesh user number "// &
                & TRIM(NumberToVString(FIELD%DECOMPOSITION%MESH%userNumber,"*",err,error))// &
                & " and the geometric field is decomposed on mesh user number "// &
                & TRIM(NumberToVString(GEOMETRIC_FIELD%DECOMPOSITION%MESH%userNumber,"*",err,error))// &
                & ". The two fields must use the same mesh."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The specified geometric field has not been finished.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified geometric field is not a geometric field.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Geometric field is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("The field does not have a decomposition associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_GEOMETRIC_FIELD_SET")
    RETURN
999 ERRORSEXITS("FIELD_GEOMETRIC_FIELD_SET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_GEOMETRIC_FIELD_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field and locks so that no further changes can be made.
  SUBROUTINE FIELD_GEOMETRIC_FIELD_SET_AND_LOCK(FIELD,GEOMETRIC_FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the geometric field for
    TYPE(FieldType), POINTER :: GEOMETRIC_FIELD !<A pointer to the geometric field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_GEOMETRIC_FIELD_SET_AND_LOCK",err,error,*999)

    CALL FIELD_GEOMETRIC_FIELD_SET(FIELD,GEOMETRIC_FIELD,err,error,*999)
    IF(ASSOCIATED(FIELD%createValuesCache)) THEN
      FIELD%createValuesCache%geometricFieldLocked=.TRUE.
    ELSE
      localError="Field create values cache is not associated for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_GEOMETRIC_FIELD_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_GEOMETRIC_FIELD_SET_AND_LOCK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_GEOMETRIC_FIELD_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Calculates the geometric parameters (line lengths, areas, volumes, scaling etc.) for a field.
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_CALCULATE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<The field to calculate the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_GEOMETRIC_PARAMETERS_CALCULATE",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    IF(FIELD%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
      localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is not a geometric field."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    IF(decomposition%calculateLines) CALL Field_GeometricParametersLineLengthsCalculate(FIELD,err,error,*999)
    !IF(decomposition%calculateFaces) CALL Field_GeometricParametersFaceAreasCalculate(FIELD,err,error,*999) 
    CALL Field_GeometricParametersElementVolumesCalculate(FIELD,err,error,*999)

    EXITS("FIELD_GEOMETRIC_PARAMETERS_CALCULATE")
    RETURN
999 ERRORSEXITS("FIELD_GEOMETRIC_PARAMETERS_CALCULATE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the geometric parameters and deallocates all memory.
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_FINALISE(GEOMETRIC_PARAMETERS,err,error,*)

    !Argument variables
    TYPE(FieldGeometricParametersType), POINTER :: GEOMETRIC_PARAMETERS !<A pointer to the geometric field parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx
    TYPE(FieldType), POINTER :: FIELD2

    ENTERS("FIELD_GEOMETRIC_PARAMETERS_FINALISE",err,error,*999)

    IF(ASSOCIATED(GEOMETRIC_PARAMETERS)) THEN
      !Nullify the geometric field pointer of those fields using this geometric field.
      DO field_idx=1,GEOMETRIC_PARAMETERS%numberOfFieldsUsing
        FIELD2=>GEOMETRIC_PARAMETERS%fieldsUsing(field_idx)%ptr
        IF(ASSOCIATED(FIELD2)) NULLIFY(FIELD2%geometricField)
      ENDDO !field_idx
      IF(ASSOCIATED(GEOMETRIC_PARAMETERS%fieldsUsing)) DEALLOCATE(GEOMETRIC_PARAMETERS%fieldsUsing)
      IF(ALLOCATED(GEOMETRIC_PARAMETERS%LENGTHS)) DEALLOCATE(GEOMETRIC_PARAMETERS%LENGTHS)
      !      IF(ALLOCATED(GEOMETRIC_PARAMETERS%AREAS)) DEALLOCATE(GEOMETRIC_PARAMETERS%AREAS) !temporarily commented out
      IF(ALLOCATED(GEOMETRIC_PARAMETERS%VOLUMES)) DEALLOCATE(GEOMETRIC_PARAMETERS%VOLUMES)
      DEALLOCATE(GEOMETRIC_PARAMETERS)
    ENDIF

    EXITS("FIELD_GEOMETRIC_PARAMETERS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_GEOMETRIC_PARAMETERS_FINALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the geometric parameters for a geometric field
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_INITIALISE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx
    TYPE(FieldPtrType), POINTER :: newFieldsUsing(:)

    NULLIFY(newFieldsUsing)

    ENTERS("FIELD_GEOMETRIC_PARAMETERS_INITIALISE",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
        !Field is a geometric field
        ALLOCATE(FIELD%geometricFieldParameters,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate geometric field parameters.",err,error,*999)
        IF(FIELD%DECOMPOSITION%calculateLines) THEN
          FIELD%geometricFieldParameters%numberOfLines=FIELD%DECOMPOSITION%TOPOLOGY%LINES%numberOfLines
          ALLOCATE(FIELD%geometricFieldParameters%lengths(FIELD%geometricFieldParameters%numberOfLines),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate lengths.",err,error,*999)
          FIELD%geometricFieldParameters%LENGTHS=0.0_DP
        ENDIF
        !        IF(FIELD%DECOMPOSITION%calculateFaces) THEN !temporarily commented out
        !          FIELD%geometricFieldParameters%numberOfAreas=FIELD%DECOMPOSITION%TOPOLOGY%FACES%numberOfFaces
        !          ALLOCATE(FIELD%geometricFieldParameters%AREAS(FIELD%geometricFieldParameters%numberOfAreas),STAT=err)
        !          IF(err/=0) CALL FlagError("Could not allocate areas.",err,error,*999)
        !          FIELD%geometricFieldParameters%AREAS=0.0_DP
        !        ENDIF
        FIELD%geometricFieldParameters%numberOfVolumes=FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS%numberOfElements
        ALLOCATE(FIELD%geometricFieldParameters%VOLUMES(FIELD%geometricFieldParameters%numberOfVolumes),STAT=err)
        IF(err/=0) CALL FLAG_ERROR("Could not allocate volumes.",err,error,*999)
        FIELD%geometricFieldParameters%VOLUMES=0.0_DP


        !The field is a geometric field so it must use itself initiallly
        ALLOCATE(FIELD%geometricFieldParameters%fieldsUsing(1),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate fields using.",err,error,*999)
        FIELD%geometricFieldParameters%fieldsUsing(1)%ptr=>FIELD
        FIELD%geometricFieldParameters%numberOfFieldsUsing=1
      ELSE
        !Field is not a geometric field
        NULLIFY(FIELD%geometricFieldParameters)
        IF(ASSOCIATED(FIELD%geometricField)) THEN
          !Set the geometric field so that it knows that this field is using it
          ALLOCATE(newFieldsUsing(FIELD%geometricField%geometricFieldParameters%numberOfFieldsUsing+1),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate new fields using.",err,error,*999)
          DO field_idx=1,FIELD%geometricField%geometricFieldParameters%numberOfFieldsUsing
            newFieldsUsing(field_idx)%ptr=>FIELD%geometricField%geometricFieldParameters%fieldsUsing(field_idx)%ptr
          ENDDO !field_idx
          newFieldsUsing(FIELD%geometricField%geometricFieldParameters%numberOfFieldsUsing+1)%ptr=>FIELD
          FIELD%geometricField%geometricFieldParameters%numberOfFieldsUsing=FIELD%geometricField% &
            & geometricFieldParameters%numberOfFieldsUsing+1
          IF(ASSOCIATED(FIELD%geometricField%geometricFieldParameters%fieldsUsing)) &
            & DEALLOCATE(FIELD%geometricField%geometricFieldParameters%fieldsUsing)
          FIELD%geometricField%geometricFieldParameters%fieldsUsing=>newFieldsUsing
        ELSE
          CALL FlagError("Field does not have a geometric field associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_GEOMETRIC_PARAMETERS_INITIALISE")
    RETURN
999 IF(ASSOCIATED(newFieldsUsing)) DEALLOCATE(newFieldsUsing)
    ERRORSEXITS("FIELD_GEOMETRIC_PARAMETERS_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given element number and element basis line number.
  SUBROUTINE Field_GeometricParametersElementLineLengthGet(field,elementNumber,elementLineNumber,lineLength,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the line length for
    INTEGER(INTG),  INTENT(IN) :: elementNumber !<The element to get the line length for
    INTEGER(INTG), INTENT(IN) :: elementLineNumber !<The element basis line to get the length for
    REAL(DP), INTENT(OUT) :: lineLength !<The line length of the chosen element line number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    TYPE(DecompositionElementType), POINTER :: decompositionElement
    TYPE(DomainElementType), POINTER :: domainElement
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: globalLineNumber

    ENTERS("Field_GeometricParametersElementLineLengthGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%fieldFinished) THEN
        IF(field%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(field%geometricFieldParameters)) THEN
            !\todo user to global element maps not in OpenCMISS?
            IF(elementNumber>=1.AND.elementNumber<=field%DECOMPOSITION%TOPOLOGY%ELEMENTS%numberOfElements) THEN
              domainElement=>field%DECOMPOSITION%DOMAIN(field%decomposition%meshComponentNumber)%ptr% &
                & TOPOLOGY%ELEMENTS%ELEMENTS(elementNumber)
              decompositionElement=>field%DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(elementNumber)
              IF(elementLineNumber>=1.AND.elementLineNumber<=domainElement%BASIS%numberOfLocalLines) THEN
                globalLineNumber=decompositionElement%elementLines(elementLineNumber)
                lineLength=Field%geometricFieldParameters%lengths(globalLineNumber)
              ELSE
                localError="Element basis line number  "//TRIM(NumberToVString(elementNumber,"*",err,error))// &
                  & " is not valid and needs to be >=1 and <="//TRIM(NumberToVString( &
                  & domainElement%BASIS%numberOfLocalLines,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="Element number "//TRIM(NumberToVString(elementNumber,"*",err,error))// &
                & " is not present in this fields decomposition"
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="Geometric parameters are not associated for field number "// &
              & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" is not a geometric field."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_GeometricParametersElementLineLengthGet")
    RETURN
999 ERRORS("Field_GeometricParametersElementLineLengthGet",err,error)
    EXITS("Field_GeometricParametersElementLineLengthGet")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersElementLineLengthGet

  !
  !================================================================================================================================
  !


  !>Gets the volume of  geometric field for a given element number .
  SUBROUTINE Field_GeometricParametersElementVolumeGet(field,elementNumber,elementVolume,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the line length for
    INTEGER(INTG),  INTENT(IN) :: elementNumber !<The element to get the line length for
    REAL(DP), INTENT(OUT) :: elementVolume !<The volume of the chosen element number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    TYPE(DecompositionElementType), POINTER :: decompositionElement
    TYPE(DomainElementType), POINTER :: domainElement
    TYPE(VARYING_STRING) :: localError
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    ENTERS("Field_GeometricParametersElementVolumeGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%fieldFinished) THEN
        IF(field%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(field%geometricFieldParameters)) THEN
            !\todo user to global element maps not in OpenCMISS?

            IF(elementNumber>=1.AND.elementNumber<=field%DECOMPOSITION%TOPOLOGY%ELEMENTS%numberOfElements) THEN
              domainElement=>field%DECOMPOSITION%DOMAIN(field%decomposition%meshComponentNumber)%ptr% &
                & TOPOLOGY%ELEMENTS%ELEMENTS(elementNumber)
              decompositionElement=>field%DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(elementNumber)
              NULLIFY(coordinateSystem)
              CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
              IF(coordinateSystem%numberOfDimensions.EQ.3) THEN 
                elementVolume = field%geometricFieldParameters%VOLUMES(elementNumber)
              ELSE
                localError = "Volumes can only be calculated for 3D elements."
                CALL FlagError(localError,err,error,*999)
              ENDIF

            ELSE
              localError="Element number "//TRIM(NumberToVString(elementNumber,"*",err,error))// &
                & " is not present in this fields decomposition"
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="Geometric parameters are not associated for field number "// &
              & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" is not a geometric field."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_GeometricParametersElementVolumeGet")
    RETURN
999 ERRORS("Field_GeometricParametersElementVolumeGet",err,error)
    EXITS("Field_GeometricParametersElementVolumeGet")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersElementVolumeGet

  !
  !================================================================================================================================
  !

  !>Calculates the element volumes from the parameters of a geometric field. 
  SUBROUTINE Field_GeometricParametersElementVolumesCalculate(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to calculate the face areas for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,elementIdx,gaussPointIdx,maxNumberOfGauss,numberOfGaussPoints,order

    REAL(DP) :: elementVolume
    REAL(DP), ALLOCATABLE :: gaussPoints(:,:),gaussWeights(:)
    TYPE(BasisType), POINTER:: basis
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(FieldInterpolationParametersPtrType), POINTER :: interpolationParameters(:)
    TYPE(FieldInterpolatedPointPtrType), POINTER :: interpolatedPoint(:)
    TYPE(FieldInterpolatedPointMetricsPtrType), POINTER :: interpolatedPointMetrics(:)
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: dummyError,localError

    ENTERS("Field_GeometricParametersElementVolumesCalculate",err,error,*996)

    CALL Field_AssertIsFinished(field,err,error,*999)
    IF(field%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
      localError="Field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//" is not a geometric field."
      CALL FlagError(localError,err,error,*996)
    ENDIF
    IF(.NOT.ASSOCIATED(field%geometricFieldParameters)) THEN
      localError="Geometric parameters are not associated for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*996)
    ENDIF

    NULLIFY(coordinateSystem)
    NULLIFY(interpolationParameters)
    NULLIFY(interpolatedPoint)
    NULLIFY(interpolatedPointMetrics)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    IF(coordinateSystem%numberOfDimensions==3) THEN !only calculate volumes if the object is in 3D
      CALL Field_InterpolationParametersInitialise(field,interpolationParameters,err,error,*999)
      CALL Field_InterpolatedPointsInitialise(interpolationParameters,interpolatedPoint,err,error,*999)
      CALL Field_InterpolatedPointsMetricsInitialise(interpolatedPoint,interpolatedPointMetrics,err,error,*999)
      !Get basis type for the first component of the mesh defined with this geometric field
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(field,decomposition,err,error,*999)
      NULLIFY(decompositionTopology)
      CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
      NULLIFY(decompositionElements)
      CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
      NULLIFY(domain)
      CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
      NULLIFY(basis)
      CALL DomainElements_BasisGet(domainElements,1,basis,err,error,*999)
      !Allocate Gauss points
      order=2
      maxNumberOfGauss=order*order*order
      ALLOCATE(gaussPoints(3,maxNumberOfGauss),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocated gauss points.",err,error,*999)
      ALLOCATE(gaussWeights(maxNumberOfGauss),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocated gauss weights.",err,error,*999)
      !Calculate Gauss points
      CALL Basis_GaussPointsCalculate(basis,order,3,numberOfGaussPoints,gaussPoints,gaussWeights,err,error,*999)
      !Loop over the elements      
      DO elementIdx=1,decompositionElements%numberOfElements
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementIdx, &
          & interpolationParameters(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
        elementVolume=0.0_DP
        DO gaussPointIdx=1,numberOfGaussPoints
          CALL Field_InterpolateXi(FIRST_PART_DERIV,gaussPoints(1:3,gaussPointIdx),interpolatedPoint(FIELD_U_VARIABLE_TYPE)%ptr, &
            & err,error,*999)
          CALL Field_InterpolatedPointMetricsCalculate(COORDINATE_JACOBIAN_VOLUME_TYPE, &
            & interpolatedPointMetrics(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
          elementVolume=elementVolume+InterpolatedPointMetrics(FIELD_U_VARIABLE_TYPE)%ptr%jacobian*gaussWeights(gaussPointIdx)
        ENDDO !gaussPointIdx
        field%geometricFieldParameters%volumes(elementIdx)=elementVolume
      ENDDO !elementIdx
      !Finalise
      DEALLOCATE(gaussWeights)
      DEALLOCATE(gaussPoints)
      CALL Field_InterpolatedPointsMetricsFinalise(interpolatedPointMetrics,err,error,*999)
      CALL Field_InterpolatedPointsFinalise(interpolatedPoint,err,error,*999)
      CALL Field_InterpolationParametersFinalise(interpolationParameters,err,error,*999)
    ENDIF

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Element volumes:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of elements = ",decompositionElements%numberOfElements, &
        & err,error,*999)
      DO elementIdx=1,decompositionElements%numberOfElements
        CALL WriteStringFmtTwoValue(DIAGNOSTIC_OUTPUT_TYPE,"    Element ",elementIdx,"(I8)"," volume = ",field% &
          & geometricFieldParameters%VOLUMES(elementIdx),"*",err,error,*999)
      ENDDO !elementIdx
    ENDIF

    EXITS("Field_GeometricParametersElementVolumesCalculate")
    RETURN
999 IF(ALLOCATED(gaussWeights)) DEALLOCATE(gaussWeights)
    IF(ALLOCATED(gaussPoints)) DEALLOCATE(gaussPoints)
    IF(ASSOCIATED(interpolatedPointMetrics)) &
      & CALL Field_InterpolatedPointsMetricsFinalise(interpolatedPointMetrics,dummyErr,dummyError,*998)
998 IF(ASSOCIATED(interpolatedPoint)) &
      & CALL Field_InterpolatedPointsFinalise(interpolatedPoint,dummyErr,dummyError,*997)
997 IF(ASSOCIATED(interpolationParameters)) &
      & CALL Field_InterpolationParametersFinalise(interpolationParameters,dummyErr,dummyError,*996)
996 ERRORS("Field_GeometricParametersElementVolumesCalculate",err,error)
    EXITS("Field_GeometricParametersElementVolumesCalculate")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersElementVolumesCalculate

  !
  !================================================================================================================================
  !

  !>Calculates the line lengths from the parameters of a geometric field. Old CMISS name LINSCA
  SUBROUTINE Field_GeometricParametersLineLengthsCalculate(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to calculate the line lengths for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,ITERATION_NUMBER,MAXIMUM_DIFFERENCE_LINE,ng,nl
    INTEGER(INTG), PARAMETER :: LINES_MAXIMUM_NUMBER_OF_ITERATIONS=20
    INTEGER(INTG) :: GAUSS_START(4) = [ 0,1,3,6 ]
    INTEGER(INTG) :: NUMBER_OF_GAUSS_POINTS=4
    REAL(DP) :: LAST_MAXIMUM_LENGTH_DIFFERENCE,LENGTH_DIFFERENCE,MAXIMUM_LENGTH_DIFFERENCE,XI(1),W,DERIV_NORM,LINE_LENGTH, &
      & OLD_LINE_LENGTH
    ! Doxygen doesn't like this
    !    REAL(DP) :: XIG(10) = [ 0.500000000000000_DP, &
    !      &                     0.211324865405187_DP,0.788675134594813_DP, &
    !      &                     0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
    !      &                     0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
    !    REAL(DP) :: WIG(10) = [ 1.000000000000000_DP, &
    !      &                     0.500000000000000_DP,0.500000000000000_DP, &
    !      &                     0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP,
    !      &                     0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]
    REAL(DP) :: XIG(10),WIG(10)
    REAL(DP), PARAMETER :: LINE_INCREMENT_TOLERANCE=CONVERGENCE_TOLERANCE
    LOGICAL :: ITERATE,UPDATE_fieldsUsing
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(FieldInterpolatedPointPtrType), POINTER :: INTERPOLATED_POINT(:)
    TYPE(FieldInterpolationParametersPtrType), POINTER :: INTERPOLATION_PARAMETERS(:)
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    XIG = [ 0.500000000000000_DP, &
      &     0.211324865405187_DP,0.788675134594813_DP, &
      &     0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
      &     0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
    WIG = [ 1.000000000000000_DP, &
      &     0.500000000000000_DP,0.500000000000000_DP, &
      &     0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP, &
      &     0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]

    NULLIFY(INTERPOLATED_POINT)
    NULLIFY(INTERPOLATION_PARAMETERS)

    ENTERS("Field_GeometricParametersLineLengthsCalculate",err,error,*997)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(FIELD%geometricFieldParameters)) THEN            
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,err,error,*999)
            !Iterate to find the line lengths as the line lengths depend on the scaling factors and vise versa.
            CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATION_PARAMETERS,err,error,*999)
            CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINT,err,error,*999)
            ITERATE=.TRUE.
            ITERATION_NUMBER=0
            LAST_MAXIMUM_LENGTH_DIFFERENCE=0.0_DP
            DO WHILE(ITERATE.AND.ITERATION_NUMBER<=LINES_MAXIMUM_NUMBER_OF_ITERATIONS)
              MAXIMUM_LENGTH_DIFFERENCE=0.0_DP
              MAXIMUM_DIFFERENCE_LINE=1
              !Loop over the lines
              DO nl=1,FIELD%DECOMPOSITION%TOPOLOGY%LINES%numberOfLines
                CALL FIELD_INTERPOLATION_PARAMETERS_LINE_GET(FIELD_VALUES_SET_TYPE,nl, &
                  & INTERPOLATION_PARAMETERS(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
                OLD_LINE_LENGTH=FIELD%geometricFieldParameters%lengths(nl)
                LINE_LENGTH=0.0_DP
                !Integrate || dr(xi)/dt || from xi=0 to 1 to determine the arc length.
                DO ng=1,NUMBER_OF_GAUSS_POINTS
                  XI(1)=XIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                  W=WIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                  CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,XI,INTERPOLATED_POINT(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
                  CALL COORDINATE_DERIVATIVE_NORM(COORDINATE_SYSTEM,PART_DERIV_S1, &
                    & INTERPOLATED_POINT(FIELD_U_VARIABLE_TYPE)%ptr,DERIV_NORM,err,error,*999)
                  LINE_LENGTH=LINE_LENGTH+W*DERIV_NORM
                ENDDO !ng
                FIELD%geometricFieldParameters%lengths(nl)=LINE_LENGTH
                LENGTH_DIFFERENCE=ABS(LINE_LENGTH-OLD_LINE_LENGTH)/(1.0_DP+OLD_LINE_LENGTH)
                IF(LENGTH_DIFFERENCE>MAXIMUM_LENGTH_DIFFERENCE) THEN
                  MAXIMUM_LENGTH_DIFFERENCE=LENGTH_DIFFERENCE
                  MAXIMUM_DIFFERENCE_LINE=nl
                ENDIF
              ENDDO !nl
              ITERATE=MAXIMUM_LENGTH_DIFFERENCE>LINE_INCREMENT_TOLERANCE
              IF(ITERATE) THEN
                IF(ITERATION_NUMBER==1) THEN
                  LAST_MAXIMUM_LENGTH_DIFFERENCE=MAXIMUM_LENGTH_DIFFERENCE
                ELSE IF(MAXIMUM_LENGTH_DIFFERENCE<LOOSE_TOLERANCE.AND. &
                  & MAXIMUM_LENGTH_DIFFERENCE>=LAST_MAXIMUM_LENGTH_DIFFERENCE) THEN
                  !Seems to be at a numerical limit
                  ITERATE=.FALSE.
                ELSE
                  LAST_MAXIMUM_LENGTH_DIFFERENCE=MAXIMUM_LENGTH_DIFFERENCE
                ENDIF
              ENDIF
              ITERATION_NUMBER=ITERATION_NUMBER+1
              IF(DIAGNOSTICS2) THEN
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Line iteration report:",err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of iterations = ",ITERATION_NUMBER,err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum length difference = ",MAXIMUM_LENGTH_DIFFERENCE, &
                  & err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Difference tolerance = ",LINE_INCREMENT_TOLERANCE, &
                  err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum difference line = ",MAXIMUM_DIFFERENCE_LINE, &
                  err,error,*999)
              ENDIF
              IF(.NOT.ITERATE.OR.ITERATION_NUMBER==LINES_MAXIMUM_NUMBER_OF_ITERATIONS) THEN
                UPDATE_fieldsUsing=.TRUE.
              ELSE
                UPDATE_fieldsUsing=.FALSE.
              ENDIF
              CALL Field_GeometricParametersScaleFactorsUpdate(FIELD,UPDATE_fieldsUsing,err,error,*999)
            ENDDO !iterate
            CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,err,error,*999)
            CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,err,error,*999)
          ELSE
            localError="Geometric parameters are not associated for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is not a geometric field."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Line lengths:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of iterations = ",ITERATION_NUMBER,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum length difference = ",MAXIMUM_LENGTH_DIFFERENCE,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Difference tolerance = ",LINE_INCREMENT_TOLERANCE,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum difference line = ",MAXIMUM_DIFFERENCE_LINE,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of lines = ",FIELD%DECOMPOSITION%TOPOLOGY%LINES%numberOfLines, &
        & err,error,*999)
      DO nl=1,FIELD%DECOMPOSITION%TOPOLOGY%LINES%numberOfLines
        CALL WRITE_STRING_FMT_TWO_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Line ",nl,"(I8)"," length = ",FIELD% &
          & geometricFieldParameters% LENGTHS(nl),"*",err,error,*999)
      ENDDO !nl
    ENDIF

    EXITS("Field_GeometricParametersLineLengthsCalculate")
    RETURN
999 IF(ASSOCIATED(INTERPOLATED_POINT)) CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,DUMMY_ERR,DUMMY_ERROR,*998)
998 IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS, &
      & DUMMY_ERR,DUMMY_ERROR,*997)
997 ERRORS("Field_GeometricParametersLineLengthsCalculate",err,error)
    EXITS("Field_GeometricParametersLineLengthsCalculate")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersLineLengthsCalculate

  !
  !================================================================================================================================
  !

  !>Calculates the face areas from the parameters of a geometric field.
  SUBROUTINE Field_GeometricParametersFaceAreasCalculate(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to calculate the face areas for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    INTEGER(INTG) :: DUMMY_ERR,ng,nf
    INTEGER(INTG) :: GAUSS_START(4) = [ 0,1,3,6 ]
    INTEGER(INTG) :: NUMBER_OF_GAUSS_POINTS=4
    REAL(DP) :: XI(1),W,FACE_AREA
    REAL(DP) :: XIG(10),WIG(10)
    TYPE(CoordinateSystemType), POINTER :: COORDINATE_SYSTEM
    TYPE(FieldInterpolatedPointPtrType), POINTER :: INTERPOLATED_POINT(:)
    TYPE(FieldInterpolatedPointMetricsPtrType), POINTER :: INTERPOLATED_POINT_METRICS(:)
    TYPE(FieldInterpolationParametersPtrType), POINTER :: INTERPOLATION_PARAMETERS(:)
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    XIG = [ 0.500000000000000_DP, &
      &     0.211324865405187_DP,0.788675134594813_DP, &
      &     0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
      &     0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
    WIG = [ 1.000000000000000_DP, &
      &     0.500000000000000_DP,0.500000000000000_DP, &
      &     0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP, &
      &     0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]
    NULLIFY(INTERPOLATED_POINT)
    NULLIFY(INTERPOLATED_POINT_METRICS)
    NULLIFY(INTERPOLATION_PARAMETERS)

    ENTERS("Field_GeometricParametersFaceAreasCalculate",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(FIELD%geometricFieldParameters)) THEN
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,err,error,*999)
            CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATION_PARAMETERS,err,error,*999)
            CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINT,err,error,*999)
            CALL Field_InterpolatedPointsMetricsInitialise(INTERPOLATED_POINT,INTERPOLATED_POINT_METRICS,err,error,*999)

            !Loop over the faces
            DO nf=1,FIELD%DECOMPOSITION%TOPOLOGY%FACES%numberOfFaces
              CALL FIELD_INTERPOLATION_PARAMETERS_FACE_GET(FIELD_VALUES_SET_TYPE,nf, &
                & INTERPOLATION_PARAMETERS(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
              FACE_AREA=0.0_DP
              DO ng=1,NUMBER_OF_GAUSS_POINTS
                XI(1)=XIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                W=WIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,XI,INTERPOLATED_POINT(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
                CALL FIELD_INTERPOLATED_POINT_METRICS_CALCULATE(COORDINATE_JACOBIAN_AREA_TYPE, &
                  & INTERPOLATED_POINT_METRICS(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
                FACE_AREA=FACE_AREA+W*INTERPOLATED_POINT_METRICS(FIELD_U_VARIABLE_TYPE)%ptr%jacobian
              ENDDO !ng
              FIELD%geometricFieldParameters%AREAS(nf)=FACE_AREA
            ENDDO !nf

            CALL Field_InterpolatedPointsMetricsFinalise(INTERPOLATED_POINT_METRICS,err,error,*999)
            CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,err,error,*999)
            CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,err,error,*999)
          ELSE
            localError="Geometric parameters are not associated for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is not a geometric field."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Face areas:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of faces = ",FIELD%DECOMPOSITION%TOPOLOGY%FACES%numberOfFaces, &
        & err,error,*999)
      DO nf=1,FIELD%DECOMPOSITION%TOPOLOGY%FACES%numberOfFaces
        CALL WRITE_STRING_FMT_TWO_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Face ",nf,"(I8)"," area = ",FIELD% &
          & geometricFieldParameters%AREAS(nf),"*",err,error,*999)
      ENDDO !nf
    ENDIF

    EXITS("Field_GeometricParametersFaceAreasCalculate")
    RETURN
999 IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) CALL Field_InterpolatedPointsMetricsFinalise(INTERPOLATED_POINT_METRICS, &
      & DUMMY_ERR,DUMMY_ERROR,*999)
    IF(ASSOCIATED(INTERPOLATED_POINT)) CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,DUMMY_ERR,DUMMY_ERROR,*999)
    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS, &
      & DUMMY_ERR,DUMMY_ERROR,*999)
    ERRORSEXITS("Field_GeometricParametersFaceAreasCalculate",err,error)
    RETURN 1

  END SUBROUTINE Field_GeometricParametersFaceAreasCalculate

  !
  !================================================================================================================================
  !

  !>Finalises the geometric parameters for a field and deallocates all memory.
  SUBROUTINE Field_GeometricParametersScaleFactorsUpdate(FIELD,UPDATE_fieldsUsing,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update the scale factors for
    LOGICAL, INTENT(IN) :: UPDATE_fieldsUsing !<If .TRUE. then update the fields that use this fields geometric parameters.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx,LAST_FIELD_IDX
    TYPE(FieldType), POINTER :: FIELD2

    ENTERS("Field_GeometricParametersScaleFactorsUpdate",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
        IF(UPDATE_fieldsUsing) THEN
          LAST_FIELD_IDX=FIELD%geometricFieldParameters%numberOfFieldsUsing
        ELSE
          LAST_FIELD_IDX=1 !The first field using will be the current field
        ENDIF
        DO field_idx=1,LAST_FIELD_IDX
          FIELD2=>FIELD%geometricFieldParameters%fieldsUsing(field_idx)%ptr
          CALL FIELD_SCALINGS_CALCULATE(FIELD2,err,error,*999)
        ENDDO !field_idx
      ELSE
        CALL FlagError("Field is not geometric field.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_GeometricParametersScaleFactorsUpdate")
    RETURN
999 ERRORSEXITS("Field_GeometricParametersScaleFactorsUpdate",err,error)
    RETURN 1

  END SUBROUTINE Field_GeometricParametersScaleFactorsUpdate

  !
  !================================================================================================================================
  !

  !>Gets the field label for a field for character labels. \see OpenCMISS::Iron::cmfe_Field_LabelGet
  SUBROUTINE FIELD_LABEL_GET_C(FIELD,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the label for
    CHARACTER(LEN=*), INTENT(OUT) :: LABEL !<On return, the field label for the specified field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: C_LENGTH,VS_LENGTH

    ENTERS("FIELD_LABEL_GET_C",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    C_LENGTH=LEN(LABEL)
    VS_LENGTH=LEN_TRIM(FIELD%LABEL)
    IF(C_LENGTH>VS_LENGTH) THEN
      LABEL=CHAR(LEN_TRIM(FIELD%LABEL))
    ELSE
      LABEL=CHAR(FIELD%LABEL,C_LENGTH)
    ENDIF

    EXITS("FIELD_LABEL_GET_C")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_GET_C",err,error)
    RETURN 1

  END SUBROUTINE FIELD_LABEL_GET_C

  !
  !================================================================================================================================
  !

  !>Gets the field label for a field for varying string labels. \see OpenCMISS::Iron::cmfe_Field_LabelGet
  SUBROUTINE FIELD_LABEL_GET_VS(FIELD,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the label for
    TYPE(VARYING_STRING), INTENT(OUT) :: LABEL !<On return, the field label for the specified field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_LABEL_GET_VS",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    LABEL=FIELD%LABEL

    EXITS("FIELD_LABEL_GET_VS")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_GET_VS",err,error)
    RETURN 1
  END SUBROUTINE FIELD_LABEL_GET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for character labels. \see OpenCMISS::Iron::cmfe_Field_LabelSet
  SUBROUTINE FIELD_LABEL_SET_C(FIELD,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the type for
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_LABEL_SET_C",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%LABEL_LOCKED) THEN
      localError="The field label has been locked for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    FIELD%LABEL=LABEL

    EXITS("FIELD_LABEL_SET_C")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_SET_C",err,error)
    RETURN 1

  END SUBROUTINE FIELD_LABEL_SET_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for varying string labels. \see OpenCMISS::Iron::cmfe_Field_LabelSet
  SUBROUTINE FIELD_LABEL_SET_VS(FIELD,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the type for
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_LABEL_SET_VS",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%LABEL_LOCKED) THEN
      localError="The field label has been locked for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    FIELD%LABEL=LABEL

    EXITS("FIELD_LABEL_SET_VS")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_SET_VS",err,error)
    RETURN 1

  END SUBROUTINE FIELD_LABEL_SET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for character labels and locks it so that no further changes can be made.
  SUBROUTINE FIELD_LABEL_SET_AND_LOCK_C(FIELD,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the type for
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The field label to set 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("FIELD_LABEL_SET_AND_LOCK_C",err,error,*999)

    CALL FIELD_LABEL_SET(FIELD,LABEL,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    createValuesCache%LABEL_LOCKED=.TRUE.

    EXITS("FIELD_LABEL_SET_AND_LOCK_C")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_SET_AND_LOCK_C",err,error)
    RETURN 1

  END SUBROUTINE FIELD_LABEL_SET_AND_LOCK_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for varying string labels and locks it so that no further changes can be made.
  SUBROUTINE FIELD_LABEL_SET_AND_LOCK_VS(FIELD,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the type for
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The field label to set 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("FIELD_LABEL_SET_AND_LOCK_VS",err,error,*999)

    CALL FIELD_LABEL_SET(FIELD,LABEL,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    createValuesCache%LABEL_LOCKED=.TRUE.

    EXITS("FIELD_LABEL_SET_AND_LOCK_VS")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_SET_AND_LOCK_VS",err,error)
    RETURN 1

  END SUBROUTINE FIELD_LABEL_SET_AND_LOCK_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field. \see OpenCMISS::Iron::cmfe_Field_DecompositionSet
  SUBROUTINE FIELD_MESH_DECOMPOSITION_SET(FIELD,MESH_DECOMPOSITION,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the decomposition for
    TYPE(DecompositionType), POINTER :: MESH_DECOMPOSITION !<A pointer to the mesh decomposition to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(MeshType), POINTER :: MESH
    TYPE(InterfaceType), POINTER :: MESH_INTERFACE,FIELD_INTERFACE
    TYPE(RegionType), POINTER :: MESH_REGION,FIELD_REGION,PARENT_REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_MESH_DECOMPOSITION_SET",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    CALL Decomposition_AssertIsDecomposed(MESH_DECOMPOSITION,err,error,*999)

    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%DECOMPOSITION_LOCKED) THEN
      localError="The mesh decomposition has been locked for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    MESH=>MESH_DECOMPOSITION%MESH
    IF(ASSOCIATED(MESH)) THEN
      NULLIFY(MESH_INTERFACE)
      MESH_REGION=>MESH%REGION
      IF(ASSOCIATED(MESH_REGION)) THEN
        NULLIFY(FIELD_INTERFACE)
        FIELD_REGION=>FIELD%REGION
        IF(ASSOCIATED(FIELD_REGION)) THEN
          IF(MESH_REGION%userNumber==FIELD_REGION%userNumber) THEN
            FIELD%DECOMPOSITION=>MESH_DECOMPOSITION
          ELSE
            localError="Inconsitent regions. The field is defined on region number "// &
              & TRIM(NumberToVString(FIELD%REGION%userNumber,"*",err,error))// &
              & " and the mesh decomposition is defined on region number "//&
              & TRIM(NumberToVString(MESH_DECOMPOSITION%MESH%REGION%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          FIELD_INTERFACE=>FIELD%INTERFACE
          IF(ASSOCIATED(FIELD_INTERFACE)) THEN
            PARENT_REGION=>FIELD_INTERFACE%parentRegion
            IF(ASSOCIATED(PARENT_REGION)) THEN
              localError="Inconsitent setup. The field is defined on interface number "// &
                & TRIM(NumberToVString(FIELD_INTERFACE%userNumber,"*",err,error))// &
                & " of parent region number "//TRIM(NumberToVString(PARENT_REGION%userNumber,"*",err,error))// &
                & " and the mesh decomposition is defined on region number "// &
                & TRIM(NumberToVString(MESH_REGION%userNumber,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ELSE
              CALL FlagError("Field interface has no parent region.",err,error,*999)
            ENDIF
          ELSE
            localError="Region or interface is not associated for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ENDIF
      ELSE
        MESH_INTERFACE=>MESH%INTERFACE
        IF(ASSOCIATED(MESH_INTERFACE)) THEN
          PARENT_REGION=>MESH_INTERFACE%parentRegion
          IF(ASSOCIATED(PARENT_REGION)) THEN
            FIELD_REGION=>FIELD%REGION
            IF(ASSOCIATED(FIELD_REGION)) THEN
              localError="Inconsitent setup. The field is defined on region number "// &
                & TRIM(NumberToVString(FIELD_REGION%userNumber,"*",err,error))// &
                & " and the mesh decomposition is defined on interface number "// &
                & TRIM(NumberToVString(MESH_INTERFACE%userNumber,"*",err,error))// &
                & " of parent region number "//TRIM(NumberToVString(PARENT_REGION%userNumber,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ELSE
              FIELD_INTERFACE=>FIELD%INTERFACE
              IF(ASSOCIATED(FIELD_INTERFACE)) THEN
                PARENT_REGION=>FIELD_INTERFACE%parentRegion
                IF(ASSOCIATED(PARENT_REGION)) THEN
                  IF(MESH_INTERFACE%userNumber==FIELD_INTERFACE%userNumber) THEN
                    FIELD%DECOMPOSITION=>MESH_DECOMPOSITION
                  ELSE
                    localError="Inconsitent interfaces. The field is defined on interface number "// &
                      & TRIM(NumberToVString(FIELD_INTERFACE%userNumber,"*",err,error))// &
                      & " of parent region number "// &
                      & TRIM(NumberToVString(PARENT_REGION%userNumber,"*",err,error))// &
                      & " and the mesh decomposition is defined on region number "//&
                      & TRIM(NumberToVString(MESH_REGION%userNumber,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)

                  ENDIF
                ELSE
                  CALL FlagError("Field interface parent region is not associated.",err,error,*999)
                ENDIF
              ELSE
                localError="Region or interface is not associated for field number "// &
                  & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)                        
              ENDIF
            ENDIF
          ELSE
            CALL FlagError("Mesh interface parent region is not associated.",err,error,*999)
          ENDIF
        ELSE
          localError="Region or interface is not associated for mesh number "// &
            & TRIM(NumberToVString(MESH%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)                        
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Mesh is not associated for the mesh decomposition.",err,error,*999)
    ENDIF

    EXITS("FIELD_MESH_DECOMPOSITION_SET")
    RETURN
999 ERRORSEXITS("FIELD_MESH_DECOMPOSITION_SET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_MESH_DECOMPOSITION_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field and locks so that no further changes can be made.
  SUBROUTINE FIELD_MESH_DECOMPOSITION_SET_AND_LOCK(FIELD,MESH_DECOMPOSITION,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the decomposition for
    TYPE(DecompositionType), POINTER :: MESH_DECOMPOSITION !<A pointer to the mesh decomposition to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("FIELD_MESH_DECOMPOSITION_SET_AND_LOCK",err,error,*999)

    CALL FIELD_MESH_DECOMPOSITION_SET(FIELD,MESH_DECOMPOSITION,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)

    createValuesCache%DECOMPOSITION_LOCKED=.TRUE.

    EXITS("FIELD_MESH_DECOMPOSITION_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_MESH_DECOMPOSITION_SET_AND_LOCK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_MESH_DECOMPOSITION_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field. \see OpenCMISS::Iron::cmfe_Field_DataProjectionSet
  SUBROUTINE Field_DataProjectionSet(field,dataProjection,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to set the decomposition for
    TYPE(DataProjectionType), POINTER :: dataProjection !<A pointer to the data projection to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    TYPE(VARYING_STRING) :: localError
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("Field_DataProjectionSet",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    IF(.NOT.ASSOCIATED(dataProjection)) CALL FlagError("Data projection is not associated.",err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)

    IF(createValuesCache%dataProjectionLocked) THEN
      localError="The data projection has been locked for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    field%DataProjection=>dataProjection

    EXITS("Field_DataProjectionSet")
    RETURN
999 ERRORSEXITS("Field_DataProjectionSet",err,error)
    RETURN 1

  END SUBROUTINE Field_DataProjectionSet

  !
  !================================================================================================================================
  !

  !>Checks the number of field components for a field variable.
  SUBROUTINE Field_NumberOfComponentsCheck(field,variableType,numberOfComponents,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to check the number of components
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !The number of components in the field variable to check
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_NumberOfComponentsCheck",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(field%fieldFinished) THEN
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
      IF(fieldVariable%numberOfComponents/=numberOfComponents) THEN
        localError="Invalid number of components. The number components for variable type "// &
          & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
          & TRIM(NumberToVString(field%userNumber,"*",err,error))//" is "// &
          & TRIM(NumberToVString(fieldVariable%numberOfComponents,"*",err,error))// &
          & " which does not correspond to the specified number of components of "// &
          & TRIM(NumberToVString(numberOFComponents,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      !Field has not been finished so check the create values cache.
      NULLIFY(createValuesCache)
      CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
      IF(.NOT.ALLOCATED(createValuesCache%numberOfComponents)) THEN
        localError="The create values cache number of components is not allocated for field number "// &
          & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      IF(createValuesCache%numberOfComponents(variableType)/=numberOfComponents) THEN
        fieldVariable=>field%variableTypeMap(variableType)%ptr
        IF(ASSOCIATED(fieldVariable)) THEN
          localError="Invalid number of components. The number components for variable type "// &
            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(field%userNumber,"*",err,error))//" is "// &
            & TRIM(NumberToVString(fieldVariable%numberOfComponents,"*",err,error))// &
            & " which does not correspond to the specified number of components of "// &
            & TRIM(NumberToVString(numberOFComponents,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ELSE
          localError="Invalid number of components. The number components for variable type "// &
            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
            & TRIM(NumberToVString(field%userNumber,"*",err,error))// &
            & " does not correspond to the specified number of components of "// &
            & TRIM(NumberToVString(numberOFComponents,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ENDIF
    ENDIF

    EXITS("Field_NumberOfComponentsCheck")
    RETURN
999 ERRORSEXITS("Field_NumberOfComponentsCheck",err,error)
    RETURN 1

  END SUBROUTINE Field_NumberOfComponentsCheck

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of field components for a field variable. \see OpenCMISS::Iron::cmfe_Field_NumberOfComponentsSet
  SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET(FIELD,VARIABLE_TYPE,NUMBER_OF_COMPONENTS,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the number of components
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_COMPONENTS !<The number of components to be set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,NEW_NUMBER_OF_COMPONENTS,OLD_NUMBER_OF_COMPONENTS,OVERLAP_NUMBER_OF_COMPONENTS,variable_idx
    INTEGER(INTG), ALLOCATABLE :: NEW_INTERPOLATION_TYPE(:,:),NEW_meshComponentNumber(:,:)
    LOGICAL, ALLOCATABLE ::NEW_componentLabelsLocked(:,:), NEW_INTERPOLATION_TYPE_LOCKED(:,:), &
      & NEW_meshComponentNumberLocked(:,:)
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError
    TYPE(VARYING_STRING), ALLOCATABLE :: NEW_componentLabels(:,:)

    ENTERS("FIELD_NUMBER_OF_COMPONENTS_SET",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)

    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(VARIABLE_TYPE<1.OR.VARIABLE_TYPE>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " is invalid. The variable type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ANY(FIELD%createValuesCache%variableTypes==VARIABLE_TYPE)) THEN
      localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)      
    ENDIF
    IF(createValuesCache%numberOfComponentsLocked(VARIABLE_TYPE)) THEN
      localError="The number of components has been locked for variable type "// &
        & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    SELECT CASE(createValuesCache%DIMENSION(VARIABLE_TYPE))
    CASE(FIELD_SCALAR_DIMENSION_TYPE)
      IF(NUMBER_OF_COMPONENTS/=1) THEN
        localError="Scalar fields cannot have "//TRIM(NumberToVString(NUMBER_OF_COMPONENTS,"*",err,error))// &
          & " components."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    CASE(FIELD_VECTOR_DIMENSION_TYPE)
      IF(NUMBER_OF_COMPONENTS<=0) THEN
        localError="Vector fields cannot have "//TRIM(NumberToVString(NUMBER_OF_COMPONENTS,"*",err,error))// &
          & " components."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      IF(createValuesCache%numberOfComponents(VARIABLE_TYPE)/=NUMBER_OF_COMPONENTS) THEN
        OLD_NUMBER_OF_COMPONENTS=MAXVAL(createValuesCache%numberOfComponents)
        NEW_NUMBER_OF_COMPONENTS=NUMBER_OF_COMPONENTS
        DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          IF(createValuesCache%numberOfComponents(variable_idx) > NEW_NUMBER_OF_COMPONENTS) THEN 
            IF(variable_idx /= VARIABLE_TYPE) NEW_NUMBER_OF_COMPONENTS=createValuesCache%numberOfComponents(variable_idx)

          ENDIF
        ENDDO
        OVERLAP_NUMBER_OF_COMPONENTS=MIN(OLD_NUMBER_OF_COMPONENTS,NEW_NUMBER_OF_COMPONENTS)
        ALLOCATE(NEW_componentLabels(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new component labels.",err,error,*999)
        ALLOCATE(NEW_componentLabelsLocked(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new component labels locked.",err,error,*999)
        ALLOCATE(NEW_INTERPOLATION_TYPE(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new interpolation type.",err,error,*999)
        ALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new interpolation type locked.",err,error,*999)
        ALLOCATE(NEW_meshComponentNumber(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new mesh component number.",err,error,*999)
        ALLOCATE(NEW_meshComponentNumberLocked(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new mesh component number locked.",err,error,*999)

        NEW_componentLabels=''
        NEW_componentLabelsLocked=.FALSE.
        NEW_INTERPOLATION_TYPE=0
        NEW_INTERPOLATION_TYPE_LOCKED=.FALSE.
        NEW_meshComponentNumber=0                   
        NEW_meshComponentNumberLocked=.FALSE.
        NEW_componentLabels(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
          & createValuesCache%componentLabels(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
        NEW_componentLabelsLocked(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
          & createValuesCache%componentLabelsLocked(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
        NEW_INTERPOLATION_TYPE(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
          & createValuesCache%interpolationTypes(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
        NEW_INTERPOLATION_TYPE_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
          & createValuesCache%interpolationTypesLocked(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
        NEW_meshComponentNumber(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
          & createValuesCache%meshComponentNumber(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
        NEW_meshComponentNumberLocked(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
          & createValuesCache%meshComponentNumberLocked(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
        !Update remaining terms
        IF(OLD_NUMBER_OF_COMPONENTS<NUMBER_OF_COMPONENTS) THEN
          DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
            DO component_idx=OLD_NUMBER_OF_COMPONENTS+1,NUMBER_OF_COMPONENTS
              NEW_componentLabels(component_idx,variable_idx)= &
                & TRIM(NumberToVString(component_idx,"*",err,error))
              IF(err/=0) GOTO 999
            ENDDO
            NEW_INTERPOLATION_TYPE(OLD_NUMBER_OF_COMPONENTS+1:NUMBER_OF_COMPONENTS,variable_idx) = &
              & createValuesCache%interpolationTypes(1,variable_idx)
            NEW_meshComponentNumber(OLD_NUMBER_OF_COMPONENTS+1:NUMBER_OF_COMPONENTS,variable_idx) = &
              & createValuesCache%meshComponentNumber(1,variable_idx)
          ENDDO
        ENDIF

        CALL MOVE_ALLOC(NEW_componentLabels,createValuesCache%componentLabels)
        CALL MOVE_ALLOC(NEW_componentLabelsLocked,createValuesCache%componentLabelsLocked)
        CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE,createValuesCache%interpolationTypes)
        CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE_LOCKED,createValuesCache%interpolationTypesLocked)
        CALL MOVE_ALLOC(NEW_meshComponentNumber,createValuesCache%meshComponentNumber)
        CALL MOVE_ALLOC(NEW_meshComponentNumberLocked,createValuesCache%meshComponentNumberLocked)

        createValuesCache%numberOfComponents(VARIABLE_TYPE)=NUMBER_OF_COMPONENTS
      ENDIF
    CASE(FIELD_TENSOR_DIMENSION_TYPE)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="Field dimension "//TRIM(NumberToVString(createValuesCache%DIMENSION(VARIABLE_TYPE),"*",err,error))// &
        & " is not valid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("FIELD_NUMBER_OF_COMPONENTS_SET")
    RETURN
999 IF(ALLOCATED(NEW_componentLabels)) DEALLOCATE(NEW_componentLabels)
    IF(ALLOCATED(NEW_componentLabelsLocked)) DEALLOCATE(NEW_componentLabelsLocked)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE)) DEALLOCATE(NEW_INTERPOLATION_TYPE)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE_LOCKED)) DEALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED)
    IF(ALLOCATED(NEW_meshComponentNumber)) DEALLOCATE(NEW_meshComponentNumber)
    IF(ALLOCATED(NEW_meshComponentNumberLocked)) DEALLOCATE(NEW_meshComponentNumberLocked)
    ERRORSEXITS("FIELD_NUMBER_OF_COMPONENTS_SET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of field components for a field variable and locks so that no further changes can be made.
  SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK(FIELD,VARIABLE_TYPE,NUMBER_OF_COMPONENTS,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the number of components
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_COMPONENTS !<The number of components to be set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK",err,error,*999)

    CALL FIELD_NUMBER_OF_COMPONENTS_SET(FIELD,VARIABLE_TYPE,NUMBER_OF_COMPONENTS,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    createValuesCache%numberOfComponentsLocked(VARIABLE_TYPE)=.TRUE.

    EXITS("FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks the number of variables for a field.
  SUBROUTINE FIELD_NUMBER_OF_VARIABLES_CHECK(FIELD,NUMBER_OF_VARIABLES,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to check the number of variables for
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_VARIABLES !<The number of variables in the specified field to check
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_NUMBER_OF_VARIABLES_CHECK",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    IF(FIELD%numberOfVariables/=NUMBER_OF_VARIABLES) THEN
      localError="Invalid number of variables. The number of variables for field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
        & TRIM(NumberToVString(FIELD%numberOfVariables,"*",err,error))// &
        & " which is does correspond to the specified number of variables of "// &
        & TRIM(NumberToVString(NUMBER_OF_VARIABLES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FIELD_NUMBER_OF_VARIABLES_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_NUMBER_OF_VARIABLES_CHECK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_NUMBER_OF_VARIABLES_CHECK

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field. \see OpenCMISS::Iron::cmfe_Field_NumberOfVariablesSet
  SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET(FIELD,NUMBER_OF_VARIABLES,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the number of variables for
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_VARIABLES !<The number of variables to set for the field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx,variable_idx2,variable_type
    INTEGER(INTG), ALLOCATABLE :: oldVariableTypes(:)
    LOGICAL :: FOUND
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_NUMBER_OF_VARIABLES_SET",err,error,*999)

    CALL Field_AssertNotFinished(field,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    IF(createValuesCache%numberOfVariablesLocked) THEN
      localError="The number of variables has been locked field number "// &
        & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    IF(NUMBER_OF_VARIABLES<1.OR.NUMBER_OF_VARIABLES>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
      localError="The specified number of variables of "//TRIM(NumberToVString(NUMBER_OF_VARIABLES,"*",err,error))// &
        & " is invalid. The number of variables must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(FIELD%numberOfVariables/=NUMBER_OF_VARIABLES) THEN
      ALLOCATE(oldVariableTypes(FIELD%numberOfVariables),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate old variable types.",err,error,*999)
      oldVariableTypes(1:FIELD%numberOfVariables)=createValuesCache%variableTypes(1:FIELD%numberOfVariables)
      DEALLOCATE(createValuesCache%variableTypes)
      ALLOCATE(createValuesCache%variableTypes(NUMBER_OF_VARIABLES),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate variable types.",err,error,*999)
      createValuesCache%variableTypes=0
      IF(NUMBER_OF_VARIABLES<FIELD%numberOfVariables) THEN
        createValuesCache%variableTypes(1:NUMBER_OF_VARIABLES)=oldVariableTypes(1:NUMBER_OF_VARIABLES)
        DO variable_idx=NUMBER_OF_VARIABLES+1,FIELD%numberOfVariables
          variable_type=oldVariableTypes(variable_idx)
          createValuesCache%variableLabels(variable_type)=""
          createValuesCache%variableLabelsLocked(variable_type)=.FALSE.
          createValuesCache%DIMENSION(variable_type)=0
          createValuesCache%DIMENSION_LOCKED(variable_type)=.FALSE.
          createValuesCache%dataTypes(variable_type)=0
          createValuesCache%dataTypesLocked(variable_type)=.FALSE.
          createValuesCache%dofOrderTypes(variable_type)=0
          createValuesCache%dofOrderTypesLocked(variable_type)=.FALSE.
          createValuesCache%numberOfComponents(variable_type)=0
          createValuesCache%numberOfComponentsLocked(variable_type)=.FALSE.
          createValuesCache%interpolationTypes(:,variable_type)=0
          createValuesCache%interpolationTypesLocked(:,variable_type)=.FALSE.
          createValuesCache%meshComponentNumber(:,variable_type)=0
          createValuesCache%meshComponentNumberLocked(:,variable_type)=.FALSE.
        ENDDO !variable_idx
      ELSE
        createValuesCache%variableTypes(1:FIELD%numberOfVariables)=oldVariableTypes(1:FIELD%numberOfVariables)
        DO variable_idx=FIELD%numberOfVariables+1,NUMBER_OF_VARIABLES
          !Find the next available variable type
          DO variable_type=1,FIELD_NUMBER_OF_VARIABLE_TYPES
            FOUND=.FALSE.
            DO variable_idx2=1,FIELD%numberOfVariables
              IF(createValuesCache%variableTypes(variable_idx2)==variable_type) THEN
                FOUND=.TRUE.
                EXIT
              ENDIF
            ENDDO !variable_idx2
            IF(.NOT.FOUND) EXIT
          ENDDO !variable_type
          IF(FOUND) THEN
            CALL FlagError("Could not find free variable type???",err,error,*999)
          ELSE
            createValuesCache%variableTypes(variable_idx)=variable_type
            SELECT CASE(variable_type)
            CASE(FIELD_U_VARIABLE_TYPE)
              createValuesCache%variableLabels(variable_type)="U"
            CASE(FIELD_DELUDELN_VARIABLE_TYPE)
              createValuesCache%variableLabels(variable_type)="del U/del n"
            CASE(FIELD_DELUDELT_VARIABLE_TYPE)
              createValuesCache%variableLabels(variable_type)="del U/del t"
            CASE(FIELD_DEL2UDELT2_VARIABLE_TYPE)
              createValuesCache%variableLabels(variable_type)="del^2 U/del t^2"
            CASE(FIELD_V_VARIABLE_TYPE)
              createValuesCache%variableLabels(variable_type)="V"
            CASE(FIELD_DELVDELN_VARIABLE_TYPE)
              createValuesCache%variableLabels(variable_type)="del V/del n"
            CASE DEFAULT
              localError="The variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            createValuesCache%variableLabelsLocked(variable_type)=.FALSE.
            createValuesCache%DIMENSION(variable_type)=createValuesCache%DIMENSION(oldVariableTypes(1))
            createValuesCache%DIMENSION_LOCKED(variable_type)=.FALSE.
            createValuesCache%dataTypes(variable_type)=createValuesCache%dataTypes(oldVariableTypes(1))
            createValuesCache%dataTypesLocked(variable_type)=.FALSE.
            createValuesCache%dofOrderTypes(variable_type)=createValuesCache%dofOrderTypes(oldVariableTypes(1))
            createValuesCache%dofOrderTypesLocked(variable_type)=.FALSE.
            createValuesCache%numberOfComponents(variable_type)=createValuesCache%numberOfComponents(oldVariableTypes(1))
            createValuesCache%numberOfComponentsLocked(variable_type)=.FALSE.
            createValuesCache%componentLabels(:,variable_type)=createValuesCache%componentLabels(:,createValuesCache% &
              & variableTypes(oldVariableTypes(1)))
            createValuesCache%componentLabelsLocked(:,variable_type)=.FALSE.
            createValuesCache%interpolationTypes(:,variable_type)=createValuesCache% interpolationTypes(:,createValuesCache% &
              & variableTypes(oldVariableTypes(1)))
            createValuesCache%interpolationTypesLocked(:,variable_type)=.FALSE.
            createValuesCache%meshComponentNumber(:,variable_type)=createValuesCache%meshComponentNumber(:,createValuesCache% &
              & variableTypes(oldVariableTypes(1)))
            createValuesCache%meshComponentNumberLocked(:,variable_type)=.FALSE.
          ENDIF
        ENDDO !variable_idx
      ENDIF
      DEALLOCATE(oldVariableTypes)
      FIELD%numberOfVariables=NUMBER_OF_VARIABLES
    ENDIF

    EXITS("FIELD_NUMBER_OF_VARIABLES_SET")
    RETURN
999 IF(ALLOCATED(oldVariableTypes)) DEALLOCATE(oldVariableTypes)
    ERRORSEXITS("FIELD_NUMBER_OF_VARIABLES_SET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field and locks so that no further changes can be made.
  SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK(FIELD,NUMBER_OF_VARIABLES,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the number of variables for
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_VARIABLES !<The number of variables to set for the field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldCreateValuesCacheType), POINTER :: createValuesCache

    ENTERS("FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK",err,error,*999)

    CALL FIELD_NUMBER_OF_VARIABLES_SET(FIELD,NUMBER_OF_VARIABLES,err,error,*999)
    NULLIFY(createValuesCache)
    CALL Field_CreateValuesCacheGet(field,createValuesCache,err,error,*999)
    createValuesCache%numberOfVariablesLocked=.TRUE.

    EXITS("FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK",err,error)
    RETURN 1

  END SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type \todo make this call distributed vector add??? 
  SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP(FIELD,VARIABLE_TYPE,ALPHA,FIELD_FROM_SET_TYPE,FIELD_TO_SET_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add the parameter sets for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: ALPHA(:) !<The multiplicative factor for the add.
    INTEGER(INTG), INTENT(IN) :: FIELD_FROM_SET_TYPE(:) !<The field parameter set identifier to add the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_TO_SET_TYPE !<The field parameter set identifier to add the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx,parameter_set_idx
    REAL(DP) :: VALUE
    TYPE(REAL_DP_PTR_TYPE) :: FIELD_FROM_PARAMETERS(SIZE(FIELD_FROM_SET_TYPE,1))
    TYPE(FieldParameterSetType), POINTER :: FIELD_TO_PARAMETER_SET
    TYPE(FieldParameterSetPtrType) :: FIELD_FROM_PARAMETER_SETS(SIZE(FIELD_FROM_SET_TYPE,1))
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SETS_ADD_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    IF(SIZE(ALPHA,1)/=SIZE(FIELD_FROM_SET_TYPE,1)) THEN
      localError="The size of the alpha array of "//TRIM(NumberToVString(SIZE(ALPHA,1),"*",err,error))// &
        & " does not match the size of the from set type array of "// &
        & TRIM(NumberToVString(SIZE(FIELD_FROM_SET_TYPE,1),"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    !Get the to parameter set
    NULLIFY(FIELD_TO_PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_TO_SET_TYPE,FIELD_TO_PARAMETER_SET,err,error,*999)
    !Get the from parameter sets and their data
    DO parameter_set_idx=1,SIZE(FIELD_FROM_SET_TYPE,1)
      NULLIFY(FIELD_FROM_PARAMETER_SETS(parameter_set_idx)%ptr)
      CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_FROM_SET_TYPE(parameter_set_idx), &
        & FIELD_FROM_PARAMETER_SETS(parameter_set_idx)%ptr,err,error,*999)
      NULLIFY(FIELD_FROM_PARAMETERS(parameter_set_idx)%ptr)
      CALL DistributedVector_DataGet(FIELD_FROM_PARAMETER_SETS(parameter_set_idx)%ptr%PARAMETERS, &
        & FIELD_FROM_PARAMETERS(parameter_set_idx)%ptr,err,error,*999)
    ENDDO
    !Do not need to do an update here as each rank already has the values.
    !Add the field dofs
    DO dof_idx=1,FIELD_VARIABLE%totalNumberOfDofs
      VALUE=0.0_DP
      DO parameter_set_idx=1,SIZE(FIELD_FROM_SET_TYPE,1)
        VALUE=VALUE+ALPHA(parameter_set_idx)*FIELD_FROM_PARAMETERS(parameter_set_idx)%ptr(dof_idx)
      ENDDO !parameter_set_idx
      CALL DistributedVector_ValuesAdd(FIELD_TO_PARAMETER_SET%PARAMETERS,dof_idx,VALUE,err,error,*999)
    ENDDO !dof_idx
    !Restore the from parameter set transfer
    DO parameter_set_idx=1,SIZE(FIELD_FROM_SET_TYPE,1)
      CALL DistributedVector_DataRestore(FIELD_FROM_PARAMETER_SETS(parameter_set_idx)%ptr%PARAMETERS, &
        & FIELD_FROM_PARAMETERS(parameter_set_idx)%ptr,err,error,*999)
    ENDDO !parameter_set_idx

    EXITS("FIELD_PARAMETER_SETS_ADD_DP")

    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SETS_ADD_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP

  !
  !================================================================================================================================
  !

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type \todo make this call distributed vector add???
  SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP1(FIELD,VARIABLE_TYPE,ALPHA,FIELD_FROM_SET_TYPE,FIELD_TO_SET_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add the parameter sets for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINE
    REAL(DP), INTENT(IN) :: ALPHA !<The multiplicative factor for the add.
    INTEGER(INTG), INTENT(IN) :: FIELD_FROM_SET_TYPE !<The field parameter set identifier to add the parameters from
    INTEGER(INTG), INTENT(IN) :: FIELD_TO_SET_TYPE !<The field parameter set identifier to add the parameters to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_PARAMETER_SETS_ADD_DP1",err,error,*999)

    CALL FIELD_PARAMETER_SETS_ADD_DP(FIELD,VARIABLE_TYPE,[ALPHA],[FIELD_FROM_SET_TYPE],FIELD_TO_SET_TYPE,err,error,*999)

    EXITS("FIELD_PARAMETER_SETS_ADD_DP1")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SETS_ADD_DP1",err,error)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP1

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type for a field
  SUBROUTINE Field_ParameterSetsCopy(field,variableType,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to copy \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetsCopy",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetsCopy(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*999)

    EXITS("Field_ParameterSetsCopy")
    RETURN
999 ERRORSEXITS("Field_ParameterSetsCopy",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetsCopy

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type if they exist for a field
  SUBROUTINE Field_ParameterSetsCopyIfExists(field,variableType,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to copy \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetsCopyIfExists",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetsCopyIfExists(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*999)

    EXITS("Field_ParameterSetsCopyIfExists")
    RETURN
999 ERRORSEXITS("Field_ParameterSetsCopyIfExists",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetsCopyIfExists

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable.
  SUBROUTINE Field_ParametersToFieldParametersCopy(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
    & FROM_COMPONENT_NUMBER,TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE,TO_COMPONENT_NUMBER,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FROM_FIELD !<A pointer to the field to copy from
    INTEGER(INTG), INTENT(IN) :: FROM_VARIABLE_TYPE !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: FROM_PARAMETER_SET_TYPE !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: FROM_COMPONENT_NUMBER !<The field variable component number to copy from
    TYPE(FieldType), POINTER :: TO_FIELD !<A pointer to the field to copy to
    INTEGER(INTG), INTENT(IN) :: TO_VARIABLE_TYPE !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: TO_PARAMETER_SET_TYPE !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: TO_COMPONENT_NUMBER !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: elem_idx,deriv_idx,version_idx,local_ny,node_idx,VALUE_INTG,gausspoint_idx
    INTEGER(INTG), POINTER :: FROM_PARAMETER_DATA_INTG(:)
    REAL(SP) :: VALUE_SP
    REAL(SP), POINTER :: FROM_PARAMETER_DATA_SP(:)
    REAL(DP) :: VALUE_DP
    REAL(DP), POINTER :: FROM_PARAMETER_DATA_DP(:)
    LOGICAL :: VALUE_L
    LOGICAL, POINTER :: FROM_PARAMETER_DATA_L(:)
    TYPE(DomainType), POINTER :: FROM_DOMAIN,TO_DOMAIN
    TYPE(DomainElementsType), POINTER :: FROM_DOMAIN_ELEMENTS
    TYPE(DomainNodesType), POINTER :: FROM_DOMAIN_NODES
    TYPE(DomainTopologyType), POINTER :: fromDomainTopology
    TYPE(FieldVariableType), POINTER :: FROM_FIELD_VARIABLE,TO_FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    NULLIFY(FROM_PARAMETER_DATA_INTG)
    NULLIFY(FROM_PARAMETER_DATA_SP)
    NULLIFY(FROM_PARAMETER_DATA_DP)
    NULLIFY(FROM_PARAMETER_DATA_L)

    ENTERS("Field_ParametersToFieldParametersCopy",err,error,*999)

    CALL Field_AssertIsFinished(FROM_FIELD,err,error,*999)
    CALL Field_AssertIsFinished(TO_FIELD,err,error,*999)
    NULLIFY(FROM_FIELD_VARIABLE)
    CALL Field_VariableGet(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_FIELD_VARIABLE,err,error,*999)
    NULLIFY(TO_FIELD_VARIABLE)
    CALL Field_VariableGet(TO_FIELD,TO_VARIABLE_TYPE,TO_FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertComponentNumberOK(FROM_FIELD_VARIABLE,FROM_COMPONENT_NUMBER,err,error,*999)
    CALL FieldVariable_AssertComponentNumberOK(TO_FIELD_VARIABLE,TO_COMPONENT_NUMBER,err,error,*999)
    NULLIFY(FROM_DOMAIN)
    CALL FieldVariable_ComponentDomainGet(FROM_FIELD_VARIABLE,FROM_COMPONENT_NUMBER,FROM_DOMAIN,err,error,*999)
    NULLIFY(TO_DOMAIN)
    CALL FieldVariable_ComponentDomainGet(TO_FIELD_VARIABLE,TO_COMPONENT_NUMBER,TO_DOMAIN,err,error,*999)
    IF(.NOT.ASSOCIATED(FROM_DOMAIN,TO_DOMAIN)) THEN
      CALL FlagError("The from field variable component domain is not associated with the "// &
        & "to field variable component domain.",err,error,*999)
    ENDIF
    IF(FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%interpolationType/= &
      & TO_FIELD_VARIABLE%components(TO_COMPONENT_NUMBER)%interpolationType) THEN
      localError="The from field variable component interpolation type of "// &
        & TRIM(NumberToVString(FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)% &
        & interpolationType,"*",err,error))// &
        & " does not match the to variable component interpolation type of "// &
        & TRIM(NumberToVString(TO_FIELD_VARIABLE%components(TO_COMPONENT_NUMBER)% &
        & interpolationType,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(FROM_FIELD_VARIABLE%dataType/=TO_FIELD_VARIABLE%dataType) THEN
      localError="The from field variable data type of "// &
        & TRIM(NumberToVString(FROM_FIELD_VARIABLE%dataType,"*",err,error))// &
        & " does not match the to variable data type of "// &
        & TRIM(NumberToVString(TO_FIELD_VARIABLE%dataType,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    SELECT CASE(FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      SELECT CASE(FROM_FIELD_VARIABLE%dataType)
      CASE(FIELD_INTG_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_INTG,err,error,*999)
        local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
          & constantParam2DOFMap
        VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
          & TO_COMPONENT_NUMBER,VALUE_INTG,err,error,*999)
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_INTG,err,error,*999)
      CASE(FIELD_SP_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_SP,err,error,*999)
        local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
          & constantParam2DOFMap
        VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
          & TO_COMPONENT_NUMBER,VALUE_SP,err,error,*999)
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_SP,err,error,*999)
      CASE(FIELD_DP_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_DP,err,error,*999)
        local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
          & constantParam2DOFMap
        VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
          & TO_COMPONENT_NUMBER,VALUE_DP,err,error,*999)
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_DP,err,error,*999)
      CASE(FIELD_L_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_L,err,error,*999)
        local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
          & constantParam2DOFMap
        VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
          & TO_COMPONENT_NUMBER,VALUE_L,err,error,*999)
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_L,err,error,*999)
      CASE DEFAULT
        localError="The from field variable data type of "// &
          & TRIM(NumberToVString(FROM_FIELD_VARIABLE%dataType,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      NULLIFY(fromDomainTopology)
      CALL Domain_DomainTopologyGet(FROM_DOMAIN,fromDomainTopology,err,error,*999)
      NULLIFY(FROM_DOMAIN_ELEMENTS)
      CALL DomainTopology_DomainElementsGet(fromDomainTopology,FROM_DOMAIN_ELEMENTS,err,error,*999)
      SELECT CASE(FROM_FIELD_VARIABLE%dataType)
      CASE(FIELD_INTG_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_INTG,err,error,*999)
        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%totalNumberOfElements
          local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
            & elementParam2DOFMap%ELEMENTS(elem_idx)
          VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &
            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_INTG,err,error,*999)
        ENDDO !elem_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_INTG,err,error,*999)
      CASE(FIELD_SP_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_SP,err,error,*999)
        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%totalNumberOfElements
          local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
            & elementParam2DOFMap%ELEMENTS(elem_idx)
          VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &
            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_SP,err,error,*999)
        ENDDO !elem_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_SP,err,error,*999)
      CASE(FIELD_DP_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_DP,err,error,*999)
        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%totalNumberOfElements
          local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
            & elementParam2DOFMap%ELEMENTS(elem_idx)
          VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &            
            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_DP,err,error,*999)
        ENDDO !elem_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_DP,err,error,*999)
      CASE(FIELD_L_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_L,err,error,*999)
        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%totalNumberOfElements
          local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
            & elementParam2DOFMap%ELEMENTS(elem_idx)
          VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &
            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_L,err,error,*999)
        ENDDO !elem_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_L,err,error,*999)
      CASE DEFAULT
        localError="The from field variable data type of "// &
          & TRIM(NumberToVString(FROM_FIELD_VARIABLE%dataType,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      NULLIFY(fromDomainTopology)
      CALL Domain_DomainTopologyGet(FROM_DOMAIN,fromDomainTopology,err,error,*999)
      NULLIFY(FROM_DOMAIN_NODES)
      CALL DomainTopology_DomainNodesGet(fromDomainTopology,FROM_DOMAIN_NODES,err,error,*999)
      SELECT CASE(FROM_FIELD_VARIABLE%dataType)
      CASE(FIELD_INTG_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_INTG,err,error,*999)
        DO node_idx=1,FROM_DOMAIN_NODES%totalNumberOfNodes
          DO deriv_idx=1,FROM_DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
            DO version_idx=1,FROM_DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(deriv_idx)% &
              & numberOfVersions
              local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
              VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                & VALUE_INTG,err,error,*999)
            ENDDO !version_idx
          ENDDO !deriv_idx
        ENDDO !node_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_INTG,err,error,*999)
      CASE(FIELD_SP_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_SP,err,error,*999)
        DO node_idx=1,FROM_DOMAIN_NODES%totalNumberOfNodes
          DO deriv_idx=1,FROM_DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
            DO version_idx=1,FROM_DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(deriv_idx)% &
              & numberOfVersions
              local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
              VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                & VALUE_SP,err,error,*999)
            ENDDO !version_idx
          ENDDO !deriv_idx
        ENDDO !node_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_SP,err,error,*999)
      CASE(FIELD_DP_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_DP,err,error,*999)
        DO node_idx=1,FROM_DOMAIN_NODES%totalNumberOfNodes
          DO deriv_idx=1,FROM_DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
            DO version_idx=1,FROM_DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(deriv_idx)% &
              & numberOfVersions
              local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
              VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                & VALUE_DP,err,error,*999)
            ENDDO !version_idx
          ENDDO !deriv_idx
        ENDDO !node_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_DP,err,error,*999)
      CASE(FIELD_L_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_L,err,error,*999)
        DO node_idx=1,FROM_DOMAIN_NODES%totalNumberOfNodes
          DO deriv_idx=1,FROM_DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
            DO version_idx=1,FROM_DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(deriv_idx)% &
              & numberOfVersions
              local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
                & nodeParam2DOFMap%nodes(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
              VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                & VALUE_L,err,error,*999)
            ENDDO !version_idx
          ENDDO !deriv_idx
        ENDDO !node_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_L,err,error,*999)
      CASE DEFAULT
        localError="The from field variable data type of "// &
          & TRIM(NumberToVString(FROM_FIELD_VARIABLE%dataType,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implmented.",err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      NULLIFY(fromDomainTopology)
      CALL Domain_DomainTopologyGet(FROM_DOMAIN,fromDomainTopology,err,error,*999)
      NULLIFY(FROM_DOMAIN_ELEMENTS)
      CALL DomainTopology_DomainElementsGet(fromDomainTopology,FROM_DOMAIN_ELEMENTS,err,error,*999)
      SELECT CASE(FROM_FIELD_VARIABLE%dataType)
      CASE(FIELD_INTG_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_INTG,err,error,*999)
        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%totalNumberOfElements
          DO gausspoint_idx=1,SIZE(FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)% &
            & paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
            local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gausspoint_idx,elem_idx)
            VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
            local_ny=TO_FIELD%variableTypeMap(TO_VARIABLE_TYPE)%ptr%&
              &COMPONENTS(TO_COMPONENT_NUMBER)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gausspoint_idx,elem_idx)
            CALL DistributedVector_ValuesSet(TO_FIELD%variableTypeMap(TO_VARIABLE_TYPE)%ptr%&
              & parameterSets%setType(TO_PARAMETER_SET_TYPE)%ptr%PARAMETERS,local_ny,VALUE_INTG,&
              & err,error,*999)
          ENDDO !gausspoint_idx
        ENDDO !elem_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_INTG,err,error,*999)
      CASE(FIELD_SP_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_SP,err,error,*999)
        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%totalNumberOfElements
          DO gausspoint_idx=1,SIZE(FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)% &
            & paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
            local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gausspoint_idx,elem_idx)
            VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
            local_ny=TO_FIELD%variableTypeMap(TO_VARIABLE_TYPE)%ptr%&
              &COMPONENTS(TO_COMPONENT_NUMBER)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gausspoint_idx,elem_idx)
            CALL DistributedVector_ValuesSet(TO_FIELD%variableTypeMap(TO_VARIABLE_TYPE)%ptr%&
              & parameterSets%setType(TO_PARAMETER_SET_TYPE)%ptr%PARAMETERS,local_ny,VALUE_SP,&
              & err,error,*999)
          ENDDO !gausspoint_idx
        ENDDO !elem_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_SP,err,error,*999)
      CASE(FIELD_DP_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_DP,err,error,*999)
        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%totalNumberOfElements
          DO gausspoint_idx=1,SIZE(FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)% &
            & paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
            local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gausspoint_idx,elem_idx)
            VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
            local_ny=TO_FIELD%variableTypeMap(TO_VARIABLE_TYPE)%ptr%&
              &COMPONENTS(TO_COMPONENT_NUMBER)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gausspoint_idx,elem_idx)
            CALL DistributedVector_ValuesSet(TO_FIELD%variableTypeMap(TO_VARIABLE_TYPE)%ptr%&
              & parameterSets%setType(TO_PARAMETER_SET_TYPE)%ptr%PARAMETERS,local_ny,VALUE_DP,&
              & err,error,*999)
          ENDDO !gausspoint_idx
        ENDDO !elem_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_DP,err,error,*999)
      CASE(FIELD_L_TYPE)
        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
          & FROM_PARAMETER_DATA_L,err,error,*999)
        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%totalNumberOfElements
          DO gausspoint_idx=1,SIZE(FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)% &
            & paramToDOFMap%gaussPointParam2DOFMap%gaussPoints,1)
            local_ny=FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gausspoint_idx,elem_idx)
            VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
            local_ny=TO_FIELD%variableTypeMap(TO_VARIABLE_TYPE)%ptr%&
              &COMPONENTS(TO_COMPONENT_NUMBER)%paramToDOFMap% &
              & gaussPointParam2DOFMap%gaussPoints(gausspoint_idx,elem_idx)
            CALL DistributedVector_ValuesSet(TO_FIELD%variableTypeMap(TO_VARIABLE_TYPE)%ptr%&
              & parameterSets%setType(TO_PARAMETER_SET_TYPE)%ptr%PARAMETERS,local_ny,VALUE_L,&
              & err,error,*999)
          ENDDO !gausspoint_idx
        ENDDO !elem_idx
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_L,err,error,*999)
      CASE DEFAULT
        CALL FlagError("Invalid data type or not implemented.",err,error,*999)
      END SELECT
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The from field variable component interpolation type of "// &
        & TRIM(NumberToVString(FROM_FIELD_VARIABLE%components(FROM_COMPONENT_NUMBER)% &
        & interpolationType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParametersToFieldParametersCopy")
    RETURN
999 ERRORSEXITS("Field_ParametersToFieldParametersCopy",err,error)
    RETURN 1

  END SUBROUTINE Field_ParametersToFieldParametersCopy


  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)    

    EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)    

    EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
    !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
    !not being set.
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>FIELD_VARIABLE%domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >0 and <="// &
        & TRIM(NumberToVString(FIELD_VARIABLE%domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    GLOBAL_DOF_NUMBER=domainMapping%localToGlobalMap(DOF_NUMBER)
    IF(domainMapping%globalToLocalMap(GLOBAL_DOF_NUMBER)%localType(1)==DOMAIN_LOCAL_GHOST) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid as it is a ghost dof for this domain."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
    !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
    !not being set.
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>FIELD_VARIABLE%domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >0 and <="// &
        & TRIM(NumberToVString(FIELD_VARIABLE%domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    GLOBAL_DOF_NUMBER=domainMapping%localToGlobalMap(DOF_NUMBER)
    IF(domainMapping%globalToLocalMap(GLOBAL_DOF_NUMBER)%localType(1)==DOMAIN_LOCAL_GHOST) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid as it is a ghost dof for this domain."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
    !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
    !not being set.
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>FIELD_VARIABLE%domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >0 and <="// &
        & TRIM(NumberToVString(FIELD_VARIABLE%domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    GLOBAL_DOF_NUMBER=domainMapping%localToGlobalMap(DOF_NUMBER)
    IF(domainMapping%globalToLocalMap(GLOBAL_DOF_NUMBER)%localType(1)==DOMAIN_LOCAL_GHOST) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid as it is a ghost dof for this domain."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)


    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
    !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
    !not being set.
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>FIELD_VARIABLE%domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >0 and <="// &
        & TRIM(NumberToVString(FIELD_VARIABLE%domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    GLOBAL_DOF_NUMBER=domainMapping%localToGlobalMap(DOF_NUMBER)
    IF(domainMapping%globalToLocalMap(GLOBAL_DOF_NUMBER)%localType(1)==DOMAIN_LOCAL_GHOST) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid as it is a ghost dof for this domain."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular user element of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddElement
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add element for user element "//TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular user element of the field variable component.\see OpenCMISS::Iron::cmfe_Field_ParameterSetAddElement 
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add element for user element "//TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular user element of the field variable component.\see OpenCMISS::Iron::cmfe_Field_ParameterSetAddElement 
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add element for user element "//TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular user element of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddElement
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add element for user element "//TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointIntg(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetAddGaussPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by Gauss point for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetAddGaussPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointSP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetAddGaussPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by Gauss point for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetAddGaussPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetAddGaussPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by Gauss point for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetAddGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointL(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetAddGaussPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by Gauss point for user element "//TRIM(NumberToVString(userElementNumber,"*",err,error))// &
        & " as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetAddGaussPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(FIELD_VARIABLE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(FIELD_VARIABLE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(FIELD_VARIABLE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(FIELD_VARIABLE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_NODE_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,VARIABLE_TYPE,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,FIELD_SET_TYPE,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by node for user node number "//TRIM(NumberToVString(USER_NODE_NUMBER,"*",err,error))// &
        & " as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,VALUE,err,error,*999)


    EXITS("FIELD_PARAMETER_SET_ADD_NODE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_NODE_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_NODE_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,VARIABLE_TYPE,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,FIELD_SET_TYPE,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by node for user node number "//TRIM(NumberToVString(USER_NODE_NUMBER,"*",err,error))// &
        & " as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_NODE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_NODE_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_NODE_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,VARIABLE_TYPE,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,FIELD_SET_TYPE,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by node for user node number "//TRIM(NumberToVString(USER_NODE_NUMBER,"*",err,error))// &
        & " as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_NODE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_NODE_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_ADD_NODE_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,VARIABLE_TYPE,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,FIELD_SET_TYPE,parameterSet,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(fieldVariable,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot add by node for user node number "//TRIM(NumberToVString(USER_NODE_NUMBER,"*",err,error))// &
        & " as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesAdd(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_NODE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_NODE_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,LOCAL_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)    

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,LOCAL_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)


    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,LOCAL_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,LOCAL_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)    

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable. If the field parameter set has already been
  !>created then an error will be raised. \see OpenCMISS::Iron::cmfe_FieldParameterSetCreate
  SUBROUTINE Field_ParameterSetCreate(field,variableType,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to create the parameter set for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The variable type to create the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetCreate",err,error,*999)

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetCreate(fieldVariable,fieldSetType,err,error,*999)
 
    EXITS("Field_ParameterSetCreate")
    RETURN
999 ERRORSEXITS("Field_ParameterSetCreate",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetCreate

  !
  !================================================================================================================================
  !

  !>Checks whether a field parameter set has been created
  SUBROUTINE Field_ParameterSetCreated(field,variableType,fieldSetType,parameterSetCreated,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to check the parameter set creation for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    LOGICAL, INTENT(OUT) :: parameterSetCreated !<On return, .TRUE. if the parameter set has been created, .FALSE, if not.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable
 
    ENTERS("Field_ParameterSetCreated",err,error,*999)

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetCreated(fieldVariable,fieldSetType,parameterSetCreated,err,error,*999)

    EXITS("Field_ParameterSetCreated")
    RETURN
999 ERRORSEXITS("Field_ParameterSetCreated",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetCreated

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type fieldSetType for a field variable if it does not already exist,
  !>otherwise it will do nothing.
  SUBROUTINE Field_ParameterSetEnsureCreated(field,variableType,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to create the parameter set for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The variable type to create the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetEnsureCreated",err,error,*999)

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetEnsureCreated(fieldVariable,fieldSetType,err,error,*999)

    EXITS("Field_ParameterSetEnsureCreated")
    RETURN
999 ERRORSEXITS("Field_ParameterSetEnsureCreated",err,error)
    RETURN 1
    
  END SUBROUTINE Field_ParameterSetEnsureCreated

  !
  !================================================================================================================================
  !

  !>Destroys the parameter set of type set type for a field variable and deallocates all memory. \see OpenCMISS::Iron::cmfe_FieldParameterSetDestroy
  SUBROUTINE FIELD_PARAMETER_SET_DESTROY(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to destroy a parameter set for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to destroy the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: parameter_set_idx,SET_INDEX
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldParameterSetPtrType), POINTER :: NEW_PARAMETER_SETS(:)
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    NULLIFY(NEW_PARAMETER_SETS)

    ENTERS("FIELD_PARAMETER_SET_DESTROY",err,error,*999)

    IF(.NOT.ASSOCIATED(FIELD)) CALL FlagError("Field is not associated.",err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    SET_INDEX=PARAMETER_SET%setIndex
    ALLOCATE(NEW_PARAMETER_SETS(FIELD_VARIABLE%parameterSets%numberOfParameterSets-1),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate new parameter sets",err,error,*999)
    DO parameter_set_idx=1,FIELD_VARIABLE%parameterSets%numberOfParameterSets
      IF(parameter_set_idx<SET_INDEX) THEN
        NEW_PARAMETER_SETS(parameter_set_idx)%ptr=>FIELD_VARIABLE%parameterSets%parameterSets(parameter_set_idx)%ptr
      ELSE IF(parameter_set_idx>SET_INDEX) THEN
        NEW_PARAMETER_SETS(parameter_set_idx-1)%ptr=>FIELD_VARIABLE%parameterSets%parameterSets(parameter_set_idx)%ptr
        NEW_PARAMETER_SETS(parameter_set_idx-1)%ptr%setIndex=NEW_PARAMETER_SETS(parameter_set_idx-1)%ptr%setIndex-1
      ENDIF
    ENDDO !parameter_set_idx
    DEALLOCATE(FIELD_VARIABLE%parameterSets%parameterSets)
    FIELD_VARIABLE%parameterSets%parameterSets=>NEW_PARAMETER_SETS
    FIELD_VARIABLE%parameterSets%numberOfParameterSets=FIELD_VARIABLE%parameterSets%numberOfParameterSets-1
    NULLIFY(FIELD_VARIABLE%parameterSets%setType(FIELD_SET_TYPE)%ptr)
    CALL FIELD_PARAMETER_SET_FINALISE(PARAMETER_SET,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_DESTROY")
    RETURN
999 IF(ASSOCIATED(NEW_PARAMETER_SETS)) DEALLOCATE(NEW_PARAMETER_SETS)
    ERRORSEXITS("FIELD_PARAMETER_SET_DESTROY",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_DESTROY

  !
  !================================================================================================================================
  !

  !>Finalises the parameter set for a field and deallocates all memory.
  SUBROUTINE FIELD_PARAMETER_SET_FINALISE(FIELD_PARAMETER_SET,err,error,*)

    !Argument variables
    TYPE(FieldParameterSetType), POINTER :: FIELD_PARAMETER_SET !<A pointer to the field parameter set to destroy
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_PARAMETER_SET_FINALISE",err,error,*999)

    IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
      IF(ASSOCIATED(FIELD_PARAMETER_SET%PARAMETERS)) CALL DistributedVector_Destroy(FIELD_PARAMETER_SET%PARAMETERS,err,error,*999)
      DEALLOCATE(FIELD_PARAMETER_SET)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_FINALISE

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field integer parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_DATA_GET_INTG",err,error,*998)

    IF(ASSOCIATED(PARAMETERS)) CALL FlagError("Parameters is already associated.",err,error,*998)
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,PARAMETERS,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_DATA_GET_INTG")
    RETURN
999 NULLIFY(PARAMETERS)
998 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_GET_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_INTG

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field single precision parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(SP), POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_DATA_GET_SP",err,error,*998)

    IF(ASSOCIATED(PARAMETERS)) CALL FlagError("Parameters is already associated.",err,error,*998)
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,PARAMETERS,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_DATA_GET_SP")
    RETURN
999 NULLIFY(PARAMETERS)
998 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_GET_SP",err,error)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_SP

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field double precision parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_DATA_GET_DP",err,error,*999)

    IF(ASSOCIATED(PARAMETERS)) CALL FlagError("Parameters is already associated.",err,error,*998)
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,PARAMETERS,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_DATA_GET_DP")
    RETURN
999 NULLIFY(PARAMETERS)
998 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_GET_DP",err,error)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_DP

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field logical parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    LOGICAL, POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_DATA_GET_L",err,error,*998)

    IF(ASSOCIATED(PARAMETERS)) CALL FlagError("Parameters is already associated.",err,error,*998)
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,PARAMETERS,err,error,*999) 

    EXITS("FIELD_PARAMETER_SET_DATA_GET_L")
    RETURN
999 NULLIFY(PARAMETERS)
998 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_GET_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_L

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable integer parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_INTG",err,error,*999)

    IF(.NOT.ASSOCIATED(PARAMETERS)) CALL FlagError("Parameters is not associated.",err,error,*999)
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,PARAMETERS,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_RESTORE_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_INTG

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable single precision parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(SP), POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_SP",err,error,*999)

    IF(.NOT.ASSOCIATED(PARAMETERS)) CALL FlagError("Parameters is not associated.",err,error,*999)
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,PARAMETERS,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_RESTORE_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_SP

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable double precision parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_DP",err,error,*999)

    IF(.NOT.ASSOCIATED(PARAMETERS)) CALL FlagError("Parameters is not associated.",err,error,*999)
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,PARAMETERS,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_RESTORE_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_DP

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable logical parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    LOGICAL, POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_L",err,error,*999)

    IF(.NOT.ASSOCIATED(PARAMETERS)) CALL FlagError("Parameters is not associated.",err,error,*999)
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,PARAMETERS,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_RESTORE_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_L

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified parameter set for the field variable.
  SUBROUTINE Field_ParameterSetGet(field,variableType,fieldSetType,parameterSet,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the parameter set for
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to get the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to get \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    TYPE(FieldParameterSetType), POINTER :: parameterSet !<On return, a pointer to the specified parameter set. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGet",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)

    EXITS("Field_ParameterSetGet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGet",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGet

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)    

    EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_CONSTANT_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_INTG

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_CONSTANT_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_SP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)    

    EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_CONSTANT_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_DP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)    

    EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_CONSTANT_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_L

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointIntg(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetDataPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("Field_ParameterSetGetDataPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetDataPointIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointSP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetDataPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,VALUE,err,error,*999)


    EXITS("Field_ParameterSetGetDataPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetDataPointSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointDP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetDataPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("Field_ParameterSetGetDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetDataPointDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointL(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetDataPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,value,err,error,*999)

    EXITS("Field_ParameterSetGetDataPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetDataPointL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_ELEMENT_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_INTG

  !
  !================================================================================================================================
  !


  !>Returns from the given parameter set a single precision value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)    

    EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_ELEMENT_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_ELEMENT_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_ELEMENT_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Returns the parameter set integer value for a specified local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value of the specified local dof.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >=1 and <= "// &
        & TRIM(NumberToVString(FIELD_VARIABLE%domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG

  !
  !================================================================================================================================
  !

  !>Returns the parameter set single precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value of the specified dof
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >=1 and <= "// &
        & TRIM(NumberToVString(FIELD_VARIABLE%domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP

  !
  !================================================================================================================================
  !

  !>Returns the parameter set double precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value of the specified dof
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >=1 and <= "// &
        & TRIM(NumberToVString(FIELD_VARIABLE%domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP

  !
  !================================================================================================================================
  !

  !>Returns the parameter set logical value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value of the specified dof.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_L",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>domainMapping%totalNumberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >=1 and <= "// &
        & TRIM(NumberToVString(FIELD_VARIABLE%domainMapping%totalNumberOfLocal,"*",err,error))// &
        & " for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_L

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetNode
  SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_NODE_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_NODE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_NODE_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetNode
  SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_NODE_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_NODE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_NODE_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_SP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetNode
  SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_NODE_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_NODE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_NODE_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_DP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetNode
  SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_GET_NODE_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_GET_NODE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_NODE_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_L

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalNodeIntg(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalNodeIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetLocalNodeIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNodeIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalNodeIntg
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalNodeSP(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalNodeSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetLocalNodeSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNodeSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalNodeSP
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalNodeDP(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalNodeDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetLocalNodeDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNodeDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalNodeDP
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local node, derivative and version of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalNodeL(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalNodeL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(fieldVariable,versionNumber,derivativeNumber,localNodeNumber,componentNumber, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetLocalNodeL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNodeL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalNodeL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local element of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalElementIntg(field,variableType,fieldSetType,localElementNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalElementIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetLocalElementIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElementIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalElementIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local element of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalElementSP(field,variableType,fieldSetType,localElementNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalElementSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetLocalElementSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElementSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalElementSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local element of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalElementDP(field,variableType,fieldSetType,localElementNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalElementDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,VALUE,err,error,*999)    

    EXITS("Field_ParameterSetGetLocalElementDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElementDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalElementDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local element of a field
  !>variable component.
  SUBROUTINE Field_ParameterSetGetLocalElementL(field,variableType,fieldSetType,localElementNumber, &
    & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalElementL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(fieldVariable,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetLocalElementL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElementL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalElementL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified gauss point of a user element of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetGetGaussPoint
  SUBROUTINE Field_ParameterSetGetGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetGaussPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetGetGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetGaussPointDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified gauss point of a local element of a field variable component. 
  SUBROUTINE Field_ParameterSetGetLocalGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGetLocalGaussPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,localElementNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesGet(parameterSet%parameters,localDof,VALUE,err,error,*999)     

    EXITS("Field_ParameterSetGetLocalGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalGaussPointDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular data point of the field variable component.  \see cmfe_Field_ParameterSetUpdateElementDataPoint
  SUBROUTINE Field_ParameterSetUpdateElementDataPointDP(field,variableType,fieldSetType,userElementNumber,dataPointIndex, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number the data point is projected on
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point projected on the element
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateElementDataPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserElementDataDOFGet(fieldVariable,userElementNumber,dataPointIndex,componentNumber, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user element "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateElementDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateElementDataPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateElementDataPointDP

  !
  !================================================================================================================================
  !

  !>Initialises the parameter set for a field.
  SUBROUTINE FIELD_PARAMETER_SET_INITIALISE(FIELD_PARAMETER_SET,err,error,*)

    !Argument variables
    TYPE(FieldParameterSetType), POINTER :: FIELD_PARAMETER_SET !<The field parameter set to initialise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_PARAMETER_SET_INITIALISE",err,error,*999)

    IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
      FIELD_PARAMETER_SET%setIndex=0
      FIELD_PARAMETER_SET%setType=0
    ELSE
      CALL FlagError("Field parameter set is not associated",err,error,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_INITIALISE")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_INITIALISE

  !
  !================================================================================================================================
  !

  !>Outputs the parameter set for a field variable.
  SUBROUTINE FIELD_PARAMETER_SET_OUTPUT(ID,FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,err,error,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ID !<The ID of the output stream
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to output the parameter set for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to output the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to output
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("FIELD_PARAMETER_SET_OUTPUT",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,VARIABLE_TYPE,fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,FIELD_SET_TYPE,parameterSet,err,error,*999)

    CALL DistributedVector_Output(ID,parameterSet%parameters,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_OUTPUT")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_OUTPUT",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_OUTPUT

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    INTEGER, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)  

    EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_ConstantDOFGet(FIELD_VARIABLE,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_L

  !
  !================================================================================================================================
  !

  !>Update the given parameter set an integer value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointIntg(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateDataPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user data point number "// &
        & TRIM(NumberToVString(userDataPointNumber,"*",err,error))//" as it is a ghost data point."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateDataPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateDataPointIntg

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointSP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, & 
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateDataPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user data point number "// &
        & TRIM(NumberToVString(userDataPointNumber,"*",err,error))//" as it is a ghost data point."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateDataPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateDataPointSP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointDP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateDataPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user data point number "// &
        & TRIM(NumberToVString(userDataPointNumber,"*",err,error))//" as it is a ghost data point."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateDataPointDP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointL(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateDataPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserDataPointDOFGet(fieldVariable,userDataPointNumber,componentNumber,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by data point for user data point number "// &
        & TRIM(NumberToVString(userDataPointNumber,"*",err,error))//" as it is a ghost data point."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateDataPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateDataPointL

  !
  !================================================================================================================================
  !

  !>Update the given parameter set an integer value for the specified local data point of a field variable component. 
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointIntg(field,variableType,fieldSetType,dataPointNumber,componentNumber,value, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalDataPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalDataPointDOFGet(fieldVariable,dataPointNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDataPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointIntg

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified local data point of a field variable component. 
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointSP(field,variableType,fieldSetType,dataPointNumber,componentNumber,VALUE, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalDataPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalDataPointDOFGet(fieldVariable,dataPointNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDataPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointSP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified local data point of a field variable component. 
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointDP(field,variableType,fieldSetType,dataPointNumber,componentNumber,VALUE, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalDataPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalDataPointDOFGet(fieldVariable,dataPointNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointDP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified local data point of a field variable component. 
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointL(field,variableType,fieldSetType,dataPointNumber,componentNumber,VALUE, &
    & err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalDataPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalDataPointDOFGet(fieldVariable,dataPointNumber,componentNumber,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalDataPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
!!TODO: Allow to specify a global number and then have it all update accordingly???
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>domainMapping%numberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%numberOfLocal,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
!!TODO: Allow to specify a global number and then have it all update accordingly???
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>domainMapping%numberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%numberOfLocal,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
!!TODO: Allow to specify a global number and then have it all update accordingly???
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>domainMapping%numberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%numberOfLocal,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L",err,error,*999)

!!TODO: Allow multiple dof number and values updates.
    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
!!TODO: Allow to specify a global number and then have it all update accordingly???
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)
    IF(DOF_NUMBER<1.OR.DOF_NUMBER>domainMapping%numberOfLocal) THEN
      localError="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",err,error))// &
        & " is invalid. It must be >= 1 and <= "// &
        & TRIM(NumberToVString(domainMapping%numberOfLocal,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision values for all local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VALUES,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    REAL(DP), INTENT(IN) :: VALUES(:) !<The values to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DomainMappingType), POINTER :: domainMapping
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    NULLIFY(domainMapping)
    CALL FieldVariable_DomainMappingGet(FIELD_VARIABLE,domainMapping,err,error,*999)    
    !\todo: Allow to specify a global number and then have it all update accordingly???
    IF(SIZE(values,1)/=domainMapping%numberOfLocal) THEN
      localError="The size of the specified values vector of "//TRIM(NumberToVString(SIZE(VALUES,1),"*",err,error))// &
        & " does not match the number of dofs for this field of "// &
        & TRIM(NumberToVString(domainMapping%numberOfLocal,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    !\todo: set the vector values directly without looping
    DO dofIdx=1,domainMapping%numberOfLocal
      CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dofIdx,VALUES(dofIdx),err,error,*999)
    ENDDO !dofIdx

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular user element of the field variable component. \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by element for user element number "// &
        & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular user element of the field variable component.  \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by element for user element number "// &
        & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular user element of the field variable component.  \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by element for user element number "// &
        & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular user element of the field variable component. \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserElementDOFGet(FIELD_VARIABLE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by element for user element number "// &
        & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local element of the field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalElementIntg(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER, &
    & COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("Field_ParameterSetUpdateLocalElementIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(FIELD_VARIABLE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateLocalElementIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalElementIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalElementIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(FIELD_VARIABLE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(FIELD_VARIABLE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalElementDOFGet(FIELD_VARIABLE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER,localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateFinish
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_FINISH(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to finish the update for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_FINISH",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL DistributedVector_UpdateFinish(PARAMETER_SET%PARAMETERS,err,error,*999)
    IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE.AND.FIELD_SET_TYPE==FIELD_VALUES_SET_TYPE) THEN
      !Geometric field values have changed so update the geometric parameters (e.g., lines etc.)
      CALL FIELD_GEOMETRIC_PARAMETERS_CALCULATE(FIELD,err,error,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_FINISH")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_FINISH",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_FINISH

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by node for user node number "// &
        & TRIM(NumberToVString(USER_NODE_NUMBER,"*",err,error))//" as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_NODE_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by node for user node number "// &
        & TRIM(NumberToVString(USER_NODE_NUMBER,"*",err,error))//" as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)


    EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_NODE_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by node for user node number "// &
        & TRIM(NumberToVString(USER_NODE_NUMBER,"*",err,error))//" as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_NODE_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_UserNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,ghostDof,err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by node for user node number "// &
        & TRIM(NumberToVString(USER_NODE_NUMBER,"*",err,error))//" as it is a ghost node."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_NODE_L",err,error)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_L

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,LOCAL_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsSPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,LOCAL_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsDPData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,LOCAL_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    CALL FieldVariable_AssertIsLData(FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    CALL FieldVariable_LocalNodeDOFGet(FIELD_VARIABLE,VERSION_NUMBER,DERIVATIVE_NUMBER,LOCAL_NODE_NUMBER,COMPONENT_NUMBER, &
      & localDof,err,error,*999)
    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,VALUE,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given integer value for a particular gauss point of the field variable component.  \see cmfe_Field_ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointIntg(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateGaussPointIntg",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsINTGData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by Gauss point for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateGaussPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointIntg

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given single precision value for a particular gauss point of the field variable component.  \see cmfe_Field_ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointSP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateGaussPointSP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsSPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by Gauss point for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateGaussPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointSP

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given double precision value for a particular gauss point of the field variable component.  \see cmfe_Field_ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateGaussPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by Gauss point for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointDP

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given logical value for a particular gauss point of the field variable component.  \see cmfe_Field__ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointL(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    LOGICAL :: ghostDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateGaussPointL",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsLData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_UserGaussDOFGet(fieldVariable,gaussPointNumber,userElementNumber,componentNumber,localDof,ghostDof, &
      & err,error,*999)
    IF(ghostDof) THEN
      localError="Cannot update by Gauss point for user element number "// &
        & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)

    EXITS("Field_ParameterSetUpdateGaussPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular gauss point of the field variable component using the local element index. 
  SUBROUTINE Field_ParameterSetUpdateLocalGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof
    TYPE(FieldParameterSetType), POINTER :: parameterSet
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetUpdateLocalGaussPointDP",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_LocalGaussDOFGet(fieldVariable,gaussPointNumber,localElementNumber,componentNumber,localDof, &
      & err,error,*999)
    CALL DistributedVector_ValuesSet(parameterSet%parameters,localDof,VALUE,err,error,*999)    

    EXITS("Field_ParameterSetUpdateLocalGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalGaussPointDP

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetInterpolateXi
  SUBROUTINE Field_ParameterSetInterpolateXiDP0(field,variableType,fieldSetType,partialDerivativeType,userElementNumber,xi, &
    & values,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The derivative number of the field to interpolate.  \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The set of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    REAL(DP) :: tempXi(SIZE(xi,1),1),tempValues(SIZE(values,1),1)

    ENTERS("Field_ParameterSetInterpolateXiDP0",err,error,*999)

    tempXi(1:SIZE(xi,1),1)=xi(1:SIZE(xi,1))
    CALL Field_ParameterSetInterpolateXiDP1(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & tempXi,tempValues,err,error,*999)
    values(1:SIZE(values,1))=tempValues(1:SIZE(values,1),1)

    EXITS("Field_ParameterSetInterpolateXiDP0")
    RETURN
999 ERRORSEXITS("Field_ParameterSetInterpolateXiDP0",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateXiDP0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetInterpolateXI
  SUBROUTINE Field_ParameterSetInterpolateXiDP1(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
    & xi,values,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative number of the field to interpolate. \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    REAL(DP), INTENT(IN) :: xi(:,:) !<xi(xiIdx,xiPointIdx). The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,xiPointIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    INTEGER(INTG) :: localElementNumber,numberOfComponents,xiPointsIdx
    LOGICAL :: ghostElement
    TYPE(FieldInterpolationParametersPtrType), POINTER :: interpolationParameters(:)
    TYPE(FieldInterpolatedPointPtrType), POINTER :: interpolatedPoint(:)
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetInterpolateXiDP1",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_NumberOfComponentsGet(fieldVariable,numberOfComponents,err,error,*999)
    IF(SIZE(values,1)<numberOfComponents) THEN
      localError="The number of the coordinate values to return the interpolated field to is invalid. "// &
        & "The supplied size is "//TRIM(NumberToVString(SIZE(values,1),"*",err,error))//" and should be >= "// &
        & TRIM(NumberToVString(numberOfComponents,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(values,2)/=SIZE(xi,2)) THEN
      localError="The specified number of xi points of "//TRIM(NumberToVString(SIZE(xi,2),"*",err,error))// &
        & " does not match the size of the supplied values array of "// &
        & TRIM(NumberToVString(SIZE(values,2),"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(decompositionElements)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_LocalElementNumberGet(decompositionElements,userElementNumber,localElementNumber,ghostElement, &
      & err,error,*999)
    NULLIFY(interpolationParameters)
    CALL Field_InterpolationParametersInitialise(field,interpolationParameters,err,error,*999)
    NULLIFY(interpolatedPoint)
    CALL Field_InterpolatedPointsInitialise(interpolationParameters,interpolatedPoint,err,error,*999)
    CALL Field_InterpolationParametersElementGet(fieldSetType,localElementNumber,interpolationParameters(variableType)%ptr, &
      & err,error,*999)
    DO xiPointsIdx=1,SIZE(xi,2)
      CALL Field_InterpolateXi(partialDerivativeType,xi(:,xiPointsIdx),interpolatedPoint(variableType)%ptr,err,error,*999)
      values(1:numberOfComponents,xiPointsIdx)=interpolatedPoint(variableType)%ptr% &
        & values(1:numberOfComponents,partialDerivativeType)
    ENDDO !xiPointsIdx
    !Finalise the interpolated point and parameters
    CALL Field_InterpolatedPointsFinalise(interpolatedPoint,err,error,*999)
    CALL Field_InterpolationParametersFinalise(interpolationParameters,err,error,*999)

    EXITS("Field_ParameterSetInterpolateXiDP1")
    RETURN
999 ERRORSEXITS("Field_ParameterSetInterpolateXiDP1",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateXiDP1

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values. \see OpenCMISS::Iron::cmfe_Field_ParameterSetInterpolateGauss
  SUBROUTINE Field_ParameterSetInterpolateGaussDP0(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
    & quadratureScheme,gaussPoint,values,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for. \see Basis_QuadratureSchemes,BasisRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPoint !<The Gauss point to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    REAL(DP) :: tempValues(SIZE(values,1),1)

    ENTERS("Field_ParameterSetInterpolateGaussDP0",err,error,*999)

    CALL Field_ParameterSetInterpolateGaussDP1(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadratureScheme,[gaussPoint],tempValues,err,error,*999)
    values(1:SIZE(values,1))=tempValues(1:SIZE(values,1),1)

    EXITS("Field_ParameterSetInterpolateGaussDP0")
    RETURN
999 ERRORSEXITS("Field_ParameterSetInterpolateGaussDP0",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateGaussDP0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values. If no Gauss points are specified then all Gauss points are interpolated. \see OpenCMISS::Iron::cmfe_Field_ParameterSetInterpolateGauss
  SUBROUTINE Field_ParameterSetInterpolateGaussDP1(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
    & quadratureSchemeType,gaussPoints,values,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier. \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The derivative number of the field to interpolate.  \see Constants_PartialDerivativeConstants,Constants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureSchemeType !<The quadrature scheme to interpolate the field for.  \see Basis_QuadratureSchemes,BasisRoutines
    INTEGER(INTG), INTENT(IN) :: gaussPoints(:) !<gaussPoints(gaussPointIdx). The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,gaussPointIdx). On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.
    !Local Variables
    INTEGER(INTG) :: gaussPointIdx,localElementNumber,numberOfComponents
    LOGICAL :: ghostElement
    TYPE(BasisType), POINTER :: basis
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(FieldInterpolationParametersPtrType), POINTER :: interpolationParameters(:)
    TYPE(FieldInterpolatedPointPtrType), POINTER :: interpolatedPoint(:)
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: quadratureScheme
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetInterpolateGaussDP1",err,error,*999)

    CALL Field_AssertIsFinished(field,err,error,*999)
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_NumberOfComponentsGet(fieldVariable,numberOfComponents,err,error,*999)
    IF(SIZE(values,1)<numberOfComponents) THEN
      localError="The number of the coordinate values to return the interpolated field to is invalid. "// &
        & "The supplied size is "//TRIM(NumberToVString(SIZE(values,1),"*",err,error))//" and should be >= "// &
        & TRIM(NumberToVString(numberOfComponents,"*",err,error))// &
        & " for field variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    CALL FieldVariable_AssertIsDPData(fieldVariable,err,error,*999)
    NULLIFY(decomposition)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    NULLIFY(decompositionTopology)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    NULLIFY(decompositionElements)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_LocalElementNumberGet(decompositionElements,userElementNumber,localElementNumber,ghostElement, &
      & err,error,*999)
    NULLIFY(domain)
    CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
    NULLIFY(domainTopology)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    NULLIFY(domainElements)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    !Get the basis for the decomposition domain. We will have to assume that the quadrature scheme will be the
    !same for all component bases.
    NULLIFY(basis)
    CALL DomainElements_BasisGet(domainElements,localElementNumber,basis,err,error,*999)
    NULLIFY(quadratureScheme)
    CALL Basis_QuadratureSchemeGet(basis,quadratureSchemeType,quadratureScheme,err,error,*999)
    NULLIFY(interpolationParameters)
    CALL Field_InterpolationParametersInitialise(field,interpolationParameters,err,error,*999)
    NULLIFY(interpolatedPoint)
    CALL Field_InterpolatedPointsInitialise(interpolationParameters,interpolatedPoint,err,error,*999)
    CALL Field_InterpolationParametersElementGet(fieldSetType,localElementNumber,interpolationParameters(variableType)%ptr, &
      & err,error,*999)
    IF(SIZE(gaussPoints,1)==0) THEN !Interpolate all Gauss points
      IF(SIZE(values,2)<quadratureScheme%NUMBER_OF_GAUSS) THEN
        localError="The size of the second dimension of the specified values array of "// &
          & TRIM(NumberToVString(SIZE(values,2),"*",err,error))// &
          & " does not match the number of Gauss points of "// &
          & TRIM(NumberToVString(quadratureScheme%NUMBER_OF_GAUSS,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      DO gaussPointIdx=1,quadratureScheme%NUMBER_OF_GAUSS
        CALL Field_InterpolateGauss(partialDerivativeType,quadratureSchemeType,gaussPointIdx, &
          & interpolatedPoint(variableType)%ptr,err,error,*999)
        values(1:numberOfComponents,gaussPointIdx)=interpolatedPoint(variableType)%ptr% &
          & values(1:numberOfComponents,partialDerivativeType)
      ENDDO !gaussPointIdx
    ELSE
      IF(SIZE(values,2)/=SIZE(gaussPoints,1)) THEN
        localError="The specified number of Gauss points of "//TRIM(NumberToVString(SIZE(gaussPoints,1),"*",err,error))// &
          & " does not match the size of the supplied values array of "// &
          & TRIM(NumberToVString(SIZE(values,2),"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      DO gaussPointIdx=1,SIZE(gaussPoints,1)
        IF(gaussPoints(gaussPointIdx)<1.OR.gaussPoints(gaussPointIdx)>quadratureScheme%NUMBER_OF_GAUSS) THEN
          localError="The specified Gauss point number of "// & 
            & TRIM(NumberToVString(gaussPoints(gaussPointIdx),"*",err,error))// &
            & " at Gauss point index "//TRIM(NumberToVString(gaussPointIdx,"*",err,error))// &
            & " is invalid. The Gauss point number should be >= 1 and <= "// &
            & TRIM(NumberToVString(quadratureScheme%NUMBER_OF_GAUSS,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
        CALL Field_InterpolateGauss(partialDerivativeType,quadratureSchemeType,gaussPoints(gaussPointIdx), &
          & interpolatedPoint(variableType)%ptr,err,error,*999)
        values(1:numberOfComponents,gaussPointIdx)=interpolatedPoint(variableType)%ptr% &
          & values(1:numberOfComponents,partialDerivativeType)
      ENDDO !gaussPointIdx
    ENDIF
    !Finalise the interpolated point and parameters
    CALL Field_InterpolatedPointsFinalise(interpolatedPoint,err,error,*999)
    CALL Field_InterpolationParametersFinalise(interpolationParameters,err,error,*999)

    EXITS("Field_ParameterSetInterpolateGaussDP1")
    RETURN
999 ERRORS("Field_ParameterSetInterpolateGaussDP1",err,error)
    EXITS("Field_ParameterSetInterpolateGaussDP1")
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateGaussDP1

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateStart
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_START(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to start the update for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_UPDATE_START",err,error,*999)

    IF(.NOT.ASSOCIATED(FIELD)) CALL FlagError("Field is not associated.",err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)

    CALL DistributedVector_UpdateStart(PARAMETER_SET%PARAMETERS,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_UPDATE_START")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_START",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_START

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set distributed vector. 
  SUBROUTINE FIELD_PARAMETER_SET_VECTOR_GET(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DISTRIBUTED_VECTOR,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the parameter set vector from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    TYPE(DistributedVectorType), POINTER :: DISTRIBUTED_VECTOR !<On return, a pointer to the field parameter set distributed vector. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: PARAMETER_SET
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE

    ENTERS("FIELD_PARAMETER_SET_VECTOR_GET",err,error,*999)

    CALL Field_AssertIsFinished(FIELD,err,error,*999)
    NULLIFY(FIELD_VARIABLE)
    CALL Field_VariableGet(field,VARIABLE_TYPE,FIELD_VARIABLE,err,error,*999)
    NULLIFY(PARAMETER_SET)
    CALL FieldVariable_ParameterSetGet(FIELD_VARIABLE,FIELD_SET_TYPE,PARAMETER_SET,err,error,*999)
    NULLIFY(DISTRIBUTED_VECTOR)
    CALL FieldParameterSet_ParametersGet(PARAMETER_SET,DISTRIBUTED_VECTOR,err,error,*999)

    EXITS("FIELD_PARAMETER_SET_VECTOR_GET")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_VECTOR_GET",err,error)
    RETURN 1

  END SUBROUTINE FIELD_PARAMETER_SET_VECTOR_GET

  !
  !================================================================================================================================
  !

  !>Finalises the parameter sets for a field and deallocates all memory.
  SUBROUTINE FIELD_PARAMETER_SETS_FINALISE(FIELD_VARIABLE,err,error,*)

    !Argument variables
    TYPE(FieldVariableType) :: FIELD_VARIABLE !<A pointer to the field variable to finalise the parameter sets for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: parameter_set_idx

    ENTERS("FIELD_PARAMETER_SETS_FINALISE",err,error,*999)

    IF(ASSOCIATED(FIELD_VARIABLE%parameterSets%setType)) DEALLOCATE(FIELD_VARIABLE%parameterSets%setType)
    IF(ASSOCIATED(FIELD_VARIABLE%parameterSets%parameterSets)) THEN
      DO parameter_set_idx=1,SIZE(FIELD_VARIABLE%parameterSets%parameterSets,1)
        CALL FIELD_PARAMETER_SET_FINALISE(FIELD_VARIABLE%parameterSets%parameterSets(parameter_set_idx)%ptr,err,error,*999)
      ENDDO !parameter_set_idx
      DEALLOCATE(FIELD_VARIABLE%parameterSets%parameterSets)
    ENDIF
    FIELD_VARIABLE%parameterSets%numberOfParameterSets=0

    EXITS("FIELD_PARAMETER_SETS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SETS_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SETS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the parameter sets for a field.
  SUBROUTINE FIELD_PARAMETER_SETS_INITIALISE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the variable parameter sets for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,parameter_set_idx,variable_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("FIELD_PARAMETER_SETS_INITIALISE",err,error,*998)

    IF(ASSOCIATED(FIELD)) THEN
      DO variable_idx=1,FIELD%numberOfVariables        
        FIELD%variables(variable_idx)%parameterSets%fieldVariable=>FIELD%variables(variable_idx)
        FIELD%variables(variable_idx)%parameterSets%numberOfParameterSets=0
        NULLIFY(FIELD%variables(variable_idx)%parameterSets%parameterSets)
        ALLOCATE(FIELD%variables(variable_idx)%parameterSets%setType(FIELD_NUMBER_OF_SET_TYPES),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate field parameter sets set types.",err,error,*999)
        DO parameter_set_idx=1,FIELD_NUMBER_OF_SET_TYPES
          NULLIFY(FIELD%variables(variable_idx)%parameterSets%setType(parameter_set_idx)%ptr)
        ENDDO !parameter_set_idx
        !Create a field values parameter set
        CALL FIELD_PARAMETER_SET_CREATE(FIELD,FIELD%variables(variable_idx)%variableType,FIELD_VALUES_SET_TYPE,err,error,*999)
      ENDDO !variable_idx
    ELSE
      CALL FlagError("Field is not associated.",err,error,*998)
    ENDIF

    EXITS("FIELD_PARAMETER_SETS_INITIALISE")
    RETURN
999 DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
      IF(ASSOCIATED(FIELD%variableTypeMap(variable_idx)%ptr)) &
        & CALL FIELD_PARAMETER_SETS_FINALISE(FIELD%variableTypeMap(variable_idx)%ptr,DUMMY_ERR,DUMMY_ERROR,*998)
    ENDDO !variable_idx
998 ERRORSEXITS("FIELD_PARAMETER_SETS_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SETS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the scaling for a field scaling index and deallocates all memory.
  SUBROUTINE FIELD_SCALING_FINALISE(field,scalingIndex,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to finalise the scalings for
    INTEGER(INTG), INTENT(IN) :: scalingIndex !<The scaling index to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
 
    ENTERS("FIELD_SCALING_FINALISE",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(scalingIndex<1.OR.scalingIndex>field%scalings%numberOfScalingIndices) THEN
      localError="The specified scaling index of "//TRIM(NumberToVString(scalingIndex,"*",err,error))// &
        & " is invalid for field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))// &
        & ". The scaling index should be >= 1 and <= "// &
        & TRIM(NumberToVString(field%scalings%numberOfScalingIndices,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)      
    ENDIF
    IF(.NOT.ALLOCATED(field%scalings%scalings)) THEN
      localError="The field scalings is not allocated for field number "// &
        & TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(ASSOCIATED(field%scalings%scalings(scalingIndex)%scaleFactors)) &
      & CALL DistributedVector_Destroy(field%scalings%scalings(scalingIndex)%scaleFactors,err,error,*999)

    EXITS("FIELD_SCALING_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_FINALISE",err,error)
    RETURN 1

  END SUBROUTINE FIELD_SCALING_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the scalings for a field scaling index corresponding to a mesh component index.
  SUBROUTINE FIELD_SCALING_INITIALISE(FIELD,scalingIndex,meshComponentNumber,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the scaling for
    INTEGER(INTG), INTENT(IN) :: scalingIndex !<The scaling index to initialise
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to initialise for the scaling
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_SCALING_INITIALISE",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(scalingIndex>0.AND.scalingIndex<=FIELD%SCALINGS%numberOfScalingIndices) THEN
        IF(meshComponentNumber>0.AND.meshComponentNumber<=FIELD%DECOMPOSITION%MESH%numberOfComponents) THEN
          FIELD%SCALINGS%SCALINGS(scalingIndex)%meshComponentNumber=meshComponentNumber
          FIELD%SCALINGS%SCALINGS(scalingIndex)%maxNumberOfElementParameters=FIELD%DECOMPOSITION% &
            & DOMAIN(meshComponentNumber)%ptr%TOPOLOGY%ELEMENTS%maximumNumberOfElementParameters
          FIELD%SCALINGS%SCALINGS(scalingIndex)%maximumNumberOfDerivatives=FIELD%DECOMPOSITION% &
            & DOMAIN(meshComponentNumber)%ptr%TOPOLOGY%NODES%maximumNumberOfDerivatives
          NULLIFY(FIELD%SCALINGS%SCALINGS(scalingIndex)%scaleFactors)
          SELECT CASE(FIELD%SCALINGS%scalingType)
          CASE(FIELD_NO_SCALING)
            !Do nothing
          CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
            !ALLOCATE(FIELD%SCALINGS%SCALINGS(scalingIndex)%scaleFactors(FIELD%SCALINGS%SCALINGS(scalingIndex)% &
            !  & maximumNumberOfDerivatives,FIELD%DECOMPOSITION%DOMAIN(meshComponentNumber)%ptr%TOPOLOGY% &
            !  & NODES%totalNumberOfNodes),STAT=err)
            !IF(err/=0) CALL FlagError("Could not allocate scale factors",err,error,*999)
            !FIELD%SCALINGS%SCALINGS(scalingIndex)%scaleFactors=1.0_DP
            CALL DistributedVector_CreateStart(FIELD%DECOMPOSITION%DOMAIN(meshComponentNumber)%ptr%MAPPINGS%DOFS, &
              & FIELD%SCALINGS%SCALINGS(scalingIndex)%scaleFactors,err,error,*999)
            CALL DistributedVector_DataTypeSet(FIELD%SCALINGS%SCALINGS(scalingIndex)%scaleFactors, &
              & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
            CALL DistributedVector_CreateFinish(FIELD%SCALINGS%SCALINGS(scalingIndex)%scaleFactors,err,error,*999)
            IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
              !Initialise the scalings to 1.0 for a geometric field. Other field types will be setup in FIELD_SCALINGS_CALCULATE
              CALL DistributedVector_AllValuesSet(FIELD%SCALINGS%SCALINGS(scalingIndex)%scaleFactors,1.0_DP,err,error,*999)
            ENDIF
          CASE(FIELD_ARC_LENGTH_SCALING)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The scaling type of "//TRIM(NumberToVString(FIELD%SCALINGS%scalingType,"*",err,error))// &
              & " is invalid for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          localError="The mesh component number of "//TRIM(NumberToVString(scalingIndex,"*",err,error))// &
            & " is invalid for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
            & " which is associated with a mesh which has "//TRIM(NumberToVString(FIELD%DECOMPOSITION% &
            & MESH%numberOfComponents,"*",err,error))//" mesh components."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="The scaling index of "//TRIM(NumberToVString(scalingIndex,"*",err,error))// &
          & " is invalid for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " which has "//TRIM(NumberToVString(FIELD%SCALINGS%numberOfScalingIndices,"*",err,error))// &
          & " scaling indices."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_SCALING_INITIALISE")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_SCALING_INITIALISE

  !
  !================================================================================================================================
  !

  !>Calculates the scale factors from the geometric field associated with the field.
  SUBROUTINE FIELD_SCALINGS_CALCULATE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to calculate the scalings for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: meshComponentNumber,xi_direction,ni1,ni2,version_idx,derivative_idx,nk2,local_node_line_idx, &
      & adjacent_local_node_line_idx,node_line_idx,node_idx,partial_derivative_idx,nu1,nu2,dof_idx,ny1,ny2,ny3,scaling_idx
    REAL(DP) :: LENGTH1,LENGTH2,MEAN_LENGTH,TEMP,NUMBER_OF_LINE_VERSIONS1,NUMBER_OF_LINE_VERSIONS2,VALUE
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    LOGICAL :: FOUND
    TYPE(DecompositionLinesType), POINTER :: DECOMPOSITION_LINES
    TYPE(DomainType), POINTER :: DOMAIN
    TYPE(DomainLinesType), POINTER :: DOMAIN_LINES
    TYPE(DomainNodesType), POINTER :: DOMAIN_NODES
    TYPE(FieldType), POINTER :: GEOMETRIC_FIELD
    TYPE(FieldScalingType), POINTER :: FIELD_SCALING
    TYPE(FieldScalingsType), POINTER :: FIELD_SCALINGS
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_SCALINGS_CALCULATE",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      FIELD_SCALINGS=>FIELD%SCALINGS
      IF(ASSOCIATED(FIELD_SCALINGS)) THEN
        GEOMETRIC_FIELD=>FIELD%geometricField
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          SELECT CASE(FIELD_SCALINGS%scalingType)
          CASE(FIELD_NO_SCALING)
            !Do nothing
            NULLIFY(DOMAIN)
          CASE(FIELD_UNIT_SCALING)
            DO scaling_idx=1,FIELD_SCALINGS%numberOfScalingIndices
              FIELD_SCALING=>FIELD_SCALINGS%SCALINGS(scaling_idx)
              meshComponentNumber=FIELD_SCALING%meshComponentNumber
              DOMAIN=>FIELD%DECOMPOSITION%DOMAIN(meshComponentNumber)%ptr
              CALL DistributedVector_AllValuesSet(FIELD_SCALING%scaleFactors,1.0_DP,err,error,*999)
              CALL DistributedVector_UpdateStart(FIELD_SCALING%scaleFactors,err,error,*999)
              CALL DistributedVector_UpdateFinish(FIELD_SCALING%scaleFactors,err,error,*999)
            ENDDO !scaling_idx
          CASE(FIELD_ARC_LENGTH_SCALING)
            CALL FlagError("Not implemented.",err,error,*999)

          CASE(FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
            DO scaling_idx=1,FIELD_SCALINGS%numberOfScalingIndices
              FIELD_SCALING=>FIELD_SCALINGS%SCALINGS(scaling_idx)
              meshComponentNumber=FIELD_SCALING%meshComponentNumber
              DOMAIN=>FIELD%DECOMPOSITION%DOMAIN(meshComponentNumber)%ptr
              DOMAIN_NODES=>DOMAIN%TOPOLOGY%NODES
              IF(FIELD%DECOMPOSITION%calculateLines) THEN
                DOMAIN_LINES=>DOMAIN%TOPOLOGY%LINES
                DECOMPOSITION_LINES=>FIELD%DECOMPOSITION%TOPOLOGY%LINES
              ENDIF
              NULLIFY(SCALE_FACTORS)
              CALL DistributedVector_DataGet(FIELD_SCALING%scaleFactors,SCALE_FACTORS,err,error,*999)
              DO node_idx=1,DOMAIN_NODES%numberOfNodes
                DO derivative_idx=1,DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
                  partial_derivative_idx=DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%partialDerivativeIndex
                  SELECT CASE(partial_derivative_idx)
                  CASE(NO_PART_DERIV)
                    DO version_idx=1,DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                      dof_idx=DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%dofIndex(version_idx)
                      CALL DistributedVector_ValuesSet(FIELD_SCALING%scaleFactors,dof_idx,1.0_DP,err,error,*999)
                    ENDDO
                  CASE(PART_DERIV_S1,PART_DERIV_S2,PART_DERIV_S3)
                    IF(FIELD%DECOMPOSITION%calculateLines) THEN
                      IF(partial_derivative_idx==PART_DERIV_S1) THEN
                        xi_direction=1
                      ELSE IF(partial_derivative_idx==PART_DERIV_S2) THEN
                        xi_direction=2
                      ELSE
                        xi_direction=3
                      ENDIF
                      LENGTH1 = 0.0_DP
                      LENGTH2 = 0.0_DP
                      NUMBER_OF_LINE_VERSIONS1 = 0.0_DP
                      NUMBER_OF_LINE_VERSIONS2 = 0.0_DP
                      DO version_idx=1,DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                        !Find a line of the correct Xi direction going through this node
                        FOUND=.FALSE.
                        DO node_line_idx=1,DOMAIN_NODES%nodes(node_idx)%numberOfNodeLines
                          local_node_line_idx=DOMAIN_NODES%nodes(node_idx)%nodeLines(node_line_idx)
                          IF(DECOMPOSITION_LINES%LINES(local_node_line_idx)%xiDirection==xi_direction) THEN
                            FOUND=.TRUE.
                            EXIT
                          ENDIF
                        ENDDO !node_line_idx
                        IF(FOUND) THEN
                          IF(DOMAIN_LINES%LINES(local_node_line_idx)%nodesInLine(1)==node_idx) THEN !Current node at the beginning of the line
                            adjacent_local_node_line_idx=DECOMPOSITION_LINES%LINES(local_node_line_idx)%adjacentLines(0)
                          ELSE !Current node at the end of the line
                            adjacent_local_node_line_idx=DECOMPOSITION_LINES%LINES(local_node_line_idx)%adjacentLines(1)
                          ENDIF
                          !Average line lengths for the different versions (division by the number of lines is done after all the line lengths are added together)
                          LENGTH1=LENGTH1+GEOMETRIC_FIELD%geometricFieldParameters%lengths(local_node_line_idx)
                          NUMBER_OF_LINE_VERSIONS1=NUMBER_OF_LINE_VERSIONS1+1
                          IF(adjacent_local_node_line_idx/=0) THEN !Adjacent node and therefore lines exist
                            LENGTH2=LENGTH2+GEOMETRIC_FIELD%geometricFieldParameters%lengths(adjacent_local_node_line_idx)
                            NUMBER_OF_LINE_VERSIONS2=NUMBER_OF_LINE_VERSIONS2+1
                          ENDIF
                        ELSE
                          localError="Could not find a line in the Xi "//TRIM(NumberToVString(xi_direction,"*",err,error))// &
                            & " direction going through node number "//TRIM(NumberToVString(node_idx,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ENDDO !version_idx
                      !Division by the numer of version for this node derivative, completing the calculation for the average line lengths
                      LENGTH1 = LENGTH1/NUMBER_OF_LINE_VERSIONS1
                      IF(adjacent_local_node_line_idx==0) THEN !No adjacent node ie end of mesh 
                        MEAN_LENGTH=LENGTH1
                      ELSE !Adjacent node and therefore lines exist
                        LENGTH2 = LENGTH2/NUMBER_OF_LINE_VERSIONS2
                        SELECT CASE(FIELD_SCALINGS%scalingType)
                        CASE(FIELD_ARITHMETIC_MEAN_SCALING)
                          MEAN_LENGTH=(LENGTH1+LENGTH2)/2.0_DP
                        CASE(FIELD_GEOMETRIC_MEAN_SCALING)
                          MEAN_LENGTH=sqrt(LENGTH1*LENGTH2)
                        CASE(FIELD_HARMONIC_MEAN_SCALING)
                          TEMP=LENGTH1*LENGTH2
                          IF(ABS(TEMP)>ZERO_TOLERANCE) THEN
                            MEAN_LENGTH=2.0_DP*TEMP/(LENGTH1+LENGTH2)
                          ELSE
                            MEAN_LENGTH=0.0_DP
                          ENDIF
                        CASE DEFAULT
                          localError="The scaling type of "// &
                            & TRIM(NumberToVString(FIELD_SCALINGS%scalingType,"*",err,error))//" is invalid."
                          CALL FlagError(localError,err,error,*999)
                        END SELECT
                      ENDIF
                      DO version_idx=1,DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                        dof_idx=DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%dofIndex(version_idx)
                        CALL DistributedVector_ValuesSet(FIELD_SCALING%scaleFactors,dof_idx,MEAN_LENGTH,err,error,*999)
                      ENDDO !version_idx
                    ENDIF
                  CASE(PART_DERIV_S1_S2,PART_DERIV_S1_S3,PART_DERIV_S2_S3,PART_DERIV_S1_S2_S3)
                    DO version_idx=1,DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                      dof_idx=DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%dofIndex(version_idx)
                      IF(partial_derivative_idx==PART_DERIV_S1_S2) THEN
                        ni1=1
                        nu1=PART_DERIV_S1
                        ni2=2
                        nu2=PART_DERIV_S2
                      ELSE IF(partial_derivative_idx==PART_DERIV_S1_S3) THEN
                        ni1=1
                        nu1=PART_DERIV_S1
                        ni2=3
                        nu2=PART_DERIV_S3
                      ELSE IF(partial_derivative_idx==PART_DERIV_S2_S3) THEN
                        ni1=2
                        nu1=PART_DERIV_S2
                        ni2=3
                        nu2=PART_DERIV_S3
                      ELSE
                        ni1=1
                        nu1=PART_DERIV_S1
                        ni2=2
                        nu2=PART_DERIV_S2
                      ENDIF
!!TODO: Shouldn't have to search for the derivative_idx directions. Store them somewhere.
                      !Find the first direction derivative_idx
                      FOUND=.FALSE.
                      DO nk2=1,DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
                        IF(DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(nk2)%partialDerivativeIndex==nu1) THEN
                          ny1=DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(nk2)%dofIndex(version_idx)
                          FOUND=.TRUE.
                          EXIT
                        ENDIF
                      ENDDO !nk2
                      IF(FOUND) THEN
                        !Find the second direction derivative_idx
                        FOUND=.FALSE.
                        DO nk2=1,DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
                          IF(DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(nk2)%partialDerivativeIndex==nu2) THEN
                            ny2=DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(nk2)%dofIndex(version_idx)
                            FOUND=.TRUE.
                            EXIT
                          ENDIF
                        ENDDO !nk2
                        IF(FOUND) THEN
                          IF(partial_derivative_idx==PART_DERIV_S1_S2_S3) THEN
                            !Find the third direction derivative_idx
                            FOUND=.FALSE.
                            DO nk2=1,DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
                              IF(DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(nk2)%partialDerivativeIndex==PART_DERIV_S3) THEN
                                ny3=DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(nk2)%dofIndex(version_idx)
                                FOUND=.TRUE.
                                EXIT
                              ENDIF
                            ENDDO !nk2
                            IF(FOUND) THEN
                              CALL DistributedVector_ValuesSet(FIELD_SCALING%scaleFactors,dof_idx, &
                                SCALE_FACTORS(ny1)*SCALE_FACTORS(ny2)*SCALE_FACTORS(ny3),err,error,*999)
                            ELSE
                              localError="Could not find the first partial derivative in the s3 direction index for "//&
                                & "local node number "//TRIM(NumberToVString(node_idx,"*",err,error))//"."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL DistributedVector_ValuesSet(FIELD_SCALING%scaleFactors,dof_idx,SCALE_FACTORS(ny1)* &
                              & SCALE_FACTORS(ny2),err,error,*999)
                          ENDIF
                        ELSE
                          localError="Could not find the first partial derivative in the s"// &
                            & TRIM(NumberToVString(ni2,"*",err,error))//" direction index for "//&
                            & "local node number "//TRIM(NumberToVString(node_idx,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        localError="Could not find the first partial derivative in the s"// &
                          & TRIM(NumberToVString(ni1,"*",err,error))//" direction index for "//&
                          & "local node number "//TRIM(NumberToVString(node_idx,"*",err,error))//"."
                      ENDIF
                    ENDDO !version_idx
                  CASE DEFAULT
                    localError="The partial derivative index of "//TRIM(NumberToVString(partial_derivative_idx,"*", &
                      & err,error))//" for derivative number "//TRIM(NumberToVString(derivative_idx,"*",err,error))// &
                      & " of local node number "//TRIM(NumberToVString(node_idx,"*",err,error))//" is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                ENDDO !derivative_idx
              ENDDO !node_idx
              CALL DistributedVector_UpdateStart(FIELD_SCALING%scaleFactors,err,error,*999)
              CALL DistributedVector_UpdateFinish(FIELD_SCALING%scaleFactors,err,error,*999)
            ENDDO !scaling_idx
          CASE DEFAULT
            localError="The scaling type of "//TRIM(NumberToVString(FIELD_SCALINGS%scalingType,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("Field geometric field is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Field scalings is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      IF(FIELD_SCALINGS%scalingType /= FIELD_NO_SCALING) THEN
        IF(ASSOCIATED(DOMAIN))THEN
          DOMAIN_NODES=>DOMAIN%TOPOLOGY%NODES
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Scale Factors for nodes in the domain:",err,error,*999)
          DO node_idx=1,DOMAIN_NODES%numberOfNodes
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"Node : ",node_idx,err,error,*999)
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of Derivatives = ", &
              & DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives,err,error,*999)
            DO derivative_idx=1,DOMAIN_NODES%nodes(node_idx)%numberOfDerivatives
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Derivative : ",derivative_idx,err,error,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Number of Versions = ", &
                & DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions,err,error,*999)
              DO version_idx=1,DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Version : ",version_idx,err,error,*999)
                dof_idx=DOMAIN_NODES%nodes(node_idx)%DERIVATIVES(derivative_idx)%dofIndex(version_idx)
                CALL DistributedVector_ValuesGet(FIELD_SCALING%scaleFactors,dof_idx,VALUE,err,error,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Scale Factor : ",VALUE,err,error,*999)
              ENDDO !version_idx
            ENDDO !derivative_idx
          ENDDO !node_idx
        ENDIF
      ENDIF
    ENDIF

    EXITS("FIELD_SCALINGS_CALCULATE")
    RETURN
999 ERRORSEXITS("FIELD_SCALINGS_CALCULATE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_SCALINGS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the scalings for a field and deallocates all memory.
  SUBROUTINE FIELD_SCALINGS_FINALISE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to finalise the scalings for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scaling_idx

    ENTERS("FIELD_SCALINGS_FINALISE",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      DO scaling_idx=1,FIELD%SCALINGS%numberOfScalingIndices
        CALL FIELD_SCALING_FINALISE(FIELD,scaling_idx,err,error,*999)
      ENDDO !scaling_idx
      IF(ALLOCATED(FIELD%SCALINGS%SCALINGS)) DEALLOCATE(FIELD%SCALINGS%SCALINGS)
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_SCALINGS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_SCALINGS_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_SCALINGS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the scaling parameters sets for a field.
  SUBROUTINE FIELD_SCALINGS_INITIALISE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the scalings for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,DUMMY_ERR,NUMBER_OF_MESH_COMPONENTS,scaling_idx,variable_idx
    INTEGER(INTG), ALLOCATABLE :: MESH_COMPONENTS(:),MESH_COMPONENTS_MAP(:)
    TYPE(LIST_TYPE), POINTER :: MESH_COMPONENTS_LIST
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    NULLIFY(MESH_COMPONENTS_LIST)

    ENTERS("FIELD_SCALINGS_INITIALISE",err,error,*997)

    IF(ASSOCIATED(FIELD)) THEN
      !Calculate the mesh component numbers involved in the field
      CALL LIST_CREATE_START(MESH_COMPONENTS_LIST,err,error,*999)
      CALL LIST_DATA_TYPE_SET(MESH_COMPONENTS_LIST,LIST_INTG_TYPE,err,error,*999)
      CALL LIST_INITIAL_SIZE_SET(MESH_COMPONENTS_LIST,FIELD%DECOMPOSITION%MESH%numberOfComponents,err,error,*999)
      CALL LIST_CREATE_FINISH(MESH_COMPONENTS_LIST,err,error,*999)
      DO variable_idx=1,FIELD%numberOfVariables
        DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
          CALL LIST_ITEM_ADD(MESH_COMPONENTS_LIST,FIELD%variables(variable_idx)%components(component_idx)%meshComponentNumber, &
            & err,error,*999)
        ENDDO !component_idx
      ENDDO !variable_idx
      CALL LIST_REMOVE_DUPLICATES(MESH_COMPONENTS_LIST,err,error,*999)
      CALL LIST_DETACH_AND_DESTROY(MESH_COMPONENTS_LIST,NUMBER_OF_MESH_COMPONENTS,MESH_COMPONENTS,err,error,*999)
      ALLOCATE(MESH_COMPONENTS_MAP(FIELD%DECOMPOSITION%MESH%numberOfComponents),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate mesh components map.",err,error,*999)
      MESH_COMPONENTS_MAP=0
      DO component_idx=1,NUMBER_OF_MESH_COMPONENTS
        MESH_COMPONENTS_MAP(MESH_COMPONENTS(component_idx))=component_idx
      ENDDO !component_idx
      !Allocate the scaling indices and initialise them
      FIELD%SCALINGS%numberOfScalingIndices=NUMBER_OF_MESH_COMPONENTS
      ALLOCATE(FIELD%SCALINGS%SCALINGS(FIELD%SCALINGS%numberOfScalingIndices),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate field scalings.",err,error,*999)
      DO scaling_idx=1,FIELD%SCALINGS%numberOfScalingIndices
        CALL FIELD_SCALING_INITIALISE(FIELD,scaling_idx,MESH_COMPONENTS(scaling_idx),err,error,*999)
      ENDDO !scaling_idx
      !Set the scaling index for all the field variable components
      DO variable_idx=1,FIELD%numberOfVariables
        DO component_idx=1,FIELD%variables(variable_idx)%numberOfComponents
          FIELD%variables(variable_idx)%components(component_idx)%scalingIndex= &
            & MESH_COMPONENTS_MAP(FIELD%variables(variable_idx)%components(component_idx)%meshComponentNumber)
        ENDDO !component_idx
      ENDDO !variable_idx
      DEALLOCATE(MESH_COMPONENTS)
      IF(FIELD%TYPE/=FIELD_GEOMETRIC_TYPE) CALL FIELD_SCALINGS_CALCULATE(FIELD,err,error,*999)
    ELSE
      CALL FlagError("Field is not associated.",err,error,*997)
    ENDIF

    EXITS("FIELD_SCALINGS_INITIALISE")
    RETURN
999 IF(ALLOCATED(MESH_COMPONENTS)) DEALLOCATE(MESH_COMPONENTS)
    IF(ASSOCIATED(MESH_COMPONENTS_LIST)) CALL LIST_DESTROY(MESH_COMPONENTS_LIST,err,error,*998)
998 CALL FIELD_SCALINGS_FINALISE(FIELD,DUMMY_ERR,DUMMY_ERROR,*997)
997 ERRORSEXITS("FIELD_SCALINGS_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_SCALINGS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Checks the scaling type for a field.
  SUBROUTINE FIELD_SCALING_TYPE_CHECK(FIELD,scalingType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to check the scaling type for
    INTEGER(INTG), INTENT(IN) :: scalingType !<The scaling type for the specified field to check \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_SCALING_TYPE_CHECK",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        SELECT CASE(scalingType)
        CASE(FIELD_NO_SCALING)
          IF(FIELD%SCALINGS%scalingType/=FIELD_NO_SCALING) THEN
            localError="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%scalingType,"*",err,error))// &
              & " which is not no scaling."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_UNIT_SCALING)
          IF(FIELD%SCALINGS%scalingType/=FIELD_UNIT_SCALING) THEN
            localError="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%scalingType,"*",err,error))// &
              & " which is not unit scaling."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          IF(FIELD%SCALINGS%scalingType/=FIELD_ARC_LENGTH_SCALING) THEN
            localError="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%scalingType,"*",err,error))// &
              & " which is not arc length scaling."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARITHMETIC_MEAN_SCALING)
          IF(FIELD%SCALINGS%scalingType/=FIELD_ARITHMETIC_MEAN_SCALING) THEN
            localError="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%scalingType,"*",err,error))// &
              
              & " which is not arithmetic mean scaling."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_GEOMETRIC_MEAN_SCALING)
          IF(FIELD%SCALINGS%scalingType/=FIELD_GEOMETRIC_MEAN_SCALING) THEN
            localError="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%scalingType,"*",err,error))// &
              
              & " which is not geometric mean scaling."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_HARMONIC_MEAN_SCALING)
          IF(FIELD%SCALINGS%scalingType/=FIELD_HARMONIC_MEAN_SCALING) THEN
            localError="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%scalingType,"*",err,error))// &
              & " which is not harmonic mean scaling."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE DEFAULT
          localError="The specified scaling type of "//TRIM(NumberToVString(scalingType,"*",err,error))// &
            & " is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_SCALING_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_TYPE_CHECK",err,error)
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the scaling type for a field. \see OpenCMISS::Iron::cmfe_Field_ScalingTypeGet
  SUBROUTINE FIELD_SCALING_TYPE_GET(FIELD,scalingType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the scaling type for
    INTEGER(INTG), INTENT(OUT) :: scalingType !<On return, the scaling type for the specified field to get \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_SCALING_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        scalingType=FIELD%SCALINGS%scalingType
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_SCALING_TYPE_GET")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_TYPE_GET",err,error)
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field. \see OpenCMISS::Iron::cmfe_FieldScalingTypeSet
  SUBROUTINE FIELD_SCALING_TYPE_SET(FIELD,scalingType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the scaling type for
    INTEGER(INTG), INTENT(IN) :: scalingType !<The scaling type to set \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_SCALING_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " has been finished."
        CALL FlagError(localError,err,error,*999)
      ELSE
        IF(ASSOCIATED(FIELD%createValuesCache)) THEN
          IF(FIELD%createValuesCache%scalingTypeLocked) THEN
            localError="The field scaling type has been locked for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
            CALL FlagError(localError,err,error,*999)
          ELSE
            SELECT CASE(scalingType)
            CASE(FIELD_NO_SCALING)
              FIELD%SCALINGS%scalingType=FIELD_NO_SCALING
            CASE(FIELD_UNIT_SCALING)
              FIELD%SCALINGS%scalingType=FIELD_UNIT_SCALING
            CASE(FIELD_ARC_LENGTH_SCALING)
              FIELD%SCALINGS%scalingType=FIELD_ARC_LENGTH_SCALING
            CASE(FIELD_ARITHMETIC_MEAN_SCALING)
              FIELD%SCALINGS%scalingType=FIELD_ARITHMETIC_MEAN_SCALING
            CASE(FIELD_GEOMETRIC_MEAN_SCALING)
              FIELD%SCALINGS%scalingType=FIELD_GEOMETRIC_MEAN_SCALING
            CASE(FIELD_HARMONIC_MEAN_SCALING)
              FIELD%SCALINGS%scalingType=FIELD_HARMONIC_MEAN_SCALING
            CASE DEFAULT
              localError="The specified scaling type of "//TRIM(NumberToVString(scalingType,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ELSE
          localError="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_SCALING_TYPE_SET")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_TYPE_SET",err,error)
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field and locks it so that no further changes can be made.
  SUBROUTINE FIELD_SCALING_TYPE_SET_AND_LOCK(FIELD,scalingType,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the scaling type for
    INTEGER(INTG), INTENT(IN) :: scalingType !<The scaling type to set \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_SCALING_TYPE_SET_AND_LOCK",err,error,*999)

    CALL FIELD_SCALING_TYPE_SET(FIELD,scalingType,err,error,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%createValuesCache)) THEN
        FIELD%createValuesCache%scalingTypeLocked=.TRUE.
      ELSE
        localError="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_SCALING_TYPE_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_TYPE_SET_AND_LOCK",err,error)
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks the field type for a field.
  SUBROUTINE FIELD_TYPE_CHECK(FIELD,TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to check the type for
    INTEGER(INTG), INTENT(IN) :: TYPE !<The field type to check \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_TYPE_CHECK",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        SELECT CASE(TYPE)
        CASE(FIELD_GEOMETRIC_TYPE)
          IF(FIELD%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
            localError="Invalid field type. The field type for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(FIELD%TYPE,"*",err,error))// &
              & " which is not a geometric field."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_FIBRE_TYPE)
          IF(FIELD%TYPE/=FIELD_FIBRE_TYPE) THEN
            localError="Invalid field type. The field type for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(FIELD%TYPE,"*",err,error))// &
              & " which is not a fibre field."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_GENERAL_TYPE)
          IF(FIELD%TYPE/=FIELD_GENERAL_TYPE) THEN
            localError="Invalid field type. The field type for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(FIELD%TYPE,"*",err,error))// &
              & " which is not a general field."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_MATERIAL_TYPE)
          IF(FIELD%TYPE/=FIELD_MATERIAL_TYPE) THEN
            localError="Invalid field type. The field type for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(FIELD%TYPE,"*",err,error))// &
              & " which is not a material field."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_GEOMETRIC_GENERAL_TYPE)
          IF(FIELD%TYPE/=FIELD_GEOMETRIC_GENERAL_TYPE) THEN
            localError="Invalid field type. The field type for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
              & TRIM(NumberToVString(FIELD%TYPE,"*",err,error))// &
              & " which is not a geometric general field."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE DEFAULT
          localError="The specified field type of "//TRIM(NumberToVString(TYPE,"*",err,error))//" is invalid."
          CALL FlagError(localError,err,error,*999)          
        END SELECT
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_TYPE_CHECK",err,error)
    RETURN 1
  END SUBROUTINE FIELD_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the field type for a field. \see OpenCMISS::Iron::cmfe_FieldTypeGet
  SUBROUTINE FIELD_TYPE_GET(FIELD,TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the type for
    INTEGER(INTG), INTENT(OUT) :: TYPE !<On return, the field type for the specified field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        TYPE=FIELD%TYPE
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_TYPE_GET")
    RETURN
999 ERRORSEXITS("FIELD_TYPE_GET",err,error)
    RETURN 1
  END SUBROUTINE FIELD_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field. \see OpenCMISS::Iron::cmfe_FieldTypeSet
  SUBROUTINE FIELD_TYPE_SET(FIELD,TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: TYPE !<The field type to set \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " has been finished."
        CALL FlagError(localError,err,error,*999)
      ELSE
        IF(ASSOCIATED(FIELD%createValuesCache)) THEN
          IF(FIELD%createValuesCache%TYPE_LOCKED) THEN
            localError="The field type has been locked for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
            CALL FlagError(localError,err,error,*999)
          ELSE
            SELECT CASE(TYPE)
            CASE(FIELD_GEOMETRIC_TYPE)
              FIELD%TYPE=FIELD_GEOMETRIC_TYPE
              FIELD%geometricField=>FIELD
            CASE(FIELD_FIBRE_TYPE)
              FIELD%TYPE=FIELD_FIBRE_TYPE
              NULLIFY(FIELD%geometricField)
            CASE(FIELD_GENERAL_TYPE)
              FIELD%TYPE=FIELD_GENERAL_TYPE
              NULLIFY(FIELD%geometricField)
            CASE(FIELD_MATERIAL_TYPE)
              FIELD%TYPE=FIELD_MATERIAL_TYPE
              NULLIFY(FIELD%geometricField)
            CASE(FIELD_GEOMETRIC_GENERAL_TYPE)
              FIELD%TYPE=FIELD_GEOMETRIC_GENERAL_TYPE
              NULLIFY(FIELD%geometricField)
            CASE DEFAULT
              localError="The specified field type of "//TRIM(NumberToVString(TYPE,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ELSE
          localError="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_TYPE_SET")
    RETURN
999 ERRORSEXITS("FIELD_TYPE_SET",err,error)
    RETURN 1
  END SUBROUTINE FIELD_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field and locks it so that no further changes can be made.
  SUBROUTINE FIELD_TYPE_SET_AND_LOCK(FIELD,TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: TYPE !<The field type to set \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_TYPE_SET_AND_LOCK",err,error,*999)

    CALL FIELD_TYPE_SET(FIELD,TYPE,err,error,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%createValuesCache)) THEN
        FIELD%createValuesCache%TYPE_LOCKED=.TRUE.
      ELSE
        localError="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_TYPE_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_TYPE_SET_AND_LOCK",err,error)
    RETURN 1
  END SUBROUTINE FIELD_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Finalises a field variable and deallocates all memory.
  SUBROUTINE FIELD_VARIABLE_FINALISE(FIELD_VARIABLE,err,error,*)

    !Argument variables
    TYPE(FieldVariableType) :: FIELD_VARIABLE !<The field variable to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELD_VARIABLE_FINALISE",err,error,*999)

    FIELD_VARIABLE%variableLabel=""
    CALL FIELD_VARIABLE_COMPONENTS_FINALISE(FIELD_VARIABLE,err,error,*999)
    CALL DomainMapping_Finalise(FIELD_VARIABLE%domainMapping,err,error,*999)
    CALL Field_DofToParamMapFinalise(FIELD_VARIABLE%dofToParamMap,err,error,*999)
    CALL FIELD_PARAMETER_SETS_FINALISE(FIELD_VARIABLE,err,error,*999)

    EXITS("FIELD_VARIABLE_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises a field variable.
  SUBROUTINE FIELD_VARIABLE_INITIALISE(FIELD,variableNumber,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the variable for
    INTEGER(INTG), INTENT(IN) :: variableNumber !<The variable number of the field to initialise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,DUMMY_ERR,variable_type
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    ENTERS("FIELD_VARIABLE_INITIALISE",err,error,*998)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%createValuesCache)) THEN
        IF(variableNumber>=1.AND.variableNumber<=FIELD%numberOfVariables) THEN
          NULLIFY(FIELD%variables(variableNumber)%FIELD)
          NULLIFY(FIELD%variables(variableNumber)%REGION)
          NULLIFY(FIELD%variables(variableNumber)%domainMapping)
!!TODO this should be done via a field_parameter_sets_initialise call
          NULLIFY(FIELD%variables(variableNumber)%parameterSets%setType)
          NULLIFY(FIELD%variables(variableNumber)%parameterSets%parameterSets)
          FIELD%variables(variableNumber)%variableNumber=variableNumber
          variable_type=FIELD%createValuesCache%variableTypes(variableNumber)
          IF(variable_type>=1.AND.variable_type<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD%variables(variableNumber)%variableType=FIELD%createValuesCache%variableTypes(variableNumber)
          ELSE
            localError="A field variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
              & " for variable number "//TRIM(NumberToVString(variableNumber,"*",err,error))// &
              & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
              & " is invalid. The number must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FlagError(localError,err,error,*998)
          ENDIF
          FIELD%variableTypeMap(FIELD%variables(variableNumber)%variableType)%ptr=>FIELD%variables(variableNumber)
          FIELD_VARIABLE=>FIELD%variableTypeMap(FIELD%variables(variableNumber)%variableType)%ptr
          FIELD_VARIABLE%variableLabel=""
          FIELD_VARIABLE%variableLabel=FIELD%createValuesCache%variableLabels(variable_type)
          FIELD_VARIABLE%FIELD=>FIELD
          FIELD_VARIABLE%REGION=>FIELD%REGION
          FIELD_VARIABLE%DIMENSION=FIELD%createValuesCache%DIMENSION(variable_type)
          FIELD_VARIABLE%dataType=FIELD%createValuesCache%dataTypes(variable_type)
          FIELD_VARIABLE%dofOrderType=FIELD%createValuesCache%dofOrderTypes(variable_type)
          IF(FIELD%createValuesCache%numberOfComponents(variable_type)>0) THEN
            FIELD_VARIABLE%numberOfComponents=FIELD%createValuesCache%numberOfComponents(variable_type)
            CALL FIELD_VARIABLE_COMPONENTS_INITIALISE(FIELD,variable_type,err,error,*999)
          ELSE
            localError="The number of components of "// &
              & TRIM(NumberToVString(FIELD%createValuesCache%numberOfComponents(variable_type),"*",err,error))// &
              & " for variable type "//TRIM(NumberToVString(variable_type,"*",err,error))// &
              & " of field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
              & " is invalid. The number must be > 0."
            CALL FlagError(localError,err,error,*999)
          ENDIF
          FIELD_VARIABLE%maxNumberElementInterpolationParameters=-1
          FIELD_VARIABLE%maxNumberNodeInterpolationParameters=-1
          DO component_idx=1,FIELD_VARIABLE%numberOfComponents
            IF(FIELD_VARIABLE%components(component_idx)%maxNumberElementInterpolationParameters> &
              & FIELD_VARIABLE%maxNumberElementInterpolationParameters) FIELD_VARIABLE% &
              & maxNumberElementInterpolationParameters=FIELD_VARIABLE%components(component_idx)% &
              & maxNumberElementInterpolationParameters
            IF(FIELD_VARIABLE%components(component_idx)%maxNumberNodeInterpolationParameters> &
              & FIELD_VARIABLE%maxNumberNodeInterpolationParameters) FIELD_VARIABLE% &
              & maxNumberNodeInterpolationParameters=FIELD_VARIABLE%components(component_idx)% &
              & maxNumberNodeInterpolationParameters
          ENDDO !component_idx
          FIELD_VARIABLE%numberOfDofs=0
          FIELD_VARIABLE%totalNumberOfDofs=0
          FIELD_VARIABLE%numberOfGlobalDofs=0
          CALL DomainMapping_Initialise(FIELD_VARIABLE%domainMapping,err,error,*999)
          CALL Field_DofToParamMapInitialise(FIELD_VARIABLE%dofToParamMap,err,error,*999)
        ELSE
          localError="Variable number "//TRIM(NumberToVString(variableNumber,"*",err,error))// &
            & " is invalid for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" which has "// &
            & TRIM(NumberToVString(FIELD%numberOfVariables,"*",err,error))//" variables."
          CALL FlagError(localError,err,error,*998)
        ENDIF
      ELSE
        CALL FlagError("Field create values cache is not associated.",err,error,*998)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*998)
    ENDIF

    EXITS("FIELD_VARIABLE_INITIALISE")
    RETURN
999 CALL FIELD_VARIABLE_FINALISE(FIELD_VARIABLE,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_VARIABLE_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable for character labels. \see OpenCMISS::Iron::cmfe_FieldVariableLabelGet
  SUBROUTINE FIELD_VARIABLE_LABEL_GET_C(FIELD,VARIABLE_TYPE,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    CHARACTER(LEN=*), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER :: C_LENGTH,VS_LENGTH
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_VARIABLE_LABEL_GET_C",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%variableTypeMap(VARIABLE_TYPE)%ptr
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            C_LENGTH=LEN(LABEL)
            VS_LENGTH=LEN_TRIM(FIELD_VARIABLE%variableLabel)
            IF(C_LENGTH>VS_LENGTH) THEN
              LABEL=CHAR(LEN_TRIM(FIELD_VARIABLE%variableLabel))
            ELSE
              LABEL=CHAR(FIELD_VARIABLE%variableLabel,C_LENGTH)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_GET_C")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_GET_C",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_GET_C

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable for varying string labels. \see OpenCMISS::Iron::cmfe_FieldVariableLabelGet
  SUBROUTINE FIELD_VARIABLE_LABEL_GET_VS(FIELD,VARIABLE_TYPE,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    TYPE(VARYING_STRING), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldVariableType), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_VARIABLE_LABEL_GET_VS",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%variableTypeMap(VARIABLE_TYPE)%ptr
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            LABEL=FIELD_VARIABLE%variableLabel
          ELSE
            localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_GET_VS")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_GET_VS",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_GET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels. \see OpenCMISS::Iron::cmfe_FieldVariableLabelSet
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_C(FIELD,VARIABLE_TYPE,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_VARIABLE_LABEL_SET_C",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" has been finished."
        CALL FlagError(localError,err,error,*999)
      ELSE
        IF(ASSOCIATED(FIELD%createValuesCache)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%createValuesCache%variableTypes==VARIABLE_TYPE)) THEN
              IF(FIELD%createValuesCache%variableLabelsLocked(VARIABLE_TYPE)) THEN
                localError="The field variable label has been locked for for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
                CALL FlagError(localError,err,error,*999)
              ELSE
                FIELD%createValuesCache%variableLabels(VARIABLE_TYPE)=LABEL
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_SET_C")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_SET_C",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels. \see OpenCMISS::Iron::cmfe_FieldVariableLabelSet
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_VS(FIELD,VARIABLE_TYPE,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_VARIABLE_LABEL_SET_VS",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" has been finished."
        CALL FlagError(localError,err,error,*999)
      ELSE
        IF(ASSOCIATED(FIELD%createValuesCache)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%createValuesCache%variableTypes==VARIABLE_TYPE)) THEN
              IF(FIELD%createValuesCache%variableLabelsLocked(VARIABLE_TYPE)) THEN
                localError="The field variable label has been locked for for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
                CALL FlagError(localError,err,error,*999)
              ELSE
                FIELD%createValuesCache%variableLabels(VARIABLE_TYPE)=LABEL
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_SET_VS")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_SET_VS",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_C(FIELD,VARIABLE_TYPE,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_C",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_SET(FIELD,VARIABLE_TYPE,LABEL,err,error,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%createValuesCache)) THEN
        FIELD%createValuesCache%variableLabelsLocked(VARIABLE_TYPE)=.TRUE.
      ELSE
        localError="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_C")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_C",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS(FIELD,VARIABLE_TYPE,LABEL,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_SET(FIELD,VARIABLE_TYPE,LABEL,err,error,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%createValuesCache)) THEN
        FIELD%createValuesCache%variableLabelsLocked(VARIABLE_TYPE)=.TRUE.
      ELSE
        localError="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS

  !
  !================================================================================================================================
  !

  !>Checks the field variable types for a field.
  SUBROUTINE FIELD_VARIABLE_TYPES_CHECK(FIELD,VARIABLE_TYPES,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to check the variable types for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). The field variable type for the variable_idx'th field variable to check
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_VARIABLE_TYPES_CHECK",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        IF(SIZE(VARIABLE_TYPES,1)>=FIELD%numberOfVariables) THEN
          DO variable_idx=1,FIELD%numberOfVariables
            IF(VARIABLE_TYPES(variable_idx)>=1.AND.VARIABLE_TYPES(variable_idx)<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
              IF(FIELD%variables(variable_idx)%variableType/=VARIABLE_TYPES(variable_idx)) THEN
                localError="Invalid variable type. The variable type for variable index number "// &
                  & TRIM(NumberToVString(variable_idx,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" is "// &
                  & TRIM(NumberToVString(FIELD%variables(variable_idx)%variableType,"*",err,error))// &
                  & " which is does correspond to the specified variable_type of "// &
                  & TRIM(NumberToVString(VARIABLE_TYPES(variable_idx),"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPES(variable_idx),"*",err,error))// &
                & " at position number "//TRIM(NumberToVString(variable_idx,"*",err,error))// &
                & " is invalid. The variable type must be between 1 and "// &
                & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)                  
            ENDIF
          ENDDO !variable_idx
        ELSE
          localError="Invalid variable types. The size of the specified variable types array is "// &
            & TRIM(NumberToVString(SIZE(VARIABLE_TYPES,1),"*",err,error))//" and it must be >= "// &
            & TRIM(NumberToVString(FIELD%numberOfVariables,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_TYPES_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_TYPES_CHECK",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_CHECK

  !
  !================================================================================================================================
  !

  !>Checks the field contains the given field variable type.
  SUBROUTINE FIELD_VARIABLE_TYPE_CHECK(FIELD,VARIABLE_TYPE,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to check the variable type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    LOGICAL :: VARIABLE_FOUND
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_VARIABLE_TYPE_CHECK",err,error,*999)

    VARIABLE_FOUND=.FALSE.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        DO variable_idx=1,FIELD%numberOfVariables
          IF(FIELD%variables(variable_idx)%variableType==VARIABLE_TYPE) THEN
            VARIABLE_FOUND=.TRUE.
            CYCLE
          END IF
        ENDDO !variable_idx
        IF(.NOT.VARIABLE_FOUND) THEN
          CALL FlagError("Field does not have a variable type of "// &
            & TRIM(NumberToVString(VARIABLE_TYPE,"*",err,error))//".",err,error,*999)
        END IF
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_TYPE_CHECK",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the field variable types for a field. \see OpenCMISS::Iron::cmfe_FieldVariableTypesGet
  SUBROUTINE FIELD_VARIABLE_TYPES_GET(FIELD,VARIABLE_TYPES,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to get the variable types for
    INTEGER(INTG), INTENT(OUT) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). On return, the field variable type variable_idx'th field variable
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_VARIABLE_TYPES_GET",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        IF(SIZE(VARIABLE_TYPES,1)>=FIELD%numberOfVariables) THEN
          VARIABLE_TYPES=0
          DO variable_idx=1,FIELD%numberOfVariables
            VARIABLE_TYPES(variable_idx)=FIELD%variables(variable_idx)%variableType
          ENDDO !variable_idx
        ELSE
          localError="Invalid variable types. The size of the specified variable types array is "// &
            & TRIM(NumberToVString(SIZE(VARIABLE_TYPES,1),"*",err,error))//" and it must be >= "// &
            & TRIM(NumberToVString(FIELD%numberOfVariables,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_TYPES_GET")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_TYPES_GET",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field. \see OpenCMISS::Iron::cmfe_FieldVariableTypesSet
  SUBROUTINE FIELD_VARIABLE_TYPES_SET(FIELD,VARIABLE_TYPES,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). The field variable type for the variable_idx'th field variable to set 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: NUMBER_OF_COMPONENTS,old_variable_type,variable_idx,variable_idx2,variable_type
    INTEGER(INTG) :: OLD_DIMENSION(FIELD_NUMBER_OF_VARIABLE_TYPES),oldDataTypes(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & oldDOFOrderTypes(FIELD_NUMBER_OF_VARIABLE_TYPES),OLD_NUMBER_OF_COMPONENTS(FIELD_NUMBER_OF_VARIABLE_TYPES)
    INTEGER(INTG), ALLOCATABLE :: oldVariableTypes(:),OLD_INTERPOLATION_TYPE(:,:),oldMeshComponentNumber(:,:)
    LOGICAL :: OLD_DIMENSION_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),oldDataTypesLocked(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & oldDOFOrderTypesLocked(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & oldNumberOfComponentsLocked(FIELD_NUMBER_OF_VARIABLE_TYPES),OLD_LABELS_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES)
    LOGICAL, ALLOCATABLE :: OLD_INTERPOLATION_TYPE_LOCKED(:,:),oldMeshComponentNumberLocked(:,:)
    TYPE(VARYING_STRING) :: localError,OLD_LABELS(FIELD_NUMBER_OF_VARIABLE_TYPES)

    ENTERS("FIELD_VARIABLE_TYPES_SET",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%fieldFinished) THEN
        localError="Field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
          & " has been finished."
        CALL FlagError(localError,err,error,*999)
      ELSE
        IF(ASSOCIATED(FIELD%createValuesCache)) THEN
          IF(FIELD%createValuesCache%variableTypesLocked) THEN
            localError="The field variable types has been locked for field number "// &
              & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//" and can not be changed."
            CALL FlagError(localError,err,error,*999)
          ELSE
            IF(SIZE(VARIABLE_TYPES,1)==FIELD%numberOfVariables) THEN
              DO variable_idx=1,FIELD%numberOfVariables
                variable_type=VARIABLE_TYPES(variable_idx)
                !Check that the variable type is in range
                IF(variable_type<1.OR.VARIABLE_TYPE>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
                  localError="The specified variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
                    & " at position number "//TRIM(NumberToVString(variable_idx,"*",err,error))// &
                    & " is invalid. The variable type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)                  
                ENDIF
                !Check that the variable type is not repeated
                DO variable_idx2=variable_idx+1,FIELD%numberOfVariables
                  IF(VARIABLE_TYPES(variable_idx2)==variable_type) THEN
                    localError="The specified variable type of "//TRIM(NumberToVString(variable_type,"*",err,error))// &
                      & " occurs at position number "//TRIM(NumberToVString(variable_idx,"*",err,error))// &
                      & " and position number "//TRIM(NumberToVString(variable_idx2,"*",err,error))// &
                      & ". The variable types must be unique."
                    CALL FlagError(localError,err,error,*999)                    
                  ENDIF
                ENDDO !variable_idx2
              ENDDO !variable_idx
              NUMBER_OF_COMPONENTS=SIZE(FIELD%createValuesCache%interpolationTypes,1)
              ALLOCATE(oldVariableTypes(FIELD%numberOfVariables),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate old variable types.",err,error,*999)
              ALLOCATE(OLD_INTERPOLATION_TYPE(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate old interpolation type.",err,error,*999)
              ALLOCATE(OLD_INTERPOLATION_TYPE_LOCKED(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate old interpolation type locked.",err,error,*999)
              ALLOCATE(oldMeshComponentNumber(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate old mesh component number.",err,error,*999)
              ALLOCATE(oldMeshComponentNumberLocked(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate old mesh component number locked.",err,error,*999)
              oldVariableTypes(1:FIELD%numberOfVariables)=FIELD%createValuesCache%variableTypes(1:FIELD%numberOfVariables)
              OLD_LABELS=FIELD%createValuesCache%variableLabels
              OLD_LABELS_LOCKED=FIELD%createValuesCache%variableLabelsLocked
              OLD_DIMENSION=FIELD%createValuesCache%DIMENSION
              OLD_DIMENSION_LOCKED=FIELD%createValuesCache%DIMENSION_LOCKED
              oldDataTypes=FIELD%createValuesCache%dataTypes
              oldDataTypesLocked=FIELD%createValuesCache%dataTypesLocked
              oldDOFOrderTypes=FIELD%createValuesCache%dofOrderTypes
              oldDOFOrderTypesLocked=FIELD%createValuesCache%dofOrderTypesLocked
              OLD_NUMBER_OF_COMPONENTS=FIELD%createValuesCache%numberOfComponents
              oldNumberOfComponentsLocked=FIELD%createValuesCache%numberOfComponentsLocked
              OLD_INTERPOLATION_TYPE(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%createValuesCache%interpolationTypes(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              OLD_INTERPOLATION_TYPE_LOCKED(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%createValuesCache%interpolationTypesLocked(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              oldMeshComponentNumber(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%createValuesCache%meshComponentNumber(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              oldMeshComponentNumberLocked(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%createValuesCache%meshComponentNumberLocked(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              FIELD%createValuesCache%variableTypes=0
              FIELD%createValuesCache%variableLabels=""
              FIELD%createValuesCache%variableLabelsLocked=.FALSE.
              FIELD%createValuesCache%DIMENSION=0
              FIELD%createValuesCache%DIMENSION_LOCKED=.FALSE.
              FIELD%createValuesCache%dataTypes=0
              FIELD%createValuesCache%dataTypesLocked=.FALSE.
              FIELD%createValuesCache%dofOrderTypes=0
              FIELD%createValuesCache%dofOrderTypesLocked=.FALSE.
              FIELD%createValuesCache%numberOfComponents=0
              FIELD%createValuesCache%numberOfComponentsLocked=.FALSE.
              FIELD%createValuesCache%interpolationTypes=0
              FIELD%createValuesCache%interpolationTypesLocked=.FALSE.
              FIELD%createValuesCache%meshComponentNumber=0
              FIELD%createValuesCache%meshComponentNumberLocked=.FALSE.
              DO variable_idx=1,FIELD%numberOfVariables                
                variable_type=VARIABLE_TYPES(variable_idx)
                old_variable_type=oldVariableTypes(variable_idx)
                FIELD%createValuesCache%variableLabels(variable_type)=OLD_LABELS(old_variable_type)
                FIELD%createValuesCache%variableLabelsLocked(variable_type)=OLD_LABELS_LOCKED(old_variable_type)
                FIELD%createValuesCache%DIMENSION(variable_type)=OLD_DIMENSION(old_variable_type)
                FIELD%createValuesCache%DIMENSION_LOCKED(variable_type)=OLD_DIMENSION_LOCKED(old_variable_type)
                FIELD%createValuesCache%dataTypes(variable_type)=oldDataTypes(old_variable_type)
                FIELD%createValuesCache%dataTypesLocked(variable_type)=oldDataTypesLocked(old_variable_type)
                FIELD%createValuesCache%dofOrderTypes(variable_type)=oldDOFOrderTypes(old_variable_type)
                FIELD%createValuesCache%dofOrderTypesLocked(variable_type)=oldDOFOrderTypesLocked(old_variable_type)
                FIELD%createValuesCache%numberOfComponents(variable_type)=OLD_NUMBER_OF_COMPONENTS(old_variable_type)
                FIELD%createValuesCache%numberOfComponentsLocked(variable_type)=oldNumberOfComponentsLocked( &
                  & old_variable_type)
                FIELD%createValuesCache%interpolationTypes(:,variable_type)=OLD_INTERPOLATION_TYPE(:,old_variable_type)
                FIELD%createValuesCache%interpolationTypesLocked(:,variable_type)=OLD_INTERPOLATION_TYPE_LOCKED(:, &
                  & old_variable_type)
                FIELD%createValuesCache%meshComponentNumber(:,variable_type)=oldMeshComponentNumber(:,old_variable_type)
                FIELD%createValuesCache%meshComponentNumberLocked(:,variable_type)=oldMeshComponentNumberLocked(:, &
                  & old_variable_type)
              ENDDO !variable_idx
              FIELD%createValuesCache%variableTypes(1:SIZE(VARIABLE_TYPES,1))=VARIABLE_TYPES(1:SIZE(VARIABLE_TYPES,1))
              DEALLOCATE(oldVariableTypes)
              DEALLOCATE(OLD_INTERPOLATION_TYPE)
              DEALLOCATE(OLD_INTERPOLATION_TYPE_LOCKED)
              DEALLOCATE(oldMeshComponentNumber)
              DEALLOCATE(oldMeshComponentNumberLocked)              
            ELSE
              localError="Invalid variable types. The size of the specified variable types array is "// &
                & TRIM(NumberToVString(SIZE(VARIABLE_TYPES,1),"*",err,error))// &
                & " and the number of variables for field number "//TRIM(NumberToVString(FIELD%userNumber,"*",err,error))// &
                & " is "//TRIM(NumberToVString(FIELD%numberOfVariables,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ENDIF
        ELSE
          localError="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_TYPES_SET")
    RETURN
999 IF(ALLOCATED(oldVariableTypes)) DEALLOCATE(oldVariableTypes)
    IF(ALLOCATED(OLD_INTERPOLATION_TYPE)) DEALLOCATE(OLD_INTERPOLATION_TYPE)
    IF(ALLOCATED(OLD_INTERPOLATION_TYPE_LOCKED)) DEALLOCATE(OLD_INTERPOLATION_TYPE_LOCKED)
    IF(ALLOCATED(oldMeshComponentNumber)) DEALLOCATE(oldMeshComponentNumber)
    IF(ALLOCATED(oldMeshComponentNumberLocked)) DEALLOCATE(oldMeshComponentNumberLocked)
    ERRORSEXITS("FIELD_VARIABLE_TYPES_SET",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field and locks it so that no further changes can be made.
  SUBROUTINE FIELD_VARIABLE_TYPES_SET_AND_LOCK(FIELD,VARIABLE_TYPES,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). The field variable type for the variable_idx'th field variable to set 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FIELD_VARIABLE_TYPES_SET_AND_LOCK",err,error,*999)

    CALL FIELD_VARIABLE_TYPES_SET(FIELD,VARIABLE_TYPES,err,error,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%createValuesCache)) THEN
        FIELD%createValuesCache%variableTypesLocked=.TRUE.
      ELSE
        localError="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%userNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_TYPES_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_TYPES_SET_AND_LOCK",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks for a valid setup of the field variables
  SUBROUTINE FieldVariablesCheck(field,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: field !<A pointer to the field to check the variables for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableIdx,variableIdx2,variableType,variableType2
    LOGICAL :: duplicates
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariablesCheck",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(ASSOCIATED(field%createValuesCache)) THEN
        !Check the number of field variables
        IF(field%numberOfVariables>0) THEN
          !Check that the variable types are unique. Just do an exhaustive check. It is expensive but the list should be short.
          duplicates=.FALSE.
          firstVariable: DO variableIdx=1,field%numberOfVariables
            variableType=field%createValuesCache%variableTypes(variableIdx)
            secondVariable: DO variableIdx2=variableIdx+1,field%numberOfVariables
              variableType2=field%createValuesCache%variableTypes(variableIdx2)
              IF(variableType==variableType2) THEN
                duplicates=.TRUE.
                EXIT firstVariable
              ENDIF
            ENDDO secondVariable !variableIdx2
          ENDDO firstVariable !variableIdx
          IF(duplicates) THEN
            localError="Invalid variable types. Two or more variables have variable type "// &
              & TRIM(NumberToVString(variableType,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Invalid field setup. The field has "//TRIM(NumberToVString(field%numberOfVariables,"*",err,error))// &
            & " variables and should have > 0 variables."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Field create values cache is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FieldVariablesCheck")
    RETURN
999 ERRORSEXITS("FieldVariablesCheck",err,error)
    RETURN 1

  END SUBROUTINE FieldVariablesCheck

  !
  !================================================================================================================================
  !

  !>Finalises the field variables for a field and deallocates all memory.
  SUBROUTINE FIELD_VARIABLES_FINALISE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to finalise the variables for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx

    ENTERS("FIELD_VARIABLES_FINALISE",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ALLOCATED(FIELD%VARIABLES)) THEN
        DO variable_idx=1,SIZE(FIELD%VARIABLES,1)
          CALL FIELD_VARIABLE_FINALISE(FIELD%variables(variable_idx),err,error,*999)
        ENDDO !variable_idx
        DEALLOCATE(FIELD%VARIABLES)
      ENDIF
      FIELD%numberOfVariables=0
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLES_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLES_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLES_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the field variables.
  SUBROUTINE FIELD_VARIABLES_INITIALISE(FIELD,err,error,*)

    !Argument variables
    TYPE(FieldType), POINTER :: FIELD !<A pointer to the field to initialise the variables for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx

    ENTERS("FIELD_VARIABLES_INITIALISE",err,error,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ALLOCATED(FIELD%VARIABLES)) THEN
        CALL FlagError("Field already has associated variables.",err,error,*999)
      ELSE
        ALLOCATE(FIELD%variables(FIELD%numberOfVariables),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate new field variables.",err,error,*999)
        DO variable_idx=1,FIELD%numberOfVariables
          CALL FIELD_VARIABLE_INITIALISE(FIELD,variable_idx,err,error,*999)
        ENDDO !variable_idx
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FIELD_VARIABLES_INITIALISE")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLES_INITIALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLES_INITIALISE

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable. If the field parameter set has already been
  !>created then an error will be raised.
  SUBROUTINE FieldVariable_ParameterSetCreate(fieldVariable,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to create the parameter set for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,parameterSetIdx
    TYPE(FieldParameterSetType), POINTER :: newParameterSet
    TYPE(FieldParameterSetPtrType), POINTER :: newParameterSets(:)
    TYPE(VARYING_STRING) :: localError,dummyError

    NULLIFY(newParameterSet)
    NULLIFY(newParameterSets)

    ENTERS("FieldVariable_ParameterSetCreate",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    IF(.NOT.ASSOCIATED(fieldVariable%parameterSets%setType)) THEN
      localError="The parameter sets set types is not associated for the field variable type "// &
        & NumberToVString(fieldVariable%variableType,"*",err,error)
      IF(ASSOCIATED(fieldVariable%field)) THEN
        localError=localError//" of field number "//NumberToVString(fieldVariable%field%userNumber,"*",err,error)
      ENDIF
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(fieldSetType<1.OR.fieldSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
       localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
        & " is invalid. The field parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(ASSOCIATED(fieldVariable%parameterSets%setType(fieldSetType)%ptr)) THEN
      localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
        & " has already been created for variable type of "// &
        & NumberToVString(fieldVariable%variableType,"*",err,error)
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//NumberToVString(fieldVariable%field%userNumber,"*",err,error)
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    ALLOCATE(newParameterSet,STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate new parameter set.",err,error,*999)
    CALL FIELD_PARAMETER_SET_INITIALISE(newParameterSet,err,error,*999)
    
    newParameterSet%setIndex=fieldVariable%parameterSets%numberOfParameterSets+1
    newParameterSet%setType=fieldSetType
    NULLIFY(newParameterSet%parameters)
    CALL DistributedVector_CreateStart(fieldVariable%domainMapping,newParameterSet%parameters,err,error,*999)
    SELECT CASE(fieldVariable%dataType)
    CASE(FIELD_INTG_TYPE)
      CALL DistributedVector_DataTypeSet(newParameterSet%parameters,DISTRIBUTED_MATRIX_VECTOR_INTG_TYPE,err,error,*999)
    CASE(FIELD_SP_TYPE)
      CALL DistributedVector_DataTypeSet(newParameterSet%parameters,DISTRIBUTED_MATRIX_VECTOR_SP_TYPE,err,error,*999)
    CASE(FIELD_DP_TYPE)
      CALL DistributedVector_DataTypeSet(newParameterSet%parameters,DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
    CASE(FIELD_L_TYPE)
      CALL DistributedVector_DataTypeSet(newParameterSet%parameters,DISTRIBUTED_MATRIX_VECTOR_L_TYPE,err,error,*999)
    CASE DEFAULT
      localError="The field data type of "//TRIM(NumberToVString(fieldVariable%dataType,"*",err,error))// &
        & " is invalid for variable type of "//NumberToVString(fieldVariable%variableType,"*",err,error)
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//NumberToVString(fieldVariable%field%userNumber,"*",err,error)
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    CALL DistributedVector_CreateFinish(newParameterSet%parameters,err,error,*999)
    SELECT CASE(fieldVariable%dataType)
    CASE(FIELD_INTG_TYPE)
      CALL DistributedVector_AllValuesSet(newParameterSet%parameters,0_INTG,err,error,*999)
    CASE(FIELD_SP_TYPE)
      CALL DistributedVector_AllValuesSet(newParameterSet%parameters,0.0_SP,err,error,*999)
    CASE(FIELD_DP_TYPE)
      CALL DistributedVector_AllValuesSet(newParameterSet%parameters,0.0_DP,err,error,*999)
    CASE(FIELD_L_TYPE)
      CALL DistributedVector_AllValuesSet(newParameterSet%parameters,.FALSE.,err,error,*999)
    END SELECT
    !Add the new parameter set to the list of parameter sets
    ALLOCATE(newParameterSets(fieldVariable%parameterSets%numberOfParameterSets+1),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate new parameter sets.",err,error,*999)
    IF(ASSOCIATED(fieldVariable%parameterSets%parameterSets)) THEN
      DO parameterSetIdx=1,fieldVariable%parameterSets%numberOfParameterSets
        newParameterSets(parameterSetIdx)%ptr=>fieldVariable%parameterSets%parameterSets(parameterSetIdx)%ptr
      ENDDO !parameterSetIdx
      DEALLOCATE(fieldVariable%parameterSets%parameterSets)
    ENDIF
    newParameterSets(fieldVariable%parameterSets%numberOfParameterSets+1)%ptr=>newParameterSet
    ALLOCATE(fieldVariable%parameterSets%parameterSets(fieldVariable%parameterSets%numberOfParameterSets+1),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate field parameter sets parameter sets.",err,error,*999)
    DO parameterSetIdx=1,fieldVariable%parameterSets%numberOfParameterSets+1
      fieldVariable%parameterSets%parameterSets(parameterSetIdx)%ptr=>newParameterSets(parameterSetIdx)%ptr
    ENDDO !parameterSetIdx
    DEALLOCATE(newParameterSets)
    fieldVariable%parameterSets%numberOfParameterSets=fieldVariable%parameterSets%numberOfParameterSets+1
    fieldVariable%parameterSets%setType(fieldSetType)%ptr=>newParameterSet
    
    EXITS("FieldVariable_ParameterSetCreate")
    RETURN
999 CALL FIELD_PARAMETER_SET_FINALISE(newParameterSet,dummyErr,dummyError,*998)
998 IF(ASSOCIATED(newParameterSets)) DEALLOCATE(newParameterSets)
    ERRORSEXITS("FieldVariable_ParameterSetCreate",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetCreate

  !
  !================================================================================================================================
  !

  !>Checks whether a field variable parameter set has been created
  SUBROUTINE FieldVariable_ParameterSetCreated(fieldVariable,fieldSetType,parameterSetCreated,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    LOGICAL, INTENT(OUT) :: parameterSetCreated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetCreated",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    !Check the set type input
    IF(fieldSetType<1.OR.fieldSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
        & " is invalid. The field parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(.NOT.ASSOCIATED(fieldVariable%parameterSets%setType)) THEN
      localError="The parameter sets set types is not associated for the field variable type "// &
        & NumberToVString(fieldVariable%variableType,"*",err,error)
      IF(ASSOCIATED(fieldVariable%field)) &
        & localError=localError//" of field number "//NumberToVString(fieldVariable%field%userNumber,"*",err,error)
      localError=localError//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    !Check if this set type has been created
    parameterSetCreated=ASSOCIATED(fieldVariable%parameterSets%setType(fieldSetType)%ptr)

    EXITS("FieldVariable_ParameterSetCreated")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetCreated",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetCreated

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type for a field variable 
  SUBROUTINE FieldVariable_ParameterSetsCopy(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldType), POINTER :: field
    TYPE(FieldParameterSetType), POINTER :: fromParameterSet,toParameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetsCopy",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    IF(parameterFromSetType<=0.OR.parameterFromSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(parameterToSetType<=0.OR.parameterToSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    fromParameterSet=>fieldVariable%parameterSets%setType(parameterFromSetType)%ptr
    IF(ASSOCIATED(fromParameterSet)) THEN
      toParameterSet=>fieldVariable%parameterSets%setType(parameterToSetType)%ptr
      IF(ASSOCIATED(toParameterSet)) THEN
        !Do not need to do an update here as each rank already has the values.
        CALL DistributedVector_Copy(fromParameterSet%parameters,toParameterSet%parameters,alpha,err,error,*999)
      ELSE
        field=>fieldVariable%field
        IF(.NOT.ASSOCIATED(field)) THEN
          localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
            & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%variableType,"",err,error))// &
            & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
        ELSE
          localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
            & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%variableType,"",err,error))//"."
        ENDIF
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      field=>fieldVariable%field
      IF(.NOT.ASSOCIATED(field)) THEN
        localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
          & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%variableType,"",err,error))// &
          & " of field number "//TRIM(NumberToVString(field%userNumber,"*",err,error))//"."
      ELSE
        localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
          & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%variableType,"",err,error))//"."
      ENDIF
      CALL FlagError(localError,err,error,*999)      
    ENDIF

    EXITS("FieldVariable_ParameterSetsCopy")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetsCopy",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetsCopy

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type if they exist for a field variable 
  SUBROUTINE FieldVariable_ParameterSetsCopyIfExists(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field variable to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldParameterSetType), POINTER :: fromParameterSet,toParameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetsCopyIfExists",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    IF(parameterFromSetType<=0.OR.parameterFromSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(parameterToSetType<=0.OR.parameterToSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    fromParameterSet=>fieldVariable%parameterSets%setType(parameterFromSetType)%ptr
    IF(ASSOCIATED(fromParameterSet)) THEN
      toParameterSet=>fieldVariable%parameterSets%setType(parameterToSetType)%ptr
      IF(ASSOCIATED(toParameterSet)) THEN
        !Do not need to do an update here as each rank already has the values.
        CALL DistributedVector_Copy(fromParameterSet%parameters,toParameterSet%parameters,alpha,err,error,*999)
      ENDIF
    ENDIF

    EXITS("FieldVariable_ParameterSetsCopyIfExists")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetsCopyIfExists",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetsCopyIfExists

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type fieldSetType for a field variable if it does not already exist,
  !>otherwise it will do nothing.
  SUBROUTINE FieldVariable_ParameterSetEnsureCreated(fieldVariable,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FieldVariableType), POINTER :: fieldVariable !<A pointer to the field to create the parameter set for
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    LOGICAL :: parameterSetCreated

    ENTERS("FieldVariable_ParameterSetEnsureCreated",err,error,*999)

    CALL FieldVariable_ParameterSetCreated(fieldVariable,fieldSetType,parameterSetCreated,err,error,*999)
    IF(.NOT.parameterSetCreated) CALL FieldVariable_ParameterSetCreate(fieldVariable,fieldSetType,err,error,*999)

    EXITS("FieldVariable_ParameterSetEnsureCreated")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetEnsureCreated",err,error)
    RETURN 1
    
  END SUBROUTINE FieldVariable_ParameterSetEnsureCreated

  !
  !================================================================================================================================
  !

  !>Finalises the fields and deallocates all memory.
  SUBROUTINE FIELDS_FINALISE(FIELDS,err,error,*)

    !Argument variables
    TYPE(FieldsType), POINTER :: FIELDS !<A pointer to the fields to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FieldType), POINTER :: FIELD

    ENTERS("FIELDS_FINALISE",err,error,*999)

    IF(ASSOCIATED(FIELDS)) THEN
      DO WHILE(FIELDS%numberOfFields>0)
        FIELD=>FIELDS%FIELDS(1)%ptr
        CALL FIELD_DESTROY(FIELD,err,error,*999)
      ENDDO !field_idx
      DEALLOCATE(FIELDS)
    ENDIF

    EXITS("FIELDS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELDS_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE FIELDS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the fields.
  SUBROUTINE FIELDS_INITIALISE_GENERIC(fields,err,error,*)

    !Argument variables
    TYPE(FieldsType), POINTER :: FIELDS !<A pointer to the fields to initialise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELDS_INITIALISE_GENERIC",err,error,*999)

    IF(.NOT.ASSOCIATED(fields)) CALL FlagError("Fields is not associated.",err,error,*999)
    
    NULLIFY(fields%region)
    NULLIFY(fields%INTERFACE)
    fields%numberOfFields=0
    NULLIFY(fields%fields)

    EXITS("FIELDS_INITIALISE_GENERIC")
    RETURN
999 ERRORSEXITS("FIELDS_INITIALISE_GENERIC",err,error)
    RETURN 1
  END SUBROUTINE FIELDS_INITIALISE_GENERIC

  !
  !================================================================================================================================
  !

  !>Initialises the fields for the given interface.
  SUBROUTINE FIELDS_INITIALISE_INTERFACE(INTERFACE,err,error,*)

    !Argument variables
    TYPE(InterfaceType), POINTER :: INTERFACE !<A pointer to the interface to initialise the fields for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("FIELDS_INITIALISE_INTERFACE",err,error,*999)

    IF(ASSOCIATED(INTERFACE)) THEN
      IF(ASSOCIATED(INTERFACE%FIELDS)) THEN
        CALL FlagError("Interface already has fields associated.",err,error,*999)
      ELSE
        ALLOCATE(INTERFACE%FIELDS,STAT=err)
        IF(err/=0) CALL FlagError("Interface fields could not be allocated.",err,error,*999)
        CALL FIELDS_INITIALISE_GENERIC(INTERFACE%FIELDS,err,error,*999)
        INTERFACE%FIELDS%INTERFACE=>INTERFACE
        ENDIF
      ELSE
        CALL FlagError("Interface is not associated.",err,error,*999)
      ENDIF

      EXITS("FIELDS_INITIALISE_INTERFACE")
      RETURN
999   ERRORSEXITS("FIELDS_INITIALISE_INTERFACE",err,error)
      RETURN 1
    END SUBROUTINE FIELDS_INITIALISE_INTERFACE

    !
    !================================================================================================================================
    !

    !>Initialises the fields for the given region.
    SUBROUTINE FIELDS_INITIALISE_REGION(REGION,err,error,*)

      !Argument variables
      TYPE(RegionType), POINTER :: REGION !<A pointer to the region to initialise the fields for
      INTEGER(INTG), INTENT(OUT) :: err !<The error code
      TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
      !Local Variables

      ENTERS("FIELDS_INITIALISE_REGION",err,error,*999)

      IF(ASSOCIATED(REGION)) THEN
        IF(ASSOCIATED(REGION%FIELDS)) THEN
          CALL FlagError("Region already has fields associated.",err,error,*999)
        ELSE
          ALLOCATE(REGION%FIELDS,STAT=err)
          IF(err/=0) CALL FlagError("Region fields could not be allocated.",err,error,*999)
          CALL FIELDS_INITIALISE_GENERIC(REGION%FIELDS,err,error,*999)
          REGION%FIELDS%REGION=>REGION
        ENDIF
      ELSE
        CALL FlagError("Region is not associated.",err,error,*999)
      ENDIF

      EXITS("FIELDS_INITIALISE_REGION")
      RETURN
999   ERRORSEXITS("FIELDS_INITIALISE_REGION",err,error)
      RETURN 1
    END SUBROUTINE FIELDS_INITIALISE_REGION

    !
    !================================================================================================================================
    !

    !> Interpolates data from one field/mesh to another
    SUBROUTINE MESH_EMBEDDING_PUSH_DATA(MESH_EMBEDDING,PARENT_FIELD,PARENT_COMPONENT,CHILD_FIELD,CHILD_COMPONENT,err,error,*)
      TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: MESH_EMBEDDING !<The mesh embedding object
      INTEGER(INTG), INTENT(OUT) :: err              !<The error code
      TYPE(VARYING_STRING), INTENT(OUT) :: error     !<The error string
      TYPE(FieldType), POINTER :: PARENT_FIELD      !<Field for the parent nodes
      TYPE(FieldType), POINTER :: CHILD_FIELD       !<Field for the child nodes
      INTEGER(INTG), INTENT(IN) :: PARENT_COMPONENT  !<Component of the parent field, must be nodally based
      INTEGER(INTG), INTENT(IN) ::  CHILD_COMPONENT  !<Component of the child  field, must be nodally based

      !Local variables
      TYPE(MeshElementType), POINTER :: ELEMENT
      TYPE(BasisType), POINTER :: BASIS
      INTEGER(INTG) :: E,I,B,version
      REAL(DP) :: INTERP_VAL, WT
      REAL(DP),ALLOCATABLE :: PARENT_VALUES(:)

      ENTERS("MESH_EMBEDDING_PUSH_DATA",err,error,*999)

      version=1
      DO E=1,MESH_EMBEDDING%PARENT_MESH%numberOfElements
        ELEMENT=>MESH_EMBEDDING%PARENT_MESH%TOPOLOGY(1)%ptr%ELEMENTS%ELEMENTS(E)
        BASIS=>ELEMENT%BASIS
        ALLOCATE(PARENT_VALUES(BASIS%numberOfNodes))

        DO B=1,BASIS%numberOfNodes
          ! Version variable added and initialized above
          CALL FIELD_PARAMETER_SET_GET_NODE(PARENT_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,version,1,& ! TODO: FROM INPUT
            &  ELEMENT%globalElementNodes(B),PARENT_COMPONENT,PARENT_VALUES(B),err,error,*999)   ! global no?
        ENDDO


        DO I=1,MESH_EMBEDDING%CHILD_NODE_XI_POSITION(E)%NUMBER_OF_NODES
          INTERP_VAL = 0.0
          DO B=1,BASIS%numberOfNodes
            WT = BASIS_EVALUATE_XI(BASIS,B,NO_PART_DERIV,MESH_EMBEDDING%CHILD_NODE_XI_POSITION(E)%XI_COORDS(:,I),err,error)
            INTERP_VAL = INTERP_VAL + WT * PARENT_VALUES(B)
          ENDDO

          ! store in field
          ! Version variable added and initialized above
          CALL FIELD_PARAMETER_SET_UPDATE_NODE(CHILD_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,version,1,& ! TODO: FROM INPUT
            &  MESH_EMBEDDING%CHILD_NODE_XI_POSITION(E)%NODE_NUMBERS(I),CHILD_COMPONENT,INTERP_VAL,err,error,*999) 
        ENDDO
        DEALLOCATE(PARENT_VALUES)
      ENDDO

      EXITS("MESH_EMBEDDING_PUSH_DATA")
      RETURN
999   ERRORSEXITS("MESH_EMBEDDING_PUSH_DATA",err,error)
      RETURN 1

    END SUBROUTINE MESH_EMBEDDING_PUSH_DATA

    !  
    !================================================================================================================================
    !  

    SUBROUTINE MESH_EMBEDDING_PULL_GAUSS_POINT_DATA(MESH_EMBEDDING,PARENT_FIELD,PARENT_COMPONENT,CHILD_FIELD,CHILD_COMPONENT,&
      & err,error,*)

      TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: MESH_EMBEDDING !<The mesh embedding object
      INTEGER(INTG), INTENT(OUT) :: err              !<The error code
      TYPE(VARYING_STRING), INTENT(OUT) :: error     !<The error string
      TYPE(FieldType), POINTER :: PARENT_FIELD      !<Field for the parent nodes
      TYPE(FieldType), POINTER :: CHILD_FIELD       !<Field for the child nodes
      INTEGER(INTG), INTENT(IN) :: PARENT_COMPONENT  !<Component of the parent field, must be nodally based
      INTEGER(INTG), INTENT(IN) ::  CHILD_COMPONENT  !<Component of the child  field, must be nodally based

      !Local variables
      TYPE(MeshElementsType), POINTER :: ELEMENTS
      TYPE(MeshElementType), POINTER :: ELEMENT
      TYPE(BasisType), POINTER :: BASIS
      INTEGER(INTG) :: E,GP,B, NGP,version
      REAL(DP) :: INTERP_VAL, WT, VAL

      ENTERS("MESH_EMBEDDING_PULL_GAUSS_POINT_DATA",err,error,*999)

      ELEMENTS=>MESH_EMBEDDING%CHILD_MESH%TOPOLOGY(1)%ptr%ELEMENTS

      BASIS=>MESH_EMBEDDING%CHILD_MESH%TOPOLOGY(1)%ptr%ELEMENTS%ELEMENTS(1)%BASIS
      version = 1
      DO E=1,MESH_EMBEDDING%PARENT_MESH%numberOfElements    
        NGP = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%ptr%NUMBER_OF_GAUSS
        DO GP=1,NGP
          ELEMENT=>ELEMENTS%ELEMENTS(MESH_EMBEDDING%GAUSS_POINT_XI_POSITION(GP,E)%ELEMENT_NUMBER)
          BASIS=>ELEMENT%BASIS
          DO B=1,BASIS%numberOfNodes
            ! Version variable added and initialized above
            CALL FIELD_PARAMETER_SET_GET_NODE(CHILD_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,version,1,& ! TODO: FROM INPUT
              &  ELEMENT%globalElementNodes(B),CHILD_COMPONENT,VAL ,err,error,*999)   ! global no?
            WT = BASIS_EVALUATE_XI(BASIS,B,NO_PART_DERIV,MESH_EMBEDDING%GAUSS_POINT_XI_POSITION(GP,E)%CHILD_XI_COORD,err,error) 
            INTERP_VAL = INTERP_VAL + WT * VAL
          ENDDO
          ! store in gauss point parent field 
          CALL FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT(PARENT_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,GP,E,& ! TODO: var type/par set from input
            &  PARENT_COMPONENT, INTERP_VAL,err,error,*999) 
        ENDDO
      ENDDO

      EXITS("MESH_EMBEDDING_PULL_GAUSS_POINT_DATA")
      RETURN
999   ERRORSEXITS("MESH_EMBEDDING_PULL_GAUSS_POINT_DATA",err,error)
      RETURN 1
    END SUBROUTINE MESH_EMBEDDING_PULL_GAUSS_POINT_DATA

    !
    !================================================================================================================================
    !

    !>Returns from the given parameter set a double precision value for the specified gauss point of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetGaussPoint
    SUBROUTINE FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD(MESH_EMBEDDING,COMPONENT_NUMBER,NGP,COORD_VALUE, &
      & err,error,*)

      TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: MESH_EMBEDDING !<The mesh embedding object
      INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER  !<Component
      INTEGER(INTG), INTENT(OUT) :: NGP
      REAL(DP), INTENT(OUT) :: COORD_VALUE(:)
      INTEGER(INTG), INTENT(OUT) :: err              !<The error code
      TYPE(VARYING_STRING), INTENT(OUT) :: error     !<The error string

      !Local variables
      TYPE(MeshElementsType), POINTER :: ELEMENTS
      TYPE(BasisType), POINTER :: BASIS
      INTEGER(INTG) :: GP

      ENTERS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD",err,error,*999)

      ELEMENTS=>MESH_EMBEDDING%PARENT_MESH%TOPOLOGY(1)%ptr%ELEMENTS

      BASIS=>MESH_EMBEDDING%PARENT_MESH%TOPOLOGY(1)%ptr%ELEMENTS%ELEMENTS(1)%BASIS
      NGP = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%ptr%NUMBER_OF_GAUSS

      DO GP = 1,NGP
        COORD_VALUE(GP) = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%ptr%&
          &GAUSS_POSITIONS(COMPONENT_NUMBER,GP)
      ENDDO

      EXITS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD")
      RETURN
999   ERRORSEXITS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD",err,error)
      RETURN 1
    END SUBROUTINE FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD

    !
    !================================================================================================================================
    !

  END MODULE FIELD_ROUTINES
