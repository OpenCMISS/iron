!> \file 
!> \author Chris Bradley
!> \brief This module handles all solver routines.
!>
!> \section LICENSE 
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!> This module handles all solver routines.
MODULE SOLVER_ROUTINES

  USE BaseRoutines
  USE BOUNDARY_CONDITIONS_ROUTINES
#ifdef WITH_CELLML
  USE CELLML_MODEL_DEFINITION
#endif
  USE CMISS_CELLML
  USE CmissPetsc
  USE CmissPetscTypes
  USE ComputationEnvironment
  USE Constants
  USE ControlLoopAccessRoutines
  USE DistributedMatrixVector
  USE EquationsAccessRoutines
  USE EquationsMappingAccessRoutines
  USE EquationsMatricesAccessRoutines
  use EquationsSetAccessRoutines
  USE EquationsSetConstants
  USE FIELD_ROUTINES
  USE FieldAccessRoutines
  USE Kinds
  USE INPUT_OUTPUT
  USE INTERFACE_CONDITIONS_CONSTANTS
  USE InterfaceConditionAccessRoutines
  USE InterfaceEquationsAccessRoutines
  USE INTERFACE_MATRICES_CONSTANTS
  USE ISO_VARYING_STRING
  USE Maths
  USE PROBLEM_CONSTANTS
  USE ProfilingRoutines
  USE SolverAccessRoutines
  USE SOLVER_MAPPING_ROUTINES
  USE SolverMappingAccessRoutines
  USE SOLVER_MATRICES_ROUTINES
  USE SolverMatricesAccessRoutines
  USE Strings
  USE Timer
  USE Types

#include "macros.h"  

  IMPLICIT NONE

  PRIVATE

#include "petscversion.h"
 
  !Module parameters

  
  !Module types

  !Module variables

  !Interfaces

  INTERFACE

    SUBROUTINE SOLVER_DAE_EXTERNAL_INTEGRATE(NUMBER_OF_DOFS,START_TIME,END_TIME,INITIAL_STEP, &
      & ONLY_ONE_MODEL_INDEX,MODELS_DATA,NUMBER_OF_STATE,STATE_DATA,NUMBER_OF_PARAMETERS, &
      & PARAMETERS_DATA,NUMBER_OF_INTERMEDIATE,INTERMEDIATE_DATA,ERR) BIND(C, NAME="SolverDAEExternalIntegrate")
      
      USE ISO_C_BINDING

      INTEGER(C_INT), VALUE, INTENT(IN) :: NUMBER_OF_DOFS
      REAL(C_DOUBLE), VALUE, INTENT(IN) :: START_TIME
      REAL(C_DOUBLE), VALUE, INTENT(IN) :: END_TIME
      REAL(C_DOUBLE), INTENT(INOUT) :: INITIAL_STEP
      INTEGER(C_INT), VALUE, INTENT(IN) :: ONLY_ONE_MODEL_INDEX
      INTEGER(C_INT), INTENT(IN) :: MODELS_DATA(*)
      INTEGER(C_INT), VALUE, INTENT(IN) :: NUMBER_OF_STATE
      REAL(C_DOUBLE), INTENT(INOUT) :: STATE_DATA(*)
      INTEGER(C_INT), VALUE, INTENT(IN) :: NUMBER_OF_PARAMETERS
      REAL(C_DOUBLE), INTENT(IN) :: PARAMETERS_DATA(*)
      INTEGER(C_INT), VALUE, INTENT(IN) :: NUMBER_OF_INTERMEDIATE
      REAL(C_DOUBLE), INTENT(OUT) :: INTERMEDIATE_DATA(*)
      INTEGER(C_INT), INTENT(OUT) :: err
      
    END SUBROUTINE SOLVER_DAE_EXTERNAL_INTEGRATE
    
  END INTERFACE

  INTERFACE CellMLEquations_CreateFinish
    MODULE PROCEDURE CELLML_EQUATIONS_CREATE_FINISH
  END INTERFACE CellMLEquations_CreateFinish
  
  INTERFACE CellMLEquations_CreateStart
    MODULE PROCEDURE CELLML_EQUATIONS_CREATE_START
  END INTERFACE CellMLEquations_CreateStart

  INTERFACE Solver_DAETimesSet
    MODULE PROCEDURE SOLVER_DAE_TIMES_SET
  END INTERFACE Solver_DAETimesSet

   INTERFACE Solver_DAETimeStepSet
    MODULE PROCEDURE SOLVER_DAE_TIME_STEP_SET
  END INTERFACE Solver_DAETimeStepSet

  INTERFACE Solver_DynamicDegreeSet
    MODULE PROCEDURE SOLVER_DYNAMIC_DEGREE_SET
  END INTERFACE Solver_DynamicDegreeSet

  INTERFACE Solver_DynamicLinearityTypeSet
    MODULE PROCEDURE SOLVER_DYNAMIC_LINEARITY_TYPE_SET
  END INTERFACE Solver_DynamicLinearityTypeSet

  INTERFACE Solver_DynamicOrderSet
    MODULE PROCEDURE SOLVER_DYNAMIC_ORDER_SET
  END INTERFACE Solver_DynamicOrderSet

  INTERFACE Solver_DynamicSchemeSet
    MODULE PROCEDURE SOLVER_DYNAMIC_SCHEME_SET
  END INTERFACE Solver_DynamicSchemeSet

  INTERFACE SOLVER_DYNAMIC_THETA_SET
    MODULE PROCEDURE SOLVER_DYNAMIC_THETA_SET_DP1
    MODULE PROCEDURE SOLVER_DYNAMIC_THETA_SET_DP
  END INTERFACE SOLVER_DYNAMIC_THETA_SET

  INTERFACE Solver_DynamicThetaSet
    MODULE PROCEDURE SOLVER_DYNAMIC_THETA_SET_DP1
    MODULE PROCEDURE SOLVER_DYNAMIC_THETA_SET_DP
  END INTERFACE Solver_DynamicThetaSet

  INTERFACE SOLVER_LABEL_GET
    MODULE PROCEDURE SOLVER_LABEL_GET_C
    MODULE PROCEDURE SOLVER_LABEL_GET_VS
  END INTERFACE SOLVER_LABEL_GET
  
  INTERFACE Solver_LabelGet
    MODULE PROCEDURE SOLVER_LABEL_GET_C
    MODULE PROCEDURE SOLVER_LABEL_GET_VS
  END INTERFACE Solver_LabelGet
  
  INTERFACE SOLVER_LABEL_SET
    MODULE PROCEDURE SOLVER_LABEL_SET_C
    MODULE PROCEDURE SOLVER_LABEL_SET_VS
  END INTERFACE SOLVER_LABEL_SET
  
  INTERFACE Solver_LabelSet
    MODULE PROCEDURE SOLVER_LABEL_SET_C
    MODULE PROCEDURE SOLVER_LABEL_SET_VS
  END INTERFACE Solver_LabelSet

  INTERFACE Solver_LibraryTypeGet
    MODULE PROCEDURE SOLVER_LIBRARY_TYPE_GET
  END INTERFACE Solver_LibraryTypeGet

  INTERFACE Solver_LibraryTypeSet
    MODULE PROCEDURE SOLVER_LIBRARY_TYPE_SET
  END INTERFACE Solver_LibraryTypeSet

  INTERFACE Solver_NonlinearDivergenceExit
    MODULE PROCEDURE SOLVER_NONLINEAR_DIVERGENCE_EXIT
  END INTERFACE Solver_NonlinearDivergenceExit

  INTERFACE Solver_TypeSet
    MODULE PROCEDURE SOLVER_TYPE_SET
  END INTERFACE Solver_TypeSet

  INTERFACE SolverEquations_CreateFinish
    MODULE PROCEDURE SOLVER_EQUATIONS_CREATE_FINISH
  END INTERFACE SolverEquations_CreateFinish
  
  INTERFACE SolverEquations_CreateStart
    MODULE PROCEDURE SOLVER_EQUATIONS_CREATE_START
  END INTERFACE SolverEquations_CreateStart

  INTERFACE SolverEquations_Destroy
    MODULE PROCEDURE SOLVER_EQUATIONS_DESTROY
  END INTERFACE SolverEquations_Destroy
  
  INTERFACE SolverEquations_EquationsSetAdd
    MODULE PROCEDURE SOLVER_EQUATIONS_EQUATIONS_SET_ADD
  END INTERFACE SolverEquations_EquationsSetAdd
  
  INTERFACE SolverEquations_InterfaceConditionAdd
    MODULE PROCEDURE SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD
  END INTERFACE SolverEquations_InterfaceConditionAdd
  
  INTERFACE SolverEquations_LinearityTypeSet
    MODULE PROCEDURE SOLVER_EQUATIONS_LINEARITY_TYPE_SET
  END INTERFACE SolverEquations_LinearityTypeSet
  
  INTERFACE SolverEquations_SparsityTypeSet
    MODULE PROCEDURE SOLVER_EQUATIONS_SPARSITY_TYPE_SET
  END INTERFACE SolverEquations_SparsityTypeSet
  
  INTERFACE SolverEquations_TimeDependenceTypeSet
    MODULE PROCEDURE SOLVER_EQUATIONS_TIME_DEPENDENCE_TYPE_SET
  END INTERFACE SolverEquations_TimeDependenceTypeSet
  
  INTERFACE Solvers_CreateStart
    MODULE PROCEDURE SOLVERS_CREATE_START
  END INTERFACE Solvers_CreateStart
  
  INTERFACE Solvers_CreateFinish
    MODULE PROCEDURE SOLVERS_CREATE_FINISH
  END INTERFACE Solvers_CreateFinish
  
  INTERFACE Solvers_NumberSet
    MODULE PROCEDURE SOLVERS_NUMBER_SET
  END INTERFACE Solvers_NumberSet
  
  PUBLIC CELLML_EQUATIONS_CELLML_ADD

  PUBLIC CELLML_EQUATIONS_CREATE_FINISH,CELLML_EQUATIONS_CREATE_START

  PUBLIC CellMLEquations_CreateStart,CellMLEquations_CreateFinish

  PUBLIC CELLML_EQUATIONS_DESTROY
  
  PUBLIC CellMLEquations_LinearityTypeGet,CellMLEquations_LinearityTypeSet

  PUBLIC CellMLEquations_TimeDependenceTypeGet,CellMLEquations_TimeDependenceTypeSet

  PUBLIC CellMLEquations_TimeGet,CellMLEquations_TimeSet
  
  PUBLIC SOLVER_DAE_SOLVER_TYPE_GET,SOLVER_DAE_SOLVER_TYPE_SET

  PUBLIC Solver_DAETimesSet,Solver_DAETimeStepSet

  PUBLIC SOLVER_DAE_TIMES_SET,SOLVER_DAE_TIME_STEP_SET
  
  PUBLIC SOLVER_DAE_EULER_SOLVER_TYPE_GET,SOLVER_DAE_EULER_SOLVER_TYPE_SET

  PUBLIC Solver_DAECellMLRHSEvaluate
  
  PUBLIC Solver_Destroy
  
  PUBLIC SOLVER_DYNAMIC_DEGREE_GET,SOLVER_DYNAMIC_DEGREE_SET

  PUBLIC Solver_DynamicDegreeSet

  PUBLIC SOLVER_DYNAMIC_LINEAR_SOLVER_GET,SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET

  PUBLIC SOLVER_DYNAMIC_LINEARITY_TYPE_GET,SOLVER_DYNAMIC_LINEARITY_TYPE_SET

  PUBLIC Solver_DynamicLinearityTypeSet
  
  PUBLIC SOLVER_DYNAMIC_ORDER_SET

  PUBLIC Solver_DynamicOrderSet

  PUBLIC SOLVER_DYNAMIC_SCHEME_SET

  PUBLIC Solver_DynamicSchemeSet

  PUBLIC SOLVER_DYNAMIC_RESTART_GET,SOLVER_DYNAMIC_RESTART_SET

  PUBLIC SOLVER_DYNAMIC_THETA_SET

  PUBLIC Solver_DynamicThetaSet

  PUBLIC SOLVER_DYNAMIC_ALE_SET

  PUBLIC SOLVER_DYNAMIC_UPDATE_BC_SET

  PUBLIC SOLVER_DYNAMIC_TIMES_SET

  PUBLIC SolverEquations_BoundaryConditionsCreateFinish,SolverEquations_BoundaryConditionsCreateStart

  PUBLIC SOLVER_EQUATIONS_CREATE_FINISH,SOLVER_EQUATIONS_CREATE_START

  PUBLIC SolverEquations_CreateFinish,SolverEquations_CreateStart

  PUBLIC SOLVER_EQUATIONS_DESTROY

  PUBLIC SolverEquations_Destroy
  
  PUBLIC SOLVER_EQUATIONS_EQUATIONS_SET_ADD

  PUBLIC SolverEquations_EquationsSetAdd

  PUBLIC SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD

  PUBLIC SolverEquations_InterfaceConditionAdd

  PUBLIC SOLVER_EQUATIONS_LINEARITY_TYPE_SET

  PUBLIC SolverEquations_LinearityTypeSet

  PUBLIC SOLVER_EQUATIONS_SPARSITY_TYPE_SET

  PUBLIC SolverEquations_SparsityTypeSet

  PUBLIC SolverEquations_SymmetryTypeGet,SolverEquations_SymmetryTypeSet

  PUBLIC SOLVER_EQUATIONS_TIME_DEPENDENCE_TYPE_SET

  PUBLIC SolverEquations_TimeDependenceTypeSet

  PUBLIC SolverEquations_NumberOfMatricesGet

  PUBLIC SolverEquations_MatrixGet

  PUBLIC SolverEquations_JacobianMatrixGet

  PUBLIC SolverEquations_VectorGet

  PUBLIC SolverEquations_ResidualVectorGet

  PUBLIC SolverEquations_RhsVectorGet

  PUBLIC SOLVER_LABEL_GET,SOLVER_LABEL_SET

  PUBLIC Solver_LabelGet,Solver_LabelSet
  
  PUBLIC SOLVER_LIBRARY_TYPE_GET,SOLVER_LIBRARY_TYPE_SET

  PUBLIC Solver_LibraryTypeGet,Solver_LibraryTypeSet

  PUBLIC SOLVER_LINEAR_TYPE_SET
  
  PUBLIC SOLVER_LINEAR_DIRECT_TYPE_SET

  PUBLIC Solver_MumpsSetIcntl,Solver_MumpsSetCntl

  PUBLIC Solver_LinearIterativeAbsoluteToleranceSet

  PUBLIC Solver_LinearIterativeDivergenceToleranceSet
  
  PUBLIC SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET

  PUBLIC Solver_LinearIterativeMaximumIterationsSet

  PUBLIC Solver_LinearIterativePreconditionerTypeSet

  PUBLIC Solver_LinearIterativeRelativeToleranceSet
  
  PUBLIC Solver_LinearIterativeSolutionInitTypeSet

  PUBLIC SOLVER_LINEAR_ITERATIVE_TYPE_SET
  
  PUBLIC Solver_GeometricTransformationArbitraryPathSet,Solver_GeometricTransformationClear
  
  PUBLIC Solver_GeometricTransformationNumberOfLoadIncrementsSet
  
  PUBLIC Solver_GeometricTransformationScalingsSet
  
  PUBLIC Solver_GeometricTransformationFieldSet
  
  PUBLIC Solver_GeometricTransformationMatrixSet
  
  PUBLIC Solver_GeometricTransformationRotationSet,Solver_GeometricTransformationTranslationSet

  PUBLIC Solver_DynamicAssemble,Solver_StaticAssemble

  PUBLIC SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET

  PUBLIC Solver_QuasiNewtonLineSearchMonitorOutputSet

  PUBLIC SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET

  PUBLIC Solver_QuasiNewtonJacobianCalculationTypeSet
  
  PUBLIC SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET

  PUBLIC SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET

  PUBLIC Solver_QuasiNewtonConvergenceTestTypeSet

  PUBLIC SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET

  PUBLIC SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET

  PUBLIC SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET

  PUBLIC Solver_QuasiNewtonMaximumFunctionEvaluationsSet

  PUBLIC SOLVER_QUASI_NEWTON_SOLUTION_INIT_TYPE_SET

  PUBLIC SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET
  
  PUBLIC SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET

  PUBLIC SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET

  PUBLIC Solver_QuasiNewtonTrustRegionToleranceSet

  PUBLIC SOLVER_QUASI_NEWTON_TYPE_SET

  PUBLIC SOLVER_QUASI_NEWTON_RESTART_SET

  PUBLIC SOLVER_QUASI_NEWTON_RESTART_TYPE_SET

  PUBLIC SOLVER_QUASI_NEWTON_SCALE_TYPE_SET

  PUBLIC SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET

  PUBLIC SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET

  PUBLIC Solver_NewtonLineSearchMonitorOutputSet

  PUBLIC SOLVER_NEWTON_LINESEARCH_ALPHA_SET

  PUBLIC SOLVER_NEWTON_LINESEARCH_TYPE_SET

  PUBLIC SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET
  
  PUBLIC SOLVER_NEWTON_LINEAR_SOLVER_GET

  PUBLIC SOLVER_NEWTON_CELLML_SOLVER_GET

  PUBLIC Solver_NewtonConvergenceTestTypeSet

  PUBLIC SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET

  PUBLIC SOLVER_NEWTON_LINESEARCH_STEPTOL_SET

  PUBLIC SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET

  PUBLIC Solver_NewtonMaximumFunctionEvaluationsSet

  PUBLIC SOLVER_NEWTON_SOLUTION_INIT_TYPE_SET

  PUBLIC SOLVER_NEWTON_SOLUTION_TOLERANCE_SET
  
  PUBLIC SOLVER_NEWTON_RELATIVE_TOLERANCE_SET

  PUBLIC SOLVER_NEWTON_TRUSTREGION_DELTA0_SET

  PUBLIC SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET

  PUBLIC SOLVER_NEWTON_TYPE_SET

  PUBLIC SOLVER_NONLINEAR_DIVERGENCE_EXIT,SOLVER_NONLINEAR_MONITOR

  PUBLIC Solver_NonlinearDivergenceExit

  PUBLIC SOLVER_NONLINEAR_TYPE_SET

  PUBLIC Solver_OptimiserMonitor
  
  PUBLIC SOLVER_OUTPUT_TYPE_SET
  
  PUBLIC Solver_Solve
  
  PUBLIC SOLVER_SOLVER_EQUATIONS_GET

  PUBLIC Solver_SolverEquationsGet

  PUBLIC SOLVER_TIME_STEPPING_MONITOR
  
  PUBLIC SOLVER_TYPE_SET

  PUBLIC Solver_TypeSet

  PUBLIC Solver_VariablesDynamicFieldUpdate

  PUBLIC Solver_VariablesDynamicFieldPreviousValuesUpdate

  PUBLIC Solver_VariablesDynamicNonlinearUpdate

  PUBLIC SOLVER_VARIABLES_FIELD_UPDATE

  PUBLIC SOLVERS_CREATE_FINISH,SOLVERS_CREATE_START

  PUBLIC Solvers_CreateFinish,Solvers_CreateStart

  PUBLIC Solvers_Destroy

  PUBLIC SOLVERS_NUMBER_SET

  PUBLIC Solvers_NumberSet

  PUBLIC SOLVER_NEWTON_CELLML_EVALUATOR_CREATE,SOLVER_CELLML_EVALUATOR_FINALISE

  PUBLIC SOLVER_LINKED_SOLVER_ADD,SOLVER_LINKED_SOLVER_REMOVE
  
  PUBLIC SOLVER_SOLUTION_UPDATE

CONTAINS

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to a solvers CellML equations. \see OpenCMISS::Iron::cmfe_CellMLEquationsCellMLAdd
  SUBROUTINE CELLML_EQUATIONS_CELLML_ADD(CELLML_EQUATIONS,CELLML,CELLML_INDEX,err,error,*)

    !Argument variables
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS !<A pointer the CellML equations to add the CellML environment to.
    TYPE(CELLML_TYPE), POINTER :: CELLML !<A pointer to the CellML environment to add
    INTEGER(INTG), INTENT(OUT) :: CELLML_INDEX !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: cellml_idx
    TYPE(CELLML_PTR_TYPE), ALLOCATABLE :: NEW_CELLML_ENVIRONMENTS(:)
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    
    ENTERS("CELLML_EQUATIONS_CELLML_ADD",err,error,*999)

    IF(ASSOCIATED(CELLML_EQUATIONS)) THEN
      IF(CELLML_EQUATIONS%CELLML_EQUATIONS_FINISHED) THEN
        CALL FlagError("CellML equations has already been finished.",err,error,*999)
      ELSE
        SOLVER=>CELLML_EQUATIONS%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          IF(ASSOCIATED(CELLML)) THEN
            IF(CELLML%CELLML_FINISHED) THEN
              ALLOCATE(NEW_CELLML_ENVIRONMENTS(CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS+1),STAT=err)
              IF(err/=0) CALL FlagError("Could not allocate new CellML environments.",err,error,*999)
              DO cellml_idx=1,CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS
                NEW_CELLML_ENVIRONMENTS(cellml_idx)%ptr=>CELLML_EQUATIONS%CELLML_ENVIRONMENTS(cellml_idx)%ptr
              ENDDO !cellml_idx
              NEW_CELLML_ENVIRONMENTS(CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS+1)%ptr=>CELLML
              CALL MOVE_ALLOC(NEW_CELLML_ENVIRONMENTS,CELLML_EQUATIONS%CELLML_ENVIRONMENTS)
              CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS=CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS+1
              CELLML_INDEX=CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS
            ELSE
              CALL FlagError("CellML environment has not been finished.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("CellML environment is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("CellML equations solver is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("CellML equations is not associated.",err,error,*999)
    ENDIF
        
    EXITS("CELLML_EQUATIONS_CELLML_ADD")
    RETURN
999 IF(ALLOCATED(NEW_CELLML_ENVIRONMENTS)) DEALLOCATE(NEW_CELLML_ENVIRONMENTS)
    ERRORSEXITS("CELLML_EQUATIONS_CELLML_ADD",err,error)
    RETURN 1
   
  END SUBROUTINE CELLML_EQUATIONS_CELLML_ADD
        
  !
  !================================================================================================================================
  !

  !>Finishes the process of creating CellML equations
  SUBROUTINE CELLML_EQUATIONS_CREATE_FINISH(CELLML_EQUATIONS,err,error,*)

    !Argument variables
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS !<A pointer the CellML equations to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER

    ENTERS("CELLML_EQUATIONS_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(CELLML_EQUATIONS)) THEN
      IF(CELLML_EQUATIONS%CELLML_EQUATIONS_FINISHED) THEN
        CALL FlagError("CellML equations has already been finished.",err,error,*999)
      ELSE
        SOLVER=>CELLML_EQUATIONS%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          CELLML_EQUATIONS%CELLML_EQUATIONS_FINISHED=.TRUE.
        ELSE
          CALL FlagError("CellML equations solver is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("CellML equations is not associated.",err,error,*999)
    ENDIF
        
    EXITS("CELLML_EQUATIONS_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("CELLML_EQUATIONS_CREATE_FINISH",err,error)
    RETURN 1
   
  END SUBROUTINE CELLML_EQUATIONS_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Starts the process of creating CellML equations
  SUBROUTINE CELLML_EQUATIONS_CREATE_START(SOLVER,CELLML_EQUATIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to start the creation of CellML equations on
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS !<On return, A pointer the CellML equations. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("CELLML_EQUATIONS_CREATE_START",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(CELLML_EQUATIONS)) THEN
        CALL FlagError("CellML equations is already associated.",err,error,*999)
      ELSE
        NULLIFY(CELLML_EQUATIONS)
        CALL CELLML_EQUATIONS_INITIALISE(SOLVER,err,error,*999)
        CELLML_EQUATIONS=>SOLVER%CELLML_EQUATIONS
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("CELLML_EQUATIONS_CREATE_START")
    RETURN
999 ERRORSEXITS("CELLML_EQUATIONS_CREATE_START",err,error)
    RETURN 1
   
  END SUBROUTINE CELLML_EQUATIONS_CREATE_START
        
  !
  !================================================================================================================================
  !

  !>Destroys the CellML equations
  SUBROUTINE CELLML_EQUATIONS_DESTROY(CELLML_EQUATIONS,err,error,*)

    !Argument variables
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS !<A pointer the CellML equations to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("CELLML_EQUATIONS_DESTROY",err,error,*999)

    IF(ASSOCIATED(CELLML_EQUATIONS)) THEN
      CALL CELLML_EQUATIONS_FINALISE(CELLML_EQUATIONS,err,error,*999)
    ELSE
      CALL FlagError("CellML equations is not associated.",err,error,*999)
    ENDIF
        
    EXITS("CELLML_EQUATIONS_DESTROY")
    RETURN
999 ERRORSEXITS("CELLML_EQUATIONS_DESTROY",err,error)
    RETURN 1
   
  END SUBROUTINE CELLML_EQUATIONS_DESTROY
        
  !
  !================================================================================================================================
  !

  !>Finalises the CellML equations and deallocates all memory.
  SUBROUTINE CELLML_EQUATIONS_FINALISE(CELLML_EQUATIONS,err,error,*)

    !Argument variables
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS !<A pointer the CellML equations to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("CELLML_EQUATIONS_FINALISE",err,error,*999)

    IF(ASSOCIATED(CELLML_EQUATIONS)) THEN
      IF(ALLOCATED(CELLML_EQUATIONS%CELLML_ENVIRONMENTS)) DEALLOCATE(CELLML_EQUATIONS%CELLML_ENVIRONMENTS)
      DEALLOCATE(CELLML_EQUATIONS)
    ENDIF
        
    EXITS("CELLML_EQUATIONS_FINALISE")
    RETURN
999 ERRORSEXITS("CELLML_EQUATIONS_FINALISE",err,error)
    RETURN 1
    
  END SUBROUTINE CELLML_EQUATIONS_FINALISE
        
  !
  !================================================================================================================================
  !

  !>Initialises the CellML equations for a solver.
  SUBROUTINE CELLML_EQUATIONS_INITIALISE(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to initialise the CellML equations for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("CELLML_EQUATIONS_INITIALISE",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(SOLVER%CELLML_EQUATIONS)) THEN
        CALL FlagError("CellML equations is already associated for this solver.",err,error,*998)
      ELSE
        ALLOCATE(SOLVER%CELLML_EQUATIONS,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate CellML equations.",err,error,*999)
        SOLVER%CELLML_EQUATIONS%SOLVER=>SOLVER
        SOLVER%CELLML_EQUATIONS%CELLML_EQUATIONS_FINISHED=.FALSE.
        SOLVER%CELLML_EQUATIONS%linearity=CELLML_EQUATIONS_LINEAR
        SOLVER%CELLML_EQUATIONS%timeDependence=CELLML_EQUATIONS_STATIC
        solver%CELLML_EQUATIONS%currentTime=0.0_DP
        SOLVER%CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS=0
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("CELLML_EQUATIONS_INITIALISE")
    RETURN
999 CALL CELLML_EQUATIONS_FINALISE(SOLVER%CELLML_EQUATIONS,dummyErr,dummyError,*998)
998 ERRORSEXITS("CELLML_EQUATIONS_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE CELLML_EQUATIONS_INITIALISE
        
  !
  !================================================================================================================================
  !

  !>Returns the linearity type for CellML equations
  SUBROUTINE CellMLEquations_LinearityTypeGet(cellMLEquations,linearityType,err,error,*)

    !Argument variables
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: cellMLEquations !<A pointer the CellML equations to get the linearity type for
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On exit, the type of linearity of the CellML equations \see PROBLEM_CONSTANTS_CellMLEquationLinearityTypes,PROBLEM_CONSTANTS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    
    ENTERS("CellMLEquations_LinearityTypeGet",err,error,*999)

    IF(.NOT.ASSOCIATED(cellMLEquations)) CALL FlagError("CellML equations is not associated.",err,error,*999)
    IF(.NOT.cellMLEquations%CELLML_EQUATIONS_FINISHED) CALL FlagError("CellML equations have not been finished.",err,error,*999)
   
    linearityType=cellMLEquations%linearity
   
    EXITS("CellMLEquations_LinearityTypeGet")
    RETURN
999 ERRORSEXITS("CellMLEquations_LinearityTypeGet",err,error)
    RETURN 1
   
  END SUBROUTINE CellMLEquations_LinearityTypeGet
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the linearity type for CellML equations
  SUBROUTINE CellMLEquations_LinearityTypeSet(cellMLEquations,linearityType,err,error,*)

    !Argument variables
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: cellMLEquations !<A pointer the CellML equations to set the linearity type for
    INTEGER(INTG), INTENT(IN) :: linearityType !<The type of linearity to be set \see PROBLEM_CONSTANTS_CellMLEquationLinearityTypes,PROBLEM_CONSTANTS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("CellMLEquations_LinearityTypeSet",err,error,*999)

    IF(.NOT.ASSOCIATED(cellMLEquations)) CALL FlagError("CellML equations is not associated.",err,error,*999)
    IF(cellMLEquations%CELLML_EQUATIONS_FINISHED) CALL FlagError("CellML equations has already been finished.",err,error,*999)
   
    SELECT CASE(linearityType)
    CASE(CELLML_EQUATIONS_LINEAR)
      cellMLEquations%linearity=CELLML_EQUATIONS_LINEAR
    CASE(CELLML_EQUATIONS_NONLINEAR)
      cellMLEquations%linearity=CELLML_EQUATIONS_NONLINEAR
    CASE DEFAULT
      localError="The specified CellML equations linearity type of "// &
        & TRIM(NumberToVString(linearityType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
   
    EXITS("CellMLEquations_LinearityTypeSet")
    RETURN
999 ERRORSEXITS("CellMLEquations_LinearityTypeSet",err,error)
    RETURN 1
   
  END SUBROUTINE CellMLEquations_LinearityTypeSet
        
  !
  !================================================================================================================================
  !

  !>Returns the time dependence type for CellML equations
  SUBROUTINE CellMLEquations_TimeDependenceTypeGet(cellMLEquations,timeDependenceType,err,error,*)

    !Argument variables
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: cellMLEquations !<A pointer the CellML equations to get the time dependence type for
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On exit, the type of time dependence of the CellML equations \see PROBLEM_CONSTANTS_CellMLEquationTimeDependenceTypes,PROBLEM_CONSTANTS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    
    ENTERS("CellMLEquations_TimeDependenceTypeGet",err,error,*999)

    IF(.NOT.ASSOCIATED(cellMLEquations)) CALL FlagError("CellML equations is not associated.",err,error,*999)
    IF(.NOT.cellMLEquations%CELLML_EQUATIONS_FINISHED) CALL FlagError("CellML equations has not been finished.",err,error,*999)
   
    timeDependenceType=cellMLEquations%timeDependence
   
    EXITS("CellMLEquations_TimeDependenceTypeGet")
    RETURN
999 ERRORSEXITS("CellMLEquations_TimeDependenceTypeGet",err,error)
    RETURN 1
   
  END SUBROUTINE CellMLEquations_TimeDependenceTypeGet
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the time dependence type for CellML equations
  SUBROUTINE CellMLEquations_TimeDependenceTypeSet(cellMLEquations,timeDependenceType,err,error,*)

    !Argument variables
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: cellMLEquations !<A pointer the CellML equations to set the time dependence type for
    INTEGER(INTG), INTENT(IN) :: timeDependenceType !<The type of time dependence to be set \see PROBLEM_CONSTANTS_CellMLEquationTimeDependenceTypes,PROBLEM_CONSTANTS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("CellMLEquations_TimeDependenceTypeSet",err,error,*999)

    IF(.NOT.ASSOCIATED(cellMLEquations)) CALL FlagError("CellML equations is not associated.",err,error,*999)
    IF(cellMLEquations%CELLML_EQUATIONS_FINISHED) CALL FlagError("CellML equations has already been finished.",err,error,*999)
   
    SELECT CASE(timeDependenceType)
    CASE(CELLML_EQUATIONS_STATIC)
      cellMLEquations%timeDependence=CELLML_EQUATIONS_STATIC
    CASE(CELLML_EQUATIONS_QUASISTATIC)
      cellMLEquations%timeDependence=CELLML_EQUATIONS_QUASISTATIC
    CASE(CELLML_EQUATIONS_DYNAMIC)
      cellMLEquations%timeDependence=CELLML_EQUATIONS_DYNAMIC
    CASE DEFAULT
      localError="The specified CellML equations time dependence type of "// &
        & TRIM(NumberToVString(timeDependenceType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
   
    EXITS("CellMLEquations_TimeDependenceTypeSet")
    RETURN
999 ERRORSEXITS("CellMLEquations_TimeDependenceTypeSet",err,error)
    RETURN 1
   
  END SUBROUTINE CellMLEquations_TimeDependenceTypeSet
        
  !
  !================================================================================================================================
  !

  !>Returns the curent time for CellML equations.
  SUBROUTINE CellMLEquations_TimeGet(cellMLEquations,time,err,error,*)

    !Argument variables
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: cellMLEquations !<A pointer the CellML equations to get the time for.
    REAL(DP), INTENT(OUT) :: time !<On exit, the time for the CellML equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
 
    ENTERS("CellMLEquations_TimeGet",err,error,*999)

    IF(.NOT.ASSOCIATED(cellMLEquations)) CALL FlagError("CellML evaluator solver is not associated.",err,error,*999)
    
    time=cellMLEquations%currentTime
   
    EXITS("CellMLEquations_TimeGet")
    RETURN
999 ERRORSEXITS("CellMLEquations_TimeGet",err,error)
    RETURN 1
   
  END SUBROUTINE CellMLEquations_TimeGet

  !
  !================================================================================================================================
  !

  !>Sets/changes the current time for CellML equations.
  SUBROUTINE CellMLEquations_TimeSet(cellMLEquations,time,err,error,*)

    !Argument variables
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: cellMLEquations !<A pointer the CellML equations to set the time for.
    REAL(DP), INTENT(IN) :: time !<The time for the CellML equations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string

    ENTERS("CellMLEquations_TimeSet",err,error,*999)
    
    IF(.NOT.ASSOCIATED(cellMLEquations)) CALL FlagError("CellML evaluator solver is not associated.",err,error,*999)

    cellMLEquations%currentTime=time
         
    EXITS("CellMLEquations_TimeSet")
    RETURN
999 ERRORSEXITS("CellMLEquations_TimeSet",err,error)
    RETURN 1
   
  END SUBROUTINE CellMLEquations_TimeSet

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a CellML evaluator solver 
  SUBROUTINE SOLVER_CELLML_EVALUATOR_CREATE_FINISH(CELLML_EVALUATOR_SOLVER,err,error,*)

    !Argument variables
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: CELLML_EVALUATOR_SOLVER !<A pointer to the CellML evaluator solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_CELLML_EVALUATOR_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(CELLML_EVALUATOR_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("CellML evaluastor solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_CELLML_EVALUATOR_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_CELLML_EVALUATOR_CREATE_FINISH",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_CELLML_EVALUATOR_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Finalise a CellML evaluator solver.
  SUBROUTINE SOLVER_CELLML_EVALUATOR_FINALISE(CELLML_EVALUATOR_SOLVER,err,error,*)

    !Argument variables
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: CELLML_EVALUATOR_SOLVER !<A pointer the CellML evaluator solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_CELLML_EVALUATOR_FINALISE",err,error,*999)

    IF(ASSOCIATED(CELLML_EVALUATOR_SOLVER)) THEN        
      DEALLOCATE(CELLML_EVALUATOR_SOLVER)
    ENDIF
         
    EXITS("SOLVER_CELLML_EVALUATOR_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_CELLML_EVALUATOR_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_CELLML_EVALUATOR_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a CellML evaluator solver for a solver.
  SUBROUTINE SOLVER_CELLML_EVALUATOR_INITIALISE(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to initialise the CellML evaluator solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("SOLVER_CELLML_EVALUATOR_INITIALISE",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(SOLVER%CELLML_EVALUATOR_SOLVER)) THEN
        CALL FlagError("CellML evaluator solver is already associated for this solver.",err,error,*998)
      ELSE
        ALLOCATE(SOLVER%CELLML_EVALUATOR_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate solver CellML evaluator solver.",err,error,*999)
        SOLVER%CELLML_EVALUATOR_SOLVER%SOLVER=>SOLVER
        SOLVER%CELLML_EVALUATOR_SOLVER%SOLVER_LIBRARY=SOLVER_CMISS_LIBRARY
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_CELLML_EVALUATOR_INITIALISE")
    RETURN
999 CALL SOLVER_CELLML_EVALUATOR_FINALISE(SOLVER%CELLML_EVALUATOR_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_CELLML_EVALUATOR_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_CELLML_EVALUATOR_INITIALISE

  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for a CellML evaluator solver.
  SUBROUTINE SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_GET(CELLML_EVALUATOR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: CELLML_EVALUATOR_SOLVER !<A pointer the CellML evaluator solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On exit, the type of library used for the CellML evaluator solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
 
    ENTERS("SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(CELLML_EVALUATOR_SOLVER)) THEN
      SOLVER_LIBRARY_TYPE=CELLML_EVALUATOR_SOLVER%SOLVER_LIBRARY
    ELSE
      CALL FlagError("CellML evaluator solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for a CellML evaluator solver.
  SUBROUTINE SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_SET(CELLML_EVALUATOR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: CELLML_EVALUATOR_SOLVER !<A pointer the CellML evaluator solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library for the CellML evaluator solver to set. \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_SET",err,error,*999)
    
    IF(ASSOCIATED(CELLML_EVALUATOR_SOLVER)) THEN
      SELECT CASE(SOLVER_LIBRARY_TYPE)
      CASE(SOLVER_CMISS_LIBRARY)
        CELLML_EVALUATOR_SOLVER%SOLVER_LIBRARY=SOLVER_CMISS_LIBRARY
      CASE DEFAULT
        localError="The specified solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
          & " is invalid for a CellML evaluator solver."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("CellML evaluator solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Solve a CellML evaluator solver
  SUBROUTINE SOLVER_CELLML_EVALUATOR_SOLVE(CELLML_EVALUATOR_SOLVER,err,error,*)

    !Argument variables
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: CELLML_EVALUATOR_SOLVER !<A pointer the CellML evaluator solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: cellml_idx
    INTEGER(INTG), POINTER :: MODELS_DATA(:)
    REAL(DP) :: time
    REAL(DP), POINTER :: INTERMEDIATE_DATA(:),PARAMETERS_DATA(:),STATE_DATA(:)
    TYPE(CELLML_TYPE), POINTER :: CELLML_ENVIRONMENT
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: CELLML_MODELS_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: MODELS_VARIABLE
    TYPE(FIELD_TYPE), POINTER :: MODELS_FIELD,STATE_FIELD,PARAMETERS_FIELD,INTERMEDIATE_FIELD
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_CELLML_EVALUATOR_SOLVE",err,error,*999)

    NULLIFY(MODELS_DATA)
    NULLIFY(INTERMEDIATE_DATA)
    NULLIFY(PARAMETERS_DATA)
    NULLIFY(STATE_DATA)

    NULLIFY(MODELS_VARIABLE)
    NULLIFY(STATE_FIELD)
    NULLIFY(PARAMETERS_FIELD)
    NULLIFY(INTERMEDIATE_FIELD)

    IF(ASSOCIATED(CELLML_EVALUATOR_SOLVER)) THEN        
      SOLVER=>CELLML_EVALUATOR_SOLVER%SOLVER
      IF(ASSOCIATED(SOLVER)) THEN
        CELLML_EQUATIONS=>SOLVER%CELLML_EQUATIONS
        IF(ASSOCIATED(CELLML_EQUATIONS)) THEN
          time=CELLML_EQUATIONS%currentTime
          DO cellml_idx=1,CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS
            CELLML_ENVIRONMENT=>CELLML_EQUATIONS%CELLML_ENVIRONMENTS(cellml_idx)%ptr
            IF(ASSOCIATED(CELLML_ENVIRONMENT)) THEN                  
              CELLML_MODELS_FIELD=>CELLML_ENVIRONMENT%MODELS_FIELD
              IF(ASSOCIATED(CELLML_MODELS_FIELD)) THEN
                MODELS_FIELD=>CELLML_MODELS_FIELD%MODELS_FIELD
                IF(ASSOCIATED(MODELS_FIELD)) THEN

!!TODO: Maybe move this getting of fields earlier up the DAE solver chain? For now keep here.
                      
                  !Make sure CellML fields have been updated to the current value of any mapped fields
                  CALL CELLML_FIELD_TO_CELLML_UPDATE(CELLML_ENVIRONMENT,err,error,*999)

                  CALL Field_VariableGet(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,MODELS_VARIABLE,err,error,*999)
                  CALL Field_ParameterSetDataGet(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                    & MODELS_DATA,err,error,*999)
                      
                  !Get the state information if this environment has any.
                  IF(ASSOCIATED(CELLML_ENVIRONMENT%STATE_FIELD)) THEN
                    STATE_FIELD=>CELLML_ENVIRONMENT%STATE_FIELD%STATE_FIELD
                    IF(ASSOCIATED(STATE_FIELD)) THEN
                      CALL Field_ParameterSetDataGet(STATE_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                        & STATE_DATA,err,error,*999)
                    ENDIF
                  ENDIF
                      
                  !Get the parameters information if this environment has any.
                  IF(ASSOCIATED(CELLML_ENVIRONMENT%PARAMETERS_FIELD)) THEN
                    PARAMETERS_FIELD=>CELLML_ENVIRONMENT%PARAMETERS_FIELD%PARAMETERS_FIELD
                    IF(ASSOCIATED(PARAMETERS_FIELD)) THEN
                      CALL Field_ParameterSetDataGet(PARAMETERS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                        & PARAMETERS_DATA,err,error,*999)
                    ENDIF
                  ENDIF
                      
                  !Get the intermediate information if this environment has any.
                  IF(ASSOCIATED(CELLML_ENVIRONMENT%INTERMEDIATE_FIELD)) THEN
                    INTERMEDIATE_FIELD=>CELLML_ENVIRONMENT%INTERMEDIATE_FIELD%INTERMEDIATE_FIELD
                    IF(ASSOCIATED(INTERMEDIATE_FIELD)) THEN
                      CALL Field_ParameterSetDataGet(INTERMEDIATE_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                        & INTERMEDIATE_DATA,err,error,*999)                            
                    ENDIF
                  ENDIF

                  !Solve these CellML equations
                  SELECT CASE(CELLML_EVALUATOR_SOLVER%SOLVER_LIBRARY)
                  CASE(SOLVER_CMISS_LIBRARY)
                    CALL SOLVER_CELLML_EVALUATE(CELLML_EVALUATOR_SOLVER,time,CELLML_ENVIRONMENT,MODELS_VARIABLE% &
                      & TOTAL_NUMBER_OF_DOFS,CELLML_ENVIRONMENT%MODELS_FIELD%ONLY_ONE_MODEL_INDEX,MODELS_DATA,CELLML_ENVIRONMENT% &
                      & MAXIMUM_NUMBER_OF_STATE,STATE_DATA,CELLML_ENVIRONMENT%MAXIMUM_NUMBER_OF_PARAMETERS, &
                      & PARAMETERS_DATA,CELLML_ENVIRONMENT%MAXIMUM_NUMBER_OF_INTERMEDIATE,INTERMEDIATE_DATA,err,error,*999)
                  CASE DEFAULT
                    CALL FlagError("Solver library not implemented.",err,error,*999)
                  END SELECT
                   
                  !Restore field data
                  CALL Field_ParameterSetDataRestore(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                    & MODELS_DATA,err,error,*999)
                  IF(ASSOCIATED(STATE_FIELD)) CALL Field_ParameterSetDataRestore(STATE_FIELD,FIELD_U_VARIABLE_TYPE, &
                    & FIELD_VALUES_SET_TYPE,STATE_DATA,err,error,*999)                    
                  IF(ASSOCIATED(PARAMETERS_FIELD)) CALL Field_ParameterSetDataRestore(PARAMETERS_FIELD, &
                    & FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,PARAMETERS_DATA,err,error,*999)                    
                  IF(ASSOCIATED(INTERMEDIATE_FIELD)) CALL Field_ParameterSetDataRestore(INTERMEDIATE_FIELD, &
                    & FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,INTERMEDIATE_DATA,err,error,*999)
                   
                  !Make sure fields have been updated to the current value of any mapped CellML fields
                  CALL CELLML_CELLML_TO_FIELD_UPDATE(CELLML_ENVIRONMENT,err,error,*999)
                    
                ELSE
                  localError="The CellML models field is not associated for CellML index "// &
                    & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The CellML models field is not associated for CellML index "// &
                  & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The CellML enviroment is not associated for for CellML index "// &
                & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ENDDO !cellml_idx
        ELSE
          CALL FlagError("Solver solver equations is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("CellML evaluator solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_CELLML_EVALUATOR_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_CELLML_EVALUATOR_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_CELLML_EVALUATOR_SOLVE

  !
  !================================================================================================================================
  !
  
  !>Evaluate the CellML equations. 
  SUBROUTINE SOLVER_CELLML_EVALUATE(CELLML_EVALUATOR_SOLVER,time,CELLML,N, ONLY_ONE_MODEL_INDEX,MODELS_DATA,MAX_NUMBER_STATES, &
    & STATE_DATA,MAX_NUMBER_PARAMETERS,PARAMETERS_DATA,MAX_NUMBER_INTERMEDIATES,INTERMEDIATE_DATA,err,error,*)

    !Argument variables
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: CELLML_EVALUATOR_SOLVER !<A pointer the CellML evaluator equation solver to evaluate
    REAL(DP), INTENT(IN) :: time !<The time for the CellML evaluate.
    TYPE(CELLML_TYPE), POINTER :: CELLML !<A pointer to the CellML environment to integrate the equations for.
    INTEGER(INTG), INTENT(IN) :: N !<The number of degrees-of-freedom
    INTEGER(INTG), INTENT(IN) :: ONLY_ONE_MODEL_INDEX !<If only one model is used in the models data the index of that model. 0 otherwise.
    INTEGER(INTG), POINTER :: MODELS_DATA(:) !<MODELS_DATA(dof_idx). The models data for the dof_idx'th dof.
    INTEGER(INTG), INTENT(IN) :: MAX_NUMBER_STATES !<The maximum number of state variables per dof
    REAL(DP), POINTER :: STATE_DATA(:) !<STATE_DATA(state_idx,dof_idx). The state data for the state_idx'th state variable of the dof_idx'th dof. state_idx varies from 1..NUMBER_STATES.
    INTEGER(INTG), INTENT(IN) :: MAX_NUMBER_PARAMETERS !<The maximum number of parameter variables per dof.
    REAL(DP), POINTER :: PARAMETERS_DATA(:) !<PARAMETERS_DATA(parameter_idx,dof_idx). The parameters data for the parameter_idx'th parameter variable of the dof_idx'th dof. parameter_idx varies from 1..NUMBER_PARAMETERS.
    INTEGER(INTG), INTENT(IN) :: MAX_NUMBER_INTERMEDIATES !<The maximum number of intermediate variables per dof.
    REAL(DP), POINTER :: INTERMEDIATE_DATA(:) !<INTERMEDIATE_DATA(intermediate_idx,dof_idx). The intermediate values data for the intermediate_idx'th intermediate variable of the dof_idx'th dof. intermediate_idx varies from 1..NUMBER_INTERMEDIATE
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx,DOF_ORDER_TYPE,INTERMEDIATE_END_DOF,intermediate_idx,INTERMEDIATE_START_DOF,model_idx, &
      & NUMBER_INTERMEDIATES,NUMBER_PARAMETERS,NUMBER_STATES,PARAMETER_END_DOF,parameter_idx,PARAMETER_START_DOF, &
      & STATE_END_DOF,state_idx,STATE_START_DOF
    REAL(DP) :: INTERMEDIATES(MAX(1,MAX_NUMBER_INTERMEDIATES)),PARAMETERS(MAX(1,MAX_NUMBER_PARAMETERS)), &
      & RATES(MAX(1,MAX_NUMBER_STATES)),STATES(MAX(1,MAX_NUMBER_STATES))
    TYPE(CELLML_MODEL_TYPE), POINTER :: MODEL
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_CELLML_EVALUATE",err,error,*999)

    IF(ASSOCIATED(CELLML_EVALUATOR_SOLVER)) THEN
      IF(ASSOCIATED(CELLML)) THEN
        IF(ASSOCIATED(CELLML%MODELS_FIELD)) THEN
          CALL FIELD_DOF_ORDER_TYPE_GET(CELLML%MODELS_FIELD%MODELS_FIELD,FIELD_U_VARIABLE_TYPE,DOF_ORDER_TYPE,err,error,*999)
          IF(DOF_ORDER_TYPE==FIELD_SEPARATED_COMPONENT_DOF_ORDER) THEN
            !Dof components are separated. Will need to copy data to temporary arrays.
            IF(ONLY_ONE_MODEL_INDEX/=0) THEN
              !We have CellML models on this rank
              IF(ONLY_ONE_MODEL_INDEX==CELLML_MODELS_FIELD_NOT_CONSTANT) THEN
                !Mulitple models
                DO dof_idx=1,N
                  model_idx=MODELS_DATA(dof_idx)
                  IF(model_idx.GT.0) THEN
                    MODEL=>CELLML%MODELS(model_idx)%ptr
                    IF(ASSOCIATED(MODEL)) THEN
                      NUMBER_STATES=MODEL%NUMBER_OF_STATE
                      NUMBER_INTERMEDIATES=MODEL%NUMBER_OF_INTERMEDIATE
                      NUMBER_PARAMETERS=MODEL%NUMBER_OF_PARAMETERS
                    
                      !Copy CellML data to temporary arrays
                      DO state_idx=1,NUMBER_STATES
                        STATES(state_idx)=STATE_DATA((dof_idx-1)*N+state_idx)
                      ENDDO !state_idx
                      DO parameter_idx=1,NUMBER_PARAMETERS
                        PARAMETERS(parameter_idx)=PARAMETERS_DATA((dof_idx-1)*N+parameter_idx)
                      ENDDO !parameter_idx
                  
#ifdef WITH_CELLML                    
                      CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time,STATES,RATES,INTERMEDIATES, &
                        & PARAMETERS)
#else
                      CALL FlagError("Must compile with WITH_CELLML ON to use CellML functionality.",err,error,*999)
#endif

                      !Copy temporary data back to CellML arrays
                      DO intermediate_idx=1,NUMBER_INTERMEDIATES
                        INTERMEDIATE_DATA((dof_idx-1)*N+intermediate_idx)=INTERMEDIATES(intermediate_idx)
                      ENDDO !intermediate_idx
                      DO state_idx=1,NUMBER_STATES
                        STATE_DATA((dof_idx-1)*N+state_idx)=STATES(state_idx)
                      ENDDO !state_idx
                    
                    ELSE
                      localError="CellML environment model is not associated for model index "// &
                        & TRIM(NumberToVString(ONLY_ONE_MODEL_INDEX,"*",err,error))//" belonging to dof index "// &
                        & TRIM(NumberToVString(dof_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ENDIF !model_idx                  
                ENDDO !dof_idx
              ELSE
                !One one model is used.          
                MODEL=>CELLML%MODELS(ONLY_ONE_MODEL_INDEX)%ptr
                IF(ASSOCIATED(MODEL)) THEN
                  NUMBER_STATES=MODEL%NUMBER_OF_STATE
                  NUMBER_INTERMEDIATES=MODEL%NUMBER_OF_INTERMEDIATE
                  NUMBER_PARAMETERS=MODEL%NUMBER_OF_PARAMETERS
                  DO dof_idx=1,N
                    model_idx=MODELS_DATA(dof_idx)
                    IF(model_idx.GT.0) THEN
                      
                      !Copy CellML data to temporary arrays
                      DO state_idx=1,NUMBER_STATES
                        STATES(state_idx)=STATE_DATA((dof_idx-1)*N+state_idx)
                      ENDDO !state_idx
                      DO parameter_idx=1,NUMBER_PARAMETERS
                        PARAMETERS(parameter_idx)=PARAMETERS_DATA((dof_idx-1)*N+parameter_idx)
                      ENDDO !parameter_idx
                      
#ifdef WITH_CELLML                    
                      CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time,STATES,RATES,INTERMEDIATES, &
                        & PARAMETERS)
#else
                      CALL FlagError("Must compile with WITH_CELLML ON to use CellML functionality.",err,error,*999)
#endif
                      
                      !Copy temporary data back to CellML arrays
                      DO intermediate_idx=1,NUMBER_INTERMEDIATES
                        INTERMEDIATE_DATA((dof_idx-1)*N+intermediate_idx)=INTERMEDIATES(intermediate_idx)
                      ENDDO !intermediate_idx
                      DO state_idx=1,NUMBER_STATES
                        STATE_DATA((dof_idx-1)*N+state_idx)=STATES(state_idx)
                      ENDDO !state_idx
                    ENDIF !model_idx
                  ENDDO !dof_idx
                ELSE
                  localError="CellML environment model is not associated for model index "// &
                    & TRIM(NumberToVString(ONLY_ONE_MODEL_INDEX,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ENDIF
            ENDIF
          ELSE
            !Dof components are continguous. Can pass data directly.
            IF(ONLY_ONE_MODEL_INDEX/=0) THEN
              !We have CellML models on this rank
              IF(ONLY_ONE_MODEL_INDEX==CELLML_MODELS_FIELD_NOT_CONSTANT) THEN
                !Mulitple models

#ifdef WITH_CELLML                    

                DO dof_idx=1,N
                  model_idx=MODELS_DATA(dof_idx)
                  IF(model_idx.GT.0) THEN
                    MODEL=>CELLML%MODELS(model_idx)%ptr
                    IF(ASSOCIATED(MODEL)) THEN
                      NUMBER_STATES=MODEL%NUMBER_OF_STATE
                      NUMBER_INTERMEDIATES=MODEL%NUMBER_OF_INTERMEDIATE
                      NUMBER_PARAMETERS=MODEL%NUMBER_OF_PARAMETERS
                      !Call RHS. Note some models might not have state, rates, intermediate or parameter data so call accordingly
                      !to avoid indexing in to null pointers
                      IF(NUMBER_STATES>0) THEN
                        IF(NUMBER_INTERMEDIATES>0) THEN
                          IF(NUMBER_PARAMETERS>0) THEN
                            !We have state, intermediate and parameters in the model
                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                            PARAMETER_START_DOF=(dof_idx-1)*MAX_NUMBER_PARAMETERS+1
                            PARAMETER_END_DOF=PARAMETER_START_DOF+NUMBER_PARAMETERS-1         
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time, & 
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF),PARAMETERS_DATA( &
                              & PARAMETER_START_DOF:PARAMETER_END_DOF))
                            
                          ELSE
                            !We do not have parameters in the model
                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                    
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time, & 
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF),PARAMETERS)
                        
                          ENDIF
                        ELSE
                          IF(NUMBER_PARAMETERS>0) THEN
                            !We do not have intermediates in the model
                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            PARAMETER_START_DOF=(dof_idx-1)*MAX_NUMBER_PARAMETERS+1
                            PARAMETER_END_DOF=PARAMETER_START_DOF+NUMBER_PARAMETERS-1         
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time, & 
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATES,PARAMETERS_DATA(PARAMETER_START_DOF:PARAMETER_END_DOF))
                            
                          ELSE
                            !We do not have intermediates or parameters in the model
                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time, & 
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATES,PARAMETERS)
                            
                          ENDIF
                        ENDIF
                      ELSE
                        IF(NUMBER_INTERMEDIATES>0) THEN
                          IF(NUMBER_PARAMETERS>0) THEN
                            !We do not have any states in the model
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                            PARAMETER_START_DOF=(dof_idx-1)*MAX_NUMBER_PARAMETERS+1
                            PARAMETER_END_DOF=PARAMETER_START_DOF+NUMBER_PARAMETERS-1         
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time,STATES,RATES, &
                              & INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF),PARAMETERS_DATA( &
                              & PARAMETER_START_DOF:PARAMETER_END_DOF))
                          ELSE
                            !We do not have any states or parameters in the model
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time,STATES,RATES, &
                              & INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF),PARAMETERS)
                            
                          ENDIF
                        ELSE
                          CALL FlagError("Invalid CellML model - there are no states or intermediates.",err,error,*999)
                        ENDIF
                      ENDIF
                                          
                    ELSE
                      localError="CellML environment model is not associated for model index "// &
                        & TRIM(NumberToVString(ONLY_ONE_MODEL_INDEX,"*",err,error))//" belonging to dof index "// &
                        & TRIM(NumberToVString(dof_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ENDIF  !model_idx                
                ENDDO !dof_idx
#else
                CALL FlagError("Must compile with WITH_CELLML ON to use CellML functionality.",err,error,*999)
#endif
                
              ELSE
                !One model is used.
                MODEL=>CELLML%MODELS(ONLY_ONE_MODEL_INDEX)%ptr
                IF(ASSOCIATED(MODEL)) THEN
                  NUMBER_STATES=MODEL%NUMBER_OF_STATE
                  NUMBER_INTERMEDIATES=MODEL%NUMBER_OF_INTERMEDIATE
                  NUMBER_PARAMETERS=MODEL%NUMBER_OF_PARAMETERS                
#ifdef WITH_CELLML
                  !Call RHS. Note some models might not have state, rates, intermediate or parameter data so call accordingly
                  !to avoid referencing null pointers
                  IF(NUMBER_STATES>0) THEN
                    IF(NUMBER_INTERMEDIATES>0) THEN
                      IF(NUMBER_PARAMETERS>0) THEN
                        !We have states, intermediate and parameters for the model
                        DO dof_idx=1,N
                          model_idx=MODELS_DATA(dof_idx)
                          IF(model_idx.GT.0) THEN
                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                            PARAMETER_START_DOF=(dof_idx-1)*MAX_NUMBER_PARAMETERS+1
                            PARAMETER_END_DOF=PARAMETER_START_DOF+NUMBER_PARAMETERS-1
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time, & 
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF),PARAMETERS_DATA( &
                              & PARAMETER_START_DOF:PARAMETER_END_DOF))
                          ENDIF !model_idx
                        ENDDO !dof_idx
                      ELSE
                        !We do not have parameters in the model
                        DO dof_idx=1,N
                          model_idx=MODELS_DATA(dof_idx)
                          IF(model_idx.GT.0) THEN
                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time, & 
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF),PARAMETERS)
                          ENDIF !model_idx
                        ENDDO !dof_idx
                        
                      ENDIF
                    ELSE
                      IF(NUMBER_PARAMETERS>0) THEN
                        !We do not have any intermediates in the model
                        DO dof_idx=1,N
                          model_idx=MODELS_DATA(dof_idx)
                          IF(model_idx.GT.0) THEN
                            
                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            PARAMETER_START_DOF=(dof_idx-1)*MAX_NUMBER_PARAMETERS+1
                            PARAMETER_END_DOF=PARAMETER_START_DOF+NUMBER_PARAMETERS-1
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time, & 
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATES,PARAMETERS_DATA(PARAMETER_START_DOF:PARAMETER_END_DOF))
                          ENDIF !model_idx
                        ENDDO !dof_idx
                      ELSE
                        !We do not have any intermediates or parameters in the model
                        DO dof_idx=1,N
                          model_idx=MODELS_DATA(dof_idx)
                          IF(model_idx.GT.0) THEN

                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time,& 
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATES,PARAMETERS)
                          ENDIF !model_idx
                        ENDDO !dof_idx
                      ENDIF
                    ENDIF
                  ELSE
                    IF(NUMBER_INTERMEDIATES>0) THEN
                      IF(NUMBER_PARAMETERS>0) THEN
                        !We do not have any states in the model
                        DO dof_idx=1,N
                          model_idx=MODELS_DATA(dof_idx)
                          IF(model_idx.GT.0) THEN
                            
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                            PARAMETER_START_DOF=(dof_idx-1)*MAX_NUMBER_PARAMETERS+1
                            PARAMETER_END_DOF=PARAMETER_START_DOF+NUMBER_PARAMETERS-1
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time,STATES,RATES, &
                              & INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF),PARAMETERS_DATA( &
                              & PARAMETER_START_DOF:PARAMETER_END_DOF))
                          ENDIF !model_idx
                        ENDDO !dof_idx
                      ELSE
                        !We do not have any states or parameters the model
                        DO dof_idx=1,N
                          model_idx=MODELS_DATA(dof_idx)
                          IF(model_idx.GT.0) THEN
                            
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,time,STATES,RATES, &
                              & INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF),PARAMETERS)
                          ENDIF !model_idx           
                        ENDDO !dof_idx
                      ENDIF
                    ELSE
                      CALL FlagError("Invalid CellML model - there are no states or intermediates.",err,error,*999)
                    ENDIF
                  ENDIF
#else
                  CALL FlagError("Must compile with WITH_CELLML ON to use CellML functionality.",err,error,*999)
#endif
                ELSE
                  localError="CellML environment model is not associated for model index "// &
                    & TRIM(NumberToVString(ONLY_ONE_MODEL_INDEX,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ELSE
          CALL FlagError("CellML environment models field is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("CellML environment is not associated.",err,error,*999)
      ENDIF      
    ELSE
      CALL FlagError("CellML evaluator solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_CELLML_EVALUATE")
    RETURN
999 ERRORSEXITS("SOLVER_CELLML_EVALUATE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_CELLML_EVALUATE

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a solver 
  SUBROUTINE SOLVER_CREATE_FINISH(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: solver_idx

    ENTERS("SOLVER_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        !Set the finished flag. The final solver finish will be done once the solver equations have been finished.
        DO solver_idx=1,SOLVER%NUMBER_OF_LINKED_SOLVERS
          SOLVER%LINKED_SOLVERS(solver_idx)%ptr%SOLVER_FINISHED=.TRUE.
        ENDDO !solver_idx

        SOLVER%SOLVER_FINISHED=.TRUE.
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_CREATE_FINISH",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Finalise an Adams-Moulton differential-algebraic equation solver and deallocate all memory.
  SUBROUTINE SOLVER_DAE_ADAMS_MOULTON_FINALISE(ADAMS_MOULTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: ADAMS_MOULTON_SOLVER !<A pointer the Adams-Moulton differential-algebraic equation solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
     
    ENTERS("SOLVER_DAE_ADAMS_MOULTON_FINALISE",err,error,*999)

    IF(ASSOCIATED(ADAMS_MOULTON_SOLVER)) THEN
      DEALLOCATE(ADAMS_MOULTON_SOLVER)
    ENDIF
         
    EXITS("SOLVER_DAE_ADAMS_MOULTON_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_ADAMS_MOULTON_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_ADAMS_MOULTON_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise an Adams-Moulton solver for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_ADAMS_MOULTON_INITIALISE(DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer the differential-algebraic equation solver to initialise an Adams-Moulton solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_DAE_ADAMS_MOULTON_INITIALISE",err,error,*998)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      IF(ASSOCIATED(DAE_SOLVER%ADAMS_MOULTON_SOLVER)) THEN
        CALL FlagError("Adams-Moulton solver is already associated for this differential-algebraic equation solver.", &
          & err,error,*998)
      ELSE
        !Allocate the Adams-Moulton solver
        ALLOCATE(DAE_SOLVER%ADAMS_MOULTON_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate Adams-Moulton solver.",err,error,*999)
        !Initialise
        DAE_SOLVER%ADAMS_MOULTON_SOLVER%DAE_SOLVER=>DAE_SOLVER
        DAE_SOLVER%ADAMS_MOULTON_SOLVER%SOLVER_LIBRARY=0
        !Defaults
      ENDIF      
    ELSE
      CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*998)
    ENDIF
         
    EXITS("SOLVER_DAE_ADAMS_MOULTON_INITIALISE")
    RETURN
999 CALL SOLVER_DAE_ADAMS_MOULTON_FINALISE(DAE_SOLVER%ADAMS_MOULTON_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_DAE_ADAMS_MOULTON_INITIALISE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DAE_ADAMS_MOULTON_INITIALISE

  !
  !================================================================================================================================
  !

  !>Solve using an Adams-Moulton differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_ADAMS_MOULTON_SOLVE(ADAMS_MOULTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: ADAMS_MOULTON_SOLVER !<A pointer the Adams-Moulton differential-algebraic equation solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_DAE_ADAMS_MOULTON_SOLVE",err,error,*999)

    IF(ASSOCIATED(ADAMS_MOULTON_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Adams-Moulton differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_ADAMS_MOULTON_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_ADAMS_MOULTON_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_ADAMS_MOULTON_SOLVE

 !
  !================================================================================================================================
  !

  !>Finishes the process of creating a differential-algebraic equation solver 
  SUBROUTINE SOLVER_DAE_CREATE_FINISH(DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer to the differential-algebraic equation solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_DAE_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_DAE_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_CREATE_FINISH",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Finalise a backward Euler differential-algebraic equation and deallocate all memory.
  SUBROUTINE SOLVER_DAE_EULER_BACKWARD_FINALISE(BACKWARD_EULER_SOLVER,err,error,*)

    !Argument variables
    TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: BACKWARD_EULER_SOLVER !<A pointer the backward Euler differential-algebraic equation solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
     
    ENTERS("SOLVER_DAE_EULER_BACKWARD_FINALISE",err,error,*999)

    IF(ASSOCIATED(BACKWARD_EULER_SOLVER)) THEN
      DEALLOCATE(BACKWARD_EULER_SOLVER)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_BACKWARD_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_BACKWARD_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_BACKWARD_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a backward Euler solver for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_EULER_BACKWARD_INITIALISE(EULER_DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_DAE_SOLVER !<A pointer the Euler differential-algebraic equation solver to initialise a backward Euler solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_DAE_EULER_BACKWARD_INITIALISE",err,error,*998)

    IF(ASSOCIATED(EULER_DAE_SOLVER)) THEN
      IF(ASSOCIATED(EULER_DAE_SOLVER%BACKWARD_EULER_SOLVER)) THEN
        CALL FlagError("Backward Euler solver is already associated for this Euler differential-algebraic equation solver.", &
          & err,error,*998)
      ELSE
        !Allocate the backward Euler solver
        ALLOCATE(EULER_DAE_SOLVER%BACKWARD_EULER_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate backward Euler solver.",err,error,*999)
        !Initialise
        EULER_DAE_SOLVER%BACKWARD_EULER_SOLVER%EULER_DAE_SOLVER=>EULER_DAE_SOLVER
        EULER_DAE_SOLVER%BACKWARD_EULER_SOLVER%SOLVER_LIBRARY=0
        !Defaults
      ENDIF      
    ELSE
      CALL FlagError("Euler differential-algebraic equation solver is not associated.",err,error,*998)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_BACKWARD_INITIALISE")
    RETURN
999 CALL SOLVER_DAE_EULER_BACKWARD_FINALISE(EULER_DAE_SOLVER%BACKWARD_EULER_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_DAE_EULER_BACKWARD_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_BACKWARD_INITIALISE

  !
  !================================================================================================================================
  !

  !>Solve using a backward Euler differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_EULER_BACKWARD_SOLVE(BACKWARD_EULER_SOLVER,err,error,*)

    !Argument variables
    TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: BACKWARD_EULER_SOLVER !<A pointer the backward Euler differential-algebraic equation solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_DAE_EULER_BACKWARD_SOLVE",err,error,*999)

    IF(ASSOCIATED(BACKWARD_EULER_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Backward Euler differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_BACKWARD_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_BACKWARD_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_BACKWARD_SOLVE

  !
  !================================================================================================================================
  !

  !>Finalise an Euler differential-algebraic equation solver and deallocate all memory.
  SUBROUTINE SOLVER_DAE_EULER_FINALISE(EULER_SOLVER,err,error,*)

    !Argument variables
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_SOLVER !<A pointer the Euler differential-algebraic equation solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
     
    ENTERS("SOLVER_DAE_EULER_FINALISE",err,error,*999)

    IF(ASSOCIATED(EULER_SOLVER)) THEN
      CALL SOLVER_DAE_EULER_FORWARD_FINALISE(EULER_SOLVER%FORWARD_EULER_SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_BACKWARD_FINALISE(EULER_SOLVER%BACKWARD_EULER_SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_IMPROVED_FINALISE(EULER_SOLVER%IMPROVED_EULER_SOLVER,err,error,*999)      
      DEALLOCATE(EULER_SOLVER)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_FINALISE

  !
  !================================================================================================================================
  !

  !>Finalise a forward Euler differential-algebraic equation and deallocate all memory.
  SUBROUTINE SOLVER_DAE_EULER_FORWARD_FINALISE(FORWARD_EULER_SOLVER,err,error,*)

    !Argument variables
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: FORWARD_EULER_SOLVER !<A pointer the forward Euler differential-algebraic equation solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
     
    ENTERS("SOLVER_DAE_EULER_FORWARD_FINALISE",err,error,*999)

    IF(ASSOCIATED(FORWARD_EULER_SOLVER)) THEN
      DEALLOCATE(FORWARD_EULER_SOLVER)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_FORWARD_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_FORWARD_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_FORWARD_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a forward Euler solver for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_EULER_FORWARD_INITIALISE(EULER_DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_DAE_SOLVER !<A pointer the Euler differential-algebraic equation solver to initialise a forward Euler solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_DAE_EULER_FORWARD_INITIALISE",err,error,*998)

    IF(ASSOCIATED(EULER_DAE_SOLVER)) THEN
      IF(ASSOCIATED(EULER_DAE_SOLVER%FORWARD_EULER_SOLVER)) THEN
        CALL FlagError("Forward Euler solver is already associated for this Euler differential-algebraic equation solver.", &
          & err,error,*998)
      ELSE
        !Allocate the forward Euler solver
        ALLOCATE(EULER_DAE_SOLVER%FORWARD_EULER_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate forward Euler solver.",err,error,*999)
        !Initialise
        EULER_DAE_SOLVER%FORWARD_EULER_SOLVER%EULER_DAE_SOLVER=>EULER_DAE_SOLVER
        EULER_DAE_SOLVER%FORWARD_EULER_SOLVER%SOLVER_LIBRARY=SOLVER_CMISS_LIBRARY
        !Defaults
      ENDIF      
    ELSE
      CALL FlagError("Euler differential-algebraic equation solver is not associated.",err,error,*998)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_FORWARD_INITIALISE")
    RETURN
999 CALL SOLVER_DAE_EULER_FORWARD_FINALISE(EULER_DAE_SOLVER%FORWARD_EULER_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_DAE_EULER_FORWARD_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_FORWARD_INITIALISE

  !
  !================================================================================================================================
  !

  !>Integrate using a forward Euler differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_EULER_FORWARD_INTEGRATE(FORWARD_EULER_SOLVER,CELLML,N,START_TIME,END_TIME,TIME_INCREMENT, &
    & ONLY_ONE_MODEL_INDEX,MODELS_DATA,MAX_NUMBER_STATES,STATE_DATA,MAX_NUMBER_PARAMETERS,PARAMETERS_DATA, &
    & MAX_NUMBER_INTERMEDIATES,INTERMEDIATE_DATA,err,error,*)

    !Argument variables
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: FORWARD_EULER_SOLVER !<A pointer the forward Euler differential-algebraic equation solver to integrate
    TYPE(CELLML_TYPE), POINTER :: CELLML !<A pointer to the CellML environment to integrate the equations for.
    INTEGER(INTG), INTENT(IN) :: N !<The number of degrees-of-freedom
    REAL(DP), INTENT(IN) :: START_TIME !<The start time for the integration
    REAL(DP), INTENT(IN) :: END_TIME !<The end time for the integration
    REAL(DP), INTENT(INOUT) :: TIME_INCREMENT !<The (initial) time increment for the integration
    INTEGER(INTG), INTENT(IN) :: ONLY_ONE_MODEL_INDEX !<If only one model is used in the models data the index of that model. 0 otherwise.
    INTEGER(INTG), POINTER :: MODELS_DATA(:) !<MODELS_DATA(dof_idx). The models data for the dof_idx'th dof.
    INTEGER(INTG), INTENT(IN) :: MAX_NUMBER_STATES !<The maximum number of state variables per dof
    REAL(DP), POINTER :: STATE_DATA(:) !<STATE_DATA(state_idx,dof_idx). The state data for the state_idx'th state variable of the dof_idx'th dof. state_idx varies from 1..NUMBER_STATES.
    INTEGER(INTG), INTENT(IN) :: MAX_NUMBER_PARAMETERS !<The maximum number of parameter variables per dof.
    REAL(DP), POINTER :: PARAMETERS_DATA(:) !<PARAMETERS_DATA(parameter_idx,dof_idx). The parameters data for the parameter_idx'th parameter variable of the dof_idx'th dof. parameter_idx varies from 1..NUMBER_PARAMETERS.
    INTEGER(INTG), INTENT(IN) :: MAX_NUMBER_INTERMEDIATES !<The maximum number of intermediate variables per dof.
    REAL(DP), POINTER :: INTERMEDIATE_DATA(:) !<INTERMEDIATE_DATA(intermediate_idx,dof_idx). The intermediate values data for the intermediate_idx'th intermediate variable of the dof_idx'th dof. intermediate_idx varies from 1.NUMBER_INTERMEDIATE    
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx,DOF_ORDER_TYPE,INTERMEDIATE_END_DOF,intermediate_idx,INTERMEDIATE_START_DOF,model_idx, &
      & NUMBER_INTERMEDIATES,NUMBER_PARAMETERS,NUMBER_STATES,PARAMETER_END_DOF,parameter_idx,PARAMETER_START_DOF, &
      & STATE_END_DOF,state_idx,STATE_START_DOF
    REAL(DP) :: INTERMEDIATES(MAX(1,MAX_NUMBER_INTERMEDIATES)),PARAMETERS(MAX(1,MAX_NUMBER_PARAMETERS)), &
      & RATES(MAX(1,MAX_NUMBER_STATES)),STATES(MAX(1,MAX_NUMBER_STATES)),TIME
    TYPE(CELLML_MODEL_TYPE), POINTER :: MODEL
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_DAE_EULER_FORWARD_INTEGRATE",err,error,*999)

    IF(ASSOCIATED(FORWARD_EULER_SOLVER)) THEN
      IF(ASSOCIATED(CELLML)) THEN
        IF(ASSOCIATED(CELLML%MODELS_FIELD)) THEN
          CALL FIELD_DOF_ORDER_TYPE_GET(CELLML%MODELS_FIELD%MODELS_FIELD,FIELD_U_VARIABLE_TYPE,DOF_ORDER_TYPE,err,error,*999)
          IF(DOF_ORDER_TYPE==FIELD_SEPARATED_COMPONENT_DOF_ORDER) THEN
            !Dof components are separated. Will need to copy data to temporary arrays.
            IF(ONLY_ONE_MODEL_INDEX==CELLML_MODELS_FIELD_NOT_CONSTANT) THEN
              !Mulitple models
              DO WHILE(TIME<=END_TIME)
                DO dof_idx=1,N
                  model_idx=MODELS_DATA(dof_idx)
                  IF(model_idx.GT.0) THEN
                    MODEL=>CELLML%MODELS(model_idx)%ptr
                    IF(ASSOCIATED(MODEL)) THEN
                      NUMBER_STATES=MODEL%NUMBER_OF_STATE
                      NUMBER_INTERMEDIATES=MODEL%NUMBER_OF_INTERMEDIATE
                      NUMBER_PARAMETERS=MODEL%NUMBER_OF_PARAMETERS

                      !Copy CellML data to temporary arrays
                      DO state_idx=1,NUMBER_STATES
                        STATES(state_idx)=STATE_DATA((dof_idx-1)*N+state_idx)
                      ENDDO !state_idx
                      DO parameter_idx=1,NUMBER_PARAMETERS
                        PARAMETERS(parameter_idx)=PARAMETERS_DATA((dof_idx-1)*N+parameter_idx)
                      ENDDO !parameter_idx
                    
#ifdef WITH_CELLML                    
                      CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,TIME,STATES,RATES,INTERMEDIATES, &
                        & PARAMETERS)
#else
                      CALL FlagError("Must compile with WITH_CELLML ON to use CellML functionality.",err,error,*999)
#endif

                      !Copy temporary data back to CellML arrays
                      DO intermediate_idx=1,NUMBER_INTERMEDIATES
                        INTERMEDIATE_DATA((dof_idx-1)*N+intermediate_idx)=INTERMEDIATES(intermediate_idx)
                      ENDDO !intermediate_idx
                      DO state_idx=1,NUMBER_STATES
                        STATE_DATA((dof_idx-1)*N+state_idx)=STATES(state_idx)+TIME_INCREMENT*RATES(state_idx)
                      ENDDO !state_idx
                   
                    ELSE
                      localError="CellML environment model is not associated for model index "// &
                        & TRIM(NumberToVString(ONLY_ONE_MODEL_INDEX,"*",err,error))//" belonging to dof index "// &
                        & TRIM(NumberToVString(dof_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ENDIF !model_idx                  
                ENDDO !dof_idx
                TIME=TIME+TIME_INCREMENT
              ENDDO !time              
            ELSE
              !One one model is used.          
              MODEL=>CELLML%MODELS(ONLY_ONE_MODEL_INDEX)%ptr
              IF(ASSOCIATED(MODEL)) THEN
                NUMBER_STATES=MODEL%NUMBER_OF_STATE
                NUMBER_INTERMEDIATES=MODEL%NUMBER_OF_INTERMEDIATE
                NUMBER_PARAMETERS=MODEL%NUMBER_OF_PARAMETERS
                TIME=START_TIME
                DO WHILE(TIME<=END_TIME)
                  DO dof_idx=1,N

                    model_idx=MODELS_DATA(dof_idx)
                    IF(model_idx.GT.0) THEN
                      !Copy CellML data to temporary arrays
                       DO state_idx=1,NUMBER_STATES
                        STATES(state_idx)=STATE_DATA((dof_idx-1)*N+state_idx)
                      ENDDO !state_idx
                      DO parameter_idx=1,NUMBER_PARAMETERS
                        PARAMETERS(parameter_idx)=PARAMETERS_DATA((dof_idx-1)*N+parameter_idx)
                      ENDDO !parameter_idx

#ifdef WITH_CELLML                    
                      CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,TIME,STATES,RATES,INTERMEDIATES, &
                        & PARAMETERS)
#else
                      CALL FlagError("Must compile with WITH_CELLML ON to use CellML functionality.",err,error,*999)
#endif
                    
                      !Copy temporary data back to CellML arrays
                      DO intermediate_idx=1,NUMBER_INTERMEDIATES
                        INTERMEDIATE_DATA((dof_idx-1)*N+intermediate_idx)=INTERMEDIATES(intermediate_idx)
                      ENDDO !intermediate_idx
                      DO state_idx=1,NUMBER_STATES
                        STATE_DATA((dof_idx-1)*N+state_idx)=STATES(state_idx)+TIME_INCREMENT*RATES(state_idx)
                      ENDDO !state_idx
                    ENDIF !model_idx
                  ENDDO !dof_idx
                  TIME=TIME+TIME_INCREMENT
                ENDDO !time
              ELSE
                localError="CellML environment model is not associated for model index "// &
                  & TRIM(NumberToVString(ONLY_ONE_MODEL_INDEX,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ENDIF
          ELSE
            !Dof components are continguous. Can pass data directly.
            IF(ONLY_ONE_MODEL_INDEX==CELLML_MODELS_FIELD_NOT_CONSTANT) THEN
              !Mulitple models
              TIME=START_TIME
              DO WHILE(TIME<=END_TIME)
                DO dof_idx=1,N
                  model_idx=MODELS_DATA(dof_idx)
                  IF(model_idx==0) THEN
                    ! Do nothing- empty model index specified
                  ELSE IF(model_idx > 0 .AND. model_idx <= CELLML%NUMBER_OF_MODELS) THEN
                    MODEL=>CELLML%MODELS(model_idx)%ptr
                    IF(ASSOCIATED(MODEL)) THEN
                      NUMBER_STATES=MODEL%NUMBER_OF_STATE
                      NUMBER_INTERMEDIATES=MODEL%NUMBER_OF_INTERMEDIATE
                      NUMBER_PARAMETERS=MODEL%NUMBER_OF_PARAMETERS

#ifdef WITH_CELLML                    
                      !Call RHS. Note some models might not have state, rates, intermediate or parameter data so call accordingly
                      !to avoid referencing null pointers
                      IF(NUMBER_STATES>0) THEN
                        IF(NUMBER_INTERMEDIATES>0) THEN
                          IF(NUMBER_PARAMETERS>0) THEN
                            !We have states, intermediate and parameters for the model
                     
                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                            PARAMETER_START_DOF=(dof_idx-1)*MAX_NUMBER_PARAMETERS+1
                            PARAMETER_END_DOF=PARAMETER_START_DOF+NUMBER_PARAMETERS-1         
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,TIME,STATE_DATA(STATE_START_DOF: &
                              & STATE_END_DOF),RATES,INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF), &
                              & PARAMETERS_DATA(PARAMETER_START_DOF:PARAMETER_END_DOF))

                          ELSE
                            !We do not have parameters in the model
                     
                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,TIME,STATE_DATA(STATE_START_DOF: &
                              & STATE_END_DOF),RATES,INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF), &
                              & PARAMETERS)

                           ENDIF
                        ELSE
                          IF(NUMBER_PARAMETERS>0) THEN
                            !We do not have intermediates in the model
                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            PARAMETER_START_DOF=(dof_idx-1)*MAX_NUMBER_PARAMETERS+1
                            PARAMETER_END_DOF=PARAMETER_START_DOF+NUMBER_PARAMETERS-1         
                            
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,TIME,STATE_DATA(STATE_START_DOF: &
                              & STATE_END_DOF),RATES,INTERMEDIATES,PARAMETERS_DATA(PARAMETER_START_DOF:PARAMETER_END_DOF))

                          ELSE
                            !We do not have intermediates or parameters in the model
                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                          
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,TIME,STATE_DATA(STATE_START_DOF: &
                              & STATE_END_DOF),RATES,INTERMEDIATES,PARAMETERS)

                          ENDIF
                        ENDIF
                      ELSE
                        CALL FlagError("Invalid CellML model for integration - there are no states.",err,error,*999)
                      ENDIF
                        
#else
                      CALL FlagError("Must compile with WITH_CELLML ON to use CellML functionality.",err,error,*999)
#endif
                      STATE_DATA(STATE_START_DOF:STATE_END_DOF)=STATE_DATA(STATE_START_DOF:STATE_END_DOF)+ &
                        & TIME_INCREMENT*RATES(1:NUMBER_STATES)
                    ELSE
                      localError="CellML environment model is not associated for model index "// &
                        & TRIM(NumberToVString(ONLY_ONE_MODEL_INDEX,"*",err,error))//" belonging to dof index "// &
                        & TRIM(NumberToVString(dof_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    localError="Invalid CellML model index: "// &
                      & TRIM(NumberToVString(model_idx,"*",err,error))//". The specified index should be between 1 and "// &
                      & TRIM(NumberToVString(CELLML%NUMBER_OF_MODELS,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ENDDO !dof_idx
                TIME=TIME+TIME_INCREMENT
              ENDDO !time              
            ELSE
              !One one model is used.
              MODEL=>CELLML%MODELS(ONLY_ONE_MODEL_INDEX)%ptr
              IF(ASSOCIATED(MODEL)) THEN
                NUMBER_STATES=MODEL%NUMBER_OF_STATE
                NUMBER_INTERMEDIATES=MODEL%NUMBER_OF_INTERMEDIATE
                NUMBER_PARAMETERS=MODEL%NUMBER_OF_PARAMETERS
#ifdef WITH_CELLML                    

                !Call RHS. Note some models might not have state, rates, intermediate or parameter data so call accordingly
                !to avoid referencing null pointers
                IF(NUMBER_STATES>0) THEN
                  IF(NUMBER_INTERMEDIATES>0) THEN
                    IF(NUMBER_PARAMETERS>0) THEN
                      !We have states, intermediate and parameters for the model
                      
                      TIME=START_TIME
                      DO WHILE(TIME<=END_TIME)
                        DO dof_idx=1,N
                          model_idx=MODELS_DATA(dof_idx)
                          IF(model_idx.GT.0) THEN

                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                            PARAMETER_START_DOF=(dof_idx-1)*MAX_NUMBER_PARAMETERS+1
                            PARAMETER_END_DOF=PARAMETER_START_DOF+NUMBER_PARAMETERS-1
                    
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,TIME, &
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF),PARAMETERS_DATA( &
                              & PARAMETER_START_DOF:PARAMETER_END_DOF))
                            
                            STATE_DATA(STATE_START_DOF:STATE_END_DOF)=STATE_DATA(STATE_START_DOF:STATE_END_DOF)+ &
                              & TIME_INCREMENT*RATES(1:NUMBER_STATES)
                          ENDIF !model_idx
                        ENDDO !dof_idx
                        TIME=TIME+TIME_INCREMENT
                      ENDDO !time
                    ELSE
                      !We do not have parameters in the model
                      TIME=START_TIME
                      DO WHILE(TIME<=END_TIME)
                        DO dof_idx=1,N
                          model_idx=MODELS_DATA(dof_idx)
                          IF(model_idx.GT.0) THEN

                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            INTERMEDIATE_START_DOF=(dof_idx-1)*MAX_NUMBER_INTERMEDIATES+1
                            INTERMEDIATE_END_DOF=INTERMEDIATE_START_DOF+NUMBER_INTERMEDIATES-1
                    
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,TIME, & 
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATE_DATA(INTERMEDIATE_START_DOF:INTERMEDIATE_END_DOF),PARAMETERS)
                             
                            STATE_DATA(STATE_START_DOF:STATE_END_DOF)=STATE_DATA(STATE_START_DOF:STATE_END_DOF)+ &
                              & TIME_INCREMENT*RATES(1:NUMBER_STATES)
                          ENDIF !model_idx
                        ENDDO !dof_idx
                        TIME=TIME+TIME_INCREMENT
                      ENDDO !time
                    ENDIF                      
                  ELSE
                    IF(NUMBER_PARAMETERS>0) THEN
                      !We do not have intermediates in the model
                      
                      TIME=START_TIME
                      DO WHILE(TIME<=END_TIME)
                        DO dof_idx=1,N
                          model_idx=MODELS_DATA(dof_idx)
                          IF(model_idx.GT.0) THEN

                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                            PARAMETER_START_DOF=(dof_idx-1)*MAX_NUMBER_PARAMETERS+1
                            PARAMETER_END_DOF=PARAMETER_START_DOF+NUMBER_PARAMETERS-1
                    
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,TIME, & 
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATES,PARAMETERS_DATA(PARAMETER_START_DOF:PARAMETER_END_DOF))
                            
                            STATE_DATA(STATE_START_DOF:STATE_END_DOF)=STATE_DATA(STATE_START_DOF:STATE_END_DOF)+ &
                              & TIME_INCREMENT*RATES(1:NUMBER_STATES)
                          ENDIF !model_idx
                        ENDDO !dof_idx
                        TIME=TIME+TIME_INCREMENT
                      ENDDO !time
                    ELSE
                      !We do not have intermediates or parameters in the model
                      TIME=START_TIME
                      DO WHILE(TIME<=END_TIME)
                        DO dof_idx=1,N
                          model_idx=MODELS_DATA(dof_idx)
                          IF(model_idx.GT.0) THEN

                            STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                            STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                     
                            CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(MODEL%ptr,TIME, & 
                              & STATE_DATA(STATE_START_DOF:STATE_END_DOF), &
                              & RATES,INTERMEDIATES,PARAMETERS)
                            
                            STATE_DATA(STATE_START_DOF:STATE_END_DOF)=STATE_DATA(STATE_START_DOF:STATE_END_DOF)+ &
                              & TIME_INCREMENT*RATES(1:NUMBER_STATES)
                          ENDIF !model_idx
                        ENDDO !dof_idx
                        TIME=TIME+TIME_INCREMENT
                      ENDDO !time
                    ENDIF
                  ENDIF
                ELSE
                  CALL FlagError("Invalid CellML model for integration - there are no states.",err,error,*999)
                ENDIF

#else
                CALL FlagError("Must compile with WITH_CELLML ON to use CellML functionality.",err,error,*999)
#endif
                    
              ELSE
                localError="CellML environment model is not associated for model index "// &
                  & TRIM(NumberToVString(ONLY_ONE_MODEL_INDEX,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ENDIF
          ENDIF
        ELSE
          CALL FlagError("CellML environment models field is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("CellML environment is not associated.",err,error,*999)
      ENDIF      
    ELSE
      CALL FlagError("Forward Euler solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_DAE_EULER_FORWARD_INTEGRATE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_FORWARD_INTEGRATE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_FORWARD_INTEGRATE

  !
  !================================================================================================================================
  !

  !>Solve using a forward Euler differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_EULER_FORWARD_SOLVE(FORWARD_EULER_SOLVER,err,error,*)

    !Argument variables
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: FORWARD_EULER_SOLVER !<A pointer the forward Euler differential-algebraic equation solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: cellml_idx
    INTEGER(INTG), POINTER :: MODELS_DATA(:)
    REAL(DP), POINTER :: INTERMEDIATE_DATA(:),PARAMETERS_DATA(:),STATE_DATA(:)
    TYPE(CELLML_TYPE), POINTER :: CELLML_ENVIRONMENT
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: CELLML_MODELS_FIELD
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_SOLVER
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: MODELS_VARIABLE
    TYPE(FIELD_TYPE), POINTER :: MODELS_FIELD,STATE_FIELD,PARAMETERS_FIELD,INTERMEDIATE_FIELD
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_DAE_EULER_FORWARD_SOLVE",err,error,*999)

    NULLIFY(MODELS_DATA)
    NULLIFY(INTERMEDIATE_DATA)
    NULLIFY(PARAMETERS_DATA)
    NULLIFY(STATE_DATA)
    NULLIFY(MODELS_VARIABLE)
    NULLIFY(MODELS_FIELD)
    NULLIFY(STATE_FIELD)
    NULLIFY(PARAMETERS_FIELD)
    NULLIFY(INTERMEDIATE_FIELD)

    IF(ASSOCIATED(FORWARD_EULER_SOLVER)) THEN
      EULER_SOLVER=>FORWARD_EULER_SOLVER%EULER_DAE_SOLVER
      IF(ASSOCIATED(EULER_SOLVER)) THEN
        DAE_SOLVER=>EULER_SOLVER%DAE_SOLVER
        IF(ASSOCIATED(DAE_SOLVER)) THEN
          SOLVER=>DAE_SOLVER%SOLVER
          IF(ASSOCIATED(SOLVER)) THEN
            CELLML_EQUATIONS=>SOLVER%CELLML_EQUATIONS
            IF(ASSOCIATED(CELLML_EQUATIONS)) THEN
              DO cellml_idx=1,CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS
                CELLML_ENVIRONMENT=>CELLML_EQUATIONS%CELLML_ENVIRONMENTS(cellml_idx)%ptr
                IF(ASSOCIATED(CELLML_ENVIRONMENT)) THEN                  
                  CELLML_MODELS_FIELD=>CELLML_ENVIRONMENT%MODELS_FIELD
                  IF(ASSOCIATED(CELLML_MODELS_FIELD)) THEN
                    MODELS_FIELD=>CELLML_MODELS_FIELD%MODELS_FIELD
                    IF(ASSOCIATED(MODELS_FIELD)) THEN

!!TODO: Maybe move this getting of fields earlier up the DAE solver chain? For now keep here.
                      
                      !Make sure CellML fields have been updated to the current value of any mapped fields
                      CALL CELLML_FIELD_TO_CELLML_UPDATE(CELLML_ENVIRONMENT,err,error,*999)

                      CALL Field_VariableGet(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,MODELS_VARIABLE,err,error,*999)
                      CALL Field_ParameterSetDataGet(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                        & MODELS_DATA,err,error,*999)
                      
                      !Get the state information if this environment has any.
                      IF(ASSOCIATED(CELLML_ENVIRONMENT%STATE_FIELD)) THEN
                        STATE_FIELD=>CELLML_ENVIRONMENT%STATE_FIELD%STATE_FIELD
                        IF(ASSOCIATED(STATE_FIELD)) THEN
                          CALL Field_ParameterSetDataGet(STATE_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                            & STATE_DATA,err,error,*999)
                        ENDIF
                      ENDIF
                      
                      !Get the parameters information if this environment has any.
                      IF(ASSOCIATED(CELLML_ENVIRONMENT%PARAMETERS_FIELD)) THEN
                        PARAMETERS_FIELD=>CELLML_ENVIRONMENT%PARAMETERS_FIELD%PARAMETERS_FIELD
                        IF(ASSOCIATED(PARAMETERS_FIELD)) THEN
                          CALL Field_ParameterSetDataGet(PARAMETERS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                            & PARAMETERS_DATA,err,error,*999)
                        ENDIF
                      ENDIF
                      
                      !Get the intermediate information if this environment has any.
                      IF(ASSOCIATED(CELLML_ENVIRONMENT%INTERMEDIATE_FIELD)) THEN
                        INTERMEDIATE_FIELD=>CELLML_ENVIRONMENT%INTERMEDIATE_FIELD%INTERMEDIATE_FIELD
                        IF(ASSOCIATED(INTERMEDIATE_FIELD)) THEN
                          CALL Field_ParameterSetDataGet(INTERMEDIATE_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                            & INTERMEDIATE_DATA,err,error,*999)                            
                        ENDIF
                      ENDIF

                      !Integrate these CellML equations
                      CALL SOLVER_DAE_EULER_FORWARD_INTEGRATE(FORWARD_EULER_SOLVER,CELLML_ENVIRONMENT,MODELS_VARIABLE% &
                        & TOTAL_NUMBER_OF_DOFS,DAE_SOLVER%START_TIME,DAE_SOLVER%END_TIME,DAE_SOLVER%INITIAL_STEP, &
                        & CELLML_ENVIRONMENT%MODELS_FIELD%ONLY_ONE_MODEL_INDEX,MODELS_DATA,CELLML_ENVIRONMENT% &
                        & MAXIMUM_NUMBER_OF_STATE,STATE_DATA,CELLML_ENVIRONMENT%MAXIMUM_NUMBER_OF_PARAMETERS, &
                        & PARAMETERS_DATA,CELLML_ENVIRONMENT%MAXIMUM_NUMBER_OF_INTERMEDIATE,INTERMEDIATE_DATA,err,error,*999)
                      
                      !Restore field data
                      CALL Field_ParameterSetDataRestore(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                        & MODELS_DATA,err,error,*999)
                      IF(ASSOCIATED(STATE_FIELD)) CALL Field_ParameterSetDataRestore(STATE_FIELD,FIELD_U_VARIABLE_TYPE, &
                        & FIELD_VALUES_SET_TYPE,STATE_DATA,err,error,*999)                    
                      IF(ASSOCIATED(PARAMETERS_FIELD)) CALL Field_ParameterSetDataRestore(PARAMETERS_FIELD, &
                        & FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,PARAMETERS_DATA,err,error,*999)                    
                      IF(ASSOCIATED(INTERMEDIATE_FIELD)) CALL Field_ParameterSetDataRestore(INTERMEDIATE_FIELD, &
                        & FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,INTERMEDIATE_DATA,err,error,*999)
                      
                      !Make sure fields have been updated to the current value of any mapped CellML fields
                      CALL CELLML_CELLML_TO_FIELD_UPDATE(CELLML_ENVIRONMENT,err,error,*999)
                      
                    ELSE
                      localError="The CellML models field is not associated for CellML index "// &
                        & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    localError="The CellML models field is not associated for CellML index "// &
                      & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The CellML enviroment is not associated for for CellML index "// &
                    & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ENDDO !cellml_idx
            ELSE
              CALL FlagError("Solver solver equations is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Euler differential-algebraic equation solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Forward Euler differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_FORWARD_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_FORWARD_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_FORWARD_SOLVE

  !
  !================================================================================================================================
  !

  !>Finalise an improved Euler differential-algebaic equation and deallocate all memory.
  SUBROUTINE SOLVER_DAE_EULER_IMPROVED_FINALISE(IMPROVED_EULER_SOLVER,err,error,*)

    !Argument variables
    TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: IMPROVED_EULER_SOLVER !<A pointer the improved Euler differential-algebraic equation solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
     
    ENTERS("SOLVER_DAE_EULER_IMPROVED_FINALISE",err,error,*999)

    IF(ASSOCIATED(IMPROVED_EULER_SOLVER)) THEN
      DEALLOCATE(IMPROVED_EULER_SOLVER)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_IMPROVED_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_IMPROVED_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_IMPROVED_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise an improved Euler solver for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_EULER_IMPROVED_INITIALISE(EULER_DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_DAE_SOLVER !<A pointer the Euler differential-algebraic equation solver to initialise an improved Euler solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_DAE_EULER_IMPROVED_INITIALISE",err,error,*998)

    IF(ASSOCIATED(EULER_DAE_SOLVER)) THEN
      IF(ASSOCIATED(EULER_DAE_SOLVER%IMPROVED_EULER_SOLVER)) THEN
        CALL FlagError("Improved Euler solver is already associated for this Euler differential-algebraic equation solver.", &
          & err,error,*998)
      ELSE
        !Allocate the improved Euler solver
        ALLOCATE(EULER_DAE_SOLVER%IMPROVED_EULER_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate improved Euler solver.",err,error,*999)
        !Initialise
        EULER_DAE_SOLVER%IMPROVED_EULER_SOLVER%EULER_DAE_SOLVER=>EULER_DAE_SOLVER
        EULER_DAE_SOLVER%IMPROVED_EULER_SOLVER%SOLVER_LIBRARY=0
        !Defaults
      ENDIF      
    ELSE
      CALL FlagError("Euler differential-algebraic equation solver is not associated.",err,error,*998)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_IMPROVED_INITIALISE")
    RETURN
999 CALL SOLVER_DAE_EULER_IMPROVED_FINALISE(EULER_DAE_SOLVER%IMPROVED_EULER_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_DAE_EULER_IMPROVED_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_IMPROVED_INITIALISE

  !
  !================================================================================================================================
  !

  !>Solve using an improved Euler differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_EULER_IMPROVED_SOLVE(IMPROVED_EULER_SOLVER,err,error,*)

    !Argument variables
    TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: IMPROVED_EULER_SOLVER !<A pointer the improved Euler differential-algebraic equation solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_DAE_EULER_IMPROVED_SOLVE",err,error,*999)

    IF(ASSOCIATED(IMPROVED_EULER_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Improved Euler differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_IMPROVED_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_IMPROVED_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_IMPROVED_SOLVE

  !
  !================================================================================================================================
  !

  !>Initialise an Euler solver for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_EULER_INITIALISE(DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer the differential-algebraic equation solver to initialise an Euler solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_DAE_EULER_INITIALISE",err,error,*998)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      IF(ASSOCIATED(DAE_SOLVER%EULER_SOLVER)) THEN
        CALL FlagError("Euler solver is already associated for this differential-algebraic equation solver.",err,error,*998)
      ELSE
        !Allocate the Euler solver
        ALLOCATE(DAE_SOLVER%EULER_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate Euler solver.",err,error,*999)
        !Initialise
        DAE_SOLVER%EULER_SOLVER%DAE_SOLVER=>DAE_SOLVER
        NULLIFY(DAE_SOLVER%EULER_SOLVER%FORWARD_EULER_SOLVER)
        NULLIFY(DAE_SOLVER%EULER_SOLVER%BACKWARD_EULER_SOLVER)
        NULLIFY(DAE_SOLVER%EULER_SOLVER%IMPROVED_EULER_SOLVER)
        !Default to a forward Euler solver
        CALL SOLVER_DAE_EULER_FORWARD_INITIALISE(DAE_SOLVER%EULER_SOLVER,err,error,*999)
        DAE_SOLVER%EULER_SOLVER%EULER_TYPE=SOLVER_DAE_EULER_FORWARD
      ENDIF
    ELSE
      CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*998)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_INITIALISE")
    RETURN
999 CALL SOLVER_DAE_EULER_FINALISE(DAE_SOLVER%EULER_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_DAE_EULER_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_INITIALISE

  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for an Euler differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_EULER_LIBRARY_TYPE_GET(EULER_DAE_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_DAE_SOLVER !<A pointer the differential-algebraic equation Euler solver to get the library type for
    INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On return, the type of library used for the differential-algebraic equation Euler solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: BACKWARD_EULER_DAE_SOLVER
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: FORWARD_EULER_DAE_SOLVER
    TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: IMPROVED_EULER_DAE_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DAE_EULER_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(EULER_DAE_SOLVER)) THEN
      SELECT CASE(EULER_DAE_SOLVER%EULER_TYPE)
      CASE(SOLVER_DAE_EULER_FORWARD)
        FORWARD_EULER_DAE_SOLVER=>EULER_DAE_SOLVER%FORWARD_EULER_SOLVER
        IF(ASSOCIATED(FORWARD_EULER_DAE_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=FORWARD_EULER_DAE_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("The forward Euler differntial-algebraic equations solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_EULER_BACKWARD)
        BACKWARD_EULER_DAE_SOLVER=>EULER_DAE_SOLVER%BACKWARD_EULER_SOLVER
        IF(ASSOCIATED(BACKWARD_EULER_DAE_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=BACKWARD_EULER_DAE_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("The backward Euler differntial-algebraic equations solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_EULER_IMPROVED)
        IMPROVED_EULER_DAE_SOLVER=>EULER_DAE_SOLVER%IMPROVED_EULER_SOLVER
        IF(ASSOCIATED(IMPROVED_EULER_DAE_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=IMPROVED_EULER_DAE_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("The improved Euler differntial-algebraic equations solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The Euler differential-algebraic equations solver type of "// &
          & TRIM(NumberToVString(EULER_DAE_SOLVER%EULER_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Euler DAE solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DAE_EULER_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_LIBRARY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for an Euler differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_EULER_LIBRARY_TYPE_SET(EULER_DAE_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_DAE_SOLVER !<A pointer the Euler differential-algebraic equation solver to set the library type for
    INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library for the Euler differential-algebraic equation solver to set \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: BACKWARD_EULER_DAE_SOLVER
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: FORWARD_EULER_DAE_SOLVER
    TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: IMPROVED_EULER_DAE_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DAE_EULER_LIBRARY_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(EULER_DAE_SOLVER)) THEN
      SELECT CASE(EULER_DAE_SOLVER%EULER_TYPE)
      CASE(SOLVER_DAE_EULER_FORWARD)
        FORWARD_EULER_DAE_SOLVER=>EULER_DAE_SOLVER%FORWARD_EULER_SOLVER
        IF(ASSOCIATED(FORWARD_EULER_DAE_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid for a forward Euler DAE solver."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("The forward Euler differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_EULER_BACKWARD)
        BACKWARD_EULER_DAE_SOLVER=>EULER_DAE_SOLVER%BACKWARD_EULER_SOLVER
        IF(ASSOCIATED(BACKWARD_EULER_DAE_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid for a backward Euler DAE solver."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("The backward Euler differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_EULER_IMPROVED)
        IMPROVED_EULER_DAE_SOLVER=>EULER_DAE_SOLVER%IMPROVED_EULER_SOLVER
        IF(ASSOCIATED(IMPROVED_EULER_DAE_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid for an improved Euler DAE solver."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("The improved Euler differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The Euler differential-algebraic equations solver type of "// &
          & TRIM(NumberToVString(EULER_DAE_SOLVER%EULER_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("The Euler differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DAE_EULER_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_LIBRARY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_LIBRARY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Solve using an Euler differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_EULER_SOLVE(EULER_SOLVER,err,error,*)

    !Argument variables
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_SOLVER !<A pointer the Euler differential-algebraic equation solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DAE_EULER_SOLVE",err,error,*999)

    IF(ASSOCIATED(EULER_SOLVER)) THEN
      SELECT CASE(EULER_SOLVER%EULER_TYPE)
      CASE(SOLVER_DAE_EULER_FORWARD)
        CALL SOLVER_DAE_EULER_FORWARD_SOLVE(EULER_SOLVER%FORWARD_EULER_SOLVER,err,error,*999)
      CASE(SOLVER_DAE_EULER_BACKWARD)
        CALL SOLVER_DAE_EULER_BACKWARD_SOLVE(EULER_SOLVER%BACKWARD_EULER_SOLVER,err,error,*999)
      CASE(SOLVER_DAE_EULER_IMPROVED)
        CALL SOLVER_DAE_EULER_IMPROVED_SOLVE(EULER_SOLVER%IMPROVED_EULER_SOLVER,err,error,*999)
      CASE DEFAULT
        localError="The Euler differential-algebraic equation solver type of "// &
          & TRIM(NumberToVString(EULER_SOLVER%EULER_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Euler differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_SOLVE

  !
  !================================================================================================================================
  !
  
  !>Returns the solve type for an Euler differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_EULER_SOLVER_TYPE_GET(SOLVER,DAE_EULER_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the Euler differential equation solver to get type for 
    INTEGER(INTG), INTENT(OUT) :: DAE_EULER_TYPE !<On return, the type of Euler solver for the Euler differential-algebraic equation to set \see SOLVER_ROUTINES_EulerDAESolverTypes,SOLVER_ROUTINES.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_DAE_SOLVER
     
    ENTERS("SOLVER_DAE_EULER_SOLVER_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        IF(SOLVER%SOLVE_TYPE==SOLVER_DAE_TYPE) THEN
          DAE_SOLVER=>SOLVER%DAE_SOLVER
          IF(ASSOCIATED(DAE_SOLVER)) THEN
            IF(DAE_SOLVER%DAE_SOLVE_TYPE==SOLVER_DAE_EULER) THEN
              EULER_DAE_SOLVER=>DAE_SOLVER%EULER_SOLVER
              IF(ASSOCIATED(EULER_DAE_SOLVER)) THEN
                DAE_EULER_TYPE=EULER_DAE_SOLVER%EULER_TYPE
              ELSE
                CALL FlagError("The differential-algebraic equation solver Euler solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The solver differential-algebraic equation solver is not an Euler differential-algebraic "// &
                & "equation solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver differential-algebraic equation solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a differential-algebraic equation solver.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_SOLVER_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_SOLVER_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_SOLVER_TYPE_GET

  !
  !================================================================================================================================
  !
  
  !>Sets/changes the solve type for an Euler differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_EULER_SOLVER_TYPE_SET(SOLVER,DAE_EULER_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the Euler differential equation solver to set type for 
    INTEGER(INTG), INTENT(IN) :: DAE_EULER_TYPE !<The type of Euler solver for the Euler differential-algebraic equation to set \see SOLVER_ROUTINES_EulerDAESolverTypes,SOLVER_ROUTINES.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_DAE_SOLVER
    TYPE(VARYING_STRING) :: localError
     
    ENTERS("SOLVER_DAE_EULER_SOLVER_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_DAE_TYPE) THEN
          DAE_SOLVER=>SOLVER%DAE_SOLVER
          IF(ASSOCIATED(DAE_SOLVER)) THEN
            IF(DAE_SOLVER%DAE_SOLVE_TYPE==SOLVER_DAE_EULER) THEN
              EULER_DAE_SOLVER=>DAE_SOLVER%EULER_SOLVER
              IF(ASSOCIATED(EULER_DAE_SOLVER)) THEN
                IF(DAE_EULER_TYPE/=EULER_DAE_SOLVER%EULER_TYPE) THEN
                  !Intialise the new Euler differential-algebraic equation solver type
                  SELECT CASE(DAE_EULER_TYPE)
                  CASE(SOLVER_DAE_EULER_FORWARD)
                    CALL SOLVER_DAE_EULER_FORWARD_INITIALISE(EULER_DAE_SOLVER,err,error,*999)
                  CASE(SOLVER_DAE_EULER_BACKWARD)
                    CALL SOLVER_DAE_EULER_BACKWARD_INITIALISE(EULER_DAE_SOLVER,err,error,*999)
                  CASE(SOLVER_DAE_EULER_IMPROVED)
                    CALL SOLVER_DAE_EULER_IMPROVED_INITIALISE(EULER_DAE_SOLVER,err,error,*999)
                  CASE DEFAULT
                    localError="The specified Euler differential-algebraic equation solver type of "// &
                      & TRIM(NumberToVString(DAE_EULER_TYPE,"*",err,error))//" is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                  !Finalise the old Euler differential-algebraic equation solver type
                  SELECT CASE(EULER_DAE_SOLVER%EULER_TYPE)
                  CASE(SOLVER_DAE_EULER_FORWARD)
                    CALL SOLVER_DAE_EULER_FORWARD_FINALISE(EULER_DAE_SOLVER%FORWARD_EULER_SOLVER,err,error,*999)
                  CASE(SOLVER_DAE_EULER_BACKWARD)
                    CALL SOLVER_DAE_EULER_BACKWARD_FINALISE(EULER_DAE_SOLVER%BACKWARD_EULER_SOLVER,err,error,*999)
                  CASE(SOLVER_DAE_EULER_IMPROVED)
                    CALL SOLVER_DAE_EULER_IMPROVED_FINALISE(EULER_DAE_SOLVER%IMPROVED_EULER_SOLVER,err,error,*999)
                  CASE DEFAULT
                    localError="The Euler differential-algebraic equation solver type of "// &
                      & TRIM(NumberToVString(EULER_DAE_SOLVER%EULER_TYPE,"*",err,error))//" is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                  EULER_DAE_SOLVER%EULER_TYPE=DAE_EULER_TYPE
                ENDIF
              ELSE
                CALL FlagError("The differential-algebraic equation solver Euler solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The solver differential-algebraic equation solver is not an Euler differential-algebraic "// &
                & "equation solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver differential-algebraic equation solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a differential-algebraic equation solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_EULER_SOLVER_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EULER_SOLVER_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EULER_SOLVER_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Finalise a differential-algebraic equation solver and deallocate all memory
  SUBROUTINE SOLVER_DAE_FINALISE(DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer the differential-algebraic equation solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_DAE_FINALISE",err,error,*999)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      CALL SOLVER_DAE_EULER_FINALISE(DAE_SOLVER%EULER_SOLVER,err,error,*999)
      CALL SOLVER_DAE_CRANK_NICOLSON_FINALISE(DAE_SOLVER%CRANK_NICOLSON_SOLVER,err,error,*999)
      CALL SOLVER_DAE_RUNGE_KUTTA_FINALISE(DAE_SOLVER%RUNGE_KUTTA_SOLVER,err,error,*999)
      CALL SOLVER_DAE_ADAMS_MOULTON_FINALISE(DAE_SOLVER%ADAMS_MOULTON_SOLVER,err,error,*999)
      CALL SOLVER_DAE_BDF_FINALISE(DAE_SOLVER%BDF_SOLVER,err,error,*999)
      CALL SOLVER_DAE_RUSH_LARSON_FINALISE(DAE_SOLVER%RUSH_LARSON_SOLVER,err,error,*999)
      CALL SOLVER_DAE_EXTERNAL_FINALISE(DAE_SOLVER%EXTERNAL_SOLVER,err,error,*999)
      DEALLOCATE(DAE_SOLVER)
    ENDIF
         
    EXITS("SOLVER_DAE_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a differential-algebraic equation solver for a solver
  SUBROUTINE SOLVER_DAE_INITIALISE(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to initialise the differential-algebraic equation solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("SOLVER_DAE_INITIALISE",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(SOLVER%DAE_SOLVER)) THEN
        CALL FlagError("Differential-algebraic equation solver is already associated for this solver.",err,error,*998)
      ELSE
        !Allocate the differential-algebraic equation solver
        ALLOCATE(SOLVER%DAE_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate solver differential-algebraic equation solver.",err,error,*999)
        !Initialise
        SOLVER%DAE_SOLVER%SOLVER=>SOLVER
        SOLVER%DAE_SOLVER%DAE_TYPE=0
        SOLVER%DAE_SOLVER%DAE_SOLVE_TYPE=0
        SOLVER%DAE_SOLVER%START_TIME=0.0_DP
        SOLVER%DAE_SOLVER%END_TIME=0.1_DP
        SOLVER%DAE_SOLVER%INITIAL_STEP=0.1_DP
        NULLIFY(SOLVER%DAE_SOLVER%EULER_SOLVER)
        NULLIFY(SOLVER%DAE_SOLVER%CRANK_NICOLSON_SOLVER)
        NULLIFY(SOLVER%DAE_SOLVER%RUNGE_KUTTA_SOLVER)
        NULLIFY(SOLVER%DAE_SOLVER%ADAMS_MOULTON_SOLVER)
        NULLIFY(SOLVER%DAE_SOLVER%BDF_SOLVER)
        NULLIFY(SOLVER%DAE_SOLVER%RUSH_LARSON_SOLVER)
        NULLIFY(SOLVER%DAE_SOLVER%EXTERNAL_SOLVER)
        !Default to an Euler differential equation solver
        CALL SOLVER_DAE_EULER_INITIALISE(SOLVER%DAE_SOLVER,err,error,*999)
        SOLVER%DAE_SOLVER%DAE_SOLVE_TYPE=SOLVER_DAE_EULER
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_DAE_INITIALISE")
    RETURN
999 CALL SOLVER_DAE_FINALISE(SOLVER%DAE_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_DAE_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_INITIALISE

  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_LIBRARY_TYPE_GET(DAE_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer the differential-algebraic equation solver to get the library type for
    INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On return, the type of library used for the differential-algebraic equation solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: ADAMS_MOULTON_DAE_SOLVER
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: BDF_DAE_SOLVER
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: CRANK_NICOLSON_DAE_SOLVER
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_DAE_SOLVER
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: RUNGE_KUTTA_DAE_SOLVER
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: RUSH_LARSON_DAE_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DAE_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      SELECT CASE(DAE_SOLVER%DAE_SOLVE_TYPE)
      CASE(SOLVER_DAE_EULER)
        EULER_DAE_SOLVER=>DAE_SOLVER%EULER_SOLVER
        IF(ASSOCIATED(EULER_DAE_SOLVER)) THEN
          CALL SOLVER_DAE_EULER_LIBRARY_TYPE_GET(EULER_DAE_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Euler differential-algebraic solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_CRANK_NICOLSON)
        CRANK_NICOLSON_DAE_SOLVER=>DAE_SOLVER%CRANK_NICOLSON_SOLVER
        IF(ASSOCIATED(CRANK_NICOLSON_DAE_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=CRANK_NICOLSON_DAE_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("The Crank-Nicolson differntial-algebraic equations solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_RUNGE_KUTTA)
        RUNGE_KUTTA_DAE_SOLVER=>DAE_SOLVER%RUNGE_KUTTA_SOLVER
        IF(ASSOCIATED(RUNGE_KUTTA_DAE_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=RUNGE_KUTTA_DAE_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("The Runge-Kutta differntial-algebraic equations solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_ADAMS_MOULTON)
        ADAMS_MOULTON_DAE_SOLVER=>DAE_SOLVER%ADAMS_MOULTON_SOLVER
        IF(ASSOCIATED(ADAMS_MOULTON_DAE_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=ADAMS_MOULTON_DAE_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("The Adams-Moulton differntial-algebraic equations solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_BDF)
        BDF_DAE_SOLVER=>DAE_SOLVER%BDF_SOLVER
        IF(ASSOCIATED(BDF_DAE_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=BDF_DAE_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("The BDF differntial-algebraic equations solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_RUSH_LARSON)
        RUSH_LARSON_DAE_SOLVER=>DAE_SOLVER%RUSH_LARSON_SOLVER
        IF(ASSOCIATED(RUSH_LARSON_DAE_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=RUSH_LARSON_DAE_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("The Rush-Larson differntial-algebraic equations solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_EXTERNAL)
        CALL FlagError("Can not get the solver library for an external differntial-algebraic equations solver.",err,error,*999)
      CASE DEFAULT
        localError="The differential-algebraic equations solver type of "// &
          & TRIM(NumberToVString(DAE_SOLVER%DAE_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("DAE solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DAE_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_LIBRARY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_LIBRARY_TYPE_SET(DAE_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer the differential-algebraic equation solver to set the library type for
    INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library for the differential-algebraic equation solver to set \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: ADAMS_MOULTON_DAE_SOLVER
    TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: BACKWARD_EULER_DAE_SOLVER
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: BDF_DAE_SOLVER
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: CRANK_NICOLSON_DAE_SOLVER
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: EULER_DAE_SOLVER
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: FORWARD_EULER_DAE_SOLVER
    TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: IMPROVED_EULER_DAE_SOLVER
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: RUNGE_KUTTA_DAE_SOLVER
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: RUSH_LARSON_DAE_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DAE_LIBRARY_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      SELECT CASE(DAE_SOLVER%DAE_SOLVE_TYPE)
      CASE(SOLVER_DAE_EULER)
        EULER_DAE_SOLVER=>DAE_SOLVER%EULER_SOLVER
        IF(ASSOCIATED(EULER_DAE_SOLVER)) THEN
          SELECT CASE(EULER_DAE_SOLVER%EULER_TYPE)
          CASE(SOLVER_DAE_EULER_FORWARD)
            FORWARD_EULER_DAE_SOLVER=>EULER_DAE_SOLVER%FORWARD_EULER_SOLVER
            IF(ASSOCIATED(FORWARD_EULER_DAE_SOLVER)) THEN
              SELECT CASE(SOLVER_LIBRARY_TYPE)
              CASE(SOLVER_CMISS_LIBRARY)
                FORWARD_EULER_DAE_SOLVER%SOLVER_LIBRARY=SOLVER_CMISS_LIBRARY
              CASE(SOLVER_PETSC_LIBRARY)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              CALL FlagError("The forward Euler differential-algebraic equation solver is not associated.",err,error,*999)
            ENDIF
          CASE(SOLVER_DAE_EULER_BACKWARD)
            BACKWARD_EULER_DAE_SOLVER=>EULER_DAE_SOLVER%BACKWARD_EULER_SOLVER
            IF(ASSOCIATED(BACKWARD_EULER_DAE_SOLVER)) THEN
              SELECT CASE(SOLVER_LIBRARY_TYPE)
              CASE(SOLVER_CMISS_LIBRARY)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(SOLVER_PETSC_LIBRARY)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              CALL FlagError("The backward Euler differential-algebraic equation solver is not associated.",err,error,*999)
            ENDIF
          CASE(SOLVER_DAE_EULER_IMPROVED)
            IMPROVED_EULER_DAE_SOLVER=>EULER_DAE_SOLVER%IMPROVED_EULER_SOLVER
            IF(ASSOCIATED(IMPROVED_EULER_DAE_SOLVER)) THEN
              SELECT CASE(SOLVER_LIBRARY_TYPE)
              CASE(SOLVER_CMISS_LIBRARY)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(SOLVER_PETSC_LIBRARY)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              CALL FlagError("The improved Euler differential-algebraic equation solver is not associated.",err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The Euler differential-algebraic equations solver type of "// &
              & TRIM(NumberToVString(EULER_DAE_SOLVER%EULER_TYPE,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("The Euler differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_CRANK_NICOLSON)
        CRANK_NICOLSON_DAE_SOLVER=>DAE_SOLVER%CRANK_NICOLSON_SOLVER
        IF(ASSOCIATED(CRANK_NICOLSON_DAE_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("The Crank-Nicolson differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_RUNGE_KUTTA)
        RUNGE_KUTTA_DAE_SOLVER=>DAE_SOLVER%RUNGE_KUTTA_SOLVER
        IF(ASSOCIATED(RUNGE_KUTTA_DAE_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("The Runge-Kutta differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_ADAMS_MOULTON)
        ADAMS_MOULTON_DAE_SOLVER=>DAE_SOLVER%ADAMS_MOULTON_SOLVER
        IF(ASSOCIATED(ADAMS_MOULTON_DAE_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("The Adams-Moulton differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_BDF)
        BDF_DAE_SOLVER=>DAE_SOLVER%BDF_SOLVER
        IF(ASSOCIATED(BDF_DAE_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            BDF_DAE_SOLVER%SOLVER_LIBRARY = SOLVER_PETSC_LIBRARY
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("The BDF differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_RUSH_LARSON)
        RUSH_LARSON_DAE_SOLVER=>DAE_SOLVER%RUSH_LARSON_SOLVER
        IF(ASSOCIATED(RUSH_LARSON_DAE_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("The Rush-Larson differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_EXTERNAL)
        CALL FlagError("Can not set the library type for an external differential-algebraic equation solver is not associated.", &
          & err,error,*999)
      CASE DEFAULT
        localError="The differential-algebraic equations solver type of "// &
          & TRIM(NumberToVString(DAE_SOLVER%DAE_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("DAE solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DAE_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_LIBRARY_TYPE_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DAE_LIBRARY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Finalise a BDF differential-algebraic equation solver and deallocate all memory.
  SUBROUTINE SOLVER_DAE_BDF_FINALISE(BDF_SOLVER,err,error,*)

    !Argument variables
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: BDF_SOLVER !<A pointer the BDF differential-algebraic equation solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
     
    ENTERS("SOLVER_DAE_BDF_FINALISE",err,error,*999)

    IF(ASSOCIATED(BDF_SOLVER)) THEN
      DEALLOCATE(BDF_SOLVER)
    ENDIF
         
    EXITS("SOLVER_DAE_BDF_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_BDF_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_BDF_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a BDF solver for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_BDF_INITIALISE(DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer the differential-algebraic equation solver to initialise a BDF solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_DAE_BDF_INITIALISE",err,error,*998)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      IF(ASSOCIATED(DAE_SOLVER%BDF_SOLVER)) THEN
        CALL FlagError("BDF solver is already associated for this differential-algebraic equation solver.",err,error,*998)
      ELSE
        !Allocate the BDF solver
        ALLOCATE(DAE_SOLVER%BDF_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate BDF solver.",err,error,*999)
        !Initialise
        DAE_SOLVER%BDF_SOLVER%DAE_SOLVER=>DAE_SOLVER
        DAE_SOLVER%BDF_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
        !Defaults
      ENDIF      
    ELSE
      CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*998)
    ENDIF
         
    EXITS("SOLVER_DAE_BDF_INITIALISE")
    RETURN
999 CALL SOLVER_DAE_BDF_FINALISE(DAE_SOLVER%BDF_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_DAE_BDF_INITIALISE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DAE_BDF_INITIALISE
  !
  !================================================================================================================================
  !

  !>Finalise a CellML PETSc solver context.
  SUBROUTINE Solver_DAECellMLPETScContextFinalise(ctx,err,error,*)

    !Argument variables
    TYPE(CellMLPETScContextType), POINTER :: ctx !<A pointer the CellML-PETSc solver context to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Solver_DAECellMLPETScContextFinalise",err,error,*999)

    IF(ASSOCIATED(ctx)) THEN
      IF(ASSOCIATED(ctx%rates)) DEALLOCATE(ctx%rates)
      IF(ALLOCATED(ctx%ratesIndices)) DEALLOCATE(ctx%ratesIndices)
      DEALLOCATE(ctx)
    ENDIF
         
    EXITS("Solver_DAECellMLPETScContextFinalise")
    RETURN
999 ERRORSEXITS("Solver_DAECellMLPETScContextFinalise",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_DAECellMLPETScContextFinalise


  !
  !================================================================================================================================
  !

  !>Initialise a CellML PETSc context
  SUBROUTINE Solver_DAECellMLPETScContextInitialise(ctx,err,error,*)

    !Argument variables
    TYPE(CellMLPETScContextType), INTENT(OUT), POINTER :: ctx !<A pointer to CellML PETSc context to initialise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("Solver_DAECellMLPETScContextInitialise",err,error,*998)

    IF(ASSOCIATED(ctx)) THEN
      CALL FlagError("Context is already associated.",err,error,*998)
    ELSE
      !Allocate the CTX
      ALLOCATE(ctx,STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate context.",err,error,*999)
      !Initialise
      NULLIFY(ctx%solver)
      NULLIFY(ctx%cellml)
      NULLIFY(ctx%rates)
      ctx%dofIdx=0
    ENDIF
         
    EXITS("Solver_DAECellMLPETScContextInitialise")
    RETURN
999 CALL Solver_DAECellMLPETScContextFinalise(ctx,dummyErr,dummyError,*998)
998 ERRORSEXITS("Solver_DAECellMLPETScContextInitialise",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_DAECellMLPETScContextInitialise
  !
  !================================================================================================================================
  !

  !>Set a CellML PETSc context
  SUBROUTINE Solver_DAECellMLPETScContextSet(ctx,solver,cellml,dofIdx,err,error,*)

    !Argument variables
    TYPE(CellMLPETScContextType), INTENT(IN), POINTER :: ctx !<A pointer to initialise a CELLML_PETSC_CONTEXT
    TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: solver !<A pointer to the solver to set to ctx
    TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: cellml !<A pointer to the CellML environment to set to ctx
    INTEGER(INTG), INTENT(IN) :: dofIdx !<The DOF index of the cellml-petsc context
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: arrayIdx,dummyErr
    TYPE(VARYING_STRING) :: dummyError
   
    ENTERS("Solver_DAECellMLPETScContextSet",err,error,*998)

    IF(ASSOCIATED(ctx)) THEN
      IF(ASSOCIATED(solver)) THEN
        IF(ASSOCIATED(cellml)) THEN
          !Set
          ctx%solver=>solver
          ctx%cellml=>cellml
          ctx%dofIdx=dofIdx
          ALLOCATE(ctx%rates(cellml%MAXIMUM_NUMBER_OF_STATE),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate context rates.",err,error,*999)
          IF (.NOT. ALLOCATED(ctx%ratesIndices)) THEN
            ALLOCATE(ctx%ratesIndices(cellml%MAXIMUM_NUMBER_OF_STATE),STAT=err)
          ENDIF
          IF(err/=0) CALL FlagError("Could not allocate context rates indicies.",err,error,*999)
          ctx%ratesIndices=[(arrayIdx,arrayIdx=0,(cellml%MAXIMUM_NUMBER_OF_STATE-1))]
        ELSE
          CALL FlagError("CellML environment is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver is not associated.",err,error,*998)
      ENDIF      
    ELSE
      CALL FlagError("ctx is not associated.",err,error,*998)
    ENDIF
         
    EXITS("Solver_DAECellMLPETScContextSet")
    RETURN
999 CALL Solver_DAECellMLPETScContextFinalise(ctx,dummyErr,dummyError,*998)
998 ERRORSEXITS("Solver_DAECellMLPETScContextSet",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_DAECellMLPETScContextSet

  !
  !================================================================================================================================
  !
  !>Integrate using a BDF differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_BDF_INTEGRATE(BDF_SOLVER,CELLML,N,START_TIME,END_TIME,TIME_INCREMENT, &
    & ONLY_ONE_MODEL_INDEX,MODELS_DATA,MAX_NUMBER_STATES,STATE_DATA,MAX_NUMBER_PARAMETERS,PARAMETERS_DATA, &
    & MAX_NUMBER_INTERMEDIATES,INTERMEDIATE_DATA,err,error,*)

    !Argument variables
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: BDF_SOLVER !<A pointer the BDF differential-algebraic equation solver to integrate
    TYPE(CELLML_TYPE), POINTER :: CELLML !<A pointer to the CellML environment to integrate the equations for.
    INTEGER(INTG), INTENT(IN) :: N !<The number of degrees-of-freedom
    REAL(DP), INTENT(IN) :: START_TIME !<The start time for the integration
    REAL(DP), INTENT(IN) :: END_TIME !<The end time for the integration
    REAL(DP), INTENT(INOUT) :: TIME_INCREMENT !<The (initial) time increment for the integration
    INTEGER(INTG), INTENT(IN) :: ONLY_ONE_MODEL_INDEX !<If only one model is used in the models data the index of that model. 0 otherwise.
    INTEGER(INTG), POINTER, INTENT(IN) :: MODELS_DATA(:) !<MODELS_DATA(dof_idx). The models data for the dof_idx'th dof.
    INTEGER(INTG), INTENT(IN) :: MAX_NUMBER_STATES !<The maximum number of state variables per dof
    REAL(DP), POINTER, INTENT (INOUT) :: STATE_DATA(:) !<STATE_DATA(state_idx,dof_idx). The state data for the state_idx'th state variable of the dof_idx'th dof. state_idx varies from 1..NUMBER_STATES.
    INTEGER(INTG), INTENT(IN) :: MAX_NUMBER_PARAMETERS !<The maximum number of parameter variables per dof.
    REAL(DP), POINTER, INTENT(INOUT) :: PARAMETERS_DATA(:) !<PARAMETERS_DATA(parameter_idx,dof_idx). The parameters data for the parameter_idx'th parameter variable of the dof_idx'th dof. parameter_idx varies from 1..NUMBER_PARAMETERS.
    INTEGER(INTG), INTENT(IN) :: MAX_NUMBER_INTERMEDIATES !<The maximum number of intermediate variables per dof.
    REAL(DP), POINTER, INTENT(INOUT) :: INTERMEDIATE_DATA(:) !<INTERMEDIATE_DATA(intermediate_idx,dof_idx). The intermediate values data for the intermediate_idx'th intermediate variable of the dof_idx'th dof. intermediate_idx varies from 1.NUMBER_INTERMEDIATE    
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(PetscTSType) :: ts !<The PETSc TS type
    REAL(DP) :: FINALSOLVEDTIME,TIMESTEP
    TYPE(PetscVecType) :: PETSC_CURRENT_STATES !<The initial and final states for the DAE
    TYPE(CellMLPETScContextType), POINTER :: CTX !<The passed through context
    INTEGER(INTG) :: dof_idx,DOF_ORDER_TYPE,model_idx, NUMBER_STATES,STATE_END_DOF,state_idx,STATE_START_DOF,array_idx
    REAL(DP), ALLOCATABLE  :: STATES_TEMP(:),RATES_TEMP(:)
    INTEGER(INTG), ALLOCATABLE :: ARRAY_INDICES(:)
    TYPE(CELLML_MODEL_TYPE), POINTER :: MODEL
    TYPE(VARYING_STRING) :: localError
    TYPE(PetscVecType) :: PETSC_RATES
    EXTERNAL :: Problem_SolverDAECellMLRHSPetsc
  
    
    ENTERS("SOLVER_DAE_BDF_INTEGRATE",err,error,*999)

    NULLIFY(CTX)
    TIMESTEP=END_TIME-START_TIME
    IF(ASSOCIATED(BDF_SOLVER)) THEN
      IF(ASSOCIATED(CELLML)) THEN
        IF(ASSOCIATED(CELLML%MODELS_FIELD)) THEN
          SELECT CASE(BDF_SOLVER%SOLVER_LIBRARY)   
          CASE(SOLVER_PETSC_LIBRARY)
            CALL FIELD_DOF_ORDER_TYPE_GET(CELLML%MODELS_FIELD%MODELS_FIELD, & 
              & FIELD_U_VARIABLE_TYPE,DOF_ORDER_TYPE,err,error,*999)
            IF(DOF_ORDER_TYPE==FIELD_SEPARATED_COMPONENT_DOF_ORDER) THEN
              
            ELSE !dof component order is contiguous
              IF(ONLY_ONE_MODEL_INDEX==CELLML_MODELS_FIELD_NOT_CONSTANT) THEN
                
              ELSE !only one model
                MODEL=>CELLML%MODELS(ONLY_ONE_MODEL_INDEX)%ptr
                IF(ASSOCIATED(MODEL)) THEN
                  !determine no. of states in model and allocate necessary arrays
                  NUMBER_STATES = MODEL%NUMBER_OF_STATE
                  ALLOCATE(STATES_TEMP(0:NUMBER_STATES-1),STAT=err)
                  ALLOCATE(RATES_TEMP(0:NUMBER_STATES-1),STAT=err)
                  ALLOCATE(ARRAY_INDICES(0:NUMBER_STATES-1),STAT=err)
                  ARRAY_INDICES = [(array_idx,array_idx=0,(NUMBER_STATES-1))]
                  
                  
                  !initialize context for petsc solving.
                  CALL Solver_DAECellMLPETScContextInitialise(ctx,err,error,*999)
                  DO dof_idx=1,N     
                    model_idx = MODELS_DATA(dof_idx)
                    IF(model_idx>0) THEN !if model is assigned to dof
                      !access the state field data
                      STATE_START_DOF=(dof_idx-1)*MAX_NUMBER_STATES+1
                      STATE_END_DOF=STATE_START_DOF+NUMBER_STATES-1
                      DO state_idx=1,NUMBER_STATES
                        STATES_TEMP(state_idx-1) = STATE_DATA(STATE_START_DOF+state_idx-1)
                      ENDDO
                      
                      !create PETSC states vector to initialize solver
                      CALL Petsc_VecCreateSeq(PETSC_COMM_SELF, &
                        & NUMBER_STATES,PETSC_CURRENT_STATES,err,error,*999)
                      !CALL Petsc_VecSetSizes(PETSC_CURRENT_STATES, &
                      !  & PETSC_DECIDE,(NUMBER_STATES),err,error,*999)
                      !CALL Petsc_VecSetFromOptions(PETSC_CURRENT_STATES,err,error,*999)
                      
                      !create PETSC rates vector to return values from evaluating rhs routine
                      CALL Petsc_VecCreateSeq(PETSC_COMM_SELF, &
                        & NUMBER_STATES,PETSC_RATES,err,error,*999)
                      !CALL Petsc_VecSetSizes(PETSC_RATES, &
                      !  & PETSC_DECIDE,(NUMBER_STATES),err,error,*999)
                      !CALL Petsc_VecSetFromOptions(PETSC_RATES,err,error,*999)
                      
                      !Set up PETSC TS context for sundials BDF solver
                      CALL Petsc_TSCreate(PETSC_COMM_SELF,ts,err,error,*999)
                      CALL Petsc_TSSetProblemType(ts,PETSC_TS_NONLINEAR,err,error,*999)
                      CALL Petsc_TSSetType(ts,PETSC_TS_SUNDIALS,err,error,*999)
                      CALL Petsc_TSSundialsSetType(ts,PETSC_SUNDIALS_BDF,err,error,*999)
                      CALL Petsc_TSSundialsSetTolerance(ts,0.0000001_DP, &
                        & 0.0000001_DP,err,error,*999)
                      !set the initial solution to the current state
                      CALL Petsc_VecSetValues(PETSC_CURRENT_STATES,(NUMBER_STATES), &
                        & ARRAY_INDICES,STATES_TEMP, &
                        & PETSC_INSERT_VALUES,err,error,*999)
                      CALL Petsc_VecAssemblyBegin(PETSC_CURRENT_STATES,err,error,*999)
                      CALL Petsc_VecAssemblyEnd(PETSC_CURRENT_STATES,err,error,*999)
                      CALL Petsc_TSSetSolution(TS,PETSC_CURRENT_STATES,err,error,*999)
                      
                      !set up the time data
                      CALL Petsc_TSSetInitialTimeStep(ts,START_TIME,TIME_INCREMENT,err,error,*999)
                      CALL Petsc_TSSetDuration(ts,5000,END_TIME,err,error,*999)
                      CALL Petsc_TSSetExactFinalTime(ts,.TRUE.,err,error,*999)
                      
                      IF(DIAGNOSTICS1) THEN
                        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  DAE START TIME = ",START_TIME,err,error,*999)
                        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  DAE END TIME = ",END_TIME,err,error,*999)
                      ENDIF
                      
                      !set rhs function and pass through the cellml model context 
                      CALL Solver_DAECellMLPETScContextSet(ctx,BDF_SOLVER%DAE_SOLVER%SOLVER,cellML,dof_idx,err,error,*999)
                      CALL Petsc_TSSetRHSFunction(TS,PETSC_RATES,Problem_SolverDAECellMLRHSPetsc,CTX,err,error,*999)
                      
                      CALL Petsc_TSSolve(TS,PETSC_CURRENT_STATES,FINALSOLVEDTIME,err,error,*999) 
                      IF(DIAGNOSTICS1) THEN
                        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  FINAL SOLVED TIME = ", &
                          & FINALSOLVEDTIME,err,error,*999)
                      ENDIF
                      
                      
                      !update the states to new integrated values
                      CALL Petsc_VecAssemblyBegin(PETSC_CURRENT_STATES,err,error,*999)
                      CALL Petsc_VecAssemblyEnd(PETSC_CURRENT_STATES,err,error,*999)
                      CALL Petsc_VecGetValues(PETSC_CURRENT_STATES, &
                        & NUMBER_STATES, ARRAY_INDICES, &
                        & STATES_TEMP, &
                        & err,error,*999)
                      
                      DO state_idx=1,NUMBER_STATES                      
                        STATE_DATA(STATE_START_DOF+state_idx-1)=  & 
                          & STATES_TEMP(state_idx-1)
                      ENDDO
                      CALL Petsc_TSFinalise(TS,err,error,*999) 
                    ENDIF !model_idx
                    CALL Petsc_VecDestroy(PETSC_CURRENT_STATES,err,error,*999)
                    CALL Petsc_VecDestroy(PETSC_RATES,err,error,*999)
                  ENDDO !dof_idx
                  
                ELSE
                  CALL FlagError("Cellml model is not associated.",err,error,*999)
                ENDIF
              ENDIF
            ENDIF !dof continguous
          CASE DEFAULT
            localError="The BDF solver library type of  "// &
              & TRIM(NumberToVString(BDF_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is not implemented."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("CELLML models field is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("CELLML environment is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("BDF solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DAE_BDF_INTEGRATE")
    RETURN 
999 ERRORSEXITS("SOLVER_DAE_BDF_INTEGRATE",err,error)
    RETURN 1

  END SUBROUTINE SOLVER_DAE_BDF_INTEGRATE
  !
  !================================================================================================================================
  !

  !>Solve using a BDF differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_BDF_SOLVE(BDF_SOLVER,err,error,*)

    !Argument variables
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: BDF_SOLVER !<A pointer the BDF differential-algebraic equation solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: cellml_idx
    INTEGER(INTG), POINTER :: MODELS_DATA(:)
    REAL(DP), POINTER :: INTERMEDIATE_DATA(:),PARAMETERS_DATA(:),STATE_DATA(:)
    TYPE(CELLML_TYPE), POINTER :: CELLML_ENVIRONMENT
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: CELLML_MODELS_FIELD
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: MODELS_VARIABLE
    TYPE(FIELD_TYPE), POINTER :: MODELS_FIELD,STATE_FIELD,PARAMETERS_FIELD,INTERMEDIATE_FIELD
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DAE_BDF_SOLVE",err,error,*999)

    NULLIFY(MODELS_DATA)
    NULLIFY(INTERMEDIATE_DATA)
    NULLIFY(PARAMETERS_DATA)
    NULLIFY(STATE_DATA)
    NULLIFY(MODELS_VARIABLE)

    IF(ASSOCIATED(BDF_SOLVER)) THEN
      DAE_SOLVER=>BDF_SOLVER%DAE_SOLVER
      IF(ASSOCIATED(DAE_SOLVER)) THEN
        SOLVER=>DAE_SOLVER%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          CELLML_EQUATIONS=>SOLVER%CELLML_EQUATIONS
          IF(ASSOCIATED(CELLML_EQUATIONS)) THEN
            DO cellml_idx=1,CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS
              CELLML_ENVIRONMENT=>CELLML_EQUATIONS%CELLML_ENVIRONMENTS(cellml_idx)%ptr
              IF(ASSOCIATED(CELLML_ENVIRONMENT)) THEN                  
                CELLML_MODELS_FIELD=>CELLML_ENVIRONMENT%MODELS_FIELD
                IF(ASSOCIATED(CELLML_MODELS_FIELD)) THEN
                  MODELS_FIELD=>CELLML_MODELS_FIELD%MODELS_FIELD
                  IF(ASSOCIATED(MODELS_FIELD)) THEN

!!TODO: Maybe move this getting of fields earlier up the DAE solver chain? For now keep here.
                      
                      !Make sure CellML fields have been updated to the current value of any mapped fields
                    CALL CELLML_FIELD_TO_CELLML_UPDATE(CELLML_ENVIRONMENT,err,error,*999)

                    CALL Field_VariableGet(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,MODELS_VARIABLE,err,error,*999)
                    CALL Field_ParameterSetDataGet(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                      & MODELS_DATA,err,error,*999)
                      
                      !Get the state information if this environment has any.
                    IF(ASSOCIATED(CELLML_ENVIRONMENT%STATE_FIELD)) THEN
                      STATE_FIELD=>CELLML_ENVIRONMENT%STATE_FIELD%STATE_FIELD
                      IF(ASSOCIATED(STATE_FIELD)) THEN
                        CALL Field_ParameterSetDataGet(STATE_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                          & STATE_DATA,err,error,*999)
                      ENDIF
                    ENDIF
                      
                    !Get the parameters information if this environment has any.
                    IF(ASSOCIATED(CELLML_ENVIRONMENT%PARAMETERS_FIELD)) THEN
                      PARAMETERS_FIELD=>CELLML_ENVIRONMENT%PARAMETERS_FIELD%PARAMETERS_FIELD
                      IF(ASSOCIATED(PARAMETERS_FIELD)) THEN
                        CALL Field_ParameterSetDataGet(PARAMETERS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                          & PARAMETERS_DATA,err,error,*999)
                      ENDIF
                    ENDIF
                      
                    !Get the intermediate information if this environment has any.
                    IF(ASSOCIATED(CELLML_ENVIRONMENT%INTERMEDIATE_FIELD)) THEN
                      INTERMEDIATE_FIELD=>CELLML_ENVIRONMENT%INTERMEDIATE_FIELD%INTERMEDIATE_FIELD
                      IF(ASSOCIATED(INTERMEDIATE_FIELD)) THEN
                        CALL Field_ParameterSetDataGet(INTERMEDIATE_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                          & INTERMEDIATE_DATA,err,error,*999)                            
                      ENDIF
                    ENDIF
                    
                    !Integrate these CellML equations

                    CALL SOLVER_DAE_BDF_INTEGRATE(BDF_SOLVER,CELLML_ENVIRONMENT,MODELS_VARIABLE% &
                      & TOTAL_NUMBER_OF_DOFS,DAE_SOLVER%START_TIME,DAE_SOLVER%END_TIME,DAE_SOLVER%INITIAL_STEP, &
                      & CELLML_ENVIRONMENT%MODELS_FIELD%ONLY_ONE_MODEL_INDEX,MODELS_DATA,CELLML_ENVIRONMENT% &
                      & MAXIMUM_NUMBER_OF_STATE,STATE_DATA,CELLML_ENVIRONMENT%MAXIMUM_NUMBER_OF_PARAMETERS, &
                      & PARAMETERS_DATA,CELLML_ENVIRONMENT%MAXIMUM_NUMBER_OF_INTERMEDIATE,INTERMEDIATE_DATA,err,error,*999)
                      
                    !Restore field data
                    CALL Field_ParameterSetDataRestore(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                      & MODELS_DATA,err,error,*999)
                    IF(ASSOCIATED(STATE_FIELD)) CALL Field_ParameterSetDataRestore(STATE_FIELD,FIELD_U_VARIABLE_TYPE, &
                      & FIELD_VALUES_SET_TYPE,STATE_DATA,err,error,*999)                    
                    IF(ASSOCIATED(PARAMETERS_FIELD)) CALL Field_ParameterSetDataRestore(PARAMETERS_FIELD, &
                      & FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,PARAMETERS_DATA,err,error,*999)                    
                    IF(ASSOCIATED(INTERMEDIATE_FIELD)) CALL Field_ParameterSetDataRestore(INTERMEDIATE_FIELD, &
                      & FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,INTERMEDIATE_DATA,err,error,*999)
                      
                    !Make sure fields have been updated to the current value of any mapped CellML fields
                    CALL CELLML_CELLML_TO_FIELD_UPDATE(CELLML_ENVIRONMENT,err,error,*999)
                                        
                  ELSE
                    localError="The CellML models field is not associated for CellML index "// &
                      & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The CellML models field is not associated for CellML index "// &
                    & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The CellML enviroment is not associated for for CellML index "// &
                  & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ENDDO !cellml_idx
          ELSE
            CALL FlagError("Solver solver equations is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("BDF differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_BDF_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_BDF_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_BDF_SOLVE
  
  !
  !================================================================================================================================
  !

  !>Finalise a Crank-Nicolson differential-algebraic equation solver and deallocate all memory.
  SUBROUTINE SOLVER_DAE_CRANK_NICOLSON_FINALISE(CRANK_NICOLSON_SOLVER,err,error,*)

    !Argument variables
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: CRANK_NICOLSON_SOLVER !<A pointer the Crank-Nicolson differential-algebraic equation solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
     
    ENTERS("SOLVER_DAE_CRANK_NICOLSON_FINALISE",err,error,*999)

    IF(ASSOCIATED(CRANK_NICOLSON_SOLVER)) THEN
      DEALLOCATE(CRANK_NICOLSON_SOLVER)
    ENDIF
         
    EXITS("SOLVER_DAE_CRANK_NICOLSON_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_CRANK_NICOLSON_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_CRANK_NICOLSON_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a Crank-Nicolson solver for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_CRANK_NICOLSON_INITIALISE(DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer the differential-algebraic equation solver to initialise a Crank-Nicolson solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_DAE_CRANK_NICOLSON_INITIALISE",err,error,*998)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      IF(ASSOCIATED(DAE_SOLVER%CRANK_NICOLSON_SOLVER)) THEN
        CALL FlagError("Crank-Nicolson solver is already associated for this differential-algebraic equation solver.", &
          & err,error,*998)
      ELSE
        !Allocate the Crank-Nicholson solver
        ALLOCATE(DAE_SOLVER%CRANK_NICOLSON_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate Crank-Nicolson solver.",err,error,*999)
        !Initialise
        DAE_SOLVER%CRANK_NICOLSON_SOLVER%DAE_SOLVER=>DAE_SOLVER
        DAE_SOLVER%CRANK_NICOLSON_SOLVER%SOLVER_LIBRARY=0
        !Defaults
      ENDIF      
    ELSE
      CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*998)
    ENDIF
         
    EXITS("SOLVER_DAE_CRANK_NICOLSON_INITIALISE")
    RETURN
999 CALL SOLVER_DAE_CRANK_NICOLSON_FINALISE(DAE_SOLVER%CRANK_NICOLSON_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_DAE_CRANK_NICOLSON_INITIALISE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DAE_CRANK_NICOLSON_INITIALISE

  !
  !================================================================================================================================
  !

  !>Solve using a Crank-Nicolson differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_CRANK_NICOLSON_SOLVE(CRANK_NICOLSON_SOLVER,err,error,*)

    !Argument variables
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: CRANK_NICOLSON_SOLVER !<A pointer the Crank-Nicolson differential-algebraic equation solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_DAE_CRANK_NICOLSON_SOLVE",err,error,*999)

    IF(ASSOCIATED(CRANK_NICOLSON_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Crank-Nicolson differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_CRANK_NICOLSON_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_CRANK_NICOLSON_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_CRANK_NICOLSON_SOLVE
  
  !
  !================================================================================================================================
  !

  !>Finalise an external differential-algebraic equation solver and deallocate all memory.
  SUBROUTINE SOLVER_DAE_EXTERNAL_FINALISE(EXTERNAL_SOLVER,err,error,*)

    !Argument variables
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: EXTERNAL_SOLVER !<A pointer the external differential-algebraic equation solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
     
    ENTERS("SOLVER_DAE_EXTERNAL_FINALISE",err,error,*999)

    IF(ASSOCIATED(EXTERNAL_SOLVER)) THEN
      DEALLOCATE(EXTERNAL_SOLVER)
    ENDIF
         
    EXITS("SOLVER_DAE_EXTERNAL_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EXTERNAL_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EXTERNAL_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise an external solver for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_EXTERNAL_INITIALISE(DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer the differential-algebraic equation solver to initialise an external solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_DAE_EXTERNAL_INITIALISE",err,error,*998)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      IF(ASSOCIATED(DAE_SOLVER%EXTERNAL_SOLVER)) THEN
        CALL FlagError("External solver is already associated for this differential-algebraic equation solver.", &
          & err,error,*998)
      ELSE
        !Allocate the external solver
        ALLOCATE(DAE_SOLVER%EXTERNAL_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate external solver.",err,error,*999)
        !Initialise
        DAE_SOLVER%EXTERNAL_SOLVER%DAE_SOLVER=>DAE_SOLVER
        !Defaults
      ENDIF      
    ELSE
      CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*998)
    ENDIF
         
    EXITS("SOLVER_DAE_EXTERNAL_INITIALISE")
    RETURN
999 CALL SOLVER_DAE_EXTERNAL_FINALISE(DAE_SOLVER%EXTERNAL_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_DAE_EXTERNAL_INITIALISE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DAE_EXTERNAL_INITIALISE

  !
  !================================================================================================================================
  !

  !>Solve using an external differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_EXTERNAL_SOLVE(EXTERNAL_SOLVER,err,error,*)

    !Argument variables
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: EXTERNAL_SOLVER !<A pointer the external differential-algebraic equation solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: cellml_idx
    INTEGER(INTG), POINTER :: MODELS_DATA(:)
    REAL(DP), POINTER :: INTERMEDIATE_DATA(:),PARAMETERS_DATA(:),STATE_DATA(:)
    TYPE(CELLML_TYPE), POINTER :: CELLML_ENVIRONMENT
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: MODELS_VARIABLE
    TYPE(FIELD_TYPE), POINTER :: MODELS_FIELD,STATE_FIELD,PARAMETERS_FIELD,INTERMEDIATE_FIELD
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DAE_EXTERNAL_SOLVE",err,error,*999)

    NULLIFY(MODELS_DATA)
    NULLIFY(INTERMEDIATE_DATA)
    NULLIFY(PARAMETERS_DATA)
    NULLIFY(STATE_DATA)

    IF(ASSOCIATED(EXTERNAL_SOLVER)) THEN
      DAE_SOLVER=>EXTERNAL_SOLVER%DAE_SOLVER
      IF(ASSOCIATED(DAE_SOLVER)) THEN
        SOLVER=>DAE_SOLVER%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          CELLML_EQUATIONS=>SOLVER%CELLML_EQUATIONS
          IF(ASSOCIATED(CELLML_EQUATIONS)) THEN
            DO cellml_idx=1,CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS
              CELLML_ENVIRONMENT=>CELLML_EQUATIONS%CELLML_ENVIRONMENTS(cellml_idx)%ptr
              IF(ASSOCIATED(CELLML_ENVIRONMENT)) THEN
                IF(ASSOCIATED(CELLML_ENVIRONMENT%MODELS_FIELD)) THEN
                  MODELS_FIELD=>CELLML_ENVIRONMENT%MODELS_FIELD%MODELS_FIELD
                  IF(ASSOCIATED(MODELS_FIELD)) THEN
                                           
                    !Make sure CellML fields have been updated to the current value of any mapped fields
                    CALL CELLML_FIELD_TO_CELLML_UPDATE(CELLML_ENVIRONMENT,err,error,*999)

                    NULLIFY(MODELS_VARIABLE)
                    CALL Field_VariableGet(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,MODELS_VARIABLE,err,error,*999)
                    CALL Field_ParameterSetDataGet(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                      & MODELS_DATA,err,error,*999)
                    
                    !Get the state information if this environment has any.
                    IF(ASSOCIATED(CELLML_ENVIRONMENT%STATE_FIELD)) THEN
                      STATE_FIELD=>CELLML_ENVIRONMENT%STATE_FIELD%STATE_FIELD
                      IF(ASSOCIATED(STATE_FIELD)) THEN
                        CALL Field_ParameterSetDataGet(STATE_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                          & STATE_DATA,err,error,*999)
                      ELSE
                        NULLIFY(STATE_DATA)
                      ENDIF
                    ELSE
                      NULLIFY(STATE_DATA)
                    ENDIF
                    
                    !Get the parameters information if this environment has any.
                    IF(ASSOCIATED(CELLML_ENVIRONMENT%PARAMETERS_FIELD)) THEN
                      PARAMETERS_FIELD=>CELLML_ENVIRONMENT%PARAMETERS_FIELD%PARAMETERS_FIELD
                      IF(ASSOCIATED(PARAMETERS_FIELD)) THEN
                        CALL Field_ParameterSetDataGet(PARAMETERS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                          & PARAMETERS_DATA,err,error,*999)
                      ELSE
                        NULLIFY(PARAMETERS_DATA)
                      ENDIF
                    ELSE
                      NULLIFY(PARAMETERS_DATA)
                    ENDIF
                    
                    !Get the intermediate information if this environment has any.
                    IF(ASSOCIATED(CELLML_ENVIRONMENT%INTERMEDIATE_FIELD)) THEN
                      INTERMEDIATE_FIELD=>CELLML_ENVIRONMENT%INTERMEDIATE_FIELD%INTERMEDIATE_FIELD
                      IF(ASSOCIATED(INTERMEDIATE_FIELD)) THEN
                        CALL Field_ParameterSetDataGet(INTERMEDIATE_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                          & INTERMEDIATE_DATA,err,error,*999)                            
                      ELSE
                        NULLIFY(INTERMEDIATE_DATA)
                      ENDIF
                    ELSE
                      NULLIFY(INTERMEDIATE_DATA)
                    ENDIF

                    !Call the external solver to integrate these CellML equations
                    CALL SOLVER_DAE_EXTERNAL_INTEGRATE(MODELS_VARIABLE%TOTAL_NUMBER_OF_DOFS,DAE_SOLVER%START_TIME, &
                      & DAE_SOLVER%END_TIME,DAE_SOLVER%INITIAL_STEP,CELLML_ENVIRONMENT%MODELS_FIELD% &
                      & ONLY_ONE_MODEL_INDEX,MODELS_DATA,CELLML_ENVIRONMENT%MAXIMUM_NUMBER_OF_STATE,STATE_DATA, &
                      & CELLML_ENVIRONMENT%MAXIMUM_NUMBER_OF_PARAMETERS,PARAMETERS_DATA,CELLML_ENVIRONMENT% &
                      & MAXIMUM_NUMBER_OF_INTERMEDIATE,INTERMEDIATE_DATA,ERR)
                    IF(err/=0) THEN
                      ERROR="Error from external solver integrate."
                      GOTO 999
                    ENDIF
                      
                    !Restore field data
                    CALL Field_ParameterSetDataRestore(MODELS_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                      & MODELS_DATA,err,error,*999)                    
                    IF(ASSOCIATED(STATE_FIELD)) CALL Field_ParameterSetDataRestore(STATE_FIELD,FIELD_U_VARIABLE_TYPE, &
                      & FIELD_VALUES_SET_TYPE,STATE_DATA,err,error,*999)                    
                    IF(ASSOCIATED(PARAMETERS_FIELD)) CALL Field_ParameterSetDataRestore(PARAMETERS_FIELD, &
                      & FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,PARAMETERS_DATA,err,error,*999)                    
                    IF(ASSOCIATED(INTERMEDIATE_FIELD)) CALL Field_ParameterSetDataRestore(INTERMEDIATE_FIELD, &
                      & FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,INTERMEDIATE_DATA,err,error,*999)                    
                    
                    !Make sure fields have been updated to the current value of any mapped CellML fields
                    CALL CELLML_CELLML_TO_FIELD_UPDATE(CELLML_ENVIRONMENT,err,error,*999)
                    
                  ELSE
                    localError="The CellML models field is not associated for CellML index "// &
                      & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The CellML models field is not associated for CellML index "// &
                    & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The CellML enviroment is not associated for for CellML index "// &
                  & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ENDDO !cellml_idx
          ELSE
            CALL FlagError("Solver solver equations is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("External Euler differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_EXTERNAL_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_EXTERNAL_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_EXTERNAL_SOLVE
  
  !
  !================================================================================================================================
  !

  !>Integrate using a forward Euler differential-algebraic equation solver.
  SUBROUTINE Solver_DAECellMLRHSEvaluate(model,time,stateStartIdx,stateDataOffset,stateData,parameterStartIdx,parameterDataOffset, &
    & parameterData,intermediateStartIdx,intermediateDataOffset,intermediateData,rateStartIdx,rateDataOffset,rateData,err,error,*)

    !Argument variables
    TYPE(CELLML_MODEL_TYPE), POINTER :: model !<The CellML model to evaluate
    REAL(DP), INTENT(IN) :: time !<The time to evaluate the CellML model at
    INTEGER(INTG), INTENT(IN) :: stateStartIdx !<The state start data offset.
    INTEGER(INTG), INTENT(IN) :: stateDataOffset !<The offset to the next state data
    REAL(DP), POINTER :: stateData(:) !<A pointer to the state data
    INTEGER(INTG), INTENT(IN) :: parameterStartIdx !<The parameter start data offset.
    INTEGER(INTG), INTENT(IN) :: parameterDataOffset !<The offset to the next parameters data
    REAL(DP), POINTER :: parameterData(:) !<A pointer to the parameters data
    INTEGER(INTG), INTENT(IN) :: intermediateStartIdx !<The intermediate start data offset.
    INTEGER(INTG), INTENT(IN) :: intermediateDataOffset !<The offset to the next intermediate data
    REAL(DP), POINTER :: intermediateData(:) !<A pointer to the intermediate data
    INTEGER(INTG), INTENT(IN) :: rateStartIdx !<The rate start data offset.
    INTEGER(INTG), INTENT(IN) :: rateDataOffset !<The offset to the next rates data
    REAL(DP), POINTER :: rateData(:) !<On exit, the rate data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: intermediateIdx,intermediateEndDOF,intermediateStartDOF,numberOfIntermediates,numberOfParameters, &
      & numberOfStates,parameterIdx,parameterEndDOF,parameterStartDOF,rateIdx,rateEndDOF,rateStartDOF,stateIdx,stateEndDOF, &
      & stateStartDOF
    REAL(DP) :: intermediates(MAX(1,intermediateDataOffset)),parameters(MAX(1,parameterDataOffset)),rates(MAX(1,rateDataOffset)), &
      & states(MAX(1,stateDataOffset))
    
    ENTERS("Solver_DAECellMLRHSEvaluate",err,error,*999)

#ifdef WITH_CELLML                    

    IF(ASSOCIATED(model)) THEN
      numberOfStates=model%NUMBER_OF_STATE
      numberOfIntermediates=model%NUMBER_OF_INTERMEDIATE
      numberOfParameters=model%NUMBER_OF_PARAMETERS
      IF(numberOfStates>0) THEN
        IF(.NOT.ASSOCIATED(stateData)) CALL FlagError("State data is not associated.",err,error,*999)
        IF(.NOT.ASSOCIATED(rateData)) CALL FlagError("Rate data is not associated.",err,error,*999)
      ENDIF
      IF(numberOfParameters>0) THEN
        IF(.NOT.ASSOCIATED(parameterData)) CALL FlagError("Parameter data is not associated.",err,error,*999)
      ENDIF
      IF(numberOfIntermediates>0) THEN
        IF(.NOT.ASSOCIATED(intermediateData)) CALL FlagError("Intermediate data is not associated.",err,error,*999)
      ENDIF
      IF(stateDataOffset>1.OR.numberOfStates==0) THEN
        !State data is not contiguous or there are no states
        
        !Copy state data to temporary array
        DO stateIdx=1,numberOfStates
          states(stateIdx)=stateData((stateStartIdx-1)*stateDataOffset+stateIdx)
        ENDDO !stateIdx
        
        IF(parameterDataOffset>1.OR.numberOfParameters==0) THEN
          !Parameter data is not contiguous or there are no parameters
          
          !Copy parameter data to temporary array
          DO parameterIdx=1,numberOfParameters
            parameters(parameterIdx)=parameterData((parameterStartIdx-1)*parameterDataOffset+parameterIdx)
          ENDDO !parameterIdx
          
          IF(intermediateDataOffset>1.OR.numberOfIntermediates==0) THEN
            !Intermediate data is not contiguous or there are no intermediates
            
            IF(rateDataOffset>1.OR.numberOfStates==0) THEN
              !Rates data is not contiguous or there are no rates
                
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,states,rates,intermediates,parameters)          
              
              !Copy intermediate data from temporary array
              DO intermediateIdx=1,numberOfIntermediates
                intermediateData((intermediateStartIdx-1)*intermediateDataOffset+intermediateIdx)=intermediates(intermediateIdx)
              ENDDO !intermediateIdx
              
              !Copy rate data from temporary array
              DO rateIdx=1,numberOfStates
                rateData((rateStartIdx-1)*rateDataOffset+rateIdx)=rates(rateIdx)
              ENDDO !rateIdx
                
            ELSE
              !Rates data is contiguous
              
              rateStartDOF=(rateStartIdx-1)*rateDataOffset+1
              rateEndDOF=rateStartDOF+numberOfStates-1
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,states,rateData(rateStartDOF:rateEndDOF), &
                & intermediates,parameters)          
              
              !Copy intermediate data from temporary array
              DO intermediateIdx=1,numberOfIntermediates
                intermediateData((intermediateStartIdx-1)*intermediateDataOffset+intermediateIdx)=intermediates(intermediateIdx)
              ENDDO !intermediateIdx
              
            ENDIF
            
          ELSE
            !Intermediate data is contiguous
            
            intermediateStartDOF=(intermediateStartIdx-1)*intermediateDataOffset+1
            intermediateEndDOF=intermediateStartDOF+numberOfIntermediates-1
            
            IF(rateDataOffset>1.OR.numberOfStates==0) THEN
              !Rates data is not contiguous or there are no rates
                
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,states,rates, &
                & intermediateData(intermediateStartDOF:intermediateEndDOF),parameters)          
              
              !Copy rate data from temporary array
              DO rateIdx=1,numberOfStates
                rateData((rateStartIdx-1)*rateDataOffset+rateIdx)=rates(rateIdx)
              ENDDO !rateIdx
              
            ELSE
              !Rates data is contiguous
              
              rateStartDOF=(rateStartIdx-1)*rateDataOffset+1
              rateEndDOF=rateStartDOF+numberOfStates-1
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,states,rateData(rateStartDOF:rateEndDOF), &
                & intermediateData(intermediateStartDOF:intermediateEndDOF),parameters)          
              
            ENDIF
          ENDIF
        ELSE
          !Parameters data is contiguous
          
          parameterStartDOF=(parameterStartIdx-1)*parameterDataOffset+1
          parameterEndDOF=parameterStartDOF+numberOfParameters-1
          
          IF(intermediateDataOffset>1.OR.numberOfIntermediates==0) THEN
            !Intermediate data is not contiguous or there are no intermediates
              
            IF(rateDataOffset>1.OR.numberOfStates==0) THEN
              !Rates data is not contiguous or there are no rates
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,states,rates,intermediates, &
                & parameters(parameterStartDOF:parameterEndDOF))     
              
              !Copy intermediate data from temporary array
              DO intermediateIdx=1,numberOfIntermediates
                intermediateData((intermediateStartIdx-1)*intermediateDataOffset+intermediateIdx)=intermediates(intermediateIdx)
              ENDDO !intermediateIdx
                
              !Copy rate data from temporary array
              DO rateIdx=1,numberOfStates
                rateData((rateStartIdx-1)*rateDataOffset+rateIdx)=rates(rateIdx)
              ENDDO !rateIdx
                
            ELSE
              !Rates data is contiguous
                
              rateStartDOF=(rateStartIdx-1)*rateDataOffset+1
              rateEndDOF=rateStartDOF+numberOfStates-1
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,states,rateData(rateStartDOF:rateEndDOF), &
                & intermediates,parameters(parameterStartDOF:parameterEndDOF))          
              
              !Copy intermediate data from temporary array
              DO intermediateIdx=1,numberOfIntermediates
                intermediateData((intermediateStartIdx-1)*intermediateDataOffset+intermediateIdx)=intermediates(intermediateIdx)
              ENDDO !intermediateIdx
              
            ENDIF
                
          ELSE
            !Intermediate data is contiguous
            
            intermediateStartDOF=(intermediateStartIdx-1)*intermediateDataOffset+1
            intermediateEndDOF=intermediateStartDOF+numberOfIntermediates-1
            
            IF(rateDataOffset>1.OR.numberOfStates==0) THEN
              !Rates data is not contiguous or there are no rates
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,states,rates, &
                & intermediateData(intermediateStartDOF:intermediateEndDOF), &
                & parameters(parameterStartDOF:parameterEndDOF))
              
              !Copy rate data from temporary array
              DO rateIdx=1,numberOfStates
                rateData((rateStartIdx-1)*rateDataOffset+rateIdx)=rates(rateIdx)
              ENDDO !rateIdx
              
            ELSE
              !Rates data is contiguous
              
              rateStartDOF=(rateStartIdx-1)*rateDataOffset+1
              rateEndDOF=rateStartDOF+numberOfStates-1
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,states,rateData(rateStartDOF:rateEndDOF), &
                & intermediateData(intermediateStartDOF:intermediateEndDOF), &
                & parameters(parameterStartDOF:parameterEndDOF))
              
            ENDIF
          ENDIF
        ENDIF
      ELSE
        !State data is contiguous

        stateStartDOF=(stateStartIdx-1)*stateDataOffset+1
        stateEndDOF=stateStartDOF+numberOfStates-1
        
        IF(parameterDataOffset>1.OR.numberOfParameters==0) THEN
          !Parameter data is not contiguous or there are no parameters
          
          !Copy parameter data to temporary array
          DO parameterIdx=1,numberOfParameters
            parameters(parameterIdx)=parameterData((parameterStartIdx-1)*parameterDataOffset+parameterIdx)
          ENDDO !parameterIdx
          
          IF(intermediateDataOffset>1.OR.numberOfIntermediates==0) THEN
            !Intermediate data is not contiguous or there are no intermediates
            
            IF(rateDataOffset>1.OR.numberOfStates==0) THEN
              !Rates data is not contiguous or there are no rates
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,stateData(stateStartDOF:stateEndDOF), &
                & rates,intermediates,parameters)          
              
              !Copy intermediate data from temporary array
              DO intermediateIdx=1,numberOfIntermediates
                intermediateData((intermediateStartIdx-1)*intermediateDataOffset+intermediateIdx)=intermediates(intermediateIdx)
              ENDDO !intermediateIdx
              
              !Copy rate data from temporary array
              DO rateIdx=1,numberOfStates
                rateData((rateStartIdx-1)*rateDataOffset+rateIdx)=rates(rateIdx)
              ENDDO !rateIdx
              
            ELSE
              !Rates data is contiguous
              
              rateStartDOF=(rateStartIdx-1)*rateDataOffset+1
              rateEndDOF=rateStartDOF+numberOfStates-1
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,stateData(stateStartDOF:stateEndDOF), &
                & rateData(rateStartDOF:rateEndDOF),intermediates,parameters)          
              
              !Copy intermediate data from temporary array
              DO intermediateIdx=1,numberOfIntermediates
                intermediateData((intermediateStartIdx-1)*intermediateDataOffset+intermediateIdx)=intermediates(intermediateIdx)
              ENDDO !intermediateIdx
              
            ENDIF
            
          ELSE
            !Intermediate data is contiguous
            
            intermediateStartDOF=(intermediateStartIdx-1)*intermediateDataOffset+1
            intermediateEndDOF=intermediateStartDOF+numberOfIntermediates-1
            
            IF(rateDataOffset>1.OR.numberOfStates==0) THEN
              !Rates data is not contiguous or there are no rates
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,stateData(stateStartDOF:stateEndDOF),rates, &
                & intermediateData(intermediateStartDOF:intermediateEndDOF),parameters)          
              
              !Copy rate data from temporary array
              DO rateIdx=1,numberOfStates
                rateData((rateStartIdx-1)*rateDataOffset+rateIdx)=rates(rateIdx)
              ENDDO !rateIdx
              
            ELSE
              !Rates data is contiguous
              
              rateStartDOF=(rateStartIdx-1)*rateDataOffset+1
              rateEndDOF=rateStartDOF+numberOfStates-1
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,stateData(stateStartDOF:stateEndDOF), &
                & rateData(rateStartDOF:rateEndDOF),intermediateData(intermediateStartDOF:intermediateEndDOF), &
                & parameters)
              
            ENDIF
          ENDIF
        ELSE
          !Parameters data is contiguous
          
          parameterStartDOF=(parameterStartIdx-1)*parameterDataOffset+1
          parameterEndDOF=parameterStartDOF+numberOfParameters-1
          
          IF(intermediateDataOffset>1.OR.numberOfIntermediates==0) THEN
            !Intermediate data is not contiguous or there are no intermediates
            
            IF(rateDataOffset>1.OR.numberOfStates==0) THEN
              !Rates data is not contiguous or there are no rates
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,stateData(stateStartDOF:stateEndDOF), &
                & rates,intermediates,parameters(parameterStartDOF:parameterEndDOF))     
              
              !Copy intermediate data from temporary array
              DO intermediateIdx=1,numberOfIntermediates
                intermediateData((intermediateStartIdx-1)*intermediateDataOffset+intermediateIdx)=intermediates(intermediateIdx)
              ENDDO !intermediateIdx
                
              !Copy rate data from temporary array
              DO rateIdx=1,numberOfStates
                rateData((rateStartIdx-1)*rateDataOffset+rateIdx)=rates(rateIdx)
              ENDDO !rateIdx
              
            ELSE
              !Rates data is contiguous
              
              rateStartDOF=(rateStartIdx-1)*rateDataOffset+1
              rateEndDOF=rateStartDOF+numberOfStates-1
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,stateData(stateStartDOF:stateEndDOF), &
                & rateData(rateStartDOF:rateEndDOF),intermediates,parameters(parameterStartDOF:parameterEndDOF))          
              
              !Copy intermediate data from temporary array
              DO intermediateIdx=1,numberOfIntermediates
                intermediateData((intermediateStartIdx-1)*intermediateDataOffset+intermediateIdx)=intermediates(intermediateIdx)
              ENDDO !intermediateIdx
              
            ENDIF
            
          ELSE
            !Intermediate data is contiguous
            
            intermediateStartDOF=(intermediateStartIdx-1)*intermediateDataOffset+1
            intermediateEndDOF=intermediateStartDOF+numberOfIntermediates-1
            
            IF(rateDataOffset>1.OR.numberOfStates==0) THEN
              !Rates data is not contiguous or there are no rates
                
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,stateData(stateStartDOF:stateEndDOF), &
                & rates,intermediateData(intermediateStartDOF:intermediateEndDOF), &
                & parameters(parameterStartDOF:parameterEndDOF))
              
              !Copy rate data from temporary array
              DO rateIdx=1,numberOfStates
                rateData((rateStartIdx-1)*rateDataOffset+rateIdx)=rates(rateIdx)
              ENDDO !rateIdx
              
            ELSE
              !Rates data is contiguous
                
              rateStartDOF=(rateStartIdx-1)*rateDataOffset+1
              rateEndDOF=rateStartDOF+numberOfStates-1
              
              CALL CELLML_MODEL_DEFINITION_CALL_RHS_ROUTINE(model%ptr,time,stateData(stateStartDOF:stateEndDOF), &
                & rateData(rateStartDOF:rateEndDOF),intermediateData(intermediateStartDOF:intermediateEndDOF), &
                & parameters(parameterStartDOF:parameterEndDOF))
              
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Model is not associated.",err,error,*999)
    ENDIF
    
#else
    CALL FlagError("Must compile with WITH_CELLML ON to use CellML functionality.",err,error,*999)
#endif 
        
    EXITS("Solver_DAECellMLRHSEvaluate")
    RETURN
999 ERRORSEXITS("Solver_DAECellMLRHSEvaluate",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_DAECellMLRHSEvaluate

  !
  !================================================================================================================================
  !

  !>Finalise a Runge-Kutta differential-algebraic equation solver and deallocate all memory.
  SUBROUTINE SOLVER_DAE_RUNGE_KUTTA_FINALISE(RUNGE_KUTTA_SOLVER,err,error,*)

    !Argument variables
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: RUNGE_KUTTA_SOLVER !<A pointer the Runge-Kutta differential-algebraic equation solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
     
    ENTERS("SOLVER_DAE_RUNGE_KUTTA_FINALISE",err,error,*999)

    IF(ASSOCIATED(RUNGE_KUTTA_SOLVER)) THEN
      DEALLOCATE(RUNGE_KUTTA_SOLVER)
    ENDIF
         
    EXITS("SOLVER_DAE_RUNGE_KUTTA_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_RUNGE_KUTTA_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_RUNGE_KUTTA_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a Runge-Kutta solver for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_RUNGE_KUTTA_INITIALISE(DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer the differential-algebraic equation solver to initialise a Runge-Kutta solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_DAE_RUNGE_KUTTA_INITIALISE",err,error,*998)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      IF(ASSOCIATED(DAE_SOLVER%RUNGE_KUTTA_SOLVER)) THEN
        CALL FlagError("Runge-Kutta solver is already associated for this differential-algebraic equation solver.",err,error,*998)
      ELSE
        !Allocate the Runge-Kutta solver
        ALLOCATE(DAE_SOLVER%RUNGE_KUTTA_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate Runge-Kutta solver.",err,error,*999)
        !Initialise
        DAE_SOLVER%RUNGE_KUTTA_SOLVER%DAE_SOLVER=>DAE_SOLVER
        DAE_SOLVER%RUNGE_KUTTA_SOLVER%SOLVER_LIBRARY=0
        !Defaults
      ENDIF      
    ELSE
      CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*998)
    ENDIF
         
    EXITS("SOLVER_DAE_RUNGE_KUTTA_INITIALISE")
    RETURN
999 CALL SOLVER_DAE_RUNGE_KUTTA_FINALISE(DAE_SOLVER%RUNGE_KUTTA_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_DAE_RUNGE_KUTTA_INITIALISE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DAE_RUNGE_KUTTA_INITIALISE

  !
  !================================================================================================================================
  !

  !>Solve using a Runge-Kutta differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_RUNGE_KUTTA_SOLVE(RUNGE_KUTTA_SOLVER,err,error,*)

    !Argument variables
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: RUNGE_KUTTA_SOLVER !<A pointer the Runge-Kutta differential-algebraic equation solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_DAE_RUNGE_KUTTA_SOLVE",err,error,*999)

    IF(ASSOCIATED(RUNGE_KUTTA_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Runge-Kutta differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_RUNGE_KUTTA_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_RUNGE_KUTTA_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_RUNGE_KUTTA_SOLVE
  
  !
  !================================================================================================================================
  !

  !>Finalise a Rush-Larson differential-algebraic equation solver and deallocate all memory.
  SUBROUTINE SOLVER_DAE_RUSH_LARSON_FINALISE(RUSH_LARSON_SOLVER,err,error,*)

    !Argument variables
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: RUSH_LARSON_SOLVER !<A pointer the Rush-Larson differential-algebraic equation solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
     
    ENTERS("SOLVER_DAE_RUSH_LARSON_FINALISE",err,error,*999)

    IF(ASSOCIATED(RUSH_LARSON_SOLVER)) THEN
      DEALLOCATE(RUSH_LARSON_SOLVER)
    ENDIF
         
    EXITS("SOLVER_DAE_RUSH_LARSON_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_RUSH_LARSON_FINALISE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DAE_RUSH_LARSON_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise an Rush-Larson solver for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_RUSH_LARSON_INITIALISE(DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer the differential-algebraic equation solver to initialise a Rush-Larson solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_DAE_RUSH_LARSON_INITIALISE",err,error,*998)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      IF(ASSOCIATED(DAE_SOLVER%RUSH_LARSON_SOLVER)) THEN
        CALL FlagError("Rush-Larson solver is already associated for this differential-algebraic equation solver.",err,error,*998)
      ELSE
        !Allocate the Rush-Larson solver
        ALLOCATE(DAE_SOLVER%RUSH_LARSON_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate Rush-Larson solver.",err,error,*999)
        !Initialise
        DAE_SOLVER%RUSH_LARSON_SOLVER%DAE_SOLVER=>DAE_SOLVER
        DAE_SOLVER%RUSH_LARSON_SOLVER%SOLVER_LIBRARY=0
        !Defaults
      ENDIF      
    ELSE
      CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*998)
    ENDIF
         
    EXITS("SOLVER_DAE_RUSH_LARSON_INITIALISE")
    RETURN
999 CALL SOLVER_DAE_RUSH_LARSON_FINALISE(DAE_SOLVER%RUSH_LARSON_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_DAE_RUSH_LARSON_INITIALISE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DAE_RUSH_LARSON_INITIALISE

  !
  !================================================================================================================================
  !

  !>Solve using a Rush-Larson differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_RUSH_LARSON_SOLVE(RUSH_LARSON_SOLVER,err,error,*)

    !Argument variables
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: RUSH_LARSON_SOLVER !<A pointer the Rush-Larson differential-algebraic equation solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_DAE_RUSH_LARSON_SOLVE",err,error,*999)

    IF(ASSOCIATED(RUSH_LARSON_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Rush-Larson differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_RUSH_LARSON_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_RUSH_LARSON_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_RUSH_LARSON_SOLVE

  !
  !================================================================================================================================
  !

  !>Solve a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_SOLVE(DAE_SOLVER,err,error,*)

    !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer the differential-algebraic equation solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: cellml_idx
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: CELLML_STATE_FIELD
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DAE_SOLVE",err,error,*999)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
      SOLVER=>DAE_SOLVER%SOLVER
      IF(ASSOCIATED(SOLVER)) THEN
        SELECT CASE(DAE_SOLVER%DAE_SOLVE_TYPE)
        CASE(SOLVER_DAE_EULER)
          CALL SOLVER_DAE_EULER_SOLVE(DAE_SOLVER%EULER_SOLVER,err,error,*999)
        CASE(SOLVER_DAE_CRANK_NICOLSON)
          CALL SOLVER_DAE_CRANK_NICOLSON_SOLVE(DAE_SOLVER%CRANK_NICOLSON_SOLVER,err,error,*999)
        CASE(SOLVER_DAE_RUNGE_KUTTA)
          CALL SOLVER_DAE_RUNGE_KUTTA_SOLVE(DAE_SOLVER%RUNGE_KUTTA_SOLVER,err,error,*999)
        CASE(SOLVER_DAE_ADAMS_MOULTON)
          CALL SOLVER_DAE_ADAMS_MOULTON_SOLVE(DAE_SOLVER%ADAMS_MOULTON_SOLVER,err,error,*999)        
        CASE(SOLVER_DAE_BDF)
          CALL SOLVER_DAE_BDF_SOLVE(DAE_SOLVER%BDF_SOLVER,err,error,*999)
        CASE(SOLVER_DAE_RUSH_LARSON)
          CALL SOLVER_DAE_RUSH_LARSON_SOLVE(DAE_SOLVER%RUSH_LARSON_SOLVER,err,error,*999)
        CASE(SOLVER_DAE_EXTERNAL)
          CALL SOLVER_DAE_EXTERNAL_SOLVE(DAE_SOLVER%EXTERNAL_SOLVER,err,error,*999)
        CASE DEFAULT
          localError="The differential-algebraic equation solver solve type of "// &
            & TRIM(NumberToVString(DAE_SOLVER%DAE_SOLVE_TYPE,"*",err,error))//" is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
        IF(SOLVER%outputType>SOLVER_SOLVER_OUTPUT) THEN
#ifdef TAUPROF
           CALL TAU_STATIC_PHASE_START("Solution Output Phase")
#endif
           CELLML_EQUATIONS=>SOLVER%CELLML_EQUATIONS
           IF(ASSOCIATED(CELLML_EQUATIONS)) THEN
             CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
             CALL WriteString(GENERAL_OUTPUT_TYPE,"Solver State vectors:",err,error,*999)
             CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Number of CellML environments = ",CELLML_EQUATIONS% &
               & NUMBER_OF_CELLML_ENVIRONMENTS,err,error,*999)
             DO cellml_idx=1,CELLML_EQUATIONS%NUMBER_OF_CELLML_ENVIRONMENTS
               CELLML=>CELLML_EQUATIONS%CELLML_ENVIRONMENTS(cellml_idx)%ptr
               IF(ASSOCIATED(CELLML)) THEN
                 CELLML_STATE_FIELD=>CELLML%STATE_FIELD
                 IF(ASSOCIATED(CELLML_STATE_FIELD)) THEN
                   CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"CellML index : ",cellml_idx,err,error,*999)
                   CALL FIELD_PARAMETER_SET_OUTPUT(GENERAL_OUTPUT_TYPE,CELLML_STATE_FIELD%STATE_FIELD,FIELD_U_VARIABLE_TYPE, &
                     & FIELD_VALUES_SET_TYPE,err,error,*999)
                 ELSE
                   CALL FlagError("CellML environment state field is not associated.",err,error,*999)
                 ENDIF
               ELSE
                 localError="CellML environment is not associated for CellML index "// &
                   & TRIM(NumberToVString(cellml_idx,"*",err,error))//"."
                 CALL FlagError(localError,err,error,*999)
               ENDIF
             ENDDO !cellml_idx
              
           ELSE
             CALL FlagError("Solver CellML equations is not associated.",err,error,*999)
           ENDIF
#ifdef TAUPROF
           CALL TAU_STATIC_PHASE_STOP("Solution Output Phase")
#endif
         ENDIF
     ELSE
        CALL FlagError("Differential-algebraic solver solver is not associated.",err,error,*999)
      ENDIF      
    ELSE
      CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_SOLVE

  !
  !================================================================================================================================
  !
  
  !>Returns the solve type for an differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_SOLVER_TYPE_GET(SOLVER,DAE_SOLVE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to get the differential-algebraic equation solver type for 
    INTEGER(INTG), INTENT(OUT) :: DAE_SOLVE_TYPE !<On return, the type of solver for the differential-algebraic equation to set \see SOLVER_ROUTINES_DAESolverTypes,SOLVER_ROUTINES.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
     
    ENTERS("SOLVER_DAE_SOLVER_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        IF(SOLVER%SOLVE_TYPE==SOLVER_DAE_TYPE) THEN
          DAE_SOLVER=>SOLVER%DAE_SOLVER
          IF(ASSOCIATED(DAE_SOLVER)) THEN
            DAE_SOLVE_TYPE=DAE_SOLVER%DAE_SOLVE_TYPE
         ELSE
            CALL FlagError("The solver differential-algebraic equation solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a differential-algebraic equation solver.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_SOLVER_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_SOLVER_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_SOLVER_TYPE_GET

  !
  !================================================================================================================================
  !
  
  !>Sets/changes the solve type for an differential-algebraic equation solver.
  SUBROUTINE SOLVER_DAE_SOLVER_TYPE_SET(SOLVER,DAE_SOLVE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the differential-algebraic equation solver type for 
    INTEGER(INTG), INTENT(IN) :: DAE_SOLVE_TYPE !<The type of solver for the differential-algebraic equation to set \see SOLVER_ROUTINES_DAESolverTypes,SOLVER_ROUTINES.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
    TYPE(VARYING_STRING) :: localError
     
    ENTERS("SOLVER_DAE_SOLVER_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_DAE_TYPE) THEN
          DAE_SOLVER=>SOLVER%DAE_SOLVER
          IF(ASSOCIATED(DAE_SOLVER)) THEN
            IF(DAE_SOLVE_TYPE/=DAE_SOLVER%DAE_SOLVE_TYPE) THEN
              !Intialise the new differential-algebraic equation solver type
              SELECT CASE(DAE_SOLVE_TYPE)
              CASE(SOLVER_DAE_EULER)
                CALL SOLVER_DAE_EULER_INITIALISE(DAE_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_CRANK_NICOLSON)
                CALL SOLVER_DAE_CRANK_NICOLSON_INITIALISE(DAE_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_RUNGE_KUTTA)
                CALL SOLVER_DAE_RUNGE_KUTTA_INITIALISE(DAE_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_ADAMS_MOULTON)
                CALL SOLVER_DAE_ADAMS_MOULTON_INITIALISE(DAE_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_BDF)
                CALL SOLVER_DAE_BDF_INITIALISE(DAE_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_RUSH_LARSON)
                CALL SOLVER_DAE_RUSH_LARSON_INITIALISE(DAE_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_EXTERNAL)
                CALL SOLVER_DAE_EXTERNAL_INITIALISE(DAE_SOLVER,err,error,*999)
              CASE DEFAULT
                localError="The specified differential-algebraic equation solver type of "// &
                  & TRIM(NumberToVString(DAE_SOLVE_TYPE,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
              !Finalise the old differential-algebraic equation solver type
              SELECT CASE(DAE_SOLVER%DAE_SOLVE_TYPE)
              CASE(SOLVER_DAE_EULER)
                CALL SOLVER_DAE_EULER_FINALISE(DAE_SOLVER%EULER_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_CRANK_NICOLSON)
                CALL SOLVER_DAE_CRANK_NICOLSON_FINALISE(DAE_SOLVER%CRANK_NICOLSON_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_RUNGE_KUTTA)
                CALL SOLVER_DAE_RUNGE_KUTTA_FINALISE(DAE_SOLVER%RUNGE_KUTTA_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_ADAMS_MOULTON)
                CALL SOLVER_DAE_ADAMS_MOULTON_FINALISE(DAE_SOLVER%ADAMS_MOULTON_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_BDF)
                CALL SOLVER_DAE_BDF_FINALISE(DAE_SOLVER%BDF_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_RUSH_LARSON)
                CALL SOLVER_DAE_RUSH_LARSON_FINALISE(DAE_SOLVER%RUSH_LARSON_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_EXTERNAL)
                CALL SOLVER_DAE_EXTERNAL_FINALISE(DAE_SOLVER%EXTERNAL_SOLVER,err,error,*999)
              CASE DEFAULT
                localError="The differential-algebraic equation solve type of "// &
                  & TRIM(NumberToVString(DAE_SOLVER%DAE_SOLVE_TYPE,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
              DAE_SOLVER%DAE_SOLVE_TYPE=DAE_SOLVE_TYPE
            ENDIF
          ELSE
            CALL FlagError("The solver differential-algebraic equation solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a differential-algebraic equation solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_SOLVER_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_SOLVER_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_SOLVER_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Set/change the times for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_TIMES_SET(SOLVER,START_TIME,END_TIME,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the differential-algebraic equation solver to set the times for
    REAL(DP), INTENT(IN) :: START_TIME !<The start time for the differential equation solver
    REAL(DP), INTENT(IN) :: END_TIME !<The end time for the differential equation solver
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DAE_TIMES_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVE_TYPE==SOLVER_DAE_TYPE) THEN
        DAE_SOLVER=>SOLVER%DAE_SOLVER
        IF(ASSOCIATED(DAE_SOLVER)) THEN
          IF(END_TIME>START_TIME) THEN
            DAE_SOLVER%START_TIME=START_TIME
            DAE_SOLVER%END_TIME=END_TIME
          ELSE
            localError="The specified end time of "//TRIM(NumberToVString(END_TIME,"*",err,error))// &
              & " is not > than the specified start time of "//TRIM(NumberToVString(START_TIME,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("The solver is not a differential-algebraic equation solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_TIMES_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_TIMES_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_TIMES_SET

  !
  !================================================================================================================================
  !

  !>Set/change the (initial) time step size for a differential-algebraic equation solver
  SUBROUTINE SOLVER_DAE_TIME_STEP_SET(SOLVER,TIME_STEP,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the differential-algebraic equation solver to set the times for
    REAL(DP), INTENT(IN) :: TIME_STEP !<The (initial) time step for the differential-algebraic equation solver    
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DAE_TIME_STEP_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVE_TYPE==SOLVER_DAE_TYPE) THEN
        DAE_SOLVER=>SOLVER%DAE_SOLVER
        IF(ASSOCIATED(DAE_SOLVER)) THEN
          IF(ABS(TIME_STEP)<=ZERO_TOLERANCE) THEN
            localError="The specified time step of "//TRIM(NumberToVString(TIME_STEP,"*",err,error))// &
              & " is invalid. The time step must not be zero."
            CALL FlagError(localError,err,error,*999)
          ELSE
            DAE_SOLVER%INITIAL_STEP=TIME_STEP
          ENDIF
        ELSE
          CALL FlagError("Differential-algebraic equation solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("The solver is not a differential-algebraic equation solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DAE_TIME_STEP_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DAE_TIME_STEP_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DAE_TIME_STEP_SET

  !
  !================================================================================================================================
  !

  !>Destroys a solver
  SUBROUTINE SOLVER_DESTROY(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the solver to destroy
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_DESTROY",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_DESTROY")
    RETURN
999 ERRORSEXITS("SOLVER_DESTROY",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DESTROY

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a dynamic solver 
  SUBROUTINE SOLVER_DYNAMIC_CREATE_FINISH(DYNAMIC_SOLVER,err,error,*)

    !Argument variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER !<A pointer to the dynamic solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: DYNAMIC_VARIABLE_TYPE,equations_matrix_idx,equations_set_idx,LINEAR_LIBRARY_TYPE,NONLINEAR_LIBRARY_TYPE, &
      & rhsVariableType
    INTEGER(INTG) :: VariableType=0
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingLinearType), POINTER :: linearMapping
    TYPE(EquationsMappingRHSType), POINTER :: rhsMapping
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatricesDynamicType), POINTER :: dynamicMatrices
    TYPE(EquationsMatricesLinearType), POINTER :: linearMatrices
    TYPE(EquationsMatrixType), POINTER :: DAMPING_MATRIX,equationsMatrix,MASS_MATRIX
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD !, INDEPENDENT_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DYNAMIC_VARIABLE,LINEAR_VARIABLE,ResidualVariable
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER,NONLINEAR_SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DYNAMIC_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
      SOLVER=>DYNAMIC_SOLVER%SOLVER
      IF(ASSOCIATED(SOLVER)) THEN
        SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          SELECT CASE(DYNAMIC_SOLVER%SOLVER_LIBRARY)
          CASE(SOLVER_CMISS_LIBRARY)
            !Create the parameter sets required for the solver
            SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
            IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
              SOLVER_MAPPING=>SOLVER_EQUATIONS%SOLVER_MAPPING
              IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                !Initialise for explicit solve
                DYNAMIC_SOLVER%EXPLICIT=ABS(DYNAMIC_SOLVER%THETA(DYNAMIC_SOLVER%DEGREE))<ZERO_TOLERANCE
                !Loop over the equations set in the solver equations
                DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                  EQUATIONS=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%EQUATIONS
                  IF(ASSOCIATED(EQUATIONS)) THEN
                    EQUATIONS_SET=>equations%equationsSet
                    IF(ASSOCIATED(EQUATIONS_SET)) THEN
                      DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
                      IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
                        NULLIFY(vectorEquations)
                        CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
                        NULLIFY(vectorMapping)
                        CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
                        dynamicMapping=>vectorMapping%dynamicMapping
                        IF(ASSOCIATED(dynamicMapping)) THEN
                          DYNAMIC_VARIABLE=>dynamicMapping%dynamicVariable
                          DYNAMIC_VARIABLE_TYPE=dynamicMapping%dynamicVariableType
                          IF(ASSOCIATED(DYNAMIC_VARIABLE)) THEN
                            !Set up the parameter sets to hold the required solver parameters
                            !1st degree or higher so set up displacement parameter sets
                                                                                    
                            IF(DYNAMIC_SOLVER%DEGREE>=SOLVER_DYNAMIC_SECOND_DEGREE) THEN
                              !2nd degree or higher so set up velocity parameter sets
                              CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                & FIELD_VELOCITY_VALUES_SET_TYPE,err,error,*999)
                              CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                & FIELD_PREVIOUS_VELOCITY_SET_TYPE,err,error,*999)
                              CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD, &
                                & DYNAMIC_VARIABLE_TYPE,FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE,err,error,*999)
                              IF(DYNAMIC_SOLVER%DEGREE>=SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                                !3rd degree or higher so set up acceleration parameter sets
                                CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                  & FIELD_ACCELERATION_VALUES_SET_TYPE,err,error,*999)
                                CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                  & FIELD_PREVIOUS_ACCELERATION_SET_TYPE,err,error,*999)
                                CALL Field_ParameterSetEnsureCreated( &
                                  & DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE,FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE, &
                                  & err,error,*999)
                              ENDIF
                            ENDIF
                            
                            !Create the dynamic matrices temporary vector for matrix-vector products                           
                            vectorMatrices=>vectorEquations%vectorMatrices
                            IF(ASSOCIATED(vectorMatrices)) THEN
                              dynamicMatrices=>vectorMatrices%dynamicMatrices
                              IF(ASSOCIATED(dynamicMatrices)) THEN
                                IF(.NOT.ASSOCIATED(dynamicMatrices%tempVector)) THEN
                                  CALL DistributedVector_CreateStart(DYNAMIC_VARIABLE%DOMAIN_MAPPING, &
                                    & dynamicMatrices%tempVector,err,error,*999)
                                  CALL DistributedVector_DataTypeSet(dynamicMatrices%tempVector, &
                                    & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
                                  CALL DistributedVector_CreateFinish(dynamicMatrices%tempVector,err,error,*999)
                                ENDIF
                                !Check to see if we have an explicit solve
                                IF(ABS(DYNAMIC_SOLVER%THETA(DYNAMIC_SOLVER%DEGREE))<ZERO_TOLERANCE) THEN
                                  IF(dynamicMapping%dampingMatrixNumber/=0) THEN
                                    DAMPING_MATRIX=>dynamicMatrices%matrices(dynamicMapping%dampingMatrixNumber)%ptr
                                    IF(ASSOCIATED(DAMPING_MATRIX)) THEN
                                      DYNAMIC_SOLVER%EXPLICIT=DYNAMIC_SOLVER%EXPLICIT.AND.DAMPING_MATRIX%LUMPED
                                    ELSE
                                      CALL FlagError("Damping matrix is not associated.",err,error,*999)
                                    ENDIF
                                  ENDIF
                                  IF(dynamicMapping%massMatrixNumber/=0) THEN
                                    MASS_MATRIX=>dynamicMatrices%matrices(dynamicMapping%massMatrixNumber)%ptr
                                    IF(ASSOCIATED(MASS_MATRIX)) THEN
                                      DYNAMIC_SOLVER%EXPLICIT=DYNAMIC_SOLVER%EXPLICIT.AND.MASS_MATRIX%LUMPED
                                    ELSE
                                      CALL FlagError("Mass matrix is not associated.",err,error,*999)
                                    ENDIF
                                  ENDIF
                                ENDIF
                              ELSE
                                CALL FlagError("Equations matrices dynamic matrices are not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("Equations equations matrices is not associated.",err,error,*999)
                            ENDIF
                            VariableType=DYNAMIC_VARIABLE_TYPE
                          ELSE
                            CALL FlagError("Dynamic mapping dynamic variable is not associated.",err,error,*999)
                          ENDIF
                        ENDIF
                        
                        IF(VariableType==0) THEN
                          !We now allow for static equation sets for dynamic solvers to be able to couple static eqs - dynamic eqs
                          NonlinearMapping=>vectorMapping%nonlinearMapping
                          IF(ASSOCIATED(NonlinearMapping)) THEN
                            IF(DYNAMIC_SOLVER%linearity==SOLVER_DYNAMIC_NONLINEAR) THEN
                              !Default to first variable type for now
                              ResidualVariable=>NonlinearMapping%residualVariables(1)%ptr
                              IF(ASSOCIATED(ResidualVariable)) THEN
                                VariableType=ResidualVariable%VARIABLE_TYPE
                              ELSE
                                CALL FlagError("Residual variable is not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              localError="The specified dynamic solver linearity type of "// &
                                & TRIM(NumberToVString(DYNAMIC_SOLVER%linearity,"*",err,error))// &
                                & " is invalid for a nonlinear equations mapping."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ENDIF
                        
                        CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,VariableType, &
                          & FIELD_PREVIOUS_VALUES_SET_TYPE,err,error,*999)
                        CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,VariableType, &
                          & FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,err,error,*999)
                        CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,VariableType, &
                          & FIELD_PREDICTED_DISPLACEMENT_SET_TYPE,err,error,*999)                       
                        CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,VariableType, &
                          & FIELD_INCREMENTAL_VALUES_SET_TYPE,err,error,*999)
                        
                        rhsMapping=>vectorMapping%rhsMapping
                        IF(ASSOCIATED(rhsMapping)) THEN
                          rhsVariableType=rhsMapping%rhsVariableType
                          CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,rhsVariableType, &
                            & FIELD_PREVIOUS_VALUES_SET_TYPE,err,error,*999)
                          IF(DYNAMIC_SOLVER%DEGREE>=SOLVER_DYNAMIC_SECOND_DEGREE) THEN
                            CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,rhsVariableType, &
                              & FIELD_PREVIOUS2_VALUES_SET_TYPE,err,error,*999)
                            IF(DYNAMIC_SOLVER%DEGREE>=SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                              CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,rhsVariableType, &
                                & FIELD_PREVIOUS3_VALUES_SET_TYPE,err,error,*999)
                            ENDIF
                          ENDIF
                        ENDIF
                        
                        nonlinearMapping=>vectorMapping%nonlinearMapping
                        IF(ASSOCIATED(nonlinearMapping)) THEN
                          CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,variableType, &
                            & FIELD_RESIDUAL_SET_TYPE,err,error,*999)
                          CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,variableType, &
                            & FIELD_PREVIOUS_RESIDUAL_SET_TYPE,err,error,*999)
                          IF(DYNAMIC_SOLVER%DEGREE>=SOLVER_DYNAMIC_SECOND_DEGREE) THEN
                            CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,variableType, &
                              & FIELD_PREVIOUS2_RESIDUAL_SET_TYPE,err,error,*999)
                            IF(DYNAMIC_SOLVER%DEGREE>=SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                              CALL Field_ParameterSetEnsureCreated(DEPENDENT_FIELD,variableType, &
                                & FIELD_PREVIOUS3_RESIDUAL_SET_TYPE,err,error,*999)
                            ENDIF
                          ENDIF
                        ENDIF
                        
                        !Check if there are any linear mappings
                        linearMapping=>vectorMapping%linearMapping
                        IF(ASSOCIATED(linearMapping)) THEN
                          !If there are any linear matrices create temporary vector for matrix-vector products
                          vectorMatrices=>vectorEquations%vectorMatrices
                          IF(ASSOCIATED(vectorMatrices)) THEN
                            linearMatrices=>vectorMatrices%linearMatrices
                            IF(ASSOCIATED(linearMatrices)) THEN
                              DO equations_matrix_idx=1,linearMatrices%numberOfLinearMatrices
                                equationsMatrix=>linearMatrices%matrices(equations_matrix_idx)%ptr
                                IF(ASSOCIATED(equationsMatrix)) THEN
                                  IF(.NOT.ASSOCIATED(equationsMatrix%tempVector)) THEN
                                    LINEAR_VARIABLE=>linearMapping%equationsMatrixToVarMaps(equations_matrix_idx)%VARIABLE
                                    IF(ASSOCIATED(LINEAR_VARIABLE)) THEN
                                      CALL DistributedVector_CreateStart(LINEAR_VARIABLE%DOMAIN_MAPPING, &
                                        & equationsMatrix%tempVector,err,error,*999)
                                      CALL DistributedVector_DataTypeSet(equationsMatrix%tempVector, &
                                        & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
                                      CALL DistributedVector_CreateFinish(equationsMatrix%tempVector,err,error,*999)
                                    ELSE
                                      CALL FlagError("Linear mapping linear variable is not associated.",err,error,*999)
                                    ENDIF
                                  ENDIF
                                ELSE
                                  CALL FlagError("Equations matrix is not associated.",err,error,*999)
                                ENDIF
                              ENDDO !equations_matrix_idx
                            ELSE
                              CALL FlagError("Equations matrices linear matrices is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Equations equations matrices is not associated.",err,error,*999)
                          ENDIF
                        ENDIF
                      ELSE
                        localError="Equations set dependent field is not associated for equations set index "// &
                          & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                        CALL FlagError(localError,err,error,*999)
                      ENDIF
                    ELSE
                      localError="Equations equations set is not associated for equations set index "// &
                        & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    localError="Equations is not associated for equations set index "// &
                      & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ENDDO !equations_set_idx
                
                !Create the solver matrices and vectors
                IF(DYNAMIC_SOLVER%linearity==SOLVER_DYNAMIC_LINEAR) THEN
                  LINEAR_SOLVER=>DYNAMIC_SOLVER%LINEAR_SOLVER
                  IF(ASSOCIATED(LINEAR_SOLVER)) THEN
                    CALL Solver_LibraryTypeGet(LINEAR_SOLVER,LINEAR_LIBRARY_TYPE,err,error,*999)
                    NULLIFY(SOLVER_MATRICES)
                    CALL SOLVER_MATRICES_CREATE_START(SOLVER_EQUATIONS,SOLVER_MATRICES,err,error,*999)
                    CALL SolverMatrices_LibraryTypeSet(SOLVER_MATRICES,LINEAR_LIBRARY_TYPE,err,error,*999)
                    IF(DYNAMIC_SOLVER%EXPLICIT) THEN
                      CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE], &
                        & err,error,*999)
                    ELSE
                      SELECT CASE(SOLVER_EQUATIONS%sparsityType)
                      CASE(SOLVER_SPARSE_MATRICES)
                        CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE], &
                          & err,error,*999)
                      CASE(SOLVER_FULL_MATRICES)
                        CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE], &
                          & err,error,*999)
                      CASE DEFAULT
                        localError="The specified solver equations sparsity type of "// &
                          & TRIM(NumberToVString(SOLVER_EQUATIONS%sparsityType,"*",err,error))// &
                          & " is invalid."
                        CALL FlagError(localError,err,error,*999)
                      END SELECT
                      SELECT CASE(SOLVER_EQUATIONS%symmetryType)
                      CASE(SOLVER_SYMMETRIC_MATRICES)
                        CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_SYMMETRIC_TYPE],err,error,*999)
                      CASE(SOLVER_UNSYMMETRIC_MATRICES)
                        CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_UNSYMMETRIC_TYPE],err,error,*999)
                      CASE DEFAULT
                        localError="The specified solver equations symmetry type of "// &
                          & TRIM(NumberToVString(SOLVER_EQUATIONS%symmetryType,"*",err,error))// &
                          & " is invalid."
                        CALL FlagError(localError,err,error,*999)
                      END SELECT
                    ENDIF
                    CALL SOLVER_MATRICES_CREATE_FINISH(SOLVER_MATRICES,err,error,*999)
                    !Link linear solver
                    LINEAR_SOLVER%SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
                    !Finish the creation of the linear solver
                    CALL SOLVER_LINEAR_CREATE_FINISH(LINEAR_SOLVER%LINEAR_SOLVER,err,error,*999)
                  ELSE
                    CALL FlagError("Dynamic solver linear solver is not associated.",err,error,*999)
                  ENDIF
                ELSE IF(DYNAMIC_SOLVER%linearity==SOLVER_DYNAMIC_NONLINEAR) THEN
                  NONLINEAR_SOLVER=>DYNAMIC_SOLVER%NONLINEAR_SOLVER
                  IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
                    CALL Solver_LibraryTypeGet(NONLINEAR_SOLVER,NONLINEAR_LIBRARY_TYPE,err,error,*999)
                    NULLIFY(SOLVER_MATRICES)
                    CALL SOLVER_MATRICES_CREATE_START(SOLVER_EQUATIONS,SOLVER_MATRICES,err,error,*999)
                    CALL SolverMatrices_LibraryTypeSet(SOLVER_MATRICES,NONLINEAR_LIBRARY_TYPE,err,error,*999)
                    IF(DYNAMIC_SOLVER%EXPLICIT) THEN
                      CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE], &
                        & err,error,*999)
                    ELSE
                      SELECT CASE(SOLVER_EQUATIONS%sparsityType)
                      CASE(SOLVER_SPARSE_MATRICES)
                        CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE], &
                          & err,error,*999)
                      CASE(SOLVER_FULL_MATRICES)
                        CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE], &
                          & err,error,*999)
                      CASE DEFAULT
                        localError="The specified solver equations sparsity type of "// &
                          & TRIM(NumberToVString(SOLVER_EQUATIONS%sparsityType,"*",err,error))// &
                          & " is invalid."
                        CALL FlagError(localError,err,error,*999)
                      END SELECT
                      SELECT CASE(SOLVER_EQUATIONS%symmetryType)
                      CASE(SOLVER_SYMMETRIC_MATRICES)
                        CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_SYMMETRIC_TYPE],err,error,*999)
                      CASE(SOLVER_UNSYMMETRIC_MATRICES)
                        CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_UNSYMMETRIC_TYPE],err,error,*999)
                      CASE DEFAULT
                        localError="The specified solver equations symmetry type of "// &
                          & TRIM(NumberToVString(SOLVER_EQUATIONS%symmetryType,"*",err,error))// &
                          & " is invalid."
                        CALL FlagError(localError,err,error,*999)
                      END SELECT
                    ENDIF
                    CALL SOLVER_MATRICES_CREATE_FINISH(SOLVER_MATRICES,err,error,*999)
                    !Link nonlinear solver
                    NONLINEAR_SOLVER%SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
                    !Finish the creation of the nonlinear solver
                    CALL SOLVER_NONLINEAR_CREATE_FINISH(NONLINEAR_SOLVER%NONLINEAR_SOLVER,err,error,*999)
                  ELSE
                    CALL FlagError("Dynamic solver linear solver is not associated.",err,error,*999)
                  ENDIF
                ENDIF
              ELSE
                CALL FlagError("Solver equations solver mapping is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver solver equations is not associated.",err,error,*999)
            ENDIF
          CASE(SOLVER_PETSC_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The solver library type of "// &
              & TRIM(NumberToVString(DYNAMIC_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("Solver solver equations is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Dynamic solver solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Dynamic solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_DYNAMIC_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_CREATE_FINISH",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DYNAMIC_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver.
  SUBROUTINE SOLVER_DYNAMIC_DEGREE_GET(SOLVER,DEGREE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the dynamic solver to get the degree for
    INTEGER(INTG), INTENT(OUT) :: DEGREE !<On return, the degree of the polynomial used for time interpolation in a dynamic solver \see SOLVER_ROUTINES_DynamicDegreeTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    
    ENTERS("SOLVER_DYNAMIC_DEGREE_GET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            DEGREE=DYNAMIC_SOLVER%DEGREE
          ELSE
            CALL FlagError("Dynamic solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("The solver has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DYNAMIC_DEGREE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_DEGREE_GET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DYNAMIC_DEGREE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver.
  SUBROUTINE SOLVER_DYNAMIC_DEGREE_SET(SOLVER,DEGREE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the dynamic solver to set the theta value for
    INTEGER(INTG), INTENT(IN) :: DEGREE !<The degree of the polynomial used for time interpolation in a dynamic solver \see SOLVER_ROUTINES_DynamicDegreeTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: degree_idx
    REAL(DP), ALLOCATABLE :: OLD_THETA(:)
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_DYNAMIC_DEGREE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("The solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            IF(DEGREE/=DYNAMIC_SOLVER%DEGREE) THEN
              IF(DEGREE>=DYNAMIC_SOLVER%ORDER) THEN
                SELECT CASE(DEGREE)
                CASE(SOLVER_DYNAMIC_FIRST_DEGREE,SOLVER_DYNAMIC_SECOND_DEGREE,SOLVER_DYNAMIC_THIRD_DEGREE)
                  ALLOCATE(OLD_THETA(DYNAMIC_SOLVER%DEGREE),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate old theta.",err,error,*999)
                  OLD_THETA(1:DYNAMIC_SOLVER%DEGREE)=DYNAMIC_SOLVER%THETA(1:DYNAMIC_SOLVER%DEGREE)
                  IF(ALLOCATED(DYNAMIC_SOLVER%THETA)) DEALLOCATE(DYNAMIC_SOLVER%THETA)
                  ALLOCATE(DYNAMIC_SOLVER%THETA(DEGREE),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate theta.",err,error,*999)
                  IF(DEGREE>DYNAMIC_SOLVER%DEGREE) THEN
                    DO degree_idx=1,DYNAMIC_SOLVER%DEGREE
                      DYNAMIC_SOLVER%THETA(degree_idx)=OLD_THETA(degree_idx)
                    ENDDO !degree_idx
                    DO degree_idx=DYNAMIC_SOLVER%DEGREE+1,DEGREE
                      DYNAMIC_SOLVER%THETA(degree_idx)=1.0_DP
                    ENDDO !degree_idx
                  ELSE
                    DO degree_idx=1,DEGREE
                      DYNAMIC_SOLVER%THETA(degree_idx)=OLD_THETA(degree_idx)
                    ENDDO !degree_idx
                  ENDIF
                  IF(ALLOCATED(OLD_THETA)) DEALLOCATE(OLD_THETA)
                  DYNAMIC_SOLVER%DEGREE=DEGREE
                CASE DEFAULT
                  localError="The specified degree of "//TRIM(NumberToVString(DEGREE,"*",err,error))//" is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ELSE
                localError="Invalid dynamic solver setup. The specfied degree of "// &
                  & TRIM(NumberToVString(DEGREE,"*",err,error))//" must be >= the current dynamic order of "// &
                  & TRIM(NumberToVString(DYNAMIC_SOLVER%ORDER,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ENDIF
          ELSE
            CALL FlagError("Dynamic solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DYNAMIC_DEGREE_SET")
    RETURN
999 IF(ALLOCATED(OLD_THETA)) DEALLOCATE(OLD_THETA)
    ERRORSEXITS("SOLVER_DYNAMIC_DEGREE_SET",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_DYNAMIC_DEGREE_SET

  !
  !================================================================================================================================
  !

  !>Finalise a dynamic solver and deallocates all memory
  RECURSIVE SUBROUTINE SOLVER_DYNAMIC_FINALISE(DYNAMIC_SOLVER,err,error,*)

    !Argument variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER !<A pointer the dynamic solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_DYNAMIC_FINALISE",err,error,*999)
    IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
      IF(ALLOCATED(DYNAMIC_SOLVER%THETA)) THEN
!         CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Dynamic solver - theta = ",DYNAMIC_SOLVER%THETA(1), &
!         & err,error,*999)
        DEALLOCATE(DYNAMIC_SOLVER%THETA)
      ENDIF
      CALL SOLVER_FINALISE(DYNAMIC_SOLVER%LINEAR_SOLVER,err,error,*999)
      CALL SOLVER_FINALISE(DYNAMIC_SOLVER%NONLINEAR_SOLVER,err,error,*999)
      DEALLOCATE(DYNAMIC_SOLVER)
    ENDIF
        
    EXITS("SOLVER_DYNAMIC_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DYNAMIC_FINALISE
 
  !
  !================================================================================================================================
  !

  !>Initialise a dynamic solver for a solver.
  SUBROUTINE SOLVER_DYNAMIC_INITIALISE(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to initialise the dynamic solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER 


    ENTERS("SOLVER_DYNAMIC_INITIALISE",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(SOLVER%DYNAMIC_SOLVER)) THEN
        CALL FlagError("Dynamic solver is already associated for this solver.",err,error,*999)
      ELSE
        !Allocate memory for dynamic solver and set default values (link solver later on)
        ALLOCATE(SOLVER%DYNAMIC_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate solver dynamic solver.",err,error,*999)
        DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
        DYNAMIC_SOLVER%SOLVER=>SOLVER
        DYNAMIC_SOLVER%SOLVER_LIBRARY=SOLVER_CMISS_LIBRARY
        DYNAMIC_SOLVER%SOLVER_INITIALISED=.FALSE.
        DYNAMIC_SOLVER%numberOfSolves=0
        DYNAMIC_SOLVER%ORDER=SOLVER_DYNAMIC_FIRST_ORDER
        DYNAMIC_SOLVER%DEGREE=SOLVER_DYNAMIC_FIRST_DEGREE
        DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME
        DYNAMIC_SOLVER%startupType=SOLVER_DYNAMIC_PREVIOUS_STARTUP_TYPE
        ALLOCATE(SOLVER%DYNAMIC_SOLVER%THETA(1),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate theta.",err,error,*999)
        DYNAMIC_SOLVER%THETA(1)=1.0_DP/2.0_DP
        DYNAMIC_SOLVER%EXPLICIT=.FALSE.
        DYNAMIC_SOLVER%RESTART=.FALSE.
        DYNAMIC_SOLVER%ALE=.TRUE. !this should be .FALSE. eventually and set by the user
        DYNAMIC_SOLVER%FSI=.FALSE. !set by the user
        DYNAMIC_SOLVER%UPDATE_BC=.TRUE.  !this should be .FALSE. eventually and set by the user
        DYNAMIC_SOLVER%CURRENT_TIME=0.0_DP
        DYNAMIC_SOLVER%TIME_INCREMENT=0.01_DP
        NULLIFY(DYNAMIC_SOLVER%LINEAR_SOLVER)
        NULLIFY(DYNAMIC_SOLVER%NONLINEAR_SOLVER)
        !Make a linear solver by default, and allocate solver%linear_solver
        CALL SOLVER_DYNAMIC_LINEARITY_TYPE_SET(SOLVER,SOLVER_DYNAMIC_LINEAR,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_DYNAMIC_INITIALISE")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DYNAMIC_INITIALISE

  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for a dynamic solver.
  SUBROUTINE SOLVER_DYNAMIC_LIBRARY_TYPE_GET(DYNAMIC_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER !<A pointer the dynamic solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On exit, the type of library used for the dynamic solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
 
    ENTERS("SOLVER_DYNAMIC_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
      SOLVER_LIBRARY_TYPE=DYNAMIC_SOLVER%SOLVER_LIBRARY
    ELSE
      CALL FlagError("Dynamic solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DYNAMIC_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DYNAMIC_LIBRARY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for a dynamic solver.
  SUBROUTINE SOLVER_DYNAMIC_LIBRARY_TYPE_SET(DYNAMIC_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER !<A pointer the dynamic solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library for the dynamic solver to set. \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_DYNAMIC_LIBRARY_TYPE_SET",err,error,*999)
    
    IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
      SELECT CASE(SOLVER_LIBRARY_TYPE)
      CASE(SOLVER_CMISS_LIBRARY)
        DYNAMIC_SOLVER%SOLVER_LIBRARY=SOLVER_CMISS_LIBRARY
      CASE DEFAULT
        localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
          & " is invalid for a dynamic solver."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Dynamic solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_DYNAMIC_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_LIBRARY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DYNAMIC_LIBRARY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for the dynamic solver. \see OpenCMISS::Iron::cmfe_SolverDynamicLinearityTypeGet
  SUBROUTINE SOLVER_DYNAMIC_LINEARITY_TYPE_GET(SOLVER,LINEARITY_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to get the dynamic linearity type for 
    INTEGER(INTG), INTENT(OUT) :: LINEARITY_TYPE !<On return, the type of linearity \see SOLVER_ROUTINES_EquationLinearityTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER !<A pointer the dynamic solver to finalise
  
    ENTERS("SOLVER_DYNAMIC_LINEARITY_TYPE_GET",err,error,*999)
    
    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
        IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
          LINEARITY_TYPE=DYNAMIC_SOLVER%linearity
        ELSE
          CALL FlagError("Dynamic solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    END IF
    
    EXITS("SOLVER_DYNAMIC_LINEARITY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_LINEARITY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DYNAMIC_LINEARITY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the linearity type for the dynamic solver. \see OpenCMISS::Iron::cmfe_SolverDynamicLinearityTypeSet
  SUBROUTINE SOLVER_DYNAMIC_LINEARITY_TYPE_SET(SOLVER,LINEARITY_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to initialise the dynamic solver for
    INTEGER(INTG), INTENT(IN) :: LINEARITY_TYPE !<The type of linearity to be set \see SOLVER_ROUTINES_EquationLinearityTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER !<A pointer the dynamic solver to finalise
    TYPE(VARYING_STRING) :: localError
  
    ENTERS("SOLVER_DYNAMIC_LINEARITY_TYPE_SET",err,error,*999)
    
    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
        IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN

          CALL SOLVER_LINKED_SOLVER_REMOVE(SOLVER,SOLVER_LINEAR_TYPE,err,error,*999)
          CALL SOLVER_FINALISE(DYNAMIC_SOLVER%LINEAR_SOLVER,err,error,*999)
          CALL SOLVER_FINALISE(DYNAMIC_SOLVER%NONLINEAR_SOLVER,err,error,*999)

          SELECT CASE(LINEARITY_TYPE)
          CASE(SOLVER_DYNAMIC_LINEAR)
            ALLOCATE(DYNAMIC_SOLVER%LINEAR_SOLVER,STAT=err)
            IF(err/=0) CALL FlagError("Could not allocate solver linear solver.",err,error,*999)
            NULLIFY(DYNAMIC_SOLVER%LINEAR_SOLVER%SOLVERS)
            DYNAMIC_SOLVER%linearity=SOLVER_DYNAMIC_LINEAR
            CALL SOLVER_INITIALISE_PTR(DYNAMIC_SOLVER%LINEAR_SOLVER,err,error,*999)
            CALL SOLVER_LINEAR_INITIALISE(DYNAMIC_SOLVER%LINEAR_SOLVER,err,error,*999)
            CALL SOLVER_LINKED_SOLVER_ADD(SOLVER,DYNAMIC_SOLVER%LINEAR_SOLVER,SOLVER_LINEAR_TYPE,err,error,*999)
            IF(DYNAMIC_SOLVER%LINEAR_SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE==SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE) THEN
              CALL Solver_LinearIterativeSolutionInitTypeSet(DYNAMIC_SOLVER%LINEAR_SOLVER,SOLVER_SOLUTION_INITIALISE_ZERO, &
                & err,error,*999)
            ENDIF

          CASE(SOLVER_DYNAMIC_NONLINEAR)
            ALLOCATE(DYNAMIC_SOLVER%NONLINEAR_SOLVER,STAT=err)
            IF(err/=0) CALL FlagError("Could not allocate solver nonlinear solver.",err,error,*999)
            NULLIFY(DYNAMIC_SOLVER%NONLINEAR_SOLVER%SOLVERS)
            DYNAMIC_SOLVER%linearity=SOLVER_DYNAMIC_NONLINEAR
            CALL SOLVER_INITIALISE_PTR(DYNAMIC_SOLVER%NONLINEAR_SOLVER,err,error,*999)
            CALL SOLVER_NONLINEAR_INITIALISE(DYNAMIC_SOLVER%NONLINEAR_SOLVER,err,error,*999)
            CALL SOLVER_LINKED_SOLVER_ADD(SOLVER,DYNAMIC_SOLVER%NONLINEAR_SOLVER,SOLVER_NONLINEAR_TYPE,err,error,*999)
            IF(DYNAMIC_SOLVER%NONLINEAR_SOLVER%NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              CALL SOLVER_NEWTON_SOLUTION_INIT_TYPE_SET(DYNAMIC_SOLVER%NONLINEAR_SOLVER,SOLVER_SOLUTION_INITIALISE_ZERO, &
                & err,error,*999)
            ENDIF
            IF(DYNAMIC_SOLVER%NONLINEAR_SOLVER%NONLINEAR_SOLVER%NEWTON_SOLVER%LINEAR_SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE== &
              & SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE) THEN
              CALL Solver_LinearIterativeSolutionInitTypeSet(DYNAMIC_SOLVER%NONLINEAR_SOLVER%NONLINEAR_SOLVER%NEWTON_SOLVER% &
                & LINEAR_SOLVER,SOLVER_SOLUTION_INITIALISE_ZERO,err,error,*999)
            ENDIF

          CASE DEFAULT
            localError="The specified solver equations linearity type of "// &
              & TRIM(NumberToVString(LINEARITY_TYPE,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("Dynamic solver is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    END IF
    
    EXITS("SOLVER_DYNAMIC_LINEARITY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_LINEARITY_TYPE_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DYNAMIC_LINEARITY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a dynamic solver
  SUBROUTINE SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(SOLVER,NONLINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the dynamic solver to get the linear solver for
    TYPE(SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER !<On exit, a pointer the linear solver linked to the dynamic solver. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER

    ENTERS("SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
        CALL FlagError("Nonlinear solver is already associated.",err,error,*999)
      ELSE
        NULLIFY(NONLINEAR_SOLVER)
        IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            NONLINEAR_SOLVER=>DYNAMIC_SOLVER%NONLINEAR_SOLVER
            IF(.NOT.ASSOCIATED(NONLINEAR_SOLVER)) CALL FlagError("Dynamic solver nonlinear solver is not associated.", & 
              & err,error,*999)
          ELSE
            CALL FlagError("Dynamic solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a dynamic solver \see OpenCMISS::Iron::cmfe_SolverDynamicLinearSolverGet
  SUBROUTINE SOLVER_DYNAMIC_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the dynamic solver to get the linear solver for
    TYPE(SOLVER_TYPE), POINTER :: LINEAR_SOLVER !<On exit, a pointer the linear solver linked to the dynamic solver. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER

    ENTERS("SOLVER_DYNAMIC_LINEAR_SOLVER_GET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(LINEAR_SOLVER)) THEN
        CALL FlagError("Linear solver is already associated.",err,error,*999)
      ELSE
        NULLIFY(LINEAR_SOLVER)
        IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            LINEAR_SOLVER=>DYNAMIC_SOLVER%LINEAR_SOLVER
            IF(.NOT.ASSOCIATED(LINEAR_SOLVER)) CALL FlagError("Dynamic solver linear solver is not associated.",err,error,*999)
          ELSE
            CALL FlagError("Dynamic solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_DYNAMIC_LINEAR_SOLVER_GET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_LINEAR_SOLVER_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_DYNAMIC_LINEAR_SOLVER_GET

  !
  !================================================================================================================================
  ! 

  !>Copies the current to previous time-step, calculates mean predicted values, predicted values and previous residual values.
  SUBROUTINE Solver_DynamicMeanPredictedCalculate(SOLVER,err,error,*)

    !Argument variableg
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the solver
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: DYNAMIC_VARIABLE_TYPE,equations_set_idx
    REAL(DP) :: DELTA_T,FIRST_MEAN_PREDICTION_FACTOR, SECOND_MEAN_PREDICTION_FACTOR,THIRD_MEAN_PREDICTION_FACTOR
    REAL(DP) :: FIRST_PREDICTION_FACTOR, SECOND_PREDICTION_FACTOR,THIRD_PREDICTION_FACTOR
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError
   
    ENTERS("Solver_DynamicMeanPredictedCalculate",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
      IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
        IF(DYNAMIC_SOLVER%SOLVER_INITIALISED) THEN
          DELTA_T=DYNAMIC_SOLVER%TIME_INCREMENT
          SELECT CASE(DYNAMIC_SOLVER%DEGREE)
          CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
            FIRST_MEAN_PREDICTION_FACTOR=1.0_DP
            FIRST_PREDICTION_FACTOR=1.0_DP
          CASE(SOLVER_DYNAMIC_SECOND_DEGREE)
            FIRST_MEAN_PREDICTION_FACTOR=1.0_DP
            SECOND_MEAN_PREDICTION_FACTOR=DYNAMIC_SOLVER%THETA(1)*DELTA_T
            FIRST_PREDICTION_FACTOR=1.0_DP
            SECOND_PREDICTION_FACTOR=DELTA_T
          CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
            FIRST_MEAN_PREDICTION_FACTOR=1.0_DP
            SECOND_MEAN_PREDICTION_FACTOR=DYNAMIC_SOLVER%THETA(1)*DELTA_T
            THIRD_MEAN_PREDICTION_FACTOR=DYNAMIC_SOLVER%THETA(2)*DELTA_T*DELTA_T/2.0_DP
            FIRST_PREDICTION_FACTOR=1.0_DP
            SECOND_PREDICTION_FACTOR=DELTA_T
            THIRD_PREDICTION_FACTOR=DELTA_T*DELTA_T/2.0_DP
          CASE DEFAULT
            localError="The dynamic solver degree of "//TRIM(NumberToVString(DYNAMIC_SOLVER%DEGREE,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ENDIF
        SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          SOLVER_MAPPING=>SOLVER_EQUATIONS%SOLVER_MAPPING
          IF(ASSOCIATED(SOLVER_MAPPING)) THEN
            SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
            IF(ASSOCIATED(SOLVER_MATRICES)) THEN
              IF(DYNAMIC_SOLVER%SOLVER_INITIALISED.OR.(.NOT.DYNAMIC_SOLVER%SOLVER_INITIALISED.AND. &
                & ((DYNAMIC_SOLVER%ORDER==SOLVER_DYNAMIC_FIRST_ORDER.AND.DYNAMIC_SOLVER%DEGREE>SOLVER_DYNAMIC_FIRST_DEGREE).OR. &
                & (DYNAMIC_SOLVER%ORDER==SOLVER_DYNAMIC_SECOND_ORDER.AND.DYNAMIC_SOLVER%DEGREE>SOLVER_DYNAMIC_SECOND_DEGREE)))) &
                & THEN
                !Loop over the equations sets
                DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                  EQUATIONS_SET=>SOLVER_MAPPING%EQUATIONS_SETS(equations_set_idx)%ptr
                  IF(ASSOCIATED(EQUATIONS_SET)) THEN
                    DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
                    EQUATIONS=>EQUATIONS_SET%EQUATIONS
                    IF(ASSOCIATED(EQUATIONS)) THEN
                      NULLIFY(vectorEquations)
                      CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
                      vectorMatrices=>vectorEquations%vectorMatrices
                      IF(ASSOCIATED(vectorMatrices)) THEN                        
                        vectorMapping=>vectorEquations%vectorMapping
                        IF(ASSOCIATED(vectorMapping)) THEN
                          dynamicMapping=>vectorMapping%dynamicMapping
                          IF(ASSOCIATED(dynamicMapping)) THEN
                            DYNAMIC_VARIABLE_TYPE=dynamicMapping%dynamicVariableType
                            IF(DYNAMIC_SOLVER%SOLVER_INITIALISED) THEN
                              !As the dynamic solver may be part of a workflow of solvers within a control loop it is possible
                              !that the current dependent field values are not equal to the current previous values that were set
                              !at the beginning of the control loop. 
                              !Copy the current field values to the previous values
                              CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                                & FIELD_PREVIOUS_VALUES_SET_TYPE,1.0_DP,err,error,*999)
                              IF(DYNAMIC_SOLVER%linearity==SOLVER_DYNAMIC_NONLINEAR) THEN
                                CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                  & FIELD_RESIDUAL_SET_TYPE,FIELD_PREVIOUS_RESIDUAL_SET_TYPE,1.0_DP, &
                                  & err,error,*999)
                              ENDIF
                              !Calculate the mean predicted and predicted values for this dependent field.
                              SELECT CASE(DYNAMIC_SOLVER%DEGREE)
                              CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
                                !The mean predicited displacement is the current displacement
                                CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                  & FIELD_PREVIOUS_VALUES_SET_TYPE,FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,1.0_DP, & 
                                  & err,error,*999)
                                IF(DYNAMIC_SOLVER%linearity==SOLVER_DYNAMIC_NONLINEAR) THEN
                                  !The predicted displacement is just the current displacement
                                  CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                    & FIELD_PREVIOUS_VALUES_SET_TYPE,FIELD_PREDICTED_DISPLACEMENT_SET_TYPE,1.0_DP, &
                                    & err,error,*999)
                                ENDIF
                              CASE(SOLVER_DYNAMIC_SECOND_DEGREE)
                                !The mean predicted displacement comes from the previous displacement and the previous velocity
                                CALL FIELD_PARAMETER_SETS_ADD(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                  & [FIRST_MEAN_PREDICTION_FACTOR,SECOND_MEAN_PREDICTION_FACTOR], &
                                  & [FIELD_PREVIOUS_VALUES_SET_TYPE,FIELD_PREVIOUS_VELOCITY_SET_TYPE], &
                                  & FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,err,error,*999)
                                !The mean predicted velocity is the current velocity
                                CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                  & FIELD_PREVIOUS_VELOCITY_SET_TYPE,FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE,1.0_DP,err,error,*999)
                                IF(DYNAMIC_SOLVER%linearity==SOLVER_DYNAMIC_NONLINEAR) THEN
                                  !The predicted displacement comes from the previous displacement and the previous velocity
                                  CALL FIELD_PARAMETER_SETS_ADD(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                    & [FIRST_PREDICTION_FACTOR,SECOND_PREDICTION_FACTOR], &
                                    & [FIELD_PREVIOUS_VALUES_SET_TYPE,FIELD_PREVIOUS_VELOCITY_SET_TYPE], &
                                    & FIELD_PREDICTED_DISPLACEMENT_SET_TYPE,err,error,*999)
                                END IF
                              CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
                                !The mean predicted displacement comes from the previous displacement and the previous
                                !velocity and acceleration
                                CALL FIELD_PARAMETER_SETS_ADD(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                  & [FIRST_MEAN_PREDICTION_FACTOR,SECOND_MEAN_PREDICTION_FACTOR, &
                                  & THIRD_MEAN_PREDICTION_FACTOR],[FIELD_PREVIOUS_VALUES_SET_TYPE, &
                                  & FIELD_PREVIOUS_VELOCITY_SET_TYPE,FIELD_PREVIOUS_ACCELERATION_SET_TYPE], &
                                  & FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,err,error,*999)
                                !The mean predicted velocity comes from the previous velocity and acceleration
                                CALL FIELD_PARAMETER_SETS_ADD(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                  & [FIRST_MEAN_PREDICTION_FACTOR,SECOND_MEAN_PREDICTION_FACTOR], &
                                  & [FIELD_PREVIOUS_VELOCITY_SET_TYPE,FIELD_PREVIOUS_ACCELERATION_SET_TYPE], &
                                  & FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE,err,error,*999)
                                !The mean predicted acceleration is the current acceleration
                                CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                  & FIELD_PREVIOUS_ACCELERATION_SET_TYPE,FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE,1.0_DP, &
                                  & err,error,*999)
                                IF(DYNAMIC_SOLVER%linearity==SOLVER_DYNAMIC_NONLINEAR) THEN
                                  !The predicted displacement comes from the previous displacement and the previous
                                  !velocity and acceleration
                                  CALL FIELD_PARAMETER_SETS_ADD(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                    & [FIRST_PREDICTION_FACTOR,SECOND_PREDICTION_FACTOR, &
                                    & THIRD_PREDICTION_FACTOR],[FIELD_PREVIOUS_VALUES_SET_TYPE, &
                                    & FIELD_PREVIOUS_VELOCITY_SET_TYPE,FIELD_PREVIOUS_ACCELERATION_SET_TYPE], &
                                    & FIELD_PREDICTED_DISPLACEMENT_SET_TYPE,err,error,*999)
                                END IF
                              CASE DEFAULT
                                localError="The dynamic solver degree of "// &
                                  & TRIM(NumberToVString(DYNAMIC_SOLVER%DEGREE,"*",err,error))//" is invalid."
                                CALL FlagError(localError,err,error,*999)                        
                              END SELECT
                            ENDIF
                          ELSE
                          
                            nonlinearMapping=>vectorMapping%nonlinearMapping
                            IF(ASSOCIATED(nonlinearMapping)) THEN
                              DYNAMIC_VARIABLE_TYPE=FIELD_U_VARIABLE_TYPE
                              IF(DYNAMIC_SOLVER%SOLVER_INITIALISED) THEN
                                !As the dynamic solver may be part of a workflow of solvers within a control loop it is possible
                                !that the current dependent field values are not equal to the current previous values that were set
                                !at the beginning of the control loop. 
                                !Copy the current field values to the previous values
                                CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                                  & FIELD_PREVIOUS_VALUES_SET_TYPE,1.0_DP,err,error,*999)
                                IF(DYNAMIC_SOLVER%linearity==SOLVER_DYNAMIC_NONLINEAR) THEN
                                  CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                    & FIELD_RESIDUAL_SET_TYPE,FIELD_PREVIOUS_RESIDUAL_SET_TYPE,1.0_DP, &
                                    & err,error,*999)
                                ENDIF
                                !Calculate the mean predicted and predicted values for this dependent field.
                                SELECT CASE(DYNAMIC_SOLVER%DEGREE)
                                CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
                                  !The mean predicited displacement is the current displacement
                                  CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                    & FIELD_PREVIOUS_VALUES_SET_TYPE,FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,1.0_DP, & 
                                    & err,error,*999)
                                  IF(DYNAMIC_SOLVER%linearity==SOLVER_DYNAMIC_NONLINEAR) THEN
                                    !The predicted displacement is just the current displacement
                                    CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                      & FIELD_PREVIOUS_VALUES_SET_TYPE,FIELD_PREDICTED_DISPLACEMENT_SET_TYPE,1.0_DP, &
                                      & err,error,*999)
                                  ENDIF
                                CASE(SOLVER_DYNAMIC_SECOND_DEGREE)
                                  !The mean predicted displacement comes from the previous displacement and the previous velocity
                                  CALL FIELD_PARAMETER_SETS_ADD(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                    & [FIRST_MEAN_PREDICTION_FACTOR,SECOND_MEAN_PREDICTION_FACTOR], &
                                    & [FIELD_PREVIOUS_VALUES_SET_TYPE,FIELD_PREVIOUS_VELOCITY_SET_TYPE], &
                                    & FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,err,error,*999)
                                  !The mean predicted velocity is the current velocity
                                  CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                    & FIELD_PREVIOUS_VELOCITY_SET_TYPE,FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE,1.0_DP,err,error,*999)
                                  IF(DYNAMIC_SOLVER%linearity==SOLVER_DYNAMIC_NONLINEAR) THEN
                                    !The predicted displacement comes from the previous displacement and the previous velocity
                                    CALL FIELD_PARAMETER_SETS_ADD(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                      & [FIRST_PREDICTION_FACTOR,SECOND_PREDICTION_FACTOR], &
                                      & [FIELD_PREVIOUS_VALUES_SET_TYPE,FIELD_PREVIOUS_VELOCITY_SET_TYPE], &
                                      & FIELD_PREDICTED_DISPLACEMENT_SET_TYPE,err,error,*999)
                                  END IF
                                CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
                                  !The mean predicted displacement comes from the previous displacement and the previous
                                  !velocity and acceleration
                                  CALL FIELD_PARAMETER_SETS_ADD(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                    & [FIRST_MEAN_PREDICTION_FACTOR,SECOND_MEAN_PREDICTION_FACTOR, &
                                    & THIRD_MEAN_PREDICTION_FACTOR],[FIELD_PREVIOUS_VALUES_SET_TYPE, &
                                    & FIELD_PREVIOUS_VELOCITY_SET_TYPE,FIELD_PREVIOUS_ACCELERATION_SET_TYPE], &
                                    & FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,err,error,*999)
                                  !The mean predicted velocity comes from the previous velocity and acceleration
                                  CALL FIELD_PARAMETER_SETS_ADD(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                    & [FIRST_MEAN_PREDICTION_FACTOR,SECOND_MEAN_PREDICTION_FACTOR], &
                                    & [FIELD_PREVIOUS_VELOCITY_SET_TYPE,FIELD_PREVIOUS_ACCELERATION_SET_TYPE], &
                                    & FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE,err,error,*999)
                                  !The mean predicted acceleration is the current acceleration
                                  CALL FIELD_PARAMETER_SETS_COPY(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                    & FIELD_PREVIOUS_ACCELERATION_SET_TYPE,FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE,1.0_DP, &
                                    & err,error,*999)
                                  IF(DYNAMIC_SOLVER%LINEARITY==SOLVER_DYNAMIC_NONLINEAR) THEN
                                    !The predicted displacement comes from the previous displacement and the previous
                                    !velocity and acceleration
                                    CALL FIELD_PARAMETER_SETS_ADD(DEPENDENT_FIELD,DYNAMIC_VARIABLE_TYPE, &
                                      & [FIRST_PREDICTION_FACTOR,SECOND_PREDICTION_FACTOR, &
                                      & THIRD_PREDICTION_FACTOR],[FIELD_PREVIOUS_VALUES_SET_TYPE, &
                                      & FIELD_PREVIOUS_VELOCITY_SET_TYPE,FIELD_PREVIOUS_ACCELERATION_SET_TYPE], &
                                      & FIELD_PREDICTED_DISPLACEMENT_SET_TYPE,err,error,*999)
                                  END IF
                                CASE DEFAULT
                                  localError="The dynamic solver degree of "// &
                                    & TRIM(NumberToVString(DYNAMIC_SOLVER%DEGREE,"*",err,error))//" is invalid."
                                  CALL FlagError(localError,err,error,*999)                        
                                END SELECT
                              ENDIF!initialised
                              NULLIFY(nonlinearMapping)
                            ELSE
                              localError="Neither equations mapping dynamic mapping nor equations mapping nonlinear "// &
                                & "mapping is associated for equations set index number "// &
                                & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF!nonlinear mapping
                          ENDIF!dynamic mapping
                        ELSE
                          CALL FlagError("Equations equations mapping is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Equations equations matrices is not associated.",err,error,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Equations set equations is not associated.",err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Equations set is not associated.",err,error,*999)
                  ENDIF
                ENDDO !equations_set_idx
              ENDIF
            ELSE
              CALL FlagError("Solver solver matrices is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver equations solver mapping is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Solver solver equations is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver dynamic solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF

    EXITS("Solver_DynamicMeanPredictedCalculate")
    RETURN
999 ERRORSEXITS("Solver_DynamicMeanPredictedCalculate",err,error)
    RETURN 1
  END SUBROUTINE Solver_DynamicMeanPredictedCalculate

  !
  !================================================================================================================================
  !

  !>Returns the restart value for a dynamic solver.
  SUBROUTINE SOLVER_DYNAMIC_RESTART_GET(SOLVER,RESTART,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the dynamic solver to get the degree for
    LOGICAL, INTENT(OUT) :: RESTART !<On return, the restart value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    
    ENTERS("SOLVER_DYNAMIC_RESTART_GET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            RESTART=DYNAMIC_SOLVER%RESTART
          ELSE
            CALL FlagError("Dynamic solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("The solver has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DYNAMIC_RESTART_GET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_RESTART_GET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DYNAMIC_RESTART_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart value  for a dynamic solver.
  SUBROUTINE SOLVER_DYNAMIC_RESTART_SET(SOLVER,RESTART,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the dynamic solver to set the theta value for
    LOGICAL, INTENT(IN) :: RESTART !<The restart value to be set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    
    ENTERS("SOLVER_DYNAMIC_RESTART_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("The solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            DYNAMIC_SOLVER%RESTART=RESTART
          ELSE
            CALL FlagError("Dynamic solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DYNAMIC_RESTART_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_RESTART_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_DYNAMIC_RESTART_SET

  !
  !================================================================================================================================
  !

  !>Monitors the differential-algebraic equations solve.
  SUBROUTINE SOLVER_TIME_STEPPING_MONITOR(DAE_SOLVER,STEPS,TIME,err,error,*)

   !Argument variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER !<A pointer to the differential-algebraic equations solver to monitor
    INTEGER(INTG), INTENT(IN) :: STEPS !<The number of iterations
    REAL(DP), INTENT(IN) :: TIME !<The current time
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    
    ENTERS("SOLVER_TIME_STEPPING_MONITOR",err,error,*999)

    IF(ASSOCIATED(DAE_SOLVER)) THEN
        
      CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(GENERAL_OUTPUT_TYPE,"Differential-algebraic equations solve monitor: ",err,error,*999)
      CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Number of steps = ",STEPS,err,error,*999)
      CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Current time    = ",TIME,err,error,*999)
        
    ELSE
      CALL FlagError("Differential-algebraic equations solver is not associated.",err,error,*999)
    ENDIF
     
    EXITS("SOLVER_TIME_STEPPING_MONITOR")
    RETURN
999 ERRORSEXITS("SOLVER_TIME_STEPPING_MONITOR",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_TIME_STEPPING_MONITOR

  !
  !================================================================================================================================
  !

  !>Sets/changes the order for a dynamic solver.
  SUBROUTINE SOLVER_DYNAMIC_ORDER_SET(SOLVER,ORDER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the dynamic solver to set the theta value for
    INTEGER(INTG), INTENT(IN) :: ORDER !<The order of the dynamic solver \see SOLVER_ROUTINES_DynamicOrderTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_DYNAMIC_ORDER_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("The solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            IF(ORDER==SOLVER_DYNAMIC_SECOND_ORDER.AND.DYNAMIC_SOLVER%DEGREE==SOLVER_DYNAMIC_FIRST_DEGREE) THEN
              localError="Invalid dynamic solver degree. You must have at least a second degree polynomial "// &
                & "interpolation for a second order dynamic solver."
              CALL FlagError(localError,err,error,*999)
            ELSE
              SELECT CASE(ORDER)
              CASE(SOLVER_DYNAMIC_FIRST_ORDER)
                DYNAMIC_SOLVER%ORDER=SOLVER_DYNAMIC_FIRST_ORDER
              CASE(SOLVER_DYNAMIC_SECOND_ORDER)
                DYNAMIC_SOLVER%ORDER=SOLVER_DYNAMIC_SECOND_ORDER
              CASE DEFAULT
                localError="The specified order of "//TRIM(NumberToVString(ORDER,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          ELSE
            CALL FlagError("Dynamic solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DYNAMIC_ORDER_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_ORDER_SET",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_DYNAMIC_ORDER_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver. \see OpenCMISS::Iron::cmfe_SolverDynamicSchemeSet
  SUBROUTINE SOLVER_DYNAMIC_SCHEME_SET(SOLVER,SCHEME,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the dynamic solver to set the scheme for
    INTEGER(INTG), INTENT(IN) :: SCHEME !<The scheme used for a dynamic solver \see SOLVER_ROUTINES_DynamicSchemeTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    REAL(DP) :: ALPHA,BETA,GAMMA,THETA
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_DYNAMIC_SCHEME_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("The solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            SELECT CASE(SCHEME)
            CASE(SOLVER_DYNAMIC_EULER_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_EULER_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_FIRST_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_FIRST_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,0.0_DP,err,error,*999)
            CASE(SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_FIRST_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_FIRST_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,1.0_DP,err,error,*999)
            CASE(SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_FIRST_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_FIRST_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,1.0_DP/2.0_DP,err,error,*999)
            CASE(SOLVER_DYNAMIC_GALERKIN_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_GALERKIN_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_FIRST_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_FIRST_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,2.0_DP/3.0_DP,err,error,*999)
            CASE(SOLVER_DYNAMIC_ZLAMAL_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_ZLAMAL_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_SECOND_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_FIRST_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[5.0_DP/6.0_DP,2.0_DP],err,error,*999)
            CASE(SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_SECOND_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_FIRST_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[3.0_DP/2.0_DP,2.0_DP],err,error,*999)
            CASE(SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_SECOND_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_FIRST_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[1.0848_DP,1.0_DP],err,error,*999)
            CASE(SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_SECOND_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_FIRST_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[1.2184_DP,1.292_DP],err,error,*999)
            CASE(SOLVER_DYNAMIC_NEWMARK1_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_NEWMARK1_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_SECOND_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_SECOND_ORDER,err,error,*999)
              BETA=0.5_DP
              GAMMA=2.0_DP
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[GAMMA,2.0_DP*BETA],err,error,*999)
            CASE(SOLVER_DYNAMIC_NEWMARK2_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_NEWMARK2_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_SECOND_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_SECOND_ORDER,err,error,*999)
              BETA=0.3025_DP
              GAMMA=0.6_DP
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[GAMMA,2.0_DP*BETA],err,error,*999)
            CASE(SOLVER_DYNAMIC_NEWMARK3_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_NEWMARK3_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_SECOND_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_SECOND_ORDER,err,error,*999)
              BETA=0.25_DP
              GAMMA=0.5_DP
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[GAMMA,2.0_DP*BETA],err,error,*999)
            CASE(SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_THIRD_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_FIRST_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[2.0_DP,11.0_DP/3.0_DP,6.0_DP],err,error,*999)
            CASE(SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_THIRD_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_FIRST_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[1.84_DP,3.07_DP,4.5_DP],err,error,*999)
            CASE(SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_THIRD_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_FIRST_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[0.80_DP,1.03_DP,1.29_DP],err,error,*999)
            CASE(SOLVER_DYNAMIC_HOUBOLT_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_HOUBOLT_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_THIRD_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_SECOND_ORDER,err,error,*999)
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[2.0_DP,11.0_DP/3.0_DP,6.0_DP],err,error,*999)
            CASE(SOLVER_DYNAMIC_WILSON_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_WILSON_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_THIRD_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_SECOND_ORDER,err,error,*999)
              THETA=1.4_DP
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[THETA,THETA**2,THETA**3],err,error,*999)
            CASE(SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_THIRD_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_SECOND_ORDER,err,error,*999)
              ALPHA=-0.1_DP
              BETA=0.3025_DP
              GAMMA=0.5_DP-ALPHA
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[1.0_DP-ALPHA,2.0_DP/3.0_DP-ALPHA+2.0_DP*BETA,6.0_DP*BETA],err,error,*999)
            CASE(SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_THIRD_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_SECOND_ORDER,err,error,*999)
              ALPHA=-0.1_DP
              BETA=1.0_DP/6.0_DP-1.0_DP/2.0_DP*ALPHA
              GAMMA=1.0_DP/2.0_DP-ALPHA
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[1.0_DP-ALPHA,1.0_DP-2.0_DP*ALPHA,1.0_DP-3.0_DP*ALPHA],err,error,*999)
            CASE(SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_THIRD_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_SECOND_ORDER,err,error,*999)
              ALPHA=-0.1_DP
              BETA=0.3025_DP
              GAMMA=0.5_DP-ALPHA
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[1.0_DP,2.0_DP/3.0_DP+2.0_DP*BETA-2.0_DP*ALPHA**2, &
                & 6.0_DP*BETA*(1.0_DP+ALPHA)],err,error,*999)
            CASE(SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME
              CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,SOLVER_DYNAMIC_THIRD_DEGREE,err,error,*999)
              CALL SOLVER_DYNAMIC_ORDER_SET(SOLVER,SOLVER_DYNAMIC_SECOND_ORDER,err,error,*999)
              ALPHA=-0.3_DP
              BETA=0.3025_DP
              GAMMA=0.5_DP-ALPHA
              CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,[1.0_DP,2.0_DP/3.0_DP+2.0_DP*BETA-2.0_DP*ALPHA**2, &
                & 6.0_DP*BETA*(1.0_DP+ALPHA)],err,error,*999)
            CASE(SOLVER_DYNAMIC_USER_DEFINED_SCHEME)
              DYNAMIC_SOLVER%SCHEME=SOLVER_DYNAMIC_USER_DEFINED_SCHEME
            CASE DEFAULT
              localError="The specified scheme of "//TRIM(NumberToVString(SCHEME,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE
            CALL FlagError("Dynamic solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DYNAMIC_SCHEME_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_SCHEME_SET",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_DYNAMIC_SCHEME_SET

  !
  !================================================================================================================================
  
  !>Solve a dynamic solver 
  SUBROUTINE Solver_DynamicSolve(dynamicSolver,err,error,*)

    !Argument variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: dynamicSolver !<A pointer to the dynamic solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: solverMatrixIdx
    TYPE(SOLVER_TYPE), POINTER :: linearSolver,solver,nonlinearSolver
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices
    TYPE(VARYING_STRING) :: localError

    ENTERS("Solver_DynamicSolve",err,error,*999)

    IF(ASSOCIATED(dynamicSolver)) THEN
      SELECT CASE(dynamicSolver%SOLVER_LIBRARY)
      CASE(SOLVER_CMISS_LIBRARY)
        solver=>dynamicSolver%solver
        IF(ASSOCIATED(solver)) THEN          
          SELECT CASE(dynamicSolver%LINEARITY)
          CASE(SOLVER_DYNAMIC_LINEAR)
            !Solve the linear dynamic problem
            linearSolver=>dynamicSolver%LINEAR_SOLVER
            IF(ASSOCIATED(linearSolver)) THEN
              IF(dynamicSolver%SOLVER_INITIALISED) THEN
                !Assemble the solver equations
                CALL Solver_DynamicMeanPredictedCalculate(solver,err,error,*999)
                CALL Solver_DynamicAssemble(solver,SOLVER_MATRICES_LINEAR_ONLY,err,error,*999)
                !Solve the linear system
                CALL Solver_Solve(linearSolver,err,error,*999)
                !Update dependent field with solution
                CALL Solver_VariablesDynamicFieldUpdate(solver,err,error,*999)
             ELSE
                !If we need to initialise the solver
                IF((dynamicSolver%ORDER==SOLVER_DYNAMIC_FIRST_ORDER.AND.dynamicSolver%DEGREE>SOLVER_DYNAMIC_FIRST_DEGREE).OR. &
                  & (dynamicSolver%ORDER==SOLVER_DYNAMIC_SECOND_ORDER.AND.dynamicSolver%DEGREE>SOLVER_DYNAMIC_SECOND_DEGREE)) THEN
                  !Assemble the solver equations
                  CALL Solver_DynamicMeanPredictedCalculate(solver,err,error,*999)
                  CALL Solver_DynamicAssemble(solver,SOLVER_MATRICES_LINEAR_ONLY,err,error,*999)
                  !Solve the linear system
                  CALL Solver_Solve(linearSolver,err,error,*999)
                  !Update dependent field with solution
                  CALL Solver_VariablesDynamicFieldUpdate(solver,err,error,*999)
                ENDIF
                !Set initialised flag
                dynamicSolver%SOLVER_INITIALISED=.TRUE.
              ENDIF
            ELSE
              CALL FlagError("Dynamic solver linear solver is not associated.",err,error,*999)
            ENDIF
          CASE(SOLVER_DYNAMIC_NONLINEAR) 
            !Solve the nonlinear dynamic problem
            nonlinearSolver=>dynamicSolver%NONLINEAR_SOLVER
            IF(ASSOCIATED(nonlinearSolver)) THEN
              IF(dynamicSolver%SOLVER_INITIALISED) THEN
                !Calculate predicted values
                CALL Solver_DynamicMeanPredictedCalculate(solver,err,error,*999)
                !Solve the nonlinear system
                CALL Solver_Solve(nonlinearSolver,err,error,*999)
                !Update dependent field with solution
                CALL Solver_VariablesDynamicFieldUpdate(solver,err,error,*999)
              ELSE
                !If we need to initialise the solver
                IF((dynamicSolver%ORDER==SOLVER_DYNAMIC_FIRST_ORDER.AND.dynamicSolver%DEGREE>SOLVER_DYNAMIC_FIRST_DEGREE).OR. &
                  & (dynamicSolver%ORDER==SOLVER_DYNAMIC_SECOND_ORDER.AND.dynamicSolver%DEGREE>SOLVER_DYNAMIC_SECOND_DEGREE)) THEN
                  !No nonlinear solver for the first (starting) time step.
                  !Use the nonlinear solvers linear solver to find starting velocities and accelerations etc.
                  NULLIFY(linearSolver)
                  CALL Solver_NonlinearSolverLinearSolverGet(nonlinearSolver,linearSolver,err,error,*999)
                  !Assemble the solver equations
                  CALL Solver_DynamicMeanPredictedCalculate(solver,err,error,*999)
                  CALL Solver_DynamicAssemble(solver,SOLVER_MATRICES_LINEAR_RESIDUAL_ONLY,err,error,*999)
                  !Solve
                  CALL Solver_Solve(linearSolver,err,error,*999)
                ELSE
                  !Assemble the solver equations for the intial values of the residual and RHS.
                  CALL Solver_DynamicMeanPredictedCalculate(solver,err,error,*999)
                  CALL Solver_DynamicAssemble(solver,SOLVER_MATRICES_RHS_RESIDUAL_ONLY,err,error,*999)
                ENDIF
                !Update dependent field with solution
                CALL Solver_VariablesDynamicFieldUpdate(solver,err,error,*999)
                !Set initialised flag
                dynamicSolver%SOLVER_INITIALISED=.TRUE.
              ENDIF
            ELSE
              CALL FlagError("Dynamic solver nonlinear solver is not associated.",err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The dynamic solver linearity type of "// &
              & TRIM(NumberToVString(dynamicSolver%LINEARITY,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT

          IF(dynamicSolver%SOLVER_INITIALISED) dynamicSolver%numberOfSolves=dynamicSolver%numberOfSolves+1
          
          IF(solver%outputType>=SOLVER_SOLVER_OUTPUT) THEN
            
#ifdef TAUPROF
            CALL TAU_STATIC_PHASE_START("Solution Output Phase")
#endif
            solverEquations=>solver%SOLVER_EQUATIONS
            IF(ASSOCIATED(solverEquations)) THEN
              solverMatrices=>solverEquations%SOLVER_MATRICES
              IF(ASSOCIATED(solverMatrices)) THEN
                CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
                CALL WriteString(GENERAL_OUTPUT_TYPE,"Solver solution vectors:",err,error,*999)
                CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Number of solution vectors = ",solverMatrices%NUMBER_OF_MATRICES, &
                  & err,error,*999)
                DO solverMatrixIdx=1,solverMatrices%NUMBER_OF_MATRICES
                  CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Solution vector for solver matrix : ",solverMatrixIdx, &
                    & err,error,*999)
                  CALL DistributedVector_Output(GENERAL_OUTPUT_TYPE,solverMatrices%matrices(solverMatrixIdx)%ptr% &
                    & SOLVER_VECTOR,err,error,*999)
                ENDDO !solverMatrixIdx
              ELSE
                CALL FlagError("Solver equations solver matrices is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver solver equations is not associated.",err,error,*999)
            ENDIF
            
#ifdef TAUPROF
            CALL TAU_STATIC_PHASE_STOP("Solution Output Phase")
#endif
          ENDIF
        ELSE
          CALL FlagError("Dynamic solver solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_PETSC_LIBRARY)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="The solver library type of "// &
          & TRIM(NumberToVString(dynamicSolver%SOLVER_LIBRARY,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Dynamic solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_DynamicSolve")
    RETURN
999 ERRORSEXITS("Solver_DynamicSolve",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_DynamicSolve
        
  !
  !================================================================================================================================
  !

  !>Sets/changes a single theta value for a dynamic solver. \see OpenCMISS::Iron::cmfe_SolverDynamicThetaSet
  SUBROUTINE SOLVER_DYNAMIC_THETA_SET_DP1(SOLVER,THETA,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the dynamic solver to set the theta value for
    REAL(DP), INTENT(IN) :: THETA !<The theta value to set for the first degree polynomial
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
   
    ENTERS("SOLVER_DYNAMIC_THETA_SET_DP1",err,error,*999)

    CALL SOLVER_DYNAMIC_THETA_SET_DP(SOLVER,[THETA],err,error,*999)
    
    EXITS("SOLVER_DYNAMIC_THETA_SET_DP1")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_THETA_SET_DP1",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_DYNAMIC_THETA_SET_DP1

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta value for a dynamic solver. \see OpenCMISS::Iron::cmfe_SolverDynamicThetaSet
  SUBROUTINE SOLVER_DYNAMIC_THETA_SET_DP(SOLVER,THETA,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the dynamic solver to set the theta value for
    REAL(DP), INTENT(IN) :: THETA(:) !<THEATA(degree_idx). The theta value to set for the degree_idx-1'th polynomial
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: degree_idx
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_DYNAMIC_THETA_SET_DP",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("The solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            IF(SIZE(THETA,1)>=DYNAMIC_SOLVER%DEGREE) THEN
              DO degree_idx=1,DYNAMIC_SOLVER%DEGREE
                IF(THETA(degree_idx)>=0.0_DP) THEN
                  DYNAMIC_SOLVER%THETA(degree_idx)=THETA(degree_idx)
                ELSE
                  localError="The specified theta "//TRIM(NumberToVString(degree_idx,"*",err,error))// &
                    & " value of "//TRIM(NumberToVString(THETA(degree_idx),"*",err,error))// &
                    & " is invalid. The theta value must be >= 0.0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ENDDO !degree_idx
            ELSE
              localError="Invalid number of the thetas. The supplied number of thetas ("// &
                & TRIM(NumberToVString(SIZE(THETA,1),"*",err,error))//") must be equal to the interpolation degree ("// &
                & TRIM(NumberToVString(DYNAMIC_SOLVER%DEGREE,"*",err,error))//")."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Dynamic solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DYNAMIC_THETA_SET_DP")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_THETA_SET_DP",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_DYNAMIC_THETA_SET_DP

  !
  !================================================================================================================================
  !

  !>Sets/changes the ALE flag for a dynamic solver.
  SUBROUTINE SOLVER_DYNAMIC_ALE_SET(SOLVER,ALE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the dynamic solver to set the theta value for
    LOGICAL :: ALE !<The ALE flag for a dynamic solver
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
!     INTEGER(INTG) :: degree_idx
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
!     TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_DYNAMIC_ALE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("The solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            DYNAMIC_SOLVER%ALE=ALE
          ELSE
            CALL FlagError("Dynamic solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DYNAMIC_ALE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_ALE_SET",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_DYNAMIC_ALE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the bc flag for a dynamic solver.
  SUBROUTINE SOLVER_DYNAMIC_UPDATE_BC_SET(SOLVER,UPDATE_BC,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the dynamic solver to set the theta value for
    LOGICAL :: UPDATE_BC!<The UPDATE_BC flag for a dynamic solver
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
!     INTEGER(INTG) :: degree_idx
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
!     TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_DYNAMIC_UPDATE_BC_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("The solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            DYNAMIC_SOLVER%UPDATE_BC=UPDATE_BC
          ELSE
            CALL FlagError("Dynamic solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_DYNAMIC_UPDATE_BC_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_UPDATE_BC_SET",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_DYNAMIC_UPDATE_BC_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the dynamic times for a dynamic solver. \see OpenCMISS::Iron::cmfe_SolverDynamicTimesSet
  SUBROUTINE SOLVER_DYNAMIC_TIMES_SET(SOLVER,CURRENT_TIME,TIME_INCREMENT,err,error,*)

   !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the dynamic solver to set the times for
    REAL(DP), INTENT(IN) :: CURRENT_TIME !<The current time to set
    REAL(DP), INTENT(IN) :: TIME_INCREMENT !<The time increment to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_DYNAMIC_TIMES_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      !Note: do not check for finished here as we may wish to modify this for multiple solves.
      IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
        DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
        IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
          IF(ABS(TIME_INCREMENT)<=ZERO_TOLERANCE) THEN
            localError="The specified time increment of "//TRIM(NumberToVString(TIME_INCREMENT,"*",err,error))// &
              & " is invalid. The time increment must not be zero."
            CALL FlagError(localError,err,error,*999)
          ELSE
            DYNAMIC_SOLVER%CURRENT_TIME=CURRENT_TIME
            DYNAMIC_SOLVER%TIME_INCREMENT=TIME_INCREMENT
          ENDIF
        ELSE
          CALL FlagError("Dynamic solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
     
    EXITS("SOLVER_DYNAMIC_TIMES_SET")
    RETURN
999 ERRORSEXITS("SOLVER_DYNAMIC_TIMES_SET",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_DYNAMIC_TIMES_SET

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a eigenproblem solver 
  SUBROUTINE SOLVER_EIGENPROBLEM_CREATE_FINISH(EIGENPROBLEM_SOLVER,err,error,*)

    !Argument variables
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: EIGENPROBLEM_SOLVER !<A pointer to the eigenproblem solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_EIGENPROBLEM_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(EIGENPROBLEM_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Eigenproblem solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_EIGENPROBLEM_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_EIGENPROBLEM_CREATE_FINISH",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EIGENPROBLEM_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Finalise a eigenproblem solver for a solver.
  SUBROUTINE SOLVER_EIGENPROBLEM_FINALISE(EIGENPROBLEM_SOLVER,err,error,*)

    !Argument variables
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: EIGENPROBLEM_SOLVER !<A pointer the eigenproblem solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_EIGENPROBLEM_FINALISE",err,error,*999)

    IF(ASSOCIATED(EIGENPROBLEM_SOLVER)) THEN        
      DEALLOCATE(EIGENPROBLEM_SOLVER)
    ENDIF
         
    EXITS("SOLVER_EIGENPROBLEM_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_EIGENPROBLEM_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EIGENPROBLEM_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a eigenproblem solver for a solver.
  SUBROUTINE SOLVER_EIGENPROBLEM_INITIALISE(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to initialise the eigenproblem solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("SOLVER_EIGENPROBLEM_INITIALISE",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(SOLVER%EIGENPROBLEM_SOLVER)) THEN
        CALL FlagError("Eigenproblem solver is already associated for this solver.",err,error,*998)
      ELSE
        ALLOCATE(SOLVER%EIGENPROBLEM_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate solver eigenproblem solver.",err,error,*999)
        SOLVER%EIGENPROBLEM_SOLVER%SOLVER=>SOLVER
        SOLVER%EIGENPROBLEM_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_EIGENPROBLEM_INITIALISE")
    RETURN
999 CALL SOLVER_EIGENPROBLEM_FINALISE(SOLVER%EIGENPROBLEM_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_EIGENPROBLEM_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EIGENPROBLEM_INITIALISE

  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for an eigenproblem solver.
  SUBROUTINE SOLVER_EIGENPROBLEM_LIBRARY_TYPE_GET(EIGENPROBLEM_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: EIGENPROBLEM_SOLVER !<A pointer the eigenproblem solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On exit, the type of library used for the eigenproblem solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
 
    ENTERS("SOLVER_EIGENPROBLEM_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(EIGENPROBLEM_SOLVER)) THEN
      SOLVER_LIBRARY_TYPE=EIGENPROBLEM_SOLVER%SOLVER_LIBRARY
    ELSE
      CALL FlagError("Eigenproblem solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_EIGENPROBLEM_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_EIGENPROBLEM_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EIGENPROBLEM_LIBRARY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for an eigenproblem solver.
  SUBROUTINE SOLVER_EIGENPROBLEM_LIBRARY_TYPE_SET(EIGENPROBLEM_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: EIGENPROBLEM_SOLVER !<A pointer the eigenproblem solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library for the eigenproblem solver to set. \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_EIGENPROBLEM_LIBRARY_TYPE_SET",err,error,*999)
    
    IF(ASSOCIATED(EIGENPROBLEM_SOLVER)) THEN
      SELECT CASE(SOLVER_LIBRARY_TYPE)
      CASE(SOLVER_CMISS_LIBRARY)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="The specified solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
          & " is invalid for an eigenproblem solver."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Dynamic solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_EIGENPROBLEM_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_EIGENPROBLEM_LIBRARY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EIGENPROBLEM_LIBRARY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Solve a eigenproblem solver
  SUBROUTINE SOLVER_EIGENPROBLEM_SOLVE(EIGENPROBLEM_SOLVER,err,error,*)

    !Argument variables
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: EIGENPROBLEM_SOLVER !<A pointer the eigenproblem solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_EIGENPROBLEM_SOLVE",err,error,*999)

    IF(ASSOCIATED(EIGENPROBLEM_SOLVER)) THEN        
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Eigenproblem solver is not associated.",err,error,*999)
    ENDIF
         
    EXITS("SOLVER_EIGENPROBLEM_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_EIGENPROBLEM_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EIGENPROBLEM_SOLVE

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating solver equations
  SUBROUTINE SOLVER_EQUATIONS_CREATE_FINISH(SOLVER_EQUATIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS !<A pointer the solver equations to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER

    ENTERS("SOLVER_EQUATIONS_CREATE_FINISH",err,error,*998)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      IF(SOLVER_EQUATIONS%SOLVER_EQUATIONS_FINISHED) THEN
        CALL FlagError("Solver equations has already been finished.",err,error,*998)
      ELSE
        SOLVER=>SOLVER_EQUATIONS%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          IF(ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
            CALL FlagError("Can not finish solver equations creation for a solver that has been linked.",err,error,*999)
          ELSE
            SOLVER_EQUATIONS%SOLVER_EQUATIONS_FINISHED=.TRUE.
          ENDIF
        ELSE
          CALL FlagError("Solver equations solver is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver equations is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_EQUATIONS_CREATE_FINISH")
    RETURN
999 CONTINUE
998 ERRORSEXITS("SOLVER_EQUATIONS_CREATE_FINISH",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EQUATIONS_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Starts the process of creating solver equations
  SUBROUTINE SOLVER_EQUATIONS_CREATE_START(SOLVER,SOLVER_EQUATIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to start the creation of solver equations on
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS !<On return, A pointer the solver equations. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_EQUATIONS_CREATE_START",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        IF(ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
          CALL FlagError("Can not start solver equations creation for a solver that has been linked.",err,error,*999)
        ELSE
          IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
            CALL FlagError("Solver equations is already associated.",err,error,*999)
          ELSE
            NULLIFY(SOLVER_EQUATIONS)
            CALL SOLVER_EQUATIONS_INITIALISE(SOLVER,err,error,*999)
            NULLIFY(SOLVER_MAPPING)
            CALL SOLVER_MAPPING_CREATE_START(SOLVER%SOLVER_EQUATIONS,SOLVER_MAPPING,err,error,*999)
            SELECT CASE(SOLVER%SOLVE_TYPE)
            CASE(SOLVER_LINEAR_TYPE)
              CALL SOLVER_MAPPING_SOLVER_MATRICES_NUMBER_SET(SOLVER_MAPPING,1,err,error,*999)
            CASE(SOLVER_NONLINEAR_TYPE)
              CALL SOLVER_MAPPING_SOLVER_MATRICES_NUMBER_SET(SOLVER_MAPPING,1,err,error,*999)
            CASE(SOLVER_DYNAMIC_TYPE)
              CALL SOLVER_MAPPING_SOLVER_MATRICES_NUMBER_SET(SOLVER_MAPPING,1,err,error,*999)
            CASE(SOLVER_DAE_TYPE)
              CALL SOLVER_MAPPING_SOLVER_MATRICES_NUMBER_SET(SOLVER_MAPPING,0,err,error,*999)
            CASE(SOLVER_EIGENPROBLEM_TYPE)
              CALL SOLVER_MAPPING_SOLVER_MATRICES_NUMBER_SET(SOLVER_MAPPING,2,err,error,*999)
            CASE DEFAULT
              localError="The solver type of "//TRIM(NumberToVString(SOLVER%SOLVE_TYPE,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
          ENDIF
        ENDIF
      ELSE
        CALL FlagError("Solver has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_EQUATIONS_CREATE_START")
    RETURN
999 ERRORSEXITS("SOLVER_EQUATIONS_CREATE_START",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EQUATIONS_CREATE_START
        
  !
  !================================================================================================================================
  !

  !>Destroys the solver equations
  SUBROUTINE SOLVER_EQUATIONS_DESTROY(SOLVER_EQUATIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS !<A pointer the solver equations to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_EQUATIONS_DESTROY",err,error,*999)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      CALL SOLVER_EQUATIONS_FINALISE(SOLVER_EQUATIONS,err,error,*999)
    ELSE
      CALL FlagError("Solver equations is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_EQUATIONS_DESTROY")
    RETURN
999 ERRORSEXITS("SOLVER_EQUATIONS_DESTROY",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EQUATIONS_DESTROY
        
  !
  !================================================================================================================================
  !

  !>Adds equations sets to solver equations. \see OpenCMISS::Iron::cmfe_SolverEquationsEquationsSetAdd
  SUBROUTINE SOLVER_EQUATIONS_EQUATIONS_SET_ADD(SOLVER_EQUATIONS,EQUATIONS_SET,EQUATIONS_SET_INDEX,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS !<A pointer the solver equations to add the equations set to.
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET !<A pointer to the equations set to add
    INTEGER(INTG), INTENT(OUT) :: EQUATIONS_SET_INDEX !<On exit, the index of the equations set that has been added
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(EquationsType), POINTER :: EQUATIONS
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(VARYING_STRING) :: localError
    LOGICAL :: TIME_COMPATIBLE,LINEARITY_COMPATIBLE
    
    ENTERS("SOLVER_EQUATIONS_EQUATIONS_SET_ADD",err,error,*999)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      IF(SOLVER_EQUATIONS%SOLVER_EQUATIONS_FINISHED) THEN
        CALL FlagError("Solver equations has already been finished.",err,error,*999)
      ELSE
        SOLVER=>SOLVER_EQUATIONS%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          IF(ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
            CALL FlagError("Can not add an equations set for a solver that has been linked.",err,error,*999)
          ELSE
            SOLVER_MAPPING=>SOLVER_EQUATIONS%SOLVER_MAPPING
            IF(ASSOCIATED(SOLVER_MAPPING)) THEN
              IF(ASSOCIATED(EQUATIONS_SET)) THEN
                EQUATIONS=>EQUATIONS_SET%EQUATIONS
                IF(ASSOCIATED(EQUATIONS)) THEN
                  TIME_COMPATIBLE=.TRUE.
                  LINEARITY_COMPATIBLE=.TRUE.
                  !Check solver equations and equations set time dependence is compatible
                  SELECT CASE(SOLVER_EQUATIONS%timeDependence)
                  CASE(SOLVER_EQUATIONS_STATIC,SOLVER_EQUATIONS_QUASISTATIC)
                    SELECT CASE(EQUATIONS%timeDependence)
                    CASE(EQUATIONS_STATIC,EQUATIONS_QUASISTATIC)
                      !OK
                    CASE DEFAULT
                      TIME_COMPATIBLE=.FALSE.
                    END SELECT
                  CASE(SOLVER_EQUATIONS_FIRST_ORDER_DYNAMIC)
                    SELECT CASE(EQUATIONS%timeDependence)
!                    
                    CASE(EQUATIONS_STATIC)
                      !OK for now, just to test!!!
!                    CASE(EQUATIONS_STATIC,EQUATIONS_QUASISTATIC)
                    CASE(EQUATIONS_QUASISTATIC)
                      !Not yet implemented, this needs to be checked to see that it works
                      TIME_COMPATIBLE=.FALSE.
                      localError="Static equations set equations with dynamic solver equations is not yet implemented."
                      CALL FlagError(localError,err,error,*999)
                    CASE(EQUATIONS_FIRST_ORDER_DYNAMIC)
                      !OK
                    CASE DEFAULT
                      TIME_COMPATIBLE=.FALSE.
                    END SELECT
                  CASE(SOLVER_EQUATIONS_SECOND_ORDER_DYNAMIC)
                    SELECT CASE(EQUATIONS%timeDependence)
                    CASE(EQUATIONS_STATIC,EQUATIONS_QUASISTATIC,EQUATIONS_FIRST_ORDER_DYNAMIC)
                      !Not implemented, this needs to be checked to see that it works
                      !TIME_COMPATIBLE=.FALSE.
                      !localError="Static or first order dynamic equations set equations with a second order dynamic "// &
                      !  & "solver equations is not yet implemented."
                      !CALL FlagError(localError,err,error,*999)
                    CASE(EQUATIONS_SECOND_ORDER_DYNAMIC)
                      !OK
                    CASE DEFAULT
                      TIME_COMPATIBLE=.FALSE.
                    END SELECT
                  CASE DEFAULT
                    TIME_COMPATIBLE=.FALSE.
                    localError="Invalid time dependence for solver equations, "// &
                      & TRIM(NumberToVString(SOLVER_EQUATIONS%timeDependence,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                  IF (.NOT. TIME_COMPATIBLE) THEN
                    localError="Invalid equations set up. The time dependence of the equations set to add ("// &
                      & TRIM(NumberToVString(EQUATIONS%timeDependence,"*",err,error))// &
                      & ") is not compatible with the solver equations time dependence ("// &
                      & TRIM(NumberToVString(SOLVER_EQUATIONS%timeDependence,"*",err,error))//")."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                  !Check solver equations and equations set linearity is compatible
                  SELECT CASE(SOLVER_EQUATIONS%LINEARITY)
                  CASE(SOLVER_EQUATIONS_LINEAR)
                    SELECT CASE(EQUATIONS%LINEARITY)
                    CASE(EQUATIONS_LINEAR)
                      !OK
                    CASE DEFAULT
                      LINEARITY_COMPATIBLE=.FALSE.
                    END SELECT
                  CASE(SOLVER_EQUATIONS_NONLINEAR)
                    SELECT CASE(EQUATIONS%LINEARITY)
                    CASE(EQUATIONS_LINEAR,EQUATIONS_NONLINEAR)
                      !OK
                    CASE DEFAULT
                      LINEARITY_COMPATIBLE=.FALSE.
                    END SELECT
                  CASE DEFAULT
                    LINEARITY_COMPATIBLE=.FALSE.
                    localError="Invalid linearity for solver equations, "// &
                      & TRIM(NumberToVString(SOLVER_EQUATIONS%LINEARITY,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                  IF (.NOT. LINEARITY_COMPATIBLE) THEN
                    localError="Invalid equations set up. The linearity of the equations set to add ("// &
                      & TRIM(NumberToVString(EQUATIONS%timeDependence,"*",err,error))// &
                      & ") is not compatible with the solver equations linearity ("// &
                      & TRIM(NumberToVString(SOLVER_EQUATIONS%timeDependence,"*",err,error))//")."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                  IF (TIME_COMPATIBLE .AND. LINEARITY_COMPATIBLE) THEN
                    CALL SOLVER_MAPPING_EQUATIONS_SET_ADD(SOLVER_MAPPING,EQUATIONS_SET,EQUATIONS_SET_INDEX,err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Equations set equations is not associated.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Equations set is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver equations solver mapping is not associated.",err,error,*999)
            ENDIF
          ENDIF
        ELSE
          CALL FlagError("Solver equations solver is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver equations is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_EQUATIONS_EQUATIONS_SET_ADD")
    RETURN
999 ERRORSEXITS("SOLVER_EQUATIONS_EQUATIONS_SET_ADD",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EQUATIONS_EQUATIONS_SET_ADD
        
  !
  !================================================================================================================================
  !

  !>Finalises the solver equations and deallocates all memory.
  SUBROUTINE SOLVER_EQUATIONS_FINALISE(SOLVER_EQUATIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS !<A pointer the solver equations to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_EQUATIONS_FINALISE",err,error,*999)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      IF(ASSOCIATED(SOLVER_EQUATIONS%SOLVER_MAPPING)) CALL SOLVER_MAPPING_DESTROY(SOLVER_EQUATIONS%SOLVER_MAPPING,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS%SOLVER_MATRICES)) CALL SOLVER_MATRICES_DESTROY(SOLVER_EQUATIONS%SOLVER_MATRICES,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS%BOUNDARY_CONDITIONS)) CALL BOUNDARY_CONDITIONS_DESTROY( &
          & SOLVER_EQUATIONS%BOUNDARY_CONDITIONS,err,error,*999)
    ENDIF

    EXITS("SOLVER_EQUATIONS_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_EQUATIONS_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EQUATIONS_FINALISE
        
  !
  !================================================================================================================================
  !

  !>Initialises the solver equations for a solver.
  SUBROUTINE SOLVER_EQUATIONS_INITIALISE(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to initialise the solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("SOLVER_EQUATIONS_INITIALISE",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(SOLVER%SOLVER_EQUATIONS)) THEN
        CALL FlagError("Solver equations is already associated for this solver.",err,error,*998)
      ELSE
        ALLOCATE(SOLVER%SOLVER_EQUATIONS,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate solver equations.",err,error,*999)
        SOLVER%SOLVER_EQUATIONS%SOLVER=>SOLVER
        SOLVER%SOLVER_EQUATIONS%SOLVER_EQUATIONS_FINISHED=.FALSE.
        SOLVER%SOLVER_EQUATIONS%sparsityType=SOLVER_SPARSE_MATRICES
        SOLVER%SOLVER_EQUATIONS%symmetryType=SOLVER_UNSYMMETRIC_MATRICES
        NULLIFY(SOLVER%SOLVER_EQUATIONS%SOLVER_MAPPING)
        NULLIFY(SOLVER%SOLVER_EQUATIONS%SOLVER_MATRICES)
        NULLIFY(SOLVER%SOLVER_EQUATIONS%BOUNDARY_CONDITIONS)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_EQUATIONS_INITIALISE")
    RETURN
999 CALL SOLVER_EQUATIONS_FINALISE(SOLVER%SOLVER_EQUATIONS,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_EQUATIONS_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EQUATIONS_INITIALISE
        
  !
  !================================================================================================================================
  !

  !>Adds an interface condition to the solver equations. \see OpenCMISS::Iron::cmfe_SolverEquationsInterfaceConditionAdd
  SUBROUTINE SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD(SOLVER_EQUATIONS,INTERFACE_CONDITION,INTERFACE_CONDITION_INDEX,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS !<A pointer the solver equations to add the interface condition to.
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION !<A pointer to the interface condition to add
    INTEGER(INTG), INTENT(OUT) :: INTERFACE_CONDITION_INDEX !<On exit, the index of the interface condition that has been added
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
   
    ENTERS("SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD",err,error,*999)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      IF(SOLVER_EQUATIONS%SOLVER_EQUATIONS_FINISHED) THEN
        CALL FlagError("Solver equations has already been finished.",err,error,*999)
      ELSE
        SOLVER=>SOLVER_EQUATIONS%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          IF(ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
            CALL FlagError("Can not add an equations set for a solver that has been linked.",err,error,*999)
          ELSE
            SOLVER_MAPPING=>SOLVER_EQUATIONS%SOLVER_MAPPING
            IF(ASSOCIATED(SOLVER_MAPPING)) THEN          
              IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
                INTERFACE_EQUATIONS=>INTERFACE_CONDITION%INTERFACE_EQUATIONS
                IF(ASSOCIATED(INTERFACE_EQUATIONS)) THEN
                  CALL SOLVER_MAPPING_INTERFACE_CONDITION_ADD(SOLVER_MAPPING,INTERFACE_CONDITION,INTERFACE_CONDITION_INDEX, &
                    & err,error,*999)
                ELSE
                  CALL FlagError("Interface condition interface equations is not associated.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Interface condition is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver equations solver mapping is not associated.",err,error,*999)
            ENDIF
          ENDIF
        ELSE
          CALL FlagError("Solver equations solver is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver equations is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD")
    RETURN
999 ERRORSEXITS("SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the linearity type for solver equations
  SUBROUTINE SOLVER_EQUATIONS_LINEARITY_TYPE_SET(SOLVER_EQUATIONS,LINEARITY_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS !<A pointer the solver equations to set the linearity type for
    INTEGER(INTG), INTENT(IN) :: LINEARITY_TYPE !<The type of linearity to be set \see SOLVER_ROUTINES_EquationLinearityTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_EQUATIONS_LINEARITY_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      IF(SOLVER_EQUATIONS%SOLVER_EQUATIONS_FINISHED) THEN
        CALL FlagError("Solver equations has already been finished.",err,error,*999)
      ELSE
        SOLVER=>SOLVER_EQUATIONS%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          IF(ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
            CALL FlagError("Can not set equations linearity for a solver that has been linked.",err,error,*999)
          ELSE
            SELECT CASE(LINEARITY_TYPE)
            CASE(SOLVER_EQUATIONS_LINEAR)
              SOLVER_EQUATIONS%LINEARITY=SOLVER_EQUATIONS_LINEAR
            CASE(SOLVER_EQUATIONS_NONLINEAR)
              SOLVER_EQUATIONS%LINEARITY=SOLVER_EQUATIONS_NONLINEAR
            CASE DEFAULT
              localError="The specified solver equations linearity type of "// &
                & TRIM(NumberToVString(LINEARITY_TYPE,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ELSE
          CALL FlagError("Solver equations solver is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver equations is not associated.",err,error,*999)
    ENDIF
   
    EXITS("SOLVER_EQUATIONS_LINEARITY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_EQUATIONS_LINEARITY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EQUATIONS_LINEARITY_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Finishes the creation of boundary conditions for the given solver equations
  SUBROUTINE SolverEquations_BoundaryConditionsCreateFinish(SOLVER_EQUATIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: SOLVER_EQUATIONS !<A pointer to the solver equations to create boundary conditions for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SolverEquations_BoundaryConditionsCreateFinish",err,error,*999)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      IF(SOLVER_EQUATIONS%SOLVER_EQUATIONS_FINISHED) THEN
        BOUNDARY_CONDITIONS=>SOLVER_EQUATIONS%BOUNDARY_CONDITIONS
        IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
          CALL BOUNDARY_CONDITIONS_CREATE_FINISH(BOUNDARY_CONDITIONS,err,error,*999)
          SOLVER=>SOLVER_EQUATIONS%SOLVER
          IF(ASSOCIATED(SOLVER)) THEN
            IF(ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
              CALL FlagError("Can not finish solver equations creation for a solver that has been linked.",err,error,*999)
            ELSE
              !Finish of the solver mapping
              CALL SOLVER_MAPPING_CREATE_FINISH(SOLVER_EQUATIONS%SOLVER_MAPPING,err,error,*999)
              !Now finish off with the solver specific actions
              SELECT CASE(SOLVER%SOLVE_TYPE)
              CASE(SOLVER_LINEAR_TYPE)
                CALL SOLVER_LINEAR_CREATE_FINISH(SOLVER%LINEAR_SOLVER,err,error,*999)
              CASE(SOLVER_NONLINEAR_TYPE)
                CALL SOLVER_NONLINEAR_CREATE_FINISH(SOLVER%NONLINEAR_SOLVER,err,error,*999)
              CASE(SOLVER_DYNAMIC_TYPE)
                CALL SOLVER_DYNAMIC_CREATE_FINISH(SOLVER%DYNAMIC_SOLVER,err,error,*999)
              CASE(SOLVER_DAE_TYPE)
                CALL SOLVER_DAE_CREATE_FINISH(SOLVER%DAE_SOLVER,err,error,*999)
              CASE(SOLVER_EIGENPROBLEM_TYPE)
                CALL SOLVER_EIGENPROBLEM_CREATE_FINISH(SOLVER%EIGENPROBLEM_SOLVER,err,error,*999)
              CASE DEFAULT
                localError="The solver type of "//TRIM(NumberToVString(SOLVER%SOLVE_TYPE,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          ENDIF
        ELSE
          CALL FlagError("Solver equations boundary conditions is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver equations are not finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver equations is not associated.",err,error,*999)
    ENDIF

    EXITS("SolverEquations_BoundaryConditionsCreateFinish")
    RETURN
999 ERRORS("SolverEquations_BoundaryConditionsCreateFinish",err,error)
    EXITS("SolverEquations_BoundaryConditionsCreateFinish")
    RETURN 1

  END SUBROUTINE SolverEquations_BoundaryConditionsCreateFinish

  !
  !================================================================================================================================
  !

  !>Starts the creation of boundary conditions for the given solver equations, and returns a pointer to the boundary conditions
  SUBROUTINE SolverEquations_BoundaryConditionsCreateStart(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: SOLVER_EQUATIONS !<A pointer to the solver equations to create boundary conditions for
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(OUT) :: BOUNDARY_CONDITIONS !<On return, a pointer the boundary conditions
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SolverEquations_BoundaryConditionsCreateStart",err,error,*999)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      IF(SOLVER_EQUATIONS%SOLVER_EQUATIONS_FINISHED) THEN
        IF(.NOT.ASSOCIATED(SOLVER_EQUATIONS%BOUNDARY_CONDITIONS)) THEN
          CALL BOUNDARY_CONDITIONS_CREATE_START(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
        ELSE
          CALL FlagError("Solver equations boundary conditions is already associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver equations are not finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver equations is not associated.",err,error,*999)
    ENDIF

    EXITS("SolverEquations_BoundaryConditionsCreateStart")
    RETURN
999 ERRORS("SolverEquations_BoundaryConditionsCreateStart",err,error)
    EXITS("SolverEquations_BoundaryConditionsCreateStart")
    RETURN 1

  END SUBROUTINE SolverEquations_BoundaryConditionsCreateStart

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations. \see OpenCMISS::Iron::cmfe_SolverEquations_SparsityTypeSet
  SUBROUTINE SOLVER_EQUATIONS_SPARSITY_TYPE_SET(SOLVER_EQUATIONS,SPARSITY_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS !<A pointer the solver equations to set the sparsity type for
    INTEGER(INTG), INTENT(IN) :: SPARSITY_TYPE !<The type of solver equations sparsity to be set \see SOLVER_ROUTINES_SparsityTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_EQUATIONS_SPARSITY_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      IF(SOLVER_EQUATIONS%SOLVER_EQUATIONS_FINISHED) THEN
        CALL FlagError("Solver equations has already been finished.",err,error,*999)
      ELSE
        SOLVER=>SOLVER_EQUATIONS%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          IF(ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
            CALL FlagError("Can not set equations sparsity for a solver that has been linked.",err,error,*999)
          ELSE
!!TODO: Maybe set the sparsity in the different types of solvers. e.g., a sparse integrator doesn't mean much.
            SELECT CASE(SPARSITY_TYPE)
            CASE(SOLVER_SPARSE_MATRICES)
              SOLVER_EQUATIONS%sparsityType=SOLVER_SPARSE_MATRICES
            CASE(SOLVER_FULL_MATRICES)
              SOLVER_EQUATIONS%sparsityType=SOLVER_FULL_MATRICES
            CASE DEFAULT
              localError="The specified solver equations sparsity type of "// &
                & TRIM(NumberToVString(SPARSITY_TYPE,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ELSE
          CALL FlagError("Solver equations solver is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver equations is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_EQUATIONS_SPARSITY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_EQUATIONS_SPARSITY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EQUATIONS_SPARSITY_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Gets the symmetry type for solver equations. \see OpenCMISS::Iron::cmfe_SolverEquations_SymmetryTypeGet
  SUBROUTINE SolverEquations_SymmetryTypeGet(solverEquations,symmetryType,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations !<A pointer the solver equations to get the symmetry type for
    INTEGER(INTG), INTENT(OUT) :: symmetryType !<On return, the type of solver equations symmetry \see SOLVER_ROUTINES_SymmetryTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(SOLVER_TYPE), POINTER :: solver
    
    ENTERS("SolverEquations_SymmetryTypeGet",err,error,*999)

    IF(.NOT.ASSOCIATED(solverEquations)) CALL FlagError("Solver equations is not associated.",err,error,*999)

    NULLIFY(solver)
    CALL SolverEquations_SolverGet(solverEquations,solver,err,error,*999)
    IF(ASSOCIATED(solver%LINKING_SOLVER)) CALL FlagError("Can not get equations sparsity for a solver that has been linked.", &
      & err,error,*999)
    
    symmetryType=solverEquations%symmetryType
    
    EXITS("SolverEquations_SymmetryTypeGet")
    RETURN
999 ERRORSEXITS("SolverEquations_SymmetryTypeGet",err,error)
    RETURN 1
   
  END SUBROUTINE SolverEquations_SymmetryTypeGet
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the symmetry type for solver equations. \see OpenCMISS::Iron::cmfe_SolverEquations_SymmetryTypeSet
  SUBROUTINE SolverEquations_SymmetryTypeSet(solverEquations,symmetryType,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations !<A pointer the solver equations to set the symmetry type for
    INTEGER(INTG), INTENT(IN) :: symmetryType !<The type of solver equations symmetry to be set \see SOLVER_ROUTINES_SymmetryTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SolverEquations_SymmetryTypeSet",err,error,*999)

    IF(.NOT.ASSOCIATED(solverEquations)) CALL FlagError("Solver equations is not associated.",err,error,*999)
    IF(solverEquations%SOLVER_EQUATIONS_FINISHED) CALL FlagError("Solver equations has already been finished.",err,error,*999)

    NULLIFY(solver)
    CALL SolverEquations_SolverGet(solverEquations,solver,err,error,*999)
    IF(ASSOCIATED(solver%LINKING_SOLVER)) CALL FlagError("Can not set equations symmetry for a solver that has been linked.", &
      & err,error,*999)
    
    SELECT CASE(symmetryType)
    CASE(SOLVER_SYMMETRIC_MATRICES)
      solverEquations%symmetryType=SOLVER_SYMMETRIC_MATRICES
    CASE(SOLVER_FULL_MATRICES)
      solverEquations%symmetryType=SOLVER_UNSYMMETRIC_MATRICES
    CASE DEFAULT
      localError="The specified solver equations symmetry type of "// &
        & TRIM(NumberToVString(symmetryType,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    
    EXITS("SolverEquations_SymmetryTypeSet")
    RETURN
999 ERRORSEXITS("SolverEquations_SymmetryTypeSet",err,error)
    RETURN 1
   
  END SUBROUTINE SolverEquations_SymmetryTypeSet
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the time dependence type for solver equations
  SUBROUTINE SOLVER_EQUATIONS_TIME_DEPENDENCE_TYPE_SET(SOLVER_EQUATIONS,TIME_DEPENDENCE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS !<A pointer the solver equations to set the sparsity type for
    INTEGER(INTG), INTENT(IN) :: TIME_DEPENDENCE_TYPE !<The type of time dependence to be set \see SOLVER_ROUTINES_EquationTimeDependenceTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_EQUATIONS_TIME_DEPENDENCE_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
      IF(SOLVER_EQUATIONS%SOLVER_EQUATIONS_FINISHED) THEN
        CALL FlagError("Solver equations has already been finished.",err,error,*999)
      ELSE
        SOLVER=>SOLVER_EQUATIONS%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          IF(ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
            CALL FlagError("Can not set equations time dependence for a solver that has been linked.",err,error,*999)
          ELSE
            SELECT CASE(TIME_DEPENDENCE_TYPE)
            CASE(SOLVER_EQUATIONS_STATIC)
              SOLVER_EQUATIONS%timeDependence=SOLVER_EQUATIONS_STATIC
            CASE(SOLVER_EQUATIONS_QUASISTATIC)
              SOLVER_EQUATIONS%timeDependence=SOLVER_EQUATIONS_QUASISTATIC
            CASE(SOLVER_EQUATIONS_FIRST_ORDER_DYNAMIC)
              SOLVER_EQUATIONS%timeDependence=SOLVER_EQUATIONS_FIRST_ORDER_DYNAMIC
            CASE(SOLVER_EQUATIONS_SECOND_ORDER_DYNAMIC)
              SOLVER_EQUATIONS%timeDependence=SOLVER_EQUATIONS_SECOND_ORDER_DYNAMIC
            CASE DEFAULT
              localError="The specified solver equations time dependence type of "// &
                & TRIM(NumberToVString(TIME_DEPENDENCE_TYPE,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ELSE
          CALL FlagError("Solver equations solver is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver equations is not associated.",err,error,*999)
    ENDIF
   
    EXITS("SOLVER_EQUATIONS_TIME_DEPENDENCE_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_EQUATIONS_TIME_DEPENDENCE_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_EQUATIONS_TIME_DEPENDENCE_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Get the number of solver matrices for the solver equations
  SUBROUTINE SolverEquations_NumberOfMatricesGet(solverEquations,numberOfMatrices,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: solverEquations !<The solver equations to get the number of matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<The number of matrices for the solver equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices

    ENTERS("SolverEquations_NumberOfMatricesGet",err,error,*999)

    IF(ASSOCIATED(solverEquations)) THEN
      solverMatrices=>solverEquations%solver_matrices
      IF(ASSOCIATED(solverMatrices)) THEN
        numberOfMatrices=solverMatrices%number_of_matrices
      ELSE
        CALL FlagError("Solver equations solver matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("Solver equations are not associated.",err,error,*999)
    END IF

    EXITS("SolverEquations_NumberOfMatricesGet")
    RETURN
999 ERRORSEXITS("SolverEquations_NumberOfMatricesGet",err,error)
    RETURN

  END SUBROUTINE SolverEquations_NumberOfMatricesGet

  !
  !================================================================================================================================
  !

  !>Get a solver matrix from the solver equations matrices
  SUBROUTINE SolverEquations_MatrixGet(solverEquations,matrixIndex,matrix,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: solverEquations !<The solver equations to get the matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The solver matrix index to get
    TYPE(DistributedMatrixType), POINTER, INTENT(INOUT) :: matrix !<On return, the requested solver matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    INTEGER(INTG) :: numberOfMatrices
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: solverMatrix

    ENTERS("SolverEquations_MatrixGet",err,error,*999)

    IF(ASSOCIATED(solverEquations)) THEN
      solverMatrices=>solverEquations%solver_matrices
      IF(ASSOCIATED(solverMatrices)) THEN
        IF(.NOT.ASSOCIATED(matrix)) THEN
          numberOfMatrices=solverMatrices%number_of_matrices
          IF(matrixIndex>0.AND.matrixIndex<=numberOfMatrices) THEN
            solverMatrix=>solverMatrices%matrices(matrixIndex)%ptr
            IF(ASSOCIATED(solverMatrix)) THEN
              matrix=>solverMatrix%matrix
            ELSE
              CALL FlagError("Solver matrices solver matrix is not associated",err,error,*999)
            END IF
          ELSE
            CALL FlagError("Invalid matrix index. The matrix index must be greater than zero and less than or equal to "// &
              & TRIM(NumberToVstring(numberOfMatrices,"*",err,error))//".",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The matrix is already associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("Solver equations solver matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("Solver equations are not associated.",err,error,*999)
    END IF

    EXITS("SolverEquations_MatrixGet")
    RETURN
999 ERRORSEXITS("SolverEquations_MatrixGet",err,error)
    RETURN

  END SUBROUTINE SolverEquations_MatrixGet

  !
  !================================================================================================================================
  !

  !>Get the Jacobian matrix from the solver equations matrices for nonlinear solver equations
  SUBROUTINE SolverEquations_JacobianMatrixGet(solverEquations,matrix,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: solverEquations !<The solver equations to get the Jacobian matrix for
    TYPE(DistributedMatrixType), POINTER, INTENT(INOUT) :: matrix !<On return, the solver equations Jacobian matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string

    ENTERS("SolverEquations_JacobianMatrixGet",err,error,*999)

    IF(ASSOCIATED(solverEquations)) THEN
      IF(solverEquations%linearity==SOLVER_EQUATIONS_NONLINEAR) THEN
        CALL SolverEquations_MatrixGet(solverEquations,1,matrix,err,error,*999)
      ELSE
        CALL FlagError("Solver equations linearity is not nonlinear.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("Solver equations are not associated.",err,error,*999)
    END IF

    EXITS("SolverEquations_JacobianMatrixGet")
    RETURN
999 ERRORSEXITS("SolverEquations_JacobianMatrixGet",err,error)
    RETURN

  END SUBROUTINE SolverEquations_JacobianMatrixGet

  !
  !================================================================================================================================
  !

  !>Get the vector assiciated with a solver matrix from the solver equations matrices
  SUBROUTINE SolverEquations_VectorGet(solverEquations,matrixIndex,vector,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: solverEquations !< The solver equations to get the vector for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !< The solver matrix index to get the vector for
    TYPE(DistributedVectorType), POINTER, INTENT(INOUT) :: vector !< On return, the requested solver matrix vector
    INTEGER(INTG), INTENT(OUT) :: err !< The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    INTEGER(INTG) :: numberOfMatrices
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: solverMatrix

    ENTERS("SolverEquations_VectorGet",err,error,*999)

    IF(ASSOCIATED(solverEquations)) THEN
      solverMatrices=>solverEquations%solver_matrices
      IF(ASSOCIATED(solverMatrices)) THEN
        IF(.NOT.ASSOCIATED(vector)) THEN
          numberOfMatrices=solverMatrices%number_of_matrices
          IF(matrixIndex>0.AND.matrixIndex<=numberOfMatrices) THEN
            solverMatrix=>solverMatrices%matrices(matrixIndex)%ptr
            IF(ASSOCIATED(solverMatrix)) THEN
              IF(ASSOCIATED(solverMatrix%solver_vector)) THEN
                vector=>solverMatrix%solver_vector
              ELSE
                CALL FlagError("There is no vector associated with this solve matrix.",err,error,*999)
              END IF
            ELSE
              CALL FlagError("Solver matrices solver matrix is not associated",err,error,*999)
            END IF
          ELSE
            CALL FlagError("Invalid matrix index. The matrix index must be greater than zero and less than or equal to "// &
              & TRIM(NumberToVstring(numberOfMatrices,"*",err,error))//".",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The vector is already associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("Solver equations solver matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("Solver equations are not associated.",err,error,*999)
    END IF

    EXITS("SolverEquations_VectorGet")
    RETURN
999 ERRORSEXITS("SolverEquations_VectorGet",err,error)
    RETURN

  END SUBROUTINE SolverEquations_VectorGet

  !
  !================================================================================================================================
  !

  !>Get the residual vector from the solver equations for nonlinear problems
  SUBROUTINE SolverEquations_ResidualVectorGet(solverEquations,residualVector,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: solverEquations !< The solver equations to get the residual vector for
    TYPE(DistributedVectorType), POINTER, INTENT(INOUT) :: residualVector !< On return, the solver residual vector
    INTEGER(INTG), INTENT(OUT) :: err !< The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices

    ENTERS("SolverEquations_ResidualVectorGet",err,error,*999)

    IF(ASSOCIATED(solverEquations)) THEN
      solverMatrices=>solverEquations%solver_matrices
      IF(ASSOCIATED(solverMatrices)) THEN
        IF(.NOT.ASSOCIATED(residualVector)) THEN
          IF(ASSOCIATED(solverMatrices%residual)) THEN
            residualVector=>solverMatrices%residual
          ELSE
            CALL FlagError("The solver matrices residual vector is not associated.",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The residual vector is already associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("Solver equations solver matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("Solver equations are not associated.",err,error,*999)
    END IF

    EXITS("SolverEquations_ResidualVectorGet")
    RETURN
999 ERRORSEXITS("SolverEquations_ResidualVectorGet",err,error)
    RETURN

  END SUBROUTINE SolverEquations_ResidualVectorGet

  !
  !================================================================================================================================
  !

  !>Get the right hand side vector from the solver equations
  SUBROUTINE SolverEquations_RhsVectorGet(solverEquations,rhsVector,err,error,*)

    !Argument variables
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: solverEquations !< The solver equations to get the right hand side vector for
    TYPE(DistributedVectorType), POINTER, INTENT(INOUT) :: rhsVector !< On return, the solver right hand side vector
    INTEGER(INTG), INTENT(OUT) :: err !< The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices

    ENTERS("SolverEquations_RhsVectorGet",err,error,*999)

    IF(ASSOCIATED(solverEquations)) THEN
      solverMatrices=>solverEquations%solver_matrices
      IF(ASSOCIATED(solverMatrices)) THEN
        IF(.NOT.ASSOCIATED(rhsVector)) THEN
          IF(ASSOCIATED(solverMatrices%rhs_vector)) THEN
            rhsVector=>solverMatrices%rhs_vector
          ELSE
            CALL FlagError("The solver matrices right hand side vector is not associated.",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The right hand side vector is already associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("Solver equations solver matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("Solver equations are not associated.",err,error,*999)
    END IF

    EXITS("SolverEquations_RhsVectorGet")
    RETURN
999 ERRORSEXITS("SolverEquations_RhsVectorGet",err,error)
    RETURN

  END SUBROUTINE SolverEquations_RhsVectorGet

  !
  !================================================================================================================================
  !

  !>Finalises a solver and deallocates all memory.
  RECURSIVE SUBROUTINE SOLVER_FINALISE(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_FINALISE",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      SOLVER%LABEL=""
      CALL SOLVER_LINEAR_FINALISE(SOLVER%LINEAR_SOLVER,err,error,*999)
      CALL SOLVER_NONLINEAR_FINALISE(SOLVER%NONLINEAR_SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_FINALISE(SOLVER%DYNAMIC_SOLVER,err,error,*999)        
      CALL SOLVER_DAE_FINALISE(SOLVER%DAE_SOLVER,err,error,*999)        
      CALL SOLVER_EIGENPROBLEM_FINALISE(SOLVER%EIGENPROBLEM_SOLVER,err,error,*999)
      CALL Solver_OptimiserFinalise(solver%optimiserSolver,err,error,*999)
      CALL SOLVER_CELLML_EVALUATOR_FINALISE(SOLVER%CELLML_EVALUATOR_SOLVER,err,error,*999)
      CALL Solver_GeometricTransformationFinalise(SOLVER%geometricTransformationSolver,err,error,*999)
      IF(.NOT.ASSOCIATED(SOLVER%LINKING_SOLVER)) &
        & CALL SOLVER_EQUATIONS_FINALISE(SOLVER%SOLVER_EQUATIONS,err,error,*999)
      IF(ALLOCATED(SOLVER%LINKED_SOLVER_TYPE_MAP)) DEALLOCATE(SOLVER%LINKED_SOLVER_TYPE_MAP)
      IF(ALLOCATED(SOLVER%LINKED_SOLVERS)) DEALLOCATE(SOLVER%LINKED_SOLVERS)
      DEALLOCATE(SOLVER)
    ENDIF 
        
    EXITS("SOLVER_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_FINALISE
  
  !
  !================================================================================================================================
  !

  !>Set the arbitrary path logical for geometric transformation solver 
  SUBROUTINE Solver_GeometricTransformationArbitraryPathSet(solver,arbitraryPath,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the field for
    LOGICAL, INTENT(IN) :: arbitraryPath !<.TRUE. if the the transformation has an arbitrary path, .FALSE. if the path is uni-directional
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Solver_GeometricTransformationArbitraryPathSet",err,error,*999)
    
    IF(ASSOCIATED(solver)) THEN
      IF(ASSOCIATED(solver%geometricTransformationSolver)) THEN
        solver%geometricTransformationSolver%arbitraryPath=arbitraryPath
      ELSE
        CALL FlagError("Geometric transformation solver is not associated for this solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("Solver_GeometricTransformationArbitraryPathSet")
    RETURN
999 ERRORS("Solver_GeometricTransformationArbitraryPathSet",err,error)
    EXITS("Solver_GeometricTransformationArbitraryPathSet")
    RETURN 1
   
  END SUBROUTINE Solver_GeometricTransformationArbitraryPathSet
  
  !
  !================================================================================================================================
  !

  !>Clear transformation for a geometric transformation solver 
  SUBROUTINE Solver_GeometricTransformationClear(solver,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the field for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: incrementIdx,i
    
    ENTERS("Solver_GeometricTransformationClear",err,error,*999)
    
    IF(ASSOCIATED(solver)) THEN
      IF(ASSOCIATED(solver%geometricTransformationSolver)) THEN
        solver%geometricTransformationSolver%transformationMatrices=0.0_DP
        DO incrementIdx=1,solver%geometricTransformationSolver%numberOfIncrements
          DO i=1,SIZE(solver%geometricTransformationSolver%transformationMatrices,1)
            solver%geometricTransformationSolver%transformationMatrices(i,i,incrementIdx)=1.0_DP
          ENDDO
        ENDDO !incrementIdx
        IF(ALLOCATED(solver%geometricTransformationSolver%scalings)) DEALLOCATE(solver%geometricTransformationSolver%scalings)
      ELSE
        CALL FlagError("Geometric transformation solver is not associated for this solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("Solver_GeometricTransformationClear")
    RETURN
    
999 ERRORSEXITS("Solver_GeometricTransformationClear",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_GeometricTransformationClear
  
  !
  !================================================================================================================================
  !

  !>Set the field and field variable type for geometric transformation solver 
  SUBROUTINE Solver_GeometricTransformationFieldSet(solver,field,variableType,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the field for
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to transformed
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to be transformed
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable,geometricFieldVariable
    INTEGER(INTG) :: numberOfGeoemtricComponents,i,j

    ENTERS("Solver_GeometricTransformationFieldSet",err,error,*999)
    
    IF(ASSOCIATED(solver)) THEN
      IF(ASSOCIATED(solver%geometricTransformationSolver)) THEN
        IF(ASSOCIATED(field)) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%ptr
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(ASSOCIATED(field%GEOMETRIC_FIELD)) THEN
              geometricFieldVariable=>field%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(1)%ptr !only 1 variable for geometric field
              IF(ASSOCIATED(geometricFieldVariable)) THEN
                numberOfGeoemtricComponents=geometricFieldVariable%NUMBER_OF_COMPONENTS
                IF(solver%geometricTransformationSolver%arbitraryPath) THEN !Allocate memory for transformation matrix at each load increment if the transformation is arbitrary at each step
                  ALLOCATE(solver%geometricTransformationSolver%transformationMatrices(numberOfGeoemtricComponents+1, &
                    & numberOfGeoemtricComponents+1,solver%geometricTransformationSolver%numberOfIncrements),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate transform matrices for geometric transformation sovler", &
                    & err,error,*999)
                ELSE !Only allocate 1 matrix if the transformation is uni-directional.
                  ALLOCATE(solver%geometricTransformationSolver%transformationMatrices(numberOfGeoemtricComponents+1, &
                    & numberOfGeoemtricComponents+1,1),STAT=err)
                  IF(err/=0) CALL FlagError("Could not allocate transform matrices for geometric transformation sovler", &
                    & err,error,*999)
                ENDIF
                solver%geometricTransformationSolver%transformationMatrices=0.0_DP
                ! Set all transformation matrices to be identity matrices
                DO i=1,SIZE(solver%geometricTransformationSolver%transformationMatrices,3)
                  DO j=1,numberOfGeoemtricComponents+1
                    solver%geometricTransformationSolver%transformationMatrices(j,j,i)=1.0_DP
                  ENDDO
                ENDDO
                solver%geometricTransformationSolver%field=>field
                solver%geometricTransformationSolver%fieldVariableType=variableType
              ELSE
                CALL FlagError("Field's geometric field variable is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Field's geometric field is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Field variable to be transformed is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Field is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Geometric transformation solver is not associated for this solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("Solver_GeometricTransformationFieldSet")
    RETURN
    
999 ERRORSEXITS("Solver_GeometricTransformationFieldSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_GeometricTransformationFieldSet
  
  !
  !================================================================================================================================
  !

  !>Set the full transformation matrix for a geometric transformation at a load increment 
  SUBROUTINE Solver_GeometricTransformationMatrixSet(solver,matrix,incrementIdx,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the field for
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(IN) :: incrementIdx !<The load increment index
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Solver_GeometricTransformationMatrixSet",err,error,*999)
    
    IF(ASSOCIATED(solver)) THEN
      IF(ASSOCIATED(solver%geometricTransformationSolver)) THEN
        IF(ASSOCIATED(solver%geometricTransformationSolver%field)) THEN 
          IF(incrementIdx>0 .AND. incrementIdx<=solver%geometricTransformationSolver%numberOfIncrements) THEN
            IF(SIZE(matrix)==SIZE(solver%geometricTransformationSolver%transformationMatrices(:,:,incrementIdx))) THEN
              solver%geometricTransformationSolver%transformationMatrices(:,:,incrementIdx)=matrix
            ELSE
              CALL FlagError("Size of matrix input does not match the transformation matrix size.", &
                & err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Load increment number out of range.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Field is not associated for this geometric transformation solver.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Geometric transformation solver is not associated for this solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_GeometricTransformationMatrixSet")
    RETURN

999 ERRORSEXITS("Solver_GeometricTransformationMatrixSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_GeometricTransformationMatrixSet
  
  !
  !================================================================================================================================
  !

  !>Set the number of load increments for geometric transformation solver 
  SUBROUTINE Solver_GeometricTransformationNumberOfLoadIncrementsSet(solver,numberOfIncrements,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the field for
    INTEGER(INTG), INTENT(IN) :: numberOfIncrements !<The number of load increments to apply the transformation
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Solver_GeometricTransformationNumberOfLoadIncrementsSet",err,error,*999)
    
    IF(ASSOCIATED(solver)) THEN
      IF(ASSOCIATED(solver%geometricTransformationSolver)) THEN
        solver%geometricTransformationSolver%numberOfIncrements=numberOfIncrements
      ELSE
        CALL FlagError("Geometric transformation solver is not associated for this solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("Solver_GeometricTransformationNumberOfLoadIncrementsSet")
    RETURN
    
999 ERRORS("Solver_GeometricTransformationNumberOfLoadIncrementsSet",err,error)
    EXITS("Solver_GeometricTransformationNumberOfLoadIncrementsSet")
    RETURN 1
   
  END SUBROUTINE Solver_GeometricTransformationNumberOfLoadIncrementsSet
  
  !
  !================================================================================================================================
  !

  !>Set the rotation for a geometric transformation 
  SUBROUTINE Solver_GeometricTransformationRotationSet(solver,pt,axis,theta,incrementIdx,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the field for
    REAL(DP), INTENT(IN) :: pt(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: theta !<The angle to rotate
    INTEGER(INTG), INTENT(IN) :: incrementIdx !<The load increment index
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: numberOfGeomComp
    REAL(DP) :: u,v,w,vectorLength,rotationMatrix(4,4),transformationMatrix(4,4)

    ENTERS("Solver_GeometricTransformationRotationSet",err,error,*999)
    
    IF(ASSOCIATED(solver)) THEN
      IF(ASSOCIATED(solver%geometricTransformationSolver)) THEN
        IF(ASSOCIATED(solver%geometricTransformationSolver%field)) THEN 
          IF(incrementIdx>0 .AND. incrementIdx<=solver%geometricTransformationSolver%numberOfIncrements) THEN
            IF(incrementIdx>1 .AND. .NOT.solver%geometricTransformationSolver%arbitraryPath) &
              & CALL FlagError("Rotating a field through multiple load increments must be specified through arbitrary path.", &
                & err,error,*999) ! Due to difficulty to scale rotation
            numberOfGeomComp=SIZE(solver%geometricTransformationSolver%transformationMatrices,1)-1
            !Add rotation to matrix at a specific step
            IF(SIZE(pt,1)==numberOfGeomComp) THEN
              IF(SIZE(axis,1)==numberOfGeomComp) THEN
                SELECT CASE(numberOfGeomComp)
                CASE(2)
                  !2D rotation
                CASE(3)
                  !3D rotation
                  vectorLength=SQRT(axis(1)**2+axis(2)**2+axis(3)**2)
                  u=axis(1)/vectorLength
                  v=axis(2)/vectorLength
                  w=axis(3)/vectorLength
                  rotationMatrix=0.0_DP
                  rotationMatrix(1,1)=u**2+(v**2+w**2)*COS(theta)
                  rotationMatrix(1,2)=u*v*(1.0_DP-COS(theta))-w*SIN(theta)
                  rotationMatrix(1,3)=u*w*(1-COS(theta))+v*SIN(theta)
                  rotationMatrix(2,1)=u*v*(1-COS(theta))+w*SIN(theta)
                  rotationMatrix(2,2)=v**2+(u**2+w**2)*COS(theta)
                  rotationMatrix(2,3)=v*w*(1-COS(theta))-u*SIN(theta)
                  rotationMatrix(3,1)=u*w*(1-COS(theta))-v*SIN(theta)
                  rotationMatrix(3,2)=v*w*(1-COS(theta))+u*SIN(theta)
                  rotationMatrix(3,3)=w**2+(u**2+v**2)*COS(theta)
                  rotationMatrix(1,4)=(pt(1)*(v**2+w**2)-u*(pt(2)*v+pt(3)*w))*(1-COS(theta))+(pt(2)*w-pt(3)*v)*SIN(theta)
                  rotationMatrix(2,4)=(pt(2)*(u**2+w**2)-v*(pt(1)*u+pt(3)*w))*(1-COS(theta))+(pt(3)*u-pt(1)*w)*SIN(theta)
                  rotationMatrix(3,4)=(pt(3)*(u**2+v**2)-w*(pt(1)*u+pt(2)*v))*(1-COS(theta))+(pt(1)*v-pt(2)*u)*SIN(theta)
                  rotationMatrix(4,4)=1.0_DP
                CASE DEFAULT
                  CALL FlagError("Number of geometric components out of range.",err,error,*999)
                END SELECT
                ! Calculate new transformation matrix by multiplying the old matrix stored with the new rotation matrix
                transformationMatrix(1:numberOfGeomComp+1,1:numberOfGeomComp+1)=MATMUL(solver%geometricTransformationSolver% & 
                  & transformationMatrices(:,:,incrementIdx),rotationMatrix(1:numberOfGeomComp+1,1:numberOfGeomComp+1))
                ! Store the new transformation matrix
                solver%geometricTransformationSolver%transformationMatrices(:,:,incrementIdx)= &
                  & transformationMatrix(1:numberOfGeomComp+1,1:numberOfGeomComp+1)
              ELSE
                CALL FlagError("Dimension of the rotation axis does not match no. field geometric components.", &
                  & err,error,*999)
              ENDIF    
            ELSE
              CALL FlagError("Dimension of the pivot point does not match no. field geometric components.", &
                & err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Load increment number out of range.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Field is not associated for this geometric transformation solver.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Geometric transformation solver is not associated for this solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_GeometricTransformationRotationSet")
    RETURN

999 ERRORSEXITS("Solver_GeometricTransformationRotationSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_GeometricTransformationRotationSet
  
  !
  !================================================================================================================================
  !

  !>Set the scalings for geometric transformation solver 
  SUBROUTINE Solver_GeometricTransformationScalingsSet(solver,scalings,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the field for
    REAL(DP), INTENT(IN) :: scalings(:) !<The scalings vector to set for uni-directional transformation
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Solver_GeometricTransformationScalingsSet",err,error,*999)
    
    IF(ASSOCIATED(solver)) THEN
      IF(ASSOCIATED(solver%geometricTransformationSolver)) THEN
        IF(solver%geometricTransformationSolver%arbitraryPath) THEN
          CALL FlagError("Transformation with arbitrary path does not have uni-directional scalings.",err,error,*999)
        ELSE
          IF(solver%geometricTransformationSolver%numberOfIncrements==SIZE(scalings)) THEN
            IF(ALLOCATED(solver%geometricTransformationSolver%scalings)) &
              & DEALLOCATE(solver%geometricTransformationSolver%scalings)
            ALLOCATE(solver%geometricTransformationSolver%scalings(SIZE(scalings)),STAT=err)
            IF(err/=0) CALL FlagError("Could not allocate scalings for geometric transformation sovler",err,error,*999)
            solver%geometricTransformationSolver%scalings(1:SIZE(scalings))=scalings(1:SIZE(scalings))
          ELSE
            CALL FlagError("Number of scalings does not match the number of increments.",err,error,*999)
          ENDIF
        ENDIF
      ELSE
        CALL FlagError("Geometric transformation solver is not associated for this solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("Solver_GeometricTransformationScalingsSet")
    RETURN
    
999 ERRORSEXITS("Solver_GeometricTransformationScalingsSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_GeometricTransformationScalingsSet
  
  !
  !================================================================================================================================
  !

  !>Set the translation for a geometric transformation 
  SUBROUTINE Solver_GeometricTransformationTranslationSet(solver,translation,incrementIdx,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the field for
    REAL(DP), INTENT(IN) :: translation(:) !<The translation vector to set
    INTEGER(INTG), INTENT(IN) :: incrementIdx !<The load increment index
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: numberOfGeomComp,i
    REAL(DP) :: transformationMatrix(4,4),translationMatrix(4,4)

    ENTERS("Solver_GeometricTransformationTranslationSet",err,error,*999)
    
    IF(ASSOCIATED(solver)) THEN
      IF(ASSOCIATED(solver%geometricTransformationSolver)) THEN
        IF(ASSOCIATED(solver%geometricTransformationSolver%field)) THEN 
          IF(incrementIdx>0 .AND. incrementIdx<=solver%geometricTransformationSolver%numberOfIncrements) THEN
            numberOfGeomComp=SIZE(solver%geometricTransformationSolver%transformationMatrices,incrementIdx)-1
            !Add translation to matrix at a specific step
            translationMatrix=0.0_DP
            transformationMatrix=0.0_DP
            DO i=1,4
              translationMatrix(i,i)=1.0_DP
            ENDDO
            IF(SIZE(translation,1)==numberOfGeomComp) THEN
              translationMatrix(1:numberOfGeomComp,numberOfGeomComp+1)=translation
              ! Calculate the new transformation matrix by multiplying the old matrix with the new translation matrix
              transformationMatrix=MATMUL(solver%geometricTransformationSolver%transformationMatrices(:,:,incrementIdx), &
                & translationMatrix(1:1+numberOfGeomComp,1:1+numberOfGeomComp))
              ! Store the new transformation matrix
              solver%geometricTransformationSolver%transformationMatrices(:,:,incrementIdx)= &
                & transformationMatrix(1:1+numberOfGeomComp,1:1+numberOfGeomComp)
            ELSE
              CALL FlagError("Number of components for translation vector does not match no. field geometric components.", &
                & err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Load increment number out of range.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Field is not associated for this geometric transformation solver.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Geometric transformation solver is not associated for this solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_GeometricTransformationTranslationSet")
    RETURN
999 ERRORS("Solver_GeometricTransformationTranslationSet",err,error)
    EXITS("Solver_GeometricTransformationTranslationSet")
    RETURN 1
   
  END SUBROUTINE Solver_GeometricTransformationTranslationSet
  
  !
  !================================================================================================================================
  !

  !>Finalise a geometric transformation solver for a solver.
  SUBROUTINE Solver_GeometricTransformationFinalise(geometricTransformationSolver,err,error,*)

    !Argument variables
    TYPE(GeometricTransformationSolverType), POINTER :: geometricTransformationSolver !<A pointer the linear solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Solver_GeometricTransformationFinalise",err,error,*999)

    IF(ASSOCIATED(geometricTransformationSolver)) THEN   
      NULLIFY(geometricTransformationSolver%solver)
      IF(ASSOCIATED(geometricTransformationSolver%field)) NULLIFY(geometricTransformationSolver%field)
      geometricTransformationSolver%arbitraryPath=.FALSE.
      IF(ALLOCATED(geometricTransformationSolver%scalings)) DEALLOCATE(geometricTransformationSolver%scalings)
      IF(ALLOCATED(geometricTransformationSolver%transformationMatrices))  &
        & DEALLOCATE(geometricTransformationSolver%transformationMatrices)
      geometricTransformationSolver%numberOfIncrements=0
      geometricTransformationSolver%fieldVariableType=0
      DEALLOCATE(geometricTransformationSolver)
    ENDIF
        
    EXITS("Solver_GeometricTransformationFinalise")
    RETURN
999 ERRORSEXITS("Solver_GeometricTransformationFinalise",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_GeometricTransformationFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialise a geometric transformation solver for a solver.
  SUBROUTINE Solver_GeometricTransformationInitialise(solver,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to initialise the geometric transformation solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(SOLVERS_TYPE), POINTER :: solvers
    TYPE(CONTROL_LOOP_TYPE), POINTER :: controlLoop
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: whileLoop
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: loadIncrementLoop
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("Solver_GeometricTransformationInitialise",err,error,*998)

    IF(ASSOCIATED(solver)) THEN
      IF(ASSOCIATED(solver%geometricTransformationSolver)) THEN
        CALL FlagError("Geometric transformation solver is already associated for this solver.",err,error,*998)
      ELSE
        !Allocate and initialise a geometric transformation solver
        ALLOCATE(solver%geometricTransformationSolver,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate solver geometric transformation solver.",err,error,*999)
        solver%geometricTransformationSolver%solver=>solver
        solver%geometricTransformationSolver%arbitraryPath=.FALSE.
        ! Set default number of load increment
        solvers=>solver%SOLVERS
        IF(ASSOCIATED(solvers)) THEN
          controlLoop=>solvers%CONTROL_LOOP
          IF(ASSOCIATED(controlLoop)) THEN
            IF(controlLoop%LOOP_TYPE==PROBLEM_CONTROL_WHILE_LOOP_TYPE) THEN
              whileLoop=>controlLoop%WHILE_LOOP
              IF(ASSOCIATED(whileLoop)) THEN
                solver%geometricTransformationSolver%numberOfIncrements=whileLoop%MAXIMUM_NUMBER_OF_ITERATIONS
              ELSE
                CALL FlagError("Control loop while loop is not associated.",err,error,*999)
              ENDIF
            ELSEIF(controlLoop%LOOP_TYPE==PROBLEM_CONTROL_LOAD_INCREMENT_LOOP_TYPE) THEN
              loadIncrementLoop=>controlLoop%LOAD_INCREMENT_LOOP
              IF(ASSOCIATED(loadIncrementLoop)) THEN
                solver%geometricTransformationSolver%numberOfIncrements=loadIncrementLoop%MAXIMUM_NUMBER_OF_ITERATIONS
              ELSE
                CALL FlagError("Control loop load increment loop is not associated.",err,error,*999)
              ENDIF
            ELSE ! For other loop types set number of increment to be 1
              solver%geometricTransformationSolver%numberOfIncrements=1
            ENDIF
          ELSE
            CALL FlagError("control loop is not associated.",err,error,*998)
          ENDIF
        ELSE
          CALL FlagError("Solvers is not associated.",err,error,*998)
        ENDIF
        ! nullify field
        NULLIFY(solver%geometricTransformationSolver%field)
        solver%geometricTransformationSolver%fieldVariableType=0
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("Solver_GeometricTransformationInitialise")
    RETURN
999 CALL Solver_GeometricTransformationFinalise(solver%geometricTransformationSolver,dummyErr,dummyError,*998)
998 ERRORSEXITS("Solver_GeometricTransformationInitialise",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_GeometricTransformationInitialise

  !
  !================================================================================================================================
  !
  
  !>Create a CellML evaluator solver for the Newton solver
  SUBROUTINE SOLVER_NEWTON_CELLML_EVALUATOR_CREATE(SOLVER,CELLML_SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the solver to create the CellML evaluator solver for
    TYPE(SOLVER_TYPE), POINTER :: CELLML_SOLVER !<On return, a pointer to the created CellML evaluator solver
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
            
    NULLIFY(CELLML_SOLVER)
    
    ENTERS("SOLVER_NEWTON_CELLML_EVALUATOR_CREATE",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      NULLIFY(NONLINEAR_SOLVER)
      IF(ASSOCIATED(SOLVER%DYNAMIC_SOLVER)) THEN
        NONLINEAR_SOLVER=>SOLVER%DYNAMIC_SOLVER%NONLINEAR_SOLVER%NONLINEAR_SOLVER
      ELSE
        NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
      ENDIF
      IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
        NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
        IF(ASSOCIATED(NEWTON_SOLVER)) THEN
          !Create the CellML evaluator solver
          ALLOCATE(NEWTON_SOLVER%CELLML_EVALUATOR_SOLVER,STAT=err)
          IF(err/=0) CALL FlagError("Cannot allocate CellML evaluator solver.",err,error,*999)
          CELLML_SOLVER=>NEWTON_SOLVER%CELLML_EVALUATOR_SOLVER
          NULLIFY(CELLML_SOLVER%SOLVERS)
          CALL SOLVER_INITIALISE_PTR(CELLML_SOLVER,err,error,*999)
          CALL SOLVER_CELLML_EVALUATOR_INITIALISE(CELLML_SOLVER,err,error,*999)
        ELSE
          CALL FlagError("Newton solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Nonlinear solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_NEWTON_CELLML_EVALUATOR_CREATE")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_CELLML_EVALUATOR_CREATE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_CELLML_EVALUATOR_CREATE

  !
  !================================================================================================================================
  !

  !>Initialise a solver for a control loop
  SUBROUTINE SOLVER_INITIALISE(SOLVERS,SOLVER_INDEX,err,error,*)

    !Argument variables
    TYPE(SOLVERS_TYPE), POINTER :: SOLVERS !<A pointer the solvers to initialise the solver for
    INTEGER(INTG), INTENT(IN) :: SOLVER_INDEX !<The solver index in solvers to initialise the solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError,localError
    
    ENTERS("SOLVER_INITIALISE",err,error,*998)

    IF(ASSOCIATED(SOLVERS)) THEN
      IF(SOLVER_INDEX>0.AND.SOLVER_INDEX<=SOLVERS%NUMBER_OF_SOLVERS) THEN
        IF(ALLOCATED(SOLVERS%SOLVERS)) THEN
          IF(ASSOCIATED(SOLVERS%SOLVERS(SOLVER_INDEX)%ptr)) THEN
            CALL FlagError("Solver pointer is already associated for this solver index.",err,error,*998)
          ELSE
            ALLOCATE(SOLVERS%SOLVERS(SOLVER_INDEX)%ptr,STAT=err)
            IF(err/=0) CALL FlagError("Could not allocate solver.",err,error,*999)
            SOLVERS%SOLVERS(SOLVER_INDEX)%ptr%SOLVERS=>SOLVERS
            CALL SOLVER_INITIALISE_PTR(SOLVERS%SOLVERS(SOLVER_INDEX)%ptr,err,error,*999)
            SOLVERS%SOLVERS(SOLVER_INDEX)%ptr%GLOBAL_NUMBER=SOLVER_INDEX
            !Default to a linear solver and initialise
            SOLVERS%SOLVERS(SOLVER_INDEX)%ptr%SOLVE_TYPE=SOLVER_LINEAR_TYPE
            CALL SOLVER_LINEAR_INITIALISE(SOLVERS%SOLVERS(SOLVER_INDEX)%ptr,err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Solvers solvers is not allocated.",err,error,*998)
        ENDIF
      ELSE
        localError="The solver index of "//TRIM(NumberToVString(SOLVER_INDEX,"*",err,error))// &
          & " is invalid. The solver index must be > 0 and <= "// &
          & TRIM(NumberToVString(SOLVERS%NUMBER_OF_SOLVERS,"*",err,error))//"."
        CALL FlagError(localError,err,error,*998)
      ENDIF
    ELSE
      CALL FlagError("Solvers is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_INITIALISE")
    RETURN
999 CALL SOLVER_FINALISE(SOLVERS%SOLVERS(SOLVER_INDEX)%ptr,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_INITIALISE

  !
  !================================================================================================================================
  !

  !>Initialise a solver 
  SUBROUTINE SOLVER_INITIALISE_PTR(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to initialise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: solver_idx
    
    ENTERS("SOLVER_INITIALISE_PTR",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      NULLIFY(SOLVER%LINKING_SOLVER)
      ALLOCATE(SOLVER%LINKED_SOLVER_TYPE_MAP(SOLVER_NUMBER_OF_SOLVER_TYPES),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocate linked solver type map.",err,error,*999)
      DO solver_idx=1,SOLVER_NUMBER_OF_SOLVER_TYPES
        NULLIFY(SOLVER%LINKED_SOLVER_TYPE_MAP(solver_idx)%ptr)
      ENDDO !solver_idx
      SOLVER%NUMBER_OF_LINKED_SOLVERS=0
      SOLVER%SOLVER_FINISHED=.FALSE.
      SOLVER%LABEL=""
      SOLVER%outputType=SOLVER_NO_OUTPUT
      NULLIFY(SOLVER%LINEAR_SOLVER)
      NULLIFY(SOLVER%NONLINEAR_SOLVER)
      NULLIFY(SOLVER%DYNAMIC_SOLVER)
      NULLIFY(SOLVER%DAE_SOLVER)
      NULLIFY(SOLVER%EIGENPROBLEM_SOLVER)
      NULLIFY(solver%optimiserSolver)
      NULLIFY(SOLVER%CELLML_EVALUATOR_SOLVER)
      NULLIFY(SOLVER%SOLVER_EQUATIONS)
      NULLIFY(SOLVER%CELLML_EQUATIONS)
      NULLIFY(SOLVER%geometricTransformationSolver)
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_INITIALISE_PTR")
    RETURN
999 ERRORSEXITS("SOLVER_INITIALISE_PTR",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_INITIALISE_PTR

  !
  !================================================================================================================================
  !

  !>Returns the label of a solver. \see OpenCMISS::Iron::cmfe_SolverLabelGet
  SUBROUTINE SOLVER_LABEL_GET_C(SOLVER,LABEL,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the solver to get the label for
    CHARACTER(LEN=*), INTENT(OUT) :: LABEL !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: C_LENGTH,VS_LENGTH

    ENTERS("SOLVER_LABEL_GET_C",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      C_LENGTH=LEN(LABEL)
      VS_LENGTH=LEN_TRIM(SOLVER%LABEL)
      IF(C_LENGTH>VS_LENGTH) THEN
        LABEL=CHAR(SOLVER%LABEL,VS_LENGTH)
      ELSE
        LABEL=CHAR(SOLVER%LABEL,C_LENGTH)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LABEL_GET_C")
    RETURN
999 ERRORSEXITS("SOLVER_LABEL_GET_C",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_LABEL_GET_C

   !
  !================================================================================================================================
  !

  !>Returns the label of a solver. \see OpenCMISS::Iron::cmfe_SolverLabelGet
  SUBROUTINE SOLVER_LABEL_GET_VS(SOLVER,LABEL,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the solver to get the label for
    TYPE(VARYING_STRING), INTENT(OUT) :: LABEL !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_LABEL_GET_VS",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      LABEL=VAR_STR(CHAR(SOLVER%LABEL))
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LABEL_GET_VS")
    RETURN
999 ERRORSEXITS("SOLVER_LABEL_GET_VS",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_LABEL_GET_VS

  !
  !================================================================================================================================
  !

  !>Sets the label of a solver. \see OpenCMISS::Iron::cmfe_SolverLabelSet
  SUBROUTINE SOLVER_LABEL_SET_C(SOLVER,LABEL,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the solver to set the label for 
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_LABEL_SET_C",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has been finished.",err,error,*999)
      ELSE
        SOLVER%LABEL=LABEL
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LABEL_SET_C")
    RETURN
999 ERRORSEXITS("SOLVER_LABEL_SET_C",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_LABEL_SET_C

  !
  !================================================================================================================================
  !

  !>Sets the label of a solver. \see OpenCMISS::Iron::cmfe_SolverLabelSet
  SUBROUTINE SOLVER_LABEL_SET_VS(SOLVER,LABEL,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the solver to set the label for 
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_LABEL_SET_VS",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has been finished.",err,error,*999)
      ELSE
        SOLVER%LABEL=LABEL
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LABEL_SET_VS")
    RETURN
999 ERRORSEXITS("SOLVER_LABEL_SET_VS",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_LABEL_SET_VS

  !
  !================================================================================================================================
  !

  !>Gets the type of library to use for the solver \see OpenCMISS::Iron::cmfe_SolverLibraryTypeGet
  SUBROUTINE SOLVER_LIBRARY_TYPE_GET(SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to get the library type of
    INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On exit, the type of library used for the solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: EIGENPROBLEM_SOLVER
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: CELLML_EVALUATOR_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      SELECT CASE(SOLVER%SOLVE_TYPE)
      CASE(SOLVER_LINEAR_TYPE)
        LINEAR_SOLVER=>SOLVER%LINEAR_SOLVER
        IF(ASSOCIATED(LINEAR_SOLVER)) THEN
          CALL SOLVER_LINEAR_LIBRARY_TYPE_GET(LINEAR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Solver linear solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_NONLINEAR_TYPE)
        NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
        IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
          CALL SOLVER_NONLINEAR_LIBRARY_TYPE_GET(NONLINEAR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Solver nonlinear solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DYNAMIC_TYPE)
        DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
        IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN         
          CALL SOLVER_DYNAMIC_LIBRARY_TYPE_GET(DYNAMIC_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
          SOLVER_LIBRARY_TYPE=DYNAMIC_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("Solver dynamic solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_DAE_TYPE)
        DAE_SOLVER=>SOLVER%DAE_SOLVER
        IF(ASSOCIATED(DAE_SOLVER)) THEN
          CALL SOLVER_DAE_LIBRARY_TYPE_GET(DAE_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Solver differential-algebraic solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_EIGENPROBLEM_TYPE)
        EIGENPROBLEM_SOLVER=>SOLVER%EIGENPROBLEM_SOLVER
        IF(ASSOCIATED(EIGENPROBLEM_SOLVER)) THEN
          CALL SOLVER_EIGENPROBLEM_LIBRARY_TYPE_GET(EIGENPROBLEM_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
          CALL FlagError("Not implemented.",err,error,*999)
        ELSE
          CALL FlagError("Solver eigenproblem solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_OPTIMISER_TYPE)
        optimiserSolver=>solver%optimiserSolver
        IF(ASSOCIATED(optimiserSolver)) THEN
          CALL Solver_OptimiserLibraryTypeGet(optimiserSolver,solver_library_type,err,error,*999)
        ELSE
          CALL FlagError("Solver optimiser solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_CELLML_EVALUATOR_TYPE)
        CELLML_EVALUATOR_SOLVER=>SOLVER%CELLML_EVALUATOR_SOLVER
        IF(ASSOCIATED(CELLML_EVALUATOR_SOLVER)) THEN
          CALL SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_GET(CELLML_EVALUATOR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Solver CellML evaluator solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The solver type of "//TRIM(NumberToVString(SOLVER%SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LIBRARY_TYPE_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library type to use for the solver. \see OpenCMISS::Iron::cmfe_SolverLibraryTypeSet
  SUBROUTINE SOLVER_LIBRARY_TYPE_SET(SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the type of
    INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library to use for the solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: EIGENPROBLEM_SOLVER
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: CELLML_EVALUATOR_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_LIBRARY_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has alredy been finished.",err,error,*999)
      ELSE
        SELECT CASE(SOLVER%SOLVE_TYPE)
        CASE(SOLVER_LINEAR_TYPE)
          LINEAR_SOLVER=>SOLVER%LINEAR_SOLVER
          IF(ASSOCIATED(LINEAR_SOLVER)) THEN
            CALL SOLVER_LINEAR_LIBRARY_TYPE_SET(LINEAR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
          ELSE
            CALL FlagError("Solver linear solver is not associated.",err,error,*999)
          ENDIF
        CASE(SOLVER_NONLINEAR_TYPE)
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            CALL SOLVER_NONLINEAR_LIBRARY_TYPE_SET(NONLINEAR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
          ELSE
            CALL FlagError("Solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        CASE(SOLVER_DYNAMIC_TYPE)
          DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
          IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
            CALL SOLVER_DYNAMIC_LIBRARY_TYPE_SET(DYNAMIC_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
          ELSE
            CALL FlagError("Solver dynamic solver is not associated.",err,error,*999)
          ENDIF
        CASE(SOLVER_DAE_TYPE)
          DAE_SOLVER=>SOLVER%DAE_SOLVER
          IF(ASSOCIATED(DAE_SOLVER)) THEN
            CALL SOLVER_DAE_LIBRARY_TYPE_SET(DAE_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
          ELSE
            CALL FlagError("Solver differential-algebraic equation solver is not associated.",err,error,*999)
          ENDIF
        CASE(SOLVER_EIGENPROBLEM_TYPE)
          EIGENPROBLEM_SOLVER=>SOLVER%EIGENPROBLEM_SOLVER
          IF(ASSOCIATED(EIGENPROBLEM_SOLVER)) THEN
            CALL SOLVER_EIGENPROBLEM_LIBRARY_TYPE_SET(EIGENPROBLEM_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
            SELECT CASE(SOLVER_LIBRARY_TYPE)
            CASE(SOLVER_CMISS_LIBRARY)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(SOLVER_PETSC_LIBRARY)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ELSE
            CALL FlagError("Solver eigenproblem solver is not associated.",err,error,*999)
          ENDIF
        CASE(SOLVER_OPTIMISER_TYPE)
          optimiserSolver=>solver%optimiserSolver
          IF(ASSOCIATED(optimiserSolver)) THEN
            CALL Solver_OptimiserLibraryTypeSet(optimiserSolver,SOLVER_LIBRARY_TYPE,err,error,*999)
          ELSE
            CALL FlagError("Solver optimiser solver is not associated.",err,error,*999)
          ENDIF
        CASE(SOLVER_CELLML_EVALUATOR_TYPE)
          CELLML_EVALUATOR_SOLVER=>SOLVER%CELLML_EVALUATOR_SOLVER
          IF(ASSOCIATED(CELLML_EVALUATOR_SOLVER)) THEN
            CALL SOLVER_CELLML_EVALUATOR_LIBRARY_TYPE_SET(CELLML_EVALUATOR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
          ELSE
            CALL FlagError("Solver CellML evaluator solver is not associated.",err,error,*999)
          ENDIF          
        CASE DEFAULT
          localError="The solver type of "//TRIM(NumberToVString(SOLVER%SOLVE_TYPE,"*",err,error))//" is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_LIBRARY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LIBRARY_TYPE_SET
  
  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a linear solver 
  SUBROUTINE SOLVER_LINEAR_CREATE_FINISH(LINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER !<A pointer to the linear solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NEWTON_LINESEARCH_SOLVER
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NEWTON_TRUSTREGION_SOLVER
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: QUASI_NEWTON_LINESEARCH_SOLVER
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: QUASI_NEWTON_TRUSTREGION_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(SOLVER_TYPE), POINTER :: LINKING_SOLVER,SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_LINEAR_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(LINEAR_SOLVER)) THEN
      SOLVER=>LINEAR_SOLVER%SOLVER
      IF(ASSOCIATED(SOLVER)) THEN
        LINKING_SOLVER=>SOLVER%LINKING_SOLVER
        IF(ASSOCIATED(LINKING_SOLVER)) THEN
          IF(LINKING_SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
            NONLINEAR_SOLVER=>LINKING_SOLVER%NONLINEAR_SOLVER
            IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
              IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
                NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
                IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                  SELECT CASE(NEWTON_SOLVER%NEWTON_SOLVE_TYPE)
                  CASE(SOLVER_NEWTON_LINESEARCH)
                    NEWTON_LINESEARCH_SOLVER=>NEWTON_SOLVER%LINESEARCH_SOLVER
                    IF(ASSOCIATED(NEWTON_LINESEARCH_SOLVER)) THEN
                      LINEAR_SOLVER%LINKED_NEWTON_PETSC_SOLVER=NEWTON_LINESEARCH_SOLVER%SOLVER_LIBRARY==SOLVER_PETSC_LIBRARY
                    ELSE
                      CALL FlagError("Newton solver linesearch solver is not associated.",err,error,*999)
                    ENDIF
                  CASE(SOLVER_NEWTON_TRUSTREGION)
                    NEWTON_TRUSTREGION_SOLVER=>NEWTON_SOLVER%TRUSTREGION_SOLVER
                    IF(ASSOCIATED(NEWTON_TRUSTREGION_SOLVER)) THEN
                      LINEAR_SOLVER%LINKED_NEWTON_PETSC_SOLVER= &
                        & NEWTON_TRUSTREGION_SOLVER%SOLVER_LIBRARY==SOLVER_PETSC_LIBRARY
                    ELSE
                      CALL FlagError("Newton solver linesearch solver is not associated.",err,error,*999)
                    ENDIF
                  CASE DEFAULT
                    localError="The Newton solve type of "// &
                      & TRIM(NumberToVString(NEWTON_SOLVER%NEWTON_SOLVE_TYPE,"*",err,error))//"is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                ELSE
                  CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
                ENDIF
              ELSEIF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
                QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
                IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                  SELECT CASE(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE)
                  CASE(SOLVER_QUASI_NEWTON_LINESEARCH)
                    QUASI_NEWTON_LINESEARCH_SOLVER=>QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER
                    IF(ASSOCIATED(QUASI_NEWTON_LINESEARCH_SOLVER)) THEN
                      LINEAR_SOLVER%LINKED_NEWTON_PETSC_SOLVER= &
                        & QUASI_NEWTON_LINESEARCH_SOLVER%SOLVER_LIBRARY==SOLVER_PETSC_LIBRARY
                    ELSE
                      CALL FlagError("Quasi-Newton solver linesearch solver is not associated.",err,error,*999)
                    ENDIF
                  CASE(SOLVER_QUASI_NEWTON_TRUSTREGION)
                    QUASI_NEWTON_TRUSTREGION_SOLVER=>QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER
                    IF(ASSOCIATED(QUASI_NEWTON_TRUSTREGION_SOLVER)) THEN
                      LINEAR_SOLVER%LINKED_NEWTON_PETSC_SOLVER= &
                        & QUASI_NEWTON_TRUSTREGION_SOLVER%SOLVER_LIBRARY==SOLVER_PETSC_LIBRARY
                    ELSE
                      CALL FlagError("Quasi-Newton solver linesearch solver is not associated.",err,error,*999)
                    ENDIF
                  CASE DEFAULT
                    localError="The Quasi-Newton solve type of "// &
                      & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE,"*",err,error))//"is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                ELSE
                  CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
                ENDIF
              ENDIF
            ELSE
              CALL FlagError("Linking solver nonlinear solver is not associated.",err,error,*999)
            ENDIF
          ENDIF
        ENDIF
        SELECT CASE(LINEAR_SOLVER%LINEAR_SOLVE_TYPE)
        CASE(SOLVER_LINEAR_DIRECT_SOLVE_TYPE)
          CALL SOLVER_LINEAR_DIRECT_CREATE_FINISH(LINEAR_SOLVER%DIRECT_SOLVER,err,error,*999)
        CASE(SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE)
          CALL SOLVER_LINEAR_ITERATIVE_CREATE_FINISH(LINEAR_SOLVER%ITERATIVE_SOLVER,err,error,*999)
        CASE DEFAULT
          localError="The linear solver type of "//TRIM(NumberToVString(LINEAR_SOLVER%LINEAR_SOLVE_TYPE,"*",err,error))// &
            & " is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE
        CALL FlagError("Linear solver solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Linear solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_LINEAR_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_CREATE_FINISH",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Finalise a Cholesky direct linear solver and deallocate all memory.
  SUBROUTINE SOLVER_LINEAR_DIRECT_CHOLESKY_FINALISE(DIRECT_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DIRECT_SOLVER !<A pointer to the linear direct solver to finalise the Cholesky solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_LINEAR_DIRECT_CHOLESKY_FINALISE",err,error,*999)

    IF(ASSOCIATED(DIRECT_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ENDIF

    EXITS("SOLVER_LINEAR_DIRECT_CHOLESKY_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_DIRECT_CHOLESKY_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_DIRECT_CHOLESKY_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a Cholesky direct linear solver for a direct linear solver.
  SUBROUTINE SOLVER_LINEAR_DIRECT_CHOLESKY_INITIALISE(DIRECT_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DIRECT_SOLVER !<A pointer the direct linear solver to initialise the Cholesky direct linear solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    
    ENTERS("SOLVER_LINEAR_DIRECT_CHOLESKY_INITIALISE",err,error,*999)

    IF(ASSOCIATED(DIRECT_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Direct linear solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_LINEAR_DIRECT_CHOLESKY_INITIALISE")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_DIRECT_CHOLESKY_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_DIRECT_CHOLESKY_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a linear direct solver 
  SUBROUTINE SOLVER_LINEAR_DIRECT_CREATE_FINISH(LINEAR_DIRECT_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: LINEAR_DIRECT_SOLVER !<A pointer to the linear direct solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER
    TYPE(DistributedMatrixType), POINTER :: SOLVER_MATRIX
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_LINEAR_DIRECT_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(LINEAR_DIRECT_SOLVER)) THEN
      LINEAR_SOLVER=>LINEAR_DIRECT_SOLVER%LINEAR_SOLVER
      IF(ASSOCIATED(LINEAR_SOLVER)) THEN
        SOLVER=>LINEAR_SOLVER%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          SELECT CASE(LINEAR_DIRECT_SOLVER%DIRECT_SOLVER_TYPE)
          CASE(SOLVER_DIRECT_LU)
            IF(ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
              !Matrices have already been set up by linking solver
              SELECT CASE(LINEAR_DIRECT_SOLVER%SOLVER_LIBRARY)
              CASE(SOLVER_CMISS_LIBRARY) !All non-PETSc libraries
                CALL FlagError("Non-PETSc linear solver cannot be linked to PETSc nonlinear solver.",err,error,*999)
              END SELECT
              SOLVER_EQUATIONS=>SOLVER%LINKING_SOLVER%SOLVER_EQUATIONS
              IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
                SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
                IF(.NOT.ASSOCIATED(SOLVER_MATRICES)) &
                  & CALL FlagError("Linked solver equation solver matrices is not associated.",err,error,*999)
              ELSE
                CALL FlagError("Linked solver solver equations is not associated.",err,error,*999)
              ENDIF
            ELSE
              !Set up solver matrices
              SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
              IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
                !Create the solver matrices
                NULLIFY(SOLVER_MATRICES)
                CALL SOLVER_MATRICES_CREATE_START(SOLVER_EQUATIONS,SOLVER_MATRICES,err,error,*999)
                CALL SolverMatrices_LibraryTypeSet(SOLVER_MATRICES,LINEAR_DIRECT_SOLVER%SOLVER_LIBRARY, &
                  & err,error,*999)

                SELECT CASE(SOLVER_EQUATIONS%sparsityType)
                CASE(SOLVER_SPARSE_MATRICES)
                  CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE], &
                    & err,error,*999)
                CASE(SOLVER_FULL_MATRICES)
                  CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE], &
                    & err,error,*999)
                CASE DEFAULT
                  localError="The specified solver equations sparsity type of "// &
                    & TRIM(NumberToVString(SOLVER_EQUATIONS%sparsityType,"*",err,error))// &
                    & " is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
                SELECT CASE(SOLVER_EQUATIONS%symmetryType)
                CASE(SOLVER_SYMMETRIC_MATRICES)
                  CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_SYMMETRIC_TYPE],err,error,*999)
                CASE(SOLVER_UNSYMMETRIC_MATRICES)
                  CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_UNSYMMETRIC_TYPE],err,error,*999)
                CASE DEFAULT
                  localError="The specified solver equations symmetry type of "// &
                    & TRIM(NumberToVString(SOLVER_EQUATIONS%symmetryType,"*",err,error))// &
                    & " is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
                CALL SOLVER_MATRICES_CREATE_FINISH(SOLVER_MATRICES,err,error,*999)
              ELSE
                CALL FlagError("Solver solver equations is not associated.",err,error,*999)
              ENDIF
            ENDIF

            !Set up direct solver
            SELECT CASE(LINEAR_DIRECT_SOLVER%SOLVER_LIBRARY)
            CASE(SOLVER_CMISS_LIBRARY)
              !Nothing else to do
            CASE(SOLVER_MUMPS_LIBRARY,SOLVER_SUPERLU_LIBRARY,SOLVER_PASTIX_LIBRARY,SOLVER_LAPACK_LIBRARY)
              !Set up solver through PETSc
              CALL Petsc_KSPCreate(computationalEnvironment%mpiCommunicator,LINEAR_DIRECT_SOLVER%KSP,err,error,*999)

              !Set any further KSP options from the command line options
              CALL Petsc_KSPSetFromOptions(LINEAR_DIRECT_SOLVER%KSP,err,error,*999)
              !Set the solver matrix to be the KSP matrix
              IF(SOLVER_MATRICES%NUMBER_OF_MATRICES==1) THEN
                SOLVER_MATRIX=>SOLVER_MATRICES%matrices(1)%ptr%MATRIX
                IF(ASSOCIATED(SOLVER_MATRIX)) THEN
                  IF(ASSOCIATED(SOLVER_MATRIX%PETSC)) THEN
                    CALL Petsc_KSPSetOperators(LINEAR_DIRECT_SOLVER%KSP,SOLVER_MATRIX%PETSC%MATRIX,SOLVER_MATRIX%PETSC%MATRIX, &
                      & err,error,*999)
                    !Check that the solver supports the matrix sparsity type
                    SELECT CASE(SOLVER_EQUATIONS%sparsityType)
                    CASE(SOLVER_FULL_MATRICES)
                      SELECT CASE(LINEAR_DIRECT_SOLVER%SOLVER_LIBRARY)
                      CASE(SOLVER_MUMPS_LIBRARY,SOLVER_SUPERLU_LIBRARY,SOLVER_PASTIX_LIBRARY)
                          CALL FlagError("Solver library does not support full matrices. Please use sparse matrices "// &
                            & "or select the LAPACK library type for the linear direct solver.",err,error,*999)
                      END SELECT
                    CASE(SOLVER_SPARSE_MATRICES)
                      SELECT CASE(LINEAR_DIRECT_SOLVER%SOLVER_LIBRARY)
                      CASE(SOLVER_LAPACK_LIBRARY)
                          CALL FlagError("Solver library does not support sparse matrices. Please use full matrices "// &
                            & "or select another solver library type for the linear direct solver.",err,error,*999)
                      END SELECT
                    END SELECT
                    !Set the KSP type to preonly
                    CALL Petsc_KSPSetType(LINEAR_DIRECT_SOLVER%KSP,PETSC_KSPPREONLY,err,error,*999)
                    !Get the pre-conditioner
                    CALL Petsc_KSPGetPC(LINEAR_DIRECT_SOLVER%KSP,LINEAR_DIRECT_SOLVER%PC,err,error,*999)
                    !Set the PC type to LU
                    CALL Petsc_PCSetType(LINEAR_DIRECT_SOLVER%PC,PETSC_PCLU,err,error,*999)
                    SELECT CASE(LINEAR_DIRECT_SOLVER%SOLVER_LIBRARY)
                    CASE(SOLVER_MUMPS_LIBRARY)
                      !Set the PC factorisation package to MUMPS
                      CALL Petsc_PCFactorSetMatSolverPackage(LINEAR_DIRECT_SOLVER%PC,PETSC_MAT_SOLVER_MUMPS,err,error,*999)
                    CASE(SOLVER_SUPERLU_LIBRARY)
                      !Set the PC factorisation package to SuperLU_DIST
                      CALL Petsc_PCFactorSetMatSolverPackage(LINEAR_DIRECT_SOLVER%PC,PETSC_MAT_SOLVER_SUPERLU_DIST, &
                        & err,error,*999)
                    CASE(SOLVER_LAPACK_LIBRARY)
                      CALL FlagError("LAPACK not available in this version of PETSc.",err,error,*999)
                    CASE(SOLVER_PASTIX_LIBRARY)
                      !Set the PC factorisation package to PaStiX
                      CALL Petsc_PCFactorSetMatSolverPackage(LINEAR_DIRECT_SOLVER%PC,PETSC_MAT_SOLVER_PASTIX,err,error,*999)
                    END SELECT
                  ELSE
                    CALL FlagError("Solver matrix PETSc is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Solver matrices distributed matrix is not associated.",err,error,*999)
                ENDIF
              ELSE
                localError="The given number of solver matrices of "// &
                  & TRIM(NumberToVString(SOLVER_MATRICES%NUMBER_OF_MATRICES,"*",err,error))// &
                  & " is invalid. There should only be one solver matrix for a linear direct solver."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            CASE(SOLVER_SPOOLES_LIBRARY)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(SOLVER_UMFPACK_LIBRARY)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(SOLVER_LUSOL_LIBRARY)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE(SOLVER_ESSL_LIBRARY)
              CALL FlagError("Not implemented.",err,error,*999)
            CASE DEFAULT
              localError="The solver library type of "// &
                & TRIM(NumberToVString(LINEAR_DIRECT_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          CASE(SOLVER_DIRECT_CHOLESKY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_DIRECT_SVD)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The direct solver type of "// &
              & TRIM(NumberToVString(LINEAR_DIRECT_SOLVER%DIRECT_SOLVER_TYPE,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("Linear solver solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Linear direct solver linear solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Linear direct solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LINEAR_DIRECT_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_DIRECT_CREATE_FINISH",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_LINEAR_DIRECT_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Finalise a direct linear solver for a linear solver and deallocate all memory.
  SUBROUTINE SOLVER_LINEAR_DIRECT_FINALISE(LINEAR_DIRECT_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: LINEAR_DIRECT_SOLVER !<A pointer to the lienar direct solver to finalise
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_LINEAR_DIRECT_FINALISE",err,error,*999)

    IF(ASSOCIATED(LINEAR_DIRECT_SOLVER)) THEN
      LINEAR_SOLVER=>LINEAR_DIRECT_SOLVER%LINEAR_SOLVER
      IF(ASSOCIATED(LINEAR_SOLVER)) THEN
        IF(.NOT.LINEAR_SOLVER%LINKED_NEWTON_PETSC_SOLVER) THEN
          CALL SOLVER_LINEAR_DIRECT_LU_FINALISE(LINEAR_DIRECT_SOLVER,err,error,*999)
        ENDIF
      ENDIF
      DEALLOCATE(LINEAR_DIRECT_SOLVER)
    ENDIF

    EXITS("SOLVER_LINEAR_DIRECT_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_DIRECT_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_DIRECT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a direct linear solver for a lienar solver
  SUBROUTINE SOLVER_LINEAR_DIRECT_INITIALISE(LINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER !<A pointer the linear solver to initialise the direct solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_LINEAR_DIRECT_INITIALISE",err,error,*998)

    IF(ASSOCIATED(LINEAR_SOLVER)) THEN
      IF(ASSOCIATED(LINEAR_SOLVER%DIRECT_SOLVER)) THEN
        CALL FlagError("Direct solver is already associated for this linear solver.",err,error,*998)
      ELSE
        ALLOCATE(LINEAR_SOLVER%DIRECT_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate linear solver direct solver.",err,error,*999)
        LINEAR_SOLVER%DIRECT_SOLVER%LINEAR_SOLVER=>LINEAR_SOLVER
        !Default to an LU direct linear solver
        LINEAR_SOLVER%DIRECT_SOLVER%DIRECT_SOLVER_TYPE=SOLVER_DIRECT_LU
        CALL SOLVER_LINEAR_DIRECT_LU_INITIALISE(LINEAR_SOLVER%DIRECT_SOLVER,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Linear solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_LINEAR_DIRECT_INITIALISE")
    RETURN
999 CALL SOLVER_LINEAR_DIRECT_FINALISE(LINEAR_SOLVER%DIRECT_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_LINEAR_DIRECT_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_DIRECT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for a direct linear solver.
  SUBROUTINE SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_GET(DIRECT_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DIRECT_SOLVER !<A pointer the direct linear solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On exit, the type of library used for the direct linear solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
 
    ENTERS("SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(DIRECT_SOLVER)) THEN
      SELECT CASE(DIRECT_SOLVER%DIRECT_SOLVER_TYPE)
      CASE(SOLVER_DIRECT_LU)
        SOLVER_LIBRARY_TYPE=DIRECT_SOLVER%SOLVER_LIBRARY
      CASE(SOLVER_DIRECT_CHOLESKY)
        SOLVER_LIBRARY_TYPE=DIRECT_SOLVER%SOLVER_LIBRARY
      CASE(SOLVER_DIRECT_SVD)
        SOLVER_LIBRARY_TYPE=DIRECT_SOLVER%SOLVER_LIBRARY
      CASE DEFAULT
        localError="The direct linear solver type of "// &
          & TRIM(NumberToVString(DIRECT_SOLVER%DIRECT_SOLVER_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Direct linear solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for a direct linear solver.
  SUBROUTINE SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_SET(DIRECT_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DIRECT_SOLVER !<A pointer the direct linear solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library for the direct linear solver to set. \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_SET",err,error,*999)
    
    IF(ASSOCIATED(DIRECT_SOLVER)) THEN
      SELECT CASE(DIRECT_SOLVER%DIRECT_SOLVER_TYPE)
      CASE(SOLVER_DIRECT_LU)
        SELECT CASE(SOLVER_LIBRARY_TYPE)
        CASE(SOLVER_CMISS_LIBRARY)
          CALL FlagError("Not implemeted.",err,error,*999)
        CASE(SOLVER_MUMPS_LIBRARY)
          DIRECT_SOLVER%SOLVER_LIBRARY=SOLVER_MUMPS_LIBRARY
        CASE(SOLVER_SUPERLU_LIBRARY)
          DIRECT_SOLVER%SOLVER_LIBRARY=SOLVER_SUPERLU_LIBRARY
        CASE(SOLVER_SPOOLES_LIBRARY)
          CALL FlagError("Not implemeted.",err,error,*999)
        CASE(SOLVER_LUSOL_LIBRARY)
          CALL FlagError("Not implemeted.",err,error,*999)
        CASE(SOLVER_ESSL_LIBRARY)
          CALL FlagError("Not implemeted.",err,error,*999)
        CASE(SOLVER_LAPACK_LIBRARY)
          DIRECT_SOLVER%SOLVER_LIBRARY=SOLVER_LAPACK_LIBRARY
        CASE(SOLVER_PASTIX_LIBRARY)
          DIRECT_SOLVER%SOLVER_LIBRARY=SOLVER_PASTIX_LIBRARY
        CASE DEFAULT
          localError="The specified solver library type of "// &
            & TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
            & " is invalid for a LU direct linear solver."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      CASE(SOLVER_DIRECT_CHOLESKY)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_DIRECT_SVD)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="The direct linear solver type of "// &
          & TRIM(NumberToVString(DIRECT_SOLVER%DIRECT_SOLVER_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Direct linear solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Finalise a LU direct linear solver and deallocate all memory.
  SUBROUTINE SOLVER_LINEAR_DIRECT_LU_FINALISE(DIRECT_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DIRECT_SOLVER !<A pointer to the linear direct solver to finalise the LU solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_LINEAR_DIRECT_LU_FINALISE",err,error,*999)

    IF(ASSOCIATED(DIRECT_SOLVER)) THEN
      SELECT CASE(DIRECT_SOLVER%SOLVER_LIBRARY)
      CASE(SOLVER_CMISS_LIBRARY)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_MUMPS_LIBRARY)
        !Call MUMPS through PETSc
        CALL Petsc_PCFinalise(DIRECT_SOLVER%PC,err,error,*999)
        CALL Petsc_KSPFinalise(DIRECT_SOLVER%KSP,err,error,*999)
      CASE(SOLVER_SUPERLU_LIBRARY)
        !Call SuperLU through PETSc
        CALL Petsc_PCFinalise(DIRECT_SOLVER%PC,err,error,*999)
        CALL Petsc_KSPFinalise(DIRECT_SOLVER%KSP,err,error,*999)
      CASE(SOLVER_SPOOLES_LIBRARY)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_UMFPACK_LIBRARY)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_LUSOL_LIBRARY)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_ESSL_LIBRARY)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_LAPACK_LIBRARY)
        !Call SuperLU through PETSc
        CALL Petsc_PCFinalise(DIRECT_SOLVER%PC,err,error,*999)
        CALL Petsc_KSPFinalise(DIRECT_SOLVER%KSP,err,error,*999)
      CASE(SOLVER_PASTIX_LIBRARY)
        !Call PaStiX through PETSc
        CALL Petsc_PCFinalise(DIRECT_SOLVER%PC,err,error,*999)
        CALL Petsc_KSPFinalise(DIRECT_SOLVER%KSP,err,error,*999)
      CASE DEFAULT
        localError="The solver library type of "// &
          & TRIM(NumberToVString(DIRECT_SOLVER%SOLVER_LIBRARY,"*",err,error))// &
          & " is invalid for a LU direct linear solver."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ENDIF

    EXITS("SOLVER_LINEAR_DIRECT_LU_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_DIRECT_LU_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_DIRECT_LU_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a LU direct linear solver for a direct linear solver.
  SUBROUTINE SOLVER_LINEAR_DIRECT_LU_INITIALISE(DIRECT_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DIRECT_SOLVER !<A pointer the direct linear solver to initialise the LU direct linear solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_LINEAR_DIRECT_LU_INITIALISE",err,error,*998)

    IF(ASSOCIATED(DIRECT_SOLVER)) THEN
      !Default to MUMPS library
      DIRECT_SOLVER%SOLVER_LIBRARY=SOLVER_MUMPS_LIBRARY
      !Call MUMPS through PETSc
      CALL Petsc_PCInitialise(DIRECT_SOLVER%PC,err,error,*999)
      CALL Petsc_KSPInitialise(DIRECT_SOLVER%KSP,err,error,*999)
    ELSE
      CALL FlagError("Direct linear solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_LINEAR_DIRECT_LU_INITIALISE")
    RETURN
999 CALL SOLVER_LINEAR_DIRECT_LU_FINALISE(DIRECT_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_LINEAR_DIRECT_LU_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_DIRECT_LU_INITIALISE

  !
  !================================================================================================================================
  !

!!\todo Allow for the mumps parameters to be set during the solver creation (i.e., cache and defer setting until we have PETSc matrix)
  
  !>Sets MUMPS ICNTL(icntl)=ivalue through PETSc Mat API (see MUMPS user guide for more info). Must be called after the boundary conditions have been set up.
  SUBROUTINE Solver_MumpsSetIcntl(solver,icntl,ivalue,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver
    INTEGER(INTG), INTENT(IN) :: icntl !<The MUMPS ICNTL integer control parameter 
    INTEGER(INTG), INTENT(IN) :: ivalue !<The MUMPS ICNTL integer value to set: ICNTL(icntl)=ivalue
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: linearSolver
    TYPE(DistributedMatrixType), POINTER :: solverMatrix
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: linearDirectSolver
    TYPE(SOLVER_TYPE), POINTER :: linkingSolver
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: linkingSolverEquations,solverEquations
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices
    TYPE(PetscMatType) :: petscFactoredMatrix !<The factored matrix obtained by calling MatGetFactor() from PETSc-MUMPS interface 
    TYPE(VARYING_STRING) :: localError

    ENTERS("Solver_MumpsSetIcntl",err,error,*999)

    IF(ASSOCIATED(solver)) THEN
      IF(solver%SOLVE_TYPE==SOLVER_LINEAR_TYPE) THEN
        linearSolver=>solver%LINEAR_SOLVER
        IF(ASSOCIATED(linearSolver)) THEN
          IF(linearSolver%LINEAR_SOLVE_TYPE==SOLVER_LINEAR_DIRECT_SOLVE_TYPE) THEN
            linearDirectSolver=>linearSolver%DIRECT_SOLVER
            IF(ASSOCIATED(linearDirectSolver)) THEN
              SELECT CASE(linearDirectSolver%DIRECT_SOLVER_TYPE)
              CASE(SOLVER_DIRECT_LU)
                SELECT CASE(linearDirectSolver%SOLVER_LIBRARY)
                CASE(SOLVER_MUMPS_LIBRARY)
                  solverEquations=>solver%SOLVER_EQUATIONS
                  NULLIFY(solverMatrices)
                  IF(ASSOCIATED(solverEquations)) THEN
                    !Solver equations for this solver.
                    solverMatrices=>solverEquations%SOLVER_MATRICES
                  ELSE
                    !No solver equations. See if there are solver equations in the linking solver.
                    linkingSolver=>solver%LINKING_SOLVER
                    IF(ASSOCIATED(linkingSolver)) THEN
                      linkingSolverEquations=>linkingSolver%SOLVER_EQUATIONS
                      IF(ASSOCIATED(linkingSolverEquations)) THEN
                        solverMatrices=>linkingSolverEquations%SOLVER_MATRICES
                      ELSE
                        CALL FlagError("Solver equations is not associated for the linking solver.",err,error,*999)
                      ENDIF
                    ENDIF
                  ENDIF
                  IF(ASSOCIATED(solverMatrices)) THEN
                    IF(solverMatrices%NUMBER_OF_MATRICES==1) THEN
                      solverMatrix=>solverMatrices%matrices(1)%ptr%MATRIX
                      IF(ASSOCIATED(solverMatrix)) THEN
                        IF(ASSOCIATED(solverMatrix%PETSC)) THEN
                          !Call MatGetFactor to create matrix petscFactoredMatrix from preconditioner context
                          CALL Petsc_PCFactorSetUpMatSolverPackage(linearDirectSolver%pc,err,error,*999)
                          CALL Petsc_PCFactorGetMatrix(linearDirectSolver%pc,petscFactoredMatrix,err,error,*999)
                          !Set ICNTL(icntl)=ivalue
                          CALL Petsc_MatMumpsSetIcntl(petscFactoredMatrix,icntl,ivalue,err,error,*999)
                        ELSE
                          CALL FlagError("Solver matrix PETSc is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Solver matrices distributed matrix is not associated.",err,error,*999)
                      ENDIF
                    ELSE
                      localError="The given number of solver matrices of "// &
                        & TRIM(NumberToVstring(solverMatrices%NUMBER_OF_MATRICES,"*",err,error))// &
                        & " is invalid. There should only be one solver matrix for a linear direct solver."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Solver matrices not associated.",err,error,*999)
                  ENDIF
                CASE DEFAULT
                  localError="The solver library type of "// &
                    & TRIM(NumberToVstring(linearDirectSolver%SOLVER_LIBRARY,"*",err,error))//" is invalid. "// &
                    & "Use MUMPS library when calling Solver_MumpsSetIcntl"
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              CASE(SOLVER_DIRECT_CHOLESKY)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(SOLVER_DIRECT_SVD)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The direct solver type of "// &
                  & TRIM(NumberToVstring(linearDirectSolver%DIRECT_SOLVER_TYPE,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
          ELSE
            CALL FlagError("Linear solver direct solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Solver is not a direct linear solver.",err,error,*999)
        ENDIF
      ELSE
         CALL FlagError("Solver linear solver is not associated.",err,error,*999)
       ENDIF
      ELSE
        CALL FlagError("Solver is not a linear solver.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_MumpsSetIcntl")
    RETURN
999 ERRORSEXITS("Solver_MumpsSetIcntl",err,error)    
    RETURN 1
    
  END SUBROUTINE Solver_MumpsSetIcntl

  !
  !================================================================================================================================
  !

!!\todo Allow for the mumps parameters to be set during the solver creation (i.e., cache and defer setting until we have PETSc matrix)

  !>Sets MUMPS CNTL(icntl)=val through PETSc Mat API (see MUMPS user guide for more info). Must be called after the boundary conditions have been set up.
  SUBROUTINE Solver_MumpsSetCntl(solver,icntl,val,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver
    INTEGER(INTG), INTENT(IN) :: icntl !<The MUMPS ICNTL integer control parameter 
    REAL(DP), INTENT(IN) :: val !<The MUMPS CNTL real value to set: CNTL(icntl)=val
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: linearSolver
    TYPE(DistributedMatrixType), POINTER :: solverMatrix
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: linearDirectSolver
    TYPE(SOLVER_TYPE), POINTER :: linkingSolver
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: linkingSolverEquations,solverEquations
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices
    TYPE(PetscMatType) :: petscFactoredMatrix !<The factored matrix obtained by calling MatGetFactor() from PETSc-MUMPS interface 
    TYPE(VARYING_STRING) :: localError

    ENTERS("Solver_MumpsSetCntl",err,error,*999)

    IF(ASSOCIATED(solver)) THEN
      linearSolver=>solver%LINEAR_SOLVER
      IF(ASSOCIATED(linearSolver)) THEN
        linearDirectSolver=>linearSolver%DIRECT_SOLVER
        IF(ASSOCIATED(linearDirectSolver)) THEN
          SELECT CASE(linearDirectSolver%DIRECT_SOLVER_TYPE)
          CASE(SOLVER_DIRECT_LU)
            SELECT CASE(linearDirectSolver%SOLVER_LIBRARY)
            CASE(SOLVER_MUMPS_LIBRARY)
              solverEquations=>solver%SOLVER_EQUATIONS
              NULLIFY(solverMatrices)
              IF(ASSOCIATED(solverEquations)) THEN
                !Solver equations for this solver.
                solverMatrices=>solverEquations%SOLVER_MATRICES
              ELSE
                !No solver equations. See if there are solver equations in the linking solver.
                linkingSolver=>solver%LINKING_SOLVER
                IF(ASSOCIATED(linkingSolver)) THEN
                  linkingSolverEquations=>linkingSolver%SOLVER_EQUATIONS
                  IF(ASSOCIATED(linkingSolverEquations)) THEN
                    solverMatrices=>linkingSolverEquations%SOLVER_MATRICES
                  ELSE
                    CALL FlagError("Solver equations is not associated for the linking solver.",err,error,*999)
                  ENDIF
                ENDIF
              ENDIF
              IF(ASSOCIATED(solverMatrices)) THEN
                IF(solverMatrices%NUMBER_OF_MATRICES==1) THEN
                  solverMatrix=>solverMatrices%matrices(1)%ptr%MATRIX
                  IF(ASSOCIATED(solverMatrix)) THEN
                    IF(ASSOCIATED(solverMatrix%PETSC)) THEN
                      !Call MatGetFactor to create matrix petscFactoredMatrix from preconditioner context
                      CALL Petsc_PCFactorSetUpMatSolverPackage(linearDirectSolver%PC,err,error,*999)
                      CALL Petsc_PCFactorGetMatrix(linearDirectSolver%PC,petscFactoredMatrix,err,error,*999)
                      !Set CNTL(icntl)=val
                      CALL Petsc_MatMumpsSetCntl(petscFactoredMatrix,icntl,val,err,error,*999)
                    ELSE
                      CALL FlagError("Solver matrix PETSc is not associated.",err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Solver matrices distributed matrix is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  localError="The given number of solver matrices of "// &
                    & TRIM(NumberToVString(solverMatrices%NUMBER_OF_MATRICES,"*",err,error))// &
                    & " is invalid. There should only be one solver matrix for a linear direct solver."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Solver matrices not associated.",err,error,*999)
              ENDIF
            CASE DEFAULT
              localError="The solver library type of "// &
                & TRIM(NumberToVString(linearDirectSolver%SOLVER_LIBRARY,"*",err,error))//" is invalid. "// &
                & "Use MUMPS library when calling Solver_MumpsSetCntl"
              CALL FlagError(localError,err,error,*999)
            END SELECT
          CASE(SOLVER_DIRECT_CHOLESKY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_DIRECT_SVD)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The direct solver type of "// &
              & TRIM(NumberToVString(linearDirectSolver%DIRECT_SOLVER_TYPE,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("Linear solver solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Linear direct solver linear solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Linear direct solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_MumpsSetCntl")
    RETURN
999 ERRORSEXITS("Solver_MumpsSetCntl",err,error)    
    RETURN 1
    
  END SUBROUTINE Solver_MumpsSetCntl

  !
  !================================================================================================================================
  !

  !>Solve a linear direct solver 
  SUBROUTINE SOLVER_LINEAR_DIRECT_SOLVE(LINEAR_DIRECT_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: LINEAR_DIRECT_SOLVER !<A pointer to the linear direct solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: global_row,local_row,STORAGE_TYPE
    REAL(DP) :: SOLVER_VALUE,VALUE
    REAL(DP), POINTER :: RHS_DATA(:)
    TYPE(DistributedVectorType), POINTER :: rhsVector,SOLVER_VECTOR
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: ROW_DOFS_MAPPING
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_LINEAR_DIRECT_SOLVE",err,error,*999)

    IF(ASSOCIATED(LINEAR_DIRECT_SOLVER)) THEN
      LINEAR_SOLVER=>LINEAR_DIRECT_SOLVER%LINEAR_SOLVER
      IF(ASSOCIATED(LINEAR_SOLVER)) THEN
        SOLVER=>LINEAR_SOLVER%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
          IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
            SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
            IF(ASSOCIATED(SOLVER_MATRICES)) THEN
              IF(SOLVER_MATRICES%NUMBER_OF_MATRICES==1) THEN
                SOLVER_MATRIX=>SOLVER_MATRICES%matrices(1)%ptr
                IF(ASSOCIATED(SOLVER_MATRIX)) THEN
                  rhsVector=>SOLVER_MATRICES%RHS_VECTOR
                  IF(ASSOCIATED(rhsVector)) THEN
                    SOLVER_VECTOR=>SOLVER_MATRICES%matrices(1)%ptr%SOLVER_VECTOR
                    IF(ASSOCIATED(SOLVER_VECTOR)) THEN
                      CALL DistributedMatrix_StorageTypeGet(SOLVER_MATRIX%MATRIX,STORAGE_TYPE,err,error,*999)
                      IF(STORAGE_TYPE==DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE) THEN
                        SOLVER_MAPPING=>SOLVER_EQUATIONS%SOLVER_MAPPING
                        IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                          ROW_DOFS_MAPPING=>SOLVER_MAPPING%ROW_DOFS_MAPPING
                          IF(ASSOCIATED(ROW_DOFS_MAPPING)) THEN
                            CALL DistributedVector_DataGet(rhsVector,RHS_DATA,err,error,*999)
                            DO local_row=1,SOLVER_MAPPING%NUMBER_OF_ROWS
                              global_row=ROW_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(local_row)
                              CALL DistributedMatrix_ValuesGet(SOLVER_MATRIX%MATRIX,local_row,global_row,VALUE,err,error,*999)
                              IF(ABS(VALUE)>ZERO_TOLERANCE) THEN
                                SOLVER_VALUE=RHS_DATA(local_row)/VALUE
                                CALL DistributedVector_ValuesSet(SOLVER_VECTOR,local_row,SOLVER_VALUE,err,error,*999)
                              ELSE
                                localError="The linear solver matrix has a zero pivot on row "// &
                                  & TRIM(NumberToVString(local_row,"*",err,error))//"."
                                CALL FlagError(localError,err,error,*999)
                              ENDIF
                            ENDDO !matrix_idx
                            CALL DistributedVector_DataRestore(rhsVector,RHS_DATA,err,error,*999)
                          ELSE
                            CALL FlagError("Solver mapping row dofs mapping is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Solver equations solver mapping is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        SELECT CASE(LINEAR_DIRECT_SOLVER%DIRECT_SOLVER_TYPE)
                        CASE(SOLVER_DIRECT_LU)
                          SELECT CASE(LINEAR_DIRECT_SOLVER%SOLVER_LIBRARY)
                          CASE(SOLVER_CMISS_LIBRARY)
                            CALL FlagError("Not implemented.",err,error,*999)
                          CASE(SOLVER_MUMPS_LIBRARY)
                            !Call MUMPS through PETSc
                            IF(ASSOCIATED(rhsVector%PETSC)) THEN
                              IF(ASSOCIATED(SOLVER_VECTOR%PETSC)) THEN
                                IF(ASSOCIATED(SOLVER_MATRIX%MATRIX)) THEN
                                  IF(ASSOCIATED(SOLVER_MATRIX%MATRIX%PETSC)) THEN
                                    IF(SOLVER_MATRIX%UPDATE_MATRIX) THEN
                                      CALL Petsc_KSPSetOperators(LINEAR_DIRECT_SOLVER%KSP,SOLVER_MATRIX%MATRIX%PETSC%MATRIX, &
                                        & SOLVER_MATRIX%MATRIX%PETSC%MATRIX,err,error,*999)
                                    ELSE
                                      CALL Petsc_PCSetReusePreconditioner(LINEAR_DIRECT_SOLVER%PC,.TRUE.,err,error,*999)
                                    ENDIF
                                    !Solve the linear system
                                    CALL Petsc_KSPSolve(LINEAR_DIRECT_SOLVER%KSP,rhsVector%PETSC%VECTOR, &
                                      & SOLVER_VECTOR%PETSC%VECTOR,err,error,*999) 
                                  ELSE
                                    CALL FlagError("Solver matrix PETSc is not associated.",err,error,*999)
                                  ENDIF
                                ELSE
                                   CALL FlagError("Solver matrix distributed matrix is not associated.",err,error,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Solver vector PETSc vector is not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("RHS vector petsc PETSc is not associated.",err,error,*999)
                            ENDIF
                          CASE(SOLVER_SUPERLU_LIBRARY)
                            !Call SuperLU through PETSc
                            IF(ASSOCIATED(rhsVector%PETSC)) THEN
                              IF(ASSOCIATED(SOLVER_VECTOR%PETSC)) THEN
                                IF(ASSOCIATED(SOLVER_MATRIX%MATRIX)) THEN
                                  IF(ASSOCIATED(SOLVER_MATRIX%MATRIX%PETSC)) THEN
                                    IF(SOLVER_MATRIX%UPDATE_MATRIX) THEN
                                      CALL Petsc_KSPSetOperators(LINEAR_DIRECT_SOLVER%KSP,SOLVER_MATRIX%MATRIX%PETSC%MATRIX, &
                                        & SOLVER_MATRIX%MATRIX%PETSC%MATRIX,err,error,*999)
                                    ELSE
                                      CALL Petsc_PCSetReusePreconditioner(LINEAR_DIRECT_SOLVER%PC,PETSC_TRUE,err,error,*999)
                                    ENDIF
                                    !Solve the linear system
                                    CALL Petsc_KSPSolve(LINEAR_DIRECT_SOLVER%KSP,rhsVector%PETSC%VECTOR, &
                                      & SOLVER_VECTOR%PETSC%VECTOR,err,error,*999) 
                                  ELSE
                                    CALL FlagError("Solver matrix PETSc is not associated.",err,error,*999)
                                  ENDIF
                                ELSE
                                   CALL FlagError("Solver matrix distributed matrix is not associated.",err,error,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Solver vector PETSc vector is not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("RHS vector petsc PETSc is not associated.",err,error,*999)
                            ENDIF
                          CASE(SOLVER_SPOOLES_LIBRARY)
                            CALL FlagError("Not implemented.",err,error,*999)
                          CASE(SOLVER_UMFPACK_LIBRARY)
                            CALL FlagError("Not implemented.",err,error,*999)
                          CASE(SOLVER_LUSOL_LIBRARY)
                            CALL FlagError("Not implemented.",err,error,*999)
                          CASE(SOLVER_ESSL_LIBRARY)
                            CALL FlagError("Not implemented.",err,error,*999)
                          CASE(SOLVER_LAPACK_LIBRARY)
                            !Call LAPACK through PETSc
                            IF(ASSOCIATED(rhsVector%PETSC)) THEN
                              IF(ASSOCIATED(SOLVER_VECTOR%PETSC)) THEN
                                IF(ASSOCIATED(SOLVER_MATRIX%MATRIX)) THEN
                                  IF(ASSOCIATED(SOLVER_MATRIX%MATRIX%PETSC)) THEN
                                    IF(SOLVER_MATRIX%UPDATE_MATRIX) THEN
                                      CALL Petsc_KSPSetOperators(LINEAR_DIRECT_SOLVER%KSP,SOLVER_MATRIX%MATRIX%PETSC%MATRIX, &
                                        & SOLVER_MATRIX%MATRIX%PETSC%MATRIX,err,error,*999)
                                    ELSE
                                      CALL Petsc_PCSetReusePreconditioner(LINEAR_DIRECT_SOLVER%PC,.TRUE.,err,error,*999)
                                    ENDIF
                                    !Solve the linear system
                                    CALL Petsc_KSPSolve(LINEAR_DIRECT_SOLVER%KSP,rhsVector%PETSC%VECTOR, &
                                      & SOLVER_VECTOR%PETSC%VECTOR,err,error,*999) 
                                  ELSE
                                    CALL FlagError("Solver matrix PETSc is not associated.",err,error,*999)
                                  ENDIF
                                ELSE
                                  CALL FlagError("Solver matrix distributed matrix is not associated.",err,error,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Solver vector PETSc vector is not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("RHS vector petsc PETSc is not associated.",err,error,*999)
                            ENDIF
                          CASE(SOLVER_PASTIX_LIBRARY)
                            !Call PASTIX through PETSc
                            IF(ASSOCIATED(rhsVector%PETSC)) THEN
                              IF(ASSOCIATED(SOLVER_VECTOR%PETSC)) THEN
                                IF(ASSOCIATED(SOLVER_MATRIX%MATRIX)) THEN
                                  IF(ASSOCIATED(SOLVER_MATRIX%MATRIX%PETSC)) THEN
                                    IF(SOLVER_MATRIX%UPDATE_MATRIX) THEN
                                      CALL Petsc_KSPSetOperators(LINEAR_DIRECT_SOLVER%KSP,SOLVER_MATRIX%MATRIX%PETSC%MATRIX, &
                                        & SOLVER_MATRIX%MATRIX%PETSC%MATRIX,err,error,*999)
                                    ELSE
                                      CALL Petsc_PCSetReusePreconditioner(LINEAR_DIRECT_SOLVER%PC,.TRUE.,err,error,*999)
                                    ENDIF
                                    !Solve the linear system
                                    CALL Petsc_KSPSolve(LINEAR_DIRECT_SOLVER%KSP,rhsVector%PETSC%VECTOR, &
                                      & SOLVER_VECTOR%PETSC%VECTOR,err,error,*999) 
                                  ELSE
                                    CALL FlagError("Solver matrix PETSc is not associated.",err,error,*999)
                                  ENDIF
                                ELSE
                                   CALL FlagError("Solver matrix distributed matrix is not associated.",err,error,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Solver vector PETSc vector is not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("RHS vector petsc PETSc is not associated.",err,error,*999)
                            ENDIF
                          CASE DEFAULT
                            localError="The solver library type of "// &
                              & TRIM(NumberToVString(LINEAR_DIRECT_SOLVER%SOLVER_LIBRARY,"*",err,error))// &
                              & " is invalid for a LU direct linear solver."
                            CALL FlagError(localError,err,error,*999)
                          END SELECT
                        CASE(SOLVER_DIRECT_CHOLESKY)
                          CALL FlagError("Not implemented.",err,error,*999)
                        CASE(SOLVER_DIRECT_SVD)
                          CALL FlagError("Not implemented.",err,error,*999)
                        CASE DEFAULT
                          localError="The direct linear solver type of "// &
                            & TRIM(NumberToVString(LINEAR_DIRECT_SOLVER%DIRECT_SOLVER_TYPE,"*",err,error))// &
                            & " is invalid."
                          CALL FlagError(localError,err,error,*999)
                        END SELECT
                      ENDIF
                    ELSE
                      CALL FlagError("Solver vector is not associated.",err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("RHS vector is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Solver matrix is not associated.",err,error,*999)
                ENDIF
              ELSE
                localError="The number of solver matrices of "// &
                  & TRIM(NumberToVString(SOLVER_MATRICES%NUMBER_OF_MATRICES,"*",err,error))// &
                  & " is invalid. There should only be one solver matrix for a linear direct solver."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver equations solver matrices is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver solver equations is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Linear solver solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Linear direct solver linear solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Linear direct solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_LINEAR_DIRECT_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_DIRECT_SOLVE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_LINEAR_DIRECT_SOLVE
        
  !
  !================================================================================================================================
  !

  !>Finalise a SVD direct linear solver and deallocate all memory.
  SUBROUTINE SOLVER_LINEAR_DIRECT_SVD_FINALISE(LINEAR_DIRECT_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: LINEAR_DIRECT_SOLVER !<A pointer to the linear direct solver to finalise the SVD solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_LINEAR_DIRECT_SVD_FINALISE",err,error,*999)

    IF(ASSOCIATED(LINEAR_DIRECT_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ENDIF

    EXITS("SOLVER_LINEAR_DIRECT_SVD_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_DIRECT_SVD_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_DIRECT_SVD_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a SVD direct linear solver for a direct linear solver.
  SUBROUTINE SOLVER_LINEAR_DIRECT_SVD_INITIALISE(DIRECT_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DIRECT_SOLVER !<A pointer the direct linear solver to initialise the SVD direct linear solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    
    ENTERS("SOLVER_LINEAR_DIRECT_SVD_INITIALISE",err,error,*999)

    IF(ASSOCIATED(DIRECT_SOLVER)) THEN
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      CALL FlagError("Direct linear solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_LINEAR_DIRECT_SVD_INITIALISE")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_DIRECT_SVD_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_DIRECT_SVD_INITIALISE

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver. \see OpenCMISS::Iron::cmfe_SolverLinearDirectTypeSet
  SUBROUTINE SOLVER_LINEAR_DIRECT_TYPE_SET(SOLVER,DIRECT_SOLVER_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the direct linear solver type for.
    INTEGER(INTG), INTENT(IN) :: DIRECT_SOLVER_TYPE !<The type of direct linear solver to set \see SOLVER_ROUTINES_DirectLinearSolverTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_LINEAR_DIRECT_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_LINEAR_TYPE) THEN
          IF(ASSOCIATED(SOLVER%LINEAR_SOLVER)) THEN
            IF(SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE==SOLVER_LINEAR_DIRECT_SOLVE_TYPE) THEN
              IF(ASSOCIATED(SOLVER%LINEAR_SOLVER%DIRECT_SOLVER)) THEN
                IF(DIRECT_SOLVER_TYPE/=SOLVER%LINEAR_SOLVER%DIRECT_SOLVER%DIRECT_SOLVER_TYPE) THEN
                  !Finalise the old direct solver
                  SELECT CASE(SOLVER%LINEAR_SOLVER%DIRECT_SOLVER%SOLVER_LIBRARY)
                  CASE(SOLVER_DIRECT_LU)
                    CALL SOLVER_LINEAR_DIRECT_LU_FINALISE(SOLVER%LINEAR_SOLVER%DIRECT_SOLVER,err,error,*999)
                  CASE(SOLVER_DIRECT_CHOLESKY)
                    CALL SOLVER_LINEAR_DIRECT_CHOLESKY_FINALISE(SOLVER%LINEAR_SOLVER%DIRECT_SOLVER,err,error,*999)
                  CASE(SOLVER_DIRECT_SVD)
                    CALL SOLVER_LINEAR_DIRECT_SVD_FINALISE(SOLVER%LINEAR_SOLVER%DIRECT_SOLVER,err,error,*999)
                  CASE DEFAULT
                    localError="The direct solver type of "//TRIM(NumberToVString(DIRECT_SOLVER_TYPE,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                  !Initialise the new library
                  SELECT CASE(DIRECT_SOLVER_TYPE)
                  CASE(SOLVER_DIRECT_LU)
                    CALL SOLVER_LINEAR_DIRECT_LU_INITIALISE(SOLVER%LINEAR_SOLVER%DIRECT_SOLVER,err,error,*999)
                  CASE(SOLVER_DIRECT_CHOLESKY)
                    CALL SOLVER_LINEAR_DIRECT_CHOLESKY_INITIALISE(SOLVER%LINEAR_SOLVER%DIRECT_SOLVER,err,error,*999)
                  CASE(SOLVER_DIRECT_SVD)
                    CALL SOLVER_LINEAR_DIRECT_SVD_INITIALISE(SOLVER%LINEAR_SOLVER%DIRECT_SOLVER,err,error,*999)
                  CASE DEFAULT
                    localError="The direct solver type of "//TRIM(NumberToVString(DIRECT_SOLVER_TYPE,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                ENDIF
              ELSE
                CALL FlagError("The solver linear solver direct solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The solver is not a linear direct solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver linear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a linear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LINEAR_DIRECT_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_DIRECT_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_DIRECT_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Finalise a linear solver for a solver.
  SUBROUTINE SOLVER_LINEAR_FINALISE(LINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER !<A pointer the linear solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_LINEAR_FINALISE",err,error,*999)

    IF(ASSOCIATED(LINEAR_SOLVER)) THEN
      CALL SOLVER_LINEAR_DIRECT_FINALISE(LINEAR_SOLVER%DIRECT_SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_FINALISE(LINEAR_SOLVER%ITERATIVE_SOLVER,err,error,*999)
      DEALLOCATE(LINEAR_SOLVER)
    ENDIF
        
    EXITS("SOLVER_LINEAR_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a linear solver for a solver.
  SUBROUTINE SOLVER_LINEAR_INITIALISE(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to initialise the linear solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("SOLVER_LINEAR_INITIALISE",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(SOLVER%LINEAR_SOLVER)) THEN
        CALL FlagError("Linear solver is already associated for this solver.",err,error,*998)
      ELSE
        !Allocate and initialise a linear solver
        ALLOCATE(SOLVER%LINEAR_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate solver linear solver.",err,error,*999)
        SOLVER%LINEAR_SOLVER%SOLVER=>SOLVER
        SOLVER%LINEAR_SOLVER%LINKED_NEWTON_PETSC_SOLVER=.FALSE.
        NULLIFY(SOLVER%LINEAR_SOLVER%DIRECT_SOLVER)
        NULLIFY(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER)
        !Default to an iterative solver
        SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE=SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE
        CALL SOLVER_LINEAR_ITERATIVE_INITIALISE(SOLVER%LINEAR_SOLVER,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_LINEAR_INITIALISE")
    RETURN
999 CALL SOLVER_LINEAR_FINALISE(SOLVER%LINEAR_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_LINEAR_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_INITIALISE

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver. \see OpenCMISS::Iron::cmfe_SolverLinearIterativeAbsoluteToleranceSet
  SUBROUTINE Solver_LinearIterativeAbsoluteToleranceSet(SOLVER,ABSOLUTE_TOLERANCE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set 
    REAL(DP), INTENT(IN) :: ABSOLUTE_TOLERANCE !<The absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_LinearIterativeAbsoluteToleranceSet",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_LINEAR_TYPE) THEN
          IF(ASSOCIATED(SOLVER%LINEAR_SOLVER)) THEN
            IF(SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE==SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE) THEN
              IF(ASSOCIATED(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER)) THEN
                IF(ABSOLUTE_TOLERANCE>ZERO_TOLERANCE) THEN
                  SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ABSOLUTE_TOLERANCE=ABSOLUTE_TOLERANCE
                ELSE
                  localError="The specified absolute tolerance of "//TRIM(NumberToVString(ABSOLUTE_TOLERANCE,"*",err,error))// &
                    & " is invalid. The absolute tolerance must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The solver linear solver iterative solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The solver is not a linear iterative solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver linear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a linear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_LinearIterativeAbsoluteToleranceSet")
    RETURN
999 ERRORSEXITS("Solver_LinearIterativeAbsoluteToleranceSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_LinearIterativeAbsoluteToleranceSet
        
  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a linear iterative solver 
  SUBROUTINE SOLVER_LINEAR_ITERATIVE_CREATE_FINISH(LINEAR_ITERATIVE_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: LINEAR_ITERATIVE_SOLVER !<A pointer to the linear iterative solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(DistributedMatrixType), POINTER :: SOLVER_MATRIX
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NEWTON_LINESEARCH_SOLVER
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NEWTON_TRUSTREGION_SOLVER
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: QUASI_NEWTON_LINESEARCH_SOLVER
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: QUASI_NEWTON_TRUSTREGION_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(SOLVER_TYPE), POINTER :: LINKING_SOLVER,SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_LINEAR_ITERATIVE_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(LINEAR_ITERATIVE_SOLVER)) THEN
      LINEAR_SOLVER=>LINEAR_ITERATIVE_SOLVER%LINEAR_SOLVER
      IF(ASSOCIATED(LINEAR_SOLVER)) THEN
        SOLVER=>LINEAR_SOLVER%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          !Should really check iterative types here and then the solver library but as they are all PETSc for now hold off.
          SELECT CASE(LINEAR_ITERATIVE_SOLVER%SOLVER_LIBRARY)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            IF(ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
              SOLVER_EQUATIONS=>SOLVER%LINKING_SOLVER%SOLVER_EQUATIONS
              IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
                SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
                IF(.NOT.ASSOCIATED(SOLVER_MATRICES)) &
                  & CALL FlagError("Linked solver equation solver matrices is not associated.",err,error,*999)
              ELSE
                CALL FlagError("Linked solver solver equations is not associated.",err,error,*999)
              ENDIF
            ELSE
              SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
              IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
                !Create the solver matrices and vectors
                NULLIFY(SOLVER_MATRICES)
                CALL SOLVER_MATRICES_CREATE_START(SOLVER_EQUATIONS,SOLVER_MATRICES,err,error,*999)
                CALL SolverMatrices_LibraryTypeSet(SOLVER_MATRICES,SOLVER_PETSC_LIBRARY,err,error,*999)
                SELECT CASE(SOLVER_EQUATIONS%sparsityType)
                CASE(SOLVER_SPARSE_MATRICES)
                  CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE], &
                    & err,error,*999)
                CASE(SOLVER_FULL_MATRICES)
                  CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE], &
                    & err,error,*999)
                CASE DEFAULT
                  localError="The specified solver equations sparsity type of "// &
                    & TRIM(NumberToVString(SOLVER_EQUATIONS%sparsityType,"*",err,error))// &
                    & " is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
                SELECT CASE(SOLVER_EQUATIONS%symmetryType)
                CASE(SOLVER_SYMMETRIC_MATRICES)
                  CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_SYMMETRIC_TYPE],err,error,*999)
                CASE(SOLVER_UNSYMMETRIC_MATRICES)
                  CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_UNSYMMETRIC_TYPE],err,error,*999)
                CASE DEFAULT
                  localError="The specified solver equations symmetry type of "// &
                    & TRIM(NumberToVString(SOLVER_EQUATIONS%symmetryType,"*",err,error))// &
                    & " is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
                CALL SOLVER_MATRICES_CREATE_FINISH(SOLVER_MATRICES,err,error,*999)
              ELSE
                CALL FlagError("Solver solver equations is not associated.",err,error,*999)
              ENDIF
            ENDIF
            !Create the PETSc KSP solver
            IF(LINEAR_SOLVER%LINKED_NEWTON_PETSC_SOLVER) THEN
              LINKING_SOLVER=>SOLVER%LINKING_SOLVER
              IF(ASSOCIATED(LINKING_SOLVER)) THEN
                NONLINEAR_SOLVER=>LINKING_SOLVER%NONLINEAR_SOLVER
                IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
                  IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
                    NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
                    IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                      SELECT CASE(NEWTON_SOLVER%NEWTON_SOLVE_TYPE)
                      CASE(SOLVER_NEWTON_LINESEARCH)
                        NEWTON_LINESEARCH_SOLVER=>NEWTON_SOLVER%LINESEARCH_SOLVER
                        IF(ASSOCIATED(NEWTON_LINESEARCH_SOLVER)) THEN
                          CALL Petsc_SnesGetKSP(NEWTON_LINESEARCH_SOLVER%snes,LINEAR_ITERATIVE_SOLVER%KSP,err,error,*999)
                        ELSE
                          CALL FlagError("Newton solver linesearch solver is not associated.",err,error,*999)
                        ENDIF
                      CASE(SOLVER_NEWTON_TRUSTREGION)
                        NEWTON_TRUSTREGION_SOLVER=>NEWTON_SOLVER%TRUSTREGION_SOLVER
                        IF(ASSOCIATED(NEWTON_TRUSTREGION_SOLVER)) THEN
                          CALL Petsc_SnesGetKSP(NEWTON_TRUSTREGION_SOLVER%snes,LINEAR_ITERATIVE_SOLVER%KSP,err,error,*999)
                        ELSE
                          CALL FlagError("Newton solver linesearch solver is not associated.",err,error,*999)
                        ENDIF
                      CASE DEFAULT
                        localError="The Newton solve type of "// &
                          & TRIM(NumberToVString(NEWTON_SOLVER%NEWTON_SOLVE_TYPE,"*",err,error))//"is invalid."
                        CALL FlagError(localError,err,error,*999)
                      END SELECT
                    ELSE
                      CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
                    ENDIF
                  ELSEIF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
                    QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
                    IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                      SELECT CASE(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE)
                      CASE(SOLVER_QUASI_NEWTON_LINESEARCH)
                        QUASI_NEWTON_LINESEARCH_SOLVER=>QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER
                        IF(ASSOCIATED(QUASI_NEWTON_LINESEARCH_SOLVER)) THEN
                          CALL Petsc_SnesGetKSP(QUASI_NEWTON_LINESEARCH_SOLVER%snes,LINEAR_ITERATIVE_SOLVER%KSP,err,error,*999)
                        ELSE
                          CALL FlagError("Quasi-Newton solver linesearch solver is not associated.",err,error,*999)
                        ENDIF
                      CASE(SOLVER_QUASI_NEWTON_TRUSTREGION)
                        QUASI_NEWTON_TRUSTREGION_SOLVER=>QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER
                        IF(ASSOCIATED(QUASI_NEWTON_TRUSTREGION_SOLVER)) THEN
                          CALL Petsc_SnesGetKSP(QUASI_NEWTON_TRUSTREGION_SOLVER%snes,LINEAR_ITERATIVE_SOLVER%KSP,err,error,*999)
                        ELSE
                          CALL FlagError("Quasi-Newton solver linesearch solver is not associated.",err,error,*999)
                        ENDIF
                      CASE DEFAULT
                        localError="The Quasi-Newton solve type of "// &
                          & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE,"*",err,error))//"is invalid."
                        CALL FlagError(localError,err,error,*999)
                      END SELECT
                    ELSE
                      CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
                    ENDIF
                  ENDIF
                ELSE
                  CALL FlagError("Linking solver nonlinear solver is not associated.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Solver linking solve is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL Petsc_KSPCreate(computationalEnvironment%mpiCommunicator,LINEAR_ITERATIVE_SOLVER%KSP,err,error,*999)
            ENDIF
            !Set the iterative solver type
            SELECT CASE(LINEAR_ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE)
            CASE(SOLVER_ITERATIVE_RICHARDSON)
              CALL Petsc_KSPSetType(LINEAR_ITERATIVE_SOLVER%KSP,PETSC_KSPRICHARDSON,err,error,*999)
            CASE(SOLVER_ITERATIVE_CHEBYSHEV)
              CALL Petsc_KSPSetType(LINEAR_ITERATIVE_SOLVER%KSP,PETSC_KSPCHEBYSHEV,err,error,*999)
            CASE(SOLVER_ITERATIVE_CONJUGATE_GRADIENT)
              CALL Petsc_KSPSetType(LINEAR_ITERATIVE_SOLVER%KSP,PETSC_KSPCG,err,error,*999)
            CASE(SOLVER_ITERATIVE_BICONJUGATE_GRADIENT)
              CALL Petsc_KSPSetType(LINEAR_ITERATIVE_SOLVER%KSP,PETSC_KSPBICG,err,error,*999)
            CASE(SOLVER_ITERATIVE_GMRES)
              CALL Petsc_KSPSetType(LINEAR_ITERATIVE_SOLVER%KSP,PETSC_KSPGMRES,err,error,*999)
              CALL Petsc_KSPGMRESSetRestart(LINEAR_ITERATIVE_SOLVER%KSP,LINEAR_ITERATIVE_SOLVER%GMRES_RESTART,err,error,*999)
            CASE(SOLVER_ITERATIVE_BiCGSTAB)
              CALL Petsc_KSPSetType(LINEAR_ITERATIVE_SOLVER%KSP,PETSC_KSPBCGS,err,error,*999)
            CASE(SOLVER_ITERATIVE_CONJGRAD_SQUARED)
              CALL Petsc_KSPSetType(LINEAR_ITERATIVE_SOLVER%KSP,PETSC_KSPCGS,err,error,*999)
            CASE DEFAULT
              localError="The iterative solver type of "// &
                & TRIM(NumberToVString(LINEAR_ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            !Get the pre-conditioner
            CALL Petsc_KSPGetPC(LINEAR_ITERATIVE_SOLVER%KSP,LINEAR_ITERATIVE_SOLVER%PC,err,error,*999)
            !Set the pre-conditioner type
            SELECT CASE(LINEAR_ITERATIVE_SOLVER%ITERATIVE_PRECONDITIONER_TYPE)
            CASE(SOLVER_ITERATIVE_NO_PRECONDITIONER)
              CALL Petsc_PCSetType(LINEAR_ITERATIVE_SOLVER%PC,PETSC_PCNONE,err,error,*999)
            CASE(SOLVER_ITERATIVE_JACOBI_PRECONDITIONER)
              CALL Petsc_PCSetType(LINEAR_ITERATIVE_SOLVER%PC,PETSC_PCJACOBI,err,error,*999)
            CASE(SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER)
              CALL Petsc_PCSetType(LINEAR_ITERATIVE_SOLVER%PC,PETSC_PCBJACOBI,err,error,*999)
            CASE(SOLVER_ITERATIVE_SOR_PRECONDITIONER)
              CALL Petsc_PCSetType(LINEAR_ITERATIVE_SOLVER%PC,PETSC_PCSOR,err,error,*999)
            CASE(SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER)
              CALL Petsc_PCSetType(LINEAR_ITERATIVE_SOLVER%PC,PETSC_PCICC,err,error,*999)
            CASE(SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER)
              CALL Petsc_PCSetType(LINEAR_ITERATIVE_SOLVER%PC,PETSC_PCILU,err,error,*999)
            CASE(SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER)
              CALL Petsc_PCSetType(LINEAR_ITERATIVE_SOLVER%PC,PETSC_PCASM,err,error,*999)
            CASE DEFAULT
              localError="The iterative preconditioner type of "// &
                & TRIM(NumberToVString(LINEAR_ITERATIVE_SOLVER%ITERATIVE_PRECONDITIONER_TYPE,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            !Set the tolerances for the KSP solver
            CALL Petsc_KSPSetTolerances(LINEAR_ITERATIVE_SOLVER%KSP,LINEAR_ITERATIVE_SOLVER%RELATIVE_TOLERANCE, &
              & LINEAR_ITERATIVE_SOLVER%ABSOLUTE_TOLERANCE,LINEAR_ITERATIVE_SOLVER%DIVERGENCE_TOLERANCE, &
              & LINEAR_ITERATIVE_SOLVER%MAXIMUM_NUMBER_OF_ITERATIONS,err,error,*999)
            !Set any further KSP options from the command line options
            CALL Petsc_KSPSetFromOptions(LINEAR_ITERATIVE_SOLVER%KSP,err,error,*999)
            !Set the solver matrix to be the KSP matrix
            IF(SOLVER_MATRICES%NUMBER_OF_MATRICES==1) THEN
              SOLVER_MATRIX=>SOLVER_MATRICES%matrices(1)%ptr%MATRIX
              IF(ASSOCIATED(SOLVER_MATRIX)) THEN
                IF(ASSOCIATED(SOLVER_MATRIX%PETSC)) THEN
                  CALL Petsc_KSPSetOperators(LINEAR_ITERATIVE_SOLVER%KSP,SOLVER_MATRIX%PETSC%MATRIX,SOLVER_MATRIX%PETSC%MATRIX, &
                    & err,error,*999)
                ELSE
                  CALL FlagError("Solver matrix PETSc is not associated.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Solver matrices distributed matrix is not associated.",err,error,*999)
              ENDIF
            ELSE
              localError="The given number of solver matrices of "// &
                & TRIM(NumberToVString(SOLVER_MATRICES%NUMBER_OF_MATRICES,"*",err,error))// &
                & " is invalid. There should only be one solver matrix for a linear iterative solver."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          CASE DEFAULT
            localError="The solver library type of "// &
              & TRIM(NumberToVString(LINEAR_ITERATIVE_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("Linear solver solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Linear iterative solver linear solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Linear iterative solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_LINEAR_ITERATIVE_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_ITERATIVE_CREATE_FINISH",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_LINEAR_ITERATIVE_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver. \see OpenCMISS::Iron::cmfe_SolverLinearIterativeDivergenceToleranceSet
  SUBROUTINE Solver_LinearIterativeDivergenceToleranceSet(SOLVER,DIVERGENCE_TOLERANCE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set 
    REAL(DP), INTENT(IN) :: DIVERGENCE_TOLERANCE !<The divergence tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_LinearIterativeDivergenceToleranceSet",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_LINEAR_TYPE) THEN
          IF(ASSOCIATED(SOLVER%LINEAR_SOLVER)) THEN
            IF(SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE==SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE) THEN
              IF(ASSOCIATED(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER)) THEN
                IF(DIVERGENCE_TOLERANCE>ZERO_TOLERANCE) THEN
                  SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%DIVERGENCE_TOLERANCE=DIVERGENCE_TOLERANCE
                ELSE
                  localError="The specified divergence tolerance of "// &
                    & TRIM(NumberToVString(DIVERGENCE_TOLERANCE,"*",err,error))// &
                    & " is invalid. The divergence tolerance must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The solver linear solver iterative solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The solver is not a linear iterative solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver linear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a linear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_LinearIterativeDivergenceToleranceSet")
    RETURN
999 ERRORS("Solver_LinearIterativeDivergenceToleranceSet",err,error)
    EXITS("Solver_LinearIterativeDivergenceToleranceSet")
    RETURN 1
   
  END SUBROUTINE Solver_LinearIterativeDivergenceToleranceSet
        
  !
  !================================================================================================================================
  !

  !>Finalise an iterative linear solver for a linear solver and deallocate all memory.
  SUBROUTINE SOLVER_LINEAR_ITERATIVE_FINALISE(LINEAR_ITERATIVE_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: LINEAR_ITERATIVE_SOLVER !<A pointer the linear iterative solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER

    ENTERS("SOLVER_LINEAR_ITERATIVE_FINALISE",err,error,*999)

    IF(ASSOCIATED(LINEAR_ITERATIVE_SOLVER)) THEN
      LINEAR_SOLVER=>LINEAR_ITERATIVE_SOLVER%LINEAR_SOLVER
      IF(ASSOCIATED(LINEAR_SOLVER)) THEN
        IF(.NOT.LINEAR_SOLVER%LINKED_NEWTON_PETSC_SOLVER) THEN
          CALL Petsc_PCFinalise(LINEAR_ITERATIVE_SOLVER%PC,err,error,*999)
          CALL Petsc_KSPFinalise(LINEAR_ITERATIVE_SOLVER%KSP,err,error,*999)
        ENDIF
      ENDIF
      DEALLOCATE(LINEAR_ITERATIVE_SOLVER)
    ENDIF
        
    EXITS("SOLVER_LINEAR_ITERATIVE_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_ITERATIVE_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_ITERATIVE_FINALISE

  !
  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver. \see OpenCMISS::Iron::cmfe_SolverLinearIterativeGMRESRestartSet
  SUBROUTINE SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(SOLVER,GMRES_RESTART,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the GMRES restart value
    INTEGER(INTG), INTENT(IN) :: GMRES_RESTART !<The GMRES restart value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: ITERATIVE_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_LINEAR_TYPE) THEN
          LINEAR_SOLVER=>SOLVER%LINEAR_SOLVER
          IF(ASSOCIATED(LINEAR_SOLVER)) THEN
            IF(LINEAR_SOLVER%LINEAR_SOLVE_TYPE==SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE) THEN
              ITERATIVE_SOLVER=>LINEAR_SOLVER%ITERATIVE_SOLVER
              IF(ASSOCIATED(ITERATIVE_SOLVER)) THEN
                IF(ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE==SOLVER_ITERATIVE_GMRES) THEN
                  IF(GMRES_RESTART>0) THEN
                    ITERATIVE_SOLVER%GMRES_RESTART=GMRES_RESTART
                  ELSE
                    localError="The specified GMRES restart value of "//TRIM(NumberToVString(GMRES_RESTART,"*",err,error))// &
                      & " is invalid. The GMRES restart value must be > 0."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The linear iterative solver is not a GMRES linear iterative solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The solver linear solver iterative solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The solver is not a linear iterative solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver linear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a linear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET
        
  !
  !================================================================================================================================
  !

  !>Initialise an iterative linear solver for a linear solver
  SUBROUTINE SOLVER_LINEAR_ITERATIVE_INITIALISE(LINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER !<A pointer the linear solver to initialise the iterative solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("SOLVER_LINEAR_ITERATIVE_INITIALISE",err,error,*998)

    IF(ASSOCIATED(LINEAR_SOLVER)) THEN
      IF(ASSOCIATED(LINEAR_SOLVER%ITERATIVE_SOLVER)) THEN
        CALL FlagError("Iterative solver is already associated for this linear solver.",err,error,*998)
      ELSE
        !Allocate and initialise an iterative solver
        ALLOCATE(LINEAR_SOLVER%ITERATIVE_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate linear solver iterative solver.",err,error,*999)
        LINEAR_SOLVER%ITERATIVE_SOLVER%LINEAR_SOLVER=>LINEAR_SOLVER
        LINEAR_SOLVER%ITERATIVE_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
        LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE=SOLVER_ITERATIVE_GMRES
        LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_PRECONDITIONER_TYPE=SOLVER_ITERATIVE_JACOBI_PRECONDITIONER
        LINEAR_SOLVER%ITERATIVE_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD
        LINEAR_SOLVER%ITERATIVE_SOLVER%MAXIMUM_NUMBER_OF_ITERATIONS=100000
        LINEAR_SOLVER%ITERATIVE_SOLVER%RELATIVE_TOLERANCE=1.0E-05_DP
        LINEAR_SOLVER%ITERATIVE_SOLVER%ABSOLUTE_TOLERANCE=1.0E-10_DP
        LINEAR_SOLVER%ITERATIVE_SOLVER%DIVERGENCE_TOLERANCE=1.0E5_DP
        LINEAR_SOLVER%ITERATIVE_SOLVER%GMRES_RESTART=30
        CALL Petsc_PCInitialise(LINEAR_SOLVER%ITERATIVE_SOLVER%PC,err,error,*999)
        CALL Petsc_KSPInitialise(LINEAR_SOLVER%ITERATIVE_SOLVER%KSP,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Linear solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_LINEAR_ITERATIVE_INITIALISE")
    RETURN
999 CALL SOLVER_LINEAR_ITERATIVE_FINALISE(LINEAR_SOLVER%ITERATIVE_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_LINEAR_ITERATIVE_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_ITERATIVE_INITIALISE

  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for an iterative linear solver.
  SUBROUTINE SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_GET(ITERATIVE_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: ITERATIVE_SOLVER !<A pointer the iterative linear solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On exit, the type of library used for the iterative linear solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
 
    ENTERS("SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(ITERATIVE_SOLVER)) THEN
      SELECT CASE(ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE)
      CASE(SOLVER_ITERATIVE_RICHARDSON)
        SOLVER_LIBRARY_TYPE=ITERATIVE_SOLVER%SOLVER_LIBRARY
      CASE(SOLVER_ITERATIVE_CHEBYSHEV)
        SOLVER_LIBRARY_TYPE=ITERATIVE_SOLVER%SOLVER_LIBRARY
      CASE(SOLVER_ITERATIVE_CONJUGATE_GRADIENT)
        SOLVER_LIBRARY_TYPE=ITERATIVE_SOLVER%SOLVER_LIBRARY
      CASE(SOLVER_ITERATIVE_GMRES)
        SOLVER_LIBRARY_TYPE=ITERATIVE_SOLVER%SOLVER_LIBRARY
      CASE(SOLVER_ITERATIVE_BiCGSTAB)
        SOLVER_LIBRARY_TYPE=ITERATIVE_SOLVER%SOLVER_LIBRARY
      CASE(SOLVER_ITERATIVE_CONJGRAD_SQUARED)
        SOLVER_LIBRARY_TYPE=ITERATIVE_SOLVER%SOLVER_LIBRARY
      CASE DEFAULT
        localError="The iterative linear solver type of "// &
          & TRIM(NumberToVString(ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Iterative linear solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for an iterative linear solver.
  SUBROUTINE SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_SET(ITERATIVE_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: ITERATIVE_SOLVER !<A pointer the iterative linear solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library for the iterative linear solver to set. \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_SET",err,error,*999)
    
    IF(ASSOCIATED(ITERATIVE_SOLVER)) THEN
      SELECT CASE(ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE)
      CASE(SOLVER_ITERATIVE_RICHARDSON)
        SELECT CASE(SOLVER_LIBRARY_TYPE)
        CASE(SOLVER_CMISS_LIBRARY)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(SOLVER_PETSC_LIBRARY)
          ITERATIVE_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
        CASE DEFAULT
          localError="The specified solver library type of "// &
            & TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
            & " is invalid for a Richardson iterative linear solver."
        END SELECT
      CASE(SOLVER_ITERATIVE_CHEBYSHEV)
        SELECT CASE(SOLVER_LIBRARY_TYPE)
        CASE(SOLVER_CMISS_LIBRARY)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(SOLVER_PETSC_LIBRARY)
          ITERATIVE_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
       CASE DEFAULT
          localError="The specified solver library type of "// &
            & TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
            & " is invalid for a Chebychev iterative linear solver."
        END SELECT
      CASE(SOLVER_ITERATIVE_CONJUGATE_GRADIENT)
        SELECT CASE(SOLVER_LIBRARY_TYPE)
        CASE(SOLVER_CMISS_LIBRARY)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(SOLVER_PETSC_LIBRARY)
          ITERATIVE_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
        CASE DEFAULT
          localError="The specified solver library type of "// &
            & TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
            & " is invalid for a Conjugate gradient iterative linear solver."
        END SELECT
      CASE(SOLVER_ITERATIVE_GMRES)
        SELECT CASE(SOLVER_LIBRARY_TYPE)
        CASE(SOLVER_CMISS_LIBRARY)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(SOLVER_PETSC_LIBRARY)
          ITERATIVE_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
       CASE DEFAULT
          localError="The specified solver library type of "// &
            & TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
            & " is invalid for a GMRES iterative linear solver."
        END SELECT
      CASE(SOLVER_ITERATIVE_BiCGSTAB)
        SELECT CASE(SOLVER_LIBRARY_TYPE)
        CASE(SOLVER_CMISS_LIBRARY)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(SOLVER_PETSC_LIBRARY)
          ITERATIVE_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
       CASE DEFAULT
          localError="The specified solver library type of "// &
            & TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
            & " is invalid for a BiCGSTAB iterative linear solver."
        END SELECT
      CASE(SOLVER_ITERATIVE_CONJGRAD_SQUARED)
        SELECT CASE(SOLVER_LIBRARY_TYPE)
        CASE(SOLVER_CMISS_LIBRARY)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(SOLVER_PETSC_LIBRARY)
          ITERATIVE_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
       CASE DEFAULT
          localError="The specified solver library type of "// &
            & TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
            & " is invalid for a Conjugate gradient squared iterative linear solver."
        END SELECT
      CASE DEFAULT
        localError="The iterative linear solver type of "// &
          & TRIM(NumberToVString(ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Iterative linear solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver. \see OpenCMISS::Iron::cmfe_SolverLinearIterativeMaximumIterationsSet
  SUBROUTINE Solver_LinearIterativeMaximumIterationsSet(SOLVER,MAXIMUM_ITERATIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the maximum number of iterations
    INTEGER(INTG), INTENT(IN) :: MAXIMUM_ITERATIONS !<The maximum number of iterations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_LinearIterativeMaximumIterationsSet",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_LINEAR_TYPE) THEN
          IF(ASSOCIATED(SOLVER%LINEAR_SOLVER)) THEN
            IF(SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE==SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE) THEN
              IF(ASSOCIATED(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER)) THEN
                IF(MAXIMUM_ITERATIONS>0) THEN
                  SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%MAXIMUM_NUMBER_OF_ITERATIONS=MAXIMUM_ITERATIONS
                ELSE
                  localError="The specified maximum iterations of "//TRIM(NumberToVString(MAXIMUM_ITERATIONS,"*",err,error))// &
                    & " is invalid. The maximum number of iterations must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The solver linear solver iterative solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The solver is not a linear iterative solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver linear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a linear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_LinearIterativeMaximumIterationsSet")
    RETURN
999 ERRORSEXITS("Solver_LinearIterativeMaximumIterationsSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_LinearIterativeMaximumIterationsSet
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the type of preconditioner for an iterative linear solver. \see OpenCMISS::Iron::cmfe_SolverLinearIterativePreconditionerTypeSet
  SUBROUTINE Solver_LinearIterativePreconditionerTypeSet(SOLVER,ITERATIVE_PRECONDITIONER_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the iterative linear solver type
    INTEGER(INTG), INTENT(IN) :: ITERATIVE_PRECONDITIONER_TYPE !<The type of iterative preconditioner to set \see SOLVER_ROUTINES_IterativeLinearSolverTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_LinearIterativePreconditionerTypeSet",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_LINEAR_TYPE) THEN
          IF(ASSOCIATED(SOLVER%LINEAR_SOLVER)) THEN
            IF(SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE==SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE) THEN
              IF(ASSOCIATED(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER)) THEN
                IF(ITERATIVE_PRECONDITIONER_TYPE/=SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_PRECONDITIONER_TYPE) THEN
                  !Intialise the new preconditioner type
                  SELECT CASE(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%SOLVER_LIBRARY)
                  CASE(SOLVER_PETSC_LIBRARY)
                    SELECT CASE(ITERATIVE_PRECONDITIONER_TYPE)
                    CASE(SOLVER_ITERATIVE_NO_PRECONDITIONER)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_PRECONDITIONER_TYPE=SOLVER_ITERATIVE_NO_PRECONDITIONER
                    CASE(SOLVER_ITERATIVE_JACOBI_PRECONDITIONER)
                      CALL FlagError("Iterative Jacobi preconditioning is not implemented for a PETSc library.",err,error,*999)
                    CASE(SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_PRECONDITIONER_TYPE= &
                        & SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER
                    CASE(SOLVER_ITERATIVE_SOR_PRECONDITIONER)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_PRECONDITIONER_TYPE= &
                        & SOLVER_ITERATIVE_SOR_PRECONDITIONER
                    CASE(SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_PRECONDITIONER_TYPE= &
                        & SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER 
                    CASE(SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_PRECONDITIONER_TYPE= &
                        & SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER
                    CASE(SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_PRECONDITIONER_TYPE= &
                        & SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER
                   CASE DEFAULT
                      localError="The iterative preconditioner type of "// &
                        & TRIM(NumberToVString(ITERATIVE_PRECONDITIONER_TYPE,"*",err,error))//" is invalid."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  CASE DEFAULT
                    localError="The solver library type of "// &
                      & TRIM(NumberToVString(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%SOLVER_LIBRARY,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT                  
                ENDIF
              ELSE
                CALL FlagError("The solver linear solver iterative solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The solver is not a linear iterative solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver linear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a linear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_LinearIterativePreconditionerTypeSet")
    RETURN
999 ERRORSEXITS("Solver_LinearIterativePreconditionerTypeSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_LinearIterativePreconditionerTypeSet
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for an iterative linear solver. \see OpenCMISS::Iron::cmfe_SolverLinearIterativeRelativeToleranceSet
  SUBROUTINE Solver_LinearIterativeRelativeToleranceSet(SOLVER,RELATIVE_TOLERANCE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set 
    REAL(DP), INTENT(IN) :: RELATIVE_TOLERANCE !<The relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_LinearIterativeRelativeToleranceSet",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_LINEAR_TYPE) THEN
          IF(ASSOCIATED(SOLVER%LINEAR_SOLVER)) THEN
            IF(SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE==SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE) THEN
              IF(ASSOCIATED(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER)) THEN
                IF(RELATIVE_TOLERANCE>ZERO_TOLERANCE) THEN
                  SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%RELATIVE_TOLERANCE=RELATIVE_TOLERANCE
                ELSE
                  localError="The specified relative tolerance of "//TRIM(NumberToVString(RELATIVE_TOLERANCE,"*",err,error))// &
                    & " is invalid. The relative tolerance must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The solver linear solver iterative solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The solver is not a linear iterative solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver linear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a linear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_LinearIterativeRelativeToleranceSet")
    RETURN
999 ERRORSEXITS("Solver_LinearIterativeRelativeToleranceSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_LinearIterativeRelativeToleranceSet
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the solution initialise type for an iterative linear solver
  SUBROUTINE Solver_LinearIterativeSolutionInitTypeSet(SOLVER,SOLUTION_INITIALISE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set 
    INTEGER(INTG), INTENT(IN) :: SOLUTION_INITIALISE_TYPE !<The solution initialise type to set \see SOLVER_ROUTINES_SolutionInitialiseTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_LinearIterativeSolutionInitTypeSet",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_LINEAR_TYPE) THEN
          IF(ASSOCIATED(SOLVER%LINEAR_SOLVER)) THEN
            IF(SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE==SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE) THEN
              IF(ASSOCIATED(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER)) THEN
                SELECT CASE(SOLUTION_INITIALISE_TYPE)
                CASE(SOLVER_SOLUTION_INITIALISE_ZERO)
                  SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_ZERO
                CASE(SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD)
                  SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD
                CASE(SOLVER_SOLUTION_INITIALISE_NO_CHANGE)
                  SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_NO_CHANGE
                CASE DEFAULT
                  localError="The specified solution initialise type of "// &
                    & TRIM(NumberToVString(SOLUTION_INITIALISE_TYPE,"*",err,error))//" is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ELSE
                CALL FlagError("The solver linear solver iterative solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The solver is not a linear iterative solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver linear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a linear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_LinearIterativeSolutionInitTypeSet")
    RETURN
999 ERRORSEXITS("Solver_LinearIterativeSolutionInitTypeSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_LinearIterativeSolutionInitTypeSet
        
  !
  !================================================================================================================================
  !

  !>Solves a linear iterative linear solver
  SUBROUTINE SOLVER_LINEAR_ITERATIVE_SOLVE(LINEAR_ITERATIVE_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: LINEAR_ITERATIVE_SOLVER !<A pointer the linear iterative solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: CONVERGED_REASON,global_row,local_row,NUMBER_ITERATIONS,STORAGE_TYPE
    REAL(DP) :: RESIDUAL_NORM,SOLVER_VALUE,VALUE
    REAL(DP), POINTER :: RHS_DATA(:)
    TYPE(DistributedVectorType), POINTER :: rhsVector,SOLVER_VECTOR
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: ROW_DOFS_MAPPING
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_LINEAR_ITERATIVE_SOLVE",err,error,*999)

    IF(ASSOCIATED(LINEAR_ITERATIVE_SOLVER)) THEN
      LINEAR_SOLVER=>LINEAR_ITERATIVE_SOLVER%LINEAR_SOLVER
      IF(ASSOCIATED(LINEAR_SOLVER)) THEN
        SOLVER=>LINEAR_SOLVER%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
          IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
            SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
            IF(ASSOCIATED(SOLVER_MATRICES)) THEN
              IF(SOLVER_MATRICES%NUMBER_OF_MATRICES==1) THEN
                SOLVER_MATRIX=>SOLVER_MATRICES%matrices(1)%ptr
                IF(ASSOCIATED(SOLVER_MATRIX)) THEN
                  rhsVector=>SOLVER_MATRICES%RHS_VECTOR
                  IF(ASSOCIATED(rhsVector)) THEN
                    SOLVER_VECTOR=>SOLVER_MATRICES%matrices(1)%ptr%SOLVER_VECTOR
                    IF(ASSOCIATED(SOLVER_VECTOR)) THEN
                      CALL DistributedMatrix_StorageTypeGet(SOLVER_MATRIX%MATRIX,STORAGE_TYPE,err,error,*999)
                      IF(STORAGE_TYPE==DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE) THEN
                        SOLVER_MAPPING=>SOLVER_EQUATIONS%SOLVER_MAPPING
                        IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                          ROW_DOFS_MAPPING=>SOLVER_MAPPING%ROW_DOFS_MAPPING
                          IF(ASSOCIATED(ROW_DOFS_MAPPING)) THEN
                            CALL DistributedVector_DataGet(rhsVector,RHS_DATA,err,error,*999)
                            DO local_row=1,SOLVER_MAPPING%NUMBER_OF_ROWS
                              global_row=ROW_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(local_row)
                              CALL DistributedMatrix_ValuesGet(SOLVER_MATRIX%MATRIX,local_row,global_row,VALUE,err,error,*999)
                              IF(ABS(VALUE)>ZERO_TOLERANCE) THEN
                                SOLVER_VALUE=RHS_DATA(local_row)/VALUE
                                CALL DistributedVector_ValuesSet(SOLVER_VECTOR,local_row,SOLVER_VALUE,err,error,*999)
                              ELSE
                                localError="The linear solver matrix has a zero pivot on row "// &
                                  & TRIM(NumberToVString(local_row,"*",err,error))//"."
                                CALL FlagError(localError,err,error,*999)
                              ENDIF
                            ENDDO !matrix_idx
                            CALL DistributedVector_DataRestore(rhsVector,RHS_DATA,err,error,*999)
                          ELSE
                            CALL FlagError("Solver mapping row dofs mapping is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Solver equations solver mapping is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        SELECT CASE(LINEAR_ITERATIVE_SOLVER%SOLVER_LIBRARY)
                        CASE(SOLVER_CMISS_LIBRARY)
                          CALL FlagError("Not implemented.",err,error,*999)
                        CASE(SOLVER_PETSC_LIBRARY)
                          IF(ASSOCIATED(rhsVector%PETSC)) THEN
                            IF(ASSOCIATED(SOLVER_VECTOR%PETSC)) THEN
                              SELECT CASE(LINEAR_ITERATIVE_SOLVER%SOLUTION_INITIALISE_TYPE)
                              CASE(SOLVER_SOLUTION_INITIALISE_ZERO)
                                !Zero the solution vector
                                CALL DistributedVector_AllValuesSet(SOLVER_VECTOR,0.0_DP,err,error,*999)
                                !Tell PETSc that the solution vector is zero
                                CALL Petsc_KSPSetInitialGuessNonZero(LINEAR_ITERATIVE_SOLVER%KSP,.FALSE.,err,error,*999)
                              CASE(SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD)
                                !Make sure the solver vector contains the current dependent field values
                                CALL SOLVER_SOLUTION_UPDATE(SOLVER,err,error,*999)
                                !Tell PETSc that the solution vector is nonzero
                                CALL Petsc_KSPSetInitialGuessNonZero(LINEAR_ITERATIVE_SOLVER%KSP,.TRUE.,err,error,*999)
                              CASE(SOLVER_SOLUTION_INITIALISE_NO_CHANGE)
                                !Do nothing
                              CASE DEFAULT
                                localError="The linear iterative solver solution initialise type of "// &
                                  & TRIM(NumberToVString(LINEAR_ITERATIVE_SOLVER%SOLUTION_INITIALISE_TYPE,"*",err,error))// &
                                  & " is invalid."
                                CALL FlagError(localError,err,error,*999)
                              END SELECT
                              !Solver the linear system
#ifdef TAUPROF
                              CALL TAU_STATIC_PHASE_START("KSPSOLVE")
#endif
                              CALL Petsc_KSPSolve(LINEAR_ITERATIVE_SOLVER%KSP,rhsVector%PETSC%VECTOR,SOLVER_VECTOR%PETSC%VECTOR, &
                                & err,error,*999)
#ifdef TAUPROF
                              CALL TAU_STATIC_PHASE_STOP("KSPSOLVE")
#endif
                              !Check for convergence
                              CALL Petsc_KSPGetConvergedReason(LINEAR_ITERATIVE_SOLVER%KSP,CONVERGED_REASON,err,error,*999)
                              SELECT CASE(CONVERGED_REASON)
                              CASE(PETSC_KSP_DIVERGED_NULL)
                                CALL FLAG_WARNING("Linear iterative solver did not converge. PETSc diverged null.",err,error,*999)
                              CASE(PETSC_KSP_DIVERGED_ITS)
                                CALL FLAG_WARNING("Linear iterative solver did not converge. PETSc diverged its.",err,error,*999)
                              CASE(PETSC_KSP_DIVERGED_DTOL)
                                CALL FLAG_WARNING("Linear iterative solver did not converge. PETSc diverged dtol.",err,error,*999)
                              CASE(PETSC_KSP_DIVERGED_BREAKDOWN)
                                CALL FLAG_WARNING("Linear iterative solver did not converge. PETSc diverged breakdown.", &
                                  & err,error,*999)
                              CASE(PETSC_KSP_DIVERGED_BREAKDOWN_BICG)
                                CALL FLAG_WARNING("Linear iterative solver did not converge. PETSc diverged breakdown BiCG.", &
                                  & err,error,*999)
                              CASE(PETSC_KSP_DIVERGED_NONSYMMETRIC)
                                CALL FLAG_WARNING("Linear iterative solver did not converge. PETSc diverged nonsymmetric.", &
                                  & err,error,*999)
                              CASE(PETSC_KSP_DIVERGED_INDEFINITE_PC)
                                CALL FLAG_WARNING("Linear iterative solver did not converge. PETSc diverged indefinite PC.", &
                                  & err,error,*999)
                              CASE(PETSC_KSP_DIVERGED_NANORINF)
                                CALL FLAG_WARNING("Linear iterative solver did not converge. PETSc diverged NaN or Inf.", &
                                  & err,error,*999)
                              CASE(PETSC_KSP_DIVERGED_INDEFINITE_MAT)
                                CALL FLAG_WARNING("Linear iterative solver did not converge. PETSc diverged indefinite mat.", &
                                  & err,error,*999)
                              END SELECT
                              IF(SOLVER%outputType>=SOLVER_SOLVER_OUTPUT) THEN
                                !Output solution characteristics
                                CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
                                CALL WriteString(GENERAL_OUTPUT_TYPE,"Linear iterative solver parameters:",err,error,*999)
                                CALL Petsc_KSPGetIterationNumber(LINEAR_ITERATIVE_SOLVER%KSP,NUMBER_ITERATIONS,err,error,*999)
                                CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Final number of iterations = ",NUMBER_ITERATIONS, &
                                  & err,error,*999)
                                CALL Petsc_KSPGetResidualNorm(LINEAR_ITERATIVE_SOLVER%KSP,RESIDUAL_NORM,err,error,*999)
                                CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Final residual norm = ",RESIDUAL_NORM, &
                                  & err,error,*999)
                                SELECT CASE(CONVERGED_REASON)
                                CASE(PETSC_KSP_CONVERGED_RTOL)
                                  CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged RTol",err,error,*999)
                                CASE(PETSC_KSP_CONVERGED_ATOL)
                                  CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged ATol",err,error,*999)
                                CASE(PETSC_KSP_CONVERGED_ITS)
                                  CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged its",err,error,*999)
                                CASE(PETSC_KSP_CONVERGED_CG_NEG_CURVE)
                                  CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged CG neg curve", &
                                    & err,error,*999)
                                CASE(PETSC_KSP_CONVERGED_CG_CONSTRAINED)
                                  CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged CG constrained", &
                                    & err,error,*999)
                                CASE(PETSC_KSP_CONVERGED_STEP_LENGTH)
                                  CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged step length", &
                                    & err,error,*999)
                                CASE(PETSC_KSP_CONVERGED_HAPPY_BREAKDOWN)
                                  CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged happy breakdown", &
                                    & err,error,*999)
                                CASE(PETSC_KSP_CONVERGED_ITERATING)
                                  CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged iterating", &
                                    & err,error,*999)
                                END SELECT
                              ENDIF
                            ELSE
                              CALL FlagError("Solver vector PETSc vector is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("RHS vector petsc PETSc is not associated.",err,error,*999)
                          ENDIF
                        CASE DEFAULT
                          localError="The solver library type of "// &
                            & TRIM(NumberToVString(LINEAR_ITERATIVE_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
                          CALL FlagError(localError,err,error,*999)
                        END SELECT
                      ENDIF
                    ELSE
                      CALL FlagError("Solver vector is not associated.",err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("RHS vector is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Solver matrix is not associated.",err,error,*999)
                ENDIF
              ELSE
                localError="The given number of solver matrices of "// &
                  & TRIM(NumberToVString(SOLVER_MATRICES%NUMBER_OF_MATRICES,"*",err,error))// &
                  & " is invalid. There should only be one solver matrix for a linear iterative solver."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver solver matrices is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver solver equations is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Linear solver solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Linear itreative solver linear solver is not associated.",err,error,*999)
      ENDIF      
    ELSE
      CALL FlagError("Linear iterative solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LINEAR_ITERATIVE_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_ITERATIVE_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_ITERATIVE_SOLVE
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the type of iterative linear solver. \see OpenCMISS::Iron::cmfe_SolverLinearIterativeTypeSet
  SUBROUTINE SOLVER_LINEAR_ITERATIVE_TYPE_SET(SOLVER,ITERATIVE_SOLVER_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the iterative linear solver type
    INTEGER(INTG), INTENT(IN) :: ITERATIVE_SOLVER_TYPE !<The type of iterative linear solver to set \see SOLVER_ROUTINES_IterativeLinearSolverTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_LINEAR_ITERATIVE_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_LINEAR_TYPE) THEN
          IF(ASSOCIATED(SOLVER%LINEAR_SOLVER)) THEN
            IF(SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE==SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE) THEN
              IF(ASSOCIATED(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER)) THEN
                IF(ITERATIVE_SOLVER_TYPE/=SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE) THEN
                  !Intialise the new solver type
                  SELECT CASE(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%SOLVER_LIBRARY)
                  CASE(SOLVER_PETSC_LIBRARY)
                    SELECT CASE(ITERATIVE_SOLVER_TYPE)
                    CASE(SOLVER_ITERATIVE_RICHARDSON)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE=SOLVER_ITERATIVE_RICHARDSON
                    CASE(SOLVER_ITERATIVE_CHEBYSHEV)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE=SOLVER_ITERATIVE_CHEBYSHEV
                    CASE(SOLVER_ITERATIVE_CONJUGATE_GRADIENT)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE=SOLVER_ITERATIVE_CONJUGATE_GRADIENT
                    CASE(SOLVER_ITERATIVE_BICONJUGATE_GRADIENT)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE=SOLVER_ITERATIVE_BICONJUGATE_GRADIENT
                    CASE(SOLVER_ITERATIVE_GMRES)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE=SOLVER_ITERATIVE_GMRES
                    CASE(SOLVER_ITERATIVE_BiCGSTAB)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE=SOLVER_ITERATIVE_BiCGSTAB
                    CASE(SOLVER_ITERATIVE_CONJGRAD_SQUARED)
                      SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%ITERATIVE_SOLVER_TYPE=SOLVER_ITERATIVE_CONJGRAD_SQUARED
                    CASE DEFAULT
                      localError="The iterative solver type of "//TRIM(NumberToVString(ITERATIVE_SOLVER_TYPE,"*",err,error))// &
                        & " is invalid."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  CASE DEFAULT
                    localError="The solver library type of "// &
                      & TRIM(NumberToVString(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER%SOLVER_LIBRARY,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT                  
                ENDIF
              ELSE
                CALL FlagError("The solver linear solver iterative solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The solver is not a linear iterative solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver linear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a linear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LINEAR_ITERATIVE_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_ITERATIVE_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_ITERATIVE_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for a linear solver.
  SUBROUTINE SOLVER_LINEAR_LIBRARY_TYPE_GET(LINEAR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER !<A pointer the linear solver to get the library type for.
     INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On exit, the type of library used for the linear solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DIRECT_SOLVER
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: ITERATIVE_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_LINEAR_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(LINEAR_SOLVER)) THEN
      SELECT CASE(LINEAR_SOLVER%LINEAR_SOLVE_TYPE)
      CASE(SOLVER_LINEAR_DIRECT_SOLVE_TYPE)
        DIRECT_SOLVER=>LINEAR_SOLVER%DIRECT_SOLVER
        IF(ASSOCIATED(DIRECT_SOLVER)) THEN
          CALL SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_GET(DIRECT_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Linear solver direct solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE)
        ITERATIVE_SOLVER=>LINEAR_SOLVER%ITERATIVE_SOLVER
        IF(ASSOCIATED(ITERATIVE_SOLVER)) THEN
          CALL SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_GET(ITERATIVE_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Linear solver iterative solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The linear solver type of "//TRIM(NumberToVString(LINEAR_SOLVER%LINEAR_SOLVE_TYPE,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Linear solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_LINEAR_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_LIBRARY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for a linear solver.
  SUBROUTINE SOLVER_LINEAR_LIBRARY_TYPE_SET(LINEAR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER !<A pointer the linear solver to get the library type for.
     INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library for the linear solver to set. \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DIRECT_SOLVER
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: ITERATIVE_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_LINEAR_LIBRARY_TYPE_SET",err,error,*999)
    
    IF(ASSOCIATED(LINEAR_SOLVER)) THEN
      SELECT CASE(LINEAR_SOLVER%LINEAR_SOLVE_TYPE)
      CASE(SOLVER_LINEAR_DIRECT_SOLVE_TYPE)
        DIRECT_SOLVER=>LINEAR_SOLVER%DIRECT_SOLVER
        IF(ASSOCIATED(DIRECT_SOLVER)) THEN
          CALL SOLVER_LINEAR_DIRECT_LIBRARY_TYPE_SET(DIRECT_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Linear solver direct solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE)
        ITERATIVE_SOLVER=>LINEAR_SOLVER%ITERATIVE_SOLVER
        IF(ASSOCIATED(ITERATIVE_SOLVER)) THEN
          CALL SOLVER_LINEAR_ITERATIVE_LIBRARY_TYPE_SET(ITERATIVE_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Linear solver iterative solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The linear solver type of "//TRIM(NumberToVString(LINEAR_SOLVER%LINEAR_SOLVE_TYPE,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Linear solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_LINEAR_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_LIBRARY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_LIBRARY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Solve a linear solver 
  SUBROUTINE SOLVER_LINEAR_SOLVE(LINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: LINEAR_SOLVER !<A pointer to the linear solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: solver_matrix_idx
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_LINEAR_SOLVE",err,error,*999)

    IF(ASSOCIATED(LINEAR_SOLVER)) THEN
      SOLVER=>LINEAR_SOLVER%SOLVER
      IF(ASSOCIATED(SOLVER)) THEN

#ifdef TAUPROF
        CALL TAU_STATIC_PHASE_START("Solver Matrix Assembly Phase")
#endif
        IF(.NOT.ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
          !Assemble the solver matrices
!!TODO: Work out what to assemble

          CALL Solver_StaticAssemble(SOLVER,SOLVER_MATRICES_LINEAR_ONLY,err,error,*999)
        ENDIF

#ifdef TAUPROF
        CALL TAU_STATIC_PHASE_STOP("Solver Matrix Assembly Phase")

        CALL TAU_STATIC_PHASE_START("Solve Phase")
#endif
        SELECT CASE(LINEAR_SOLVER%LINEAR_SOLVE_TYPE)
        CASE(SOLVER_LINEAR_DIRECT_SOLVE_TYPE)
          CALL SOLVER_LINEAR_DIRECT_SOLVE(LINEAR_SOLVER%DIRECT_SOLVER,err,error,*999)
        CASE(SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE)
          CALL SOLVER_LINEAR_ITERATIVE_SOLVE(LINEAR_SOLVER%ITERATIVE_SOLVER,err,error,*999)
        CASE DEFAULT
          localError="The linear solver type of "//TRIM(NumberToVString(LINEAR_SOLVER%LINEAR_SOLVE_TYPE,"*",err,error))// &
            & " is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
#ifdef TAUPROF
        CALL TAU_STATIC_PHASE_STOP("Solve Phase")
#endif
        
        IF(SOLVER%outputType>=SOLVER_SOLVER_OUTPUT) THEN

#ifdef TAUPROF
          CALL TAU_STATIC_PHASE_START("Solution Output Phase")
#endif
          
          SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
          IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
            SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
            IF(ASSOCIATED(SOLVER_MATRICES)) THEN
              CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
              CALL WriteString(GENERAL_OUTPUT_TYPE,"Solver solution vectors:",err,error,*999)
              CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Number of solution vectors = ",SOLVER_MATRICES%NUMBER_OF_MATRICES, &
                & err,error,*999)
              DO solver_matrix_idx=1,SOLVER_MATRICES%NUMBER_OF_MATRICES
                CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Solution vector for solver matrix : ",solver_matrix_idx,err,error,*999)
                CALL DistributedVector_Output(GENERAL_OUTPUT_TYPE,SOLVER_MATRICES%matrices(solver_matrix_idx)%ptr% &
                  & SOLVER_VECTOR,err,error,*999)
              ENDDO !solver_matrix_idx
            ELSE
              CALL FlagError("Solver equations solver matrices is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver solver equations is not associated.",err,error,*999)
          ENDIF
          
#ifdef TAUPROF
        CALL TAU_STATIC_PHASE_STOP("Solution Output Phase")
#endif
        ENDIF
        
        IF(.NOT.ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
          !Update depenent field with solution
#ifdef TAUPROF
          CALL TAU_STATIC_PHASE_START("Field Update Phase")
#endif
          CALL SOLVER_VARIABLES_FIELD_UPDATE(SOLVER,err,error,*999)
#ifdef TAUPROF
          CALL TAU_STATIC_PHASE_STOP("Field Update Phase")
#endif
        ENDIF
      ELSE
        CALL FlagError("Linear solver solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Linear solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_LINEAR_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_LINEAR_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_SOLVE
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the type of linear solver. \see OpenCMISS::Iron::cmfe_SolverLinearTypeSet
  SUBROUTINE SOLVER_LINEAR_TYPE_SET(SOLVER,LINEAR_SOLVE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the linear solver type
    INTEGER(INTG), INTENT(IN) :: LINEAR_SOLVE_TYPE !<The type of linear solver to set \see SOLVER_ROUTINES_LinearSolverTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError,localError
    
    ENTERS("SOLVER_LINEAR_TYPE_SET",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*998)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_LINEAR_TYPE) THEN
          IF(ASSOCIATED(SOLVER%LINEAR_SOLVER)) THEN
            IF(LINEAR_SOLVE_TYPE/=SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE) THEN
              !Intialise the new solver type
              SELECT CASE(LINEAR_SOLVE_TYPE)
              CASE(SOLVER_LINEAR_DIRECT_SOLVE_TYPE)
                CALL SOLVER_LINEAR_DIRECT_INITIALISE(SOLVER%LINEAR_SOLVER,err,error,*999)
              CASE(SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE)
                CALL SOLVER_LINEAR_ITERATIVE_INITIALISE(SOLVER%LINEAR_SOLVER,err,error,*999)
              CASE DEFAULT
                localError="The linear solver type of "//TRIM(NumberToVString(LINEAR_SOLVE_TYPE,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
              !Finalise the old solver type
              SELECT CASE(SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE)
              CASE(SOLVER_LINEAR_DIRECT_SOLVE_TYPE)
                CALL SOLVER_LINEAR_DIRECT_FINALISE(SOLVER%LINEAR_SOLVER%DIRECT_SOLVER,err,error,*999)
              CASE(SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE)
                CALL SOLVER_LINEAR_ITERATIVE_FINALISE(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER,err,error,*999)
              CASE DEFAULT
                localError="The linear solver type of "// &
                  & TRIM(NumberToVString(SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
              SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE=LINEAR_SOLVE_TYPE
            ENDIF
          ELSE
            CALL FlagError("The solver linear solver is not associated.",err,error,*998)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a linear solver.",err,error,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
    
    EXITS("SOLVER_LINEAR_TYPE_SET")
    RETURN
999 SELECT CASE(LINEAR_SOLVE_TYPE)
    CASE(SOLVER_LINEAR_DIRECT_SOLVE_TYPE)
      CALL SOLVER_LINEAR_DIRECT_FINALISE(SOLVER%LINEAR_SOLVER%DIRECT_SOLVER,dummyErr,dummyError,*998)
    CASE(SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE)
      CALL SOLVER_LINEAR_ITERATIVE_FINALISE(SOLVER%LINEAR_SOLVER%ITERATIVE_SOLVER,dummyErr,dummyError,*998)
    END SELECT
998 ERRORSEXITS("SOLVER_LINEAR_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_LINEAR_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Assembles the solver matrices and rhs from the dynamic equations.
  SUBROUTINE Solver_DynamicAssemble(solver,selectionType,err,error,*)
    
    !Argument variable
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer to the solver
    INTEGER(INTG), INTENT(IN) :: selectionType !<The type of matrix selection \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dynamicVariableType,equationsMatrixIdx,equationsRowNumber,equationsSetIdx,linearVariableType, &
      & rhsBoundaryCondition,rhsGlobalDOF,rhsVariableDOF,rhsVariableType,solverRowIdx,solverRowNumber, &
      & solverMatrixIdx,residualVariableDOF,variableBoundaryCondition,variableType,equationsMatrixIdx2, &
      & variableIdx,variableGlobalDOF,variableDOF,equationsRowNumber2,equationsMatrixNumber,dependentVariableType, &
      & equationsColumnNumber,dirichletRow,dirichletIdx, &
      & interfaceConditionIdx,interfaceMatrixIdx,interfaceColumnNumber,interfaceRowNumber, &
      & interfaceVariableType,numberOfInterfaceMatrices
    INTEGER(INTG) :: currentIteration,outputIteration
    REAL(SP) :: systemElapsed,systemTime1(1),systemTime2(1),userElapsed,userTime1(1),userTime2(1)
    REAL(DP) :: dampingMatrixCoefficient,deltaT,dynamicValue,firstUpdateFactor,residualValue, &
      & linearValue,linearValueSum,massMatrixCoefficient,nonlinearValue,rhsValue,rowCouplingCoefficient,previousResidualValue, &
      & secondUpdateFactor,sourceValue,stiffnessMatrixCoefficient,VALUE,jacobianMatrixCoefficient,alphaValue, &
      & matrixValue,dynamicDisplacementFactor,dynamicVelocityFactor,dynamicAccelerationFactor,rhsIntegratedValue, &
      & currentFunctionFactor,previousFunctionFactor,previous2FunctionFactor,previous3FunctionFactor
    REAL(DP) :: currentTime,timeIncrement,startTime,stopTime
    REAL(DP) :: matrixCoefficients(2)=[0.0_DP,0.0_DP]
    REAL(DP), POINTER :: checkData(:),checkData2(:),currentValuesVector(:),previousValuesVector(:),previousVelocityVector(:), &
      & previousAccelerationVector(:),previousResidualParameters(:),previous2ResidualParameters(:), &
      & previous3ResidualParameters(:), previousRHSParameters(:),previous2RHSParameters(:),previous3RHSParameters(:), &
      & rhsIntegratedParameters(:),rhsParameters(:),solverRHSData(:),solverResidualData(:)
    LOGICAL :: hasIntegratedValues
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: boundaryConditions
    TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE), POINTER :: sparsityIndices
    TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: rhsBoundaryConditions,dependentBoundaryConditions
    TYPE(CONTROL_LOOP_TYPE), POINTER :: controlLoop
    TYPE(DistributedMatrixType), POINTER :: previousSolverDistributedMatrix,solverDistributedMatrix
    TYPE(DistributedVectorType), POINTER :: dependentVector,dynamicTempVector,equationsRHSVector,distributedSourceVector, &
      & linearTempVector,predictedMeanAccelerationVector,predictedMeanDisplacementVector,predictedMeanVelocityVector, &
      & solverRHSVector,solverResidualVector,residualVector,incrementalVector,interfaceTempVector, &
      & lagrangeVector
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: rhsDomainMapping,variableDomainMapping
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: dynamicSolver
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsJacobianType), POINTER :: jacobianMatrix
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingLinearType), POINTER :: linearMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingRHSType), POINTER :: rhsMapping
    TYPE(EquationsMappingSourceType), POINTER :: sourceMapping
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatricesDynamicType), POINTER :: dynamicMatrices
    TYPE(EquationsMatricesLinearType), POINTER :: linearMatrices
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesRHSType), POINTER :: rhsVector
    TYPE(EquationsMatricesSourceType), POINTER :: sourceVector
    TYPE(EquationsMatrixType), POINTER :: dampingMatrix,linearMatrix,massMatrix,stiffnessMatrix,equationsMatrix
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
    TYPE(FIELD_TYPE), POINTER :: dependentField,lagrangeField
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: dependentVariable,dynamicVariable,linearVariable,rhsVariable,interfaceVariable
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: interfaceEquations
    TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: interfaceLagrange
    TYPE(INTERFACE_MAPPING_TYPE), POINTER :: interfaceMapping
    TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER :: interfaceRHSMapping
    TYPE(INTERFACE_MATRICES_TYPE), POINTER :: interfaceMatrices
    TYPE(INTERFACE_MATRIX_TYPE), POINTER :: interfaceMatrix
    TYPE(INTERFACE_RHS_TYPE), POINTER :: interfaceRHSVector
    TYPE(INTERFACE_TO_SOLVER_MAPS_TYPE), POINTER :: interfaceToSolverMap
    TYPE(JACOBIAN_TO_SOLVER_MAP_TYPE), POINTER :: jacobianToSolverMap
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: solverMapping
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: solverMatrix
    TYPE(VARYING_STRING) :: localError
   
    ENTERS("Solver_DynamicAssemble",err,error,*999)

    IF(.NOT.ASSOCIATED(solver)) CALL FlagError("Solver is not associated.",err,error,*999)
       
    !Determine which dynamic solver needs to be used
    IF(solver%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
      dynamicSolver=>solver%DYNAMIC_SOLVER
    ELSE IF(solver%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN 
      dynamicSolver=>solver%LINKING_SOLVER%DYNAMIC_SOLVER
    ELSE
      CALL FlagError("Dynamic solver solve type is not associated.",err,error,*999)
    ENDIF
    IF(.NOT.ASSOCIATED(dynamicSolver)) CALL FlagError("Solver dynamic solver is not associated.",err,error,*999)

    NULLIFY(controlLoop)
    CALL Solver_ControlLoopGet(solver,controlLoop,err,error,*999)
    CALL ControlLoop_CurrentTimeInformationGet(controlLoop,currentTime,timeIncrement,startTime,stopTime, &
      & currentIteration,outputIteration,err,error,*999)
    
    deltaT=dynamicSolver%TIME_INCREMENT
    SELECT CASE(dynamicSolver%degree)
    CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
      stiffnessMatrixCoefficient=1.0_DP*dynamicSolver%theta(1)*deltaT
      dampingMatrixCoefficient=1.0_DP
      massMatrixCoefficient=0.0_DP
      jacobianMatrixCoefficient=stiffnessMatrixCoefficient
      dynamicDisplacementFactor=deltaT
      currentFunctionFactor=dynamicSolver%theta(1)
      previousFunctionFactor=1.0_DP-dynamicSolver%theta(1)
    CASE(SOLVER_DYNAMIC_SECOND_DEGREE)
      stiffnessMatrixCoefficient=dynamicSolver%theta(2)*deltaT*deltaT/2.0_DP
      dampingMatrixCoefficient=dynamicSolver%theta(1)*deltaT
      massMatrixCoefficient=1.0_DP
      jacobianMatrixCoefficient=(dynamicSolver%theta(2)+dynamicSolver%theta(1))*deltaT*deltaT/4.0_DP
      firstUpdateFactor=deltaT
      dynamicDisplacementFactor=deltaT*deltaT/2.0_DP
      dynamicVelocityFactor=deltaT
      currentFunctionFactor=(dynamicSolver%theta(2)+dynamicSolver%theta(1))/2.0_DP
      previousFunctionFactor=1.0_DP-dynamicSolver%theta(2)
      previous2FunctionFactor=(dynamicSolver%theta(2)-dynamicSolver%theta(1))/2.0_DP
    CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
      stiffnessMatrixCoefficient=dynamicSolver%theta(3)*deltaT*deltaT*deltaT/6.0_DP
      dampingMatrixCoefficient=dynamicSolver%theta(2)*deltaT*deltaT/2.0_DP
      massMatrixCoefficient=dynamicSolver%theta(1)*deltaT
      jacobianMatrixCoefficient=(dynamicSolver%theta(3)+3.0_DP*dynamicSolver%theta(2)+2.0_DP*dynamicSolver%theta(1))* &
        & deltaT*deltaT*deltaT/36.0_DP
      firstUpdateFactor=deltaT
      secondUpdateFactor=deltaT*deltaT/2.0_DP
      dynamicDisplacementFactor=deltaT*deltaT*deltaT/6.0_DP
      dynamicVelocityFactor=deltaT
      dynamicAccelerationFactor=deltaT*deltaT/2.0_DP
      currentFunctionFactor=(dynamicSolver%theta(3)+3.0_DP*dynamicSolver%theta(2)+2.0_DP*dynamicSolver%theta(1))/6.0_DP
      previousFunctionFactor=1.0_DP-(dynamicSolver%theta(3)+2.0_DP*dynamicSolver%theta(2)-dynamicSolver%theta(1))/2.0_DP
      previous2FunctionFactor=(dynamicSolver%theta(3)+dynamicSolver%theta(2)-2.0_DP*dynamicSolver%theta(1))/2.0_DP
      previous3FunctionFactor=(dynamicSolver%theta(1)-dynamicSolver%theta(3))/6.0_DP            
    CASE DEFAULT
      localError="The dynamic solver degree of "//TRIM(NumberToVString(dynamicSolver%degree,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    
    NULLIFY(solverEquations)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    NULLIFY(solverMapping)
    CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
    NULLIFY(solverMatrices)
    CALL SolverEquations_SolverMatricesGet(solverEquations,solverMatrices,err,error,*999)

    NULLIFY(previousSolverDistributedMatrix)
    
    !Assemble the solver matrices    
    IF(selectionType==SOLVER_MATRICES_ALL.OR. &
      & selectionType==SOLVER_MATRICES_LINEAR_ONLY.OR. &
      & selectionType==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
      & selectionType==SOLVER_MATRICES_LINEAR_RESIDUAL_ONLY.OR. &
      & selectionType==SOLVER_MATRICES_JACOBIAN_ONLY) THEN
      IF(dynamicSolver%SOLVER_INITIALISED.OR.(.NOT.dynamicSolver%SOLVER_INITIALISED.AND. &
        & ((dynamicSolver%ORDER==SOLVER_DYNAMIC_FIRST_ORDER.AND.dynamicSolver%DEGREE>SOLVER_DYNAMIC_FIRST_DEGREE).OR. &
        & (dynamicSolver%ORDER==SOLVER_DYNAMIC_SECOND_ORDER.AND.dynamicSolver%DEGREE>SOLVER_DYNAMIC_SECOND_DEGREE)))) THEN
        !Assemble solver matrices
        IF(solver%outputType>=SOLVER_TIMING_OUTPUT) THEN
          CALL CPUTimer(USER_CPU,userTime1,err,error,*999)
          CALL CPUTimer(SYSTEM_CPU,systemTime1,err,error,*999)
        ENDIF
        !Just deal with one solver matrix for now. 
        solverMatrixIdx=1
        IF(solverMapping%NUMBER_OF_SOLVER_MATRICES/=solverMatrixIdx) &
          & CALL FlagError("Invalid number of solver matrices.",err,error,*999)

        NULLIFY(solverMatrix)
        CALL SolverMatrices_SolverMatrixGet(solverMatrices,solverMatrixIdx,solverMatrix,err,error,*999)
        IF(solverMatrix%UPDATE_MATRIX) THEN      
          solverDistributedMatrix=>solverMatrix%MATRIX
          IF(.NOT.ASSOCIATED(solverDistributedMatrix)) &
            & CALL FlagError("Solver matrix distributed matrix is not associated.",err,error,*999)

          !Initialise matrix to zero
          CALL DistributedMatrix_AllValuesSet(solverDistributedMatrix,0.0_DP,err,error,*999)
          !Loop over the equations sets
          DO equationsSetIdx=1,solverMapping%NUMBER_OF_EQUATIONS_SETS
            NULLIFY(equationsSet)
            CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
            NULLIFY(equations)
            CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
            NULLIFY(vectorEquations)
            CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
            NULLIFY(vectorMapping)
            CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
            NULLIFY(vectorMatrices)
            CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
            dynamicMapping=>vectorMapping%dynamicMapping
            IF(ASSOCIATED(dynamicMapping)) THEN
              NULLIFY(dynamicMatrices)
              CALL EquationsMatricesVector_DynamicMatricesGet(vectorMatrices,dynamicMatrices,err,error,*999)
              IF(dynamicSolver%SOLVER_INITIALISED) THEN                      
                IF(dynamicMapping%stiffnessMatrixNumber/=0) THEN
                  NULLIFY(stiffnessMatrix)
                  CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,dynamicMapping%stiffnessMatrixNumber, &
                    & stiffnessMatrix,err,error,*999)
                  CALL SolverMatrix_EquationsMatrixAdd(solverMatrix,equationsSetIdx,stiffnessMatrixCoefficient,stiffnessMatrix, &
                    & err,error,*999)
                ENDIF
                IF(dynamicMapping%dampingMatrixNumber/=0) THEN
                  NULLIFY(dampingMatrix)
                  CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,dynamicMapping%dampingMatrixNumber, &
                    & dampingMatrix,err,error,*999)
                  CALL SolverMatrix_EquationsMatrixAdd(solverMatrix,equationsSetIdx,dampingMatrixCoefficient,dampingMatrix, &
                    & err,error,*999)
                ENDIF
                IF(dynamicMapping%massMatrixNumber/=0) THEN
                  NULLIFY(massMatrix)
                  CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,dynamicMapping%massMatrixNumber, &
                    & massMatrix,err,error,*999)
                  CALL SolverMatrix_EquationsMatrixAdd(solverMatrix,equationsSetIdx,massMatrixCoefficient,massMatrix, &
                    & err,error,*999)
                ENDIF
              ELSE
                IF(dynamicSolver%ORDER==SOLVER_DYNAMIC_SECOND_ORDER.AND. &
                  & dynamicSolver%DEGREE==SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                  IF(dynamicMapping%massMatrixNumber==0) &
                    & CALL FlagError("Can not perform initial solve with no mass matrix.",err,error,*999)
                  NULLIFY(massMatrix)
                  CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,dynamicMapping%massMatrixNumber, &
                    & massMatrix,err,error,*999)
                  CALL SolverMatrix_EquationsMatrixAdd(solverMatrix,equationsSetIdx,-1.0_DP,massMatrix,err,error,*999)
                ELSE
                  IF(dynamicMapping%dampingMatrixNumber==0) &
                    & CALL FlagError("Can not perform initial solve with no damping matrix.",err,error,*999)
                  NULLIFY(dampingMatrix)
                  CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,dynamicMapping%dampingMatrixNumber, &
                    & dampingMatrix,err,error,*999)
                  CALL SolverMatrix_EquationsMatrixAdd(solverMatrix,equationsSetIdx,-1.0_DP,dampingMatrix,err,error,*999)
                ENDIF
              ENDIF !dynamic solver initialised
            ENDIF
!!TODO: What if we had and equations set that contained a linear matrix that was mapped to the dynamic variable??? It should be added in like a K matrix?
            NULLIFY(jacobianToSolverMap)
            NULLIFY(jacobianMatrix)
            nonlinearMapping=>vectorMapping%nonlinearMapping
            IF(ASSOCIATED(nonlinearMapping)) THEN
              IF(selectionType==SOLVER_MATRICES_ALL.OR. &
                & selectionType==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
                & selectionType==SOLVER_MATRICES_JACOBIAN_ONLY) THEN
!!TODO: What about equations set that do not have the residual variable the same as the dynamic variable???                
                !Now set the values from the equations Jacobian
                NULLIFY(nonlinearMatrices)
                CALL EquationsMatricesVector_NonlinearMatricesGet(vectorMatrices,nonlinearMatrices,err,error,*999)
                DO equationsMatrixIdx=1,nonlinearMatrices%numberOfJacobians
                  jacobianToSolverMap=>solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                    & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solverMatrixIdx)%JACOBIAN_TO_SOLVER_MATRIX_MAPS(equationsMatrixIdx)%ptr
                  IF(ASSOCIATED(jacobianToSolverMap)) THEN
                    jacobianMatrix=>jacobianToSolverMap%JACOBIAN_MATRIX
                    IF(ASSOCIATED(jacobianMatrix)) THEN
                      CALL SolverMatrix_JacobianMatrixAdd(solverMatrix,equationsSetIdx,jacobianMatrixCoefficient,jacobianMatrix, &
                        & err,error,*999)
                    ELSE
                      CALL FlagError("Jacobian matrix is not associated.",err,error,*999)
                    ENDIF
                  ELSE
                    localError="Jacobian to solver map is not associated for Jacobian number "// &
                      & TRIM(NumberToVString(equationsMatrixIdx,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ENDDO !equationsMatrixIdx
              ENDIF
            ENDIF
          ENDDO !equationsSetIdx
          !Loop over any interface conditions
          DO interfaceConditionIdx=1,solverMapping%NUMBER_OF_INTERFACE_CONDITIONS
            !Loop over the interface matrices
            DO interfaceMatrixIdx=1,solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
              & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solverMatrixIdx)%NUMBER_OF_INTERFACE_MATRICES
              interfaceToSolverMap=>solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
                & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solverMatrixIdx)% &
                & INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS(interfaceMatrixIdx)%ptr
              IF(ASSOCIATED(interfaceToSolverMap)) THEN
                interfaceMatrix=>interfaceToSolverMap%INTERFACE_MATRIX
                IF(ASSOCIATED(interfaceMatrix)) THEN
                  SELECT CASE(interfaceMatrix%INTERFACE_MATRIX_TIME_DEPENDENCE_TYPE)
                  CASE(INTERFACE_MATRIX_STATIC)
                    matrixCoefficients(1)=stiffnessMatrixCoefficient
                  CASE(INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC)
                    matrixCoefficients(1)=dampingMatrixCoefficient
                  CASE DEFAULT
                    CALL FlagError("Not implemented.",Err,Error,*999)
                  END SELECT
                  IF(interfaceMatrix%HAS_TRANSPOSE) THEN
                    SELECT CASE(interfaceMatrix%INTERFACE_MATRIX_TRANSPOSE_TIME_DEPENDENCE_TYPE)
                    CASE(INTERFACE_MATRIX_STATIC)
                      matrixCoefficients(2)=stiffnessMatrixCoefficient
                    CASE(INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC)
                      matrixCoefficients(2)=dampingMatrixCoefficient
                    CASE DEFAULT
                      CALL FlagError("Not implemented.",Err,Error,*999)
                    END SELECT
                  ELSE
                    matrixCoefficients(2)=0.0_DP
                  ENDIF
                  CALL SolverMatrix_InterfaceMatrixAdd(solverMatrix,interfaceConditionIdx,matrixCoefficients,interfaceMatrix, &
                    & err,error,*999)
                ELSE
                  CALL FlagError("The interface matrix is not associated.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The interface matrix interface to solver map is not associated.",err,error,*999)
              ENDIF
            ENDDO !interfaceMatrixIdx
          ENDDO !interfaceConditionIdx
          !Update the solver matrix values
          CALL DistributedMatrix_UpdateStart(solverDistributedMatrix,err,error,*999)          
          IF(ASSOCIATED(previousSolverDistributedMatrix)) &
            & CALL DistributedMatrix_UpdateFinish(previousSolverDistributedMatrix,err,error,*999)
          previousSolverDistributedMatrix=>solverDistributedMatrix
          IF(solver%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
            IF(dynamicSolver%SOLVER_INITIALISED) solverMatrix%UPDATE_MATRIX=.FALSE.
          ELSE IF(solver%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN 
            IF(dynamicSolver%SOLVER_INITIALISED) solverMatrix%UPDATE_MATRIX=.TRUE.
          ELSE
            CALL FlagError("Dynamic solver solve type is not associated.",err,error,*999)
          END IF
        ENDIF !Update matrix
        IF(ASSOCIATED(previousSolverDistributedMatrix)) &
          & CALL DistributedMatrix_UpdateFinish(previousSolverDistributedMatrix,err,error,*999)
        IF(solver%outputType>=SOLVER_TIMING_OUTPUT) THEN
          CALL CPUTimer(USER_CPU,userTime2,err,error,*999)
          CALL CPUTimer(SYSTEM_CPU,systemTime2,err,error,*999)
          userElapsed=userTime2(1)-userTime1(1)
          systemElapsed=systemTime2(1)-systemTime1(1)
          IF(solver%outputType>=SOLVER_MATRIX_OUTPUT) &
            & CALL Profiling_TimingsOutput(0,"",userElapsed,systemElapsed,err,error,*999)
          CALL Profiling_TimingsOutput(1,"Solver matrices assembly",userElapsed,systemElapsed,err,error,*999)
        ENDIF
      ENDIF
    ENDIF

    NULLIFY(solverRHSVector)
    IF(selectionType==SOLVER_MATRICES_ALL.OR. &
      & selectionType==SOLVER_MATRICES_LINEAR_ONLY.OR. &
      & selectionType==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
      & selectionType==SOLVER_MATRICES_RHS_RESIDUAL_ONLY.OR. &
      & selectionType==SOLVER_MATRICES_LINEAR_RESIDUAL_ONLY.OR. &
      & selectionType==SOLVER_MATRICES_RHS_ONLY) THEN
      !Assemble rhs vector
      IF(solver%outputType>=SOLVER_TIMING_OUTPUT) THEN
        CALL CPUTimer(USER_CPU,userTime1,err,error,*999)
        CALL CPUTimer(SYSTEM_CPU,systemTime1,err,error,*999)
      ENDIF
      IF(solverMatrices%UPDATE_RHS_VECTOR) THEN
        CALL SolverMatrices_RHSVectorGet(solverMatrices,solverRHSVector,err,error,*999)
        NULLIFY(solverRHSData)
        CALL DistributedVector_DataGet(solverRHSVector,solverRHSData,err,error,*999)
        !Initialise the RHS to zero
        CALL DistributedVector_AllValuesSet(solverRHSVector,0.0_DP,err,error,*999)          
        !Get the solver variables data                  
        NULLIFY(checkData)
        CALL DistributedVector_DataGet(solverRHSVector,checkData,err,error,*999)             
        !Loop over the equations sets
        DO equationsSetIdx=1,solverMapping%NUMBER_OF_EQUATIONS_SETS
          NULLIFY(equationsSet)
          CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
          NULLIFY(dependentField)
          CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
          NULLIFY(equations)
          CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
          NULLIFY(vectorEquations)
          CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
          NULLIFY(vectorMatrices)
          CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
          NULLIFY(vectorMapping)
          CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
          dynamicMapping=>vectorMapping%dynamicMapping
          IF(ASSOCIATED(dynamicMapping)) THEN
            dynamicVariableType=dynamicMapping%dynamicVariableType
            !Calculate the dynamic contributions
            NULLIFY(dynamicVariable)
            CALL EquationsMappingDynamic_DynamicVariableGet(dynamicMapping,dynamicVariable,err,error,*999)
            NULLIFY(dynamicMatrices)
            CALL EquationsMatricesVector_DynamicMatricesGet(vectorMatrices,dynamicMatrices,err,error,*999)
            dynamicTempVector=>dynamicMatrices%tempVector
            !Initialise the dynamic temporary vector to zero
            CALL DistributedVector_AllValuesSet(dynamicTempVector,0.0_DP,err,error,*999)
            IF(dynamicMapping%stiffnessMatrixNumber/=0) THEN
              NULLIFY(stiffnessMatrix)
              CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,dynamicMapping%stiffnessMatrixNumber, &
                & stiffnessMatrix,err,error,*999)
              NULLIFY(predictedMeanDisplacementVector)
              CALL Field_ParameterSetVectorGet(dependentField,dynamicVariableType, &
                & FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,predictedMeanDisplacementVector, &
                & err,error,*999)
              CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE,1.0_DP,stiffnessMatrix%matrix, &
                & predictedMeanDisplacementVector,dynamicTempVector,err,error,*999)                
            ENDIF
            IF(dynamicMapping%dampingMatrixNumber/=0.AND. &
              & dynamicSolver%DEGREE>SOLVER_DYNAMIC_FIRST_DEGREE) THEN
              NULLIFY(dampingMatrix)
              CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,dynamicMapping%dampingMatrixNumber, &
                & dampingMatrix,err,error,*999)
              NULLIFY(predictedMeanVelocityVector)
              CALL Field_ParameterSetVectorGet(dependentField,dynamicVariableType, &
                & FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE,predictedMeanVelocityVector, &
                & err,error,*999)
              CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE,1.0_DP,dampingMatrix%matrix, &
                & predictedMeanVelocityVector,dynamicTempVector,err,error,*999)
            ENDIF
            IF(dynamicMapping%massMatrixNumber/=0.AND. &
              & dynamicSolver%DEGREE>SOLVER_DYNAMIC_SECOND_DEGREE) THEN
              NULLIFY(massMatrix)
              CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,dynamicMapping%massMatrixNumber, &
                & massMatrix,err,error,*999)
              NULLIFY(predictedMeanAccelerationVector)
              CALL Field_ParameterSetVectorGet(dependentField,dynamicVariableType, &
                & FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE,predictedMeanAccelerationVector, &
                & err,error,*999)
              CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE,1.0_DP,massMatrix%matrix, &
                & predictedMeanAccelerationVector,dynamicTempVector,err,error,*999)
            ENDIF
          ENDIF
          nonlinearMapping=>vectorMapping%nonlinearMapping
          IF(ASSOCIATED(nonlinearMapping)) THEN
            !Default to FIELD_U_VARIABLE_TYPE
            dynamicVariableType=FIELD_U_VARIABLE_TYPE
            IF(ASSOCIATED(dynamicTempVector)) NULLIFY(dynamicTempVector)                                      
            !Get the nonlinear vector contribute to the RHS values if nonlinear solve
            IF(solver%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN 
              NULLIFY(previousResidualParameters)
              CALL Field_ParameterSetDataGet(dependentField,dynamicVariableType, &
                & FIELD_PREVIOUS_RESIDUAL_SET_TYPE,previousResidualParameters,err,error,*999)
              IF(dynamicSolver%degree>=SOLVER_DYNAMIC_SECOND_DEGREE) THEN
                NULLIFY(previous2ResidualParameters)
                CALL Field_ParameterSetDataGet(dependentField,dynamicVariableType, &
                  & FIELD_PREVIOUS2_RESIDUAL_SET_TYPE,previous2ResidualParameters,err,error,*999)
              ENDIF
              IF(dynamicSolver%degree>=SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                NULLIFY(previous3ResidualParameters)
                CALL Field_ParameterSetDataGet(dependentField,dynamicVariableType, &
                  & FIELD_PREVIOUS3_RESIDUAL_SET_TYPE,previous3ResidualParameters,err,error,*999)
              ENDIF
            ENDIF
          ENDIF
          !Calculate the contributions from any linear matrices 
          linearMapping=>vectorMapping%linearMapping
          IF(ASSOCIATED(linearMapping)) THEN
            NULLIFY(linearMatrices)
            CALL EquationsMatricesVector_LinearMatricesGet(vectorMatrices,linearMatrices,err,error,*999)
            DO equationsMatrixIdx=1,linearMatrices%numberOfLinearMatrices
              NULLIFY(linearMatrix)
              CALL EquationsMatricesLinear_EquationsMatrixGet(linearMatrices,equationsMatrixIdx,linearMatrix,err,error,*999)
              linearVariableType=linearMapping%equationsMatrixToVarMaps(equationsMatrixIdx)%variableType                
              linearVariable=>linearMapping%equationsMatrixToVarMaps(equationsMatrixIdx)%variable
              IF(ASSOCIATED(linearVariable)) THEN
!!TODO: Need to work out if the linear variable is a a dynamic variable (in which case it gets added to the stiffness matrix) or
!!if it is not a dynamic variable (and thus by definition doesn't change with time) in which case it goes to the RHS. 
                linearTempVector=>linearMatrix%tempVector
                !Initialise the linear temporary vector to zero
                CALL DistributedVector_AllValuesSet(linearTempVector,0.0_DP,err,error,*999)                  
                NULLIFY(dependentVector)
                CALL Field_ParameterSetVectorGet(dependentField,linearVariableType, &
                  & FIELD_VALUES_SET_TYPE,dependentVector,err,error,*999)
                CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE, &
                  & 1.0_DP,linearMatrix%matrix,dependentVector,linearTempVector,err,error,*999)
              ELSE
                CALL FlagError("Linear variable is not associated.",err,error,*999)
              ENDIF
            ENDDO !equationsMatrixIdx
          ENDIF
          sourceMapping=>vectorMapping%sourceMapping
          IF(ASSOCIATED(sourceMapping)) THEN
            NULLIFY(sourceVector)
!!TODO: can source vectors change with time. If so then they need to have previous function factors applied. 
            CALL EquationsMatricesVector_SourceVectorGet(vectorMatrices,sourceVector,err,error,*999)
            distributedSourceVector=>sourceVector%vector
          ENDIF
          rhsMapping=>vectorMapping%rhsMapping
          IF(ASSOCIATED(rhsMapping)) THEN
            rhsVariableType=rhsMapping%rhsVariableType
            boundaryConditions=>solverEquations%BOUNDARY_CONDITIONS
            IF(.NOT.ASSOCIATED(boundaryConditions)) &
              & CALL FlagError("Equations set boundary conditions is not associated.",err,error,*999)
!!TODO: what if the equations set doesn't have a RHS vector??? Will be sorted once LHS mapping is implemented.
            rhsVariableType=rhsMapping%rhsVariableType
            rhsVariable=>rhsMapping%rhsVariable
            rhsDomainMapping=>rhsVariable%DOMAIN_MAPPING
            CALL Field_ParameterSetCreated(rhsVariable%field,rhsVariableType, &
              & FIELD_INTEGRATED_NEUMANN_SET_TYPE,hasIntegratedValues,err,error,*999)
            CALL BOUNDARY_CONDITIONS_VARIABLE_GET(boundaryConditions,rhsVariable,rhsBoundaryConditions,err,error,*999)
            IF(.NOT.ASSOCIATED(rhsBoundaryConditions)) &
              & CALL FlagError("RHS boundary conditions variable is not associated.",err,error,*999)
            !Update RHS field by integrating any point Neumann conditions
            CALL BoundaryConditions_NeumannIntegrate(rhsBoundaryConditions,err,error,*999)
            !Get values and previous values
            NULLIFY(currentValuesVector)
            CALL Field_ParameterSetDataGet(dependentField,dynamicVariableType, &
              FIELD_VALUES_SET_TYPE,currentValuesVector,err,error,*999)
            NULLIFY(previousValuesVector)
            CALL Field_ParameterSetDataGet(dependentField,dynamicVariableType, &
              FIELD_PREVIOUS_VALUES_SET_TYPE,previousValuesVector,err,error,*999)
            NULLIFY(rhsParameters)
            CALL Field_ParameterSetDataGet(dependentField,rhsVariableType, &
              & FIELD_VALUES_SET_TYPE,rhsParameters,err,error,*999)
            NULLIFY(previousRHSParameters)
            CALL Field_ParameterSetDataGet(dependentField,rhsVariableType, &
              & FIELD_PREVIOUS_VALUES_SET_TYPE,previousRHSParameters,err,error,*999)
            IF(hasIntegratedValues) THEN
              NULLIFY(rhsIntegratedParameters)
              CALL Field_ParameterSetDataGet(dependentField,rhsVariableType, &
                & FIELD_INTEGRATED_NEUMANN_SET_TYPE,rhsIntegratedParameters,err,error,*999)                
            ENDIF
            IF(dynamicSolver%degree>=SOLVER_DYNAMIC_SECOND_DEGREE) THEN
              NULLIFY(previousVelocityVector)
              CALL Field_ParameterSetDataGet(dependentField,dynamicVariableType, &
                FIELD_PREVIOUS_VELOCITY_SET_TYPE,previousVelocityVector,err,error,*999)
              NULLIFY(previous2RHSParameters)
              CALL Field_ParameterSetDataGet(dependentField,rhsVariableType, &
                & FIELD_PREVIOUS2_VALUES_SET_TYPE,previous2RHSParameters,err,error,*999)
              IF(dynamicSolver%degree>=SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                NULLIFY(previousAccelerationVector)
                CALL Field_ParameterSetDataGet(dependentField,dynamicVariableType, &
                  FIELD_PREVIOUS_ACCELERATION_SET_TYPE,previousAccelerationVector,err,error,*999)
                NULLIFY(previous3RHSParameters)
                CALL Field_ParameterSetDataGet(dependentField,rhsVariableType, &
                  & FIELD_PREVIOUS3_VALUES_SET_TYPE,previous3RHSParameters,err,error,*999)
              ENDIF
            ENDIF
            NULLIFY(rhsVector)
            CALL EquationsMatricesVector_RHSVectorGet(vectorMatrices,rhsVector,err,error,*999)
            equationsRHSVector=>rhsVector%vector
            !Loop over the rows in the equations set
            DO equationsRowNumber=1,vectorMapping%totalNumberOfRows
              rhsVariableDOF=rhsMapping%equationsRowToRHSDofMap(equationsRowNumber)
              !Get the dynamic contribution to the RHS values               
              IF(ASSOCIATED(dynamicTempVector)) THEN
                CALL DistributedVector_ValuesGet(dynamicTempVector,equationsRowNumber,dynamicValue,err,error,*999)
              ELSE
                dynamicValue=0.0_DP
              ENDIF
              !Get the linear matrices contribution to the RHS values if there are any
              IF(ASSOCIATED(linearMapping)) THEN
                linearValueSum=0.0_DP
                DO equationsMatrixIdx=1,linearMatrices%numberOfLinearMatrices
                  linearMatrix=>linearMatrices%matrices(equationsMatrixIdx)%ptr
                  linearTempVector=>linearMatrix%tempVector
                  CALL DistributedVector_ValuesGet(linearTempVector,equationsRowNumber,linearValue,err,error,*999)
                  linearValueSum=linearValueSum+linearValue
                ENDDO !equationsMatrixIdx
                linearValue=linearValueSum
              ELSE
                linearValue=0.0_DP
              ENDIF
              !Get the source vector contribute to the RHS values if there are any
              IF(ASSOCIATED(sourceMapping)) THEN
                !Add in equations source values
                CALL DistributedVector_ValuesGet(distributedSourceVector,equationsRowNumber,sourceValue,err,error,*999)
              ELSE
                sourceValue=0.0_DP
              ENDIF
              !Get the nonlinear vector contribute to the RHS values if nonlinear solve
              IF(solver%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN 
                nonlinearMapping=>vectorMapping%nonlinearMapping
                IF(ASSOCIATED(nonlinearMapping)) THEN
                  residualVariableDOF=nonlinearMapping%equationsRowToResidualDOFMap(equationsRowNumber)
                  nonlinearValue=previousResidualParameters(residualVariableDOF)*previousFunctionFactor
                  IF(dynamicSolver%degree>=SOLVER_DYNAMIC_SECOND_DEGREE) THEN
                    nonlinearValue=nonlinearValue+previous2ResidualParameters(residualVariableDOF)*previous2FunctionFactor
                    IF(dynamicSolver%degree>=SOLVER_DYNAMIC_THIRD_DEGREE) &
                      & nonlinearValue=nonlinearValue+previous3ResidualParameters(residualVariableDOF)*previous3FunctionFactor
                  ENDIF
                ELSE
                  nonlinearValue=0.0_DP
                ENDIF
              ELSE
                nonlinearValue=0.0_DP
              ENDIF
              !Loop over the solver rows associated with this equations set row
              DO solverRowIdx=1,solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)%NUMBER_OF_SOLVER_ROWS
                solverRowNumber=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                  & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)%SOLVER_ROWS( &
                  & solverRowIdx)
                rowCouplingCoefficient=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP( &
                  & equationsSetIdx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)% &
                  & COUPLING_COEFFICIENTS(solverRowIdx)
                rhsValue=-1.0_DP*(dynamicValue+linearValue+sourceValue+nonlinearValue)*rowCouplingCoefficient
                CALL DistributedVector_ValuesAdd(solverRHSVector,solverRowNumber,rhsValue,err,error,*999)
              ENDDO !solverRowIdx
              IF(hasIntegratedValues) THEN
                !Add any Neumann integrated values, b = f + N q
                CALL DistributedVector_ValuesAdd(equationsRHSVector,equationsRowNumber, &
                  & rhsIntegratedParameters(rhsVariableDOF),err,error,*999)
              ENDIF
            ENDDO !equationsRowNumber

            DO equationsRowNumber=1,vectorMapping%totalNumberOfRows
              !Get the dynamic contribution to the the RHS values
              rhsVariableDOF=rhsMapping%equationsRowToRHSDofMap(equationsRowNumber)
              rhsGlobalDOF=rhsDomainMapping%LOCAL_TO_GLOBAL_MAP(rhsVariableDOF)
              rhsBoundaryCondition=rhsBoundaryConditions%DOF_TYPES(rhsGlobalDOF)
              !Apply boundary conditions
              SELECT CASE(rhsBoundaryCondition)
              CASE(BOUNDARY_CONDITION_DOF_FREE)
                !Get the equations RHS values
                CALL DistributedVector_ValuesGet(equationsRHSVector,equationsRowNumber,rhsValue,err,error,*999)
                rhsValue=rhsValue+rhsParameters(rhsVariableDOF)*currentFunctionFactor
                rhsValue=rhsValue+previousRHSParameters(rhsVariableDOF)*previousFunctionFactor
                IF(dynamicSolver%degree>=SOLVER_DYNAMIC_SECOND_DEGREE) THEN
                  rhsValue=rhsValue+previous2RHSParameters(rhsVariableDOF)*previous2FunctionFactor
                  IF(dynamicSolver%degree>=SOLVER_DYNAMIC_THIRD_DEGREE) &
                    & rhsValue=rhsValue+previous3RHSParameters(rhsVariableDOF)*previous3FunctionFactor                    
                ENDIF
                !Loop over the solver rows associated with this equations set row
                DO solverRowIdx=1,solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                  & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)%NUMBER_OF_SOLVER_ROWS
                  solverRowNumber=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                    & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)%SOLVER_ROWS( &
                    & solverRowIdx)
                  rowCouplingCoefficient=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP( &
                    & equationsSetIdx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)% &
                    & COUPLING_COEFFICIENTS(solverRowIdx)
                  VALUE=rhsValue*rowCouplingCoefficient
                  CALL DistributedVector_ValuesAdd(solverRHSVector,solverRowNumber,VALUE, &
                    & err,error,*999)
                ENDDO !solverRowIdx
                !Note: for cases in which the boundary condition does not change with time then alpha will be
                !      implicitly zero and the contribution to the RHS will have been included above with the dynamic value.
                !      However, for cases in which the boundary condition is changing we need to compute the corresponding
                !      alpha value and include it on the RHS. This alpha value also needs to be set for nolinear problems as
                !      it will not have come from the nonlinear solver as A.alpha is included in the residual below. 
                variableType=dynamicMapping%dynamicVariableType
                dependentVariable=>dynamicMapping%varToEquationsMatricesMaps(variableType)%variable
                dependentVariableType=dependentVariable%VARIABLE_TYPE
                variableDomainMapping=>dependentVariable%DOMAIN_MAPPING
                CALL BOUNDARY_CONDITIONS_VARIABLE_GET(boundaryConditions,dependentVariable, &
                  & dependentBoundaryConditions,err,error,*999)
                variableDOF=dynamicMapping%equationsRowToVariableDOFMaps(equationsRowNumber)
                variableGlobalDOF=variableDomainMapping%LOCAL_TO_GLOBAL_MAP(variableDOF)
                variableBoundaryCondition=dependentBoundaryConditions%DOF_TYPES(variableGlobalDOF)

                IF(variableBoundaryCondition==BOUNDARY_CONDITION_DOF_FIXED) THEN
                  SELECT CASE(dynamicSolver%DEGREE)
                  CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
                    alphaValue=(currentValuesVector(variableDOF)-previousValuesVector(variableDOF))/ &
                      & dynamicDisplacementFactor
                  CASE(SOLVER_DYNAMIC_SECOND_DEGREE)
                    alphaValue=(currentValuesVector(variableDOF)- &
                      & previousValuesVector(variableDOF)- &
                      & dynamicVelocityFactor*previousVelocityVector(variableDOF))/ &
                      & dynamicDisplacementFactor
                  CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
                    alphaValue=(currentValuesVector(variableDOF)- &
                      & previousValuesVector(variableDOF)- &
                      & dynamicVelocityFactor*previousVelocityVector(variableDOF) - &
                      & dynamicAccelerationFactor*previousAccelerationVector(variableDOF))/ &
                      & dynamicDisplacementFactor
                  CASE DEFAULT
                    localError="The dynamic solver degree of "// &
                      & TRIM(NumberToVString(dynamicSolver%degree,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT

                  !Update the incremented values for non-linear problems
                  IF(ASSOCIATED(nonlinearMapping)) &
                    & CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                    & FIELD_INCREMENTAL_VALUES_SET_TYPE,variableDOF,alphavalue,err,error,*999)

                  IF(ABS(alphaValue)>=ZERO_TOLERANCE) THEN
                    DO equationsMatrixIdx=1,dynamicMapping%varToEquationsMatricesMaps(variableType)% &
                      & numberOfEquationsMatrices
                      equationsMatrixNumber=dynamicMapping%varToEquationsMatricesMaps(variableType)% &
                        & equationsMatrixNumbers(equationsMatrixIdx)
                      IF(equationsMatrixNumber==dynamicMapping%stiffnessMatrixNumber) &
                        & alphaValue=alphaValue*stiffnessMatrixCoefficient                        
                      IF(equationsMatrixNumber==dynamicMapping%dampingMatrixNumber) &
                        & alphaValue=alphaValue*dampingMatrixCoefficient                     
                      IF(equationsMatrixNumber==dynamicMapping%massMatrixNumber) &
                        & alphaValue=alphaValue*massMatrixCoefficient
                      equationsMatrix=>dynamicMatrices%matrices(equationsMatrixNumber)%ptr
                      equationsColumnNumber=dynamicMapping% &
                        & varToEquationsMatricesMaps(variableType)% &
                        & dofToColumnsMaps(equationsMatrixIdx)% &
                        & columnDOF(variableDOF)
                      IF(ASSOCIATED(dependentBoundaryConditions%DIRICHLET_BOUNDARY_CONDITIONS)) &
                        & CALL FlagError("Dirichlet boundary conditions is not associated.",err,error,*999)  
                      IF(dependentBoundaryConditions%NUMBER_OF_DIRICHLET_CONDITIONS>0) THEN
                        DO dirichletIdx=1,dependentBoundaryConditions%NUMBER_OF_DIRICHLET_CONDITIONS
                          IF(dependentBoundaryConditions%DIRICHLET_BOUNDARY_CONDITIONS% &
                            & DIRICHLET_DOF_INDICES(dirichletIdx)==equationsColumnNumber) EXIT
                        ENDDO !dirichletIdx
                        SELECT CASE(equationsMatrix%storageType)
                        CASE(DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE)
                          DO dirichletRow=1,vectorMatrices%totalNumberOfRows
                            CALL DistributedMatrix_ValuesGet(equationsMatrix%matrix,dirichletRow,equationsColumnNumber, &
                              & matrixValue,err,error,*999)
                            IF(ABS(matrixValue)>=ZERO_TOLERANCE) THEN
                              DO solverRowIdx=1,solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% & 
                                & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichletRow)%NUMBER_OF_SOLVER_ROWS
                                solverRowNumber=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                                  & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichletRow)%SOLVER_ROWS(solverRowIdx)
                                rowCouplingCoefficient=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                                  & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichletRow)%COUPLING_COEFFICIENTS(solverRowIdx)
                                VALUE=-1.0_DP*matrixValue*alphaValue*rowCouplingCoefficient
                                CALL DistributedVector_ValuesAdd(solverRHSVector,solverRowNumber,VALUE,err,error,*999)
                              ENDDO !solverRowIdx
                            ENDIF
                          ENDDO !dirichletRow
                        CASE(DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE)
                          dirichletRow=equationsColumnNumber
                          CALL DistributedMatrix_ValuesGet(equationsMatrix%matrix,dirichletRow,equationsColumnNumber, &
                            & matrixValue,err,error,*999)
                          IF(ABS(matrixValue)>=ZERO_TOLERANCE) THEN
                            DO solverRowIdx=1,solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% & 
                              & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichletRow)%NUMBER_OF_SOLVER_ROWS
                              solverRowNumber=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                                & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichletRow)%SOLVER_ROWS(solverRowIdx)
                              rowCouplingCoefficient=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                                & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichletRow)%COUPLING_COEFFICIENTS(solverRowIdx)
                              VALUE=-1.0_DP*matrixValue*alphaValue*rowCouplingCoefficient
                              CALL DistributedVector_ValuesAdd(solverRHSVector,solverRowNumber,VALUE,err,error,*999)
                            ENDDO !solverRowIdx
                          ENDIF
                        CASE(DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE)
                          CALL FlagError("Not implemented.",err,error,*999)
                        CASE(DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE)
                          CALL FlagError("Not implemented.",err,error,*999)
                        CASE(DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE)
                          sparsityIndices=>dependentBoundaryConditions%DIRICHLET_BOUNDARY_CONDITIONS% &
                            & DYNAMIC_SPARSITY_INDICES(equationsSetIdx,equationsMatrixIdx)%ptr
                          IF(ASSOCIATED(sparsityIndices)) THEN
                            DO equationsRowNumber2=sparsityIndices%SPARSE_COLUMN_INDICES(dirichletIdx), &
                              & sparsityIndices%SPARSE_COLUMN_INDICES(dirichletIdx+1)-1
                              dirichletRow=sparsityIndices%SPARSE_ROW_INDICES(equationsRowNumber2)
                              CALL DistributedMatrix_ValuesGet(equationsMatrix%matrix,dirichletRow,equationsColumnNumber, &
                                & matrixValue,err,error,*999)
                              IF(ABS(matrixValue)>=ZERO_TOLERANCE) THEN
                                DO solverRowIdx=1,solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% & 
                                  & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichletRow)%NUMBER_OF_SOLVER_ROWS
                                  solverRowNumber=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                                    & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichletRow)%SOLVER_ROWS(solverRowIdx)
                                  rowCouplingCoefficient=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                                    & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichletRow)%COUPLING_COEFFICIENTS(solverRowIdx)
                                  VALUE=-1.0_DP*matrixValue*alphaValue*rowCouplingCoefficient
                                  CALL DistributedVector_ValuesAdd(solverRHSVector,solverRowNumber,VALUE,err,error,*999)
                                ENDDO !solverRowIdx
                              ENDIF
                            ENDDO !equationsRowNumber2
                          ELSE
                            CALL FlagError("Sparsity indices are not associated.",err,error,*999)
                          ENDIF
                        CASE(DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE)
                          CALL FlagError("Not implemented.",err,error,*999)
                        CASE(DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE)
                          CALL FlagError("Not implemented.",err,error,*999)
                        CASE DEFAULT
                          localError="The storage type of "//TRIM(NumberToVString(equationsMatrix%storageType,"*", &
                            & err,error))//" is invalid."
                          CALL FlagError(localError,err,error,*999)
                        END SELECT
                      ENDIF
                    ENDDO !matrix_idx
                  ENDIF
                ENDIF

              CASE(BOUNDARY_CONDITION_DOF_FIXED)
                !Set Neumann boundary conditions

!!TODO: There is a bit of a disconnect with vectors and fields. At the moment for the RHS the f vector is sort of the same
!!as the rhs field variable that is mapped to it. And thus getting the rhs value from the distributed RHS vector is the same
!!as getting the value from the field parameters set vector. In reality the RHS f vector is a function of the RHS field variable
!!and it is not really the same thing. For a lot of things the "function" is an identity matrix or function but this should
!!not be assumed. Now this affects how things get handled with time. We want to vary the RHS field dofs with time and this
!!is taken into account by using the previousFunctionFactors below. However, we really should be multiplying the value of the
!!previous f vector by the previousFunctionFactor and not the previous values of the field variable mapped to the f vector.
!!This will mean keeping the previous values of the vectors as well as the previous values of the field DOFs. This also
!!greatly affects how time varying sources are handled! Maybe this is handled with LHS mapping as any matrix/vector that is
!!not mapped to the solver variables is automatically put on the RHS? Sources (and RHS?) will thus be like any other matrix-vector?
!!Might handle things like Neumann point fluxes and or linear matrices for linear operations on source fields?

                CALL DistributedVector_ValuesGet(equationsRHSVector,equationsRowNumber,rhsValue,err,error,*999)
                rhsValue=rhsValue+rhsParameters(rhsVariableDOF)*currentFunctionFactor
                rhsValue=rhsValue+previousRHSParameters(rhsVariableDOF)*previousFunctionFactor
                IF(dynamicSolver%degree>=SOLVER_DYNAMIC_SECOND_DEGREE) THEN
                  rhsValue=rhsValue+previous2RHSParameters(rhsVariableDOF)*previous2FunctionFactor
                  IF(dynamicSolver%degree>=SOLVER_DYNAMIC_THIRD_DEGREE) &
                    & rhsValue=rhsValue+previous3RHSParameters(rhsVariableDOF)*previous3FunctionFactor                    
                ENDIF
                !Loop over the solver rows associated with this equations set row
                DO solverRowIdx=1,solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                  & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)%NUMBER_OF_SOLVER_ROWS
                  solverRowNumber=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                    & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)%SOLVER_ROWS( &
                    & solverRowIdx)
                  rowCouplingCoefficient=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP( &
                    & equationsSetIdx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)% &
                    & COUPLING_COEFFICIENTS(solverRowIdx)
                  VALUE=rhsValue*rowCouplingCoefficient
                  CALL DistributedVector_ValuesAdd(solverRHSVector,solverRowNumber,VALUE,err,error,*999)
                ENDDO !solverRowIdx
              CASE(BOUNDARY_CONDITION_DOF_MIXED)
                !Set Robin or is it Cauchy??? boundary conditions
                CALL FlagError("Mixed Boundary Conditions Not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The RHS boundary condition of "// &
                  & TRIM(NumberToVString(rhsBoundaryCondition,"*",err,error))// &
                  & " for RHS variable dof number "// &
                  & TRIM(NumberToVString(rhsVariableDOF,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
              IF(.NOT.dynamicSolver%SOLVER_INITIALISED) THEN
                !Copy current RHS i.e., RHS at time zero, to previous RHSs to initialise
                !Get the equations RHS contribution
                CALL DistributedVector_ValuesGet(equationsRHSVector,equationsRowNumber,rhsValue,err,error,*999)
                CALL Field_ParameterSetUpdateLocalDOF(dependentField,rhsVariableType, &
                  & FIELD_PREVIOUS_VALUES_SET_TYPE,rhsVariableDOF,rhsValue,err,error,*999)
                IF(dynamicSolver%degree>SOLVER_DYNAMIC_FIRST_DEGREE) THEN
                  CALL Field_ParameterSetUpdateLocalDOF(dependentField,rhsVariableType, &
                    & FIELD_PREVIOUS2_VALUES_SET_TYPE,rhsVariableDOF,rhsValue,err,error,*999)
                  IF(dynamicSolver%degree>SOLVER_DYNAMIC_SECOND_DEGREE) THEN
                    CALL Field_ParameterSetUpdateLocalDOF(dependentField,rhsVariableType, &
                      & FIELD_PREVIOUS3_VALUES_SET_TYPE,rhsVariableDOF,rhsValue,err,error,*999)
                  ENDIF
                ENDIF
              ENDIF
            ENDDO !equationsRowNumber
            IF(ASSOCIATED(nonlinearMapping)) &
              & CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_INCREMENTAL_VALUES_SET_TYPE, &
              & err,error,*999)
            CALL Field_ParameterSetDataRestore(dependentField,dynamicVariableType, &
              & FIELD_PREVIOUS_VALUES_SET_TYPE,previousValuesVector,err,error,*999)
            CALL Field_ParameterSetDataRestore(dependentField,rhsVariableType, &
              & FIELD_VALUES_SET_TYPE,rhsParameters,err,error,*999)
            CALL Field_ParameterSetDataRestore(dependentField,rhsVariableType, &
              & FIELD_PREVIOUS_VALUES_SET_TYPE,previousRHSParameters,err,error,*999)
            IF(hasIntegratedValues) THEN
              CALL Field_ParameterSetDataRestore(dependentField,rhsVariableType, &
                & FIELD_INTEGRATED_NEUMANN_SET_TYPE,rhsIntegratedParameters,err,error,*999)                
            ENDIF
            IF(dynamicSolver%degree>=SOLVER_DYNAMIC_SECOND_DEGREE) THEN
              CALL Field_ParameterSetDataRestore(dependentField,dynamicVariableType, &
                FIELD_PREVIOUS_VELOCITY_SET_TYPE,previousVelocityVector,err,error,*999)
              CALL Field_ParameterSetDataRestore(dependentField,rhsVariableType, &
                & FIELD_PREVIOUS2_VALUES_SET_TYPE,previous2RHSParameters,err,error,*999)                
              IF(dynamicSolver%degree>=SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                CALL Field_ParameterSetDataRestore(dependentField,dynamicVariableType, &
                  FIELD_PREVIOUS_ACCELERATION_SET_TYPE,previousAccelerationVector,err,error,*999)
                CALL Field_ParameterSetDataRestore(dependentField,rhsVariableType, &
                  & FIELD_PREVIOUS3_VALUES_SET_TYPE,previous3RHSParameters,err,error,*999)
              ENDIF
            ENDIF
            IF(ASSOCIATED(nonlinearMapping)) &
              & CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_INCREMENTAL_VALUES_SET_TYPE, &
              & err,error,*999)
          ENDIF
        ENDDO !equationsSetIdx
        !Add in any rows from any interface conditions
        DO interfaceConditionIdx=1,solverMapping%NUMBER_OF_INTERFACE_CONDITIONS
          NULLIFY(interfaceCondition)
          CALL SolverMapping_InterfaceConditionGet(solverMapping,interfaceConditionIdx,interfaceCondition,err,error,*999)
          SELECT CASE(interfaceCondition%METHOD)
          CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,INTERFACE_CONDITION_PENALTY_METHOD)
            NULLIFY(interfaceEquations)
            CALL InterfaceCondition_EquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
            NULLIFY(interfaceMapping)
            CALL InterfaceEquations_InterfaceMappingGet(interfaceEquations,interfaceMapping,err,error,*999)
            NULLIFY(interfaceMatrices)
            CALL InterfaceEquations_InterfaceMatricesGet(interfaceEquations,interfaceMatrices,err,error,*999)
            interfaceLagrange=>interfaceCondition%LAGRANGE
            IF(ASSOCIATED(interfaceLagrange)) THEN
              lagrangeField=>interfaceLagrange%LAGRANGE_FIELD
              IF(ASSOCIATED(lagrangeField)) THEN
                interfaceRHSMapping=>interfaceMapping%RHS_MAPPING
                IF(ASSOCIATED(interfaceRHSMapping)) THEN
                  interfaceRHSVector=>interfaceMatrices%RHS_VECTOR
                  IF(ASSOCIATED(interfaceRHSVector)) THEN
                    !Worry about BCs on the Lagrange variables later.
                    DO interfaceColumnNumber=1,interfaceMapping%TOTAL_NUMBER_OF_COLUMNS
                      CALL DistributedVector_ValuesGet(interfaceRHSVector%RHS_VECTOR, &
                        & interfaceColumnNumber,rhsValue,err,error,*999)
                      !Loop over the solver rows this interface column is mapped to
                      DO solverRowIdx=1,solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP( &
                        & interfaceConditionIdx)%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS( &
                        & interfaceColumnNumber)%NUMBER_OF_SOLVER_ROWS
                        solverRowNumber=solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP( &
                          & interfaceConditionIdx)%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS( &
                          & interfaceColumnNumber)%SOLVER_ROW
                        rowCouplingCoefficient=solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP( &
                          & interfaceConditionIdx)%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS( &
                          & interfaceColumnNumber)%COUPLING_COEFFICIENT
                        VALUE=rhsValue*rowCouplingCoefficient
                        CALL DistributedVector_ValuesAdd(solverRHSVector,solverRowNumber,VALUE, &
                          & err,error,*999)
                      ENDDO !solverRowIdx
                    ENDDO !interface_column_idx
                  ELSE
                    CALL FlagError("Interface matrices RHS vector is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Interface mapping RHS mapping is not associated.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Interface Lagrange field is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Interface Lagrange is not associated.",err,error,*999)
            ENDIF
          CASE(INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(INTERFACE_CONDITION_POINT_TO_POINT_METHOD)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE DEFAULT
            localError="The interface condition method of "// &
              & TRIM(NumberToVString(interfaceCondition%METHOD,"*",err,error))// &
              & " is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ENDDO !interfaceConditionIdx
        !        
        !Start the update the solver RHS vector values
        CALL DistributedVector_UpdateStart(solverRHSVector,err,error,*999)
        CALL DistributedVector_UpdateFinish(solverRHSVector,err,error,*999)

        NULLIFY(checkData)
        CALL DistributedVector_DataGet(solverRHSVector,checkData,err,error,*999)

      ENDIF
      IF(solver%outputType>=SOLVER_TIMING_OUTPUT) THEN
        CALL CPUTimer(USER_CPU,userTime2,err,error,*999)
        CALL CPUTimer(SYSTEM_CPU,systemTime2,err,error,*999)
        userElapsed=userTime2(1)-userTime1(1)
        systemElapsed=systemTime2(1)-systemTime1(1)
        IF(solver%outputType>=SOLVER_MATRIX_OUTPUT) &
          & CALL Profiling_TimingsOutput(0,"",userElapsed,systemElapsed,err,error,*999)
        CALL Profiling_TimingsOutput(1,"Solver RHS assembly",userElapsed,systemElapsed,err,error,*999)
      ENDIF
    ENDIF

    NULLIFY(solverResidualVector)
    IF(selectionType==SOLVER_MATRICES_ALL.OR. &
      & selectionType==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
      & selectionType==SOLVER_MATRICES_RESIDUAL_ONLY.OR. &
      & selectionType==SOLVER_MATRICES_LINEAR_RESIDUAL_ONLY.OR. &
      & selectionType==SOLVER_MATRICES_RHS_RESIDUAL_ONLY) THEN
      
      !Assemble residual vector
      IF(solver%outputType>=SOLVER_TIMING_OUTPUT) THEN
        CALL CPUTimer(USER_CPU,userTime1,err,error,*999)
        CALL CPUTimer(SYSTEM_CPU,systemTime1,err,error,*999)
      ENDIF
      IF(solverMatrices%UPDATE_RESIDUAL) THEN
        solverResidualVector=>solverMatrices%RESIDUAL
        IF(ASSOCIATED(solverResidualVector)) THEN
          !Initialise the residual to zero
          CALL DistributedVector_AllValuesSet(solverResidualVector,0.0_DP,err,error,*999)
          !Get the solver variables data
          NULLIFY(solverResidualData)
          CALL DistributedVector_DataGet(solverResidualVector,solverResidualData,err,error,*999)
          NULLIFY(checkData)
          CALL DistributedVector_DataGet(solverResidualVector,checkData,err,error,*999)
          !Loop over the equations sets
          DO equationsSetIdx=1,solverMapping%NUMBER_OF_EQUATIONS_SETS
            NULLIFY(equationsSet)
            CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
            NULLIFY(dependentField)
            CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
            NULLIFY(equations)
            CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
            NULLIFY(vectorEquations)
            CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
            NULLIFY(vectorMatrices)
            CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
            NULLIFY(vectorMapping)
            CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
            NULLIFY(dynamicMapping)               
            dynamicMapping=>vectorMapping%dynamicMapping
            IF(ASSOCIATED(dynamicMapping)) THEN
              dynamicVariableType=dynamicMapping%dynamicVariableType
              !Calculate the dynamic contributions
              NULLIFY(dynamicVariable)
              CALL EquationsMappingDynamic_DynamicVariableGet(dynamicMapping,dynamicVariable,err,error,*999)
              NULLIFY(dynamicMatrices)
              CALL EquationsMatricesVector_DynamicMatricesGet(vectorMatrices,dynamicMatrices,err,error,*999)
              dynamicTempVector=>dynamicMatrices%tempVector
              !Initialise the dynamic temporary vector to zero
              CALL DistributedVector_AllValuesSet(dynamicTempVector,0.0_DP,err,error,*999)
              NULLIFY(incrementalVector)
              !Define the pointer to the incrementalVector
              CALL Field_ParameterSetVectorGet(dependentField,dynamicVariableType, &
                & FIELD_INCREMENTAL_VALUES_SET_TYPE,incrementalVector,err,error,*999)
              IF(dynamicMapping%stiffnessMatrixNumber/=0) THEN
                NULLIFY(stiffnessMatrix)
                CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,dynamicMapping%stiffnessMatrixNumber, &
                  & stiffnessMatrix,err,error,*999)
                CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE, & 
                  & stiffnessMatrixCoefficient,stiffnessMatrix%matrix,incrementalVector, & 
                  & dynamicTempVector,err,error,*999)
              ENDIF
              IF(dynamicMapping%dampingMatrixNumber/=0.AND. &
                & dynamicSolver%DEGREE>=SOLVER_DYNAMIC_FIRST_DEGREE) THEN
                NULLIFY(dampingMatrix)
                CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,dynamicMapping%dampingMatrixNumber, &
                  & dampingMatrix,err,error,*999)
                CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE, &
                  & dampingMatrixCoefficient,dampingMatrix%matrix,incrementalVector, & 
                  & dynamicTempVector,err,error,*999)
              ENDIF
              IF(dynamicMapping%massMatrixNumber/=0.AND. &
                & dynamicSolver%DEGREE>=SOLVER_DYNAMIC_SECOND_DEGREE) THEN
                NULLIFY(massMatrix)
                CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,dynamicMapping%massMatrixNumber, &
                  & massMatrix,err,error,*999)
                CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE, &
                  & massMatrixCoefficient,massMatrix%MATRIX,incrementalVector, & 
                  & dynamicTempVector,err,error,*999)
              ENDIF
            ENDIF
            !Calculate the contributions from any linear matrices
!!TODO: This should only be for matrices that are mapped to the dynamic variable?
            linearMapping=>vectorMapping%linearMapping
            IF(ASSOCIATED(linearMapping)) THEN
              NULLIFY(linearMatrices)
              CALL EquationsMatricesVector_LinearMatricesGet(vectorMatrices,linearMatrices,err,error,*999)
              DO equationsMatrixIdx=1,linearMatrices%numberOfLinearMatrices
                NULLIFY(linearMatrix)
                CALL EquationsMatricesLinear_EquationsMatrixGet(linearMatrices,equationsMatrixIdx,linearMatrix,err,error,*999)
                linearVariableType=linearMapping%equationsMatrixToVarMaps(equationsMatrixIdx)%variableType
                linearVariable=>linearMapping%equationsMatrixToVarMaps(equationsMatrixIdx)%variable
                IF(ASSOCIATED(linearVariable)) THEN
                  linearTempVector=>linearMatrix%tempVector
                  !Initialise the linear temporary vector to zero
                  CALL DistributedVector_AllValuesSet(linearTempVector,0.0_DP,err,error,*999)
                  NULLIFY(dependentVector)
                  CALL Field_ParameterSetVectorGet(dependentField,linearVariableType, &
                    & FIELD_VALUES_SET_TYPE,dependentVector,err,error,*999)
                  CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE, &
                    & 1.0_DP,linearMatrix%MATRIX,dependentVector,linearTempVector,err,error,*999)
                ELSE
                  CALL FlagError("Linear variable is not associated.",err,error,*999)
                ENDIF
              ENDDO !equationsMatrixIdx
            ENDIF
            !Calculate the solver residual
            nonlinearMapping=>vectorMapping%nonlinearMapping
            IF(ASSOCIATED(nonlinearMapping)) THEN
              NULLIFY(nonlinearMatrices)
              CALL EquationsMatricesVector_NonlinearMatricesGet(vectorMatrices,nonlinearMatrices,err,error,*999)
              residualVector=>nonlinearMatrices%residual
              !Loop over the rows in the equations set
              DO equationsRowNumber=1,vectorMapping%totalNumberOfRows
                IF(solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                  & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)% &
                  & NUMBER_OF_SOLVER_ROWS>0) THEN
                  !Get the equations residual contribution
                  CALL DistributedVector_ValuesGet(residualVector,equationsRowNumber,residualValue,err,error,*999)
                  residualValue=residualValue*currentFunctionFactor
                  !Get the linear matrices contribution to the RHS values if there are any.
!!TODO: this should only be for linear matrices mapped to the dynamic variable???
                  IF(ASSOCIATED(linearMapping)) THEN
                    linearValueSum=0.0_DP
                    DO equationsMatrixIdx2=1,linearMatrices%numberOfLinearMatrices
                      linearMatrix=>linearMatrices%matrices(equationsMatrixIdx2)%ptr
                      linearTempVector=>linearMatrix%tempVector
                      CALL DistributedVector_ValuesGet(linearTempVector,equationsRowNumber,linearValue,err,error,*999)
                      linearValueSum=linearValueSum+linearValue
                    ENDDO !equationsMatrixIdx2
                    residualValue=residualValue+linearValueSum
                  ENDIF
                  IF(ASSOCIATED(dynamicMapping)) THEN
                    !Get the dynamic contribution to the residual values
                    CALL DistributedVector_ValuesGet(dynamicTempVector,equationsRowNumber,dynamicValue,err,error,*999)
                    residualValue=residualValue+dynamicValue
                  ENDIF
                  !Loop over the solver rows associated with this equations set residual row
                  DO solverRowIdx=1,solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                    & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)%NUMBER_OF_SOLVER_ROWS
                    solverRowNumber=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
                      & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)%SOLVER_ROWS(solverRowIdx)
                    rowCouplingCoefficient=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP( &
                      & equationsSetIdx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equationsRowNumber)% &
                      & COUPLING_COEFFICIENTS(solverRowIdx)
                    VALUE=residualValue*rowCouplingCoefficient
                    !Add in nonlinear residual values
                    CALL DistributedVector_ValuesAdd(solverResidualVector,solverRowNumber,VALUE,err,error,*999)
                  ENDDO !solverRowIdx
                ENDIF
                IF(.NOT.dynamicSolver%SOLVER_INITIALISED) THEN
                  !Copy current residual i.e., residual at time zero, to previous residuals to initialise
                  !Get the equations residual contribution
                  CALL DistributedVector_ValuesGet(residualVector,equationsRowNumber,residualValue,err,error,*999)
                  variableDOF=dynamicMapping%equationsRowToVariableDOFMaps(equationsRowNumber)
                  CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                    & FIELD_PREVIOUS_RESIDUAL_SET_TYPE,variableDOF,residualValue,err,error,*999)
                  IF(dynamicSolver%degree>SOLVER_DYNAMIC_FIRST_DEGREE) THEN
                    CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                      & FIELD_PREVIOUS2_RESIDUAL_SET_TYPE,variableDOF,residualValue,err,error,*999)
                    IF(dynamicSolver%degree>SOLVER_DYNAMIC_SECOND_DEGREE) THEN
                      CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                        & FIELD_PREVIOUS3_RESIDUAL_SET_TYPE,variableDOF,residualValue,err,error,*999)
                    ENDIF
                  ENDIF
                ENDIF
              ENDDO !equationsRowNumber
            ENDIF
          ENDDO !equationsSetIdx

          !Loop over the interface conditions
          DO interfaceConditionIdx=1,solverMapping%NUMBER_OF_INTERFACE_CONDITIONS
            NULLIFY(interfaceCondition)
            CALL SolverMapping_InterfaceConditionGet(solverMapping,interfaceConditionIdx,interfaceCondition,err,error,*999)
            NULLIFY(interfaceEquations)
            CALL InterfaceCondition_EquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
            NULLIFY(interfaceMapping)
            CALL InterfaceEquations_InterfaceMappingGet(interfaceEquations,interfaceMapping,err,error,*999)
            NULLIFY(interfaceMatrices)
            CALL InterfaceEquations_InterfaceMatricesGet(interfaceEquations,interfaceMatrices,err,error,*999)
            lagrangeField=>interfaceCondition%LAGRANGE%LAGRANGE_FIELD
            IF(ASSOCIATED(lagrangeField)) THEN
              SELECT CASE(interfaceCondition%method)
              CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD)
                numberOfInterfaceMatrices=interfaceMapping%NUMBER_OF_INTERFACE_MATRICES
              CASE(INTERFACE_CONDITION_PENALTY_METHOD)
                numberOfInterfaceMatrices=interfaceMapping%NUMBER_OF_INTERFACE_MATRICES-1
              END SELECT
              !Calculate the contributions from any interface matrices
              DO interfaceMatrixIdx=1,numberOfInterfaceMatrices
                !Calculate the interface matrix-Lagrange vector product residual contribution
                interfaceMatrix=>interfaceMatrices%matrices(interfaceMatrixIdx)%ptr
                IF(ASSOCIATED(interfaceMatrix)) THEN
                  interfaceVariableType=interfaceMapping%LAGRANGE_VARIABLE_TYPE
                  interfaceVariable=>interfaceMapping%LAGRANGE_VARIABLE
                  IF(ASSOCIATED(interfaceVariable)) THEN
                    interfaceTempVector=>interfaceMatrix%TEMP_VECTOR
                    !Initialise the linear temporary vector to zero
                    CALL DistributedVector_AllValuesSet(interfaceTempVector,0.0_DP,err,error,*999)
                    NULLIFY(lagrangeVector)
                    CALL Field_ParameterSetVectorGet(lagrangeField,interfaceVariableType, &
                      & FIELD_VALUES_SET_TYPE,lagrangeVector,err,error,*999)                      
                    SELECT CASE(interfaceMatrix%INTERFACE_MATRIX_TIME_DEPENDENCE_TYPE)
                    CASE(INTERFACE_MATRIX_STATIC)
                      matrixCoefficients(1)=stiffnessMatrixCoefficient
                    CASE(INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC)
                      matrixCoefficients(1)=dampingMatrixCoefficient
                    CASE DEFAULT
                      CALL FlagError("Not implemented.",Err,Error,*999)
                    END SELECT
                    IF(interfaceMatrix%HAS_TRANSPOSE) THEN
                      SELECT CASE(interfaceMatrix%INTERFACE_MATRIX_TRANSPOSE_TIME_DEPENDENCE_TYPE)
                      CASE(INTERFACE_MATRIX_STATIC)
                        matrixCoefficients(2)=stiffnessMatrixCoefficient
                      CASE(INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC)
                        matrixCoefficients(2)=dampingMatrixCoefficient
                      CASE DEFAULT
                        CALL FlagError("Not implemented.",Err,Error,*999)
                      END SELECT
                    ELSE
                      matrixCoefficients(2)=0.0_DP
                    ENDIF

                    CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE, &
                      & matrixCoefficients(1),interfaceMatrix%matrix,lagrangeVector,interfaceTempVector, &
                      & err,error,*999)

                    !Add interface matrix residual contribution to the solver residual
                    DO interfaceRowNumber=1,interfaceMatrix%NUMBER_OF_ROWS
                      IF(solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
                        & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interfaceMatrixIdx)% &
                        & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interfaceRowNumber)%NUMBER_OF_SOLVER_ROWS>0) THEN
                        !Loop over the solver rows associated with this interface residual row
                        !Currently earch interface matrix row has only one corresponding solver row number & coupling coefficient
                        solverRowNumber=solverMapping% & 
                          & INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interfaceMatrixIdx)% &
                          & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interfaceRowNumber)%SOLVER_ROW
                        rowCouplingCoefficient=solverMapping% &
                          & INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interfaceMatrixIdx)% &
                          & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interfaceRowNumber)%COUPLING_COEFFICIENT
                        CALL DistributedVector_ValuesGet(interfaceTempVector,interfaceRowNumber,residualValue,err,error,*999)
                        value=residualValue*rowCouplingCoefficient
                        !Add in nonlinear residual values
                        CALL DistributedVector_ValuesAdd(solverResidualVector,solverRowNumber,value,err,error,*999)
                      ENDIF
                    ENDDO !interfaceRowNumber
                  ELSE
                    CALL FlagError("Interface variable is not associated.",err,error,*999)
                  ENDIF
                  !Calculate the transposed interface matrix-dependent variable product residual contribution
                  dependentVariableType=interfaceMapping%INTERFACE_MATRIX_ROWS_TO_VAR_MAPS(interfaceMatrixIdx)%VARIABLE_TYPE
                  dependentVariable=>interfaceMapping%INTERFACE_MATRIX_ROWS_TO_VAR_MAPS(interfaceMatrixIdx)%VARIABLE
                  IF(ASSOCIATED(dependentVariable)) THEN
                    interfaceTempVector=>interfaceMatrix%TEMP_TRANSPOSE_VECTOR
                    !Initialise the linear temporary vector to zero
                    CALL DistributedVector_AllValuesSet(interfaceTempVector,0.0_DP,err,error,*999)
                    NULLIFY(dependentVector)
                    dependentField=>dependentVariable%field
                    !hard-coded for now TODO under the assumption that the first equations set is the solid
                    !equations set and the second equations set is the fluid equations set
                    !FSI only - needs to be extended/generalized for other coupled problems TODO
                    IF(interfaceMatrixIdx==1) THEN
                      CALL Field_ParameterSetVectorGet(dependentField,dependentVariableType, &
                        & FIELD_INCREMENTAL_VALUES_SET_TYPE,dependentVector,err,error,*999)
                    ELSE
                      CALL Field_ParameterSetVectorGet(dependentField,dependentVariableType, &
                        & FIELD_VALUES_SET_TYPE,dependentVector,err,error,*999)
                    ENDIF
                    CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE, &
                      & matrixCoefficients(2),interfaceMatrix%MATRIX_TRANSPOSE,dependentVector, &
                      & interfaceTempVector,err,error,*999)

                    !Add interface matrix residual contribution to the solver residual.
                    !The number of columns in the interface matrix is equivalent to the
                    !number of rows of the transposed interface matrices

                    DO interfaceRowNumber=1,interfaceMatrices%NUMBER_OF_COLUMNS
                      IF(solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
                        & INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS(interfaceRowNumber)%NUMBER_OF_SOLVER_ROWS>0) THEN
                        !Loop over the solver rows associated with this interface residual row
                        !Currently earch interface matrix row has only one corresponding solver row number & coupling coefficient
                        solverRowNumber=solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
                          & INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS(interfaceRowNumber)%SOLVER_ROW
                        rowCouplingCoefficient=solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
                          & INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS(interfaceRowNumber)%COUPLING_COEFFICIENT
                        CALL DistributedVector_ValuesGet(interfaceTempVector,interfaceRowNumber,residualValue,err,error,*999)
                        !   IF(interfaceMatrixIdx==1) THEN
                        !     VALUE=residualValue*rowCouplingCoefficient/deltaT
                        !   ELSE
                        VALUE=residualValue*rowCouplingCoefficient
                        !   ENDIF
                        !Add in nonlinear residual values
                        CALL DistributedVector_ValuesAdd(solverResidualVector,solverRowNumber,VALUE,err,error,*999)
                      ENDIF
                    ENDDO !interfaceRowNumber
                  ELSE
                    CALL FlagError("Dependent variable is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Interface matrix is not associated.",err,error,*999)
                ENDIF
              ENDDO !interfaceMatrixIdx
              SELECT CASE(interfaceCondition%METHOD)
              CASE(INTERFACE_CONDITION_PENALTY_METHOD)
                interfaceMatrixIdx=interfaceMapping%NUMBER_OF_INTERFACE_MATRICES
                !Calculate the Lagrange-Lagrange vector product residual contribution from the penalty term
                interfaceMatrix=>interfaceMatrices%matrices(interfaceMatrixIdx)%ptr
                IF(ASSOCIATED(interfaceMatrix)) THEN
                  interfaceVariableType=interfaceMapping%LAGRANGE_VARIABLE_TYPE
                  interfaceVariable=>interfaceMapping%LAGRANGE_VARIABLE
                  IF(ASSOCIATED(interfaceVariable)) THEN
                    interfaceTempVector=>interfaceMatrix%TEMP_VECTOR
                    !Initialise the linear temporary vector to zero
                    CALL DistributedVector_AllValuesSet(interfaceTempVector,0.0_DP,err,error,*999)
                    NULLIFY(lagrangeVector)
                    CALL Field_ParameterSetVectorGet(lagrangeField,interfaceVariableType, &
                      & FIELD_VALUES_SET_TYPE,lagrangeVector,err,error,*999)
                    CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE,1.0_DP, &
                      & interfaceMatrix%MATRIX,lagrangeVector,interfaceTempVector,err,error,*999)
                    !Add interface matrix residual contribution to the solver residual
                    DO interfaceRowNumber=1,interfaceMatrix%NUMBER_OF_ROWS
                      IF(solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
                        & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interfaceMatrixIdx)% &
                        & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interfaceRowNumber)%NUMBER_OF_SOLVER_ROWS>0) THEN
                        !Loop over the solver rows associated with this interface residual row
                        !Currently earch interface matrix row has only one corresponding solver
                        !row number & coupling coefficient
                        solverRowNumber=solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interfaceMatrixIdx)% &
                          & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interfaceRowNumber)%SOLVER_ROW
                        rowCouplingCoefficient=solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interfaceMatrixIdx)% &
                          & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interfaceRowNumber)%COUPLING_COEFFICIENT
                        CALL DistributedVector_ValuesGet(interfaceTempVector,interfaceRowNumber, &
                          & residualValue,err,error,*999)
                        VALUE=residualValue*rowCouplingCoefficient
                        !Add in nonlinear residual values
                        CALL DistributedVector_ValuesAdd(solverResidualVector,solverRowNumber,VALUE,err,error,*999)
                      ENDIF
                    ENDDO !interfaceRowNumber
                  ELSE
                    CALL FlagError("Interface variable is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  localError="Interface matrix is not associated for linear matrix number "// &
                    & TRIM(NumberToVString(equationsMatrixIdx,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              END SELECT
            ELSE
              CALL FlagError("Interface Lagrange field is not associated.",err,error,*999)
            ENDIF
          ENDDO !interfaceConditionIdx
          !
          !Start the update the solver residual vector values
          CALL DistributedVector_UpdateStart(solverResidualVector,err,error,*999)

          NULLIFY(checkData2)
          CALL DistributedVector_DataGet(solverResidualVector,checkData2,err,error,*999)

        ELSE
          CALL FlagError("The solver residual vector is not associated.",err,error,*999)
        ENDIF
      ENDIF
      IF(ASSOCIATED(solverResidualVector)) &
        & CALL DistributedVector_UpdateFinish(solverResidualVector,err,error,*999)
      IF(solver%outputType>=SOLVER_TIMING_OUTPUT) THEN
        CALL CPUTimer(USER_CPU,userTime2,err,error,*999)
        CALL CPUTimer(SYSTEM_CPU,systemTime2,err,error,*999)
        userElapsed=userTime2(1)-userTime1(1)
        systemElapsed=systemTime2(1)-systemTime1(1)
        IF(solver%outputType>=SOLVER_MATRIX_OUTPUT) &
          & CALL Profiling_TimingsOutput(0,"",userElapsed,systemElapsed,err,error,*999)
        CALL Profiling_TimingsOutput(1,"Solver residual assembly",userElapsed,systemElapsed,err,error,*999)
      ENDIF
    ENDIF

    IF(dynamicSolver%SOLVER_INITIALISED) THEN
      !Set the first part of the next time step. Note that we do not have to add in the previous time value as it is
      !already there from when we copied the values to the previous time step.
      !Loop over the equations sets
      IF(dynamicSolver%DEGREE>SOLVER_DYNAMIC_FIRST_DEGREE) THEN
        DO equationsSetIdx=1,solverMapping%NUMBER_OF_EQUATIONS_SETS
          NULLIFY(equationsSet)
          CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
          NULLIFY(dependentField)
          CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
          NULLIFY(equations)
          CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
          NULLIFY(vectorEquations)
          CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
          NULLIFY(vectorMapping)
          CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
          dynamicMapping=>vectorMapping%dynamicMapping
          IF(ASSOCIATED(dynamicMapping)) THEN
            dynamicVariableType=dynamicMapping%dynamicVariableType
            SELECT CASE(dynamicSolver%degree)
            CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
              !Do nothing. Increment will be added after the solve.
            CASE(SOLVER_DYNAMIC_SECOND_DEGREE)
              CALL FIELD_PARAMETER_SETS_ADD(dependentField,dynamicVariableType,firstUpdateFactor, &
                & FIELD_PREVIOUS_VELOCITY_SET_TYPE,FIELD_VALUES_SET_TYPE,err,error,*999)
            CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
              CALL FIELD_PARAMETER_SETS_ADD(dependentField,dynamicVariableType,[firstUpdateFactor, &
                & secondUpdateFactor],[FIELD_PREVIOUS_VELOCITY_SET_TYPE,FIELD_PREVIOUS_VALUES_SET_TYPE], &
                & FIELD_VALUES_SET_TYPE,err,error,*999)
              CALL FIELD_PARAMETER_SETS_ADD(dependentField,dynamicVariableType,firstUpdateFactor, &
                & FIELD_PREVIOUS_ACCELERATION_SET_TYPE,FIELD_VELOCITY_VALUES_SET_TYPE,err,error,*999)
            CASE DEFAULT
              localError="The dynamic solver degree of "// &
                & TRIM(NumberToVString(dynamicSolver%DEGREE,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ENDDO !equationsSetIdx
      ENDIF
    ENDIF
      
    !If required output the solver matrices
    IF(solver%outputType>=SOLVER_MATRIX_OUTPUT) THEN
      CALL SOLVER_MATRICES_OUTPUT(GENERAL_OUTPUT_TYPE,selectionType,solverMatrices,err,error,*999)
    ENDIF
    
    EXITS("Solver_DynamicAssemble")
    RETURN
999 ERRORSEXITS("Solver_DynamicAssemble",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_DynamicAssemble

  !
  !================================================================================================================================
  !

  !>Assembles the solver matrices and rhs from the static equations.
  SUBROUTINE Solver_StaticAssemble(SOLVER,SELECTION_TYPE,err,error,*)

    !Argument variable
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the solver
    INTEGER(INTG), INTENT(IN) :: SELECTION_TYPE !<The type of matrix selection \see SOLVER_MATRICES_ROUTINES_SelectMatricesTypes,SOLVER_MATRICES_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dependent_variable_type,interface_variable_type,equations_column_number,equations_matrix_idx, &
      & equationsMatrixNumber,interface_row_number,equations_row_number,equations_row_number2,equations_set_idx, & 
      & interface_column_number,interface_condition_idx,interface_matrix_idx,linearVariableType,rhs_boundary_condition, &
      & rhs_global_dof,equations_matrix_idx2,rhs_variable_dof,rhs_variable_type,variable_boundary_condition,solver_matrix_idx, &
      & solver_row_idx,solver_row_number,variable_dof,variable_global_dof,variable_idx,variable_type,&
      & dirichlet_idx,dirichlet_row,numberOfInterfaceMatrices
    REAL(SP) :: systemElapsed,SYSTEM_TIME1(1),SYSTEM_TIME2(1),userElapsed,USER_TIME1(1),USER_TIME2(1)
    REAL(DP) :: DEPENDENT_VALUE,LINEAR_VALUE,LINEAR_VALUE_SUM,MATRIX_VALUE,RESIDUAL_VALUE,rhsValue,rowCouplingCoefficient, &
      & sourceValue,VALUE,RHS_INTEGRATED_VALUE
    REAL(DP), POINTER :: RHS_PARAMETERS(:),CHECK_DATA(:),CHECK_DATA2(:),CHECK_DATA3(:),CHECK_DATA4(:)
    LOGICAL :: SUBTRACT_FIXED_BCS_FROM_RESIDUAL,HAS_INTEGRATED_VALUES
    TYPE(REAL_DP_PTR_TYPE), ALLOCATABLE :: DEPENDENT_PARAMETERS(:)
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: DEPENDENT_BOUNDARY_CONDITIONS,rhsBoundaryConditions
    TYPE(DistributedMatrixType), POINTER :: PREVIOUS_SOLVER_DISTRIBUTED_MATRIX,SOLVER_DISTRIBUTED_MATRIX
    TYPE(DistributedVectorType), POINTER :: lagrangeVector,DEPENDENT_VECTOR,distributedSourceVector,equationsRHSVector, &
      & linearTempVector,interfaceTempVector,residualVector,solverResidualVector,solverRHSVector
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: rhsDomainMapping,variableDomainMapping
    TYPE(EquationsJacobianType), POINTER :: JACOBIAN_MATRIX
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMappingLinearType), POINTER :: linearMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingRHSType), POINTER :: rhsMapping
    TYPE(EquationsMappingSourceType), POINTER :: sourceMapping
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatricesLinearType), POINTER :: linearMatrices
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesRHSType), POINTER :: rhsVector
    TYPE(EquationsMatricesSourceType), POINTER :: sourceVector
    TYPE(EquationsMatrixType), POINTER :: equationsMatrix,LINEAR_MATRIX
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(EQUATIONS_TO_SOLVER_MAPS_TYPE), POINTER :: EQUATIONS_TO_SOLVER_MAP
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD,LAGRANGE_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: INTERFACE_VARIABLE,DEPENDENT_VARIABLE,LINEAR_VARIABLE,rhsVariable
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: INTERFACE_LAGRANGE
    TYPE(INTERFACE_MAPPING_TYPE), POINTER :: INTERFACE_MAPPING
    TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER :: INTERFACE_RHS_MAPPING
    TYPE(INTERFACE_MATRICES_TYPE), POINTER :: INTERFACE_MATRICES
    TYPE(INTERFACE_MATRIX_TYPE), POINTER :: INTERFACE_MATRIX
    TYPE(INTERFACE_RHS_TYPE), POINTER :: INTERFACE_RHS_VECTOR
    TYPE(INTERFACE_TO_SOLVER_MAPS_TYPE), POINTER :: INTERFACE_TO_SOLVER_MAP
    TYPE(JACOBIAN_TO_SOLVER_MAP_TYPE), POINTER :: JACOBIAN_TO_SOLVER_MAP
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX
    TYPE(VARYING_STRING) :: localError
    TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE), POINTER :: SPARSITY_INDICES
  
    ENTERS("Solver_StaticAssemble",err,error,*999)
  
    IF(ASSOCIATED(SOLVER)) THEN
      SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        SOLVER_MAPPING=>SOLVER_EQUATIONS%SOLVER_MAPPING
        IF(ASSOCIATED(SOLVER_MAPPING)) THEN
          SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
          IF(ASSOCIATED(SOLVER_MATRICES)) THEN
            !Assemble the solver matrices
            NULLIFY(PREVIOUS_SOLVER_DISTRIBUTED_MATRIX)
            IF(SELECTION_TYPE==SOLVER_MATRICES_ALL.OR. &
              & SELECTION_TYPE==SOLVER_MATRICES_LINEAR_ONLY.OR. &
              & SELECTION_TYPE==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
              & SELECTION_TYPE==SOLVER_MATRICES_JACOBIAN_ONLY) THEN
              !Assemble solver matrices
              IF(SOLVER%outputType>=SOLVER_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,USER_TIME1,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,SYSTEM_TIME1,err,error,*999)
              ENDIF
              !Loop over the solver matrices
              DO solver_matrix_idx=1,SOLVER_MAPPING%NUMBER_OF_SOLVER_MATRICES
                SOLVER_MATRIX=>SOLVER_MATRICES%matrices(solver_matrix_idx)%ptr
                IF(ASSOCIATED(SOLVER_MATRIX)) THEN
                  IF(SOLVER_MATRIX%UPDATE_MATRIX) THEN
                    SOLVER_DISTRIBUTED_MATRIX=>SOLVER_MATRIX%MATRIX
                    IF(ASSOCIATED(SOLVER_DISTRIBUTED_MATRIX)) THEN
                      !Initialise matrix to zero
                      CALL DistributedMatrix_AllValuesSet(SOLVER_DISTRIBUTED_MATRIX,0.0_DP,err,error,*999)
                      !Loop over the equations sets
                      DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                        !First Loop over the linear equations matrices
                        DO equations_matrix_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_LINEAR_EQUATIONS_MATRICES
                          EQUATIONS_TO_SOLVER_MAP=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                            & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS( &
                            & equations_matrix_idx)%ptr
                          IF(ASSOCIATED(EQUATIONS_TO_SOLVER_MAP)) THEN
                            equationsMatrix=>EQUATIONS_TO_SOLVER_MAP%EQUATIONS_MATRIX
                            IF(ASSOCIATED(equationsMatrix)) THEN
                              CALL SolverMatrix_EquationsMatrixAdd(SOLVER_MATRIX,equations_set_idx,1.0_DP,equationsMatrix, &
                                & err,error,*999)
                            ELSE
                              CALL FlagError("The equations matrix is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("The equations matrix equations to solver map is not associated.",err,error,*999)
                          ENDIF
                        ENDDO !equations_matrix_idx
                        IF(SELECTION_TYPE==SOLVER_MATRICES_ALL.OR. &
                          & SELECTION_TYPE==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
                          & SELECTION_TYPE==SOLVER_MATRICES_JACOBIAN_ONLY) THEN
                          !Now set the values from the equations Jacobian
                          DO equations_matrix_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                              & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_EQUATIONS_JACOBIANS 
                            JACOBIAN_TO_SOLVER_MAP=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                              & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%JACOBIAN_TO_SOLVER_MATRIX_MAPS( &
                              & equations_matrix_idx)%ptr
                            IF(ASSOCIATED(JACOBIAN_TO_SOLVER_MAP)) THEN
                              JACOBIAN_MATRIX=>JACOBIAN_TO_SOLVER_MAP%JACOBIAN_MATRIX
                              IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN
                                CALL SolverMatrix_JacobianMatrixAdd(SOLVER_MATRIX,equations_set_idx,1.0_DP,JACOBIAN_MATRIX, &
                                  & err,error,*999)
                              ELSE
                                CALL FlagError("Jacobian matrix is not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              localError="Jacobian to solver map is not associated for Jacobian number "// &
                                & TRIM(NumberToVString(equations_matrix_idx,"*",err,error))//"."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDDO
                        ENDIF
                      ENDDO !equations_set_idx
                      !Loop over any interface conditions
                      DO interface_condition_idx=1,SOLVER_MAPPING%NUMBER_OF_INTERFACE_CONDITIONS
                        !Loop over the interface matrices
                        DO interface_matrix_idx=1,SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_INTERFACE_MATRICES
                          INTERFACE_TO_SOLVER_MAP=>SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                            & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS( &
                            & interface_matrix_idx)%ptr
                          IF(ASSOCIATED(INTERFACE_TO_SOLVER_MAP)) THEN
                            INTERFACE_MATRIX=>INTERFACE_TO_SOLVER_MAP%INTERFACE_MATRIX
                            IF(ASSOCIATED(INTERFACE_MATRIX)) THEN
                              CALL SolverMatrix_InterfaceMatrixAdd(SOLVER_MATRIX,interface_condition_idx,[1.0_DP,1.0_DP], &
                                & INTERFACE_MATRIX,err,error,*999)
                            ELSE
                              CALL FlagError("The interface matrix is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("The interface matrix interface to solver map is not associated.",err,error,*999)
                          ENDIF
                        ENDDO !interface_matrix_idx
                      ENDDO !interface_condition_idx
                      !Update the solver matrix values
                      CALL DistributedMatrix_UpdateStart(SOLVER_DISTRIBUTED_MATRIX,err,error,*999)
                      IF(ASSOCIATED(PREVIOUS_SOLVER_DISTRIBUTED_MATRIX)) THEN
                        CALL DistributedMatrix_UpdateFinish(PREVIOUS_SOLVER_DISTRIBUTED_MATRIX,err,error,*999)
                      ENDIF
                      PREVIOUS_SOLVER_DISTRIBUTED_MATRIX=>SOLVER_DISTRIBUTED_MATRIX
                    ELSE
                      CALL FlagError("Solver matrix distributed matrix is not associated.",err,error,*999)
                    ENDIF
                  ENDIF !Update matrix
                ELSE
                  CALL FlagError("Solver matrix is not associated.",err,error,*999)
                ENDIF
              ENDDO !solver_matrix_idx
              IF(ASSOCIATED(PREVIOUS_SOLVER_DISTRIBUTED_MATRIX)) THEN
                CALL DistributedMatrix_UpdateFinish(PREVIOUS_SOLVER_DISTRIBUTED_MATRIX,err,error,*999)
              ENDIF
              IF(SOLVER%outputType>=SOLVER_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,USER_TIME2,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,SYSTEM_TIME2,err,error,*999)
                userElapsed=USER_TIME2(1)-USER_TIME1(1)
                systemElapsed=SYSTEM_TIME2(1)-SYSTEM_TIME1(1)
                IF(solver%outputType>=SOLVER_MATRIX_OUTPUT) &
                  & CALL Profiling_TimingsOutput(0,"",userElapsed,systemElapsed,err,error,*999)
                CALL Profiling_TimingsOutput(1,"Solver matrices assembly",userElapsed,systemElapsed,err,error,*999)
              ENDIF
            ENDIF
            !The solver matrices have only one residual vector
            NULLIFY(solverResidualVector)
            IF(SELECTION_TYPE==SOLVER_MATRICES_ALL.OR. &
              & SELECTION_TYPE==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
              & SELECTION_TYPE==SOLVER_MATRICES_RESIDUAL_ONLY.OR. &
              & SELECTION_TYPE==SOLVER_MATRICES_RHS_RESIDUAL_ONLY) THEN
              !Assemble residual vector
              !We assemble residual vector before RHS vector, then when assembling the RHS vector we subtract
              !the RHS terms for fixed BCs from the residual vector as this residual evaluation uses a matrix
              !vector product of the full equations matrix rather than the reduced solver matrix
              IF(SOLVER%outputType>=SOLVER_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,USER_TIME1,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,SYSTEM_TIME1,err,error,*999)
              ENDIF
              IF(SOLVER_MATRICES%UPDATE_RESIDUAL) THEN
                solverResidualVector=>SOLVER_MATRICES%RESIDUAL
                IF(ASSOCIATED(solverResidualVector)) THEN
                  !Initialise the residual to zero
                  CALL DistributedVector_AllValuesSet(solverResidualVector,0.0_DP,err,error,*999)
                  !Loop over the equations sets
                  DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                    EQUATIONS_SET=>SOLVER_MAPPING%EQUATIONS_SETS(equations_set_idx)%ptr
                    IF(ASSOCIATED(EQUATIONS_SET)) THEN
                      DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
                      IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
                        EQUATIONS=>EQUATIONS_SET%EQUATIONS
                        IF(ASSOCIATED(EQUATIONS)) THEN
                          NULLIFY(vectorEquations)
                          CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
                          vectorMatrices=>vectorEquations%vectorMatrices
                          IF(ASSOCIATED(vectorMatrices)) THEN
                            vectorMapping=>vectorEquations%vectorMapping
                            IF(ASSOCIATED(vectorMapping)) THEN
                              !Calculate the contributions from any linear matrices
                              linearMapping=>vectorMapping%linearMapping
                              IF(ASSOCIATED(linearMapping)) THEN
                                linearMatrices=>vectorMatrices%linearMatrices
                                IF(ASSOCIATED(linearMatrices)) THEN
                                  DO equations_matrix_idx=1,linearMatrices%numberOfLinearMatrices
                                    LINEAR_MATRIX=>linearMatrices%matrices(equations_matrix_idx)%ptr
                                    IF(ASSOCIATED(LINEAR_MATRIX)) THEN
                                      linearVariableType=linearMapping%equationsMatrixToVarMaps(equations_matrix_idx)% &
                                        & variableType
                                      LINEAR_VARIABLE=>linearMapping%equationsMatrixToVarMaps(equations_matrix_idx)% &
                                        & variable
                                      IF(ASSOCIATED(LINEAR_VARIABLE)) THEN
                                        linearTempVector=>LINEAR_MATRIX%tempVector
                                        !Initialise the linear temporary vector to zero
                                        CALL DistributedVector_AllValuesSet(linearTempVector,0.0_DP,err,error,*999)
                                        NULLIFY(DEPENDENT_VECTOR)
                                        CALL Field_ParameterSetVectorGet(DEPENDENT_FIELD,linearVariableType, &
                                          & FIELD_VALUES_SET_TYPE,DEPENDENT_VECTOR,err,error,*999)
                                        CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE,1.0_DP, &
                                          & LINEAR_MATRIX%MATRIX,DEPENDENT_VECTOR,linearTempVector,err,error,*999)
                                      ELSE
                                        CALL FlagError("Linear variable is not associated.",err,error,*999)
                                      ENDIF
                                    ELSE
                                      localError="Linear matrix is not associated for linear matrix number "// &
                                        & TRIM(NumberToVString(equations_matrix_idx,"*",err,error))//"."
                                      CALL FlagError(localError,err,error,*999)
                                    ENDIF
                                  ENDDO !equations_matrix_idx
                                ELSE
                                  CALL FlagError("Equations matrices linear matrices is not associated.",err,error,*999)
                                ENDIF
                              ENDIF
                              !Calculate the solver residual
                              nonlinearMapping=>vectorMapping%nonlinearMapping
                              IF(ASSOCIATED(nonlinearMapping)) THEN
                                nonlinearMatrices=>vectorMatrices%nonlinearMatrices
                                IF(ASSOCIATED(nonlinearMatrices)) THEN
                                  residualVector=>nonlinearMatrices%RESIDUAL
                                  !Loop over the rows in the equations set
                                  DO equations_row_number=1,vectorMapping%totalNumberOfRows
                                    IF(SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                      & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)% &
                                      & NUMBER_OF_SOLVER_ROWS>0) THEN
                                      !Get the equations residual contribution
                                      CALL DistributedVector_ValuesGet(residualVector,equations_row_number, &
                                        & RESIDUAL_VALUE,err,error,*999)
                                      !Get the linear matrices contribution to the RHS values if there are any
                                      IF(ASSOCIATED(linearMapping)) THEN
                                        LINEAR_VALUE_SUM=0.0_DP
                                        DO equations_matrix_idx2=1,linearMatrices%numberOfLinearMatrices
                                          LINEAR_MATRIX=>linearMatrices%matrices(equations_matrix_idx2)%ptr
                                          linearTempVector=>LINEAR_MATRIX%tempVector
                                          CALL DistributedVector_ValuesGet(linearTempVector,equations_row_number, &
                                            & LINEAR_VALUE,err,error,*999)
                                          LINEAR_VALUE_SUM=LINEAR_VALUE_SUM+LINEAR_VALUE
                                        ENDDO !equations_matrix_idx2
                                        RESIDUAL_VALUE=RESIDUAL_VALUE+LINEAR_VALUE_SUM
                                      ENDIF
                                      !Loop over the solver rows associated with this equations set residual row
                                      DO solver_row_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                        & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)%NUMBER_OF_SOLVER_ROWS
                                        solver_row_number=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                          & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)%SOLVER_ROWS( &
                                          & solver_row_idx)
                                        rowCouplingCoefficient=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP( &
                                          & equations_set_idx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)% &
                                          & COUPLING_COEFFICIENTS(solver_row_idx)
                                        VALUE=RESIDUAL_VALUE*rowCouplingCoefficient
                                        !Add in nonlinear residual values
                                        CALL DistributedVector_ValuesAdd(solverResidualVector,solver_row_number,VALUE, &
                                          & err,error,*999)
                                      ENDDO !solver_row_idx
                                    ENDIF
                                  ENDDO !equations_row_number
                                ELSE
                                  CALL FlagError("Equations matrices nonlinear matrices is not associated.",err,error,*999)
                                ENDIF
                              ELSE IF(ASSOCIATED(linearMapping)) THEN
                                DO equations_row_number=1,vectorMapping%totalNumberOfRows
                                  IF(SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                      & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)% &
                                      & NUMBER_OF_SOLVER_ROWS>0) THEN
                                    LINEAR_VALUE_SUM=0.0_DP
                                    DO equations_matrix_idx=1,linearMatrices%numberOfLinearMatrices
                                      LINEAR_MATRIX=>linearMatrices%matrices(equations_matrix_idx)%ptr
                                      linearTempVector=>LINEAR_MATRIX%tempVector
                                      CALL DistributedVector_ValuesGet(linearTempVector,equations_row_number, &
                                        & LINEAR_VALUE,err,error,*999)
                                      LINEAR_VALUE_SUM=LINEAR_VALUE_SUM+LINEAR_VALUE
                                    ENDDO !equations_matrix_idx
                                    RESIDUAL_VALUE=LINEAR_VALUE_SUM
                                    !Loop over the solver rows associated with this equations set residual row
                                    DO solver_row_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                      & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)%NUMBER_OF_SOLVER_ROWS
                                      solver_row_number=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                        & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)%SOLVER_ROWS( &
                                        & solver_row_idx)
                                      rowCouplingCoefficient=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP( &
                                        & equations_set_idx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)% &
                                        & COUPLING_COEFFICIENTS(solver_row_idx)
                                      VALUE=RESIDUAL_VALUE*rowCouplingCoefficient
                                      !Add in nonlinear residual values
                                      CALL DistributedVector_ValuesAdd(solverResidualVector,solver_row_number,VALUE, &
                                        & err,error,*999)
                                    ENDDO !solver_row_idx
                                  ENDIF
                                ENDDO !equations_row_number
                              ENDIF
                            ELSE
                              CALL FlagError("Equations equations mapping is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Equations equations matrices is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Equations set equations is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Equations set dependent field is not associated.",err,error,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Equations set is not associated.",err,error,*999)
                    ENDIF
                  ENDDO !equations_set_idx
                  !Loop over the interface conditions
                  DO interface_condition_idx=1,SOLVER_MAPPING%NUMBER_OF_INTERFACE_CONDITIONS
                    INTERFACE_CONDITION=>SOLVER_MAPPING%INTERFACE_CONDITIONS(interface_condition_idx)%ptr
                    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
                      LAGRANGE_FIELD=>INTERFACE_CONDITION%LAGRANGE%LAGRANGE_FIELD
                      IF(ASSOCIATED(LAGRANGE_FIELD)) THEN
                        INTERFACE_EQUATIONS=>INTERFACE_CONDITION%INTERFACE_EQUATIONS
                        IF(ASSOCIATED(INTERFACE_EQUATIONS)) THEN
                          INTERFACE_MATRICES=>INTERFACE_EQUATIONS%INTERFACE_MATRICES
                          IF(ASSOCIATED(INTERFACE_MATRICES)) THEN
                            INTERFACE_MAPPING=>INTERFACE_EQUATIONS%INTERFACE_MAPPING
                            IF(ASSOCIATED(INTERFACE_MAPPING)) THEN
                              SELECT CASE(INTERFACE_CONDITION%METHOD)
                              CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD)
                                numberOfInterfaceMatrices=INTERFACE_MAPPING%NUMBER_OF_INTERFACE_MATRICES
                              CASE(INTERFACE_CONDITION_PENALTY_METHOD)
                                numberOfInterfaceMatrices=INTERFACE_MAPPING%NUMBER_OF_INTERFACE_MATRICES-1
                              ENDSELECT
                              !Calculate the contributions from any interface matrices
                              DO interface_matrix_idx=1,numberOfInterfaceMatrices
                                !Calculate the interface matrix-Lagrange vector product residual contribution
                                INTERFACE_MATRIX=>INTERFACE_MATRICES%matrices(interface_matrix_idx)%ptr
                                IF(ASSOCIATED(INTERFACE_MATRIX)) THEN
                                  INTERFACE_VARIABLE_TYPE=INTERFACE_MAPPING%LAGRANGE_VARIABLE_TYPE
                                  INTERFACE_VARIABLE=>INTERFACE_MAPPING%LAGRANGE_VARIABLE
                                  IF(ASSOCIATED(INTERFACE_VARIABLE)) THEN
                                    interfaceTempVector=>INTERFACE_MATRIX%TEMP_VECTOR
                                    !Initialise the linear temporary vector to zero
                                    CALL DistributedVector_AllValuesSet(interfaceTempVector,0.0_DP,err,error,*999)
                                    NULLIFY(lagrangeVector)
                                    CALL Field_ParameterSetVectorGet(LAGRANGE_FIELD,INTERFACE_VARIABLE_TYPE, &
                                      & FIELD_VALUES_SET_TYPE,lagrangeVector,err,error,*999)
                                    CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE,1.0_DP, &
                                      & INTERFACE_MATRIX%MATRIX,lagrangeVector,interfaceTempVector,err,error,*999)
                                    !Add interface matrix residual contribution to the solver residual
                                    DO interface_row_number=1,INTERFACE_MATRIX%NUMBER_OF_ROWS
                                      IF(SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                                        & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interface_matrix_idx)% &
                                        & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interface_row_number)%NUMBER_OF_SOLVER_ROWS>0) THEN
                                        !Loop over the solver rows associated with this interface residual row
                                        !Currently earch interface matrix row has only one corresponding solver row number & coupling coefficient
                                        solver_row_number=SOLVER_MAPPING% & 
                                          & INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interface_matrix_idx)% &
                                          & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interface_row_number)%SOLVER_ROW
                                        rowCouplingCoefficient=SOLVER_MAPPING% &
                                          & INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interface_matrix_idx)% &
                                          & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interface_row_number)%COUPLING_COEFFICIENT
                                        CALL DistributedVector_ValuesGet(interfaceTempVector,interface_row_number, &
                                          & RESIDUAL_VALUE,err,error,*999)
                                        VALUE=RESIDUAL_VALUE*rowCouplingCoefficient
                                        !Add in nonlinear residual values
                                        CALL DistributedVector_ValuesAdd(solverResidualVector,solver_row_number,VALUE, &
                                          & err,error,*999)
                                      ENDIF
                                    ENDDO !interface_row_number
                                  ELSE
                                    CALL FlagError("Interface variable is not associated.",err,error,*999)
                                  ENDIF
                                  !Calculate the transposed interface matrix-dependent variable product residual contribution
                                  dependent_variable_type=INTERFACE_MAPPING% &
                                    & INTERFACE_MATRIX_ROWS_TO_VAR_MAPS(interface_matrix_idx)%VARIABLE_TYPE
                                  DEPENDENT_VARIABLE=>INTERFACE_MAPPING% &
                                    & INTERFACE_MATRIX_ROWS_TO_VAR_MAPS(interface_matrix_idx)%VARIABLE
                                  IF(ASSOCIATED(DEPENDENT_VARIABLE)) THEN
                                    interfaceTempVector=>INTERFACE_MATRIX%TEMP_TRANSPOSE_VECTOR
                                    !Initialise the linear temporary vector to zero
                                    CALL DistributedVector_AllValuesSet(interfaceTempVector,0.0_DP,err,error,*999)
                                    NULLIFY(DEPENDENT_VECTOR)
                                    DEPENDENT_FIELD=>DEPENDENT_VARIABLE%FIELD
                                    CALL Field_ParameterSetVectorGet(DEPENDENT_FIELD,dependent_variable_type, &
                                      & FIELD_VALUES_SET_TYPE,DEPENDENT_VECTOR,err,error,*999)
                                    CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE,1.0_DP, &
                                      & INTERFACE_MATRIX%MATRIX_TRANSPOSE,DEPENDENT_VECTOR,interfaceTempVector,err,error,*999)
                                    !Add interface matrix residual contribution to the solver residual.
                                    !The number of columns in the interface matrix is equivalent to the number of rows of the transposed interface matrices
                                    DO interface_row_number=1,INTERFACE_MATRICES%NUMBER_OF_COLUMNS
                                      IF(SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                                        & INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS(interface_row_number)%NUMBER_OF_SOLVER_ROWS>0) THEN
                                        !Loop over the solver rows associated with this interface residual row
                                        !Currently earch interface matrix row has only one corresponding solver row number & coupling coefficient
                                        solver_row_number=SOLVER_MAPPING% & 
                                          & INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                                          & INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS(interface_row_number)%SOLVER_ROW
                                        rowCouplingCoefficient=SOLVER_MAPPING% & 
                                          & INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                                          & INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS(interface_row_number)%COUPLING_COEFFICIENT
                                        CALL DistributedVector_ValuesGet(interfaceTempVector,interface_row_number, &
                                          & RESIDUAL_VALUE,err,error,*999)
                                        VALUE=RESIDUAL_VALUE*rowCouplingCoefficient
                                        !Add in nonlinear residual values
                                        CALL DistributedVector_ValuesAdd(solverResidualVector,solver_row_number,VALUE, &
                                          & err,error,*999)
                                      ENDIF
                                    ENDDO !interface_row_number
                                  ELSE
                                    CALL FlagError("Dependent variable is not associated.",err,error,*999)
                                  ENDIF
                                ELSE
                                  localError="Interface matrix is not associated for linear matrix number "// &
                                    & TRIM(NumberToVString(equations_matrix_idx,"*",err,error))//"."
                                  CALL FlagError(localError,err,error,*999)
                                ENDIF
                              ENDDO !interface_matrix_idx
                              SELECT CASE(INTERFACE_CONDITION%METHOD)
                              CASE(INTERFACE_CONDITION_PENALTY_METHOD)
                                interface_matrix_idx=INTERFACE_MAPPING%NUMBER_OF_INTERFACE_MATRICES
                                !Calculate the Lagrange-Lagrange vector product residual contribution from the penalty term
                                INTERFACE_MATRIX=>INTERFACE_MATRICES%matrices(interface_matrix_idx)%ptr
                                IF(ASSOCIATED(INTERFACE_MATRIX)) THEN
                                  INTERFACE_VARIABLE_TYPE=INTERFACE_MAPPING%LAGRANGE_VARIABLE_TYPE
                                  INTERFACE_VARIABLE=>INTERFACE_MAPPING%LAGRANGE_VARIABLE
                                  IF(ASSOCIATED(INTERFACE_VARIABLE)) THEN
                                    interfaceTempVector=>INTERFACE_MATRIX%TEMP_VECTOR
                                    !Initialise the linear temporary vector to zero
                                    CALL DistributedVector_AllValuesSet(interfaceTempVector,0.0_DP,err,error,*999)
                                    NULLIFY(lagrangeVector)
                                    CALL Field_ParameterSetVectorGet(LAGRANGE_FIELD,INTERFACE_VARIABLE_TYPE, &
                                      & FIELD_VALUES_SET_TYPE,lagrangeVector,err,error,*999)
                                    CALL DistributedMatrix_MatrixByVectorAdd(DISTRIBUTED_MATRIX_VECTOR_NO_GHOSTS_TYPE,1.0_DP, &
                                      & INTERFACE_MATRIX%MATRIX,lagrangeVector,interfaceTempVector,err,error,*999)
                                    !Add interface matrix residual contribution to the solver residual
                                    DO interface_row_number=1,INTERFACE_MATRIX%NUMBER_OF_ROWS
                                      IF(SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                                        & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interface_matrix_idx)% &
                                        & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interface_row_number)%NUMBER_OF_SOLVER_ROWS>0) THEN
                                        !Loop over the solver rows associated with this interface residual row
                                        !Currently earch interface matrix row has only one corresponding solver row number & coupling coefficient
                                        solver_row_number=SOLVER_MAPPING% & 
                                          & INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interface_matrix_idx)% &
                                          & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interface_row_number)%SOLVER_ROW
                                        rowCouplingCoefficient=SOLVER_MAPPING% &
                                          & INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(interface_matrix_idx)% &
                                          & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(interface_row_number)%COUPLING_COEFFICIENT
                                        CALL DistributedVector_ValuesGet(interfaceTempVector,interface_row_number, &
                                          & RESIDUAL_VALUE,err,error,*999)
                                        VALUE=RESIDUAL_VALUE*rowCouplingCoefficient
                                        !Add in nonlinear residual values
                                        CALL DistributedVector_ValuesAdd(solverResidualVector,solver_row_number,VALUE, &
                                          & err,error,*999)
                                      ENDIF
                                    ENDDO !interface_row_number
                                  ELSE
                                    CALL FlagError("Interface variable is not associated.",err,error,*999)
                                  ENDIF
                                ELSE
                                  localError="Interface matrix is not associated for linear matrix number "// &
                                    & TRIM(NumberToVString(equations_matrix_idx,"*",err,error))//"."
                                  CALL FlagError(localError,err,error,*999)
                                ENDIF
                              ENDSELECT
                            ELSE
                              CALL FlagError("Interface mapping is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Interface matrices is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Interface equations is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Interface Lagrange field is not associated.",err,error,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Interface condition is not associated.",err,error,*999)
                    ENDIF
                  ENDDO !interface_condition_idx
                  !Start the update the solver residual vector values
                  CALL DistributedVector_UpdateStart(solverResidualVector,err,error,*999)
                ELSE
                  CALL FlagError("The solver residual vector is not associated.",err,error,*999)
                ENDIF
              ENDIF
              IF(ASSOCIATED(solverResidualVector)) THEN
                CALL DistributedVector_UpdateFinish(solverResidualVector,err,error,*999)
              ENDIF
              IF(SOLVER%outputType>=SOLVER_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,USER_TIME2,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,SYSTEM_TIME2,err,error,*999)
                userElapsed=USER_TIME2(1)-USER_TIME1(1)
                systemElapsed=SYSTEM_TIME2(1)-SYSTEM_TIME1(1)
                IF(solver%outputType>=SOLVER_MATRIX_OUTPUT) &
                  & CALL Profiling_TimingsOutput(0,"",userElapsed,systemElapsed,err,error,*999)
                CALL Profiling_TimingsOutput(1,"Solver residual assembly",userElapsed,systemElapsed,err,error,*999)
              ENDIF
            ENDIF
            NULLIFY(solverRHSVector)
            IF(SELECTION_TYPE==SOLVER_MATRICES_ALL.OR. &
              & SELECTION_TYPE==SOLVER_MATRICES_LINEAR_ONLY.OR. &
              & SELECTION_TYPE==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
              & SELECTION_TYPE==SOLVER_MATRICES_RHS_ONLY.OR. &
              & SELECTION_TYPE==SOLVER_MATRICES_RHS_RESIDUAL_ONLY) THEN
              !Assemble rhs vector
              IF(SOLVER%outputType>=SOLVER_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,USER_TIME1,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,SYSTEM_TIME1,err,error,*999)
              ENDIF
              IF(SOLVER_MATRICES%UPDATE_RHS_VECTOR) THEN
                solverRHSVector=>SOLVER_MATRICES%RHS_VECTOR
                IF(ASSOCIATED(solverRHSVector)) THEN
                  !Initialise the RHS to zero
                  CALL DistributedVector_AllValuesSet(solverRHSVector,0.0_DP,err,error,*999)
                  NULLIFY(CHECK_DATA)
                  CALL DistributedVector_DataGet(solverRHSVector,CHECK_DATA,err,error,*999)
                  SUBTRACT_FIXED_BCS_FROM_RESIDUAL=.FALSE.
                  IF(SELECTION_TYPE==SOLVER_MATRICES_ALL.OR. &
                      & SELECTION_TYPE==SOLVER_MATRICES_NONLINEAR_ONLY.OR. &
                      & SELECTION_TYPE==SOLVER_MATRICES_RHS_RESIDUAL_ONLY) THEN
                    IF(SOLVER_MATRICES%UPDATE_RESIDUAL) THEN
                      IF(ASSOCIATED(solverResidualVector)) THEN
                        SUBTRACT_FIXED_BCS_FROM_RESIDUAL=.TRUE.
                      ELSE
                        CALL FlagError("The solver residual vector is not associated.",err,error,*999)
                      ENDIF
                    ENDIF
                  ENDIF
                  !Loop over the equations sets
                  DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                    EQUATIONS_SET=>SOLVER_MAPPING%EQUATIONS_SETS(equations_set_idx)%ptr
                    IF(ASSOCIATED(EQUATIONS_SET)) THEN
                      DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
                      IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
                        EQUATIONS=>EQUATIONS_SET%EQUATIONS
                        IF(ASSOCIATED(EQUATIONS)) THEN
                          NULLIFY(vectorEquations)
                          CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
                          vectorMatrices=>vectorEquations%vectorMatrices
                          IF(ASSOCIATED(vectorMatrices)) THEN
                            vectorMapping=>vectorEquations%vectorMapping
                            IF(ASSOCIATED(vectorMapping)) THEN
                              sourceMapping=>vectorMapping%sourceMapping
                              IF(ASSOCIATED(sourceMapping)) THEN
                                sourceVector=>vectorMatrices%sourceVector
                                IF(ASSOCIATED(sourceVector)) THEN
                                  distributedSourceVector=>sourceVector%VECTOR
                                ELSE
                                  CALL FlagError("Source vector vector is not associated.",err,error,*999)
                                ENDIF
                              ENDIF
                              rhsMapping=>vectorMapping%rhsMapping
                              IF(ASSOCIATED(rhsMapping)) THEN
                                NULLIFY(RHS_PARAMETERS)
                                RHS_VARIABLE_TYPE=rhsMapping%rhsVariableType
                                CALL Field_ParameterSetDataGet(DEPENDENT_FIELD,RHS_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                                  & RHS_PARAMETERS,err,error,*999)
                                NULLIFY(CHECK_DATA)
                                CALL DistributedVector_DataGet(solverRHSVector,CHECK_DATA,err,error,*999)    
                                rhsVector=>vectorMatrices%rhsVector
                                IF(ASSOCIATED(rhsVector)) THEN
                                  linearMapping=>vectorMapping%linearMapping
                                  nonlinearMapping=>vectorMapping%nonlinearMapping
                                  IF(ASSOCIATED(linearMapping)) THEN
                                    linearMatrices=>vectorMatrices%linearMatrices
                                    IF(ASSOCIATED(linearMatrices)) THEN
                                      ALLOCATE(DEPENDENT_PARAMETERS(linearMapping%numberOfLinearMatrixVariables),STAT=err)
                                      IF(err/=0) CALL FlagError("Could not allocate dependent_parameters.",err,error,*999)
                                      DO variable_idx=1,linearMapping%numberOfLinearMatrixVariables
                                        variable_type=linearMapping%linearMatrixVariableTypes(variable_idx)
                                        NULLIFY(DEPENDENT_PARAMETERS(variable_idx)%ptr)
                                        CALL Field_ParameterSetDataGet(DEPENDENT_FIELD,variable_type,FIELD_VALUES_SET_TYPE, &
                                          & DEPENDENT_PARAMETERS(variable_idx)%ptr,err,error,*999)
                                      ENDDO !variable_idx
                                    ELSE
                                      CALL FlagError("Equations matrices linear matrices is not associated.",err,error,*999)
                                    ENDIF
                                  ENDIF
                                  BOUNDARY_CONDITIONS=>SOLVER_EQUATIONS%BOUNDARY_CONDITIONS
                                  IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
!!TODO: what if the equations set doesn't have a RHS vector???
                                    rhsVariable=>rhsMapping%rhsVariable
                                    RHS_VARIABLE_TYPE=rhsVariable%VARIABLE_TYPE
                                    rhsDomainMapping=>rhsVariable%DOMAIN_MAPPING
                                    ! Check if there are any integrated values to add
                                    CALL Field_ParameterSetCreated(rhsVariable%FIELD,RHS_VARIABLE_TYPE, &
                                      & FIELD_INTEGRATED_NEUMANN_SET_TYPE,HAS_INTEGRATED_VALUES,err,error,*999)
                                    equationsRHSVector=>rhsVector%VECTOR
                                    CALL BOUNDARY_CONDITIONS_VARIABLE_GET(BOUNDARY_CONDITIONS,rhsVariable, &
                                      & rhsBoundaryConditions,err,error,*999)
                                    IF(ASSOCIATED(rhsBoundaryConditions)) THEN
                                      !Update RHS field by integrating any point Neumann conditions
                                      CALL BoundaryConditions_NeumannIntegrate(rhsBoundaryConditions, &
                                        & err,error,*999)
                                      !Loop over the rows in the equations set
                                      DO equations_row_number=1,vectorMapping%totalNumberOfRows
                                        !Get the source vector contribute to the RHS values if there are any
                                        IF(ASSOCIATED(sourceMapping)) THEN
                                          !Add in equations source values
                                          CALL DistributedVector_ValuesGet(distributedSourceVector,equations_row_number, &
                                            & sourceValue,err,error,*999)
                                          !Loop over the solver rows associated with this equations set row
                                          DO solver_row_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                            & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)%NUMBER_OF_SOLVER_ROWS

                                            solver_row_number=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                              & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)%SOLVER_ROWS( &
                                              & solver_row_idx)

                                            rowCouplingCoefficient=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP( &
                                              & equations_set_idx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)% &
                                              & COUPLING_COEFFICIENTS(solver_row_idx)
                                            VALUE=1.0_DP*sourceValue*rowCouplingCoefficient
                                            !Calculates the contribution from each row of the equations matrix and adds to solver matrix
                                            CALL DistributedVector_ValuesAdd(solverRHSVector,solver_row_number,VALUE, &
                                              & err,error,*999)
                                          ENDDO !solver_row_idx
                                        ENDIF
                                        rhs_variable_dof=rhsMapping%equationsRowToRHSDofMap(equations_row_number)
                                        rhs_global_dof=rhsDomainMapping%LOCAL_TO_GLOBAL_MAP(rhs_variable_dof)
                                        rhs_boundary_condition=rhsBoundaryConditions%DOF_TYPES(rhs_global_dof)
                                        !Apply boundary conditions
                                        SELECT CASE(rhs_boundary_condition)
                                        CASE(BOUNDARY_CONDITION_DOF_FREE)
                                          !Add in equations RHS values
                                          CALL DistributedVector_ValuesGet(equationsRHSVector,equations_row_number, &
                                            & rhsValue,err,error,*999)
                                          IF(HAS_INTEGRATED_VALUES) THEN
                                            !Add any Neumann integrated values, b = f + N q
                                            CALL Field_ParameterSetGetLocalDOF(rhsVariable%FIELD,RHS_VARIABLE_TYPE, &
                                              & FIELD_INTEGRATED_NEUMANN_SET_TYPE,rhs_variable_dof,RHS_INTEGRATED_VALUE, &
                                              & err,error,*999)
                                            rhsValue=rhsValue+RHS_INTEGRATED_VALUE
                                          END IF
                                          !Loop over the solver rows associated with this equations set row
                                          DO solver_row_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                            & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)%NUMBER_OF_SOLVER_ROWS
                                            solver_row_number=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                              & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)%SOLVER_ROWS( &
                                              & solver_row_idx)
                                            rowCouplingCoefficient=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP( &
                                              & equations_set_idx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)% &
                                              & COUPLING_COEFFICIENTS(solver_row_idx)
                                            VALUE=rhsValue*rowCouplingCoefficient
                                            CALL DistributedVector_ValuesAdd(solverRHSVector,solver_row_number,VALUE, &
                                              & err,error,*999)
                                          ENDDO !solver_row_idx
                                          !Set Dirichlet boundary conditions
                                          IF(ASSOCIATED(linearMapping).AND..NOT.ASSOCIATED(nonlinearMapping)) THEN
                                            !Loop over the dependent variables associated with this equations set row
                                            DO variable_idx=1,linearMapping%numberOfLinearMatrixVariables
                                              variable_type=linearMapping%linearMatrixVariableTypes(variable_idx)
                                              DEPENDENT_VARIABLE=>linearMapping%varToEquationsMatricesMaps( &
                                                & variable_type)%VARIABLE
                                              DEPENDENT_VARIABLE_TYPE=DEPENDENT_VARIABLE%VARIABLE_TYPE
                                              variableDomainMapping=>DEPENDENT_VARIABLE%DOMAIN_MAPPING
                                              CALL BOUNDARY_CONDITIONS_VARIABLE_GET(BOUNDARY_CONDITIONS,DEPENDENT_VARIABLE, &
                                                & DEPENDENT_BOUNDARY_CONDITIONS,err,error,*999)
                                              variable_dof=linearMapping%equationsRowToVariableDOFMaps( &
                                                & equations_row_number,variable_idx)
                                              variable_global_dof=variableDomainMapping%LOCAL_TO_GLOBAL_MAP(variable_dof)
                                              variable_boundary_condition=DEPENDENT_BOUNDARY_CONDITIONS%DOF_TYPES( &
                                                & variable_global_dof)
                                              IF(variable_boundary_condition==BOUNDARY_CONDITION_DOF_FIXED) THEN
                                                DEPENDENT_VALUE=DEPENDENT_PARAMETERS(variable_idx)%ptr(variable_dof)
                                                IF(ABS(DEPENDENT_VALUE)>=ZERO_TOLERANCE) THEN
                                                  DO equations_matrix_idx=1,linearMapping%varToEquationsMatricesMaps( &
                                                    & variable_type)%numberOfEquationsMatrices
                                                    equationsMatrixNumber=linearMapping%varToEquationsMatricesMaps( &
                                                      & variable_type)%equationsMatrixNumbers(equations_matrix_idx)
                                                    equationsMatrix=>linearMatrices%matrices(equationsMatrixNumber)%ptr
                                                    equations_column_number=linearMapping%varToEquationsMatricesMaps( &
                                                      & variable_type)%dofToColumnsMaps(equations_matrix_idx)%columnDOF( &
                                                      & variable_dof)
                                                    IF(ASSOCIATED(DEPENDENT_BOUNDARY_CONDITIONS%DIRICHLET_BOUNDARY_CONDITIONS)) THEN
                                                      IF(DEPENDENT_BOUNDARY_CONDITIONS%NUMBER_OF_DIRICHLET_CONDITIONS>0) THEN
                                                        DO dirichlet_idx=1,DEPENDENT_BOUNDARY_CONDITIONS% &
                                                          & NUMBER_OF_DIRICHLET_CONDITIONS
                                                          IF(DEPENDENT_BOUNDARY_CONDITIONS%DIRICHLET_BOUNDARY_CONDITIONS% &
                                                            & DIRICHLET_DOF_INDICES(dirichlet_idx)==equations_column_number) EXIT
                                                        ENDDO
                                                        SELECT CASE(equationsMatrix%storageType)
                                                        CASE(DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE)
                                                          DO dirichlet_row=1,vectorMatrices%totalNumberOfRows
                                                            CALL DistributedMatrix_ValuesGet(equationsMatrix%MATRIX, &
                                                              & dirichlet_row,equations_column_number,MATRIX_VALUE,err,error,*999)
                                                            IF(ABS(MATRIX_VALUE)>=ZERO_TOLERANCE) THEN
                                                              DO solver_row_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP( &
                                                                & equations_set_idx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS( &
                                                                & dirichlet_row)%NUMBER_OF_SOLVER_ROWS
                                                                solver_row_number=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP( &
                                                                  & equations_set_idx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS( &
                                                                  & dirichlet_row)%SOLVER_ROWS(solver_row_idx)
                                                                rowCouplingCoefficient=SOLVER_MAPPING% &
                                                                  & EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                                                  & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichlet_row)% &
                                                                  & COUPLING_COEFFICIENTS(solver_row_idx)
                                                                VALUE=-1.0_DP*MATRIX_VALUE*DEPENDENT_VALUE*rowCouplingCoefficient
                                                                CALL DistributedVector_ValuesAdd(solverRHSVector, &
                                                                  & solver_row_number,VALUE,err,error,*999)
                                                                IF(SUBTRACT_FIXED_BCS_FROM_RESIDUAL) THEN
                                                                  CALL DistributedVector_ValuesAdd(solverResidualVector, &
                                                                      & solver_row_number,VALUE,err,error,*999)
                                                                ENDIF
                                                              ENDDO !solver_row_idx
                                                            ENDIF
                                                          ENDDO !dirichlet_row
                                                        CASE(DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE)
                                                          dirichlet_row=equations_column_number
                                                          CALL DistributedMatrix_ValuesGet(equationsMatrix%MATRIX, &
                                                            & dirichlet_row,equations_column_number,MATRIX_VALUE,err,error,*999)
                                                          IF(ABS(MATRIX_VALUE)>=ZERO_TOLERANCE) THEN
                                                            DO solver_row_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP( &
                                                              & equations_set_idx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS( &
                                                              & dirichlet_row)%NUMBER_OF_SOLVER_ROWS
                                                              solver_row_number=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP( &
                                                                & equations_set_idx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS( &
                                                                & dirichlet_row)%SOLVER_ROWS(solver_row_idx)
                                                              rowCouplingCoefficient=SOLVER_MAPPING% &
                                                                & EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                                                & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichlet_row)% &
                                                                & COUPLING_COEFFICIENTS(solver_row_idx)
                                                              VALUE=-1.0_DP*MATRIX_VALUE*DEPENDENT_VALUE*rowCouplingCoefficient
                                                              CALL DistributedVector_ValuesAdd(solverRHSVector, &
                                                                & solver_row_number,VALUE,err,error,*999)
                                                              IF(SUBTRACT_FIXED_BCS_FROM_RESIDUAL) THEN
                                                                CALL DistributedVector_ValuesAdd(solverResidualVector, &
                                                                    & solver_row_number,VALUE,err,error,*999)
                                                              ENDIF
                                                            ENDDO !solver_row_idx
                                                          ENDIF
                                                        CASE(DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE)
                                                          CALL FlagError("Not implemented.",err,error,*999)
                                                        CASE(DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE)
                                                          CALL FlagError("Not implemented.",err,error,*999)
                                                        CASE(DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE)
                                                          SPARSITY_INDICES=>DEPENDENT_BOUNDARY_CONDITIONS% &
                                                            & DIRICHLET_BOUNDARY_CONDITIONS%LINEAR_SPARSITY_INDICES( &
                                                            & equations_set_idx,equations_matrix_idx)%ptr
                                                          IF(ASSOCIATED(SPARSITY_INDICES)) THEN
                                                            DO equations_row_number2=SPARSITY_INDICES%SPARSE_COLUMN_INDICES( &
                                                              & dirichlet_idx),SPARSITY_INDICES%SPARSE_COLUMN_INDICES( &
                                                              & dirichlet_idx+1)-1
                                                              dirichlet_row=SPARSITY_INDICES%SPARSE_ROW_INDICES( &
                                                                & equations_row_number2)
                                                              CALL DistributedMatrix_ValuesGet(equationsMatrix%MATRIX, &
                                                                & dirichlet_row,equations_column_number,MATRIX_VALUE,err,error,*999)
                                                              IF(ABS(MATRIX_VALUE)>=ZERO_TOLERANCE) THEN
                                                                DO solver_row_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP( &
                                                                  & equations_set_idx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS( &
                                                                  & dirichlet_row)%NUMBER_OF_SOLVER_ROWS
                                                                  solver_row_number=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP( &
                                                                    & equations_set_idx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS( &
                                                                    & dirichlet_row)%SOLVER_ROWS(solver_row_idx)
                                                                  rowCouplingCoefficient=SOLVER_MAPPING% &
                                                                    & EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                                                    & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(dirichlet_row)% &
                                                                    & COUPLING_COEFFICIENTS(solver_row_idx)
                                                                  VALUE=-1.0_DP*MATRIX_VALUE*DEPENDENT_VALUE* &
                                                                    & rowCouplingCoefficient
                                                                  CALL DistributedVector_ValuesAdd(solverRHSVector, &
                                                                    & solver_row_number,VALUE,err,error,*999)
                                                                  IF(SUBTRACT_FIXED_BCS_FROM_RESIDUAL) THEN
                                                                    CALL DistributedVector_ValuesAdd(solverResidualVector, &
                                                                        & solver_row_number,VALUE,err,error,*999)
                                                                  ENDIF
                                                                ENDDO !solver_row_idx
                                                              ENDIF
                                                            ENDDO !equations_row_number2
                                                          ELSE
                                                            CALL FlagError("Sparsity indices are not associated.",err,error,*999)
                                                          ENDIF
                                                        CASE(DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE)
                                                          CALL FlagError("Not implemented.",err,error,*999)
                                                        CASE(DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE)
                                                          CALL FlagError("Not implemented.",err,error,*999)
                                                        CASE DEFAULT
                                                          localError="The storage type of "// &
                                                            & TRIM(NumberToVString(equationsMatrix%storageType,"*", &
                                                            & err,error))//" is invalid."
                                                          CALL FlagError(localError,err,error,*999)
                                                        END SELECT
                                                      ENDIF
                                                    ELSE
                                                      CALL FlagError("Dirichlet boundary conditions is not associated.",ERR, &
                                                        & ERROR,*999)
                                                    ENDIF
                                                  ENDDO !matrix_idx
                                                ENDIF
                                              ENDIF
                                            ENDDO !variable_idx
                                          ENDIF
                                        CASE(BOUNDARY_CONDITION_DOF_FIXED)
                                          rhsValue=RHS_PARAMETERS(rhs_variable_dof)
                                          ! Add any integrated RHS values calculated from point Neumann conditions, b = f + N q
                                          IF(HAS_INTEGRATED_VALUES) THEN
                                            CALL Field_ParameterSetGetLocalDOF(rhsVariable%FIELD,RHS_VARIABLE_TYPE, &
                                              & FIELD_INTEGRATED_NEUMANN_SET_TYPE,rhs_variable_dof,RHS_INTEGRATED_VALUE, &
                                              & err,error,*999)
                                            rhsValue=rhsValue+RHS_INTEGRATED_VALUE
                                          END IF
                                          IF(ABS(rhsValue)>=ZERO_TOLERANCE) THEN
                                            !Loop over the solver rows associated with this equations set row
                                            DO solver_row_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                              & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)%NUMBER_OF_SOLVER_ROWS
                                              solver_row_number=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                                & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)%SOLVER_ROWS( &
                                                & solver_row_idx)
                                              rowCouplingCoefficient=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP( &
                                                & equations_set_idx)%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(equations_row_number)% &
                                                & COUPLING_COEFFICIENTS(solver_row_idx)
                                              !For nonlinear problems, f(x) - b = 0, and for linear, K x = b, so we always add the
                                              !right hand side field value to the solver right hand side vector
                                              VALUE=rhsValue*rowCouplingCoefficient
                                              CALL DistributedVector_ValuesAdd(solverRHSVector,solver_row_number,VALUE, &
                                                & err,error,*999)
                                            ENDDO !solver_row_idx
                                          ENDIF
                                        CASE(BOUNDARY_CONDITION_DOF_MIXED)
                                          !Set Robin or is it Cauchy??? boundary conditions
                                          CALL FlagError("Not implemented.",err,error,*999)
                                        CASE DEFAULT
                                          localError="The RHS boundary condition of "// &
                                            & TRIM(NumberToVString(rhs_boundary_condition,"*",err,error))// &
                                            & " for RHS variable dof number "// &
                                            & TRIM(NumberToVString(rhs_variable_dof,"*",err,error))//" is invalid."
                                          CALL FlagError(localError,err,error,*999)
                                        END SELECT
                                      ENDDO !equations_row_number
                                      IF(ASSOCIATED(solverResidualVector)) THEN
                                        CALL DistributedVector_UpdateStart(solverResidualVector,err,error,*999)
                                        CALL DistributedVector_UpdateFinish(solverResidualVector,err,error,*999)
                                      ENDIF
                                      NULLIFY(CHECK_DATA2)
                                      CALL DistributedVector_DataGet(equationsRHSVector,CHECK_DATA2,err,error,*999)    
                                      NULLIFY(CHECK_DATA3)
                                      CALL DistributedVector_DataGet(solverRHSVector,CHECK_DATA3,err,error,*999)    
                                      NULLIFY(CHECK_DATA4)
                                      CALL DistributedVector_DataGet(solverRHSVector,CHECK_DATA4,err,error,*999)    
                                    ELSE
                                      CALL FlagError("RHS boundary conditions variable is not associated.",err,error,*999)
                                    ENDIF
                                  ELSE
                                    CALL FlagError("Equations set boundary conditions is not associated.",err,error,*999)
                                  ENDIF
                                  IF(ASSOCIATED(linearMapping)) THEN
                                    DO variable_idx=1,linearMapping%numberOfLinearMatrixVariables
                                      variable_type=linearMapping%linearMatrixVariableTypes(variable_idx)
                                      CALL Field_ParameterSetDataRestore(DEPENDENT_FIELD,variable_type,FIELD_VALUES_SET_TYPE, &
                                        & DEPENDENT_PARAMETERS(variable_idx)%ptr,err,error,*999)
                                    ENDDO !variable_idx
                                    IF(ALLOCATED(DEPENDENT_PARAMETERS)) DEALLOCATE(DEPENDENT_PARAMETERS)
                                  ENDIF
                                ELSE
                                  CALL FlagError("Equations matrices RHS vector is not associated.",err,error,*999)
                                ENDIF
                                CALL Field_ParameterSetDataRestore(DEPENDENT_FIELD,RHS_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                                  & RHS_PARAMETERS,err,error,*999)
                              ELSE
                                CALL FlagError("Equations mapping RHS mapping is not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("Equations equations mapping is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Equations equations matrices is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Equations set equations is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Equations set is not associated.",err,error,*999)
                      ENDIF
                    ENDIF
                  ENDDO !equations_set_idx
                  !Add in any rows from any interface conditions
                  DO interface_condition_idx=1,SOLVER_MAPPING%NUMBER_OF_INTERFACE_CONDITIONS
                    INTERFACE_CONDITION=>SOLVER_MAPPING%INTERFACE_CONDITIONS(interface_condition_idx)%ptr
                    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
                      SELECT CASE(INTERFACE_CONDITION%METHOD)
                      CASE(INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,INTERFACE_CONDITION_PENALTY_METHOD)
                        INTERFACE_EQUATIONS=>INTERFACE_CONDITION%INTERFACE_EQUATIONS
                        IF(ASSOCIATED(INTERFACE_EQUATIONS)) THEN
                          INTERFACE_MAPPING=>INTERFACE_EQUATIONS%INTERFACE_MAPPING
                          IF(ASSOCIATED(INTERFACE_MAPPING)) THEN
                            INTERFACE_LAGRANGE=>INTERFACE_CONDITION%LAGRANGE
                            IF(ASSOCIATED(INTERFACE_LAGRANGE)) THEN
                              LAGRANGE_FIELD=>INTERFACE_LAGRANGE%LAGRANGE_FIELD
                              IF(ASSOCIATED(LAGRANGE_FIELD)) THEN
                                INTERFACE_RHS_MAPPING=>INTERFACE_MAPPING%RHS_MAPPING
                                IF(ASSOCIATED(INTERFACE_RHS_MAPPING)) THEN
                                  INTERFACE_MATRICES=>INTERFACE_EQUATIONS%INTERFACE_MATRICES
                                  IF(ASSOCIATED(INTERFACE_MATRICES)) THEN
                                    INTERFACE_RHS_VECTOR=>INTERFACE_MATRICES%RHS_VECTOR
                                    IF(ASSOCIATED(INTERFACE_RHS_VECTOR)) THEN
                                      !Worry about BCs on the Lagrange variables later.
                                      DO interface_column_number=1,INTERFACE_MAPPING%TOTAL_NUMBER_OF_COLUMNS
                                        CALL DistributedVector_ValuesGet(INTERFACE_RHS_VECTOR%RHS_VECTOR, &
                                          & interface_column_number,rhsValue,err,error,*999)
                                        !Loop over the solver rows this interface column is mapped to
                                        DO solver_row_idx=1,SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP( &
                                          & interface_condition_idx)%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS( &
                                          & interface_column_number)%NUMBER_OF_SOLVER_ROWS
                                          solver_row_number=SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP( &
                                            & interface_condition_idx)%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS( &
                                            & interface_column_number)%SOLVER_ROW
                                          rowCouplingCoefficient=SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP( &
                                            & interface_condition_idx)%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS( &
                                            & interface_column_number)%COUPLING_COEFFICIENT
                                          VALUE=rhsValue*rowCouplingCoefficient
                                          CALL DistributedVector_ValuesAdd(solverRHSVector,solver_row_number,VALUE, &
                                            & err,error,*999)
                                        ENDDO !solver_row_idx
                                      ENDDO !interface_column_idx
                                    ELSE
                                      CALL FlagError("Interface matrices RHS vector is not associated.",err,error,*999)
                                    ENDIF
                                  ELSE
                                    CALL FlagError("Interface equations interface matrices is not associated.",err,error,*999)
                                  ENDIF
                                ELSE
                                  CALL FlagError("Interface mapping RHS mapping is not associated.",err,error,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Interface Lagrange field is not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("Interface Lagrange is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Interface equations interface mapping is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Interface condition equations is not associated.",err,error,*999)
                        ENDIF
                      CASE(INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD)
                        CALL FlagError("Not implemented.",err,error,*999)
                      CASE(INTERFACE_CONDITION_POINT_TO_POINT_METHOD)
                        CALL FlagError("Not implemented.",err,error,*999)
                      CASE DEFAULT
                        localError="The interface condition method of "// &
                          & TRIM(NumberToVString(INTERFACE_CONDITION%METHOD,"*",err,error))// &
                          & " is invalid."
                        CALL FlagError(localError,err,error,*999)
                      END SELECT
                    ELSE
                      CALL FlagError("Interface condition is not associated.",err,error,*999)
                    ENDIF
                  ENDDO !interface_condition_idx
                  !Start the update the solver RHS vector values
                  CALL DistributedVector_UpdateStart(solverRHSVector,err,error,*999)
                  NULLIFY(CHECK_DATA)
                  CALL DistributedVector_DataGet(solverRHSVector,CHECK_DATA,err,error,*999)   
                ELSE
                  CALL FlagError("The solver RHS vector is not associated.",err,error,*999)
                ENDIF
              ENDIF
              IF(SOLVER%outputType>=SOLVER_TIMING_OUTPUT) THEN
                CALL CPUTimer(USER_CPU,USER_TIME2,err,error,*999)
                CALL CPUTimer(SYSTEM_CPU,SYSTEM_TIME2,err,error,*999)
                userElapsed=USER_TIME2(1)-USER_TIME1(1)
                systemElapsed=SYSTEM_TIME2(1)-SYSTEM_TIME1(1)
                IF(solver%outputType>=SOLVER_MATRIX_OUTPUT) &
                  & CALL Profiling_TimingsOutput(0,"",userElapsed,systemElapsed,err,error,*999)
                CALL Profiling_TimingsOutput(1,"Solver RHS assembly",userElapsed,systemElapsed,err,error,*999)
              ENDIF
            ENDIF
            IF(ASSOCIATED(solverRHSVector)) THEN
              CALL DistributedVector_UpdateFinish(solverRHSVector,err,error,*999)
            ENDIF
            !If required output the solver matrices
            IF(SOLVER%outputType>=SOLVER_MATRIX_OUTPUT) THEN
              CALL SOLVER_MATRICES_OUTPUT(GENERAL_OUTPUT_TYPE,SELECTION_TYPE,SOLVER_MATRICES,err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver solver matrices is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Solver matrices solution mapping is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver solver equations is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF

    EXITS("Solver_StaticAssemble")
    RETURN
999 IF(ALLOCATED(DEPENDENT_PARAMETERS)) DEALLOCATE(DEPENDENT_PARAMETERS)    
    ERRORSEXITS("Solver_StaticAssemble",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_StaticAssemble

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for a nonlinear Quasi-Newton solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonAbsoluteToleranceSet
  SUBROUTINE SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,ABSOLUTE_TOLERANCE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the absolute tolerance for
    REAL(DP), INTENT(IN) :: ABSOLUTE_TOLERANCE !<The absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(ABSOLUTE_TOLERANCE>ZERO_TOLERANCE) THEN
                  QUASI_NEWTON_SOLVER%ABSOLUTE_TOLERANCE=ABSOLUTE_TOLERANCE
                ELSE
                  localError="The specified absolute tolerance of "//TRIM(NumberToVString(ABSOLUTE_TOLERANCE,"*",err,error))// &
                    & " is invalid. The absolute tolerance must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver.
  SUBROUTINE Solver_QuasiNewtonLineSearchMonitorOutputSet(solver,linesearchMonitorOutputFlag,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the absolute tolerance for
    LOGICAL, INTENT(IN) :: linesearchMonitorOutputFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: linesearchSolver
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: nonlinearSolver
    
    ENTERS("Solver_QuasiNewtonLineSearchMonitorOutputSet",err,error,*999)

    IF(ASSOCIATED(solver)) THEN
      IF(solver%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(solver%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          nonlinearSolver=>solver%NONLINEAR_SOLVER
          IF(ASSOCIATED(nonlinearSolver)) THEN
            IF(nonlinearSolver%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>nonlinearSolver%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE==SOLVER_QUASI_NEWTON_LINESEARCH) THEN
                  linesearchSolver=>QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER
                  IF(ASSOCIATED(linesearchSolver)) THEN
                    linesearchSolver%linesearchMonitorOutput=linesearchMonitorOutputFlag
                  ELSE
                    CALL FlagError("The Quasi-Newton linesearch solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Quasi-Newton solver is not a linesearch solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_QuasiNewtonLineSearchMonitorOutputSet")
    RETURN
999 ERRORS("Solver_QuasiNewtonLineSearchMonitorOutputSet",err,error)    
    EXITS("Solver_QuasiNewtonLineSearchMonitorOutputSet")    
    RETURN 1
   
  END SUBROUTINE Solver_QuasiNewtonLineSearchMonitorOutputSet

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a Quasi-Newton solver 
  SUBROUTINE SOLVER_QUASI_NEWTON_CREATE_FINISH(QUASI_NEWTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER !<A pointer to the Quasi-Newton solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_QUASI_NEWTON_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
      SELECT CASE(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE)
      CASE(SOLVER_QUASI_NEWTON_LINESEARCH)
        CALL Solver_QuasiNewtonLinesearchCreateFinish(QUASI_NEWTON_SOLVER% &
          & LINESEARCH_SOLVER,err,error,*999)
      CASE(SOLVER_QUASI_NEWTON_TRUSTREGION)
        CALL Solver_QuasiNewtonTrustRegionCreateFinish(QUASI_NEWTON_SOLVER% &
          & TRUSTREGION_SOLVER,err,error,*999)
      CASE DEFAULT
        localError="The Quasi-Newton solver type of "// &
          & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Quasi-Newton solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_QUASI_NEWTON_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_CREATE_FINISH",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Finalise a Quasi-Newton solver and deallocate all memory
  RECURSIVE SUBROUTINE SOLVER_QUASI_NEWTON_FINALISE(QUASI_NEWTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER !<A pointer the Quasi-Newton solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_QUASI_NEWTON_FINALISE",err,error,*999)

    IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
      CALL Solver_QuasiNewtonLinesearchFinalise(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_TRUSTREGION_FINALISE(QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER,err,error,*999)
      CALL SOLVER_FINALISE(QUASI_NEWTON_SOLVER%LINEAR_SOLVER,err,error,*999)
      DEALLOCATE(QUASI_NEWTON_SOLVER)
    ENDIF
         
    EXITS("SOLVER_QUASI_NEWTON_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a Quasi-Newton solver for a nonlinear solver
  SUBROUTINE SOLVER_QUASI_NEWTON_INITIALISE(NONLINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER !<A pointer the solver to initialise the Quasi-Newton solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: dummyError
 
    ENTERS("SOLVER_QUASI_NEWTON_INITIALISE",err,error,*998)

    IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
      IF(ASSOCIATED(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER)) THEN
        CALL FlagError("Quasi-Newton solver is already associated for this nonlinear solver.",err,error,*998)
      ELSE        
        SOLVER=>NONLINEAR_SOLVER%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          !Allocate and initialise a Quasi-Newton solver
          ALLOCATE(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER,STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate nonlinear solver Quasi-Newton solver.",err,error,*999)
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%NONLINEAR_SOLVER=>NONLINEAR_SOLVER
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS=0
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS=0
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%MAXIMUM_NUMBER_OF_ITERATIONS=50
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS=1000
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE=SOLVER_NEWTON_JACOBIAN_FD_CALCULATED
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%convergenceTestType=SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%ABSOLUTE_TOLERANCE=1.0E-10_DP
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%RELATIVE_TOLERANCE=1.0E-05_DP
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%SOLUTION_TOLERANCE=1.0E-05_DP
          NULLIFY(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER)
          NULLIFY(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER)
          NULLIFY(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%CELLML_EVALUATOR_SOLVER)
          NULLIFY(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%convergenceTest)
          ALLOCATE(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%convergenceTest,STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate convergence test object.",err,error,*999)
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%convergenceTest%energyFirstIter = 0.0_DP
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%convergenceTest%normalisedEnergy = 0.0_DP
          !Default to a Quasi-Newton linesearch solver
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE=SOLVER_QUASI_NEWTON_LINESEARCH
          CALL SOLVER_QUASI_NEWTON_LINESEARCH_INITIALISE(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER,err,error,*999)
          !Default to a Quasi-Newton Good Broyden variant
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%QUASI_NEWTON_TYPE=SOLVER_QUASI_NEWTON_GOODBROYDEN
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%RESTART_TYPE=SOLVER_QUASI_NEWTON_RESTART_PERIODIC
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%RESTART=10
          NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%SCALE_TYPE=SOLVER_QUASI_NEWTON_SCALE_JACOBIAN
          !Create the linked linear solver
          ALLOCATE(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%LINEAR_SOLVER,STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate Quasi-Newton solver linear solver.",err,error,*999)
          NULLIFY(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%LINEAR_SOLVER%SOLVERS)
          CALL SOLVER_INITIALISE_PTR(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%LINEAR_SOLVER,err,error,*999)
          CALL SOLVER_LINEAR_INITIALISE(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%LINEAR_SOLVER,err,error,*999)
          CALL SOLVER_LINKED_SOLVER_ADD(SOLVER,NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER%LINEAR_SOLVER,SOLVER_LINEAR_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Nonlinear solver solver is not associated.",err,error,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Nonlinear solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_QUASI_NEWTON_INITIALISE")
    RETURN
999 CALL SOLVER_QUASI_NEWTON_FINALISE(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_QUASI_NEWTON_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_INITIALISE

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of Jacobian calculation type for a Quasi-Newton solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonJacobianCalculationSet
  SUBROUTINE Solver_QuasiNewtonJacobianCalculationTypeSet(SOLVER,JACOBIAN_CALCULATION_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the Jacobian calculation type
    INTEGER(INTG), INTENT(IN) :: JACOBIAN_CALCULATION_TYPE !<The type of Jacobian calculation type to set \see SOLVER_ROUTINES_JacobianCalculationTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_QuasiNewtonJacobianCalculationTypeSet",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(JACOBIAN_CALCULATION_TYPE/=QUASI_NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE) THEN
                  SELECT CASE(JACOBIAN_CALCULATION_TYPE)
                  CASE(SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED)
                    QUASI_NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE=SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED
                  CASE(SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED)
                    QUASI_NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE=SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED
                  CASE(SOLVER_NEWTON_JACOBIAN_FD_CALCULATED)
                    QUASI_NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE=SOLVER_NEWTON_JACOBIAN_FD_CALCULATED
                  CASE DEFAULT
                    localError="The Jacobian calculation type of "// &
                      & TRIM(NumberToVString(JACOBIAN_CALCULATION_TYPE,"*",err,error))//" is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                ENDIF
              ELSE
                CALL FlagError("The nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The Solver nonlinear solver is not associated",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated",err,error,*999)
    ENDIF
    
    EXITS("Solver_QuasiNewtonJacobianCalculationTypeSet")
    RETURN
999 ERRORS("Solver_QuasiNewtonJacobianCalculationTypeSet",err,error)
    EXITS("Solver_QuasiNewtonJacobianCalculationTypeSet")
    RETURN 1
    
  END SUBROUTINE Solver_QuasiNewtonJacobianCalculationTypeSet
        
  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for a Quasi-Newton solver.
  SUBROUTINE SOLVER_QUASI_NEWTON_LIBRARY_TYPE_GET(QUASI_NEWTON_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER !<A pointer the Quasi-Newton solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On exit, the type of library used for the Quasi-Newton solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER
    TYPE(VARYING_STRING) :: localError
 
    ENTERS("SOLVER_QUASI_NEWTON_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
      SELECT CASE(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE)
      CASE(SOLVER_QUASI_NEWTON_LINESEARCH)
        LINESEARCH_SOLVER=>QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER
        IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=LINESEARCH_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("Quasi-Newton line search solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_QUASI_NEWTON_TRUSTREGION)
        TRUSTREGION_SOLVER=>QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER
        IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=TRUSTREGION_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("Quasi-Newton trust region solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The Quasi-Newton solver type of "// &
          & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Quasi-Newton solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_LIBRARY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for a Quasi-Newton solver.
  SUBROUTINE SOLVER_QUASI_NEWTON_LIBRARY_TYPE_SET(QUASI_NEWTON_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER !<A pointer the Quasi-Newton solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library for the Quasi-Newton solver to set. \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_QUASI_NEWTON_LIBRARY_TYPE_SET",err,error,*999)
    
    IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
      SELECT CASE(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE)
      CASE(SOLVER_QUASI_NEWTON_LINESEARCH)
        LINESEARCH_SOLVER=>QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER
        IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            LINESEARCH_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid for a Quasi-Newton linesearch solver."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("Quasi-Newton line search solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_QUASI_NEWTON_TRUSTREGION)
        TRUSTREGION_SOLVER=>QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER
        IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            TRUSTREGION_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid for a Quasi-Newton trustregion solver."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("Quasi-Newton trust region solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The Quasi-Newton solver type of "// &
          & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Quasi-Newton solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_QUASI_NEWTON_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_LIBRARY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_LIBRARY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonLinearSolverGetSet
  SUBROUTINE SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the Quasi-Newton solver to get the linear solver for
    TYPE(SOLVER_TYPE), POINTER :: LINEAR_SOLVER !<On exit, a pointer the linear solver linked to the Quasi-Newton solver. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER

    ENTERS("SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(LINEAR_SOLVER)) THEN
        CALL FlagError("Linear solver is already associated.",err,error,*999)
      ELSE
        NULLIFY(LINEAR_SOLVER)
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                LINEAR_SOLVER=>QUASI_NEWTON_SOLVER%LINEAR_SOLVER
                IF(.NOT.ASSOCIATED(LINEAR_SOLVER)) &
                  & CALL FlagError("Quasi-Newton solver linear solver is not associated.",err,error,*999)
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET

  !
  !================================================================================================================================
  !
  
  !>Returns the CellML solver associated with a Quasi-Newton solver  \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonCellMLSolverGetSet
  SUBROUTINE SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the Quasi-Newton solver to get the linear solver for
    TYPE(SOLVER_TYPE), POINTER :: CELLML_SOLVER !<On exit, a pointer the linear solver linked to the Quasi-Newton solver. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER

    ENTERS("SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(CELLML_SOLVER)) THEN
        CALL FlagError("Linear solver is already associated.",err,error,*999)
      ELSE
        NULLIFY(CELLML_SOLVER)
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                CELLML_SOLVER=>QUASI_NEWTON_SOLVER%CELLML_EVALUATOR_SOLVER
                IF(.NOT.ASSOCIATED(CELLML_SOLVER)) &
                  & CALL FlagError("Quasi-Newton solver CellML solver is not associated.",err,error,*999)
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%DYNAMIC_SOLVER%NONLINEAR_SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                CELLML_SOLVER=>QUASI_NEWTON_SOLVER%CELLML_EVALUATOR_SOLVER
                IF(.NOT.ASSOCIATED(CELLML_SOLVER)) &
                  & CALL FlagError("Quasi-Newton solver CellML solver is not associated.",err,error,*999)
              ELSE
                CALL FlagError("Dynamic nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The Dynamic nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver dynamic nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a nonlinear or dynamic nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET

  !
  !================================================================================================================================
  !
  
  !>Sets/changes the convergence test for a Quasi-Newton nonlinear solver \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonConvergenceTestSet
  SUBROUTINE Solver_QuasiNewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the convergence test for
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: quasiNewtonSolver 
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: nonlinearSolver
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_QuasiNewtonConvergenceTestTypeSet",err,error,*999)

    IF(ASSOCIATED(solver)) THEN
      IF(solver%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(solver%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          nonlinearSolver=>solver%NONLINEAR_SOLVER
          IF(ASSOCIATED(nonlinearSolver)) THEN
            IF(nonlinearSolver%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              quasiNewtonSolver=>nonlinearSolver%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(quasiNewtonSolver)) THEN
                SELECT CASE(convergenceTestType)
                CASE(SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT)
                  quasiNewtonSolver%convergenceTestType=SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT
                CASE(SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM)
                  quasiNewtonSolver%convergenceTestType=SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM
                CASE(SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO)
                  quasiNewtonSolver%convergenceTestType=SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO
                CASE DEFAULT
                  localError="The specified convergence test type of "//TRIM(NumberToVString(convergenceTestType, &
                    & "*",err,error))//" is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
    CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_QuasiNewtonConvergenceTestTypeSet")
    RETURN
999 ERRORSEXITS("Solver_QuasiNewtonConvergenceTestTypeSet",err,error)    
    RETURN 1
   
  END SUBROUTINE Solver_QuasiNewtonConvergenceTestTypeSet
        
  !
  !================================================================================================================================
  !

  !>Finishes the process of creating nonlinear Quasi-Newton line search solver
  SUBROUTINE Solver_QuasiNewtonLinesearchCreateFinish(LINESEARCH_SOLVER,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER !<A pointer the nonlinear Quasi-Newton line search solver to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    EXTERNAL :: Problem_SolverJacobianEvaluatePetsc
    EXTERNAL :: Problem_SolverJacobianFDCalculatePetsc
    EXTERNAL :: Problem_SolverResidualEvaluatePetsc
    EXTERNAL :: Problem_SolverConvergenceTestPetsc
    EXTERNAL :: Problem_SolverNonlinearMonitorPETSC
    INTEGER(INTG) :: equations_matrix_idx,equations_set_idx,interface_condition_idx,interface_matrix_idx
    TYPE(DistributedMatrixType), POINTER :: JACOBIAN_MATRIX
    TYPE(DistributedVectorType), POINTER :: residualVector
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMappingLinearType), POINTER :: linearMapping
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatricesLinearType), POINTER :: linearMatrices
    TYPE(EquationsMatrixType), POINTER :: equationsMatrix
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD,LAGRANGE_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: LINEAR_VARIABLE,INTERFACE_VARIABLE,LAGRANGE_VARIABLE
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(SOLVER_TYPE), POINTER :: LINEAR_SOLVER,SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_JACOBIAN
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(INTERFACE_MAPPING_TYPE), POINTER :: INTERFACE_MAPPING
    TYPE(INTERFACE_MATRICES_TYPE), POINTER :: INTERFACE_MATRICES
    TYPE(INTERFACE_MATRIX_TYPE), POINTER :: INTERFACE_MATRIX

    TYPE(VARYING_STRING) :: localError
  
    ENTERS("Solver_QuasiNewtonLinesearchCreateFinish",err,error,*999)

    IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
      QUASI_NEWTON_SOLVER=>LINESEARCH_SOLVER%QUASI_NEWTON_SOLVER
      IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
        NONLINEAR_SOLVER=>QUASI_NEWTON_SOLVER%NONLINEAR_SOLVER
        IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
          SOLVER=>NONLINEAR_SOLVER%SOLVER
          IF(ASSOCIATED(SOLVER)) THEN
            SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
            IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
              SELECT CASE(LINESEARCH_SOLVER%SOLVER_LIBRARY)
              CASE(SOLVER_CMISS_LIBRARY)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(SOLVER_PETSC_LIBRARY)
                SOLVER_MAPPING=>SOLVER_EQUATIONS%SOLVER_MAPPING
                IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                  !Loop over the equations set in the solver equations
                  DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                    EQUATIONS=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%EQUATIONS
                    IF(ASSOCIATED(EQUATIONS)) THEN
                      EQUATIONS_SET=>equations%equationsSet
                      IF(ASSOCIATED(EQUATIONS_SET)) THEN
                        DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
                        IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
                          NULLIFY(vectorEquations)
                          CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
                          vectorMapping=>vectorEquations%vectorMapping
                          IF(ASSOCIATED(vectorMapping)) THEN
                            linearMapping=>vectorMapping%linearMapping
                            IF(ASSOCIATED(linearMapping)) THEN
                              !If there are any linear matrices create temporary vector for matrix-vector products
                              vectorMatrices=>vectorEquations%vectorMatrices
                              IF(ASSOCIATED(vectorMatrices)) THEN
                                linearMatrices=>vectorMatrices%linearMatrices
                                IF(ASSOCIATED(linearMatrices)) THEN
                                  DO equations_matrix_idx=1,linearMatrices%numberOfLinearMatrices
                                    equationsMatrix=>linearMatrices%matrices(equations_matrix_idx)%ptr
                                    IF(ASSOCIATED(equationsMatrix)) THEN
                                      IF(.NOT.ASSOCIATED(equationsMatrix%tempVector)) THEN
                                        LINEAR_VARIABLE=>linearMapping%equationsMatrixToVarMaps(equations_matrix_idx)%VARIABLE
                                        IF(ASSOCIATED(LINEAR_VARIABLE)) THEN
                                          CALL DistributedVector_CreateStart(LINEAR_VARIABLE%DOMAIN_MAPPING, &
                                            & equationsMatrix%tempVector,err,error,*999)
                                          CALL DistributedVector_DataTypeSet(equationsMatrix%tempVector, &
                                            & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
                                          CALL DistributedVector_CreateFinish(equationsMatrix%tempVector,err,error,*999)
                                        ELSE
                                          CALL FlagError("Linear mapping linear variable is not associated.",err,error,*999)
                                        ENDIF
                                      ENDIF
                                    ELSE
                                      CALL FlagError("Equations matrix is not associated.",err,error,*999)
                                    ENDIF
                                  ENDDO !equations_matrix_idx
                                ELSE
                                  CALL FlagError("Equations matrices linear matrices is not associated.",err,error,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Equations equations matrices is not associated.",err,error,*999)
                              ENDIF
                            ENDIF
                          ELSE
                            CALL FlagError("Equations equations mapping is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          localError="Equations set dependent field is not associated for equations set index "// &
                            & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        localError="Equations equations set is not associated for equations set index "// &
                          & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                        CALL FlagError(localError,err,error,*999)
                      ENDIF
                    ELSE
                      localError="Equations is not associated for equations set index "// &
                        & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ENDDO !equations_set_idx
                  !Loop over the interface conditions
                  DO interface_condition_idx=1,SOLVER_MAPPING%NUMBER_OF_INTERFACE_CONDITIONS
                    INTERFACE_CONDITION=>SOLVER_MAPPING%INTERFACE_CONDITIONS(interface_condition_idx)%ptr
                    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
                      LAGRANGE_FIELD=>INTERFACE_CONDITION%LAGRANGE%LAGRANGE_FIELD
                      IF(ASSOCIATED(LAGRANGE_FIELD)) THEN
                        INTERFACE_EQUATIONS=>INTERFACE_CONDITION%INTERFACE_EQUATIONS
                        IF(ASSOCIATED(INTERFACE_EQUATIONS)) THEN
                          INTERFACE_MATRICES=>INTERFACE_EQUATIONS%INTERFACE_MATRICES
                          IF(ASSOCIATED(INTERFACE_MATRICES)) THEN
                            INTERFACE_MAPPING=>INTERFACE_EQUATIONS%INTERFACE_MAPPING
                            IF(ASSOCIATED(INTERFACE_MAPPING)) THEN
                              LAGRANGE_VARIABLE=>INTERFACE_MAPPING%LAGRANGE_VARIABLE
                              IF(ASSOCIATED(LAGRANGE_VARIABLE)) THEN
                                !Create temporary vector for matrix-vector products
                                DO interface_matrix_idx=1,INTERFACE_MAPPING%NUMBER_OF_INTERFACE_MATRICES
                                  INTERFACE_MATRIX=>INTERFACE_MATRICES%matrices(interface_matrix_idx)%ptr
                                  IF(ASSOCIATED(INTERFACE_MATRIX)) THEN
                                    IF(.NOT.ASSOCIATED(INTERFACE_MATRIX%TEMP_VECTOR)) THEN
                                      INTERFACE_VARIABLE=>INTERFACE_MAPPING% &
                                        & INTERFACE_MATRIX_ROWS_TO_VAR_MAPS(interface_matrix_idx)%VARIABLE
                                      IF(ASSOCIATED(INTERFACE_VARIABLE)) THEN
                                        !Set up the temporary interface distributed vector to be used with interface matrices
                                        CALL DistributedVector_CreateStart(INTERFACE_VARIABLE%DOMAIN_MAPPING, &
                                          & INTERFACE_MATRIX%TEMP_VECTOR,err,error,*999)
                                        CALL DistributedVector_DataTypeSet(INTERFACE_MATRIX%TEMP_VECTOR, &
                                          & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
                                        CALL DistributedVector_CreateFinish(INTERFACE_MATRIX%TEMP_VECTOR,err,error,*999)
                                        !Set up the temporary interface distributed vector to be used with transposed interface matrices
                                        CALL DistributedVector_CreateStart(LAGRANGE_VARIABLE%DOMAIN_MAPPING, &
                                          & INTERFACE_MATRIX%TEMP_TRANSPOSE_VECTOR,err,error,*999)
                                        CALL DistributedVector_DataTypeSet(INTERFACE_MATRIX%TEMP_TRANSPOSE_VECTOR, &
                                          & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
                                        CALL DistributedVector_CreateFinish(INTERFACE_MATRIX%TEMP_TRANSPOSE_VECTOR, &
                                          & err,error,*999)
                                      ELSE
                                        CALL FlagError("Interface mapping variable is not associated.",err,error,*999)
                                      ENDIF
                                    ENDIF
                                  ELSE
                                    CALL FlagError("Interface matrix is not associated.",err,error,*999)
                                  ENDIF
                                ENDDO !interface_matrix_idx
                              ELSE
                                CALL FlagError("Interface matrix is not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("interface condition mapping is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Interface matrices is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          localError="Interface eqauations is not associated for interface condition index "// &
                            & TRIM(NumberToVString(interface_condition_idx,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        localError="Interface condition Lagrange field is not associated for interface condition "// &
                          & TRIM(NumberToVString(interface_condition_idx,"*",err,error))//"."
                        CALL FlagError(localError,err,error,*999)
                      ENDIF
                    ELSE
                      localError="Interface condition is not associated for interface condition index "// &
                        & TRIM(NumberToVString(interface_condition_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ENDDO !interface_idx
                  !Create the PETSc SNES solver
                  CALL Petsc_SnesCreate(computationalEnvironment%mpiCommunicator,LINESEARCH_SOLVER%snes,err,error,*999)
                  !Set the nonlinear solver type to be a Quasi-Newton line search solver
                  CALL Petsc_SnesSetType(LINESEARCH_SOLVER%snes,PETSC_SNESQN,err,error,*999)
                  !Following routines don't work for petsc version < 3.5.
                 !Set the nonlinear Quasi-Newton type
                  SELECT CASE(QUASI_NEWTON_SOLVER%QUASI_NEWTON_TYPE)
                  CASE(SOLVER_QUASI_NEWTON_LBFGS)
                    CALL Petsc_SnesQNSetType(LINESEARCH_SOLVER%snes,PETSC_SNES_QN_LBFGS,err,error,*999)
                  CASE(SOLVER_QUASI_NEWTON_GOODBROYDEN)
                    CALL Petsc_SnesQNSetType(LINESEARCH_SOLVER%snes,PETSC_SNES_QN_BROYDEN,err,error,*999)
                  CASE(SOLVER_QUASI_NEWTON_BADBROYDEN)
                    CALL Petsc_SnesQNSetType(LINESEARCH_SOLVER%snes,PETSC_SNES_QN_BADBROYDEN,err,error,*999)
                  CASE DEFAULT
                      localError="The specified nonlinear Quasi-Newton type of "// &
                        & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%QUASI_NEWTON_TYPE,"*",err,error))//" is invalid."
                      CALL FlagError(localError,err,error,*999)
                  END SELECT
                  !Set the nonlinear Quasi-Newton restart type
                  SELECT CASE(QUASI_NEWTON_SOLVER%RESTART_TYPE)
                  CASE(SOLVER_QUASI_NEWTON_RESTART_NONE)
                    CALL Petsc_SnesQNSetRestartType(LINESEARCH_SOLVER%snes,PETSC_SNES_QN_RESTART_NONE,err,error,*999)
                  CASE(SOLVER_QUASI_NEWTON_RESTART_POWELL)
                    CALL Petsc_SnesQNSetRestartType(LINESEARCH_SOLVER%snes,PETSC_SNES_QN_RESTART_POWELL,err,error,*999)
                  CASE(SOLVER_QUASI_NEWTON_RESTART_PERIODIC)
                    CALL Petsc_SnesQNSetRestartType(LINESEARCH_SOLVER%snes,PETSC_SNES_QN_RESTART_PERIODIC,err,error,*999)
                  CASE DEFAULT
                      localError="The specified nonlinear Quasi-Newton restart type of "// &
                        & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%RESTART_TYPE,"*",err,error))//" is invalid."
                      CALL FlagError(localError,err,error,*999)
                  END SELECT
                  !Set the nonlinear Quasi-Newton scale type
                  SELECT CASE(QUASI_NEWTON_SOLVER%SCALE_TYPE)
                  CASE(SOLVER_QUASI_NEWTON_SCALE_NONE)
                    CALL Petsc_SnesQNSetScaleType(LINESEARCH_SOLVER%snes,PETSC_SNES_QN_SCALE_NONE,err,error,*999)
                  CASE(SOLVER_QUASI_NEWTON_SCALE_SHANNO)
                    CALL Petsc_SnesQNSetScaleType(LINESEARCH_SOLVER%snes,PETSC_SNES_QN_SCALE_SHANNO,err,error,*999)
                  CASE(SOLVER_QUASI_NEWTON_SCALE_LINESEARCH)
                    CALL Petsc_SnesQNSetScaleType(LINESEARCH_SOLVER%snes,PETSC_SNES_QN_SCALE_LINESEARCH,err,error,*999)
                  CASE(SOLVER_QUASI_NEWTON_SCALE_JACOBIAN)
                    CALL Petsc_SnesQNSetScaleType(LINESEARCH_SOLVER%snes,PETSC_SNES_QN_SCALE_JACOBIAN,err,error,*999)
                  CASE DEFAULT
                      localError="The specified nonlinear Quasi-Newton scale type of "// &
                        & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%SCALE_TYPE,"*",err,error))//" is invalid."
                      CALL FlagError(localError,err,error,*999)
                  END SELECT

                  !Set the Quasi-Newton restart
                  !Not implemented yet, as there is currently no routine in PETSc for this. If need be, this can be set in your petscrc file.
                  !Create the solver matrices and vectors
                  LINEAR_SOLVER=>QUASI_NEWTON_SOLVER%LINEAR_SOLVER
                  IF(ASSOCIATED(LINEAR_SOLVER)) THEN
                    NULLIFY(SOLVER_MATRICES)
                    CALL SOLVER_MATRICES_CREATE_START(SOLVER_EQUATIONS,SOLVER_MATRICES,err,error,*999)
                    CALL SolverMatrices_LibraryTypeSet(SOLVER_MATRICES,SOLVER_PETSC_LIBRARY,err,error,*999)
                    SELECT CASE(SOLVER_EQUATIONS%sparsityType)
                    CASE(SOLVER_SPARSE_MATRICES)
                      CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE], &
                        & err,error,*999)
                    CASE(SOLVER_FULL_MATRICES)
                      CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE], &
                        & err,error,*999)
                    CASE DEFAULT
                      localError="The specified solver equations sparsity type of "// &
                        & TRIM(NumberToVString(SOLVER_EQUATIONS%sparsityType,"*",err,error))//" is invalid."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                    SELECT CASE(SOLVER_EQUATIONS%symmetryType)
                    CASE(SOLVER_SYMMETRIC_MATRICES)
                      CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_SYMMETRIC_TYPE],err,error,*999)
                    CASE(SOLVER_UNSYMMETRIC_MATRICES)
                      CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_UNSYMMETRIC_TYPE],err,error,*999)
                    CASE DEFAULT
                      localError="The specified solver equations symmetry type of "// &
                        & TRIM(NumberToVString(SOLVER_EQUATIONS%symmetryType,"*",err,error))// &
                        & " is invalid."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                    CALL SOLVER_MATRICES_CREATE_FINISH(SOLVER_MATRICES,err,error,*999)
                    !Link linear solver
                    LINEAR_SOLVER%SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
                    !Finish the creation of the linear solver
                    CALL SOLVER_LINEAR_CREATE_FINISH(LINEAR_SOLVER%LINEAR_SOLVER,err,error,*999)
                    !Associate linear solver's KSP to nonlinear solver's SNES
                    SELECT CASE(LINEAR_SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE)
                    CASE(SOLVER_LINEAR_DIRECT_SOLVE_TYPE)
                      CALL Petsc_SnesSetKsp(linesearch_solver%snes,linear_solver%linear_solver%direct_solver%ksp,err,error,*999)
                    CASE(SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE)
                      CALL Petsc_SnesSetKsp(linesearch_solver%snes,linear_solver%linear_solver%iterative_solver%ksp,err,error,*999)
                    END SELECT

                    !Set the nonlinear function
                    residualVector=>SOLVER_MATRICES%RESIDUAL
                    IF(ASSOCIATED(residualVector)) THEN
                      IF(ASSOCIATED(residualVector%PETSC)) THEN
                        !Pass the linesearch solver object rather than the temporary solver
                        CALL Petsc_SnesSetFunction(LINESEARCH_SOLVER%snes,residualVector%PETSC%VECTOR, &
                          & Problem_SolverResidualEvaluatePetsc,LINESEARCH_SOLVER%QUASI_NEWTON_SOLVER%NONLINEAR_SOLVER%SOLVER, &
                          & err,error,*999)
                        SELECT CASE(LINESEARCH_SOLVER%QUASI_NEWTON_SOLVER%convergenceTestType)
                        CASE(SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT)
                          !Default convergence test, do nothing
                        CASE(SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM,SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO)
                          CALL Petsc_SnesSetConvergenceTest(LINESEARCH_SOLVER%snes,Problem_SolverConvergenceTestPetsc, &
                            & LINESEARCH_SOLVER%QUASI_NEWTON_SOLVER%NONLINEAR_SOLVER%SOLVER,err,error,*999)
                        CASE DEFAULT
                          localError="The specified convergence test type of "//TRIM(NumberToVString(LINESEARCH_SOLVER% &
                            & QUASI_NEWTON_SOLVER%convergenceTestType,"*",err,error))//" is invalid."
                          CALL FlagError(localError,err,error,*999)
                        END SELECT
                      ELSE
                        CALL FlagError("The residual vector PETSc is not associated.",err,error,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Solver matrices residual vector is not associated.",err,error,*999)
                    ENDIF
                  
                    !Set the Jacobian
                    IF(SOLVER_MATRICES%NUMBER_OF_MATRICES==1) THEN
                      SOLVER_JACOBIAN=>SOLVER_MATRICES%matrices(1)%ptr
                      IF(ASSOCIATED(SOLVER_JACOBIAN)) THEN
                        JACOBIAN_MATRIX=>SOLVER_JACOBIAN%MATRIX
                        IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN
                          IF(ASSOCIATED(JACOBIAN_MATRIX%PETSC)) THEN
                            SELECT CASE(QUASI_NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE)
                            CASE(SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED)
                              CALL FlagError("Cannot have no Jacobian calculation for a PETSc nonlinear linesearch solver.", &
                                & err,error,*999)
                            CASE(SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED)
                              SOLVER_JACOBIAN%UPDATE_MATRIX=.TRUE. !CMISS will fill in the Jacobian values
                              !Pass the linesearch solver object rather than the temporary solver
                              CALL Petsc_SnesSetJacobian(LINESEARCH_SOLVER%snes,JACOBIAN_MATRIX%PETSC%MATRIX, &
                                & JACOBIAN_MATRIX%PETSC%MATRIX,Problem_SolverJacobianEvaluatePetsc, &
                                & LINESEARCH_SOLVER%QUASI_NEWTON_SOLVER%NONLINEAR_SOLVER%SOLVER,err,error,*999)
                            CASE(SOLVER_NEWTON_JACOBIAN_FD_CALCULATED)
                              SOLVER_JACOBIAN%UPDATE_MATRIX=.FALSE. !Petsc will fill in the Jacobian values
                              CALL DistributedMatrix_Form(JACOBIAN_MATRIX,err,error,*999)
                              SELECT CASE(SOLVER_EQUATIONS%sparsityType)
                              CASE(SOLVER_SPARSE_MATRICES)
                                CALL Petsc_MatColoringCreate(JACOBIAN_MATRIX%PETSC%MATRIX,LINESEARCH_SOLVER%jacobianMatColoring, &
                                  & err,error,*999)
                                CALL Petsc_MatColoringSetType(LINESEARCH_SOLVER%jacobianMatColoring,PETSC_MATCOLORING_SL, &
                                  & err,error,*999)
                                CALL Petsc_MatColoringSetFromOptions(LINESEARCH_SOLVER%jacobianMatColoring,err,error,*999)
                                CALL Petsc_MatColoringApply(LINESEARCH_SOLVER%jacobianMatColoring,LINESEARCH_SOLVER% &
                                  & jacobianISColoring,err,error,*999)
                                CALL Petsc_MatColoringDestroy(LINESEARCH_SOLVER%jacobianMatColoring,err,error,*999)
                                CALL Petsc_MatFDColoringCreate(JACOBIAN_MATRIX%PETSC%MATRIX,LINESEARCH_SOLVER% &
                                  & jacobianISColoring,LINESEARCH_SOLVER%jacobianMatFDColoring,err,error,*999)
                                 CALL Petsc_MatFDColoringSetFunction(LINESEARCH_SOLVER%jacobianMatFDColoring, &
                                  & Problem_SolverResidualEvaluatePetsc,LINESEARCH_SOLVER%QUASI_NEWTON_SOLVER%NONLINEAR_SOLVER% &
                                  & SOLVER,err,error,*999)
                                CALL Petsc_MatFDColoringSetFromOptions(LINESEARCH_SOLVER%jacobianMatFDColoring,err,error,*999)
                                CALL Petsc_MatFDColoringSetup(JACOBIAN_MATRIX%PETSC%MATRIX,LINESEARCH_SOLVER% &
                                  & jacobianISColoring,LINESEARCH_SOLVER%jacobianMatFDColoring,err,error,*999)
                                CALL Petsc_ISColoringDestroy(LINESEARCH_SOLVER%jacobianISColoring,err,error,*999)
                              CASE(SOLVER_FULL_MATRICES)
                                !Do nothing
                              CASE DEFAULT
                                localError="The specified solver equations sparsity type of "// &
                                  & TRIM(NumberToVString(SOLVER_EQUATIONS%sparsityType,"*",err,error))//" is invalid."
                                CALL FlagError(localError,err,error,*999)
                              END SELECT
                              CALL Petsc_SnesSetJacobian(LINESEARCH_SOLVER%snes,JACOBIAN_MATRIX%PETSC%MATRIX, &
                                & JACOBIAN_MATRIX%PETSC%MATRIX,Problem_SolverJacobianFDCalculatePetsc,LINESEARCH_SOLVER% &
                                & QUASI_NEWTON_SOLVER%NONLINEAR_SOLVER%SOLVER,err,error,*999)
                            CASE DEFAULT
                              localError="The Jacobian calculation type of "// &
                                & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE,"*",err,error))// &
                                & " is invalid."
                              CALL FlagError(localError,err,error,*999)
                            END SELECT
                          ELSE
                            CALL FlagError("Jacobian matrix PETSc is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Solver Jacobian matrix is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("The solver Jacobian is not associated.",err,error,*999)
                      ENDIF
                    ELSE
                      localError="Invalid number of solver matrices. The number of solver matrices is "// &
                        & TRIM(NumberToVString(SOLVER_MATRICES%NUMBER_OF_MATRICES,"*",err,error))//" and it should be 1."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                    IF(SOLVER%outputType>=SOLVER_MONITOR_OUTPUT) THEN
                      !Set the monitor
                      !Pass the linesearch solver object rather than the temporary solver
                      CALL Petsc_SnesMonitorSet(LINESEARCH_SOLVER%snes,Problem_SolverNonlinearMonitorPETSC, &
                        & LINESEARCH_SOLVER%QUASI_NEWTON_SOLVER%NONLINEAR_SOLVER%SOLVER,err,error,*999)
                    ENDIF
                    CALL Petsc_SnesGetLineSearch(linesearch_solver%snes,linesearch_solver%snesLineSearch,err,error,*999)
                    !Set the line search type and order where applicable
                    SELECT CASE(linesearch_solver%linesearch_type)
                    CASE(SOLVER_QUASI_NEWTON_LINESEARCH_BASIC)
                      CALL Petsc_SnesLineSearchSetType(linesearch_solver%snesLineSearch,PETSC_SNES_LINESEARCH_BASIC,err,error,*999)
                    CASE(SOLVER_QUASI_NEWTON_LINESEARCH_L2)
                      CALL Petsc_SnesLineSearchSetType(linesearch_solver%snesLineSearch,PETSC_SNES_LINESEARCH_L2,err,error,*999)
                    CASE(SOLVER_QUASI_NEWTON_LINESEARCH_CP)
                      CALL Petsc_SnesLineSearchSetType(linesearch_solver%snesLineSearch,PETSC_SNES_LINESEARCH_CP,err,error,*999)
                    CASE DEFAULT
                      localError="The nonlinear Quasi-Newton line search type of "// &
                        & TRIM(NumberToVString(linesearch_solver%linesearch_type,"*",err,error))//" is invalid."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                    ! Set step tolerances, leave iterative line search options as defaults
                    CALL Petsc_SnesLineSearchSetTolerances(linesearch_solver%snesLineSearch, &
                      & LINESEARCH_SOLVER%LINESEARCH_STEPTOLERANCE,LINESEARCH_SOLVER%LINESEARCH_MAXSTEP, &
                      & PETSC_DEFAULT_REAL,PETSC_DEFAULT_REAL,PETSC_DEFAULT_REAL, &
                      & PETSC_DEFAULT_INTEGER,err,error,*999)
                    IF(linesearch_solver%linesearchMonitorOutput) THEN
                      CALL Petsc_SnesLineSearchSetMonitor(linesearch_solver%snesLineSearch,PETSC_TRUE,err,error,*999)
                    ELSE
                      CALL Petsc_SnesLineSearchSetMonitor(linesearch_solver%snesLineSearch,PETSC_FALSE,err,error,*999)
                    ENDIF
                    !Set the tolerances for the SNES solver
                    CALL Petsc_SnesSetTolerances(LINESEARCH_SOLVER%snes,QUASI_NEWTON_SOLVER%ABSOLUTE_TOLERANCE, &
                      & QUASI_NEWTON_SOLVER%RELATIVE_TOLERANCE,QUASI_NEWTON_SOLVER%SOLUTION_TOLERANCE, &
                      & QUASI_NEWTON_SOLVER%MAXIMUM_NUMBER_OF_ITERATIONS, &
                      & QUASI_NEWTON_SOLVER%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS,err,error,*999)
                    !Set any further SNES options from the command line options
                    CALL Petsc_SnesSetFromOptions(LINESEARCH_SOLVER%snes,err,error,*999)
                  ELSE
                    CALL FlagError("Quasi-Newton linesearch solver linear solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Solver equations solver mapping is not associated.",err,error,*999)
                ENDIF
              CASE DEFAULT
                localError="The solver library type of "// &
                  & TRIM(NumberToVString(LINESEARCH_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              CALL FlagError("Solver solver equations is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Nonlinear solver solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Quasi-Newton solver nonlinear solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Linesearch solver Quasi-Newton solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Line search solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_QuasiNewtonLinesearchCreateFinish")
    RETURN
999 ERRORSEXITS("Solver_QuasiNewtonLinesearchCreateFinish",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_QuasiNewtonLinesearchCreateFinish

  !
  !================================================================================================================================
  !

  !>Finalise a nonlinear Quasi-Newton line search solver and deallocate all memory
  SUBROUTINE Solver_QuasiNewtonLinesearchFinalise(linesearchSolver,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: linesearchSolver !<A pointer the nonlinear Quasi-Newton line search solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
  
    ENTERS("Solver_QuasiNewtonLinesearchFinalise",err,error,*999)

    IF(ASSOCIATED(linesearchSolver)) THEN
      CALL Petsc_ISColoringFinalise(linesearchSolver%jacobianISColoring,err,error,*999)
      CALL Petsc_MatColoringFinalise(linesearchSolver%jacobianMatColoring,err,error,*999)
      CALL Petsc_MatFDColoringFinalise(linesearchSolver%jacobianMatFDColoring,err,error,*999)
      CALL Petsc_SnesLineSearchFinalise(linesearchSolver%snesLineSearch,err,error,*999)
      CALL Petsc_SnesFinalise(linesearchSolver%snes,err,error,*999)
      DEALLOCATE(linesearchSolver)
    ENDIF
        
    EXITS("Solver_QuasiNewtonLinesearchFinalise")
    RETURN
999 ERRORSEXITS("Solver_QuasiNewtonLinesearchFinalise",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_QuasiNewtonLinesearchFinalise

  !
  !================================================================================================================================
  !

  !>Initialise a nonlinear Quasi-Newton line search solver for a Quasi-Newton solver
  SUBROUTINE SOLVER_QUASI_NEWTON_LINESEARCH_INITIALISE(QUASI_NEWTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER !<A pointer the nonlinear Quasi-Newton solver to initialise the Quasi-Newton line search solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
  
    ENTERS("SOLVER_QUASI_NEWTON_LINESEARCH_INITIALISE",err,error,*998)

    IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
      IF(ASSOCIATED(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER)) THEN
        CALL FlagError("Quasi-Newton line search solver is already associated for this Quasi-Newton solver.",err,error,*998)
      ELSE
        !Allocate and initialise the Quasi-Newton linesearch solver
        ALLOCATE(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate nonlinear solver Quasi-Newton line search solver.",err,error,*999)
        QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER%QUASI_NEWTON_SOLVER=>QUASI_NEWTON_SOLVER
        QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
        QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER%LINESEARCH_TYPE=SOLVER_QUASI_NEWTON_LINESEARCH_CP
        QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER%LINESEARCH_MAXSTEP=1.0E8_DP
        QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER%LINESEARCH_STEPTOLERANCE=CONVERGENCE_TOLERANCE
        CALL Petsc_MatColoringInitialise(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER%jacobianMatColoring,err,error,*999)
        CALL Petsc_ISColoringInitialise(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER%jacobianISColoring,err,error,*999)
        CALL Petsc_MatFDColoringInitialise(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER%jacobianMatFDColoring,err,error,*999)
        CALL Petsc_SnesInitialise(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER%snes,err,error,*999)
        CALL Petsc_SnesLinesearchInitialise(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER%snesLineSearch,err,error,*999)
        QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER%linesearchMonitorOutput=.false.
      ENDIF
    ELSE
      CALL FlagError("Quasi-Newton solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_QUASI_NEWTON_LINESEARCH_INITIALISE")
    RETURN
999 CALL Solver_QuasiNewtonLinesearchFinalise(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_QUASI_NEWTON_LINESEARCH_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_LINESEARCH_INITIALISE

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a nonlinear Quasi-Newton linesearch solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonLineSearchMaxStepSet
  SUBROUTINE SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,LINESEARCH_MAXSTEP,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the line search maximum step for
    REAL(DP), INTENT(IN) :: LINESEARCH_MAXSTEP !<The line search maximum step to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE==SOLVER_QUASI_NEWTON_LINESEARCH) THEN
                  LINESEARCH_SOLVER=>QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER
                  IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
                    IF(LINESEARCH_MAXSTEP>ZERO_TOLERANCE) THEN
                      LINESEARCH_SOLVER%LINESEARCH_MAXSTEP=LINESEARCH_MAXSTEP
                    ELSE
                      localError="The specified line search maximum step of "// &
                        & TRIM(NumberToVString(LINESEARCH_MAXSTEP,"*",err,error))// &
                        & " is invalid. The line search maximum step must be > 0."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The Quasi-Newton solver line search solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Quasi-Newton solver is not a line search solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET
        
  !
  !================================================================================================================================
  !

  !Solves a nonlinear Quasi-Newton line search solver 
  SUBROUTINE SOLVER_QUASI_NEWTON_LINESEARCH_SOLVE(LINESEARCH_SOLVER,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER !<A pointer to the nonlinear Quasi-Newton line search solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    !EXTERNAL :: Problem_SolverResidualEvaluatePetsc
    INTEGER(INTG) :: CONVERGED_REASON,NUMBER_ITERATIONS
    REAL(DP) :: FUNCTION_NORM
    TYPE(DistributedVectorType), POINTER :: rhsVector,SOLVER_VECTOR
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(PetscVecType) :: FUNCTION_VECTOR
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_QUASI_NEWTON_LINESEARCH_SOLVE",err,error,*999)

    IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
      QUASI_NEWTON_SOLVER=>LINESEARCH_SOLVER%QUASI_NEWTON_SOLVER
      IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
        NONLINEAR_SOLVER=>QUASI_NEWTON_SOLVER%NONLINEAR_SOLVER
        IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
          SOLVER=>NONLINEAR_SOLVER%SOLVER
          IF(ASSOCIATED(SOLVER)) THEN
            SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
            IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
              SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
              IF(ASSOCIATED(SOLVER_MATRICES)) THEN
                IF(SOLVER_MATRICES%NUMBER_OF_MATRICES==1) THEN
                  rhsVector=>SOLVER_MATRICES%RHS_VECTOR
                  IF(ASSOCIATED(rhsVector)) THEN
                    SOLVER_VECTOR=>SOLVER_MATRICES%matrices(1)%ptr%SOLVER_VECTOR
                    IF(ASSOCIATED(SOLVER_VECTOR)) THEN
                      SELECT CASE(LINESEARCH_SOLVER%SOLVER_LIBRARY)
                      CASE(SOLVER_CMISS_LIBRARY)
                        CALL FlagError("Not implemented.",err,error,*999)
                      CASE(SOLVER_PETSC_LIBRARY)
                        SELECT CASE(QUASI_NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE)
                        CASE(SOLVER_SOLUTION_INITIALISE_ZERO)
                          !Zero the solution vector
                          CALL DistributedVector_AllValuesSet(SOLVER_VECTOR,0.0_DP,err,error,*999)
                        CASE(SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD)
                          !Make sure the solver vector contains the current dependent field values
                          CALL SOLVER_SOLUTION_UPDATE(SOLVER,err,error,*999)
                        CASE(SOLVER_SOLUTION_INITIALISE_NO_CHANGE)
                          !Do nothing
                        CASE DEFAULT
                          localError="The Quasi-Newton solver solution initialise type of "// &
                            & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE,"*",err,error))// &
                            & " is invalid."
                          CALL FlagError(localError,err,error,*999)
                        END SELECT
                        !Solve the nonlinear equations
                        CALL Petsc_SnesSolve(LINESEARCH_SOLVER%snes,rhsVector%PETSC%VECTOR,SOLVER_VECTOR%PETSC%VECTOR, &
                          & err,error,*999)
                        !Check for convergence
                        CALL Petsc_SnesGetConvergedReason(LINESEARCH_SOLVER%snes,CONVERGED_REASON,err,error,*999)
                        SELECT CASE(CONVERGED_REASON)
                        CASE(PETSC_SNES_DIVERGED_FUNCTION_COUNT)
                          CALL FLAG_WARNING("Nonlinear line search solver did not converge. PETSc diverged function count.", &
                            & err,error,*999)
                        CASE(PETSC_SNES_DIVERGED_LINEAR_SOLVE)
                          CALL FLAG_WARNING("Nonlinear line search solver did not converge. PETSc diverged linear solve.", &
                            & err,error,*999)
                        CASE(PETSC_SNES_DIVERGED_FNORM_NAN)
                          CALL FLAG_WARNING("Nonlinear line search solver did not converge. PETSc diverged F Norm NaN.", &
                            & err,error,*999)
                        CASE(PETSC_SNES_DIVERGED_MAX_IT)
                          CALL FLAG_WARNING("Nonlinear line search solver did not converge. PETSc diverged maximum iterations.", &
                            & err,error,*999)
                        CASE(PETSC_SNES_DIVERGED_LINE_SEARCH)
                          CALL FLAG_WARNING("Nonlinear line search solver did not converge. PETSc diverged line search.", &
                            & err,error,*999)
                        CASE(PETSC_SNES_DIVERGED_LOCAL_MIN)
                          CALL FLAG_WARNING("Nonlinear line search solver did not converge. PETSc diverged local minimum.", &
                            & err,error,*999)
                        END SELECT
                         IF(SOLVER%outputType>=SOLVER_SOLVER_OUTPUT) THEN
                          !Output solution characteristics
                          CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
                          CALL WriteString(GENERAL_OUTPUT_TYPE,"Quasi-Newton linesearch solver parameters:",err,error,*999)
                          CALL Petsc_SnesGetIterationNumber(LINESEARCH_SOLVER%snes,NUMBER_ITERATIONS,err,error,*999)
                          CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Final number of iterations = ",NUMBER_ITERATIONS, &
                            & err,error,*999)
                          CALL Petsc_SnesGetFunction(LINESEARCH_SOLVER%snes,FUNCTION_VECTOR,err,error,*999)
                          CALL Petsc_VecNorm(FUNCTION_VECTOR,PETSC_NORM_2,FUNCTION_NORM,err,error,*999)
                          CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Final function norm = ",FUNCTION_NORM, &
                            & err,error,*999)
                          SELECT CASE(CONVERGED_REASON)
                          CASE(PETSC_SNES_CONVERGED_FNORM_ABS)
                            CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged F Norm absolute.", &
                              & err,error,*999)
                          CASE(PETSC_SNES_CONVERGED_FNORM_RELATIVE)
                            CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged F Norm relative.", &
                              & err,error,*999)
                          CASE(PETSC_SNES_CONVERGED_ITS)
                            CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged its.",err,error,*999)
                          CASE(PETSC_SNES_CONVERGED_ITERATING)
                            CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged iterating.",err,error,*999)
                          END SELECT
                        ENDIF
                      CASE DEFAULT
                        localError="The Quasi-Newton line search solver library type of "// &
                          & TRIM(NumberToVString(LINESEARCH_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
                        CALL FlagError(localError,err,error,*999)
                      END SELECT
                    ELSE
                      CALL FlagError("Solver vector is not associated.",err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Solver RHS vector is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  localError="The number of solver matrices of "// &
                    & TRIM(NumberToVString(SOLVER_MATRICES%NUMBER_OF_MATRICES,"*",err,error))// &
                    & " is invalid. There should only be one solver matrix for a Quasi-Newton linesearch solver."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Solver matrices is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver solver equations is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Nonlinear solver solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Quasi-Newton solver nonlinear solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Linesearch solver Quasi-Newton solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Linesearch solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_LINESEARCH_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_LINESEARCH_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_LINESEARCH_SOLVE
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a nonlinear Quasi-Newton line search solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonLineSearchStepTolSet
  SUBROUTINE SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,LINESEARCH_STEPTOL,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the line search step tolerance for
    REAL(DP), INTENT(IN) :: LINESEARCH_STEPTOL !<The line search step tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET",err,error,*999)
    
    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE==SOLVER_QUASI_NEWTON_LINESEARCH) THEN
                  LINESEARCH_SOLVER=>QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER
                  IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
                    IF(LINESEARCH_STEPTOL>ZERO_TOLERANCE) THEN
                      LINESEARCH_SOLVER%LINESEARCH_STEPTOLERANCE=LINESEARCH_STEPTOL
                    ELSE
                      localError="The specified line search step tolerance of "// &
                        & TRIM(NumberToVString(LINESEARCH_STEPTOL,"*",err,error))// &
                        & " is invalid. The line search step tolerance must be > 0."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The Quasi-Newton solver line search solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Quasi-Newton solver is not a line search solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The nonlinear Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the line search type for a nonlinear Quasi-Newton linesearch solver \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonLineSearchTypeSet
  SUBROUTINE SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET(SOLVER,LINESEARCH_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the line search type for
    INTEGER(INTG), INTENT(IN) :: LINESEARCH_TYPE !<The line search type to set \see SOLVER_ROUTINES_QuasiNewtonLineSearchTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE==SOLVER_QUASI_NEWTON_LINESEARCH) THEN
                  LINESEARCH_SOLVER=>QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER
                  IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
                    SELECT CASE(LINESEARCH_TYPE)
                    CASE(SOLVER_QUASI_NEWTON_LINESEARCH_BASIC)
                      LINESEARCH_SOLVER%LINESEARCH_TYPE=SOLVER_QUASI_NEWTON_LINESEARCH_BASIC
                    CASE(SOLVER_QUASI_NEWTON_LINESEARCH_L2)
                      LINESEARCH_SOLVER%LINESEARCH_TYPE=SOLVER_QUASI_NEWTON_LINESEARCH_L2
                    CASE(SOLVER_QUASI_NEWTON_LINESEARCH_CP)
                      LINESEARCH_SOLVER%LINESEARCH_TYPE=SOLVER_QUASI_NEWTON_LINESEARCH_CP
                    CASE DEFAULT
                      localError="The specified line search type of "//TRIM(NumberToVString(LINESEARCH_TYPE,"*",err,error))// &
                        & " is invalid."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    CALL FlagError("The Quasi-Newton solver line search solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Quasi-Newton solver is not a line search solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a nonlinear Quasi-Newton solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonMaximumFunctionEvaluationsSet
  SUBROUTINE Solver_QuasiNewtonMaximumFunctionEvaluationsSet(SOLVER,MAXIMUM_FUNCTION_EVALUATIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the maximum function evaluations for
    INTEGER(INTG), INTENT(IN) :: MAXIMUM_FUNCTION_EVALUATIONS !<The maximum function evaluations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_QuasiNewtonMaximumFunctionEvaluationsSet",err,error,*999)
    
    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(MAXIMUM_FUNCTION_EVALUATIONS>0) THEN
                  QUASI_NEWTON_SOLVER%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS=MAXIMUM_FUNCTION_EVALUATIONS
                ELSE
                  localError="The specified maximum number of function evaluations of "// &
                    & TRIM(NumberToVString(MAXIMUM_FUNCTION_EVALUATIONS,"*",err,error))// &
                    & " is invalid. The maximum number of function evaluations must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_QuasiNewtonMaximumFunctionEvaluationsSet")
    RETURN
999 ERRORS("Solver_QuasiNewtonMaximumFunctionEvaluationsSet",err,error)
    EXITS("Solver_QuasiNewtonMaximumFunctionEvaluationsSet")
    RETURN 1
   
  END SUBROUTINE Solver_QuasiNewtonMaximumFunctionEvaluationsSet
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a nonlinear Quasi-Newton solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonMaximumIterationsSet
  SUBROUTINE SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,MAXIMUM_ITERATIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the maximum iterations for
    INTEGER(INTG), INTENT(IN) :: MAXIMUM_ITERATIONS !<The maximum iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(MAXIMUM_ITERATIONS>0) THEN
                  QUASI_NEWTON_SOLVER%MAXIMUM_NUMBER_OF_ITERATIONS=MAXIMUM_ITERATIONS
                ELSE
                  localError="The specified maximum iterations of "//TRIM(NumberToVString(MAXIMUM_ITERATIONS,"*",err,error))// &
                    & " is invalid. The maximum number of iterations must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear sovler Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a nonlinear Quasi-Newton solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonRelativeToleranceSet
  SUBROUTINE SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,RELATIVE_TOLERANCE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the relative tolerance for
    REAL(DP), INTENT(IN) :: RELATIVE_TOLERANCE !<The relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(RELATIVE_TOLERANCE>ZERO_TOLERANCE) THEN
                  QUASI_NEWTON_SOLVER%RELATIVE_TOLERANCE=RELATIVE_TOLERANCE
                ELSE
                  localError="The specified relative tolerance of "//TRIM(NumberToVString(RELATIVE_TOLERANCE,"*",err,error))// &
                    & " is invalid. The relative tolerance must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the solution initialisation for a nonlinear Quasi-Newton solver
  SUBROUTINE SOLVER_QUASI_NEWTON_SOLUTION_INIT_TYPE_SET(SOLVER,SOLUTION_INITIALISE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the solution tolerance for
    INTEGER(INTG), INTENT(IN) :: SOLUTION_INITIALISE_TYPE !<The solution initialise type to set \see SOLVER_ROUTINES_SolutionInitialiseTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_SOLUTION_INIT_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                SELECT CASE(SOLUTION_INITIALISE_TYPE)
                CASE(SOLVER_SOLUTION_INITIALISE_ZERO)
                  QUASI_NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_ZERO
                CASE(SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD)
                  QUASI_NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD
                CASE(SOLVER_SOLUTION_INITIALISE_NO_CHANGE)
                  QUASI_NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_NO_CHANGE
                CASE DEFAULT
                  localError="The specified solution initialise type  of "// &
                    & TRIM(NumberToVString(SOLUTION_INITIALISE_TYPE,"*",err,error))//" is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF            
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_SOLUTION_INIT_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_SOLUTION_INIT_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_SOLUTION_INIT_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a nonlinear Quasi-Newton solver. \see OpenCMISS::Iron::cmfe_SolverNewtonSolutionToleranceSet
  SUBROUTINE SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,SOLUTION_TOLERANCE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the solution tolerance for
    REAL(DP), INTENT(IN) :: SOLUTION_TOLERANCE !<The solution tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(SOLUTION_TOLERANCE>ZERO_TOLERANCE) THEN
                  QUASI_NEWTON_SOLVER%SOLUTION_TOLERANCE=SOLUTION_TOLERANCE
                ELSE
                  localError="The specified solution tolerance of "//TRIM(NumberToVString(SOLUTION_TOLERANCE,"*",err,error))// &
                    & " is invalid. The relative tolerance must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF            
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET
        
  !
  !================================================================================================================================
  !

  !Solves a nonlinear Quasi-Newton solver 
  SUBROUTINE SOLVER_QUASI_NEWTON_SOLVE(QUASI_NEWTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER !<A pointer to the nonlinear Quasi-Newton solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_QUASI_NEWTON_SOLVE",err,error,*999)

    IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
      SELECT CASE(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE)
      CASE(SOLVER_QUASI_NEWTON_LINESEARCH)
        CALL SOLVER_QUASI_NEWTON_LINESEARCH_SOLVE(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER,err,error,*999)
      CASE(SOLVER_QUASI_NEWTON_TRUSTREGION)
        CALL SOLVER_QUASI_NEWTON_TRUSTREGION_SOLVE(QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER,err,error,*999)
      CASE DEFAULT
        localError="The nonlinear solver type of "// &
          & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Quasi-Newton solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_QUASI_NEWTON_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_SOLVE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_QUASI_NEWTON_SOLVE
        
  !
  !================================================================================================================================
  !

  !>Finishes the process of creating nonlinear Quasi-Newton trust region solver
  SUBROUTINE Solver_QuasiNewtonTrustRegionCreateFinish(TRUSTREGION_SOLVER,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER !<A pointer the nonlinear Quasi-Newton trust region solver to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    EXTERNAL :: Problem_SolverResidualEvaluatePetsc
    INTEGER(INTG) :: equations_matrix_idx,equations_set_idx
    TYPE(DistributedVectorType), POINTER :: residualVector
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMappingLinearType), POINTER :: linearMapping
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatricesLinearType), POINTER :: linearMatrices
    TYPE(EquationsMatrixType), POINTER :: equationsMatrix
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: LINEAR_VARIABLE
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError
  
    ENTERS("Solver_QuasiNewtonTrustRegionCreateFinish",err,error,*999)

    IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
      QUASI_NEWTON_SOLVER=>TRUSTREGION_SOLVER%QUASI_NEWTON_SOLVER
      IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
        NONLINEAR_SOLVER=>QUASI_NEWTON_SOLVER%NONLINEAR_SOLVER
        IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
          SOLVER=>NONLINEAR_SOLVER%SOLVER
          IF(ASSOCIATED(SOLVER)) THEN
            SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
            IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
              SELECT CASE(TRUSTREGION_SOLVER%SOLVER_LIBRARY)
              CASE(SOLVER_CMISS_LIBRARY)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(SOLVER_PETSC_LIBRARY)
                SOLVER_MAPPING=>SOLVER_EQUATIONS%SOLVER_MAPPING
                IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                  !Loop over the equations set in the solver equations
                  DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                    EQUATIONS=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%EQUATIONS
                    IF(ASSOCIATED(EQUATIONS)) THEN
                      EQUATIONS_SET=>equations%equationsSet
                      IF(ASSOCIATED(EQUATIONS_SET)) THEN
                        DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
                        IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
                          NULLIFY(vectorEquations)
                          CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
                          vectorMapping=>vectorEquations%vectorMapping
                          IF(ASSOCIATED(vectorMapping)) THEN
                            linearMapping=>vectorMapping%linearMapping
                            IF(ASSOCIATED(linearMapping)) THEN
                              !If there are any linear matrices create temporary vector for matrix-vector products
                              vectorMatrices=>vectorEquations%vectorMatrices
                              IF(ASSOCIATED(vectorMatrices)) THEN
                                linearMatrices=>vectorMatrices%linearMatrices
                                IF(ASSOCIATED(linearMatrices)) THEN
                                  DO equations_matrix_idx=1,linearMatrices%numberOfLinearMatrices
                                    equationsMatrix=>linearMatrices%matrices(equations_matrix_idx)%ptr
                                    IF(ASSOCIATED(equationsMatrix)) THEN
                                      IF(.NOT.ASSOCIATED(equationsMatrix%tempVector)) THEN
                                        LINEAR_VARIABLE=>linearMapping%equationsMatrixToVarMaps(equations_matrix_idx)%VARIABLE
                                        IF(ASSOCIATED(LINEAR_VARIABLE)) THEN
                                          CALL DistributedVector_CreateStart(LINEAR_VARIABLE%DOMAIN_MAPPING, &
                                            & equationsMatrix%tempVector,err,error,*999)
                                          CALL DistributedVector_DataTypeSet(equationsMatrix%tempVector, &
                                            & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
                                          CALL DistributedVector_CreateFinish(equationsMatrix%tempVector,err,error,*999)
                                        ELSE
                                          CALL FlagError("Linear mapping linear variable is not associated.",err,error,*999)
                                        ENDIF
                                      ENDIF
                                    ELSE
                                      CALL FlagError("Equations matrix is not associated.",err,error,*999)
                                    ENDIF
                                  ENDDO !equations_matrix_idx
                                ELSE
                                  CALL FlagError("Equations matrices linear matrices is not associated.",err,error,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Equations equations matrices is not associated.",err,error,*999)
                              ENDIF
                            ENDIF
                          ELSE
                            CALL FlagError("Equations equations mapping is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          localError="Equations set dependent field is not associated for equations set index "// &
                            & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        localError="Equations equations set is not associated for equations set index "// &
                          & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                        CALL FlagError(localError,err,error,*999)
                      ENDIF
                    ELSE
                      localError="Equations is not associated for equations set index "// &
                        & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ENDDO !equations_set_idx
                  
                  !Create the solver matrices and vectors
                  CALL SOLVER_MATRICES_CREATE_START(SOLVER_EQUATIONS,SOLVER_MATRICES,err,error,*999)
                  CALL SolverMatrices_LibraryTypeSet(SOLVER_MATRICES,SOLVER_PETSC_LIBRARY,err,error,*999)
!!TODO: set up the matrix structure if using an analytic Jacobian
                  SELECT CASE(SOLVER_EQUATIONS%symmetryType)
                  CASE(SOLVER_SYMMETRIC_MATRICES)
                    CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_SYMMETRIC_TYPE],err,error,*999)
                  CASE(SOLVER_UNSYMMETRIC_MATRICES)
                    CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_UNSYMMETRIC_TYPE],err,error,*999)
                  CASE DEFAULT
                    localError="The specified solver equations symmetry type of "// &
                      & TRIM(NumberToVString(SOLVER_EQUATIONS%symmetryType,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                  CALL SOLVER_MATRICES_CREATE_FINISH(SOLVER_MATRICES,err,error,*999)
                  !Create the PETSc SNES solver
                  CALL Petsc_SnesCreate(computationalEnvironment%mpiCommunicator,TRUSTREGION_SOLVER%snes,err,error,*999)
                  !Set the nonlinear solver type to be a Quasi-Newton trust region solver
                  CALL Petsc_SnesSetType(TRUSTREGION_SOLVER%snes,PETSC_SNESNEWTONTR,err,error,*999)
                  !Set the nonlinear function
                  residualVector=>SOLVER_MATRICES%RESIDUAL
                  IF(ASSOCIATED(residualVector)) THEN
                    IF(ASSOCIATED(residualVector%PETSC)) THEN
                      CALL Petsc_SnesSetFunction(TRUSTREGION_SOLVER%snes,residualVector%PETSC%VECTOR, &
                        & Problem_SolverResidualEvaluatePetsc,SOLVER,err,error,*999)
                      CALL FlagError("The residual vector PETSc is not associated.",err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Solver matrices residual vector is not associated.",err,error,*999)
                  ENDIF
                  !Set the Jacobian if necessary
                  !Set the trust region delta ???
                  
                  !Set the trust region tolerance
                  CALL Petsc_SnesSetTrustRegionTolerance(TRUSTREGION_SOLVER%snes,TRUSTREGION_SOLVER%TRUSTREGION_TOLERANCE, &
                    & err,error,*999)
                  !Set the tolerances for the SNES solver
                  CALL Petsc_SnesSetTolerances(TRUSTREGION_SOLVER%snes,QUASI_NEWTON_SOLVER%ABSOLUTE_TOLERANCE, &
                    & QUASI_NEWTON_SOLVER%RELATIVE_TOLERANCE,QUASI_NEWTON_SOLVER%SOLUTION_TOLERANCE, &
                    & QUASI_NEWTON_SOLVER%MAXIMUM_NUMBER_OF_ITERATIONS,QUASI_NEWTON_SOLVER%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS, &
                    & err,error,*999)
                  !Set any further SNES options from the command line options
                  CALL Petsc_SnesSetFromOptions(TRUSTREGION_SOLVER%snes,err,error,*999)
                ELSE
                  CALL FlagError("Solver equations solver mapping is not associated.",err,error,*999)
                ENDIF
              CASE DEFAULT
                localError="The solver library type of "// &
                  & TRIM(NumberToVString(TRUSTREGION_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              CALL FlagError("Solver solver equations is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Nonlinear solver solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Quasi-Newton solver nonlinear solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Trust region Quasi-Newton solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Trust region solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("Solver_QuasiNewtonTrustRegionCreateFinish")
    RETURN
999 ERRORSEXITS("Solver_QuasiNewtonTrustRegionCreateFinish",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_QuasiNewtonTrustRegionCreateFinish

  !
  !================================================================================================================================
  !

  !>Sets/changes the trust region delta0 for a nonlinear Quasi-Newton trust region solver solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonTrustRegionDelta0Set
  SUBROUTINE SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,TRUSTREGION_DELTA0,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the trust region delta0 for
    REAL(DP), INTENT(IN) :: TRUSTREGION_DELTA0 !<The trust region delta0 to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE==SOLVER_QUASI_NEWTON_TRUSTREGION) THEN
                  TRUSTREGION_SOLVER=>QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER
                  IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
                    IF(TRUSTREGION_DELTA0>ZERO_TOLERANCE) THEN
                      TRUSTREGION_SOLVER%TRUSTREGION_DELTA0=TRUSTREGION_DELTA0
                    ELSE
                      localError="The specified trust region delta0 of "// &
                        & TRIM(NumberToVString(TRUSTREGION_DELTA0,"*",err,error))// &
                        & " is invalid. The trust region delta0 must be > 0."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The Quasi-Newton solver trust region solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Quasi-Newton solver is not a trust region solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET
        
  !
  !================================================================================================================================
  !
  
  !>Finalise a nonlinear Quasi-Newton trust region solver and deallocate all memory
  SUBROUTINE SOLVER_QUASI_NEWTON_TRUSTREGION_FINALISE(TRUSTREGION_SOLVER,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER !<A pointer the non linear trust region solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
  
    ENTERS("SOLVER_QUASI_NEWTON_TRUSTREGION_FINALISE",err,error,*999)

    IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN      
      CALL Petsc_SnesFinalise(TRUSTREGION_SOLVER%snes,err,error,*999)
      DEALLOCATE(TRUSTREGION_SOLVER)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_TRUSTREGION_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_TRUSTREGION_FINALISE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_QUASI_NEWTON_TRUSTREGION_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a Quaso-Newton trust region solver for a nonlinear solver
  SUBROUTINE SOLVER_QUASI_NEWTON_TRUSTREGION_INITIALISE(QUASI_NEWTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER !<A pointer the Quasi-Newton solver to initialise the trust region solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
  
    ENTERS("SOLVER_QUASI_NEWTON_TRUSTREGION_INITIALISE",err,error,*998)

    IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
      IF(ASSOCIATED(QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER)) THEN
        CALL FlagError("Trust region solver is already associated for this nonlinear solver.",err,error,*998)
      ELSE
        ALLOCATE(QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate Quasi-Newton solver trust region solver.",err,error,*999)
        QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER%QUASI_NEWTON_SOLVER=>QUASI_NEWTON_SOLVER
        QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
!!TODO: set this properly
        QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER%TRUSTREGION_DELTA0=0.01_DP
        CALL Petsc_SnesInitialise(QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER%snes,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Quasi-Newton solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_QUASI_NEWTON_TRUSTREGION_INITIALISE")
    RETURN
999 CALL SOLVER_QUASI_NEWTON_TRUSTREGION_FINALISE(QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_QUASI_NEWTON_TRUSTREGION_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_TRUSTREGION_INITIALISE

  !
  !================================================================================================================================
  !

  !Solves a nonlinear Quasi-Newton trust region solver 
  SUBROUTINE SOLVER_QUASI_NEWTON_TRUSTREGION_SOLVE(TRUSTREGION_SOLVER,err,error,*)

    !Argument variables
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER !<A pointer to the nonlinear Quasi-Newton trust region solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_QUASI_NEWTON_TRUSTREGION_SOLVE",err,error,*999)

    IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
      QUASI_NEWTON_SOLVER=>TRUSTREGION_SOLVER%QUASI_NEWTON_SOLVER
      IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN        
        NONLINEAR_SOLVER=>QUASI_NEWTON_SOLVER%NONLINEAR_SOLVER
        IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
          SOLVER=>NONLINEAR_SOLVER%SOLVER
          IF(ASSOCIATED(SOLVER)) THEN
            SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
            IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
              SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
              IF(ASSOCIATED(SOLVER_MATRICES)) THEN
                SELECT CASE(TRUSTREGION_SOLVER%SOLVER_LIBRARY)
                CASE(SOLVER_CMISS_LIBRARY)
                  CALL FlagError("Not implemented.",err,error,*999)
                CASE(SOLVER_PETSC_LIBRARY)
                  CALL FlagError("Not implemented.",err,error,*999)
                CASE DEFAULT
                  localError="The nonlinear Quasi-Newton trust region solver library type of "// &
                    & TRIM(NumberToVString(TRUSTREGION_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ELSE
                CALL FlagError("Solver matrices is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver solver equations is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Nonlinear solver solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Quasi-Newton solver nonlinear solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Trust region solver Quasi-Newton solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Trust region solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_QUASI_NEWTON_TRUSTREGION_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_TRUSTREGION_SOLVE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_QUASI_NEWTON_TRUSTREGION_SOLVE
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the trust region tolerance for a nonlinear Quasi-Newton trust region solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonTrustRegionToleranceSet
  SUBROUTINE Solver_QuasiNewtonTrustRegionToleranceSet(SOLVER,TRUSTREGION_TOLERANCE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the trust region tolerance for
    REAL(DP), INTENT(IN) :: TRUSTREGION_TOLERANCE !<The trust region tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_QuasiNewtonTrustRegionToleranceSet",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE==SOLVER_QUASI_NEWTON_TRUSTREGION) THEN
                  TRUSTREGION_SOLVER=>QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER
                  IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
                    IF(TRUSTREGION_TOLERANCE>ZERO_TOLERANCE) THEN
                      TRUSTREGION_SOLVER%TRUSTREGION_TOLERANCE=TRUSTREGION_TOLERANCE
                    ELSE
                      localError="The specified trust region tolerance of "// &
                        & TRIM(NumberToVString(TRUSTREGION_TOLERANCE,"*",err,error))// &
                        & " is invalid. The trust region tolerance must be > 0."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The Quasi-Newton solver trust region solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Quasi-Newton solver is not a trust region solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_QuasiNewtonTrustRegionToleranceSet")
    RETURN
999 ERRORSEXITS("Solver_QuasiNewtonTrustRegionToleranceSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_QuasiNewtonTrustRegionToleranceSet
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the restart of nonlinear Quasi-Newton solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonRestartSet
  SUBROUTINE SOLVER_QUASI_NEWTON_RESTART_SET(SOLVER,RESTART,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the nonlinear Quasi-Newton solver type
    INTEGER(INTG), INTENT(IN) :: RESTART !<Sets the number of stored updates and the restart period for periodic restart type 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    
    ENTERS("SOLVER_QUASI_NEWTON_RESTART_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                QUASI_NEWTON_SOLVER%RESTART=RESTART
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_RESTART_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_RESTART_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_RESTART_SET
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the restart type of nonlinear Quasi-Newton solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonRestartTypeSet
  SUBROUTINE SOLVER_QUASI_NEWTON_RESTART_TYPE_SET(SOLVER,QUASI_NEWTON_RESTART_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the nonlinear Quasi-Newton solver type
    INTEGER(INTG), INTENT(IN) :: QUASI_NEWTON_RESTART_TYPE !<The restart type of nonlinear Quasi-Newton to set \see SOLVER_ROUTINES_QuasiNewtonRestartTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_RESTART_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(QUASI_NEWTON_RESTART_TYPE/=QUASI_NEWTON_SOLVER%RESTART_TYPE) THEN
                  !Intialise the new type
                  SELECT CASE(QUASI_NEWTON_RESTART_TYPE)
                  CASE(SOLVER_QUASI_NEWTON_RESTART_NONE)
                    QUASI_NEWTON_SOLVER%RESTART_TYPE=SOLVER_QUASI_NEWTON_RESTART_NONE
                  CASE(SOLVER_QUASI_NEWTON_RESTART_POWELL)
                    QUASI_NEWTON_SOLVER%RESTART_TYPE=SOLVER_QUASI_NEWTON_RESTART_POWELL
                  CASE(SOLVER_QUASI_NEWTON_RESTART_PERIODIC)
                    QUASI_NEWTON_SOLVER%RESTART_TYPE=SOLVER_QUASI_NEWTON_RESTART_PERIODIC
                  CASE DEFAULT
                    localError="The Quasi-Newton restart type of "//TRIM(NumberToVString( &
                      & QUASI_NEWTON_RESTART_TYPE,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_RESTART_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_RESTART_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_RESTART_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the scale type of nonlinear Quasi-Newton solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonScaleTypeSet
  SUBROUTINE SOLVER_QUASI_NEWTON_SCALE_TYPE_SET(SOLVER,QUASI_NEWTON_SCALE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the nonlinear Quasi-Newton solver type
    INTEGER(INTG), INTENT(IN) :: QUASI_NEWTON_SCALE_TYPE !<The scale type of nonlinear Quasi-Newton to set \see SOLVER_ROUTINES_QuasiNewtonScaleTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
   TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_SCALE_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(QUASI_NEWTON_SCALE_TYPE/=QUASI_NEWTON_SOLVER%SCALE_TYPE) THEN
                  !Intialise the new type
                  SELECT CASE(QUASI_NEWTON_SCALE_TYPE)
                  CASE(SOLVER_QUASI_NEWTON_SCALE_NONE)
                    QUASI_NEWTON_SOLVER%SCALE_TYPE=SOLVER_QUASI_NEWTON_SCALE_NONE
                  CASE(SOLVER_QUASI_NEWTON_SCALE_SHANNO)
                    QUASI_NEWTON_SOLVER%SCALE_TYPE=SOLVER_QUASI_NEWTON_SCALE_SHANNO
                  CASE(SOLVER_QUASI_NEWTON_SCALE_LINESEARCH)
                    QUASI_NEWTON_SOLVER%SCALE_TYPE=SOLVER_QUASI_NEWTON_SCALE_LINESEARCH
                  CASE(SOLVER_QUASI_NEWTON_SCALE_JACOBIAN)
                    QUASI_NEWTON_SOLVER%SCALE_TYPE=SOLVER_QUASI_NEWTON_SCALE_JACOBIAN
                  CASE DEFAULT
                    localError="The Quasi-Newton scale type of "//TRIM(NumberToVString( &
                      & QUASI_NEWTON_SCALE_TYPE,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_SCALE_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_SCALE_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_SCALE_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the type of nonlinear Quasi-Newton solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonTypeSet
  SUBROUTINE SOLVER_QUASI_NEWTON_TYPE_SET(SOLVER,QUASI_NEWTON_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the nonlinear Quasi-Newton solver type
    INTEGER(INTG), INTENT(IN) :: QUASI_NEWTON_TYPE !<The type of nonlinear Quasi-Newton to set \see SOLVER_ROUTINES_QuasiNewtonTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_QUASI_NEWTON_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(QUASI_NEWTON_TYPE/=QUASI_NEWTON_SOLVER%QUASI_NEWTON_TYPE) THEN
                  !Intialise the new type
                  SELECT CASE(QUASI_NEWTON_TYPE)
                  CASE(SOLVER_QUASI_NEWTON_LBFGS)
                    QUASI_NEWTON_SOLVER%QUASI_NEWTON_TYPE=SOLVER_QUASI_NEWTON_LBFGS
                  CASE(SOLVER_QUASI_NEWTON_GOODBROYDEN)
                    QUASI_NEWTON_SOLVER%QUASI_NEWTON_TYPE=SOLVER_QUASI_NEWTON_GOODBROYDEN
                  CASE(SOLVER_QUASI_NEWTON_BADBROYDEN)
                    QUASI_NEWTON_SOLVER%QUASI_NEWTON_TYPE=SOLVER_QUASI_NEWTON_BADBROYDEN
                  CASE DEFAULT
                    localError="The Quasi-Newton type of "//TRIM(NumberToVString(QUASI_NEWTON_TYPE,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_QUASI_NEWTON_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type of nonlinear Quasi-Newton solver. \see OpenCMISS::Iron::cmfe_SolverQuasiNewtonSolveTypeSet
  SUBROUTINE SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET(SOLVER,QUASI_NEWTON_SOLVE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the nonlinear Quasi-Newton solver type
    INTEGER(INTG), INTENT(IN) :: QUASI_NEWTON_SOLVE_TYPE !<The type of nonlinear solver to set \see SOLVER_ROUTINES_QuasiNewtonSolverTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: dummyError,localError
    
    ENTERS("SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*998)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_QUASI_NEWTON) THEN
              QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
              IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
                IF(QUASI_NEWTON_SOLVE_TYPE/=QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE) THEN
                  !Intialise the new solver type
                  SELECT CASE(QUASI_NEWTON_SOLVE_TYPE)
                  CASE(SOLVER_QUASI_NEWTON_LINESEARCH)
                    CALL SOLVER_QUASI_NEWTON_LINESEARCH_INITIALISE(QUASI_NEWTON_SOLVER,err,error,*999)
                  CASE(SOLVER_QUASI_NEWTON_TRUSTREGION)
                    CALL SOLVER_QUASI_NEWTON_TRUSTREGION_INITIALISE(QUASI_NEWTON_SOLVER,err,error,*999)
                  CASE DEFAULT
                    localError="The Quasi-Newton solver type of " &
                      & //TRIM(NumberToVString(QUASI_NEWTON_SOLVE_TYPE,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                  !Finalise the old solver type
                  SELECT CASE(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE)
                  CASE(SOLVER_QUASI_NEWTON_LINESEARCH)
                    CALL Solver_QuasiNewtonLinesearchFinalise(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER,err,error,*999)
                  CASE(SOLVER_QUASI_NEWTON_TRUSTREGION)
                    CALL SOLVER_QUASI_NEWTON_TRUSTREGION_FINALISE(QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER,err,error,*999)
                  CASE DEFAULT
                    localError="The Quasi-Newton solver type of "// &
                      & TRIM(NumberToVString(QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE,"*",err,error))//" is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                  QUASI_NEWTON_SOLVER%QUASI_NEWTON_SOLVE_TYPE=QUASI_NEWTON_SOLVE_TYPE
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*998)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Quasi-Newton solver.",err,error,*998)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*998)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
    
    EXITS("SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET")
    RETURN
999 SELECT CASE(QUASI_NEWTON_SOLVE_TYPE)
    CASE(SOLVER_QUASI_NEWTON_LINESEARCH)
      CALL Solver_QuasiNewtonLinesearchFinalise(QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER,dummyErr,dummyError,*998)
    CASE(SOLVER_QUASI_NEWTON_TRUSTREGION)
      CALL SOLVER_QUASI_NEWTON_TRUSTREGION_FINALISE(QUASI_NEWTON_SOLVER%TRUSTREGION_SOLVER,dummyErr,dummyError,*998)
    END SELECT
998 ERRORSEXITS("SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for a nonlinear Newton solver. \todo should this be SOLVER_NONLINEAR_NEWTON_ABSOLUTE_TOLERANCE_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonAbsoluteToleranceSet
  SUBROUTINE SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,ABSOLUTE_TOLERANCE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the absolute tolerance for
    REAL(DP), INTENT(IN) :: ABSOLUTE_TOLERANCE !<The absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(ABSOLUTE_TOLERANCE>ZERO_TOLERANCE) THEN
                  NEWTON_SOLVER%ABSOLUTE_TOLERANCE=ABSOLUTE_TOLERANCE
                ELSE
                  localError="The specified absolute tolerance of "//TRIM(NumberToVString(ABSOLUTE_TOLERANCE,"*",err,error))// &
                    & " is invalid. The absolute tolerance must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver.
  SUBROUTINE Solver_NewtonLineSearchMonitorOutputSet(solver,linesearchMonitorOutputFlag,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the absolute tolerance for
    LOGICAL, INTENT(IN) :: linesearchMonitorOutputFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: linesearchSolver
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: newtonSolver
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: nonlinearSolver
    
    ENTERS("Solver_NewtonLineSearchMonitorOutputSet",err,error,*999)

    IF(ASSOCIATED(solver)) THEN
      IF(solver%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(solver%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          nonlinearSolver=>solver%NONLINEAR_SOLVER
          IF(ASSOCIATED(nonlinearSolver)) THEN
            IF(nonlinearSolver%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              newtonSolver=>nonlinearSolver%NEWTON_SOLVER
              IF(ASSOCIATED(newtonSolver)) THEN
                IF(newtonSolver%NEWTON_SOLVE_TYPE==SOLVER_NEWTON_LINESEARCH) THEN
                  linesearchSolver=>newtonSolver%LINESEARCH_SOLVER
                  IF(ASSOCIATED(linesearchSolver)) THEN
                    linesearchSolver%linesearchMonitorOutput=linesearchMonitorOutputFlag
                  ELSE
                    CALL FlagError("The Newton linesearch solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Newton solver is not a linesearch solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_NewtonLineSearchMonitorOutputSet")
    RETURN
999 ERRORSEXITS("Solver_NewtonLineSearchMonitorOutputSet",err,error)    
    RETURN 1
   
  END SUBROUTINE Solver_NewtonLineSearchMonitorOutputSet

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a Newton solver 
  SUBROUTINE SOLVER_NEWTON_CREATE_FINISH(NEWTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER !<A pointer to the Newton solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_NEWTON_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(NEWTON_SOLVER)) THEN
      SELECT CASE(NEWTON_SOLVER%NEWTON_SOLVE_TYPE)
      CASE(SOLVER_NEWTON_LINESEARCH)
        CALL SOLVER_NEWTON_LINESEARCH_CREATE_FINISH(NEWTON_SOLVER%LINESEARCH_SOLVER,err,error,*999)
      CASE(SOLVER_NEWTON_TRUSTREGION)
        CALL SOLVER_NEWTON_TRUSTREGION_CREATE_FINISH(NEWTON_SOLVER%TRUSTREGION_SOLVER,err,error,*999)
      CASE DEFAULT
        localError="The Newton solver type of "// &
          & TRIM(NumberToVString(NEWTON_SOLVER%NEWTON_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Newton solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_NEWTON_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_CREATE_FINISH",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_CREATE_FINISH
        
  !
  !================================================================================================================================
  !

  !>Finalise a Newton solver and deallocate all memory
  RECURSIVE SUBROUTINE SOLVER_NEWTON_FINALISE(NEWTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER !<A pointer the Newton solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVER_NEWTON_FINALISE",err,error,*999)

    IF(ASSOCIATED(NEWTON_SOLVER)) THEN
      CALL SOLVER_NEWTON_LINESEARCH_FINALISE(NEWTON_SOLVER%LINESEARCH_SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_FINALISE(NEWTON_SOLVER%TRUSTREGION_SOLVER,err,error,*999)
      CALL SOLVER_FINALISE(NEWTON_SOLVER%LINEAR_SOLVER,err,error,*999)
      DEALLOCATE(NEWTON_SOLVER)
    ENDIF
         
    EXITS("SOLVER_NEWTON_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a Newton solver for a nonlinear solver
  SUBROUTINE SOLVER_NEWTON_INITIALISE(NONLINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER !<A pointer the solver to initialise the Newton solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: dummyError
 
    ENTERS("SOLVER_NEWTON_INITIALISE",err,error,*998)

    IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
      IF(ASSOCIATED(NONLINEAR_SOLVER%NEWTON_SOLVER)) THEN
        CALL FlagError("Newton solver is already associated for this nonlinear solver.",err,error,*998)
      ELSE        
        SOLVER=>NONLINEAR_SOLVER%SOLVER
        IF(ASSOCIATED(SOLVER)) THEN
          !Allocate and initialise a Newton solver
          ALLOCATE(NONLINEAR_SOLVER%NEWTON_SOLVER,STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate nonlinear solver Newton solver.",err,error,*999)
          NONLINEAR_SOLVER%NEWTON_SOLVER%NONLINEAR_SOLVER=>NONLINEAR_SOLVER
          NONLINEAR_SOLVER%NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD
          NONLINEAR_SOLVER%NEWTON_SOLVER%TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS=0
          NONLINEAR_SOLVER%NEWTON_SOLVER%TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS=0
          NONLINEAR_SOLVER%NEWTON_SOLVER%MAXIMUM_NUMBER_OF_ITERATIONS=50
          NONLINEAR_SOLVER%NEWTON_SOLVER%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS=1000
          NONLINEAR_SOLVER%NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE=SOLVER_NEWTON_JACOBIAN_FD_CALCULATED
          NONLINEAR_SOLVER%NEWTON_SOLVER%convergenceTestType=SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT
          NONLINEAR_SOLVER%NEWTON_SOLVER%ABSOLUTE_TOLERANCE=1.0E-10_DP
          NONLINEAR_SOLVER%NEWTON_SOLVER%RELATIVE_TOLERANCE=1.0E-05_DP
          NONLINEAR_SOLVER%NEWTON_SOLVER%SOLUTION_TOLERANCE=1.0E-05_DP
          NULLIFY(NONLINEAR_SOLVER%NEWTON_SOLVER%LINESEARCH_SOLVER)
          NULLIFY(NONLINEAR_SOLVER%NEWTON_SOLVER%TRUSTREGION_SOLVER)
          NULLIFY(NONLINEAR_SOLVER%NEWTON_SOLVER%CELLML_EVALUATOR_SOLVER)
          NULLIFY(NONLINEAR_SOLVER%NEWTON_SOLVER%convergenceTest)
          ALLOCATE(NONLINEAR_SOLVER%NEWTON_SOLVER%convergenceTest,STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate convergence test object.",err,error,*999)
          NONLINEAR_SOLVER%NEWTON_SOLVER%convergenceTest%energyFirstIter = 0.0_DP
          NONLINEAR_SOLVER%NEWTON_SOLVER%convergenceTest%normalisedEnergy = 0.0_DP
          !Default to a Newton linesearch solver
          NONLINEAR_SOLVER%NEWTON_SOLVER%NEWTON_SOLVE_TYPE=SOLVER_NEWTON_LINESEARCH
          CALL SOLVER_NEWTON_LINESEARCH_INITIALISE(NONLINEAR_SOLVER%NEWTON_SOLVER,err,error,*999)
          !Create the linked linear solver
          ALLOCATE(NONLINEAR_SOLVER%NEWTON_SOLVER%LINEAR_SOLVER,STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate Newton solver linear solver.",err,error,*999)
          NULLIFY(NONLINEAR_SOLVER%NEWTON_SOLVER%LINEAR_SOLVER%SOLVERS)
          CALL SOLVER_INITIALISE_PTR(NONLINEAR_SOLVER%NEWTON_SOLVER%LINEAR_SOLVER,err,error,*999)
          CALL SOLVER_LINEAR_INITIALISE(NONLINEAR_SOLVER%NEWTON_SOLVER%LINEAR_SOLVER,err,error,*999)
          CALL SOLVER_LINKED_SOLVER_ADD(SOLVER,NONLINEAR_SOLVER%NEWTON_SOLVER%LINEAR_SOLVER,SOLVER_LINEAR_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Nonlinear solver solver is not associated.",err,error,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Nonlinear solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_NEWTON_INITIALISE")
    RETURN
999 CALL SOLVER_NEWTON_FINALISE(NONLINEAR_SOLVER%NEWTON_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_NEWTON_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_INITIALISE

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of Jacobian calculation type for a Newton solver. \todo should this be SOLVER_NONLINEAR_NEWTON_JACOBIAN_CALCULATION_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonJacobianCalculationSet
  SUBROUTINE SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(SOLVER,JACOBIAN_CALCULATION_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the Jacobian calculation type
    INTEGER(INTG), INTENT(IN) :: JACOBIAN_CALCULATION_TYPE !<The type of Jacobian calculation type to set \see SOLVER_ROUTINES_JacobianCalculationTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(JACOBIAN_CALCULATION_TYPE/=NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE) THEN
                  SELECT CASE(JACOBIAN_CALCULATION_TYPE)
                  CASE(SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED)
                    NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE=SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED
                  CASE(SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED)
                    NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE=SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED
                  CASE(SOLVER_NEWTON_JACOBIAN_FD_CALCULATED)
                    NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE=SOLVER_NEWTON_JACOBIAN_FD_CALCULATED
                  CASE DEFAULT
                    localError="The Jacobian calculation type of "// &
                      & TRIM(NumberToVString(JACOBIAN_CALCULATION_TYPE,"*",err,error))//" is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                ENDIF
              ELSE
                CALL FlagError("The nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The Solver nonlinear solver is not associated",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for a Newton solver.
  SUBROUTINE SOLVER_NEWTON_LIBRARY_TYPE_GET(NEWTON_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER !<A pointer the Newton solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On exit, the type of library used for the Newton solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER
    TYPE(VARYING_STRING) :: localError
 
    ENTERS("SOLVER_NEWTON_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(NEWTON_SOLVER)) THEN
      SELECT CASE(NEWTON_SOLVER%NEWTON_SOLVE_TYPE)
      CASE(SOLVER_NEWTON_LINESEARCH)
        LINESEARCH_SOLVER=>NEWTON_SOLVER%LINESEARCH_SOLVER
        IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=LINESEARCH_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("Newton line search solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_NEWTON_TRUSTREGION)
        TRUSTREGION_SOLVER=>NEWTON_SOLVER%TRUSTREGION_SOLVER
        IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
          SOLVER_LIBRARY_TYPE=TRUSTREGION_SOLVER%SOLVER_LIBRARY
        ELSE
          CALL FlagError("Newton trust region solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The Newton solver type of "// &
          & TRIM(NumberToVString(NEWTON_SOLVER%NEWTON_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Newton solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_LIBRARY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for a Newton solver.
  SUBROUTINE SOLVER_NEWTON_LIBRARY_TYPE_SET(NEWTON_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER !<A pointer the Newton solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library for the Newton solver to set. \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_NEWTON_LIBRARY_TYPE_SET",err,error,*999)
    
    IF(ASSOCIATED(NEWTON_SOLVER)) THEN
      SELECT CASE(NEWTON_SOLVER%NEWTON_SOLVE_TYPE)
      CASE(SOLVER_NEWTON_LINESEARCH)
        LINESEARCH_SOLVER=>NEWTON_SOLVER%LINESEARCH_SOLVER
        IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            LINESEARCH_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid for a Newton linesearch solver."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("Newton line search solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_NEWTON_TRUSTREGION)
        TRUSTREGION_SOLVER=>NEWTON_SOLVER%TRUSTREGION_SOLVER
        IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
          SELECT CASE(SOLVER_LIBRARY_TYPE)
          CASE(SOLVER_CMISS_LIBRARY)
            CALL FlagError("Not implemented.",err,error,*999)
          CASE(SOLVER_PETSC_LIBRARY)
            TRUSTREGION_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
          CASE DEFAULT
            localError="The solver library type of "//TRIM(NumberToVString(SOLVER_LIBRARY_TYPE,"*",err,error))// &
              & " is invalid for a Newton trustregion solver."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ELSE
          CALL FlagError("Newton trust region solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The Newton solver type of "// &
          & TRIM(NumberToVString(NEWTON_SOLVER%NEWTON_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Newton solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_NEWTON_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_LIBRARY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_LIBRARY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver \todo should this be SOLVER_NONLINEAR_NEWTON_LINEAR_SOLVER_GET??? \see OpenCMISS::Iron::cmfe_SolverNewtonLinearSolverGetSet
  SUBROUTINE SOLVER_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the Newton solver to get the linear solver for
    TYPE(SOLVER_TYPE), POINTER :: LINEAR_SOLVER !<On exit, a pointer the linear solver linked to the Newton solver. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER

    ENTERS("SOLVER_NEWTON_LINEAR_SOLVER_GET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(LINEAR_SOLVER)) THEN
        CALL FlagError("Linear solver is already associated.",err,error,*999)
      ELSE
        NULLIFY(LINEAR_SOLVER)
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                LINEAR_SOLVER=>NEWTON_SOLVER%LINEAR_SOLVER
                IF(.NOT.ASSOCIATED(LINEAR_SOLVER)) &
                  & CALL FlagError("Newton solver linear solver is not associated.",err,error,*999)
              ELSE
                CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a dynamic solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_LINEAR_SOLVER_GET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_LINEAR_SOLVER_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_LINEAR_SOLVER_GET

  !
  !================================================================================================================================
  !
  
  !>Returns the CellML solver associated with a Newton solver \todo should this be SOLVER_NONLINEAR_NEWTON_CELLML_SOLVER_GET??? \see OpenCMISS::Iron::cmfe_SolverNewtonCellMLSolverGetSet
  SUBROUTINE SOLVER_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the Newton solver to get the linear solver for
    TYPE(SOLVER_TYPE), POINTER :: CELLML_SOLVER !<On exit, a pointer the linear solver linked to the Newton solver. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER

    ENTERS("SOLVER_NEWTON_CELLML_SOLVER_GET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(CELLML_SOLVER)) THEN
        CALL FlagError("Linear solver is already associated.",err,error,*999)
      ELSE
        NULLIFY(CELLML_SOLVER)
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                CELLML_SOLVER=>NEWTON_SOLVER%CELLML_EVALUATOR_SOLVER
                IF(.NOT.ASSOCIATED(CELLML_SOLVER)) &
                  & CALL FlagError("Newton solver CellML solver is not associated.",err,error,*999)
              ELSE
                CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE IF(SOLVER%SOLVE_TYPE==SOLVER_DYNAMIC_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%DYNAMIC_SOLVER%NONLINEAR_SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                CELLML_SOLVER=>NEWTON_SOLVER%CELLML_EVALUATOR_SOLVER
                IF(.NOT.ASSOCIATED(CELLML_SOLVER)) &
                  & CALL FlagError("Newton solver CellML solver is not associated.",err,error,*999)
              ELSE
                CALL FlagError("Dynamic nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The Dynamic nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver dynamic nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The specified solver is not a nonlinear or dynamic nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_CELLML_SOLVER_GET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_CELLML_SOLVER_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_CELLML_SOLVER_GET

  !
  !================================================================================================================================
  !
  
  !>Sets/changes the convergence test for a Newton nonlinear solver \see OpenCMISS::Iron::cmfe_SolverNewtonConvergenceTestSet
  SUBROUTINE Solver_NewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the convergence test for
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: newtonSolver 
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: nonlinearSolver
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_NewtonConvergenceTestTypeSet",err,error,*999)

    IF(ASSOCIATED(solver)) THEN
      IF(solver%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(solver%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          nonlinearSolver=>solver%NONLINEAR_SOLVER
          IF(ASSOCIATED(nonlinearSolver)) THEN
            IF(nonlinearSolver%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              newtonSolver=>nonlinearSolver%NEWTON_SOLVER
              IF(ASSOCIATED(newtonSolver)) THEN
                SELECT CASE(convergenceTestType)
                CASE(SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT)
                  newtonSolver%convergenceTestType=SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT
                CASE(SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM)
                  newtonSolver%convergenceTestType=SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM
                CASE(SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO)
                  newtonSolver%convergenceTestType=SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO
                CASE DEFAULT
                  localError="The specified convergence test type of "//TRIM(NumberToVString(convergenceTestType, &
                    & "*",err,error))//" is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ELSE
                CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
    CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_NewtonConvergenceTestTypeSet")
    RETURN
999 ERRORSEXITS("Solver_NewtonConvergenceTestTypeSet",err,error)    
    RETURN 1
   
  END SUBROUTINE Solver_NewtonConvergenceTestTypeSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for a Newton linesearch solver \todo should this be SOLVER_NONLINEAR_NEWTON_LINESEARCH_ALPHA_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonLineSearchAlphaSet
  SUBROUTINE SOLVER_NEWTON_LINESEARCH_ALPHA_SET(SOLVER,LINESEARCH_ALPHA,err,error,*)
    
    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the line search alpha for
    REAL(DP), INTENT(IN) :: LINESEARCH_ALPHA !<The line search alpha to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_LINESEARCH_ALPHA_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(NEWTON_SOLVER%NEWTON_SOLVE_TYPE==SOLVER_NEWTON_LINESEARCH) THEN
                  LINESEARCH_SOLVER=>NEWTON_SOLVER%LINESEARCH_SOLVER
                  IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
                    IF(LINESEARCH_ALPHA>ZERO_TOLERANCE) THEN
                      LINESEARCH_SOLVER%LINESEARCH_ALPHA=LINESEARCH_ALPHA
                    ELSE
                      localError="The specified line search alpha of "//TRIM(NumberToVString(LINESEARCH_ALPHA,"*",err,error))// &
                        & " is invalid. The line search alpha must be > 0."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The Newton solver line search solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Newton solver is not a line search solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_LINESEARCH_ALPHA_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_LINESEARCH_ALPHA_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_LINESEARCH_ALPHA_SET
        
  !
  !================================================================================================================================
  !

  !>Finishes the process of creating nonlinear Newton line search solver
  SUBROUTINE SOLVER_NEWTON_LINESEARCH_CREATE_FINISH(LINESEARCH_SOLVER,err,error,*)

    !Argument variables
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER !<A pointer the nonlinear Newton line search solver to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    EXTERNAL :: Problem_SolverJacobianEvaluatePetsc
    EXTERNAL :: Problem_SolverJacobianFDCalculatePetsc
    EXTERNAL :: Problem_SolverResidualEvaluatePetsc
    EXTERNAL :: Problem_SolverConvergenceTestPetsc
    EXTERNAL :: Problem_SolverNonlinearMonitorPetsc
    INTEGER(INTG) :: equations_matrix_idx,equations_set_idx,interface_condition_idx,interface_matrix_idx
    TYPE(DistributedMatrixType), POINTER :: JACOBIAN_MATRIX
    TYPE(DistributedVectorType), POINTER :: residualVector
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMappingLinearType), POINTER :: linearMapping
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatricesLinearType), POINTER :: linearMatrices
    TYPE(EquationsMatrixType), POINTER :: equationsMatrix
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD,LAGRANGE_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: LINEAR_VARIABLE,INTERFACE_VARIABLE,LAGRANGE_VARIABLE
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(SOLVER_TYPE), POINTER :: LINEAR_SOLVER,SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_JACOBIAN
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(INTERFACE_MAPPING_TYPE), POINTER :: INTERFACE_MAPPING
    TYPE(INTERFACE_MATRICES_TYPE), POINTER :: INTERFACE_MATRICES
    TYPE(INTERFACE_MATRIX_TYPE), POINTER :: INTERFACE_MATRIX

    TYPE(VARYING_STRING) :: localError
  
    ENTERS("SOLVER_NEWTON_LINESEARCH_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
      NEWTON_SOLVER=>LINESEARCH_SOLVER%NEWTON_SOLVER
      IF(ASSOCIATED(NEWTON_SOLVER)) THEN
        NONLINEAR_SOLVER=>NEWTON_SOLVER%NONLINEAR_SOLVER
        IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
          SOLVER=>NONLINEAR_SOLVER%SOLVER
          IF(ASSOCIATED(SOLVER)) THEN
            SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
            IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
              SELECT CASE(LINESEARCH_SOLVER%SOLVER_LIBRARY)
              CASE(SOLVER_CMISS_LIBRARY)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(SOLVER_PETSC_LIBRARY)
                SOLVER_MAPPING=>SOLVER_EQUATIONS%SOLVER_MAPPING
                IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                  !Loop over the equations set in the solver equations
                  DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                    EQUATIONS=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%EQUATIONS
                    IF(ASSOCIATED(EQUATIONS)) THEN
                      EQUATIONS_SET=>equations%equationsSet
                      IF(ASSOCIATED(EQUATIONS_SET)) THEN
                        DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
                        IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
                          NULLIFY(vectorEquations)
                          CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
                          vectorMapping=>vectorEquations%vectorMapping
                          IF(ASSOCIATED(vectorMapping)) THEN
                            linearMapping=>vectorMapping%linearMapping
                            IF(ASSOCIATED(linearMapping)) THEN
                              !If there are any linear matrices create temporary vector for matrix-vector products
                              vectorMatrices=>vectorEquations%vectorMatrices
                              IF(ASSOCIATED(vectorMatrices)) THEN
                                linearMatrices=>vectorMatrices%linearMatrices
                                IF(ASSOCIATED(linearMatrices)) THEN
                                  DO equations_matrix_idx=1,linearMatrices%numberOfLinearMatrices
                                    equationsMatrix=>linearMatrices%matrices(equations_matrix_idx)%ptr
                                    IF(ASSOCIATED(equationsMatrix)) THEN
                                      IF(.NOT.ASSOCIATED(equationsMatrix%tempVector)) THEN
                                        LINEAR_VARIABLE=>linearMapping%equationsMatrixToVarMaps(equations_matrix_idx)%VARIABLE
                                        IF(ASSOCIATED(LINEAR_VARIABLE)) THEN
                                          CALL DistributedVector_CreateStart(LINEAR_VARIABLE%DOMAIN_MAPPING, &
                                            & equationsMatrix%tempVector,err,error,*999)
                                          CALL DistributedVector_DataTypeSet(equationsMatrix%tempVector, &
                                            & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
                                          CALL DistributedVector_CreateFinish(equationsMatrix%tempVector,err,error,*999)
                                        ELSE
                                          CALL FlagError("Linear mapping linear variable is not associated.",err,error,*999)
                                        ENDIF
                                      ENDIF
                                    ELSE
                                      CALL FlagError("Equations matrix is not associated.",err,error,*999)
                                    ENDIF
                                  ENDDO !equations_matrix_idx
                                ELSE
                                  CALL FlagError("Equations matrices linear matrices is not associated.",err,error,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Equations equations matrices is not associated.",err,error,*999)
                              ENDIF
                            ENDIF
                          ELSE
                            CALL FlagError("Equations equations mapping is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          localError="Equations set dependent field is not associated for equations set index "// &
                            & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        localError="Equations equations set is not associated for equations set index "// &
                          & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                        CALL FlagError(localError,err,error,*999)
                      ENDIF
                    ELSE
                      localError="Equations is not associated for equations set index "// &
                        & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ENDDO !equations_set_idx
                  !Loop over the interface conditions
                  DO interface_condition_idx=1,SOLVER_MAPPING%NUMBER_OF_INTERFACE_CONDITIONS
                    INTERFACE_CONDITION=>SOLVER_MAPPING%INTERFACE_CONDITIONS(interface_condition_idx)%ptr
                    IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
                      LAGRANGE_FIELD=>INTERFACE_CONDITION%LAGRANGE%LAGRANGE_FIELD
                      IF(ASSOCIATED(LAGRANGE_FIELD)) THEN
                        INTERFACE_EQUATIONS=>INTERFACE_CONDITION%INTERFACE_EQUATIONS
                        IF(ASSOCIATED(INTERFACE_EQUATIONS)) THEN
                          INTERFACE_MATRICES=>INTERFACE_EQUATIONS%INTERFACE_MATRICES
                          IF(ASSOCIATED(INTERFACE_MATRICES)) THEN
                            INTERFACE_MAPPING=>INTERFACE_EQUATIONS%INTERFACE_MAPPING
                            IF(ASSOCIATED(INTERFACE_MAPPING)) THEN
                              LAGRANGE_VARIABLE=>INTERFACE_MAPPING%LAGRANGE_VARIABLE
                              IF(ASSOCIATED(LAGRANGE_VARIABLE)) THEN
                                !Create temporary vector for matrix-vector products
                                DO interface_matrix_idx=1,INTERFACE_MAPPING%NUMBER_OF_INTERFACE_MATRICES
                                  INTERFACE_MATRIX=>INTERFACE_MATRICES%matrices(interface_matrix_idx)%ptr
                                  IF(ASSOCIATED(INTERFACE_MATRIX)) THEN
                                    IF(.NOT.ASSOCIATED(INTERFACE_MATRIX%TEMP_VECTOR)) THEN
                                      INTERFACE_VARIABLE=>INTERFACE_MAPPING% &
                                        & INTERFACE_MATRIX_ROWS_TO_VAR_MAPS(interface_matrix_idx)%VARIABLE
                                      IF(ASSOCIATED(INTERFACE_VARIABLE)) THEN
                                        !Set up the temporary interface distributed vector to be used with interface matrices
                                        CALL DistributedVector_CreateStart(INTERFACE_VARIABLE%DOMAIN_MAPPING, &
                                          & INTERFACE_MATRIX%TEMP_VECTOR,err,error,*999)
                                        CALL DistributedVector_DataTypeSet(INTERFACE_MATRIX%TEMP_VECTOR, &
                                          & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
                                        CALL DistributedVector_CreateFinish(INTERFACE_MATRIX%TEMP_VECTOR,err,error,*999)
                                        !Set up the temporary interface distributed vector to be used with transposed interface matrices
                                        CALL DistributedVector_CreateStart(LAGRANGE_VARIABLE%DOMAIN_MAPPING, &
                                          & INTERFACE_MATRIX%TEMP_TRANSPOSE_VECTOR,err,error,*999)
                                        CALL DistributedVector_DataTypeSet(INTERFACE_MATRIX%TEMP_TRANSPOSE_VECTOR, &
                                          & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
                                        CALL DistributedVector_CreateFinish(INTERFACE_MATRIX%TEMP_TRANSPOSE_VECTOR, &
                                          & err,error,*999)
                                      ELSE
                                        CALL FlagError("Interface mapping variable is not associated.",err,error,*999)
                                      ENDIF
                                    ENDIF
                                  ELSE
                                    CALL FlagError("Interface matrix is not associated.",err,error,*999)
                                  ENDIF
                                ENDDO !interface_matrix_idx
                              ELSE
                                CALL FlagError("Interface matrix is not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("interface condition mapping is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Interface matrices is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          localError="Interface eqauations is not associated for interface condition index "// &
                            & TRIM(NumberToVString(interface_condition_idx,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        localError="Interface condition Lagrange field is not associated for interface condition "// &
                          & TRIM(NumberToVString(interface_condition_idx,"*",err,error))//"."
                        CALL FlagError(localError,err,error,*999)
                      ENDIF
                    ELSE
                      localError="Interface condition is not associated for interface condition index "// &
                        & TRIM(NumberToVString(interface_condition_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ENDDO !interface_idx
                  !Create the PETSc SNES solver
                  CALL Petsc_SnesCreate(computationalEnvironment%mpiCommunicator,LINESEARCH_SOLVER%snes,err,error,*999)
                  !Set the nonlinear solver type to be a Newton line search solver
                  CALL Petsc_SnesSetType(LINESEARCH_SOLVER%snes,PETSC_SNESNEWTONLS,err,error,*999)
                  
                  !Create the solver matrices and vectors
                  LINEAR_SOLVER=>NEWTON_SOLVER%LINEAR_SOLVER
                  IF(ASSOCIATED(LINEAR_SOLVER)) THEN
                    NULLIFY(SOLVER_MATRICES)
                    CALL SOLVER_MATRICES_CREATE_START(SOLVER_EQUATIONS,SOLVER_MATRICES,err,error,*999)
                    CALL SolverMatrices_LibraryTypeSet(SOLVER_MATRICES,SOLVER_PETSC_LIBRARY,err,error,*999)
                    SELECT CASE(SOLVER_EQUATIONS%sparsityType)
                    CASE(SOLVER_SPARSE_MATRICES)
                      CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE], &
                        & err,error,*999)
                    CASE(SOLVER_FULL_MATRICES)
                      CALL SOLVER_MATRICES_STORAGE_TYPE_SET(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE], &
                        & err,error,*999)
                    CASE DEFAULT
                      localError="The specified solver equations sparsity type of "// &
                        & TRIM(NumberToVString(SOLVER_EQUATIONS%sparsityType,"*",err,error))//" is invalid."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                    SELECT CASE(SOLVER_EQUATIONS%symmetryType)
                    CASE(SOLVER_SYMMETRIC_MATRICES)
                      CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_SYMMETRIC_TYPE],err,error,*999)
                    CASE(SOLVER_UNSYMMETRIC_MATRICES)
                      CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_UNSYMMETRIC_TYPE],err,error,*999)
                    CASE DEFAULT
                      localError="The specified solver equations symmetry type of "// &
                        & TRIM(NumberToVString(SOLVER_EQUATIONS%symmetryType,"*",err,error))// &
                        & " is invalid."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                    CALL SOLVER_MATRICES_CREATE_FINISH(SOLVER_MATRICES,err,error,*999)
                    !Link linear solver
                    LINEAR_SOLVER%SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
                    !Finish the creation of the linear solver
                    CALL SOLVER_LINEAR_CREATE_FINISH(LINEAR_SOLVER%LINEAR_SOLVER,err,error,*999)
                    !Associate linear solver's KSP to nonlinear solver's SNES
                    SELECT CASE(LINEAR_SOLVER%LINEAR_SOLVER%LINEAR_SOLVE_TYPE)
                    CASE(SOLVER_LINEAR_DIRECT_SOLVE_TYPE)
                      CALL Petsc_SnesSetKsp(linesearch_solver%snes,linear_solver%linear_solver%direct_solver%ksp,err,error,*999)
                    CASE(SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE)
                      CALL Petsc_SnesSetKsp(linesearch_solver%snes,linear_solver%linear_solver%iterative_solver%ksp,err,error,*999)
                    END SELECT

                    !Set the nonlinear function
                    residualVector=>SOLVER_MATRICES%RESIDUAL
                    IF(ASSOCIATED(residualVector)) THEN
                      IF(ASSOCIATED(residualVector%PETSC)) THEN
                        !Set the solver as a context for the SNES object
                        CALL Petsc_SnesSetApplicationContext(LINESEARCH_SOLVER%snes,LINESEARCH_SOLVER%NEWTON_SOLVER% &
                          & NONLINEAR_SOLVER%SOLVER,err,error,*999)
                        !Pass the linesearch solver object rather than the temporary solver
                        CALL Petsc_SnesSetFunction(LINESEARCH_SOLVER%snes,residualVector%PETSC%VECTOR, &
                          & Problem_SolverResidualEvaluatePetsc,LINESEARCH_SOLVER%NEWTON_SOLVER%NONLINEAR_SOLVER%SOLVER, &
                          & err,error,*999)
                        SELECT CASE(LINESEARCH_SOLVER%NEWTON_SOLVER%convergenceTestType)
                        CASE(SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT)
                          !Default convergence test, do nothing
                        CASE(SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM,SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO)
                          CALL Petsc_SnesSetConvergenceTest(LINESEARCH_SOLVER%snes,Problem_SolverConvergenceTestPetsc, &
                            & LINESEARCH_SOLVER%NEWTON_SOLVER%NONLINEAR_SOLVER%SOLVER,err,error,*999)
                        CASE DEFAULT
                          localError="The specified convergence test type of "//TRIM(NumberToVString(LINESEARCH_SOLVER% &
                            & NEWTON_SOLVER%convergenceTestType,"*",err,error))//" is invalid."
                          CALL FlagError(localError,err,error,*999)
                        END SELECT
                      ELSE
                        CALL FlagError("The residual vector PETSc is not associated.",err,error,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Solver matrices residual vector is not associated.",err,error,*999)
                    ENDIF
                  
                    !Set the Jacobian
                    IF(SOLVER_MATRICES%NUMBER_OF_MATRICES==1) THEN
                      SOLVER_JACOBIAN=>SOLVER_MATRICES%matrices(1)%ptr
                      IF(ASSOCIATED(SOLVER_JACOBIAN)) THEN
                        JACOBIAN_MATRIX=>SOLVER_JACOBIAN%MATRIX
                        IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN
                          IF(ASSOCIATED(JACOBIAN_MATRIX%PETSC)) THEN
                            SELECT CASE(NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE)
                            CASE(SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED)
                              CALL FlagError("Cannot have no Jacobian calculation for a PETSc nonlinear linesearch solver.", &
                                & err,error,*999)
                            CASE(SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED)
                              SOLVER_JACOBIAN%UPDATE_MATRIX=.TRUE. !CMISS will fill in the Jacobian values
                              !Pass the linesearch solver object rather than the temporary solver
                              CALL Petsc_SnesSetJacobian(LINESEARCH_SOLVER%snes,JACOBIAN_MATRIX%PETSC%MATRIX, &
                                & JACOBIAN_MATRIX%PETSC%MATRIX,Problem_SolverJacobianEvaluatePetsc, &
                                & LINESEARCH_SOLVER%NEWTON_SOLVER%NONLINEAR_SOLVER%SOLVER,err,error,*999)
                            CASE(SOLVER_NEWTON_JACOBIAN_FD_CALCULATED)
                              SOLVER_JACOBIAN%UPDATE_MATRIX=.FALSE. !Petsc will fill in the Jacobian values
                              CALL DistributedMatrix_Form(JACOBIAN_MATRIX,err,error,*999)
                              SELECT CASE(SOLVER_EQUATIONS%sparsityType)
                              CASE(SOLVER_SPARSE_MATRICES)
                                CALL Petsc_MatColoringCreate(JACOBIAN_MATRIX%petsc%matrix,LINESEARCH_SOLVER%jacobianMatColoring, &
                                  & err,error,*999)
                                CALL Petsc_MatColoringSetType(LINESEARCH_SOLVER%jacobianMatColoring,PETSC_MATCOLORING_SL, &
                                  & err,error,*999)
                                CALL Petsc_MatColoringSetFromOptions(LINESEARCH_SOLVER%jacobianMatColoring,err,error,*999)
                                CALL Petsc_MatColoringApply(LINESEARCH_SOLVER%jacobianMatColoring,LINESEARCH_SOLVER% &
                                  & jacobianISColoring,err,error,*999)
                                CALL Petsc_MatColoringDestroy(LINESEARCH_SOLVER%jacobianMatColoring,err,error,*999)
                                !Compute SNESComputeJacobianDefaultColor data structure
                                CALL Petsc_MatFDColoringCreate(JACOBIAN_MATRIX%petsc%matrix,LINESEARCH_SOLVER%jacobianISColoring, &
                                  & LINESEARCH_SOLVER%jacobianMatFDColoring,err,error,*999)
                                !Pass the linesearch solver object rather than the temporary solver
                                CALL Petsc_MatFDColoringSetFunction(LINESEARCH_SOLVER%jacobianMatFDColoring, &
                                  & Problem_SolverResidualEvaluatePetsc,LINESEARCH_SOLVER%NEWTON_SOLVER%NONLINEAR_SOLVER% &
                                  & SOLVER,err,error,*999)
                                CALL Petsc_MatFDColoringSetFromOptions(LINESEARCH_SOLVER%jacobianMatFDColoring,err,error,*999)
                                CALL Petsc_MatFDColoringSetup(JACOBIAN_MATRIX%petsc%matrix,LINESEARCH_SOLVER%jacobianISColoring, &
                                  & LINESEARCH_SOLVER%jacobianMatFDColoring,err,error,*999)
                                CALL Petsc_ISColoringDestroy(LINESEARCH_SOLVER%jacobianISColoring,err,error,*999)
                              CASE(SOLVER_FULL_MATRICES)
                                !Do nothing
                              CASE DEFAULT
                                localError="The specified solver equations sparsity type of "// &
                                  & TRIM(NumberToVString(SOLVER_EQUATIONS%sparsityType,"*",err,error))//" is invalid."
                                CALL FlagError(localError,err,error,*999)
                              END SELECT
                              CALL Petsc_SnesSetJacobian(LINESEARCH_SOLVER%snes,JACOBIAN_MATRIX%petsc%matrix, &
                                & JACOBIAN_MATRIX%petsc%matrix,Problem_SolverJacobianFDCalculatePetsc,LINESEARCH_SOLVER% &
                                & NEWTON_SOLVER%NONLINEAR_SOLVER%SOLVER,err,error,*999)
                            CASE DEFAULT
                              localError="The Jacobian calculation type of "// &
                                & TRIM(NumberToVString(NEWTON_SOLVER%JACOBIAN_CALCULATION_TYPE,"*",err,error))// &
                                & " is invalid."
                              CALL FlagError(localError,err,error,*999)
                            END SELECT
                          ELSE
                            CALL FlagError("Jacobian matrix PETSc is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Solver Jacobian matrix is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("The solver Jacobian is not associated.",err,error,*999)
                      ENDIF
                    ELSE
                      localError="Invalid number of solver matrices. The number of solver matrices is "// &
                        & TRIM(NumberToVString(SOLVER_MATRICES%NUMBER_OF_MATRICES,"*",err,error))//" and it should be 1."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                    IF(SOLVER%outputType>=SOLVER_MONITOR_OUTPUT) THEN
                      !Set the monitor
                      !Pass the linesearch solver object rather than the temporary solver
                      CALL Petsc_SnesMonitorSet(LINESEARCH_SOLVER%snes,Problem_SolverNonlinearMonitorPETSC, &
                        & LINESEARCH_SOLVER%NEWTON_SOLVER%NONLINEAR_SOLVER%SOLVER,err,error,*999)
                    ENDIF
                    CALL Petsc_SnesGetLineSearch(linesearch_solver%snes,linesearch_solver%snesLineSearch,err,error,*999)
                    !Set the line search type and order where applicable
                    SELECT CASE(linesearch_solver%linesearch_type)
                    CASE(SOLVER_NEWTON_LINESEARCH_NONORMS)
                      CALL Petsc_SnesLineSearchSetType(linesearch_solver%snesLineSearch,PETSC_SNES_LINESEARCH_BASIC,err,error,*999)
                      CALL Petsc_SnesLineSearchSetComputeNorms(linesearch_solver%snesLineSearch,.FALSE.,err,error,*999)
                    CASE(SOLVER_NEWTON_LINESEARCH_LINEAR)
                      CALL Petsc_SnesLineSearchSetType(linesearch_solver%snesLineSearch,PETSC_SNES_LINESEARCH_CP,err,error,*999)
                      CALL Petsc_SnesLineSearchSetOrder(linesearch_solver%snesLineSearch,PETSC_SNES_LINESEARCH_ORDER_LINEAR, &
                        & err,error,*999)
                    CASE(SOLVER_NEWTON_LINESEARCH_QUADRATIC)
                      CALL Petsc_SnesLineSearchSetType(linesearch_solver%snesLineSearch,PETSC_SNES_LINESEARCH_BT,err,error,*999)
                      CALL Petsc_SnesLineSearchSetOrder(linesearch_solver%snesLineSearch,PETSC_SNES_LINESEARCH_ORDER_QUADRATIC, &
                        & err,error,*999)
                    CASE(SOLVER_NEWTON_LINESEARCH_CUBIC)
                      CALL Petsc_SnesLineSearchSetType(linesearch_solver%snesLineSearch,PETSC_SNES_LINESEARCH_BT,err,error,*999)
                      CALL Petsc_SnesLineSearchSetOrder(linesearch_solver%snesLineSearch,PETSC_SNES_LINESEARCH_ORDER_CUBIC, &
                        & err,error,*999)
                    CASE DEFAULT
                      localError="The nonlinear Newton line search type of "// &
                        & TRIM(NumberToVString(linesearch_solver%linesearch_type,"*",err,error))//" is invalid."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                    SELECT CASE(linesearch_solver%linesearch_type)
                    CASE(SOLVER_NEWTON_LINESEARCH_QUADRATIC,SOLVER_NEWTON_LINESEARCH_CUBIC)
                      ! Alpha parameter only applicable for back-tracking linesearch
                      CALL Petsc_SnesLineSearchBTSetAlpha(linesearch_solver%snesLineSearch,LINESEARCH_SOLVER%LINESEARCH_ALPHA, &
                        & err,error,*999)
                    END SELECT
                    !Set step tolerances, leave iterative line search options as defaults.
!!TODO: set the rtol, atol, ltol and maxits properly.
                    CALL Petsc_SnesLineSearchSetTolerances(linesearch_solver%snesLineSearch, &
                      & LINESEARCH_SOLVER%LINESEARCH_STEPTOLERANCE,LINESEARCH_SOLVER%LINESEARCH_MAXSTEP, &
                      & PETSC_DEFAULT_REAL,PETSC_DEFAULT_REAL,PETSC_DEFAULT_REAL,PETSC_DEFAULT_INTEGER,err,error,*999)
                    IF(linesearch_solver%linesearchMonitorOutput) THEN
                      CALL Petsc_SnesLineSearchSetMonitor(linesearch_solver%snesLineSearch,PETSC_TRUE,err,error,*999)
                    ELSE
                      CALL Petsc_SnesLineSearchSetMonitor(linesearch_solver%snesLineSearch,PETSC_FALSE,err,error,*999)
                    ENDIF
                    !Set the tolerances for the SNES solver
                    CALL Petsc_SnesSetTolerances(LINESEARCH_SOLVER%snes,NEWTON_SOLVER%ABSOLUTE_TOLERANCE, &
                      & NEWTON_SOLVER%RELATIVE_TOLERANCE,NEWTON_SOLVER%SOLUTION_TOLERANCE, &
                      & NEWTON_SOLVER%MAXIMUM_NUMBER_OF_ITERATIONS, &
                      & NEWTON_SOLVER%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS,err,error,*999)            
                    !Set any further SNES options from the command line options
                    CALL Petsc_SnesSetFromOptions(LINESEARCH_SOLVER%snes,err,error,*999)
                  ELSE
                    CALL FlagError("Newton linesearch solver linear solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Solver equations solver mapping is not associated.",err,error,*999)
                ENDIF
              CASE DEFAULT
                localError="The solver library type of "// &
                  & TRIM(NumberToVString(LINESEARCH_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              CALL FlagError("Solver solver equations is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Nonlinear solver solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Newton solver nonlinear solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Linesearch solver Newton solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Line search solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_LINESEARCH_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_LINESEARCH_CREATE_FINISH",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_LINESEARCH_CREATE_FINISH

  !
  !================================================================================================================================
  !

  !>Finalise a nonlinear Newton line search solver and deallocate all memory
  SUBROUTINE SOLVER_NEWTON_LINESEARCH_FINALISE(LINESEARCH_SOLVER,err,error,*)

    !Argument variables
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER !<A pointer the nonlinear Newton line search solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
  
    ENTERS("SOLVER_NEWTON_LINESEARCH_FINALISE",err,error,*999)

    IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
      CALL Petsc_MatColoringFinalise(LINESEARCH_SOLVER%jacobianMatColoring,err,error,*999)
      CALL Petsc_ISColoringFinalise(LINESEARCH_SOLVER%jacobianISColoring,err,error,*999)
      CALL Petsc_MatFDColoringFinalise(LINESEARCH_SOLVER%jacobianMatFDColoring,err,error,*999)
      CALL Petsc_SnesLineSearchFinalise(LINESEARCH_SOLVER%snesLineSearch,err,error,*999)
      CALL Petsc_SnesFinalise(LINESEARCH_SOLVER%snes,err,error,*999)
      DEALLOCATE(LINESEARCH_SOLVER)
    ENDIF
        
    EXITS("SOLVER_NEWTON_LINESEARCH_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_LINESEARCH_FINALISE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_LINESEARCH_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a nonlinear Newton line search solver for a Newton solver
  SUBROUTINE SOLVER_NEWTON_LINESEARCH_INITIALISE(NEWTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER !<A pointer the nonlinear Newton solver to initialise the Newton line search solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
  
    ENTERS("SOLVER_NEWTON_LINESEARCH_INITIALISE",err,error,*998)

    IF(ASSOCIATED(NEWTON_SOLVER)) THEN
      IF(ASSOCIATED(NEWTON_SOLVER%LINESEARCH_SOLVER)) THEN
        CALL FlagError("Netwon line search solver is already associated for this Newton solver.",err,error,*998)
      ELSE
        !Allocate and initialise the Newton linesearch solver
        ALLOCATE(NEWTON_SOLVER%LINESEARCH_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate nonlinear solver Newton line search solver.",err,error,*999)
        NEWTON_SOLVER%LINESEARCH_SOLVER%NEWTON_SOLVER=>NEWTON_SOLVER
        NEWTON_SOLVER%LINESEARCH_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
        NEWTON_SOLVER%LINESEARCH_SOLVER%LINESEARCH_TYPE=SOLVER_NEWTON_LINESEARCH_CUBIC
        NEWTON_SOLVER%LINESEARCH_SOLVER%LINESEARCH_ALPHA=0.0001_DP
        NEWTON_SOLVER%LINESEARCH_SOLVER%LINESEARCH_MAXSTEP=1.0E8_DP
        NEWTON_SOLVER%LINESEARCH_SOLVER%LINESEARCH_STEPTOLERANCE=CONVERGENCE_TOLERANCE
        CALL Petsc_MatColoringInitialise(NEWTON_SOLVER%LINESEARCH_SOLVER%jacobianMatColoring,err,error,*999)
        CALL Petsc_ISColoringInitialise(NEWTON_SOLVER%LINESEARCH_SOLVER%jacobianISColoring,err,error,*999)
        CALL Petsc_MatFDColoringInitialise(NEWTON_SOLVER%LINESEARCH_SOLVER%jacobianMatFDColoring,err,error,*999)
        CALL Petsc_SnesInitialise(NEWTON_SOLVER%LINESEARCH_SOLVER%snes,err,error,*999)
        CALL Petsc_SnesLineSearchInitialise(NEWTON_SOLVER%LINESEARCH_SOLVER%snesLineSearch,err,error,*999)
        NEWTON_SOLVER%LINESEARCH_SOLVER%linesearchMonitorOutput=.false.
      ENDIF
    ELSE
      CALL FlagError("Newton solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_NEWTON_LINESEARCH_INITIALISE")
    RETURN
999 CALL SOLVER_NEWTON_LINESEARCH_FINALISE(NEWTON_SOLVER%LINESEARCH_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_NEWTON_LINESEARCH_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_LINESEARCH_INITIALISE

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a nonlinear Newton linesearch solver. \todo should this be SOLVER_NONLINEAR_NEWTON_LINESEARCH_MAXSTEP_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonLineSearchMaxStepSet
  SUBROUTINE SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,LINESEARCH_MAXSTEP,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the line search maximum step for
    REAL(DP), INTENT(IN) :: LINESEARCH_MAXSTEP !<The line search maximum step to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(NEWTON_SOLVER%NEWTON_SOLVE_TYPE==SOLVER_NEWTON_LINESEARCH) THEN
                  LINESEARCH_SOLVER=>NEWTON_SOLVER%LINESEARCH_SOLVER
                  IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
                    IF(LINESEARCH_MAXSTEP>ZERO_TOLERANCE) THEN
                      LINESEARCH_SOLVER%LINESEARCH_MAXSTEP=LINESEARCH_MAXSTEP
                    ELSE
                      localError="The specified line search maximum step of "// &
                        & TRIM(NumberToVString(LINESEARCH_MAXSTEP,"*",err,error))// &
                        & " is invalid. The line search maximum step must be > 0."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The Newton solver line search solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Newton solver is not a line search solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET
        
  !
  !================================================================================================================================
  !

  !Solves a nonlinear Newton line search solver 
  SUBROUTINE SOLVER_NEWTON_LINESEARCH_SOLVE(LINESEARCH_SOLVER,err,error,*)

    !Argument variables
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER !<A pointer to the nonlinear Newton line search solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: CONVERGED_REASON,NUMBER_ITERATIONS
    REAL(DP) :: FUNCTION_NORM
    TYPE(DistributedVectorType), POINTER :: rhsVector,SOLVER_VECTOR
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(PetscVecType) :: FUNCTION_VECTOR
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_NEWTON_LINESEARCH_SOLVE",err,error,*999)

    IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
      NEWTON_SOLVER=>LINESEARCH_SOLVER%NEWTON_SOLVER
      IF(ASSOCIATED(NEWTON_SOLVER)) THEN
        NONLINEAR_SOLVER=>NEWTON_SOLVER%NONLINEAR_SOLVER
        IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
          SOLVER=>NONLINEAR_SOLVER%SOLVER
          IF(ASSOCIATED(SOLVER)) THEN
            SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
            IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
              SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
              IF(ASSOCIATED(SOLVER_MATRICES)) THEN
                IF(SOLVER_MATRICES%NUMBER_OF_MATRICES==1) THEN
                  rhsVector=>SOLVER_MATRICES%RHS_VECTOR
                  IF(ASSOCIATED(rhsVector)) THEN
                    SOLVER_VECTOR=>SOLVER_MATRICES%matrices(1)%ptr%SOLVER_VECTOR
                    IF(ASSOCIATED(SOLVER_VECTOR)) THEN
                      SELECT CASE(LINESEARCH_SOLVER%SOLVER_LIBRARY)
                      CASE(SOLVER_CMISS_LIBRARY)
                        CALL FlagError("Not implemented.",err,error,*999)
                      CASE(SOLVER_PETSC_LIBRARY)
                        SELECT CASE(NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE)
                        CASE(SOLVER_SOLUTION_INITIALISE_ZERO)
                          !Zero the solution vector
                          CALL DistributedVector_AllValuesSet(SOLVER_VECTOR,0.0_DP,err,error,*999)
                        CASE(SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD)
                          !Make sure the solver vector contains the current dependent field values
                          CALL SOLVER_SOLUTION_UPDATE(SOLVER,err,error,*999)
                        CASE(SOLVER_SOLUTION_INITIALISE_NO_CHANGE)
                          !Do nothing
                        CASE DEFAULT
                          localError="The Newton solver solution initialise type of "// &
                            & TRIM(NumberToVString(NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE,"*",err,error))// &
                            & " is invalid."
                          CALL FlagError(localError,err,error,*999)
                        END SELECT
                        !Solve the nonlinear equations
                        CALL Petsc_SnesSolve(LINESEARCH_SOLVER%snes,rhsVector%PETSC%VECTOR,SOLVER_VECTOR%PETSC%VECTOR, &
                          & err,error,*999)
                        !Check for convergence
                        CALL Petsc_SnesGetConvergedReason(LINESEARCH_SOLVER%snes,CONVERGED_REASON,err,error,*999)
                        SELECT CASE(CONVERGED_REASON)
                        CASE(PETSC_SNES_DIVERGED_FUNCTION_DOMAIN)
                          CALL FlagError("Nonlinear line search solver did not converge. PETSc diverged function domain.", &
                            & err,error,*999)
                        CASE(PETSC_SNES_DIVERGED_FUNCTION_COUNT)
                          CALL FlagError("Nonlinear line search solver did not converge. PETSc diverged function count.", &
                            & err,error,*999)
                        CASE(PETSC_SNES_DIVERGED_LINEAR_SOLVE)
                          CALL FlagError("Nonlinear line search solver did not converge. PETSc diverged linear solve.", &
                            & err,error,*999)
                        CASE(PETSC_SNES_DIVERGED_FNORM_NAN)
                          CALL FlagError("Nonlinear line search solver did not converge. PETSc diverged F Norm NaN.", &
                            & err,error,*999)
                        CASE(PETSC_SNES_DIVERGED_MAX_IT)
                          CALL FlagError("Nonlinear line search solver did not converge. PETSc diverged maximum iterations.", &
                            & err,error,*999)
                        CASE(PETSC_SNES_DIVERGED_LINE_SEARCH)
                          CALL FlagError("Nonlinear line search solver did not converge. PETSc diverged line search.", &
                            & err,error,*999)
                        CASE(PETSC_SNES_DIVERGED_LOCAL_MIN)
                          CALL FlagError("Nonlinear line search solver did not converge. PETSc diverged local minimum.", &
                            & err,error,*999)
                        END SELECT
                        IF(SOLVER%outputType>=SOLVER_SOLVER_OUTPUT) THEN
                          !Output solution characteristics
                          CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
                          CALL WriteString(GENERAL_OUTPUT_TYPE,"Newton linesearch solver parameters:",err,error,*999)
                          CALL Petsc_SnesGetIterationNumber(LINESEARCH_SOLVER%snes,NUMBER_ITERATIONS,err,error,*999)
                          CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Final number of iterations = ",NUMBER_ITERATIONS, &
                            & err,error,*999)
                          CALL Petsc_SnesGetFunction(LINESEARCH_SOLVER%snes,FUNCTION_VECTOR,err,error,*999)
                          CALL Petsc_VecNorm(FUNCTION_VECTOR,PETSC_NORM_2,FUNCTION_NORM,err,error,*999)
                          CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Final function norm = ",FUNCTION_NORM, &
                            & err,error,*999)
                          SELECT CASE(CONVERGED_REASON)
                          CASE(PETSC_SNES_CONVERGED_FNORM_ABS)
                            CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged F Norm absolute.", &
                              & err,error,*999)
                          CASE(PETSC_SNES_CONVERGED_FNORM_RELATIVE)
                            CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged F Norm relative.", &
                              & err,error,*999)
                          CASE(PETSC_SNES_CONVERGED_SNORM_RELATIVE)
                            CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged S Norm relative.", &
                              & err,error,*999)
                          CASE(PETSC_SNES_CONVERGED_ITS)
                            CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged its.",err,error,*999)
                          CASE(PETSC_SNES_CONVERGED_ITERATING)
                            CALL WriteString(GENERAL_OUTPUT_TYPE,"Converged Reason = PETSc converged iterating.",err,error,*999)
                          END SELECT
                        ENDIF
                      CASE DEFAULT
                        localError="The Newton line search solver library type of "// &
                          & TRIM(NumberToVString(LINESEARCH_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
                        CALL FlagError(localError,err,error,*999)
                      END SELECT
                    ELSE
                      CALL FlagError("Solver vector is not associated.",err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Solver RHS vector is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  localError="The number of solver matrices of "// &
                    & TRIM(NumberToVString(SOLVER_MATRICES%NUMBER_OF_MATRICES,"*",err,error))// &
                    & " is invalid. There should only be one solver matrix for a Newton linesearch solver."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Solver matrices is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver solver equations is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Nonlinear solver solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Newton solver nonlinear solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Linesearch solver Newton solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Linesearch solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_LINESEARCH_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_LINESEARCH_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_LINESEARCH_SOLVE
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a nonlinear Newton line search solver. \todo should this be SOLVER_NONLINEAR_NEWTON_LINESEARCH_STEPTOL_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonLineSearchStepTolSet
  SUBROUTINE SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,LINESEARCH_STEPTOL,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the line search step tolerance for
    REAL(DP), INTENT(IN) :: LINESEARCH_STEPTOL !<The line search step tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_LINESEARCH_STEPTOL_SET",err,error,*999)
    
    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(NEWTON_SOLVER%NEWTON_SOLVE_TYPE==SOLVER_NEWTON_LINESEARCH) THEN
                  LINESEARCH_SOLVER=>NEWTON_SOLVER%LINESEARCH_SOLVER
                  IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
                    IF(LINESEARCH_STEPTOL>ZERO_TOLERANCE) THEN
                      LINESEARCH_SOLVER%LINESEARCH_STEPTOLERANCE=LINESEARCH_STEPTOL
                    ELSE
                      localError="The specified line search step tolerance of "// &
                        & TRIM(NumberToVString(LINESEARCH_STEPTOL,"*",err,error))// &
                        & " is invalid. The line search step tolerance must be > 0."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The Newton solver line search solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Newton solver is not a line search solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The nonlinear Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_LINESEARCH_STEPTOL_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_LINESEARCH_STEPTOL_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_LINESEARCH_STEPTOL_SET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the line search type for a nonlinear Newton linesearch solver \todo should this be SOLVER_NONLINEAR_NEWTON_LINESEARCH_TYPE_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonLineSearchTypeSet
  SUBROUTINE SOLVER_NEWTON_LINESEARCH_TYPE_SET(SOLVER,LINESEARCH_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the line search type for
    INTEGER(INTG), INTENT(IN) :: LINESEARCH_TYPE !<The line search type to set \see SOLVER_ROUTINES_NewtonLineSearchTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: LINESEARCH_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_LINESEARCH_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(NEWTON_SOLVER%NEWTON_SOLVE_TYPE==SOLVER_NEWTON_LINESEARCH) THEN
                  LINESEARCH_SOLVER=>NEWTON_SOLVER%LINESEARCH_SOLVER
                  IF(ASSOCIATED(LINESEARCH_SOLVER)) THEN
                    SELECT CASE(LINESEARCH_TYPE)
                    CASE(SOLVER_NEWTON_LINESEARCH_NONORMS)
                      LINESEARCH_SOLVER%LINESEARCH_TYPE=SOLVER_NEWTON_LINESEARCH_NONORMS
                    CASE(SOLVER_NEWTON_LINESEARCH_LINEAR)
                      LINESEARCH_SOLVER%LINESEARCH_TYPE=SOLVER_NEWTON_LINESEARCH_LINEAR
                    CASE(SOLVER_NEWTON_LINESEARCH_QUADRATIC)
                      LINESEARCH_SOLVER%LINESEARCH_TYPE=SOLVER_NEWTON_LINESEARCH_QUADRATIC
                    CASE(SOLVER_NEWTON_LINESEARCH_CUBIC)
                      LINESEARCH_SOLVER%LINESEARCH_TYPE=SOLVER_NEWTON_LINESEARCH_CUBIC
                    CASE DEFAULT
                      localError="The specified line search type of "//TRIM(NumberToVString(LINESEARCH_TYPE,"*",err,error))// &
                        & " is invalid."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    CALL FlagError("The Newton solver line search solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Newton solver is not a line search solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_LINESEARCH_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_LINESEARCH_TYPE_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_LINESEARCH_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a nonlinear Newton solver. \todo should this be SOLVER_NONLINEAR_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonMaximumFunctionEvaluationsSet
  SUBROUTINE Solver_NewtonMaximumFunctionEvaluationsSet(SOLVER,MAXIMUM_FUNCTION_EVALUATIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the maximum function evaluations for
    INTEGER(INTG), INTENT(IN) :: MAXIMUM_FUNCTION_EVALUATIONS !<The maximum function evaluations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_NewtonMaximumFunctionEvaluationsSet",err,error,*999)
    
    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(MAXIMUM_FUNCTION_EVALUATIONS>0) THEN
                  NEWTON_SOLVER%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS=MAXIMUM_FUNCTION_EVALUATIONS
                ELSE
                  localError="The specified maximum number of function evaluations of "// &
                    & TRIM(NumberToVString(MAXIMUM_FUNCTION_EVALUATIONS,"*",err,error))// &
                    & " is invalid. The maximum number of function evaluations must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("Solver_NewtonMaximumFunctionEvaluationsSet")
    RETURN
999 ERRORSEXITS("Solver_NewtonMaximumFunctionEvaluationsSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_NewtonMaximumFunctionEvaluationsSet
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a nonlinear Newton solver. \todo should this be SOLVER_NONLINEAR_NEWTON_MAXIMUM_ITERATIONS_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonMaximumIterationsSet
  SUBROUTINE SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,MAXIMUM_ITERATIONS,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the maximum iterations for
    INTEGER(INTG), INTENT(IN) :: MAXIMUM_ITERATIONS !<The maximum iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(MAXIMUM_ITERATIONS>0) THEN
                  NEWTON_SOLVER%MAXIMUM_NUMBER_OF_ITERATIONS=MAXIMUM_ITERATIONS
                ELSE
                  localError="The specified maximum iterations of "//TRIM(NumberToVString(MAXIMUM_ITERATIONS,"*",err,error))// &
                    & " is invalid. The maximum number of iterations must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear sovler Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a nonlinear Newton solver. \todo should this be SOLVER_NONLINEAR_NEWTON_RELATIVE_TOLERANCE_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonRelativeToleranceSet
  SUBROUTINE SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,RELATIVE_TOLERANCE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the relative tolerance for
    REAL(DP), INTENT(IN) :: RELATIVE_TOLERANCE !<The relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_RELATIVE_TOLERANCE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(RELATIVE_TOLERANCE>ZERO_TOLERANCE) THEN
                  NEWTON_SOLVER%RELATIVE_TOLERANCE=RELATIVE_TOLERANCE
                ELSE
                  localError="The specified relative tolerance of "//TRIM(NumberToVString(RELATIVE_TOLERANCE,"*",err,error))// &
                    & " is invalid. The relative tolerance must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("The nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_RELATIVE_TOLERANCE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_RELATIVE_TOLERANCE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_RELATIVE_TOLERANCE_SET
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the solution initialisation for a nonlinear Newton solver
  SUBROUTINE SOLVER_NEWTON_SOLUTION_INIT_TYPE_SET(SOLVER,SOLUTION_INITIALISE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the solution tolerance for
    INTEGER(INTG), INTENT(IN) :: SOLUTION_INITIALISE_TYPE !<The solution initialise type to set \see SOLVER_ROUTINES_SolutionInitialiseTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_SOLUTION_INIT_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                SELECT CASE(SOLUTION_INITIALISE_TYPE)
                CASE(SOLVER_SOLUTION_INITIALISE_ZERO)
                  NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_ZERO
                CASE(SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD)
                  NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD
                CASE(SOLVER_SOLUTION_INITIALISE_NO_CHANGE)
                  NEWTON_SOLVER%SOLUTION_INITIALISE_TYPE=SOLVER_SOLUTION_INITIALISE_NO_CHANGE
                CASE DEFAULT
                  localError="The specified solution initialise type  of "// &
                    & TRIM(NumberToVString(SOLUTION_INITIALISE_TYPE,"*",err,error))//" is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ELSE
                CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF            
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_SOLUTION_INIT_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_SOLUTION_INIT_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_SOLUTION_INIT_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a nonlinear Newton solver. \todo should this be SOLVER_NONLINEAR_NEWTON_SOLUTION_TOLERANCE_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonSolutionToleranceSet
  SUBROUTINE SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,SOLUTION_TOLERANCE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the solution tolerance for
    REAL(DP), INTENT(IN) :: SOLUTION_TOLERANCE !<The solution tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_SOLUTION_TOLERANCE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(SOLUTION_TOLERANCE>ZERO_TOLERANCE) THEN
                  NEWTON_SOLVER%SOLUTION_TOLERANCE=SOLUTION_TOLERANCE
                ELSE
                  localError="The specified solution tolerance of "//TRIM(NumberToVString(SOLUTION_TOLERANCE,"*",err,error))// &
                    & " is invalid. The relative tolerance must be > 0."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF            
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_SOLUTION_TOLERANCE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_SOLUTION_TOLERANCE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_SOLUTION_TOLERANCE_SET
        
  !
  !================================================================================================================================
  !

  !Solves a nonlinear Newton solver 
  SUBROUTINE SOLVER_NEWTON_SOLVE(NEWTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER !<A pointer to the nonlinear Newton solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_NEWTON_SOLVE",err,error,*999)

    IF(ASSOCIATED(NEWTON_SOLVER)) THEN
      SELECT CASE(NEWTON_SOLVER%NEWTON_SOLVE_TYPE)
      CASE(SOLVER_NEWTON_LINESEARCH)
        CALL SOLVER_NEWTON_LINESEARCH_SOLVE(NEWTON_SOLVER%LINESEARCH_SOLVER,err,error,*999)
      CASE(SOLVER_NEWTON_TRUSTREGION)
        CALL SOLVER_NEWTON_TRUSTREGION_SOLVE(NEWTON_SOLVER%TRUSTREGION_SOLVER,err,error,*999)
      CASE DEFAULT
        localError="The nonlinear solver type of "// &
          & TRIM(NumberToVString(NEWTON_SOLVER%NEWTON_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Newton solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_NEWTON_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_SOLVE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_SOLVE
        
  !
  !================================================================================================================================
  !

  !>Finishes the process of creating nonlinear Newton trust region solver
  SUBROUTINE SOLVER_NEWTON_TRUSTREGION_CREATE_FINISH(TRUSTREGION_SOLVER,err,error,*)

    !Argument variables
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER !<A pointer the nonlinear Newton trust region solver to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    EXTERNAL :: Problem_SolverResidualEvaluatePetsc
    INTEGER(INTG) :: equations_matrix_idx,equations_set_idx
    TYPE(DistributedVectorType), POINTER :: residualVector
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMappingLinearType), POINTER :: linearMapping
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatricesLinearType), POINTER :: linearMatrices
    TYPE(EquationsMatrixType), POINTER :: equationsMatrix
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: LINEAR_VARIABLE
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError
  
    ENTERS("SOLVER_NEWTON_TRUSTREGION_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
      NEWTON_SOLVER=>TRUSTREGION_SOLVER%NEWTON_SOLVER
      IF(ASSOCIATED(NEWTON_SOLVER)) THEN
        NONLINEAR_SOLVER=>NEWTON_SOLVER%NONLINEAR_SOLVER
        IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
          SOLVER=>NONLINEAR_SOLVER%SOLVER
          IF(ASSOCIATED(SOLVER)) THEN
            SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
            IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
              SELECT CASE(TRUSTREGION_SOLVER%SOLVER_LIBRARY)
              CASE(SOLVER_CMISS_LIBRARY)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(SOLVER_PETSC_LIBRARY)
                SOLVER_MAPPING=>SOLVER_EQUATIONS%SOLVER_MAPPING
                IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                  !Loop over the equations set in the solver equations
                  DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                    EQUATIONS=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)%EQUATIONS
                    IF(ASSOCIATED(EQUATIONS)) THEN
                      EQUATIONS_SET=>equations%equationsSet
                      IF(ASSOCIATED(EQUATIONS_SET)) THEN
                        DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
                        IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
                          NULLIFY(vectorEquations)
                          CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)                         
                          vectorMapping=>vectorEquations%vectorMapping
                          IF(ASSOCIATED(vectorMapping)) THEN
                            linearMapping=>vectorMapping%linearMapping
                            IF(ASSOCIATED(linearMapping)) THEN
                              !If there are any linear matrices create temporary vector for matrix-vector products
                              vectorMatrices=>vectorEquations%vectorMatrices
                              IF(ASSOCIATED(vectorMatrices)) THEN
                                linearMatrices=>vectorMatrices%linearMatrices
                                IF(ASSOCIATED(linearMatrices)) THEN
                                  DO equations_matrix_idx=1,linearMatrices%numberOfLinearMatrices
                                    equationsMatrix=>linearMatrices%matrices(equations_matrix_idx)%ptr
                                    IF(ASSOCIATED(equationsMatrix)) THEN
                                      IF(.NOT.ASSOCIATED(equationsMatrix%tempVector)) THEN
                                        LINEAR_VARIABLE=>linearMapping%equationsMatrixToVarMaps(equations_matrix_idx)%VARIABLE
                                        IF(ASSOCIATED(LINEAR_VARIABLE)) THEN
                                          CALL DistributedVector_CreateStart(LINEAR_VARIABLE%DOMAIN_MAPPING, &
                                            & equationsMatrix%tempVector,err,error,*999)
                                          CALL DistributedVector_DataTypeSet(equationsMatrix%tempVector, &
                                            & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,err,error,*999)
                                          CALL DistributedVector_CreateFinish(equationsMatrix%tempVector,err,error,*999)
                                        ELSE
                                          CALL FlagError("Linear mapping linear variable is not associated.",err,error,*999)
                                        ENDIF
                                      ENDIF
                                    ELSE
                                      CALL FlagError("Equations matrix is not associated.",err,error,*999)
                                    ENDIF
                                  ENDDO !equations_matrix_idx
                                ELSE
                                  CALL FlagError("Equations matrices linear matrices is not associated.",err,error,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Equations equations matrices is not associated.",err,error,*999)
                              ENDIF
                            ENDIF
                          ELSE
                            CALL FlagError("Equations equations mapping is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          localError="Equations set dependent field is not associated for equations set index "// &
                            & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        localError="Equations equations set is not associated for equations set index "// &
                          & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                        CALL FlagError(localError,err,error,*999)
                      ENDIF
                    ELSE
                      localError="Equations is not associated for equations set index "// &
                        & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ENDDO !equations_set_idx
                  
                  !Create the solver matrices and vectors
                  CALL SOLVER_MATRICES_CREATE_START(SOLVER_EQUATIONS,SOLVER_MATRICES,err,error,*999)
                  CALL SolverMatrices_LibraryTypeSet(SOLVER_MATRICES,SOLVER_PETSC_LIBRARY,err,error,*999)
!!TODO: set up the matrix structure if using an analytic Jacobian
                  SELECT CASE(SOLVER_EQUATIONS%symmetryType)
                  CASE(SOLVER_SYMMETRIC_MATRICES)
                    CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_SYMMETRIC_TYPE],err,error,*999)
                  CASE(SOLVER_UNSYMMETRIC_MATRICES)
                    CALL SolverMatrices_SymmetryTypeSet(SOLVER_MATRICES,[DISTRIBUTED_MATRIX_UNSYMMETRIC_TYPE],err,error,*999)
                  CASE DEFAULT
                    localError="The specified solver equations symmetry type of "// &
                      & TRIM(NumberToVString(SOLVER_EQUATIONS%symmetryType,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                  CALL SOLVER_MATRICES_CREATE_FINISH(SOLVER_MATRICES,err,error,*999)
                  !Create the PETSc SNES solver
                  CALL Petsc_SnesCreate(computationalEnvironment%mpiCommunicator,TRUSTREGION_SOLVER%snes,err,error,*999)
                  !Set the nonlinear solver type to be a Newton trust region solver
                  CALL Petsc_SnesSetType(TRUSTREGION_SOLVER%snes,PETSC_SNESNEWTONTR,err,error,*999)
                  !Set the solver as the SNES application context
                  CALL Petsc_SnesSetApplicationContext(TRUSTREGION_SOLVER%snes,solver,err,error,*999)
                  !Set the nonlinear function
                  residualVector=>SOLVER_MATRICES%RESIDUAL
                  IF(ASSOCIATED(residualVector)) THEN
                    IF(ASSOCIATED(residualVector%PETSC)) THEN
                      CALL Petsc_SnesSetFunction(TRUSTREGION_SOLVER%snes,residualVector%PETSC%VECTOR, &
                        & Problem_SolverResidualEvaluatePetsc,SOLVER,err,error,*999)
                      CALL FlagError("The residual vector PETSc is not associated.",err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Solver matrices residual vector is not associated.",err,error,*999)
                  ENDIF
                  !Set the Jacobian if necessary
                  !Set the trust region delta ???
                  
                  !Set the trust region tolerance
                  CALL Petsc_SnesSetTrustRegionTolerance(TRUSTREGION_SOLVER%snes,TRUSTREGION_SOLVER%TRUSTREGION_TOLERANCE, &
                    & err,error,*999)
                  !Set the tolerances for the SNES solver
                  CALL Petsc_SnesSetTolerances(TRUSTREGION_SOLVER%snes,NEWTON_SOLVER%ABSOLUTE_TOLERANCE, &
                    & NEWTON_SOLVER%RELATIVE_TOLERANCE,NEWTON_SOLVER%SOLUTION_TOLERANCE, &
                    & NEWTON_SOLVER%MAXIMUM_NUMBER_OF_ITERATIONS,NEWTON_SOLVER%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS, &
                    & err,error,*999)
                  !Set any further SNES options from the command line options
                  CALL Petsc_SnesSetFromOptions(TRUSTREGION_SOLVER%snes,err,error,*999)
                ELSE
                  CALL FlagError("Solver equations solver mapping is not associated.",err,error,*999)
                ENDIF
              CASE DEFAULT
                localError="The solver library type of "// &
                  & TRIM(NumberToVString(TRUSTREGION_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              CALL FlagError("Solver solver equations is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Nonlinear solver solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Newton solver nonlinear solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Trust region Newton solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Trust region solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_NEWTON_TRUSTREGION_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_TRUSTREGION_CREATE_FINISH",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_TRUSTREGION_CREATE_FINISH

  !
  !================================================================================================================================
  !

  !>Sets/changes the trust region delta0 for a nonlinear Newton trust region solver solver. \todo should this be SOLVER_NONLINEAR_NEWTON_TRUSTREGION_DELTA0_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonTrustRegionDelta0Set
  SUBROUTINE SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,TRUSTREGION_DELTA0,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the trust region delta0 for
    REAL(DP), INTENT(IN) :: TRUSTREGION_DELTA0 !<The trust region delta0 to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_TRUSTREGION_DELTA0_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(NEWTON_SOLVER%NEWTON_SOLVE_TYPE==SOLVER_NEWTON_TRUSTREGION) THEN
                  TRUSTREGION_SOLVER=>NEWTON_SOLVER%TRUSTREGION_SOLVER
                  IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
                    IF(TRUSTREGION_DELTA0>ZERO_TOLERANCE) THEN
                      TRUSTREGION_SOLVER%TRUSTREGION_DELTA0=TRUSTREGION_DELTA0
                    ELSE
                      localError="The specified trust region delta0 of "// &
                        & TRIM(NumberToVString(TRUSTREGION_DELTA0,"*",err,error))// &
                        & " is invalid. The trust region delta0 must be > 0."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The Newton solver trust region solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Newton solver is not a trust region solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_TRUSTREGION_DELTA0_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_TRUSTREGION_DELTA0_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_TRUSTREGION_DELTA0_SET
        
  !
  !================================================================================================================================
  !
  
  !>Finalise a nonlinear Newton trust region solver and deallocate all memory
  SUBROUTINE SOLVER_NEWTON_TRUSTREGION_FINALISE(TRUSTREGION_SOLVER,err,error,*)

    !Argument variables
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER !<A pointer the non linear trust region solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
  
    ENTERS("SOLVER_NEWTON_TRUSTREGION_FINALISE",err,error,*999)

    IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN      
      CALL Petsc_SnesFinalise(TRUSTREGION_SOLVER%snes,err,error,*999)
      DEALLOCATE(TRUSTREGION_SOLVER)
    ENDIF
    
    EXITS("SOLVER_NEWTON_TRUSTREGION_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_TRUSTREGION_FINALISE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_TRUSTREGION_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a Newton trust region solver for a nonlinear solver
  SUBROUTINE SOLVER_NEWTON_TRUSTREGION_INITIALISE(NEWTON_SOLVER,err,error,*)

    !Argument variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER !<A pointer the Newton solver to initialise the trust region solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
  
    ENTERS("SOLVER_NEWTON_TRUSTREGION_INITIALISE",err,error,*998)

    IF(ASSOCIATED(NEWTON_SOLVER)) THEN
      IF(ASSOCIATED(NEWTON_SOLVER%TRUSTREGION_SOLVER)) THEN
        CALL FlagError("Trust region solver is already associated for this nonlinear solver.",err,error,*998)
      ELSE
        ALLOCATE(NEWTON_SOLVER%TRUSTREGION_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate Newton solver trust region solver.",err,error,*999)
        NEWTON_SOLVER%TRUSTREGION_SOLVER%NEWTON_SOLVER=>NEWTON_SOLVER
        NEWTON_SOLVER%TRUSTREGION_SOLVER%SOLVER_LIBRARY=SOLVER_PETSC_LIBRARY
!!TODO: set this properly
        NEWTON_SOLVER%TRUSTREGION_SOLVER%TRUSTREGION_DELTA0=0.01_DP
        CALL Petsc_SnesInitialise(NEWTON_SOLVER%TRUSTREGION_SOLVER%snes,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Newton solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_NEWTON_TRUSTREGION_INITIALISE")
    RETURN
999 CALL SOLVER_NEWTON_TRUSTREGION_FINALISE(NEWTON_SOLVER%TRUSTREGION_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_NEWTON_TRUSTREGION_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_TRUSTREGION_INITIALISE

  !
  !================================================================================================================================
  !

  !Solves a nonlinear Newton trust region solver 
  SUBROUTINE SOLVER_NEWTON_TRUSTREGION_SOLVE(TRUSTREGION_SOLVER,err,error,*)

    !Argument variables
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER !<A pointer to the nonlinear Newton trust region solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_NEWTON_TRUSTREGION_SOLVE",err,error,*999)

    IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
      NEWTON_SOLVER=>TRUSTREGION_SOLVER%NEWTON_SOLVER
      IF(ASSOCIATED(NEWTON_SOLVER)) THEN        
        NONLINEAR_SOLVER=>NEWTON_SOLVER%NONLINEAR_SOLVER
        IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
          SOLVER=>NONLINEAR_SOLVER%SOLVER
          IF(ASSOCIATED(SOLVER)) THEN
            SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
            IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
              SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
              IF(ASSOCIATED(SOLVER_MATRICES)) THEN
                SELECT CASE(TRUSTREGION_SOLVER%SOLVER_LIBRARY)
                CASE(SOLVER_CMISS_LIBRARY)
                  CALL FlagError("Not implemented.",err,error,*999)
                CASE(SOLVER_PETSC_LIBRARY)
                  CALL FlagError("Not implemented.",err,error,*999)
                CASE DEFAULT
                  localError="The nonlinear Newton trust region solver library type of "// &
                    & TRIM(NumberToVString(TRUSTREGION_SOLVER%SOLVER_LIBRARY,"*",err,error))//" is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              ELSE
                CALL FlagError("Solver matrices is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver solver equations is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Nonlinear solver solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Newton solver nonlinear solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Trust region solver Newton solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Trust region solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_NEWTON_TRUSTREGION_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_TRUSTREGION_SOLVE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_NEWTON_TRUSTREGION_SOLVE
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the trust region tolerance for a nonlinear Newton trust region solver. \todo should this be SOLVER_NONLINEAR_NEWTON_TRUSTREGION_TOLERANCE_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonTrustRegionToleranceSet
  SUBROUTINE SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(SOLVER,TRUSTREGION_TOLERANCE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the trust region tolerance for
    REAL(DP), INTENT(IN) :: TRUSTREGION_TOLERANCE !<The trust region tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: TRUSTREGION_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(NEWTON_SOLVER%NEWTON_SOLVE_TYPE==SOLVER_NEWTON_TRUSTREGION) THEN
                  TRUSTREGION_SOLVER=>NEWTON_SOLVER%TRUSTREGION_SOLVER
                  IF(ASSOCIATED(TRUSTREGION_SOLVER)) THEN
                    IF(TRUSTREGION_TOLERANCE>ZERO_TOLERANCE) THEN
                      TRUSTREGION_SOLVER%TRUSTREGION_TOLERANCE=TRUSTREGION_TOLERANCE
                    ELSE
                      localError="The specified trust region tolerance of "// &
                        & TRIM(NumberToVString(TRUSTREGION_TOLERANCE,"*",err,error))// &
                        & " is invalid. The trust region tolerance must be > 0."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The Newton solver trust region solver is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The Newton solver is not a trust region solver.",err,error,*999)
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the type of nonlinear Newton solver. \todo should this be SOLVER_NONLINEAR_NEWTON_TYPE_SET??? \see OpenCMISS::Iron::cmfe_SolverNewtonTypeSet
  SUBROUTINE SOLVER_NEWTON_TYPE_SET(SOLVER,NEWTON_SOLVE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the nonlinear Newton solver type
    INTEGER(INTG), INTENT(IN) :: NEWTON_SOLVE_TYPE !<The type of nonlinear solver to set \see SOLVER_ROUTINES_NewtonSolverTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: dummyError,localError
    
    ENTERS("SOLVER_NEWTON_TYPE_SET",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*998)
      ELSE
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE==SOLVER_NONLINEAR_NEWTON) THEN
              NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
              IF(ASSOCIATED(NEWTON_SOLVER)) THEN
                IF(NEWTON_SOLVE_TYPE/=NEWTON_SOLVER%NEWTON_SOLVE_TYPE) THEN
                  !Intialise the new solver type
                  SELECT CASE(NEWTON_SOLVE_TYPE)
                  CASE(SOLVER_NEWTON_LINESEARCH)
                    CALL SOLVER_NEWTON_LINESEARCH_INITIALISE(NEWTON_SOLVER,err,error,*999)
                  CASE(SOLVER_NEWTON_TRUSTREGION)
                    CALL SOLVER_NEWTON_TRUSTREGION_INITIALISE(NEWTON_SOLVER,err,error,*999)
                  CASE DEFAULT
                    localError="The Newton solver type of "//TRIM(NumberToVString(NEWTON_SOLVE_TYPE,"*",err,error))// &
                      & " is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                  !Finalise the old solver type
                  SELECT CASE(NEWTON_SOLVER%NEWTON_SOLVE_TYPE)
                  CASE(SOLVER_NEWTON_LINESEARCH)
                    CALL SOLVER_NEWTON_LINESEARCH_FINALISE(NEWTON_SOLVER%LINESEARCH_SOLVER,err,error,*999)
                  CASE(SOLVER_NEWTON_TRUSTREGION)
                    CALL SOLVER_NEWTON_TRUSTREGION_FINALISE(NEWTON_SOLVER%TRUSTREGION_SOLVER,err,error,*999)
                  CASE DEFAULT
                    localError="The Newton solver type of "// &
                      & TRIM(NumberToVString(NEWTON_SOLVER%NEWTON_SOLVE_TYPE,"*",err,error))//" is invalid."
                    CALL FlagError(localError,err,error,*999)
                  END SELECT
                  NEWTON_SOLVER%NEWTON_SOLVE_TYPE=NEWTON_SOLVE_TYPE
                ENDIF
              ELSE
                CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*998)
              ENDIF
            ELSE
              CALL FlagError("The nonlinear solver is not a Newton solver.",err,error,*998)
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*998)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
    
    EXITS("SOLVER_NEWTON_TYPE_SET")
    RETURN
999 SELECT CASE(NEWTON_SOLVE_TYPE)
    CASE(SOLVER_NEWTON_LINESEARCH)
      CALL SOLVER_NEWTON_LINESEARCH_FINALISE(NEWTON_SOLVER%LINESEARCH_SOLVER,dummyErr,dummyError,*998)
    CASE(SOLVER_NEWTON_TRUSTREGION)
      CALL SOLVER_NEWTON_TRUSTREGION_FINALISE(NEWTON_SOLVER%TRUSTREGION_SOLVER,dummyErr,dummyError,*998)
    END SELECT
998 ERRORSEXITS("SOLVER_NEWTON_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NEWTON_TYPE_SET
        
  !
  !================================================================================================================================
  !

        
  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a nonlinear solver 
  SUBROUTINE SOLVER_NONLINEAR_CREATE_FINISH(NONLINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER !<A pointer to the nonlinear solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_NONLINEAR_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
      SELECT CASE(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE)
      CASE(SOLVER_NONLINEAR_NEWTON)
        CALL SOLVER_NEWTON_CREATE_FINISH(NONLINEAR_SOLVER%NEWTON_SOLVER,err,error,*999)
      CASE(SOLVER_NONLINEAR_BFGS_INVERSE)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_NONLINEAR_SQP)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_NONLINEAR_QUASI_NEWTON)
        CALL SOLVER_QUASI_NEWTON_CREATE_FINISH(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER,err,error,*999)
      CASE DEFAULT
        localError="The nonlinear solver type of "// &
          & TRIM(NumberToVString(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Nonlinear solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_NONLINEAR_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVER_NONLINEAR_CREATE_FINISH",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NONLINEAR_CREATE_FINISH

  !
  !================================================================================================================================
  !

  !>Instead of warning on nonlinear divergence, exit with error
  SUBROUTINE SOLVER_NONLINEAR_DIVERGENCE_EXIT(SOLVER,err,error,*)
    TYPE(SOLVER_TYPE), INTENT(IN) :: SOLVER
    INTEGER(INTG), INTENT(OUT) :: err
    TYPE(VARYING_STRING), INTENT(OUT) :: error
    !Local variables
    TYPE(NONLINEAR_SOLVER_TYPE),POINTER :: NONLINEAR_SOLVER
    TYPE(NEWTON_SOLVER_TYPE),POINTER :: NEWTON_SOLVER
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE),POINTER :: NEWTON_LINESEARCH_SOLVER
    TYPE(QUASI_NEWTON_SOLVER_TYPE),POINTER :: QUASI_NEWTON_SOLVER
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE),POINTER :: QUASI_NEWTON_LINESEARCH_SOLVER
    INTEGER(INTG) :: CONVERGED_REASON

    ENTERS("SOLVER_NONLINEAR_DIVERGENCE_EXIT",err,error,*999)

    NULLIFY(NONLINEAR_SOLVER,NEWTON_SOLVER,NEWTON_LINESEARCH_SOLVER,QUASI_NEWTON_SOLVER,QUASI_NEWTON_LINESEARCH_SOLVER)

    NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
    IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
      SELECT CASE(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE)
      CASE(SOLVER_NONLINEAR_NEWTON)
        NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
        IF(ASSOCIATED(NEWTON_SOLVER)) THEN
          SELECT CASE (NEWTON_SOLVER%NEWTON_SOLVE_TYPE)
          CASE(SOLVER_NEWTON_LINESEARCH)
            NEWTON_LINESEARCH_SOLVER=>NEWTON_SOLVER%LINESEARCH_SOLVER
            IF(ASSOCIATED(NEWTON_LINESEARCH_SOLVER)) THEN
              CALL Petsc_SnesGetConvergedReason(NEWTON_LINESEARCH_SOLVER%snes,CONVERGED_REASON,err,error,*999)
                SELECT CASE(CONVERGED_REASON)
                CASE(PETSC_SNES_DIVERGED_FUNCTION_COUNT)
                  CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged function count.", &
                    & err,error,*999)
                CASE(PETSC_SNES_DIVERGED_LINEAR_SOLVE)
                  CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged linear solve.", &
                    & err,error,*999)
                CASE(PETSC_SNES_DIVERGED_FNORM_NAN)
                  CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged F Norm NaN.", &
                    & err,error,*999)
                CASE(PETSC_SNES_DIVERGED_MAX_IT)
                  CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged maximum iterations.", &
                    & err,error,*999)
                CASE(PETSC_SNES_DIVERGED_LINE_SEARCH)
                  CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged line search.", &
                    & err,error,*999)
                CASE(PETSC_SNES_DIVERGED_LOCAL_MIN)
                  CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged local minimum.", &
                    & err,error,*999)
                END SELECT
            ELSE
              CALL FlagError("Linesearch solver is not associated.",err,error,*999)
            ENDIF
          CASE(SOLVER_NEWTON_TRUSTREGION)
            !Not yet implemented. Don't kick up a fuss, just exit
          END SELECT
        ELSE
          CALL FlagError("Newton solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_NONLINEAR_BFGS_INVERSE)
        !Not yet implemented. Don't kick up a fuss, just exit
      CASE(SOLVER_NONLINEAR_SQP)
        !Not yet implemented. Don't kick up a fuss, just exit
      CASE(SOLVER_NONLINEAR_QUASI_NEWTON)
        QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
        IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
          QUASI_NEWTON_LINESEARCH_SOLVER=>QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER
          IF(ASSOCIATED(QUASI_NEWTON_LINESEARCH_SOLVER)) THEN
            CALL Petsc_SnesGetConvergedReason(QUASI_NEWTON_LINESEARCH_SOLVER%snes,CONVERGED_REASON,err,error,*999)
            SELECT CASE(CONVERGED_REASON)
            CASE(PETSC_SNES_DIVERGED_FUNCTION_COUNT)
              CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged function count.", &
                & err,error,*999)
            CASE(PETSC_SNES_DIVERGED_LINEAR_SOLVE)
              CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged linear solve.", &
                & err,error,*999)
            CASE(PETSC_SNES_DIVERGED_FNORM_NAN)
              CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged F Norm NaN.", &
                & err,error,*999)
            CASE(PETSC_SNES_DIVERGED_MAX_IT)
              CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged maximum iterations.", &
                & err,error,*999)
            CASE(PETSC_SNES_DIVERGED_LINE_SEARCH)
              CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged line search.", &
                & err,error,*999)
            CASE(PETSC_SNES_DIVERGED_LOCAL_MIN)
              CALL FlagError("Nonlinear line search solver did not converge. Exit due to PETSc diverged local minimum.", &
                & err,error,*999)
            END SELECT
          ELSE
              CALL FlagError("Linesearch solver is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Newton solver is not associated.",err,error,*999)
        ENDIF
      END SELECT
    ELSE
      CALL FlagError("Nonlinear solver is not associated.",err,error,*999)
    ENDIF

    EXITS("SOLVER_NONLINEAR_DIVERGENCE_EXIT")
    RETURN
999 ERRORSEXITS("SOLVER_NONLINEAR_DIVERGENCE_EXIT",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_NONLINEAR_DIVERGENCE_EXIT

  !
  !================================================================================================================================
  !

  !>Finalise a nonlinear solver for a solver.
  RECURSIVE SUBROUTINE SOLVER_NONLINEAR_FINALISE(NONLINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER !<A pointer the nonlinear solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_NONLINEAR_FINALISE",err,error,*999)

    IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
      SELECT CASE(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE)
      CASE(SOLVER_NONLINEAR_NEWTON)
        CALL SOLVER_NEWTON_FINALISE(NONLINEAR_SOLVER%NEWTON_SOLVER,err,error,*999)
      CASE(SOLVER_NONLINEAR_BFGS_INVERSE)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_NONLINEAR_SQP)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_NONLINEAR_QUASI_NEWTON)
        CALL SOLVER_QUASI_NEWTON_FINALISE(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER,err,error,*999)
      CASE DEFAULT
        localError="The nonlinear solver type of "// &
          & TRIM(NumberToVString(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
      DEALLOCATE(NONLINEAR_SOLVER)
    ENDIF
         
    EXITS("SOLVER_NONLINEAR_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVER_NONLINEAR_FINALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NONLINEAR_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise a nonlinear solver for a solver.
  SUBROUTINE SOLVER_NONLINEAR_INITIALISE(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to initialise the nonlinear solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError
    
    ENTERS("SOLVER_NONLINEAR_INITIALISE",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(SOLVER%NONLINEAR_SOLVER)) THEN
        CALL FlagError("Nonlinear solver is already associated for this solver.",err,error,*998)
      ELSE
        !Allocate and initialise a Nonlinear solver
        ALLOCATE(SOLVER%NONLINEAR_SOLVER,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate solver nonlinear solver.",err,error,*999)
        SOLVER%NONLINEAR_SOLVER%SOLVER=>SOLVER
        NULLIFY(SOLVER%NONLINEAR_SOLVER%NEWTON_SOLVER)
        !Default to a nonlinear Newton solver
        SOLVER%NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE=SOLVER_NONLINEAR_NEWTON
        CALL SOLVER_NEWTON_INITIALISE(SOLVER%NONLINEAR_SOLVER,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
        
    EXITS("SOLVER_NONLINEAR_INITIALISE")
    RETURN
999 CALL SOLVER_NONLINEAR_FINALISE(SOLVER%NONLINEAR_SOLVER,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_NONLINEAR_INITIALISE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NONLINEAR_INITIALISE

  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for a nonlinear solver.
  SUBROUTINE SOLVER_NONLINEAR_LIBRARY_TYPE_GET(NONLINEAR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER !<A pointer the nonlinear solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: SOLVER_LIBRARY_TYPE !<On exit, the type of library used for the nonlinear solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_NONLINEAR_LIBRARY_TYPE_GET",err,error,*999)

    IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
      SELECT CASE(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE)
      CASE(SOLVER_NONLINEAR_NEWTON)
        NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
        IF(ASSOCIATED(NEWTON_SOLVER)) THEN
          CALL SOLVER_NEWTON_LIBRARY_TYPE_GET(NEWTON_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_NONLINEAR_BFGS_INVERSE)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_NONLINEAR_SQP)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_NONLINEAR_QUASI_NEWTON)
        QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
        IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
          CALL SOLVER_QUASI_NEWTON_LIBRARY_TYPE_GET(QUASI_NEWTON_SOLVER, &
            & SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The nonlinear solver type of "// &
          & TRIM(NumberToVString(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Nonlinear solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NONLINEAR_LIBRARY_TYPE_GET")
    RETURN
999 ERRORSEXITS("SOLVER_NONLINEAR_LIBRARY_TYPE_GET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NONLINEAR_LIBRARY_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for a nonlinear solver.
  SUBROUTINE SOLVER_NONLINEAR_LIBRARY_TYPE_SET(NONLINEAR_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*)

    !Argument variables
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER !<A pointer the nonlinear solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: SOLVER_LIBRARY_TYPE !<The type of library for the nonlinear solver to set. \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: NEWTON_SOLVER
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(VARYING_STRING) :: localError
 
    ENTERS("SOLVER_NONLINEAR_LIBRARY_TYPE_SET",err,error,*999)
    
    IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
      SELECT CASE(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE)
      CASE(SOLVER_NONLINEAR_NEWTON)
        NEWTON_SOLVER=>NONLINEAR_SOLVER%NEWTON_SOLVER
        IF(ASSOCIATED(NEWTON_SOLVER)) THEN
          CALL SOLVER_NEWTON_LIBRARY_TYPE_SET(NEWTON_SOLVER,SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_NONLINEAR_BFGS_INVERSE)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_NONLINEAR_SQP)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE(SOLVER_NONLINEAR_QUASI_NEWTON)
        QUASI_NEWTON_SOLVER=>NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER
        IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
          CALL SOLVER_QUASI_NEWTON_LIBRARY_TYPE_SET(QUASI_NEWTON_SOLVER, &
            & SOLVER_LIBRARY_TYPE,err,error,*999)
        ELSE
          CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The nonlinear solver type of "// &
          & TRIM(NumberToVString(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Nonlinear solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_NONLINEAR_LIBRARY_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_NONLINEAR_LIBRARY_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NONLINEAR_LIBRARY_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Monitors the nonlinear solve.
  SUBROUTINE SOLVER_NONLINEAR_MONITOR(nonlinearSolver,its,norm,err,error,*)

   !Argument variables
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: nonlinearSolver !<A pointer to the nonlinear solver to monitor
    INTEGER(INTG), INTENT(IN) :: its !<The number of iterations
    REAL(DP), INTENT(IN) :: norm !<The residual norm
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    REAL(DP) :: xnorm !<The norm of the current solution 
    REAL(DP) :: fnorm !<The norm of the current function 
    REAL(DP) :: ynorm !<The norm of the current update
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: newtonLinesearchSolver
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: newtonSolver
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: quasiNewtonlinesearchSolver
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: QUASI_NEWTON_SOLVER
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_NONLINEAR_MONITOR",err,error,*999)

    IF(ASSOCIATED(nonlinearSolver)) THEN
        
      CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
      CALL WriteString(GENERAL_OUTPUT_TYPE,"Nonlinear solve monitor: ",err,error,*999)
      CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,ERROR,*999)
      CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Iteration number = ",its,err,error,*999)
      SELECT CASE(nonlinearSolver%NONLINEAR_SOLVE_TYPE)
      CASE(SOLVER_NONLINEAR_NEWTON)
        newtonSolver=>nonlinearSolver%NEWTON_SOLVER
        IF(ASSOCIATED(newtonSolver)) THEN
          SELECT CASE(newtonSolver%convergenceTestType)
            CASE(SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT)
              CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Function Norm = ",norm,err,error,*999)
            CASE(SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM)
              SELECT CASE(newtonSolver%NEWTON_SOLVE_TYPE)
              CASE(SOLVER_NEWTON_LINESEARCH)
                newtonLinesearchSolver=>newtonSolver%LINESEARCH_SOLVER
                IF(ASSOCIATED(newtonLinesearchSolver)) THEN
                  CALL petsc_SnesLineSearchGetNorms(newtonLinesearchSolver%sneslinesearch,xnorm,fnorm,ynorm,err,error,*999)
                  CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Solution Norm          = ",xnorm,err,error,*999)
                  CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Solution Update Norm   = ",ynorm,err,error,*999)
                  CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Function Norm          = ",fnorm,err,error,*999)
                  CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Normalised Energy Norm = ", &
                    & newtonSolver%convergenceTest%normalisedEnergy,err,error,*999)
                ELSE
                  CALL FlagError("Newton solver linesearch solver is not associated.",err,error,*999)
                ENDIF
              CASE(SOLVER_NEWTON_TRUSTREGION)
                CALL FlagError("The Newton Trust region solver is not implemented.",err,error,*999)
              CASE DEFAULT
                localError="The Newton solve type of "// &
                  & TRIM(NumberToVString(newtonSolver%NEWTON_SOLVE_TYPE,"*",err,error))//"is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            CASE(SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO)
              CALL FlagError("The Sum of differentiated ratios of unconstrained to constrained residuals"// &
                &  "convergence test type is not implemented.",err,error,*999)
            END SELECT
          CALL WriteString(GENERAL_OUTPUT_TYPE,"  Newton solver information: ",err,error,*999)          
          CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"    Number of function evaluations = ",newtonSolver% &
            & TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS,err,error,*999)
          CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"    Number of Jacobian evaluations = ",newtonSolver% &
            & TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS,err,error,*999)            
        ELSE
          CALL FlagError("Nonlinear solver Newton solver is not associated.",err,error,*999)
        ENDIF
      CASE(SOLVER_NONLINEAR_BFGS_INVERSE)
        !Do nothing
      CASE(SOLVER_NONLINEAR_SQP)
        !Do nothing
      CASE(SOLVER_NONLINEAR_QUASI_NEWTON)
        QUASI_NEWTON_SOLVER=>nonlinearSolver%QUASI_NEWTON_SOLVER
        IF(ASSOCIATED(QUASI_NEWTON_SOLVER)) THEN
          SELECT CASE(QUASI_NEWTON_SOLVER%convergenceTestType)
            CASE(SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT)
              CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Function Norm    = ",norm,err,error,*999)
            CASE(SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM)
              quasiNewtonLinesearchSolver=>QUASI_NEWTON_SOLVER%LINESEARCH_SOLVER
              IF(ASSOCIATED(quasiNewtonLinesearchSolver)) THEN
                CALL petsc_SnesLineSearchGetNorms(quasiNewtonLinesearchSolver%sneslinesearch, &
                  & xnorm,fnorm,ynorm,err,error,*999)
                CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Solution Norm          = ",xnorm,err,error,*999)
                CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Solution Update Norm   = ",ynorm,err,error,*999)
                CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Function Norm          = ",fnorm,err,error,*999)
                CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"  Normalised Energy Norm = ", &
                  & QUASI_NEWTON_SOLVER%convergenceTest%normalisedEnergy,err,error,*999)
              ELSE
                CALL FlagError("Quasi-Newton solver linesearch solver is not associated.",err,error,*999)
              ENDIF
            CASE(SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO)
              CALL FlagError("The Sum of differentiated ratios of unconstrained to constrained residuals"// &
                &  "convergence test type is not implemented.",err,error,*999)
            END SELECT
          CALL WriteString(GENERAL_OUTPUT_TYPE,"  Quasi-Newton solver information: ",err,error,*999)          
          CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"    Number of function evaluations = ",QUASI_NEWTON_SOLVER% &
            & TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS,err,error,*999)
          CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"    Number of Jacobian evaluations = ",QUASI_NEWTON_SOLVER% &
            & TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS,err,error,*999)            
        ELSE
          CALL FlagError("Nonlinear solver Quasi-Newton solver is not associated.",err,error,*999)
        ENDIF
      CASE DEFAULT
        localError="The nonlinear solver type of "// &
          & TRIM(NumberToVString(nonlinearSolver%NONLINEAR_SOLVE_TYPE,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ELSE
      CALL FlagError("Nonlinear solver is not associated.",err,error,*999)
    ENDIF
     
    EXITS("SOLVER_NONLINEAR_MONITOR")
    RETURN
999 ERRORSEXITS("SOLVER_NONLINEAR_MONITOR",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_NONLINEAR_MONITOR

  !
  !================================================================================================================================
  !

  !Solves a nonlinear solver 
  SUBROUTINE SOLVER_NONLINEAR_SOLVE(NONLINEAR_SOLVER,err,error,*)

    !Argument variables
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER !<A pointer to the nonlinear solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: solver_matrix_idx
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVER_NONLINEAR_SOLVE",err,error,*999)

    IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
      SOLVER=>NONLINEAR_SOLVER%SOLVER
      IF(ASSOCIATED(SOLVER)) THEN
        SELECT CASE(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE)
        CASE(SOLVER_NONLINEAR_NEWTON)
          CALL SOLVER_NEWTON_SOLVE(NONLINEAR_SOLVER%NEWTON_SOLVER,err,error,*999)
        CASE(SOLVER_NONLINEAR_BFGS_INVERSE)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(SOLVER_NONLINEAR_SQP)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE(SOLVER_NONLINEAR_QUASI_NEWTON)
          CALL SOLVER_QUASI_NEWTON_SOLVE(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER,err,error,*999)
        CASE DEFAULT
          localError="The nonlinear solver type of "// &
            & TRIM(NumberToVString(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE,"*",err,error))//" is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
        
        IF(SOLVER%outputType>=SOLVER_SOLVER_OUTPUT) THEN
          
#ifdef TAUPROF
          CALL TAU_STATIC_PHASE_START("Solution Output Phase")
#endif
          
          SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
          IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
            SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
            IF(ASSOCIATED(SOLVER_MATRICES)) THEN
              CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
              CALL WriteString(GENERAL_OUTPUT_TYPE,"Solver solution vectors:",err,error,*999)
              CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Number of solution vectors = ",SOLVER_MATRICES%NUMBER_OF_MATRICES, &
                & err,error,*999)
              DO solver_matrix_idx=1,SOLVER_MATRICES%NUMBER_OF_MATRICES
                CALL WriteStringValue(GENERAL_OUTPUT_TYPE,"Solution vector for solver matrix : ",solver_matrix_idx, &
                  & err,error,*999)
                CALL DistributedVector_Output(GENERAL_OUTPUT_TYPE,SOLVER_MATRICES%matrices(solver_matrix_idx)%ptr% &
                  & SOLVER_VECTOR,err,error,*999)
              ENDDO !solver_matrix_idx
            ELSE
              CALL FlagError("Solver equations solver matrices is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver solver equations is not associated.",err,error,*999)
          ENDIF
          
#ifdef TAUPROF
          CALL TAU_STATIC_PHASE_STOP("Solution Output Phase")
#endif
        ENDIF
      ELSE
        CALL FlagError("Nonlinear solver solver is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Nonlinear solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("SOLVER_NONLINEAR_SOLVE")
    RETURN
999 ERRORSEXITS("SOLVER_NONLINEAR_SOLVE",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NONLINEAR_SOLVE
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the type of nonlinear solver. \see OpenCMISS::Iron::cmfe_SolverNonlinearTypeSet
  SUBROUTINE SOLVER_NONLINEAR_TYPE_SET(SOLVER,NONLINEAR_SOLVE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the nonlinear solver type
    INTEGER(INTG), INTENT(IN) :: NONLINEAR_SOLVE_TYPE !<The type of nonlinear solver to set \see SOLVER_ROUTINES_NonlinearSolverTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: dummyError,localError
    
    ENTERS("SOLVER_NONLINEAR_TYPE_SET",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*998)
      ELSE
        CALL SOLVER_LINKED_SOLVER_REMOVE(SOLVER,SOLVER_LINEAR_TYPE,err,error,*999)
        IF(SOLVER%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
          NONLINEAR_SOLVER=>SOLVER%NONLINEAR_SOLVER
          IF(ASSOCIATED(NONLINEAR_SOLVER)) THEN
            IF(NONLINEAR_SOLVE_TYPE/=NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE) THEN
              !Finalise the old solver type
              SELECT CASE(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE)
              CASE(SOLVER_NONLINEAR_NEWTON)
                CALL SOLVER_NEWTON_FINALISE(NONLINEAR_SOLVER%NEWTON_SOLVER,err,error,*999)
              CASE(SOLVER_NONLINEAR_BFGS_INVERSE)
                CALL FlagError("Not implemented.",err,error,*999)                
              CASE(SOLVER_NONLINEAR_SQP)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(SOLVER_NONLINEAR_QUASI_NEWTON)
                CALL SOLVER_QUASI_NEWTON_FINALISE(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER,err,error,*999)
              CASE DEFAULT
                localError="The nonlinear solver type of "// &
                  & TRIM(NumberToVString(NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
              NONLINEAR_SOLVER%NONLINEAR_SOLVE_TYPE=NONLINEAR_SOLVE_TYPE
              !Intialise the new solver type
              SELECT CASE(NONLINEAR_SOLVE_TYPE)
              CASE(SOLVER_NONLINEAR_NEWTON)
                NULLIFY(NONLINEAR_SOLVER%NEWTON_SOLVER)
                CALL SOLVER_NEWTON_INITIALISE(NONLINEAR_SOLVER,err,error,*999)
              CASE(SOLVER_NONLINEAR_BFGS_INVERSE)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(SOLVER_NONLINEAR_SQP)
                CALL FlagError("Not implemented.",err,error,*999)
              CASE(SOLVER_NONLINEAR_QUASI_NEWTON)
                NULLIFY(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER)
                CALL SOLVER_QUASI_NEWTON_INITIALISE(NONLINEAR_SOLVER,err,error,*999)
              CASE DEFAULT
                localError="The specified nonlinear solver type of "// &
                  & TRIM(NumberToVString(NONLINEAR_SOLVE_TYPE,"*",err,error))//" is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          ELSE
            CALL FlagError("The solver nonlinear solver is not associated.",err,error,*998)
          ENDIF
        ELSE
          CALL FlagError("The solver is not a nonlinear solver.",err,error,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
    
    EXITS("SOLVER_NONLINEAR_TYPE_SET")
    RETURN
999 SELECT CASE(NONLINEAR_SOLVE_TYPE)
    CASE(SOLVER_NONLINEAR_NEWTON)
      CALL SOLVER_NEWTON_FINALISE(NONLINEAR_SOLVER%NEWTON_SOLVER,dummyErr,dummyError,*998)
    CASE(SOLVER_NONLINEAR_BFGS_INVERSE)
      CALL FlagError("Not implemented.",err,error,*998)                
    CASE(SOLVER_NONLINEAR_SQP)
      CALL FlagError("Not implemented.",err,error,*998)      
    CASE(SOLVER_NONLINEAR_QUASI_NEWTON)
      CALL SOLVER_QUASI_NEWTON_FINALISE(NONLINEAR_SOLVER%QUASI_NEWTON_SOLVER,dummyErr,dummyError,*998)
    END SELECT
998 ERRORSEXITS("SOLVER_NONLINEAR_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_NONLINEAR_TYPE_SET
  
  !
  !================================================================================================================================
  !

  !>Returns the type of certainty for an optimiser solver.
  SUBROUTINE Solver_OptimiserCertaintyTypeGet(optimiserSolver,solverCertaintyType,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to get the certainty type for.
    INTEGER(INTG), INTENT(OUT) :: solverCertaintyType !<On exit, the type of certainty for the optimiser solver \see SOLVER_ROUTINES_OptimiserCertaintyTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
 
    ENTERS("Solver_OptimiserCertaintyTypeGet",err,error,*999)

    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    solverCertaintyType=optimiserSolver%certaintyType
    
    EXITS("Solver_OptimiserCertaintyTypeGet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserCertaintyTypeGet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserCertaintyTypeGet

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of certainty for an optimisation solver.
  SUBROUTINE Solver_OptimiserCertaintyTypeSet(optimiserSolver,solverCertaintyType,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to set the certainty type for.
    INTEGER(INTG), INTENT(IN) :: solverCertaintyType !<The type of certainty for the optimiser solver to set. \see SOLVER_ROUTINES_OptimiserCertaintyType,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("Solver_OptimiserCertaintyTypeSet",err,error,*999)
    
    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    SELECT CASE(solverCertaintyType)
    CASE(SOLVER_OPTIMISER_DETERMINISTIC_CERTAINTY)
      optimiserSolver%certaintyType=SOLVER_OPTIMISER_DETERMINISTIC_CERTAINTY
    CASE(SOLVER_OPTIMISER_STOCHASTIC_CERTAINTY)
      optimiserSolver%certaintyType=SOLVER_OPTIMISER_STOCHASTIC_CERTAINTY
    CASE DEFAULT
      localError="The specified certainty type of "//TRIM(NumberToVString(solverCertaintyType,"*",err,error))// &
        & " is invalid for an optimiser solver."
      CALL FlagError(localError,err,error,*999)
    END SELECT
        
    EXITS("Solver_OptimiserCertaintyTypeSet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserCertaintyTypeSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserCertaintyTypeSet

  !
  !================================================================================================================================
  !

  !>Returns the type of constraints for an optimiser solver.
  SUBROUTINE Solver_OptimiserConstraintTypeGet(optimiserSolver,solverConstraintType,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to get the constraint type for.
    INTEGER(INTG), INTENT(OUT) :: solverConstraintType !<On exit, the type of constraint for the optimiser solver \see SOLVER_ROUTINES_OptimiserConstraintTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
 
    ENTERS("Solver_OptimiserConstraintTypeGet",err,error,*999)

    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    solverConstraintType=optimiserSolver%constraintType
    
    EXITS("Solver_OptimiserConstraintTypeGet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserConstraintTypeGet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserConstraintTypeGet

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of constraint for an optimisation solver.
  SUBROUTINE Solver_OptimiserConstraintTypeSet(optimiserSolver,solverConstraintType,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to set the constraint type for.
    INTEGER(INTG), INTENT(IN) :: solverConstraintType !<The type of constraint for the optimiser solver to set. \see SOLVER_ROUTINES_OptimiserConstraintType,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("Solver_OptimiserConstraintTypeSet",err,error,*999)
    
    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    SELECT CASE(solverConstraintType)
    CASE(SOLVER_OPTIMISER_UNCONSTRAINED)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(SOLVER_OPTIMISER_BOUND_CONSTRAINED)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(SOLVER_OPTIMISER_LINEAR_CONSTRAINTS)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(SOLVER_OPTIMISER_NONLINEAR_CONSTRAINTS)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(SOLVER_OPTIMISER_PDE_CONSTRAINTS)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE DEFAULT
      localError="The specified constraint type of "//TRIM(NumberToVString(solverConstraintType,"*",err,error))// &
        & " is invalid for an optimiser solver."
      CALL FlagError(localError,err,error,*999)
    END SELECT
        
    EXITS("Solver_OptimiserConstraintTypeSet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserConstraintTypeSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserConstraintTypeSet

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating an optimiser solver 
  SUBROUTINE Solver_OptimiserCreateFinish(optimiserSolver,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer to the optimiser solver to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Solver_OptimiserCreateFinish",err,error,*999)

    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    CALL FlagError("Not implemented.",err,error,*999)
         
    EXITS("Solver_OptimiserCreateFinish")
    RETURN
999 ERRORSEXITS("Solver_OptimiserCreateFinish",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserCreateFinish
        
  !
  !================================================================================================================================
  !

  !>Finalise a optimiser solver.
  SUBROUTINE Solver_OptimiserFinalise(optimiserSolver,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Solver_OptimiserFinalise",err,error,*999)

    IF(ASSOCIATED(optimiserSolver)) THEN        
      DEALLOCATE(optimiserSolver)
    ENDIF
         
    EXITS("Solver_OptimiserFinalise")
    RETURN
999 ERRORSEXITS("Solver_OptimiserFinalise",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserFinalise

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of gradient calculation type for an optimisation solver.
  SUBROUTINE Solver_OptimiserGradientCalculationTypeSet(solver,gradientCalculationType,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the gradient calculation type
    INTEGER(INTG), INTENT(IN) :: gradientCalculationType !<The type of gradient calculation type to set for an optimisation solver \see SOLVER_ROUTINES_OptimiserGradientCalculationTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_OptimiserGradientCalculationTypeSet",err,error,*999)

    IF(.NOT.ASSOCIATED(solver)) CALL FlagError("Solver is not associated",err,error,*999)
    IF(solver%SOLVER_FINISHED) CALL FlagError("Solver has already been finished",err,error,*999)
    IF(solver%SOLVE_TYPE/=SOLVER_OPTIMISER_TYPE) CALL FlagError("The solver is not an optimiser solver",err,error,*999)
    IF(.NOT.ASSOCIATED(solver%optimiserSolver)) CALL FlagError("The solver optimiser solver is not associated",err,error,*999)

    optimiserSolver=>solver%optimiserSolver
    IF(gradientCalculationType/=optimiserSolver%gradientCalculationType) THEN
      SELECT CASE(gradientCalculationType)
      CASE(SOLVER_OPTIMISER_GRADIENT_NOT_CALCULATED)
        optimiserSolver%gradientCalculationType=SOLVER_OPTIMISER_GRADIENT_NOT_CALCULATED
      CASE(SOLVER_OPTIMISER_GRADIENT_EQUATIONS_CALCULATED)
        optimiserSolver%gradientCalculationType=SOLVER_OPTIMISER_GRADIENT_EQUATIONS_CALCULATED
      CASE(SOLVER_OPTIMISER_GRADIENT_FD_CALCULATED)
        optimiserSolver%gradientCalculationType=SOLVER_OPTIMISER_GRADIENT_FD_CALCULATED
      CASE DEFAULT
        localError="The gradient calculation type of "//TRIM(NumberToVString(gradientCalculationType,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ENDIF
    
    EXITS("Solver_OptimiserGradientCalculationTypeSet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserGradientCalculationTypeSet",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_OptimiserGradientCalculationTypeSet
        
  !
  !================================================================================================================================
  !

  !>Sets/changes the type of Hessian calculation type for an optimisation solver.
  SUBROUTINE Solver_OptimiserHessianCalculationTypeSet(solver,hessianCalculationType,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to set the Hessian calculation type
    INTEGER(INTG), INTENT(IN) :: hessianCalculationType !<The type of Hessian calculation type to set for an optimisation solver \see SOLVER_ROUTINES_OptimiserHessianCalculationTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("Solver_OptimiserHessianCalculationTypeSet",err,error,*999)

    IF(.NOT.ASSOCIATED(solver)) CALL FlagError("Solver is not associated",err,error,*999)
    IF(solver%SOLVER_FINISHED) CALL FlagError("Solver has already been finished",err,error,*999)
    IF(solver%SOLVE_TYPE/=SOLVER_OPTIMISER_TYPE) CALL FlagError("The solver is not an optimiser solver",err,error,*999)
    IF(.NOT.ASSOCIATED(solver%optimiserSolver)) CALL FlagError("The solver optimiser solver is not associated",err,error,*999)

    optimiserSolver=>solver%optimiserSolver
    IF(hessianCalculationType/=optimiserSolver%hessianCalculationType) THEN
      SELECT CASE(hessianCalculationType)
      CASE(SOLVER_OPTIMISER_HESSIAN_NOT_CALCULATED)
        optimiserSolver%hessianCalculationType=SOLVER_OPTIMISER_HESSIAN_NOT_CALCULATED
      CASE(SOLVER_OPTIMISER_HESSIAN_EQUATIONS_CALCULATED)
        optimiserSolver%hessianCalculationType=SOLVER_OPTIMISER_HESSIAN_EQUATIONS_CALCULATED
      CASE(SOLVER_OPTIMISER_HESSIAN_FD_CALCULATED)
        optimiserSolver%hessianCalculationType=SOLVER_OPTIMISER_HESSIAN_FD_CALCULATED
      CASE DEFAULT
        localError="The Hessian calculation type of "//TRIM(NumberToVString(hessianCalculationType,"*",err,error))//" is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    ENDIF
    
    EXITS("Solver_OptimiserHessianCalculationTypeSet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserHessianCalculationTypeSet",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_OptimiserHessianCalculationTypeSet
        
  !
  !================================================================================================================================
  !

  !>Initialise an optimiser solver for a solver.
  SUBROUTINE Solver_OptimiserInitialise(solver,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to initialise the optimiser solver for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("Solver_OptimiserInitialise",err,error,*998)

    IF(.NOT.ASSOCIATED(solver)) CALL FlagError("Solver is not associated.",err,error,*998)
    IF(ASSOCIATED(solver%optimiserSolver)) CALL FlagError("Optimiser solver is already associated for this solver.",err,error,*998)
     
    ALLOCATE(solver%optimiserSolver,STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate solver optimiser solver.",err,error,*999)
    solver%optimiserSolver%solver=>solver
    solver%optimiserSolver%solverLibrary=SOLVER_PETSC_LIBRARY
    solver%optimiserSolver%variableType=SOLVER_OPTIMISER_CONTINUOUS_VARIABLES
    solver%optimiserSolver%objectiveType=SOLVER_OPTIMISER_ONE_OBJECTIVE
    solver%optimiserSolver%constraintType=SOLVER_OPTIMISER_UNCONSTRAINED
    solver%optimiserSolver%certaintyType=SOLVER_OPTIMISER_DETERMINISTIC_CERTAINTY
    solver%optimiserSolver%gradientCalculationType=SOLVER_OPTIMISER_GRADIENT_FD_CALCULATED
    solver%optimiserSolver%hessianCalculationType=SOLVER_OPTIMISER_HESSIAN_FD_CALCULATED
        
    EXITS("Solver_OptimiserInitialise")
    RETURN
999 CALL Solver_OptimiserFinalise(solver%optimiserSolver,dummyErr,dummyError,*998)
998 ERRORSEXITS("Solver_OptimiserInitialise",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserInitialise

  !
  !================================================================================================================================
  !

  !>Returns the type of library to use for an optimiser solver.
  SUBROUTINE Solver_OptimiserLibraryTypeGet(optimiserSolver,solverLibraryType,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: solverLibraryType !<On exit, the type of library used for the optimiser solver \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
 
    ENTERS("Solver_OptimiserLibraryTypeGet",err,error,*999)

    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    solverLibraryType=optimiserSolver%solverLibrary
    
    EXITS("Solver_OptimiserLibraryTypeGet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserLibraryTypeGet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserLibraryTypeGet

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library to use for an optimisation solver.
  SUBROUTINE Solver_OptimiserLibraryTypeSet(optimiserSolver,solverLibraryType,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: solverLibraryType !<The type of library for the optimiser solver to set. \see SOLVER_ROUTINES_SolverLibraries,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("Solver_OptimiserLibraryTypeSet",err,error,*999)
    
    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    SELECT CASE(solverLibraryType)
    CASE(SOLVER_CMISS_LIBRARY)
      CALL FlagError("Not implemented.",err,error,*999)
    CASE(SOLVER_PETSC_LIBRARY)
      optimiserSolver%solverLibrary=SOLVER_PETSC_LIBRARY
    CASE DEFAULT
      localError="The specified solver library type of "//TRIM(NumberToVString(solverLibraryType,"*",err,error))// &
        & " is invalid for an optimiser solver."
      CALL FlagError(localError,err,error,*999)
    END SELECT
        
    EXITS("Solver_OptimiserLibraryTypeSet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserLibraryTypeSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserLibraryTypeSet

  !
  !================================================================================================================================
  !

  !>Monitors the optimiser solve.
  SUBROUTINE Solver_OptimiserMonitor(optimiserSolver,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer to the optimiser solver to monitor
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    
    ENTERS("Solver_OptimiserSolver",err,error,*999)

    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
        
    CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
    CALL WriteString(GENERAL_OUTPUT_TYPE,"Optimiser solve monitor: ",err,error,*999)
    CALL WriteString(GENERAL_OUTPUT_TYPE,"",err,error,*999)
     
    EXITS("Solver_OptimiserMonitor")
    RETURN
999 ERRORSEXITS("Solver_OptimiserMonitor",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_OptimiserMonitor

  !
  !================================================================================================================================
  !

  !>Returns the type of objective for an optimiser solver.
  SUBROUTINE Solver_OptimiserObjectiveTypeGet(optimiserSolver,solverObjectiveType,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to get the objective type for.
    INTEGER(INTG), INTENT(OUT) :: solverObjectiveType !<On exit, the type of objective for the optimiser solver \see SOLVER_ROUTINES_OptimiserObjectiveTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
 
    ENTERS("Solver_OptimiserObjectiveTypeGet",err,error,*999)

    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    solverObjectiveType=optimiserSolver%objectiveType
    
    EXITS("Solver_OptimiserObjectiveTypeGet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserObjectiveTypeGet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserObjectiveTypeGet

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of objective for an optimisation solver.
  SUBROUTINE Solver_OptimiserObjectiveTypeSet(optimiserSolver,solverObjectiveType,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to set the objective type for.
    INTEGER(INTG), INTENT(IN) :: solverObjectiveType !<The type of objective for the optimiser solver to set. \see SOLVER_ROUTINES_OptimiserObjectiveType,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("Solver_OptimiserObjectiveTypeSet",err,error,*999)
    
    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    SELECT CASE(solverObjectiveType)
    CASE(SOLVER_OPTIMISER_NO_OBJECTIVE)
      optimiserSolver%objectiveType=SOLVER_OPTIMISER_NO_OBJECTIVE
    CASE(SOLVER_OPTIMISER_ONE_OBJECTIVE)
      optimiserSolver%objectiveType=SOLVER_OPTIMISER_ONE_OBJECTIVE
    CASE(SOLVER_OPTIMISER_MANY_OBJECTIVE)
      optimiserSolver%objectiveType=SOLVER_OPTIMISER_MANY_OBJECTIVE
    CASE DEFAULT
      localError="The specified objective type of "//TRIM(NumberToVString(solverObjectiveType,"*",err,error))// &
        & " is invalid for an optimiser solver."
      CALL FlagError(localError,err,error,*999)
    END SELECT
        
    EXITS("Solver_OptimiserObjectiveTypeSet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserObjectiveTypeSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserObjectiveTypeSet

  !
  !================================================================================================================================
  !

  !>Solve an optimiser solver
  SUBROUTINE Solver_OptimiserSolve(optimiserSolver,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("Solver_OptimiserSolve",err,error,*999)

    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    CALL FlagError("Not implemented.",err,error,*999)
         
    EXITS("Solver_OptimiserSolve")
    RETURN
999 ERRORSEXITS("Solver_OptimiserSolve",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserSolve

  !
  !================================================================================================================================
  !

  !>Returns the type of variable for an optimiser solver.
  SUBROUTINE Solver_OptimiserVariableTypeGet(optimiserSolver,solverVariableType,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to get the variable type for.
    INTEGER(INTG), INTENT(OUT) :: solverVariableType !<On exit, the type of variable for the optimiser solver \see SOLVER_ROUTINES_OptimiserVariableTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
 
    ENTERS("Solver_OptimiserVariableTypeGet",err,error,*999)

    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    solverVariableType=optimiserSolver%variableType
    
    EXITS("Solver_OptimiserVariableTypeGet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserVariableTypeGet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserVariableTypeGet

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of variable type for an optimisation solver.
  SUBROUTINE Solver_OptimiserVariableTypeSet(optimiserSolver,solverVariableType,err,error,*)

    !Argument variables
    TYPE(OptimiserSolverType), POINTER :: optimiserSolver !<A pointer the optimiser solver to set the variable type for.
    INTEGER(INTG), INTENT(IN) :: solverVariableType !<The type of variable for the optimiser solver to set. \see SOLVER_ROUTINES_OptimiserVariableType,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("Solver_OptimiserVariableTypeSet",err,error,*999)
    
    IF(.NOT.ASSOCIATED(optimiserSolver)) CALL FlagError("Optimiser solver is not associated.",err,error,*999)
    
    SELECT CASE(solverVariableType)
    CASE(SOLVER_OPTIMISER_CONTINUOUS_VARIABLES)
      optimiserSolver%variableType=SOLVER_OPTIMISER_CONTINUOUS_VARIABLES
    CASE(SOLVER_OPTIMISER_DISCRETE_VARIABLES)
      optimiserSolver%variableType=SOLVER_OPTIMISER_DISCRETE_VARIABLES
    CASE DEFAULT
      localError="The specified variable type of "//TRIM(NumberToVString(solverVariableType,"*",err,error))// &
        & " is invalid for an optimiser solver."
      CALL FlagError(localError,err,error,*999)
    END SELECT
        
    EXITS("Solver_OptimiserVariableTypeSet")
    RETURN
999 ERRORSEXITS("Solver_OptimiserVariableTypeSet",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_OptimiserVariableTypeSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for a solver. \see OpenCMISS::Iron::cmfe_SolverOutputTypeSet
  SUBROUTINE SOLVER_OUTPUT_TYPE_SET(SOLVER,OUTPUT_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the output type for
    INTEGER(INTG), INTENT(IN) :: OUTPUT_TYPE !<The type of solver output to be set \see SOLVER_ROUTINES_OutputTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("SOLVER_OUTPUT_TYPE_SET",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*999)
      ELSE        
        SELECT CASE(OUTPUT_TYPE)
        CASE(SOLVER_NO_OUTPUT)
          SOLVER%outputType=SOLVER_NO_OUTPUT
        CASE(SOLVER_MONITOR_OUTPUT)
          SOLVER%outputType=SOLVER_MONITOR_OUTPUT
        CASE(SOLVER_PROGRESS_OUTPUT)
          SOLVER%outputType=SOLVER_PROGRESS_OUTPUT
        CASE(SOLVER_TIMING_OUTPUT)
          SOLVER%outputType=SOLVER_TIMING_OUTPUT
        CASE(SOLVER_SOLVER_OUTPUT)
          SOLVER%outputType=SOLVER_SOLVER_OUTPUT
        CASE(SOLVER_MATRIX_OUTPUT)
          SOLVER%outputType=SOLVER_MATRIX_OUTPUT         
        CASE DEFAULT
          localError="The specified solver output type of "// &
            & TRIM(NumberToVString(OUTPUT_TYPE,"*",err,error))//" is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_OUTPUT_TYPE_SET")
    RETURN
999 ERRORSEXITS("SOLVER_OUTPUT_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_OUTPUT_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Updates the solver solution from the field variables
  SUBROUTINE SOLVER_SOLUTION_UPDATE(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to update the solution from
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: column_number,equations_set_idx,local_number,solver_matrix_idx,variable_dof_idx,variable_idx,variable_type, &
      & interface_condition_idx
    REAL(DP) :: additive_constant,VALUE,coupling_coefficient
    REAL(DP), POINTER :: VARIABLE_DATA(:)
    TYPE(DistributedVectorType), POINTER :: SOLVER_VECTOR
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: DOMAIN_MAPPING
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD,LAGRANGE_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DEPENDENT_VARIABLE,LAGRANGE_VARIABLE
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX
 
    NULLIFY(VARIABLE_DATA)
    
    ENTERS("SOLVER_SOLUTION_UPDATE",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
          IF(ASSOCIATED(SOLVER_MATRICES)) THEN
            SOLVER_MAPPING=>SOLVER_MATRICES%SOLVER_MAPPING
            IF(ASSOCIATED(SOLVER_MAPPING)) THEN
              DO solver_matrix_idx=1,SOLVER_MATRICES%NUMBER_OF_MATRICES
                SOLVER_MATRIX=>SOLVER_MATRICES%matrices(solver_matrix_idx)%ptr
                IF(ASSOCIATED(SOLVER_MATRIX)) THEN
                  SOLVER_VECTOR=>SOLVER_MATRIX%SOLVER_VECTOR
                  IF(ASSOCIATED(SOLVER_VECTOR)) THEN
                    DOMAIN_MAPPING=>SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)%COLUMN_DOFS_MAPPING
                    IF(ASSOCIATED(DOMAIN_MAPPING)) THEN
                      DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                        DO variable_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_VARIABLES
                          DEPENDENT_VARIABLE=>SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                            & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%VARIABLES(variable_idx)%ptr
                          IF(ASSOCIATED(DEPENDENT_VARIABLE)) THEN
                            variable_type=DEPENDENT_VARIABLE%VARIABLE_TYPE
                            DEPENDENT_FIELD=>DEPENDENT_VARIABLE%FIELD
                            NULLIFY(VARIABLE_DATA)
                            CALL Field_ParameterSetDataGet(DEPENDENT_FIELD,variable_type,FIELD_VALUES_SET_TYPE,VARIABLE_DATA, &
                              & err,error,*999)
                            DO variable_dof_idx=1,DEPENDENT_VARIABLE%NUMBER_OF_DOFS
                              column_number=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%VARIABLE_TO_SOLVER_COL_MAPS(variable_idx)% &
                                & COLUMN_NUMBERS(variable_dof_idx)
                              IF(column_number/=0) THEN
                                coupling_coefficient=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                  & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%VARIABLE_TO_SOLVER_COL_MAPS( &
                                  & variable_idx)%COUPLING_COEFFICIENTS(variable_dof_idx)
                                additive_constant=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                                  & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%VARIABLE_TO_SOLVER_COL_MAPS( &
                                  & variable_idx)%ADDITIVE_CONSTANTS(variable_dof_idx)
                                VALUE=VARIABLE_DATA(variable_dof_idx)*coupling_coefficient+additive_constant
                                local_number=DOMAIN_MAPPING%GLOBAL_TO_LOCAL_MAP(column_number)%LOCAL_NUMBER(1)
                                CALL DistributedVector_ValuesSet(SOLVER_VECTOR,local_number,VALUE,err,error,*999)
                              ENDIF
                            ENDDO !variable_dof_idx
                            CALL Field_ParameterSetDataRestore(DEPENDENT_FIELD,variable_type,FIELD_VALUES_SET_TYPE, &
                              & VARIABLE_DATA,err,error,*999)
                          ELSE
                            CALL FlagError("Variable is not associated.",err,error,*999)
                          ENDIF
                        ENDDO !variable_idx
                      ENDDO !equations_set_idx
                      DO interface_condition_idx=1,SOLVER_MAPPING%NUMBER_OF_INTERFACE_CONDITIONS
                        LAGRANGE_VARIABLE=>SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                          & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%LAGRANGE_VARIABLE
                        IF(ASSOCIATED(DEPENDENT_VARIABLE)) THEN
                          variable_type=LAGRANGE_VARIABLE%VARIABLE_TYPE
                          LAGRANGE_FIELD=>LAGRANGE_VARIABLE%FIELD
                          NULLIFY(VARIABLE_DATA)
                          CALL Field_ParameterSetDataGet(LAGRANGE_FIELD,variable_type,FIELD_VALUES_SET_TYPE,VARIABLE_DATA, &
                            & err,error,*999)
                          DO variable_dof_idx=1,LAGRANGE_VARIABLE%NUMBER_OF_DOFS
                            column_number=SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                              & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%LAGRANGE_VARIABLE_TO_SOLVER_COL_MAP% &
                              & COLUMN_NUMBERS(variable_dof_idx)
                            IF(column_number/=0) THEN
                              coupling_coefficient=SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                                & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%LAGRANGE_VARIABLE_TO_SOLVER_COL_MAP% &
                                & COUPLING_COEFFICIENTS(variable_dof_idx)
                              additive_constant=SOLVER_MAPPING%INTERFACE_CONDITION_TO_SOLVER_MAP(interface_condition_idx)% &
                                & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%LAGRANGE_VARIABLE_TO_SOLVER_COL_MAP% &
                                & ADDITIVE_CONSTANTS(variable_dof_idx)
                              VALUE=VARIABLE_DATA(variable_dof_idx)*coupling_coefficient+additive_constant
                              local_number=DOMAIN_MAPPING%GLOBAL_TO_LOCAL_MAP(column_number)%LOCAL_NUMBER(1)
                              CALL DistributedVector_ValuesSet(SOLVER_VECTOR,local_number,VALUE,err,error,*999)
                            ENDIF
                          ENDDO !variable_dof_idx
                          CALL Field_ParameterSetDataRestore(DEPENDENT_FIELD,variable_type,FIELD_VALUES_SET_TYPE, &
                            & VARIABLE_DATA,err,error,*999)
                        ELSE
                          CALL FlagError("Variable is not associated.",err,error,*999)
                        ENDIF
                      ENDDO !equations_set_idx
                    ELSE
                      CALL FlagError("Domain mapping is not associated.",err,error,*999)
                    ENDIF
                    CALL DistributedVector_UpdateStart(SOLVER_VECTOR,err,error,*999)
                    CALL DistributedVector_UpdateFinish(SOLVER_VECTOR,err,error,*999)
                  ELSE
                    CALL FlagError("Solver vector is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Solver matrix is not associated.",err,error,*999)
                ENDIF
              ENDDO !solver_matrix_idx
            ELSE
              CALL FlagError("Solver matrices solution mapping is not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver equations solver matrices are not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Solver solver equations is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVER_SOLUTION_UPDATE")
    RETURN
999 ERRORSEXITS("SOLVER_SOLUTION_UPDATE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_SOLUTION_UPDATE
  
  !
  !================================================================================================================================
  !

  !>Solve the problem. 
  RECURSIVE SUBROUTINE Solver_Solve(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to solve
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    REAL(SP) :: systemElapsed,SYSTEM_TIME1(1),SYSTEM_TIME2(1),userElapsed,USER_TIME1(1),USER_TIME2(1)
    TYPE(VARYING_STRING) :: localError

    ENTERS("Solver_Solve",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        IF(SOLVER%outputType>=SOLVER_TIMING_OUTPUT) THEN
          CALL CPUTimer(USER_CPU,USER_TIME1,err,error,*999)
          CALL CPUTimer(SYSTEM_CPU,SYSTEM_TIME1,err,error,*999)          
        ENDIF
        !Solve the system depending on the solver type
        SELECT CASE(SOLVER%SOLVE_TYPE)
        CASE(SOLVER_LINEAR_TYPE)
          !Solve linear equations
          CALL SOLVER_LINEAR_SOLVE(SOLVER%LINEAR_SOLVER,err,error,*999)
        CASE(SOLVER_NONLINEAR_TYPE)
          !Solve nonlinear equations
          CALL SOLVER_NONLINEAR_SOLVE(SOLVER%NONLINEAR_SOLVER,err,error,*999)
        CASE(SOLVER_DYNAMIC_TYPE)
          !Solve dynamic equations
          CALL Solver_DynamicSolve(SOLVER%DYNAMIC_SOLVER,err,error,*999)
        CASE(SOLVER_DAE_TYPE)
          !Solve differential-algebraic equations
          CALL SOLVER_DAE_SOLVE(SOLVER%DAE_SOLVER,err,error,*999)
        CASE(SOLVER_EIGENPROBLEM_TYPE)
          !Solve eigenproblem
          CALL SOLVER_EIGENPROBLEM_SOLVE(SOLVER%EIGENPROBLEM_SOLVER,err,error,*999)
        CASE(SOLVER_OPTIMISER_TYPE)
          !Solve an optimisation problem
          CALL Solver_OptimiserSolve(solver%optimiserSolver,err,error,*999)
        CASE(SOLVER_CELLML_EVALUATOR_TYPE)
          !Solve a CellML evaluator
          CALL SOLVER_CELLML_EVALUATOR_SOLVE(SOLVER%CELLML_EVALUATOR_SOLVER,err,error,*999)
        CASE DEFAULT
          localError="The solver type of "//TRIM(NumberToVString(SOLVER%SOLVE_TYPE,"*",err,error))//" is invalid."
          CALL FlagError(localError,err,error,*999)
        END SELECT
        !If necessary output the timing information
        IF(SOLVER%outputType>=SOLVER_TIMING_OUTPUT) THEN
          CALL CPUTimer(USER_CPU,USER_TIME2,err,error,*999)
          CALL CPUTimer(SYSTEM_CPU,SYSTEM_TIME2,err,error,*999)
          userElapsed=USER_TIME2(1)-USER_TIME1(1)
          systemElapsed=SYSTEM_TIME2(1)-SYSTEM_TIME1(1)
          IF(solver%outputType>=SOLVER_MATRIX_OUTPUT) &
            & CALL Profiling_TimingsOutput(0,"",userElapsed,systemElapsed,err,error,*999)
          CALL Profiling_TimingsOutput(1,"Total time for solve",userElapsed,systemElapsed,err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF
        
    EXITS("Solver_Solve")
    RETURN
999 ERRORSEXITS("Solver_Solve",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_Solve

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a solver.
  SUBROUTINE SOLVER_TYPE_SET(SOLVER,SOLVE_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to set the solver type for.
    INTEGER(INTG), INTENT(IN) :: SOLVE_TYPE !<The type of solver to be set \see SOLVER_ROUTINES_SolverTypes,SOLVER_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr
    TYPE(VARYING_STRING) :: dummyError,localError
    
    ENTERS("SOLVER_TYPE_SET",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        CALL FlagError("Solver has already been finished.",err,error,*998)
      ELSE
        IF(ASSOCIATED(SOLVER%LINKING_SOLVER)) THEN
          CALL FlagError("Can not changed the solver type for a solve that has been linked.",err,error,*998)
        ELSE
          IF(SOLVE_TYPE/=SOLVER%SOLVE_TYPE) THEN
            !Initialise the new solver type 
            SELECT CASE(SOLVE_TYPE)
            CASE(SOLVER_LINEAR_TYPE)
              CALL SOLVER_LINEAR_INITIALISE(SOLVER,err,error,*999)
            CASE(SOLVER_NONLINEAR_TYPE)
              CALL SOLVER_NONLINEAR_INITIALISE(SOLVER,err,error,*999)
            CASE(SOLVER_DYNAMIC_TYPE)
              CALL SOLVER_DYNAMIC_INITIALISE(SOLVER,err,error,*999)
            CASE(SOLVER_DAE_TYPE)
              CALL SOLVER_DAE_INITIALISE(SOLVER,err,error,*999)
            CASE(SOLVER_EIGENPROBLEM_TYPE)
              CALL SOLVER_EIGENPROBLEM_INITIALISE(SOLVER,err,error,*999)
            CASE(SOLVER_OPTIMISER_TYPE)
              CALL Solver_OptimiserInitialise(solver,err,error,*999)
            CASE(SOLVER_CELLML_EVALUATOR_TYPE)
              CALL SOLVER_CELLML_EVALUATOR_INITIALISE(SOLVER,err,error,*999)
            CASE(SOLVER_GEOMETRIC_TRANSFORMATION_TYPE)
              CALL Solver_GeometricTransformationInitialise(SOLVER,err,error,*999)
            CASE DEFAULT
              localError="The specified solve type of "//TRIM(NumberToVString(SOLVE_TYPE,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            !Finalise the old solve type
            SELECT CASE(SOLVER%SOLVE_TYPE)
            CASE(SOLVER_LINEAR_TYPE)
              CALL SOLVER_LINEAR_FINALISE(SOLVER%LINEAR_SOLVER,err,error,*999)
            CASE(SOLVER_NONLINEAR_TYPE)
              CALL SOLVER_NONLINEAR_FINALISE(SOLVER%NONLINEAR_SOLVER,err,error,*999)
            CASE(SOLVER_DYNAMIC_TYPE)
              CALL SOLVER_DYNAMIC_FINALISE(SOLVER%DYNAMIC_SOLVER,err,error,*999)
            CASE(SOLVER_DAE_TYPE)
              CALL SOLVER_DAE_FINALISE(SOLVER%DAE_SOLVER,err,error,*999)
            CASE(SOLVER_EIGENPROBLEM_TYPE)
              CALL SOLVER_EIGENPROBLEM_FINALISE(SOLVER%EIGENPROBLEM_SOLVER,err,error,*999)
            CASE(SOLVER_OPTIMISER_TYPE)
              CALL Solver_OptimiserFinalise(solver%optimiserSolver,err,error,*999)
            CASE(SOLVER_CELLML_EVALUATOR_TYPE)
              CALL SOLVER_CELLML_EVALUATOR_FINALISE(SOLVER%CELLML_EVALUATOR_SOLVER,err,error,*999)
            CASE(SOLVER_GEOMETRIC_TRANSFORMATION_TYPE)
              CALL Solver_GeometricTransformationFinalise(SOLVER%geometricTransformationSolver,err,error,*999)
            CASE DEFAULT
              localError="The solver solve type of "//TRIM(NumberToVString(SOLVER%SOLVE_TYPE,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
            !Set the solve type
            SOLVER%SOLVE_TYPE=SOLVE_TYPE
          ENDIF
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
    
    EXITS("SOLVER_TYPE_SET")
    RETURN
999 SELECT CASE(SOLVE_TYPE)
    CASE(SOLVER_LINEAR_TYPE)
      CALL SOLVER_LINEAR_FINALISE(SOLVER%LINEAR_SOLVER,dummyErr,dummyError,*998)
    CASE(SOLVER_NONLINEAR_TYPE)
      CALL SOLVER_NONLINEAR_FINALISE(SOLVER%NONLINEAR_SOLVER,dummyErr,dummyError,*998)
    CASE(SOLVER_DYNAMIC_TYPE)
      CALL SOLVER_DYNAMIC_FINALISE(SOLVER%DYNAMIC_SOLVER,dummyErr,dummyError,*998)
    CASE(SOLVER_DAE_TYPE)
      CALL SOLVER_DAE_FINALISE(SOLVER%DAE_SOLVER,dummyErr,dummyError,*998)
    CASE(SOLVER_EIGENPROBLEM_TYPE)
      CALL SOLVER_EIGENPROBLEM_FINALISE(SOLVER%EIGENPROBLEM_SOLVER,dummyErr,dummyError,*998)
    CASE(SOLVER_OPTIMISER_TYPE)
      CALL Solver_OptimiserFinalise(solver%optimiserSolver,dummyErr,dummyError,*998)
    CASE(SOLVER_GEOMETRIC_TRANSFORMATION_TYPE)
      CALL Solver_GeometricTransformationFinalise(SOLVER%geometricTransformationSolver,err,error,*999)
    END SELECT
998 ERRORSEXITS("SOLVER_TYPE_SET",err,error)
    RETURN 1
   
  END SUBROUTINE SOLVER_TYPE_SET
        
  !
  !================================================================================================================================
  !

  !>Updates the dependent variables from the solver solution for dynamic solvers
  SUBROUTINE Solver_VariablesDynamicFieldUpdate(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to update the variables from
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,dynamicVariableType,equationsDOFIdx,equationsSetIdx,solverDOFIdx,solverMatrixIdx,variableDOF
    REAL(DP) :: currentAcceleration,additiveConstant,deltaT,currentDisplacement,previousAcceleration, &
      & previousDisplacement,previousVelocity,alphaValue,variableCoefficient,currentVelocity
    REAL(DP), POINTER :: solverData(:)
    TYPE(DistributedVectorType), POINTER :: solverVector
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: dynamicSolver
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
    TYPE(FIELD_TYPE), POINTER :: dependentField
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: dependentVariable
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: solverMapping
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: solverMatrix
    TYPE(VARYING_STRING) :: dummyError,localError

    NULLIFY(solverData)
    
    ENTERS("Solver_VariablesDynamicFieldUpdate",err,error,*998)

    IF(.NOT.ASSOCIATED(solver)) CALL FlagError("Solver is not associated.",err,error,*999)
    IF(.NOT.solver%SOLVER_FINISHED) CALL FlagError("Solver has not been finished.",err,error,*999)
    
    NULLIFY(dynamicSolver)
    CALL Solver_DynamicSolverGet(solver,dynamicSolver,err,error,*999)
    deltaT=dynamicSolver%TIME_INCREMENT
    NULLIFY(solverEquations)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    NULLIFY(solverMatrices)
    CALL SolverEquations_SolverMatricesGet(solverEquations,solverMatrices,err,error,*999)
    NULLIFY(solverMapping)
    CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
    DO solverMatrixIdx=1,solverMatrices%NUMBER_OF_MATRICES
      NULLIFY(solverMatrix)
      CALL SolverMatrices_SolverMatrixGet(solverMatrices,solverMatrixIdx,solverMatrix,err,error,*999)
      NULLIFY(solverVector)
      CALL SolverMatrix_SolverVectorGet(solverMatrix,solverVector,err,error,*999)
      !Get the solver variables data
      CALL DistributedVector_DataGet(solverVector,solverData,err,error,*999)
      !Loop over the solver variable dofs
      DO solverDOFIdx=1,solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)%NUMBER_OF_DOFS
        !Loop over the equations sets associated with this dof
        DO equationsDOFIdx=1,solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
          & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%NUMBER_OF_EQUATION_DOFS
          SELECT CASE(solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
            & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%EQUATIONS_TYPES(equationsDOFIdx))
          CASE(SOLVER_MAPPING_EQUATIONS_EQUATIONS_SET)
            dependentVariable=>solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
              & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%VARIABLE(equationsDOFIdx)%ptr
            IF(.NOT.ASSOCIATED(dependentVariable)) CALL FlagError("Dependent variable is not associated.",err,error,*999)
            dynamicVariableType=dependentVariable%VARIABLE_TYPE
            NULLIFY(dependentField)
            CALL FieldVariable_FieldGet(dependentVariable,dependentField,err,error,*999)
            !Get the dependent field dof the solver dof is mapped to
            variableDOF=solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
              & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%VARIABLE_DOF(equationsDOFIdx)
            variableCoefficient=solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
              & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%VARIABLE_COEFFICIENT(equationsDOFIdx)
            additiveConstant=solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
              & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%ADDITIVE_CONSTANT(equationsDOFIdx)
            alphaValue=solverData(solverDOFIdx)*variableCoefficient+additiveConstant
            !Set the dependent field dof
            IF(dynamicSolver%SOLVER_INITIALISED) THEN
              SELECT CASE(dynamicSolver%degree)
              CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
                CALL Field_ParameterSetGetLocalDOF(dependentField,dynamicVariableType, & 
                  & FIELD_PREVIOUS_VALUES_SET_TYPE,variableDOF,previousDisplacement, &
                  & err,error,*999)
                currentDisplacement=previousDisplacement+deltaT*alphaValue
                CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                  & FIELD_VALUES_SET_TYPE,variableDOF,currentDisplacement,err,error,*999)
              CASE(SOLVER_DYNAMIC_SECOND_DEGREE)
                CALL Field_ParameterSetGetLocalDOF(dependentField,dynamicVariableType, & 
                  & FIELD_PREVIOUS_VALUES_SET_TYPE,variableDOF,previousDisplacement, &
                  & err,error,*999)
                CALL Field_ParameterSetGetLocalDOF(dependentField,dynamicVariableType, & 
                  & FIELD_PREVIOUS_VELOCITY_SET_TYPE,variableDOF,previousVelocity, &
                  & err,error,*999)
                currentDisplacement=previousDisplacement+deltaT*previousVelocity+(deltaT*deltaT/2.0_DP)*alphaValue
                currentVelocity=previousVelocity+deltaT*alphaValue
                CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                  & FIELD_VALUES_SET_TYPE,variableDOF,currentDisplacement,err,error,*999)
                CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                  & FIELD_VELOCITY_VALUES_SET_TYPE,variableDOF,currentVelocity,err,error,*999)
              CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
                CALL Field_ParameterSetGetLocalDOF(dependentField,dynamicVariableType, & 
                  & FIELD_PREVIOUS_VALUES_SET_TYPE,variableDOF,previousDisplacement, &
                  & err,error,*999)
                CALL Field_ParameterSetGetLocalDOF(dependentField,dynamicVariableType, & 
                  & FIELD_PREVIOUS_VELOCITY_SET_TYPE,variableDOF,previousVelocity, &
                  & err,error,*999)
                CALL Field_ParameterSetGetLocalDOF(dependentField,dynamicVariableType, & 
                  & FIELD_PREVIOUS_ACCELERATION_SET_TYPE,variableDOF,previousAcceleration, &
                  & err,error,*999)
                currentDisplacement=previousDisplacement+deltaT*previousVelocity+ &
                  & (deltaT*deltaT/2.0_DP)*previousAcceleration+ &
                  & (deltaT*deltaT*deltaT/6.0_DP)*alphaValue
                currentVelocity=previousVelocity+deltaT*previousAcceleration+(deltaT*deltaT/2.0_DP)*alphaValue
                currentAcceleration=previousAcceleration+deltaT*alphaValue
                CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                  & FIELD_VALUES_SET_TYPE,variableDOF,currentDisplacement,err,error,*999)
                CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                  & FIELD_VELOCITY_VALUES_SET_TYPE,variableDOF,currentVelocity,err,error,*999)
                CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                  & FIELD_ACCELERATION_VALUES_SET_TYPE,variableDOF,currentAcceleration,err,error,*999)
              CASE DEFAULT
                localError="The dynamic solver degree of "//TRIM(NumberToVString(dynamicSolver%degree,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              SELECT CASE(dynamicSolver%order)
              CASE(SOLVER_DYNAMIC_FIRST_ORDER)
                SELECT CASE(dynamicSolver%degree)
                CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
                  !Do nothing
                CASE(SOLVER_DYNAMIC_SECOND_DEGREE)
                  CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                    & FIELD_INITIAL_VELOCITY_SET_TYPE,variableDOF,alphaValue,err,error,*999)
                CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
                  CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                    & FIELD_INITIAL_VELOCITY_SET_TYPE,variableDOF,alphaValue,err,error,*999)
                  CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                    & FIELD_INITIAL_ACCELERATION_SET_TYPE,variableDOF,0.0_DP,err,error,*999)
                CASE DEFAULT
                  localError="The dynamic solver degree of "//TRIM(NumberToVString(dynamicSolver%degree,"*",err,error))// &
                    & " is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              CASE(SOLVER_DYNAMIC_SECOND_ORDER)
                IF(dynamicSolver%degree==SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                  CALL Field_ParameterSetUpdateLocalDOF(dependentField,dynamicVariableType, &
                    & FIELD_INITIAL_ACCELERATION_SET_TYPE,variableDOF,alphaValue,err,error,*999)
                ENDIF
              CASE DEFAULT
                localError="The dynamic solver order of "//TRIM(NumberToVString(dynamicSolver%order,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          CASE(SOLVER_MAPPING_EQUATIONS_INTERFACE_CONDITION)
            !
          CASE DEFAULT
            localError="The equations type of "//TRIM(NumberToVString(solverMapping% &
              & SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)%SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)% &
              & EQUATIONS_TYPES(equationsDOFIdx),"*",err,error))//" of equations index "// &
              & TRIM(NumberToVString(equationsDOFIdx,"*",err,error))//" for solver degree-of-freedom "// &
              & TRIM(NumberToVString(solverDOFIdx,"*",err,error))//" is invalid."
            CALL FlagError(localError,err,error,*999)
          END SELECT
        ENDDO !equationsDOFIdx
      ENDDO !solverDOFIdx
      !Restore the solver dof data
      CALL DistributedVector_DataRestore(solverVector,solverData,err,error,*999)
      !Start the transfer of the field dofs
      DO equationsSetIdx=1,solverMapping%NUMBER_OF_EQUATIONS_SETS
        NULLIFY(equationsSet)
        CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
        NULLIFY(dependentField)
        CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
        NULLIFY(equations)
        CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
        NULLIFY(vectorEquations)
        CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
        NULLIFY(vectorMapping)
        CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
        dynamicMapping=>vectorMapping%dynamicMapping
        IF(ASSOCIATED(dynamicMapping)) THEN
          dynamicVariableType=dynamicMapping%dynamicVariableType
          IF(dynamicSolver%SOLVER_INITIALISED) THEN
            CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_VALUES_SET_TYPE,err,error,*999)
            IF(dynamicSolver%DEGREE>SOLVER_DYNAMIC_FIRST_DEGREE) THEN
              CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_VELOCITY_VALUES_SET_TYPE, &
                & err,error,*999)
              IF(dynamicSolver%DEGREE>SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_ACCELERATION_VALUES_SET_TYPE, &
                  & err,error,*999)
              ENDIF
            ENDIF
          ELSE
            SELECT CASE(dynamicSolver%order)
            CASE(SOLVER_DYNAMIC_FIRST_ORDER)
              SELECT CASE(dynamicSolver%degree)
              CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
                !Do nothing
              CASE(SOLVER_DYNAMIC_SECOND_DEGREE)                                  
                CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_INITIAL_VELOCITY_SET_TYPE, &
                  & err,error,*999)
              CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
                CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_INITIAL_VELOCITY_SET_TYPE, &
                  & err,error,*999)
                CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_INITIAL_ACCELERATION_SET_TYPE, &
                  & err,error,*999)
              CASE DEFAULT
                localError="The dynamic solver degree of "//TRIM(NumberToVString(dynamicSolver%degree,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            CASE(SOLVER_DYNAMIC_SECOND_ORDER)
              IF(dynamicSolver%DEGREE==SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_INITIAL_ACCELERATION_SET_TYPE, &
                  & err,error,*999)
              ENDIF
            CASE DEFAULT
              localError="The dynamic solver order of "//TRIM(NumberToVString(dynamicSolver%order,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ELSE
          nonlinearMapping=>vectorMapping%nonlinearMapping
          IF(ASSOCIATED(nonlinearMapping)) THEN
            dynamicVariableType=FIELD_U_VARIABLE_TYPE
            IF(dynamicSolver%SOLVER_INITIALISED) THEN
              CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_VALUES_SET_TYPE,err,error,*999)
              IF(dynamicSolver%DEGREE>SOLVER_DYNAMIC_FIRST_DEGREE) THEN
                CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_VELOCITY_VALUES_SET_TYPE, &
                  & err,error,*999)
                IF(dynamicSolver%DEGREE>SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                  CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_ACCELERATION_VALUES_SET_TYPE, &
                    & err,error,*999)
                ENDIF
              ENDIF
            ELSE
              SELECT CASE(dynamicSolver%order)
              CASE(SOLVER_DYNAMIC_FIRST_ORDER)
                SELECT CASE(dynamicSolver%DEGREE)
                CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
                  !Do nothing
                CASE(SOLVER_DYNAMIC_SECOND_DEGREE)                                  
                  CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_INITIAL_VELOCITY_SET_TYPE, &
                    & err,error,*999)
                CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
                  CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_INITIAL_VELOCITY_SET_TYPE, &
                    & err,error,*999)
                  CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_INITIAL_ACCELERATION_SET_TYPE, &
                    & err,error,*999)
                CASE DEFAULT
                  localError="The dynamic solver degree of "//TRIM(NumberToVString(dynamicSolver%degree,"*",err,error))// &
                    & " is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              CASE(SOLVER_DYNAMIC_SECOND_ORDER)
                IF(dynamicSolver%DEGREE==SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                  CALL Field_ParameterSetUpdateStart(dependentField,dynamicVariableType,FIELD_INITIAL_ACCELERATION_SET_TYPE, &
                    & err,error,*999)
                ENDIF
              CASE DEFAULT
                localError="The dynamic solver order of "//TRIM(NumberToVString(dynamicSolver%order,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          ELSE
            localError="Neither equations mapping dynamic mapping nor equations mapping nonlinear "// &
              & "mapping is associated for equations set index number "// &
              & TRIM(NumberToVString(equationsSetIdx,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ENDIF
      ENDDO !equationsSetIdx
      !Finish the transfer of the field dofs
      DO equationsSetIdx=1,solverMapping%NUMBER_OF_EQUATIONS_SETS
        NULLIFY(equationsSet)
        CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
        NULLIFY(dependentField)
        CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
        NULLIFY(equations)
        CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
        NULLIFY(vectorEquations)
        CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
        NULLIFY(vectorMapping)
        CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
        dynamicMapping=>vectorMapping%dynamicMapping
        IF(ASSOCIATED(dynamicMapping))THEN
          dynamicVariableType=dynamicMapping%dynamicVariableType
          IF(dynamicSolver%SOLVER_INITIALISED) THEN
            CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_VALUES_SET_TYPE,err,error,*999)
            IF(dynamicSolver%DEGREE>SOLVER_DYNAMIC_FIRST_DEGREE) THEN
              CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_VELOCITY_VALUES_SET_TYPE, &
                & err,error,*999)
              IF(dynamicSolver%DEGREE>SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_ACCELERATION_VALUES_SET_TYPE, &
                  & err,error,*999)
              ENDIF
            ENDIF
          ELSE
            SELECT CASE(dynamicSolver%order)
            CASE(SOLVER_DYNAMIC_FIRST_ORDER)
              SELECT CASE(dynamicSolver%DEGREE)
              CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
                !Do nothing
              CASE(SOLVER_DYNAMIC_SECOND_DEGREE)                                  
                CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_INITIAL_VELOCITY_SET_TYPE, &
                  & err,error,*999)
              CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
                CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_INITIAL_VELOCITY_SET_TYPE, &
                  & err,error,*999)
                CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_INITIAL_ACCELERATION_SET_TYPE, &
                  & err,error,*999)
              CASE DEFAULT
                localError="The dynamic solver degree of "//TRIM(NumberToVString(dynamicSolver%degree,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            CASE(SOLVER_DYNAMIC_SECOND_ORDER)
              IF(dynamicSolver%DEGREE==SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_INITIAL_ACCELERATION_SET_TYPE, &
                  & err,error,*999)
              ENDIF
            CASE DEFAULT
              localError="The dynamic solver order of "//TRIM(NumberToVString(dynamicSolver%order,"*",err,error))// &
                & " is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDIF
        ELSE
          nonlinearMapping=>vectorMapping%nonlinearMapping
          IF(ASSOCIATED(nonlinearMapping)) THEN
            dynamicVariableType=FIELD_U_VARIABLE_TYPE
            IF(dynamicSolver%SOLVER_INITIALISED) THEN
              CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_VALUES_SET_TYPE, &
                & err,error,*999)
              IF(dynamicSolver%DEGREE>SOLVER_DYNAMIC_FIRST_DEGREE) THEN
                CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_VELOCITY_VALUES_SET_TYPE, &
                  & err,error,*999)
                IF(dynamicSolver%DEGREE>SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                  CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_ACCELERATION_VALUES_SET_TYPE, &
                    & err,error,*999)
                ENDIF
              ENDIF
            ELSE
              SELECT CASE(dynamicSolver%order)
              CASE(SOLVER_DYNAMIC_FIRST_ORDER)
                SELECT CASE(dynamicSolver%DEGREE)
                CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
                  !Do nothing
                CASE(SOLVER_DYNAMIC_SECOND_DEGREE)                                  
                  CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_INITIAL_VELOCITY_SET_TYPE, &
                    & err,error,*999)
                CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
                  CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_INITIAL_VELOCITY_SET_TYPE, &
                    & err,error,*999)
                  CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_INITIAL_ACCELERATION_SET_TYPE, &
                    & err,error,*999)
                CASE DEFAULT
                  localError="The dynamic solver degree of "//TRIM(NumberToVString(dynamicSolver%DEGREE,"*",err,error))// &
                    & " is invalid."
                  CALL FlagError(localError,err,error,*999)
                END SELECT
              CASE(SOLVER_DYNAMIC_SECOND_ORDER)
                IF(dynamicSolver%DEGREE==SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                  CALL Field_ParameterSetUpdateFinish(dependentField,dynamicVariableType,FIELD_INITIAL_ACCELERATION_SET_TYPE, &
                    & err,error,*999)
                ENDIF
              CASE DEFAULT
                localError="The dynamic solver order of "//TRIM(NumberToVString(dynamicSolver%order,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ENDIF
          ELSE
            CALL FlagError("Neither dynamic nor nonlinear mapping is associated.",err,error,*999)
          ENDIF
        ENDIF
      ENDDO !equationsSetIdx
    ENDDO !solverMatrixIdx
    
    EXITS("Solver_VariablesDynamicFieldUpdate")
    RETURN
999 IF(ASSOCIATED(solverData)) CALL DistributedVector_DataRestore(solverVector,solverData,dummyErr,dummyError,*998)
998 ERRORSEXITS("Solver_VariablesDynamicFieldUpdate",err,error)
    RETURN 1
   
  END SUBROUTINE Solver_VariablesDynamicFieldUpdate

  !
  !================================================================================================================================
  !

  !>Updates the previous values from the solver solution for dynamic solvers
  SUBROUTINE Solver_VariablesDynamicFieldPreviousValuesUpdate(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to update the variables from
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: VARIABLE_TYPE,equations_set_idx,solver_matrix_idx, &
      & residual_variable_idx,variable_idx
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DYNAMIC_SOLVER
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE,RESIDUAL_VARIABLE
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(VARYING_STRING) :: localError

    ENTERS("Solver_VariablesDynamicFieldPreviousValuesUpdate",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        DYNAMIC_SOLVER=>SOLVER%DYNAMIC_SOLVER
        IF(ASSOCIATED(DYNAMIC_SOLVER)) THEN
          SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
          IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
            SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
            IF(ASSOCIATED(SOLVER_MATRICES)) THEN
              SOLVER_MAPPING=>SOLVER_MATRICES%SOLVER_MAPPING
              IF(ASSOCIATED(SOLVER_MAPPING)) THEN
                DO solver_matrix_idx=1,SOLVER_MATRICES%NUMBER_OF_MATRICES
                  !Loop over the variables involved in the solver matrix.
                  DO variable_idx=1,SOLVER_MAPPING%VARIABLES_LIST(solver_matrix_idx)%NUMBER_OF_VARIABLES
                    FIELD_VARIABLE=>SOLVER_MAPPING%VARIABLES_LIST(solver_matrix_idx)%VARIABLES(variable_idx)%VARIABLE
                    IF(ASSOCIATED(FIELD_VARIABLE)) THEN
                      VARIABLE_TYPE=FIELD_VARIABLE%VARIABLE_TYPE
                      FIELD=>FIELD_VARIABLE%FIELD
                      !Copy the displacements
                      CALL FIELD_PARAMETER_SETS_COPY(FIELD,VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                        & FIELD_PREVIOUS_VALUES_SET_TYPE,1.0_DP,err,error,*999)
                      IF(DYNAMIC_SOLVER%DEGREE>=SOLVER_DYNAMIC_SECOND_DEGREE) THEN
                        !Copy velocity
                        CALL FIELD_PARAMETER_SETS_COPY(FIELD,VARIABLE_TYPE,FIELD_VELOCITY_VALUES_SET_TYPE, &
                          & FIELD_PREVIOUS_VELOCITY_SET_TYPE,1.0_DP,err,error,*999)
                        IF(DYNAMIC_SOLVER%DEGREE>=SOLVER_DYNAMIC_THIRD_DEGREE) THEN
                          !Copy acceleration
                          CALL FIELD_PARAMETER_SETS_COPY(FIELD,VARIABLE_TYPE,FIELD_ACCELERATION_VALUES_SET_TYPE, &
                            & FIELD_PREVIOUS_ACCELERATION_SET_TYPE,1.0_DP,err,error,*999)
                        ENDIF
                      ENDIF
                    ELSE
                      localError="The solver mapping variables list variable is not associated for variable index "// &
                        & TRIM(NumberToVString(variable_idx,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ENDDO !variable_idx
                  IF(DYNAMIC_SOLVER%LINEARITY==SOLVER_DYNAMIC_NONLINEAR) THEN
                    !Loop over the equations sets and copy any residuals
                    DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                      EQUATIONS_SET=>SOLVER_MAPPING%EQUATIONS_SETS(equations_set_idx)%ptr
                      IF(ASSOCIATED(EQUATIONS_SET)) THEN
                        EQUATIONS=>EQUATIONS_SET%EQUATIONS
                        IF(ASSOCIATED(EQUATIONS)) THEN
                          IF(EQUATIONS%LINEARITY==EQUATIONS_NONLINEAR) THEN
                            NULLIFY(vectorEquations)
                            CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
                            vectorMapping=>vectorEquations%vectorMapping
                            IF(ASSOCIATED(vectorMapping)) THEN
                              nonlinearMapping=>vectorMapping%nonlinearMapping
                              IF(ASSOCIATED(nonlinearMapping)) THEN
                                DO residual_variable_idx=1,nonlinearMapping%numberOfResidualVariables
                                  RESIDUAL_VARIABLE=>nonlinearMapping%residualVariables(residual_variable_idx)%ptr
                                  IF(ASSOCIATED(RESIDUAL_VARIABLE)) THEN
                                    CALL FIELD_PARAMETER_SETS_COPY(RESIDUAL_VARIABLE%FIELD,RESIDUAL_VARIABLE%VARIABLE_TYPE, &
                                      & FIELD_RESIDUAL_SET_TYPE,FIELD_PREVIOUS_RESIDUAL_SET_TYPE,1.0_DP,err,error,*999)
                                  ELSE
                                    localError="Nonlinear mapping residual variable is not associated for "// &
                                      "residual variable index "//TRIM(NumberToVString(residual_variable_idx,"*",err,error))// &
                                      & "."
                                    CALL FlagError(localError,err,error,*999)
                                  ENDIF
                                ENDDO !residual_variable_idx
                              ELSE
                                CALL FlagError("Equations mapping nonlinear mapping is not associated.",err,error,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("Equations equations mapping is not associated.",err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          CALL FlagError("Equations set equations is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        localError="The solver mapping equations set is not associated for equations set index "// &
                          & TRIM(NumberToVString(equations_set_idx,"*",err,error))//"."
                        CALL FlagError(localError,err,error,*999)
                      ENDIF
                    ENDDO !equations_set_idx
                  ENDIF
                ENDDO !solver_matrix_idx
              ELSE
                CALL FlagError("Solver matrices solution mapping is not associated.",err,error,*999)
              ENDIF
            ELSE
              CALL FlagError("Solver equations solver matrices are not associated.",err,error,*999)
            ENDIF
          ELSE
            CALL FlagError("Solver solver equations is not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Solver dynamic solver is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF

    EXITS("Solver_VariablesDynamicFieldPreviousValuesUpdate")
    RETURN
999 ERRORS("Solver_VariablesDynamicFieldPreviousValuesUpdate",err,error)
    EXITS("Solver_VariablesDynamicFieldPreviousValuesUpdate")
    RETURN 1

  END SUBROUTINE Solver_VariablesDynamicFieldPreviousValuesUpdate

  !
  !================================================================================================================================
  !

  !>Update the field values form the dynamic factor * current solver values AND add in previous values
  SUBROUTINE Solver_VariablesDynamicNonlinearUpdate(solver,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: solver !<A pointer the solver to update the variables from
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string

    !Local Variables
    INTEGER(INTG) :: dummyErr,dynamicVariableType,equationsDOFIdx,equationsSetIdx,solverDOFIdx,solverMatrixIdx,variableDOF
    REAL(DP) :: additiveConstant,deltaT,value,variableCoefficient
    REAL(DP) :: alphaValue,alphaDOFValue,currentDisplacement,dynamicAlphaFactor,dynamicDisplacementFactor, &
      & dynamicVelocityFactor,dynamicAccelerationFactor,predictedDisplacement,previousDisplacement, &
      & previousVelocity,previousAcceleration
    INTEGER(INTG) :: variableIdx,variableType,interfaceConditionIdx
    REAL(DP), POINTER :: solverData(:)
    TYPE(DistributedVectorType), POINTER :: solverVector
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: dynamicSolver
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: interfaceEquations
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition
    TYPE(FIELD_TYPE), POINTER :: dependentField
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: dependentVariable
    TYPE(SOLVER_TYPE), POINTER :: linkingSolver
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: solverMapping
    TYPE(INTERFACE_MAPPING_TYPE), POINTER :: interfaceMapping
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: solverMatrices
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: solverMatrix
    TYPE(VARYING_STRING) :: dummyError,localError

    NULLIFY(solverData)
    
    ENTERS("Solver_VariablesDynamicNonlinearUpdate",err,error,*998)
    
    IF(.NOT.ASSOCIATED(solver)) CALL FlagError("Solver is not associated.",err,error,*998)
    IF(.NOT.solver%SOLVER_FINISHED) CALL FlagError("Solver has not been finished.",err,error,*998)

    NULLIFY(linkingSolver)
    CALL Solver_LinkingSolverGet(solver,linkingSolver,err,error,*999)
    NULLIFY(dynamicSolver)
    CALL Solver_DynamicSolverGet(linkingSolver,dynamicSolver,err,error,*999)
    !Define the dynamic alpha factor
    IF(dynamicSolver%SOLVER_INITIALISED) THEN
      deltaT=dynamicSolver%TIME_INCREMENT
      !Set the dependent field for calculating the nonlinear residual and Jacobian values
      NULLIFY(solverEquations)
      CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
      NULLIFY(solverMatrices)
      CALL SolverEquations_SolverMatricesGet(solverEquations,solverMatrices,err,error,*999)
      NULLIFY(solverMapping)
      CALL SolverEquations_SolverMappingGet(solverEquations,solverMapping,err,error,*999)
      DO solverMatrixIdx=1,solverMatrices%NUMBER_OF_MATRICES
        NULLIFY(solverMatrix)
        CALL SolverMatrices_SolverMatrixGet(solverMatrices,solverMatrixIdx,solverMatrix,err,error,*999)
        NULLIFY(solverVector)
        CALL SolverMatrix_SolverVectorGet(solverMatrix,solverVector,err,error,*999)
        !Get the solver variables data                  
        CALL DistributedVector_DataGet(solverVector,solverData,err,error,*999)
        !Loop over the solver variable dofs
        DO solverDOFIdx=1,solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)%NUMBER_OF_DOFS
          !Loop over the equations associated with this dof
          DO equationsDOFIdx=1,solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
            & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%NUMBER_OF_EQUATION_DOFS
            SELECT CASE(solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
              & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%EQUATIONS_TYPES(equationsDOFIdx))
            CASE(SOLVER_MAPPING_EQUATIONS_EQUATIONS_SET)
              !Equations set dof.
              dependentVariable=>solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
                & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%VARIABLE(equationsDOFIdx)%ptr
              IF(.NOT.ASSOCIATED(dependentVariable)) CALL FlagError("Dependent variable is not associated.",err,error,*999)
              variableType=dependentVariable%VARIABLE_TYPE
              equationsSet=>solverMapping%EQUATIONS_SETS(solverMapping% &
                & SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
                & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%EQUATIONS_INDICES(equationsDOFIdx))%ptr 
              IF(.NOT.ASSOCIATED(equationsSet)) CALL FlagError("Equations set is not associated.",err,error,*999)
              NULLIFY(dependentField)
              CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
              NULLIFY(equations)
              CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
              NULLIFY(vectorEquations)
              CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
              NULLIFY(vectorMapping)
              CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
              !Get the dependent field variable dof the solver dof is mapped to
              variableDOF=solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
                & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%VARIABLE_DOF(equationsDOFIdx)
              variableCoefficient=solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
                & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%VARIABLE_COEFFICIENT(equationsDOFIdx)
              additiveConstant=solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
                & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%ADDITIVE_CONSTANT(equationsDOFIdx)
              !Store the alpha increment
              alphaValue=solverData(solverDOFIdx)
              CALL Field_ParameterSetUpdateLocalDOF(dependentField,variableType, &
                & FIELD_INCREMENTAL_VALUES_SET_TYPE,variableDOF,alphaValue,err,error,*999)
              !Calculate solver data only
              alphaDOFValue=alphaValue*variableCoefficient+additiveConstant
              dynamicMapping=>vectorMapping%dynamicMapping
              IF(ASSOCIATED(dynamicMapping)) THEN
                dynamicVariableType=dynamicMapping%dynamicVariableType
              ELSE
                nonlinearMapping=>vectorMapping%nonlinearMapping
                IF(ASSOCIATED(nonlinearMapping)) THEN
                  !Default to FIELD_U_VARIABLE_TYPE
                  dynamicVariableType=FIELD_U_VARIABLE_TYPE
                ELSE
                  CALL FlagError("Neither dynamic nor nonlinear mapping is associated",err,error,*999)
                ENDIF
              ENDIF
              !Get the predicted displacement data       
              CALL Field_ParameterSetGetLocalDOF(dependentField,dynamicVariableType, &
                & FIELD_PREVIOUS_VALUES_SET_TYPE,variableDOF,previousDisplacement, &
                & err,error,*999)
              SELECT CASE(dynamicSolver%degree)
              CASE(SOLVER_DYNAMIC_FIRST_DEGREE)
                currentDisplacement=previousDisplacement+deltaT*alphaDOFValue
              CASE(SOLVER_DYNAMIC_SECOND_DEGREE)
                CALL Field_ParameterSetGetLocalDOF(dependentField,dynamicVariableType, &
                  & FIELD_VELOCITY_VALUES_SET_TYPE,variableDOF,previousVelocity, &
                  & err,error,*999)
                currentDisplacement=previousDisplacement+deltaT*previousVelocity+deltaT*deltaT*alphaDOFValue/2.0_DP
              CASE(SOLVER_DYNAMIC_THIRD_DEGREE)
                CALL Field_ParameterSetGetLocalDOF(dependentField,dynamicVariableType, &
                  & FIELD_VELOCITY_VALUES_SET_TYPE,variableDOF,previousVelocity, &
                  & err,error,*999)
                CALL Field_ParameterSetGetLocalDOF(dependentField,dynamicVariableType, &
                  & FIELD_ACCELERATION_VALUES_SET_TYPE,variableDOF,previousAcceleration, &
                  & err,error,*999)
                currentDisplacement=previousDisplacement+deltaT*previousVelocity+ &
                  & deltaT*deltaT*previousAcceleration/2.0_DP+deltaT+deltaT*deltaT*alphaDOFValue/6.0_DP                  
              CASE DEFAULT
                localError="The dynamic solver degree of "//TRIM(NumberToVString(dynamicSolver%degree,"*",err,error))// &
                  & " is invalid."
                CALL FlagError(localError,err,error,*999)
              END SELECT
              CALL Field_ParameterSetUpdateLocalDOF(dependentField,variableType,FIELD_VALUES_SET_TYPE,variableDOF, &
                  & currentDisplacement,err,error,*999)
            CASE(SOLVER_MAPPING_EQUATIONS_INTERFACE_CONDITION)
              !Equations set dof.
              dependentVariable=>solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
                & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%VARIABLE(equationsDOFIdx)%ptr
              !equationsSet=>solverMapping%EQUATIONS_SETS(equationsDOFIdx)%ptr see above
              interfaceCondition=>solverMapping%INTERFACE_CONDITIONS(solverMapping% &
                & SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
                & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%EQUATIONS_INDICES(equationsDOFIdx))%ptr
              IF(.NOT.ASSOCIATED(interfaceCondition)) CALL FlagError("Interface condition is not associated.",err,error,*999)
              !TODO Generalize
              NULLIFY(interfaceEquations)
              CALL InterfaceCondition_EquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
              NULLIFY(interfaceMapping)
              CALL InterfaceEquations_InterfaceMappingGet(interfaceEquations,interfaceMapping,err,error,*999)
              NULLIFY(dependentField)
              CALL InterfaceCondition_LagrangeFieldGet(interfaceCondition,dependentField,err,error,*999)
              variableType=dependentVariable%VARIABLE_TYPE
              dynamicVariableType=interfaceMapping%LAGRANGE_VARIABLE_TYPE
              !Get the dependent field variable dof the solver dof is mapped to
              variableDOF=solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
                & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%VARIABLE_DOF(equationsDOFIdx)
              variableCoefficient=solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
                & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%VARIABLE_COEFFICIENT(equationsDOFIdx)
              additiveConstant=solverMapping%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)% &
                & SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)%ADDITIVE_CONSTANT(equationsDOFIdx)
              !Store the alpha increment
              alphaValue=solverData(solverDOFIdx)
              CALL Field_ParameterSetUpdateLocalDOF(dependentField,variableType, &
                & FIELD_INCREMENTAL_VALUES_SET_TYPE,variableDOF,alphaValue,err,error,*999)
              !Calculate solver data only
              alphaDOFValue=alphaValue*variableCoefficient+additiveConstant
              dynamicMapping=>vectorMapping%dynamicMapping
!!TODO: Why is predicted displacement zero here?????
              predictedDisplacement=0.0_DP
              !Calculate modified input values for residual and Jacobian calculation
              currentDisplacement=predictedDisplacement+currentDisplacement*dynamicAlphaFactor
              CALL Field_ParameterSetUpdateLocalDOF(dependentField,variableType, &
                & FIELD_VALUES_SET_TYPE,variableDOF,VALUE,err,error,*999)
            CASE DEFAULT
              localError="The equations type of "//TRIM(NumberToVString(solverMapping% &
                & SOLVER_COL_TO_EQUATIONS_COLS_MAP(solverMatrixIdx)%SOLVER_DOF_TO_VARIABLE_MAPS(solverDOFIdx)% &
                & EQUATIONS_TYPES(equationsDOFIdx),"*",err,error))//" of equations index "// &
                & TRIM(NumberToVString(equationsDOFIdx,"*",err,error))//" for solver degree-of-freedom "// &
                & TRIM(NumberToVString(solverDOFIdx,"*",err,error))//" is invalid."
              CALL FlagError(localError,err,error,*999)
            END SELECT
          ENDDO !equationsDOFIdx
        ENDDO !solverDOFIdx
        !Restore the solver dof data
        CALL DistributedVector_DataRestore(solverVector,solverData,err,error,*999)
        !Start the transfer of the field dofs
        DO equationsSetIdx=1,solverMapping%NUMBER_OF_EQUATIONS_SETS
          NULLIFY(equationsSet)
          CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
          NULLIFY(dependentField)
          CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
          DO variableIdx=1,solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
            & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solverMatrixIdx)%NUMBER_OF_VARIABLES
            variableType=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
              & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solverMatrixIdx)%VARIABLE_TYPES(variableIdx)
            CALL Field_ParameterSetUpdateStart(dependentField,variableType,FIELD_VALUES_SET_TYPE,err,error,*999)
            CALL Field_ParameterSetUpdateStart(dependentField,variableType,FIELD_INCREMENTAL_VALUES_SET_TYPE, &
              & err,error,*999)
          ENDDO !variableIdx
        ENDDO !equationsSetIdx
        !Finish the transfer of the field dofs
        DO equationsSetIdx=1,solverMapping%NUMBER_OF_EQUATIONS_SETS
          NULLIFY(equationsSet)
          CALL SolverMapping_EquationsSetGet(solverMapping,equationsSetIdx,equationsSet,err,error,*999)
          NULLIFY(dependentField)
          CALL EquationsSet_DependentFieldGet(equationsSet,dependentField,err,error,*999)
          DO variableIdx=1,solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
            & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solverMatrixIdx)%NUMBER_OF_VARIABLES
            variableType=solverMapping%EQUATIONS_SET_TO_SOLVER_MAP(equationsSetIdx)% &
              & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solverMatrixIdx)%VARIABLE_TYPES(variableIdx)
            CALL Field_ParameterSetUpdateFinish(dependentField,variableType,FIELD_VALUES_SET_TYPE,err,error,*999)
            CALL Field_ParameterSetUpdateFinish(dependentField,variableType,FIELD_INCREMENTAL_VALUES_SET_TYPE,err,error,*999)
          ENDDO !variableIdx
        ENDDO !equationsSetIdx
                
        !TODO Generalize
        DO interfaceConditionIdx=1,solverMapping%NUMBER_OF_INTERFACE_CONDITIONS
          NULLIFY(interfaceCondition)
          CALL SolverMapping_InterfaceConditionGet(solverMapping,interfaceConditionIdx,interfaceCondition,err,error,*999)
          NULLIFY(dependentField)
          CALL InterfaceCondition_LagrangeFieldGet(interfaceCondition,dependentField,err,error,*999)
          variableType=solverMapping%INTERFACE_CONDITION_TO_SOLVER_MAP(interfaceConditionIdx)% &
            & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(solverMatrixIdx)%LAGRANGE_VARIABLE_TYPE
          CALL Field_ParameterSetUpdateStart(dependentField,variableType,FIELD_VALUES_SET_TYPE,Err,Error,*999)
          CALL Field_ParameterSetUpdateFinish(dependentField,variableType,FIELD_VALUES_SET_TYPE,Err,Error,*999)
        ENDDO
      ENDDO !solverMatrixIdx
     
    ENDIF
    
    EXITS("Solver_VariablesDynamicNonlinearUpdate")
    RETURN
999 IF(ASSOCIATED(solverData)) CALL DistributedVector_DataRestore(solverVector,solverData,dummyErr,dummyError,*998)
998 ERRORSEXITS("Solver_VariablesDynamicNonlinearUpdate",err,error)
    RETURN 1
    
  END SUBROUTINE Solver_VariablesDynamicNonlinearUpdate


  !
  !================================================================================================================================
  !

  !>Updates the dependent variables from the solver solution for static solvers
  SUBROUTINE SOLVER_VARIABLES_FIELD_UPDATE(SOLVER,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer the solver to update the variables from
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,equations_idx,equations_set_idx,solver_dof_idx,solver_matrix_idx,variable_dof,variable_idx, &
      & VARIABLE_TYPE
    REAL(DP) :: additive_constant,VALUE,variable_coefficient
    REAL(DP), POINTER :: SOLVER_DATA(:)
    TYPE(DistributedVectorType), POINTER :: SOLVER_VECTOR
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD,LAGRANGE_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DEPENDENT_VARIABLE,LAGRANGE_VARIABLE
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: SOLVER_MAPPING
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: SOLVER_MATRICES
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: SOLVER_MATRIX
    TYPE(VARYING_STRING) :: dummyError,localError

    NULLIFY(SOLVER_DATA)
    
    ENTERS("SOLVER_VARIABLES_FIELD_UPDATE",err,error,*998)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLVER%SOLVER_FINISHED) THEN
        SOLVER_EQUATIONS=>SOLVER%SOLVER_EQUATIONS
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          SOLVER_MATRICES=>SOLVER_EQUATIONS%SOLVER_MATRICES
          IF(ASSOCIATED(SOLVER_MATRICES)) THEN
            SOLVER_MAPPING=>SOLVER_MATRICES%SOLVER_MAPPING
            IF(ASSOCIATED(SOLVER_MAPPING)) THEN
              DO solver_matrix_idx=1,SOLVER_MATRICES%NUMBER_OF_MATRICES
                SOLVER_MATRIX=>SOLVER_MATRICES%matrices(solver_matrix_idx)%ptr
                IF(ASSOCIATED(SOLVER_MATRIX)) THEN
                  SOLVER_VECTOR=>SOLVER_MATRIX%SOLVER_VECTOR
                  IF(ASSOCIATED(SOLVER_VECTOR)) THEN
                    !Get the solver variables data
                    CALL DistributedVector_DataGet(SOLVER_VECTOR,SOLVER_DATA,err,error,*999)
                    !Loop over the solver variable dofs
                    DO solver_dof_idx=1,SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)%NUMBER_OF_DOFS
                      !Loop over the equations associated with this dof
                      DO equations_idx=1,SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                        & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%NUMBER_OF_EQUATION_DOFS
                        SELECT CASE(SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                          & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%EQUATIONS_TYPES(equations_idx))
                        CASE(SOLVER_MAPPING_EQUATIONS_EQUATIONS_SET)
                          !Equations set dof.
                          DEPENDENT_VARIABLE=>SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                            & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%VARIABLE(equations_idx)%ptr
                          IF(ASSOCIATED(DEPENDENT_VARIABLE)) THEN
                            VARIABLE_TYPE=DEPENDENT_VARIABLE%VARIABLE_TYPE
                            DEPENDENT_FIELD=>DEPENDENT_VARIABLE%FIELD
                            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
                              !Get the dependent field variable dof the solver dof is mapped to
                              variable_dof=SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                                & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%VARIABLE_DOF(equations_idx)
                              variable_coefficient=SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                                & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%VARIABLE_COEFFICIENT(equations_idx)
                              additive_constant=SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                                & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%ADDITIVE_CONSTANT(equations_idx)
                              !Set the dependent field variable dof
                              VALUE=SOLVER_DATA(solver_dof_idx)*variable_coefficient+additive_constant
                              CALL Field_ParameterSetUpdateLocalDOF(DEPENDENT_FIELD,VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                                & variable_dof,VALUE,err,error,*999)
                            ELSE
                              CALL FlagError("Dependent field is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Dependent variable is not associated.",err,error,*999)
                          ENDIF
                        CASE(SOLVER_MAPPING_EQUATIONS_INTERFACE_CONDITION)
                          !Interface condition dof.
                          LAGRANGE_VARIABLE=>SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                           & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%VARIABLE(equations_idx)%ptr
                          IF(ASSOCIATED(LAGRANGE_VARIABLE)) THEN
                            VARIABLE_TYPE=LAGRANGE_VARIABLE%VARIABLE_TYPE
                            LAGRANGE_FIELD=>LAGRANGE_VARIABLE%FIELD
                            IF(ASSOCIATED(LAGRANGE_FIELD)) THEN
                              !Get the dependent field variable dof the solver dof is mapped to
                              variable_dof=SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                                & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%VARIABLE_DOF(equations_idx)
                              variable_coefficient=SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                                & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%VARIABLE_COEFFICIENT(equations_idx)
                              additive_constant=SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                                & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%ADDITIVE_CONSTANT(equations_idx)
                              !Set the dependent field variable dof
                              VALUE=SOLVER_DATA(solver_dof_idx)*variable_coefficient+additive_constant
                              CALL Field_ParameterSetUpdateLocalDOF(LAGRANGE_FIELD,VARIABLE_TYPE,FIELD_VALUES_SET_TYPE, &
                                & variable_dof,VALUE,err,error,*999)
                            ELSE
                              CALL FlagError("Lagrange field is not associated.",err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Lagrange variable is not associated.",err,error,*999)
                          ENDIF
                        CASE DEFAULT
                          localError="The equations type of "//TRIM(NumberToVString(SOLVER_MAPPING% &
                            & SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)%SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)% &
                            & EQUATIONS_TYPES(equations_idx),"*",err,error))//" of equations index "// &
                            & TRIM(NumberToVString(equations_idx,"*",err,error))//" for solver degree-of-freedom "// &
                            & TRIM(NumberToVString(solver_dof_idx,"*",err,error))//" is invalid."
                          CALL FlagError(localError,err,error,*999)
                        END SELECT
                      ENDDO !equations_idx
                    ENDDO !solver_dof_idx
                    IF(DIAGNOSTICS2) THEN
                      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Solver matrix index = ",solver_matrix_idx,err,error,*999)
                      DO solver_dof_idx=1,SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)%NUMBER_OF_DOFS
                        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Solver dof index = ",solver_dof_idx,err,error,*999)
                        DO equations_idx=1,SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                          & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%NUMBER_OF_EQUATION_DOFS
                          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Equations index = ",equations_idx,err,error,*999)
                          variable_dof=SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                            & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%VARIABLE_DOF(equations_idx)
                          variable_coefficient=SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                            & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%VARIABLE_COEFFICIENT(equations_idx)
                          additive_constant=SOLVER_MAPPING%SOLVER_COL_TO_EQUATIONS_COLS_MAP(solver_matrix_idx)% &
                            & SOLVER_DOF_TO_VARIABLE_MAPS(solver_dof_idx)%ADDITIVE_CONSTANT(equations_idx)
                          VALUE=SOLVER_DATA(solver_dof_idx)*variable_coefficient+additive_constant
                          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Variable dof = ",variable_dof,err,error,*999)
                          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Variable coefficient = ",variable_coefficient, &
                              & err,error,*999)
                          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Additive constant = ",additive_constant, &
                              & err,error,*999)
                          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Value = ",VALUE,err,error,*999)
                        ENDDO
                      ENDDO
                    ENDIF
                    !Restore the solver dof data
                    CALL DistributedVector_DataRestore(SOLVER_VECTOR,SOLVER_DATA,err,error,*999)
                    !Start the transfer of the field dofs
                    DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                      EQUATIONS_SET=>SOLVER_MAPPING%EQUATIONS_SETS(equations_set_idx)%ptr
                      IF(ASSOCIATED(EQUATIONS_SET)) THEN
                        DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
                        DO variable_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_VARIABLES
                          VARIABLE_TYPE=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                            & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%VARIABLE_TYPES(variable_idx)
                          CALL Field_ParameterSetUpdateStart(DEPENDENT_FIELD,VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,err,error,*999)
                        ENDDO !variable_idx
                      ELSE
                        CALL FlagError("Equations set is not associated.",err,error,*999)
                      ENDIF
                    ENDDO !equations_set_idx
                    !Finish the transfer of the field dofs
                    DO equations_set_idx=1,SOLVER_MAPPING%NUMBER_OF_EQUATIONS_SETS
                      EQUATIONS_SET=>SOLVER_MAPPING%EQUATIONS_SETS(equations_set_idx)%ptr
                      DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
                      DO variable_idx=1,SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                        & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%NUMBER_OF_VARIABLES
                        VARIABLE_TYPE=SOLVER_MAPPING%EQUATIONS_SET_TO_SOLVER_MAP(equations_set_idx)% &
                          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(solver_matrix_idx)%VARIABLE_TYPES(variable_idx)
                        CALL Field_ParameterSetUpdateFinish(DEPENDENT_FIELD,VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,err,error,*999)
                      ENDDO !variable_idx
                    ENDDO !equations_set_idx
                  ELSE
                    CALL FlagError("Solver vector is not associated.",err,error,*998)
                  ENDIF
                ELSE
                  CALL FlagError("Solver matrix is not associated.",err,error,*998)
                ENDIF
              ENDDO !solver_matrix_idx
            ELSE
              CALL FlagError("Solver matrices solution mapping is not associated.",err,error,*998)
            ENDIF
          ELSE
            CALL FlagError("Solver equations solver matrices are not associated.",err,error,*998)
          ENDIF
        ELSE
          CALL FlagError("Solver solver equations is not associated.",err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Solver has not been finished.",err,error,*998)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*998)
    ENDIF
    
    EXITS("SOLVER_VARIABLES_FIELD_UPDATE")
    RETURN
999 IF(ASSOCIATED(SOLVER_DATA)) CALL DistributedVector_DataRestore(SOLVER_VECTOR,SOLVER_DATA,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVER_VARIABLES_FIELD_UPDATE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_VARIABLES_FIELD_UPDATE
  
  !
  !================================================================================================================================
  !

  !>Finish the creation of solvers.
  SUBROUTINE SOLVERS_CREATE_FINISH(SOLVERS,err,error,*)

    !Argument variables
    TYPE(SOLVERS_TYPE), POINTER :: SOLVERS !<A pointer to the solvers to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: solver_idx
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
   
    ENTERS("SOLVERS_CREATE_FINISH",err,error,*999)

    IF(ASSOCIATED(SOLVERS)) THEN
      IF(SOLVERS%SOLVERS_FINISHED) THEN
        CALL FlagError("Solvers has already been finished.",err,error,*999)
      ELSE        
        CONTROL_LOOP=>SOLVERS%CONTROL_LOOP
        IF(ASSOCIATED(CONTROL_LOOP)) THEN          
          !Finish the solver creation
          IF(ALLOCATED(SOLVERS%SOLVERS)) THEN
            DO solver_idx=1,SOLVERS%NUMBER_OF_SOLVERS
              SOLVER=>SOLVERS%SOLVERS(solver_idx)%ptr
              IF(ASSOCIATED(SOLVER)) THEN
                CALL SOLVER_CREATE_FINISH(SOLVER,err,error,*999)
              ELSE
                CALL FlagError("Solver is not associated.",err,error,*999)
              ENDIF
            ENDDO !solver_idx            
            SOLVERS%SOLVERS_FINISHED=.TRUE.
          ELSE
            CALL FlagError("Solvers solvers is not allocated.",err,error,*999)
          ENDIF
        ELSE
          CALL FlagError("Solvers control loop is not associated.",err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solvers is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVERS_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("SOLVERS_CREATE_FINISH",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVERS_CREATE_FINISH

  !
  !================================================================================================================================
  !

  !>Start the creation of a solvers for the control loop. 
  SUBROUTINE SOLVERS_CREATE_START(CONTROL_LOOP,SOLVERS,err,error,*)

    !Argument variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP !<A pointer to the control loop to create the solvers for
    TYPE(SOLVERS_TYPE), POINTER :: SOLVERS !<On exit, a pointer to the solvers. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("SOLVERS_CREATE_START",err,error,*999)
    
    IF(ASSOCIATED(CONTROL_LOOP)) THEN
      IF(CONTROL_LOOP%CONTROL_LOOP_FINISHED) THEN
        IF(CONTROL_LOOP%NUMBER_OF_SUB_LOOPS==0) THEN
          IF(ASSOCIATED(SOLVERS)) THEN
            CALL FlagError("Solvers is already associated.",err,error,*999)
          ELSE
            NULLIFY(SOLVERS)
            !Initialise the solvers
            CALL SOLVERS_INITIALISE(CONTROL_LOOP,err,error,*999)
            !Return the pointer
            SOLVERS=>CONTROL_LOOP%SOLVERS
          ENDIF
        ELSE
          localError="Invalid control loop setup. The specified control loop has "// &
            & TRIM(NumberToVString(CONTROL_LOOP%NUMBER_OF_SUB_LOOPS,"*",err,error))// &
            & " sub loops. To create solvers the control loop must have 0 sub loops."          
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Control loop has not been finished.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Control loop is not associated.",err,error,*999)
    ENDIF
    
    EXITS("SOLVERS_CREATE_START")
    RETURN
999 ERRORSEXITS("SOLVERS_CREATE_START",err,error)
    RETURN 1
  END SUBROUTINE SOLVERS_CREATE_START
  
  !
  !================================================================================================================================
  !

  !>Destroys the solvers
  SUBROUTINE SOLVERS_DESTROY(SOLVERS,err,error,*)

    !Argument variables
    TYPE(SOLVERS_TYPE), POINTER :: SOLVERS !<A pointer to the solvers to destroy
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables

    ENTERS("SOLVERS_DESTROY",err,error,*999)

    IF(ASSOCIATED(SOLVERS)) THEN
      CALL SOLVERS_FINALISE(SOLVERS,err,error,*999)
    ELSE
      CALL FlagError("Solvers is not associated.",err,error,*999)
    ENDIF
       
    EXITS("SOLVERS_DESTROY")
    RETURN
999 ERRORSEXITS("SOLVERS_DESTROY",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVERS_DESTROY

  !
  !================================================================================================================================
  !

  !>Finalises the solvers and deallocates all memory
  SUBROUTINE SOLVERS_FINALISE(SOLVERS,err,error,*)

    !Argument variables
    TYPE(SOLVERS_TYPE), POINTER :: SOLVERS !<A pointer to the solvers to finalise
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: solver_idx
 
    ENTERS("SOLVERS_FINALISE",err,error,*999)

    IF(ASSOCIATED(SOLVERS)) THEN
      IF(ALLOCATED(SOLVERS%SOLVERS)) THEN
        DO solver_idx=1,SIZE(SOLVERS%SOLVERS,1)
          CALL SOLVER_FINALISE(SOLVERS%SOLVERS(solver_idx)%ptr,err,error,*999)
        ENDDO !solver_idx
        DEALLOCATE(SOLVERS%SOLVERS)
      ENDIF
      DEALLOCATE(SOLVERS)
    ENDIF
       
    EXITS("SOLVERS_FINALISE")
    RETURN
999 ERRORSEXITS("SOLVERS_FINALISE",err,error)
    RETURN 1
  END SUBROUTINE SOLVERS_FINALISE
  
  !
  !================================================================================================================================
  !

  !>Initialises the solvers for a control loop.
  SUBROUTINE SOLVERS_INITIALISE(CONTROL_LOOP,err,error,*)

    !Argument variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP !<A pointer to the control loop to initialise the solvers for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,solver_idx
    TYPE(VARYING_STRING) :: dummyError

    ENTERS("SOLVERS_INITIALISE",err,error,*998)

    IF(ASSOCIATED(CONTROL_LOOP)) THEN
      IF(ASSOCIATED(CONTROL_LOOP%SOLVERS)) THEN
        CALL FlagError("Solvers is already allocated for this control loop.",err,error,*998)
      ELSE
        ALLOCATE(CONTROL_LOOP%SOLVERS,STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate control loop solvers.",err,error,*999)
        CONTROL_LOOP%SOLVERS%CONTROL_LOOP=>CONTROL_LOOP
        CONTROL_LOOP%SOLVERS%SOLVERS_FINISHED=.FALSE.
        CONTROL_LOOP%SOLVERS%NUMBER_OF_SOLVERS=1
        ALLOCATE(CONTROL_LOOP%SOLVERS%SOLVERS(CONTROL_LOOP%SOLVERS%NUMBER_OF_SOLVERS),STAT=err)
        IF(err/=0) CALL FlagError("Could not allocate solvers solvers.",err,error,*999)
        DO solver_idx=1,CONTROL_LOOP%SOLVERS%NUMBER_OF_SOLVERS
          NULLIFY(CONTROL_LOOP%SOLVERS%SOLVERS(solver_idx)%ptr)
          CALL SOLVER_INITIALISE(CONTROL_LOOP%SOLVERS,solver_idx,err,error,*999)
        ENDDO !solver_idx
      ENDIF
    ELSE
      CALL FlagError("Control loop is not associated.",err,error,*998)
    ENDIF
       
    EXITS("SOLVERS_INITIALISE")
    RETURN
999 CALL SOLVERS_FINALISE(CONTROL_LOOP%SOLVERS,dummyErr,dummyError,*998)
998 ERRORSEXITS("SOLVERS_INITIALISE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVERS_INITIALISE
  
 
  !
  !================================================================================================================================
  !

  !>Sets/changes the number of solvers.
  SUBROUTINE SOLVERS_NUMBER_SET(SOLVERS,NUMBER_OF_SOLVERS,err,error,*)

    !Argument variables
    TYPE(SOLVERS_TYPE), POINTER :: SOLVERS !<A pointer to the solvers to set the number for
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_SOLVERS !<The number of solvers to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: solver_idx, OLD_NUMBER_OF_SOLVERS
    TYPE(SOLVER_PTR_TYPE), ALLOCATABLE :: OLD_SOLVERS(:)
    TYPE(VARYING_STRING) :: localError
 
    ENTERS("SOLVERS_NUMBER_SET",err,error,*998)

    IF(ASSOCIATED(SOLVERS)) THEN
      IF(SOLVERS%SOLVERS_FINISHED) THEN
        CALL FlagError("Solvers have already been finished.",err,error,*998)
      ELSE
        IF(NUMBER_OF_SOLVERS>0) THEN
          OLD_NUMBER_OF_SOLVERS=SOLVERS%NUMBER_OF_SOLVERS
          IF(NUMBER_OF_SOLVERS/=OLD_NUMBER_OF_SOLVERS) THEN
            ALLOCATE(OLD_SOLVERS(OLD_NUMBER_OF_SOLVERS),STAT=err)
            IF(err/=0) CALL FlagError("Could not allocate old solvers.",err,error,*999)
            DO solver_idx=1,OLD_NUMBER_OF_SOLVERS
              OLD_SOLVERS(solver_idx)%ptr=>SOLVERS%SOLVERS(solver_idx)%ptr
            ENDDO !solver_idx
            IF(ALLOCATED(SOLVERS%SOLVERS)) DEALLOCATE(SOLVERS%SOLVERS)
            ALLOCATE(SOLVERS%SOLVERS(NUMBER_OF_SOLVERS),STAT=err)
            IF(err/=0) CALL FlagError("Could not allocate solvers.",err,error,*999)
            IF(NUMBER_OF_SOLVERS>OLD_NUMBER_OF_SOLVERS) THEN
              DO solver_idx=1,OLD_NUMBER_OF_SOLVERS
                SOLVERS%SOLVERS(solver_idx)%ptr=>OLD_SOLVERS(solver_idx)%ptr
              ENDDO !solver_idx
              SOLVERS%NUMBER_OF_SOLVERS=NUMBER_OF_SOLVERS
              DO solver_idx=OLD_NUMBER_OF_SOLVERS+1,NUMBER_OF_SOLVERS
                NULLIFY(SOLVERS%SOLVERS(solver_idx)%ptr)
                CALL SOLVER_INITIALISE(SOLVERS,solver_idx,err,error,*999)
              ENDDO !solution_idx
            ELSE
              DO solver_idx=1,NUMBER_OF_SOLVERS
                SOLVERS%SOLVERS(solver_idx)%ptr=>OLD_SOLVERS(solver_idx)%ptr
              ENDDO !solver_idx
              DO solver_idx=NUMBER_OF_SOLVERS+1,OLD_NUMBER_OF_SOLVERS
                CALL SOLVER_FINALISE(OLD_SOLVERS(solver_idx)%ptr,err,error,*999)
              ENDDO !solver_idx
              SOLVERS%NUMBER_OF_SOLVERS=NUMBER_OF_SOLVERS
            ENDIF
          ENDIF
        ELSE
          localError="The specified number of solvers of "//TRIM(NumberToVString(NUMBER_OF_SOLVERS,"*",err,error))// &
            & " is invalid. The number of solvers must be > 0."
          CALL FlagError(localError,err,error,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Solvers is not associated.",err,error,*998)
    ENDIF
       
    EXITS("SOLVERS_NUMBER_SET")
    RETURN
999 IF(ALLOCATED(OLD_SOLVERS)) DEALLOCATE(OLD_SOLVERS)
998 ERRORSEXITS("SOLVERS_NUMBER_SET",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVERS_NUMBER_SET
  
  !
  !================================================================================================================================
  !

  !>Adds a linked solver to the solver. Also sets the solver type for the linked solver, als well as its linking solver.
  SUBROUTINE SOLVER_LINKED_SOLVER_ADD(SOLVER,SOLVER_TO_LINK,SOLV_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the solver to add the linked solver to.
    TYPE(SOLVER_TYPE), POINTER :: SOLVER_TO_LINK !<A pointer the the solver to be linked. 
    INTEGER(INTG), INTENT(IN) :: SOLV_TYPE !<The solver type of the solver to be linked.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    TYPE(SOLVER_PTR_TYPE), ALLOCATABLE, TARGET :: OLD_LINKED_SOLVERS(:)
    INTEGER(INTG) :: solver_idx

    ENTERS("SOLVER_LINKED_SOLVER_ADD",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(ASSOCIATED(SOLVER_TO_LINK)) THEN
        IF(SOLV_TYPE>=1 .AND. SOLV_TYPE<=SOLVER_NUMBER_OF_SOLVER_TYPES) THEN
          !does the solver have already linked solvers?
          IF(SOLVER%NUMBER_OF_LINKED_SOLVERS==0) THEN
            !no - then start the creation of linked solvers
            ALLOCATE(SOLVER%LINKED_SOLVERS(1),STAT=err)
            IF(err/=0) CALL FlagError("Could not allocate linked solvers.",err,error,*999)
            DO solver_idx=1,SOLVER_NUMBER_OF_SOLVER_TYPES
              NULLIFY(SOLVER%LINKED_SOLVER_TYPE_MAP(solver_idx)%ptr)
            ENDDO !solver_idx
            SOLVER%LINKED_SOLVER_TYPE_MAP(SOLV_TYPE)%ptr=>SOLVER_TO_LINK
            SOLVER%LINKED_SOLVERS(1)%ptr=>SOLVER_TO_LINK
            SOLVER%NUMBER_OF_LINKED_SOLVERS=SOLVER%NUMBER_OF_LINKED_SOLVERS+1
          ELSE IF(SOLVER%NUMBER_OF_LINKED_SOLVERS>0.AND.SOLVER%NUMBER_OF_LINKED_SOLVERS<=SOLVER_NUMBER_OF_SOLVER_TYPES) THEN
            !yes, there are already linked solvers
            !check if a solver of the same type has already been linked
            DO solver_idx=1,SOLVER%NUMBER_OF_LINKED_SOLVERS
              IF(SOLVER%LINKED_SOLVERS(solver_idx)%ptr%SOLVE_TYPE==SOLV_TYPE) THEN
                localError="The solver has already a linked solver of type "//TRIM(NumberToVString(SOLV_TYPE, &
                  & "*",err,error))//" attached to it."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ENDDO !solver_idx
            ALLOCATE(OLD_LINKED_SOLVERS(SOLVER%NUMBER_OF_LINKED_SOLVERS),STAT=err)
            IF(err/=0) CALL FlagError("Could not old linked solvers.",err,error,*999)
            DO solver_idx=1,SOLVER%NUMBER_OF_LINKED_SOLVERS
              OLD_LINKED_SOLVERS(solver_idx)%ptr=>SOLVER%LINKED_SOLVERS(solver_idx)%ptr
            ENDDO
            DEALLOCATE(SOLVER%LINKED_SOLVERS)
            ALLOCATE(SOLVER%LINKED_SOLVERS(SOLVER%NUMBER_OF_LINKED_SOLVERS+1),STAT=err)
            IF(err/=0) CALL FlagError("Could not new linked solvers.",err,error,*999)
            DO solver_idx=1,SOLVER%NUMBER_OF_LINKED_SOLVERS
              SOLVER%LINKED_SOLVERS(solver_idx)%ptr=>OLD_LINKED_SOLVERS(solver_idx)%ptr
            ENDDO
            SOLVER%LINKED_SOLVERS(SOLVER%NUMBER_OF_LINKED_SOLVERS+1)%ptr=>SOLVER_TO_LINK
            SOLVER%LINKED_SOLVER_TYPE_MAP(SOLV_TYPE)%ptr=>SOLVER_TO_LINK
            SOLVER%NUMBER_OF_LINKED_SOLVERS=SOLVER%NUMBER_OF_LINKED_SOLVERS+1
            DEALLOCATE(OLD_LINKED_SOLVERS)
          ELSE
            localError="The number of linked solvers is "//TRIM(NumberToVString(SOLVER%NUMBER_OF_LINKED_SOLVERS,"*",ERR, &
              & ERROR))//" but should be between 0 and "//TRIM(NumberToVString(SOLVER_NUMBER_OF_SOLVER_TYPES,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
          !set the solver type for the linked solver
          SOLVER%LINKED_SOLVER_TYPE_MAP(SOLV_TYPE)%ptr%SOLVE_TYPE=SOLV_TYPE
          !set the linking solver for the linked solver
          SOLVER%LINKED_SOLVER_TYPE_MAP(SOLV_TYPE)%ptr%LINKING_SOLVER=>SOLVER
        ELSE
          localError="The specified solver type is "//TRIM(NumberToVString(SOLV_TYPE,"*",err,error))//&
            & " but should be between 1 and "//TRIM(NumberToVString(SOLVER_NUMBER_OF_SOLVER_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("The solver to link is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF

    EXITS("SOLVER_LINKED_SOLVER_ADD")
    RETURN
999 ERRORSEXITS("SOLVER_LINKED_SOLVER_ADD",err,error)
    RETURN 1
  END SUBROUTINE SOLVER_LINKED_SOLVER_ADD

  !
  !================================================================================================================================
  !

  !>Adds a linked solver to the solver. Also sets the solver type for the linked solver, als well as its linking solver.
  SUBROUTINE SOLVER_LINKED_SOLVER_REMOVE(SOLVER,SOLV_TYPE,err,error,*)

    !Argument variables
    TYPE(SOLVER_TYPE), POINTER :: SOLVER !<A pointer to the solver to add the linked solver to.
    INTEGER(INTG), INTENT(IN) :: SOLV_TYPE !<The solver type of the solver to be linked.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: solver_idx

    ENTERS("SOLVER_LINKED_SOLVER_REMOVE",err,error,*999)

    IF(ASSOCIATED(SOLVER)) THEN
      IF(SOLV_TYPE>=1 .AND. SOLV_TYPE<=SOLVER_NUMBER_OF_SOLVER_TYPES) THEN
        !Check if there is any linked solvers
        IF(SOLVER%NUMBER_OF_LINKED_SOLVERS>0.AND.SOLVER%NUMBER_OF_LINKED_SOLVERS<=SOLVER_NUMBER_OF_SOLVER_TYPES) THEN
          !Check if a solver of the same type has already been linked
          DO solver_idx=1,SOLVER%NUMBER_OF_LINKED_SOLVERS
            IF(SOLVER%LINKED_SOLVERS(solver_idx)%ptr%SOLVE_TYPE==SOLV_TYPE) THEN
              DEALLOCATE(SOLVER%LINKED_SOLVERS)
              SOLVER%NUMBER_OF_LINKED_SOLVERS=SOLVER%NUMBER_OF_LINKED_SOLVERS-1
            ENDIF
          ENDDO !solver_idx
        ENDIF
      ELSE
        localError="The specified solver type is "//TRIM(NumberToVString(SOLV_TYPE,"*",err,error))//&
          & " but should be between 1 and "//TRIM(NumberToVString(SOLVER_NUMBER_OF_SOLVER_TYPES,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Solver is not associated.",err,error,*999)
    ENDIF

    EXITS("SOLVER_LINKED_SOLVER_REMOVE")
    RETURN
999 ERRORSEXITS("SOLVER_LINKED_SOLVER_REMOVE",err,error)
    RETURN 1
    
  END SUBROUTINE SOLVER_LINKED_SOLVER_REMOVE



  !
  !================================================================================================================================
  !

END MODULE SOLVER_ROUTINES

!
!================================================================================================================================
!

!>Called from the PETSc TS solvers to monitor the dynamic solver
SUBROUTINE SOLVER_TIME_STEPPING_MONITOR_PETSC(ts,STEPS,TIME,X,CTX,ERR)

  USE BaseRoutines
  USE CmissPetscTypes
  USE ISO_VARYING_STRING
  USE KINDS
  USE SOLVER_ROUTINES
  USE SolverAccessRoutines
  USE STRINGS
  USE TYPES

  IMPLICIT NONE

  !Argument variables
  TYPE(PetscTSType), INTENT(INOUT) :: ts !<The PETSc ts type
  INTEGER(INTG), INTENT(INOUT) :: STEPS !<The iteration number
  REAL(DP), INTENT(INOUT) :: TIME !<The current time
  TYPE(PetscVecType), INTENT(INOUT) :: X !<The current iterate
  TYPE(SOLVER_TYPE), POINTER :: CTX !<The passed through context
  INTEGER(INTG), INTENT(INOUT) :: err !<The error code
  !Local Variables
  TYPE(DAE_SOLVER_TYPE), POINTER :: DAE_SOLVER
  TYPE(VARYING_STRING) :: error,localError

  IF(ASSOCIATED(CTX)) THEN
    IF(CTX%SOLVE_TYPE==SOLVER_DAE_TYPE) THEN
      DAE_SOLVER=>CTX%DAE_SOLVER

      CALL SOLVER_TIME_STEPPING_MONITOR(DAE_SOLVER,STEPS,TIME,err,error,*999)

    ELSE
      localError="Invalid solve type. The solve type of "//TRIM(NumberToVString(CTX%SOLVE_TYPE,"*",err,error))// &
        & " does not correspond to a differntial-algebraic equations solver."
      CALL FlagError(localError,err,error,*999)
    ENDIF
  ELSE
    CALL FlagError("Solver context is not associated.",err,error,*999)
  ENDIF

  RETURN
999 CALL WriteError(err,error,*998)
998 CALL FlagWarning("Error monitoring differential-algebraic equations solve.",err,error,*997)
997 RETURN
  
END SUBROUTINE SOLVER_TIME_STEPPING_MONITOR_PETSC


!
!================================================================================================================================
!
!>Called from the PETSc SNES solvers to monitor the Newton nonlinear solver
SUBROUTINE SOLVER_NONLINEAR_MONITOR_PETSC(snes,ITS,NORM,CTX,ERR)

  USE BaseRoutines
  USE CmissPetscTypes
  USE ISO_VARYING_STRING
  USE KINDS
  USE SOLVER_ROUTINES
  USE SolverAccessRoutines
  USE STRINGS
  USE TYPES

  IMPLICIT NONE

  !Argument variables
  TYPE(PetscSnesType), INTENT(INOUT) :: snes !<The PETSc SNES type
  INTEGER(INTG), INTENT(INOUT) :: ITS !<The iteration number
  REAL(DP), INTENT(INOUT) :: NORM !<The residual norm
  TYPE(SOLVER_TYPE), POINTER :: CTX !<The passed through context
  INTEGER(INTG), INTENT(INOUT) :: err !<The error code
  !Local Variables
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NONLINEAR_SOLVER
  TYPE(VARYING_STRING) :: error,localError

  IF(ASSOCIATED(CTX)) THEN
    IF(CTX%SOLVE_TYPE==SOLVER_NONLINEAR_TYPE) THEN
      NONLINEAR_SOLVER=>CTX%NONLINEAR_SOLVER

      CALL SOLVER_NONLINEAR_MONITOR(NONLINEAR_SOLVER,ITS,NORM,err,error,*999)

    ELSE
      localError="Invalid solve type. The solve type of "//TRIM(NumberToVString(CTX%SOLVE_TYPE,"*",err,error))// &
        & " does not correspond to a nonlinear solver."
      CALL FlagError(localError,err,error,*999)
    ENDIF
  ELSE
    CALL FlagError("Solver context is not associated.",err,error,*999)
  ENDIF

  RETURN
999 CALL WriteError(err,error,*998)
998 CALL FlagWarning("Error monitoring nonlinear solve.",err,error,*997)
997 RETURN
  
END SUBROUTINE SOLVER_NONLINEAR_MONITOR_PETSC
